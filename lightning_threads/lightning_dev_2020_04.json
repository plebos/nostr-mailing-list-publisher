[
    {
        "title": "[Lightning-dev] Proof-of-closure as griefing attack mitigation",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-01T06:19:03",
                "message_text_only": "Introduction\n============\n\nGiven the fact that contracts on offchain protocols need to be enforceable onchain as well, timelocks involved in multi-hop payments are measured in blocks.\nThis is because the blockchain can only (third-party-verifiably) enforce timeouts in units of entire blocks.\nThis leads to very long timeouts for payment delivery, thus multi-hop offchain payment attempts can be, deliberately or accidentally, be in a \"pending\" state up to the very large timeouts involved.\n\nDeliberately setting up a multi-hop payment such that it will be in a \"pending\" state for long periods of time is colloquially known as a \"griefing attack\".\nIn this article, we assess various proposed solutions to mitigate the effects of griefing attacks, and propose a particular solution, proof-of-closure, as well, that requires significant changes to the update state machine.\n\nDigression: Why Grief?\n======================\n\nBefore embarking on our investigation for solutions to the griefing problem, we should first wonder if griefing is, in fact, a problem.\n\nThis brings up the question of: why would anybody grief at all?\n\nHumans, like cats and other less-sapient pieces of walking meat, often find enjoyment in causing the suffering of others for no immediate direct gain to themselves, as a public demonstration of dominance over those they make suffer (aka \"shits and giggles\", which, if executed correctly, can lead to eventual direct gains to themselves or their progeny or relatives or allies, but such details are often outside the ken of the very beings who execute such survival strategies: brains are pieces of meat that have been hacked to act as action-reaction engines, but are not sophisticated enough to execute as pure rationality engines at all times).\nFortunately, in the Bitcoin world, only purely rational beings of pure selfishness can exist in the long run, thus we can neglect such motivations as mere noise.\n\nFirst, let us investigate *how* griefing attacks can be performed.\n\n* An intermediate node in a multi-hop attempt can delay forwarding or failing an incoming HTLC.\n* A final node in a payment attempt can delay claiming an incoming HTLC.\n\nLet us consider a purely rational intermediate node of pure selfishness:\n\n* If it forwards as soon as possible, it can earn fees, and also speed up the release of the HTLC-locked funds so that they can reuse those funds as liquidity for further payment attempts.\n* Thus, delaying an HTLC is not selfishly-rational for an intermediate node.\n\nThus, for an intermediate node, it seems there is no selfishly-rational motivation to execute a griefing attack on an arbitrary payment attempt.\nWe can then conclude that an intermediate that delays a payment would do so, not of its own rational self-interest, but as an accident, such as an unforeseen connectivity or power failure.\n\nHowever, things are different when we consider a non-arbitrary payment.\nSuppose a node were to make a payment attempt to itself, and deliberately delay claiming this self-payment.\nThis lets any single node, *who happens to own large liquidity*, to lock up the liquidity of other nodes.\n\nThe motivation to lock up the liquidity of other nodes is to *eliminate competition*.\nSuppose we have a network as below:\n\n    A -- B -- C\n      \\     /\n       \\   /\n        \\ /\n         E\n\nWhen A and C want to transact with one another, they may choose to route via either B or E.\nB and E are therefore competitors in the business of forwarding payments.\n\nBut suppose E has much larger channels AE and CE than the channels of AB and CB.\nFor example, suppose E has 100mBTC perfectly-balanced channels while B has only 10mBTC perfectly-balanced channels, as all things should be in simplified models of reality.\nE can then \"take out the competition\" by making a 5mBTC self-payment along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing to claim the payment, tying up all the liquidity of the channels of B.\nBy doing so, it can ensure that A and C will always fail to pay via B, even if they wish to transact in amounts less than 5mBTC.\nE thereby eliminates B as a competitor.\n\nThis demonstrates that griefing attacks will be motivated, such that such attacks will be performed by payers and payees *against intermediate nodes*.\nIntermediate nodes have no motivation to attack payers and payees (those are their potential customers in the business of forwarding payments, and attacking potential customers is bad business: such attacking intermediate nodes will be removed economically in the long run).\nHowever, payers and payees can become motivated to attack intermediate nodes, if the \"payer\" and \"payee\" are actually competitor intermediate nodes.\n\n(We can observe that this is always a possibility even outside of Lightning: a service or product provider has no incentive to attack its customers (\"the customer is always right\"), but have an incentive to *pretend* to be a customer of a competitor and attack them.)\n\nWe will keep this fact in mind: active griefing attacks are attacks *on* intermediate nodes, not *by* intermediate nodes, because there is no economic incentive for intermediate nodes to attack their customers.\n\nPrevious Proposed Solutions\n===========================\n\nTime-Spent Reporting\n--------------------\n\nAt each channel along the route, the time spent by a node to handle its forwarding is recorded, and reported upstream in the route.\n\nUnfortunately, this solution protects payers from intermediate nodes and payees: it does not protect intermediate nodes from colluding payers and payees.\nEven if an intermediate node knows that a particular node is consistently slow via a previous time-spent report, it will not be able, with our current onion routing, determine if an onion packet it just received will or will not go through the known-slow node.\nThus, an intermediate node would not be able to defend against distant payees that, with a colluding payer, will not claim a particular payment.\n\nAs we have established, an active griefing atttack will never be deliberately performed by a selfishly-rational intermediate node.\nThus, this solution protects against the wrong thing: it protects payers against slow/unreliable intermediate nodes, it does not protect intermediate nodes against malicious payer/payee collusions.\nIt protects only against intermediate nodes that inadvertently go offline during forwarding, but such nodes will inevitably lose out on the forwarding market anyway, and will disappear in the long run.\n\nUp-Front Payment\n----------------\n\nPayers pay for an attempt, not just the successful completion of an attempt.\n\nA variation on this is that the payer (or payee) continuously pays as long as the payment is pending.\nFurther variations include paying by other means, such as just locking funds or paying with proof-of-work.\n\nWhile it certainly erects economic barriers against payer/payee collusions attacking intermediate nodes, it *also* erects economic barriers against normal, non-malicious payments.\n\nWe can consider that economic barriers against non-malicious, low-value, high-frequency payments (\"micropayments\") may be enough that such payments become infeasible if we impose up-front payment for mere attempts.\nThus, while this solution is certainly something we can consider, we must be reluctant to use it due to its up-front, strict-evaluation behavior.\n\nProof-Of-Closure\n================\n\nObserving the above, we want the properties for a \"good\" solution to griefing attacks to be:\n\n* It should protect intermediate nodes against payer/payee collusions.\n* It should only come into play upon detection of an attack.\n\nWe now present proof-of-closure, which (we hope) has the above properties.\n\nWe can consider instead a softer timeout, distinct from the HTLC block-based timeout.\nThis softer timeout is measurable in fractions of a second, e.g. units of 0.1 seconds.\n\nEach node on the network advertises, in addition to a block-based `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\nFurther, each invoice contains, in addition to a block-based `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n\nThus, there are two timeouts:\n\n* The current \"hard\" block-based timeout that is enforceable onchain.\n* A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n\nThe soft timeout, as mentioned, is not enforceable onchain.\nInstead, enforcement of the soft timeout *is* the act of putting the channel state onchain.\n\nNow, for the current \"hard\" block-based timeout, we already have a reaction.\nIf the HTLC \"hard\" timeout is approaching:\n\n* Drop the channel onchain and enforce the hard timeout onchain to reclaim the funds in the HTLCs.\n* Wait for the onchain action to be deeply resolved (either timelock or hashlock branch is confirmed deeply) and report the result (success or fail) upstream.\n\nWhat happens if the \"soft\" timeout is violated?\n\n* Drop the channel onchain.\n* Report the channel closure upstream.\n\nThe \"hard\" timeout is cancelled in any of these two conditions:\n\n* A success is reported via `update_fulfill_htlc`, OR,\n* A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel.\n\nThe \"soft\" timeout is cancelled in any of these three conditions, the first two of which are the same as above:\n\n* A success is reported via `update_fulfill_htlc`, OR,\n* A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel, OR\n* A channel closure is reported.\n\nLet us fill this in more detail.\n\nSuppose we have a payment route A->B->C->E.\n\nBoth the \"hard\" block timeouts and the \"soft\" second timeouts decrement monotonically at each hop.\nThus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n\n* Suppose E then delays claiming the payment and violates the \"soft\" timeout.\n* C then drops the CE channel onchain.\n* C reports, before its own timeout (slightly larger than the timeout imposed on E), the closing of the channel CE, to B.\n* B validates this report, and if valid, propagates the report to A.\n* A validates this report, and if valid, accepts that the payment will be \"stuck\" for up to the hard timeout it imposed on B.\n\nC has to report back to B in order to prevent B from closing the BC channel, and B has to report back to A in order to prevent A from closing the AB channel.\nThe decrementing seconds-unit timeouts are needed for each hop, for the same reason that decrementing block-unit timeouts are needed.\n\nSince E is motivated to attack intermediate nodes because it wants to redirect payment forwards through itself rather than its competitotrs, having one of its channels closed (which prevents it from being used for forwarding) is directly opposed to its end goal of getting more money, thus, we can believe the action of closing a channel involved in a griefing attack is sufficient disincentive.\n\nThe major drawback is that enforcement of the soft timeout *is* a channel closure, which is generally a negative for the network.\nThis is not a remote attack vector, since a node can only trigger this closure if it is able to stall the fulfillment or failure of an HTLC on a channel, which generally means the node triggering this closure can only do so for its own channels (or it is able to, via a separate mechanism, remotely crash a different node).\n\nProving Channel Closes\n----------------------\n\nWhat C *really* needs to prove is that:\n\n* It is *willing* to close a channel due to a violation of the soft timeout.\n* The channel it is willing to close was, in fact, involved in the same payment attempt.\n\nWith the above, B can believe that C was innocent of wrongdoing, because:\n\n* C would only be wiling to close a channel in case of a protocol violation, in this case, a violation of the soft timeout.\n* The channel it closed was closed because of this payment attempt, and not because of another payment attempt, or some other unrelated channel being unilaterally closed.\n\nFirst, what C needs to prove is *NOT*, in fact, actual channel closure: it needs to prove a *willingness* to close a channel.\nThus, it does not require the channel to actually be *closed* yet, i.e. it does not have to wait for onchain activity that the channel closure is in a mempool and is confirmed deeply onchain etc etc.\n\nThus, to prove a *willingness to close* rather than an actual close, C can provide the unilateral close of the channel CE.\nThe act of unilaterally closing a channel is the publication of the transaction(s) making up the unilateral close.\nThus, if C is *willing* to close the channel, it is willing to publish the transaction(s) involved, and thus, providing the unilateral close to B and further upstream, shows a willingness to close the channel.\n\nB then validates the provided proof-of-closure by checking that the unilateral close transaction is either onchain, in the mempool, or that it spends a TXO that is not currently spent by another transaction.\nIn the case the unilateral close transaction is not confirmed and in the mempool, B can speed up its propagation on the Bitcoin layer by putting it in its own mempool as well --- after all, C is willing to close the channel to exonerate itself and punish the actual culprit, and B putting the unilateral close in its own mempool can only help C in what it is willing to do.\n\nSecondly, C needs to prove that the channel it is willing to close involves the payment attempt, and is not some other channel closure that it is attempting to use to fulfill its own soft timeout.\nSince the unilateral close transaction *is* the proof-of-closure, B (and A) can inspect the transaction outputs and see (with some additional data from C) that one of the outputs is to an HTLC that matches the payment hash.\n\nThus, B (and A) can believe that the proof-of-closure proves that whoever is presenting it is free of wrongdoing, as whoever is actually causing the delay has been punished (by someone being willing to close a channel with the culprit), and that the proof-of-closure commits to this particular payment attempt and no other (because it commits to a particular payment hash).\n\nFurther, if CE is closed by E dropping it onchain rather than C, C will still be able to fulfill its own soft timeout by taking the closing transaction from E, which should still contain the HTLC.\nIndeed, neither A nor B will particularly care (nor need to know) who dropped the channel onchain, or (for A) that the channel participants are C and E.\n\nUpdate State Shenanigans\n------------------------\n\nBitcoin update mechanisms are complicated things, and it may be possible for an attacking payee E to fool around with the update state machine to make it difficult for C to report a willingness to close CE.\n\nIn particular, I quote here the relevant passages from `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update mechanism:\n\n> Thus each update traverses through the following states:\n>\n> 1. pending on the receiver\n> 2. in the receiver's latest commitment transaction\n> 3. ... and the receiver's previous commitment transaction has been revoked,\n>    and the update is pending on the sender\n> 4. ... and in the sender's latest commitment transaction\n> 5. ... and the sender's previous commitment transaction has been revoked\n\nThe payee E is the \"receiver\" in this context.\n\nIn this case, once the update has reached step 2, then E has a commitment transaction that it can put onchain, that contains an HTLC it can claim.\n>From this step onward, C cannot send a failure (i.e. it cannot send back an `update_fail_htlc`) back to B, because E could drop its latest commitment onchain and claim the HTLC onchain.\n\nHowever, until step 4, C does not have a unilateral close containing the HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that refers to the payment.\n\nThus, between steps 2 to 4, C cannot safely respond to its own soft timeout.\nC cannot respond with a failure, as E could then drop its latest commitment transaction onchain and claim the payment from C, and extract money from C that way.\nC also cannot respond with a proof-of-closure, as it does not have a transaction that it can use to provide this proof.\n\nThe best that C can do would be to impose an even shorter timeout between steps 2 and 4 above, and to drop its current commitment transaction (which does not contain the HTLC yet and thus does not constitute a valid proof-of-closure) onchain.\nIn between the time it drops the commitment transaction and its own incoming soft timeout, there is a chance, however small, that this transaction will be confirmed, and the channel will (with high probability) settle in a state where the HTLC is not instantiated, thus C can safely fail its incoming HTLC (not show a proof-of-closure, since that is not possible for C to do) without risk of loss, just prior to its own soft timeout.\n\nOf course, C is still at risk here: E could collude with miners via a side-channel fee offer to confirm its commitment transaction with the HTLC present, and ensure that C is liable for the HTLC value.\n\nWith Decker-Russell-Osuntokun, we can remove this risk by requiring a ritual as follows:\n\n1.  C requests exclusive access to update their single shared state.\n  * This can be done via a variety of sub-protocols, including a fair coin toss in case of near-simultaneous requests for exclusive locks on both sides.\n2.  C provides the details of the new HTLC to E.\n3.  C and E generate the new state transaction and exchange signatures for it.\n4.  C and E generate (without signing) the new update transaction.\n5.  E provides the signature (or share of signature, if MuSig) for the new update transaction to C.\n6.  C provides the signature for the new update transaction to E, which releases the exclusive lock on the shared state atomically with the finalization of the new update transaction.\n\nPrior to step 5, C can simply fail the incoming HTLC from B in case its own soft timeout is near.\nEven if E performs step 5 after C has already failed the incoming HTLC from B, C can simply not perform step 6 and drop the channel onchain with the previous update and state transactions.\n\nWith Poon-Dryja, we will have to rearrange the order in which we perform things, effectively adding an extra communications turnaround between the participants.\nSpecifically, the order would have to be revised to:\n\n> 1. pending on the sender\n> 2. in the sender's latest commitment transaction\n> 3. ... and the sender's previous commitment transaction has been revoked,\n>    and the update is pending on the receiver\n> 4. ... and in the receiver's latest commitment transaction\n> 5. ... and the receiver's previous commitment transaction has been revoked\n\nThis allows the sender (C in our context) to provide a proof-of-closure after step 2, and before step 2, C can safely return a failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it can still use the previous commitment that still has no HTLC).\n\nOf course, this change will require redesigning the update state machine, increasing the number of communication turnarounds, and creating a subtle incompatbility when transitioning a payment from a hop that knows only the old update state machine to a hop that knows the new update state machine.\n\nPurely Falsified Proof-Of-Closure\n---------------------------------\n\nOf course, the attacking node E might want to create a false proof-of-closure.\nE can do this by simulating a Lightning channel: lock an amount of funds in a 2-of-2 (where E controls both keys), then spend it in a set of transactions mimicking the unilateral close.\n\nWe observe, however, that the overhead of simulating a Lightning channel is the same as the overhead of actually creating and closing a Lightning channel.\nSince the punishment of proof-of-closure is to force attackers to have their channels closed, we can consider that this simulation of a channel open and close is sufficient as well.\n\nFuture-Proofing\n---------------\n\nThis sketch of proof-of-closure can be used for any update mechanism:\n\n* With Poon-Dryja, C can use its own commitment transaction as the proof-of-closure.\n* With Decker-Wattenhofer, C can give all the offchain transactions up to the last stage in the multi-stage decrementing-`nSequence` mechanism.\n* With Deckker-Russell-Osuntokun, C can give the latest update and state trnsaction.\n\nBasically, we expect that for now, and in the future, any update mechanism worth consideration will have a concept of \"unilateral close\" where a channel can be dropped onchain, using data that only one of the channel participants holds.\n\nSuch a unilateral close will be a sequence of one or more valid transactions, terminating in a transaction containing an HTLC-like contract in one of its outputs.\n\nThus, to validate the unilateral close, it is only required to validate all the transactions contained in the proof-of-closure, and see that the last transaction has an HTLC output.\n\nThe limitations are thus:\n\n* The acceptable forms of HTLC would need to be agreed-upon by the entire network.\n* Implementations would need to be able to assess, in a Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n\nPayment Decorrelation and Payment Points\n----------------------------------------\n\nOf course, having a single payment hash for the entire payment attempt is a privacy loss, which we intend to fix in the near future by using payment points, and adding a blinding scalar at each hop, aka. payment decorrelation.\n\nThus, in the future, there will not be any HTLC, but instead a PTLC.\nFurther, the payment point at each hop will be changed at each hop, in order to prevent decorrelation.\n\nThus, C needs to provide proofs:\n\n* That an apparent singlesig on the unilateral close output is in fact a PTLC.\n  C needs to provide:\n  * A target point P.\n  * A partial signature that would spend that singlesig for a particular sighash.\n  * An adaptor signature which, with knowledge of the completed signature, adaptor signature, and sighash message, would have revealed the scalar behind P.\n* That the PTLC belongs to the same payment attempt as what B offered to C.\n  C needs to provide:\n  * The C-only blinding factor that is the difference between the payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n\nThen, when B needs to propagate the proof-of-closure back to A, B simply adds its own blinding factor to the reported blinding factor, in order to convince A that this is the same payment attempt.\n\nAs we have brought up privacy, we observe that, when this mechanism triggers, there is a mild privacy loss, in that intermediate nodes now know some channel closure that is related to this payment, and can thus determine the exact path that the payment attempt went through, at least until the channel being closed.\nHowever, proof-of-closure is only propagated in case of violation of the soft timeout, so for normal non-malicious payments, proof-of-closure does not cause any privacy loss."
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-04-01T18:07:58",
                "message_text_only": "Hi ZmnSCPxj and list,\n\nLove the idea! I have a couple questions though:\n\nI'm not convinced that \"Purely Falsified Proof-Of-Closure\" aren't\neffective. Consider a similar network to the one you described where we\nhave channels A - B - C and A - E - C but where we add a \"fake\" channel E -\nE'. Now if the attacker sets up a payment from E to E' using the route E -\nC - B - A - E - E', then the attacker can successfully lock up all of B's\nchannels (as is desirable to get rid of competition) and also generate a\nfalse proof of closure for the E - E' channel. Even if this false proof\n(which is a commitment tx) ends up being published on chain, E has lost no\nability to route and has successfully made B unable to route between A and\nC. If my understanding of the proposal is correct, and it may not be, then\nthe punishment for grieving payments is the threat of closing channels that\nwould benefit from the grieving attack. But adding a new channel on the end\nto be closed seems to invalidate this punishment?\n\nA second question I have is if you think that it would be advisable to use\nup-front payments (pay for attempt, not just success) on payments with\nabnormally high soft timeouts? If all this works, this combination seems to\nbe a way to enable hodl invoices under the proof of closure proposal.\n\nBest,\nNadav\n\nOn Wed, Apr 1, 2020 at 1:19 AM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Introduction\n> ============\n>\n> Given the fact that contracts on offchain protocols need to be enforceable\n> onchain as well, timelocks involved in multi-hop payments are measured in\n> blocks.\n> This is because the blockchain can only (third-party-verifiably) enforce\n> timeouts in units of entire blocks.\n> This leads to very long timeouts for payment delivery, thus multi-hop\n> offchain payment attempts can be, deliberately or accidentally, be in a\n> \"pending\" state up to the very large timeouts involved.\n>\n> Deliberately setting up a multi-hop payment such that it will be in a\n> \"pending\" state for long periods of time is colloquially known as a\n> \"griefing attack\".\n> In this article, we assess various proposed solutions to mitigate the\n> effects of griefing attacks, and propose a particular solution,\n> proof-of-closure, as well, that requires significant changes to the update\n> state machine.\n>\n> Digression: Why Grief?\n> ======================\n>\n> Before embarking on our investigation for solutions to the griefing\n> problem, we should first wonder if griefing is, in fact, a problem.\n>\n> This brings up the question of: why would anybody grief at all?\n>\n> Humans, like cats and other less-sapient pieces of walking meat, often\n> find enjoyment in causing the suffering of others for no immediate direct\n> gain to themselves, as a public demonstration of dominance over those they\n> make suffer (aka \"shits and giggles\", which, if executed correctly, can\n> lead to eventual direct gains to themselves or their progeny or relatives\n> or allies, but such details are often outside the ken of the very beings\n> who execute such survival strategies: brains are pieces of meat that have\n> been hacked to act as action-reaction engines, but are not sophisticated\n> enough to execute as pure rationality engines at all times).\n> Fortunately, in the Bitcoin world, only purely rational beings of pure\n> selfishness can exist in the long run, thus we can neglect such motivations\n> as mere noise.\n>\n> First, let us investigate *how* griefing attacks can be performed.\n>\n> * An intermediate node in a multi-hop attempt can delay forwarding or\n> failing an incoming HTLC.\n> * A final node in a payment attempt can delay claiming an incoming HTLC.\n>\n> Let us consider a purely rational intermediate node of pure selfishness:\n>\n> * If it forwards as soon as possible, it can earn fees, and also speed up\n> the release of the HTLC-locked funds so that they can reuse those funds as\n> liquidity for further payment attempts.\n> * Thus, delaying an HTLC is not selfishly-rational for an intermediate\n> node.\n>\n> Thus, for an intermediate node, it seems there is no selfishly-rational\n> motivation to execute a griefing attack on an arbitrary payment attempt.\n> We can then conclude that an intermediate that delays a payment would do\n> so, not of its own rational self-interest, but as an accident, such as an\n> unforeseen connectivity or power failure.\n>\n> However, things are different when we consider a non-arbitrary payment.\n> Suppose a node were to make a payment attempt to itself, and deliberately\n> delay claiming this self-payment.\n> This lets any single node, *who happens to own large liquidity*, to lock\n> up the liquidity of other nodes.\n>\n> The motivation to lock up the liquidity of other nodes is to *eliminate\n> competition*.\n> Suppose we have a network as below:\n>\n>     A -- B -- C\n>       \\     /\n>        \\   /\n>         \\ /\n>          E\n>\n> When A and C want to transact with one another, they may choose to route\n> via either B or E.\n> B and E are therefore competitors in the business of forwarding payments.\n>\n> But suppose E has much larger channels AE and CE than the channels of AB\n> and CB.\n> For example, suppose E has 100mBTC perfectly-balanced channels while B has\n> only 10mBTC perfectly-balanced channels, as all things should be in\n> simplified models of reality.\n> E can then \"take out the competition\" by making a 5mBTC self-payment along\n> E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing\n> to claim the payment, tying up all the liquidity of the channels of B.\n> By doing so, it can ensure that A and C will always fail to pay via B,\n> even if they wish to transact in amounts less than 5mBTC.\n> E thereby eliminates B as a competitor.\n>\n> This demonstrates that griefing attacks will be motivated, such that such\n> attacks will be performed by payers and payees *against intermediate nodes*.\n> Intermediate nodes have no motivation to attack payers and payees (those\n> are their potential customers in the business of forwarding payments, and\n> attacking potential customers is bad business: such attacking intermediate\n> nodes will be removed economically in the long run).\n> However, payers and payees can become motivated to attack intermediate\n> nodes, if the \"payer\" and \"payee\" are actually competitor intermediate\n> nodes.\n>\n> (We can observe that this is always a possibility even outside of\n> Lightning: a service or product provider has no incentive to attack its\n> customers (\"the customer is always right\"), but have an incentive to\n> *pretend* to be a customer of a competitor and attack them.)\n>\n> We will keep this fact in mind: active griefing attacks are attacks *on*\n> intermediate nodes, not *by* intermediate nodes, because there is no\n> economic incentive for intermediate nodes to attack their customers.\n>\n> Previous Proposed Solutions\n> ===========================\n>\n> Time-Spent Reporting\n> --------------------\n>\n> At each channel along the route, the time spent by a node to handle its\n> forwarding is recorded, and reported upstream in the route.\n>\n> Unfortunately, this solution protects payers from intermediate nodes and\n> payees: it does not protect intermediate nodes from colluding payers and\n> payees.\n> Even if an intermediate node knows that a particular node is consistently\n> slow via a previous time-spent report, it will not be able, with our\n> current onion routing, determine if an onion packet it just received will\n> or will not go through the known-slow node.\n> Thus, an intermediate node would not be able to defend against distant\n> payees that, with a colluding payer, will not claim a particular payment.\n>\n> As we have established, an active griefing atttack will never be\n> deliberately performed by a selfishly-rational intermediate node.\n> Thus, this solution protects against the wrong thing: it protects payers\n> against slow/unreliable intermediate nodes, it does not protect\n> intermediate nodes against malicious payer/payee collusions.\n> It protects only against intermediate nodes that inadvertently go offline\n> during forwarding, but such nodes will inevitably lose out on the\n> forwarding market anyway, and will disappear in the long run.\n>\n> Up-Front Payment\n> ----------------\n>\n> Payers pay for an attempt, not just the successful completion of an\n> attempt.\n>\n> A variation on this is that the payer (or payee) continuously pays as long\n> as the payment is pending.\n> Further variations include paying by other means, such as just locking\n> funds or paying with proof-of-work.\n>\n> While it certainly erects economic barriers against payer/payee collusions\n> attacking intermediate nodes, it *also* erects economic barriers against\n> normal, non-malicious payments.\n>\n> We can consider that economic barriers against non-malicious, low-value,\n> high-frequency payments (\"micropayments\") may be enough that such payments\n> become infeasible if we impose up-front payment for mere attempts.\n> Thus, while this solution is certainly something we can consider, we must\n> be reluctant to use it due to its up-front, strict-evaluation behavior.\n>\n> Proof-Of-Closure\n> ================\n>\n> Observing the above, we want the properties for a \"good\" solution to\n> griefing attacks to be:\n>\n> * It should protect intermediate nodes against payer/payee collusions.\n> * It should only come into play upon detection of an attack.\n>\n> We now present proof-of-closure, which (we hope) has the above properties.\n>\n> We can consider instead a softer timeout, distinct from the HTLC\n> block-based timeout.\n> This softer timeout is measurable in fractions of a second, e.g. units of\n> 0.1 seconds.\n>\n> Each node on the network advertises, in addition to a block-based\n> `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> Further, each invoice contains, in addition to a block-based `final_cltv`,\n> a `final_timeout` in units of 0.1 seconds.\n>\n> Thus, there are two timeouts:\n>\n> * The current \"hard\" block-based timeout that is enforceable onchain.\n> * A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n>\n> The soft timeout, as mentioned, is not enforceable onchain.\n> Instead, enforcement of the soft timeout *is* the act of putting the\n> channel state onchain.\n>\n> Now, for the current \"hard\" block-based timeout, we already have a\n> reaction.\n> If the HTLC \"hard\" timeout is approaching:\n>\n> * Drop the channel onchain and enforce the hard timeout onchain to reclaim\n> the funds in the HTLCs.\n> * Wait for the onchain action to be deeply resolved (either timelock or\n> hashlock branch is confirmed deeply) and report the result (success or\n> fail) upstream.\n>\n> What happens if the \"soft\" timeout is violated?\n>\n> * Drop the channel onchain.\n> * Report the channel closure upstream.\n>\n> The \"hard\" timeout is cancelled in any of these two conditions:\n>\n> * A success is reported via `update_fulfill_htlc`, OR,\n> * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably\n> removed from the latest commitments/state(s) of the channel.\n>\n> The \"soft\" timeout is cancelled in any of these three conditions, the\n> first two of which are the same as above:\n>\n> * A success is reported via `update_fulfill_htlc`, OR,\n> * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably\n> removed from the latest commitments/state(s) of the channel, OR\n> * A channel closure is reported.\n>\n> Let us fill this in more detail.\n>\n> Suppose we have a payment route A->B->C->E.\n>\n> Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement\n> monotonically at each hop.\n> Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n>\n> * Suppose E then delays claiming the payment and violates the \"soft\"\n> timeout.\n> * C then drops the CE channel onchain.\n> * C reports, before its own timeout (slightly larger than the timeout\n> imposed on E), the closing of the channel CE, to B.\n> * B validates this report, and if valid, propagates the report to A.\n> * A validates this report, and if valid, accepts that the payment will be\n> \"stuck\" for up to the hard timeout it imposed on B.\n>\n> C has to report back to B in order to prevent B from closing the BC\n> channel, and B has to report back to A in order to prevent A from closing\n> the AB channel.\n> The decrementing seconds-unit timeouts are needed for each hop, for the\n> same reason that decrementing block-unit timeouts are needed.\n>\n> Since E is motivated to attack intermediate nodes because it wants to\n> redirect payment forwards through itself rather than its competitotrs,\n> having one of its channels closed (which prevents it from being used for\n> forwarding) is directly opposed to its end goal of getting more money,\n> thus, we can believe the action of closing a channel involved in a griefing\n> attack is sufficient disincentive.\n>\n> The major drawback is that enforcement of the soft timeout *is* a channel\n> closure, which is generally a negative for the network.\n> This is not a remote attack vector, since a node can only trigger this\n> closure if it is able to stall the fulfillment or failure of an HTLC on a\n> channel, which generally means the node triggering this closure can only do\n> so for its own channels (or it is able to, via a separate mechanism,\n> remotely crash a different node).\n>\n> Proving Channel Closes\n> ----------------------\n>\n> What C *really* needs to prove is that:\n>\n> * It is *willing* to close a channel due to a violation of the soft\n> timeout.\n> * The channel it is willing to close was, in fact, involved in the same\n> payment attempt.\n>\n> With the above, B can believe that C was innocent of wrongdoing, because:\n>\n> * C would only be wiling to close a channel in case of a protocol\n> violation, in this case, a violation of the soft timeout.\n> * The channel it closed was closed because of this payment attempt, and\n> not because of another payment attempt, or some other unrelated channel\n> being unilaterally closed.\n>\n> First, what C needs to prove is *NOT*, in fact, actual channel closure: it\n> needs to prove a *willingness* to close a channel.\n> Thus, it does not require the channel to actually be *closed* yet, i.e. it\n> does not have to wait for onchain activity that the channel closure is in a\n> mempool and is confirmed deeply onchain etc etc.\n>\n> Thus, to prove a *willingness to close* rather than an actual close, C can\n> provide the unilateral close of the channel CE.\n> The act of unilaterally closing a channel is the publication of the\n> transaction(s) making up the unilateral close.\n> Thus, if C is *willing* to close the channel, it is willing to publish the\n> transaction(s) involved, and thus, providing the unilateral close to B and\n> further upstream, shows a willingness to close the channel.\n>\n> B then validates the provided proof-of-closure by checking that the\n> unilateral close transaction is either onchain, in the mempool, or that it\n> spends a TXO that is not currently spent by another transaction.\n> In the case the unilateral close transaction is not confirmed and in the\n> mempool, B can speed up its propagation on the Bitcoin layer by putting it\n> in its own mempool as well --- after all, C is willing to close the channel\n> to exonerate itself and punish the actual culprit, and B putting the\n> unilateral close in its own mempool can only help C in what it is willing\n> to do.\n>\n> Secondly, C needs to prove that the channel it is willing to close\n> involves the payment attempt, and is not some other channel closure that it\n> is attempting to use to fulfill its own soft timeout.\n> Since the unilateral close transaction *is* the proof-of-closure, B (and\n> A) can inspect the transaction outputs and see (with some additional data\n> from C) that one of the outputs is to an HTLC that matches the payment hash.\n>\n> Thus, B (and A) can believe that the proof-of-closure proves that whoever\n> is presenting it is free of wrongdoing, as whoever is actually causing the\n> delay has been punished (by someone being willing to close a channel with\n> the culprit), and that the proof-of-closure commits to this particular\n> payment attempt and no other (because it commits to a particular payment\n> hash).\n>\n> Further, if CE is closed by E dropping it onchain rather than C, C will\n> still be able to fulfill its own soft timeout by taking the closing\n> transaction from E, which should still contain the HTLC.\n> Indeed, neither A nor B will particularly care (nor need to know) who\n> dropped the channel onchain, or (for A) that the channel participants are C\n> and E.\n>\n> Update State Shenanigans\n> ------------------------\n>\n> Bitcoin update mechanisms are complicated things, and it may be possible\n> for an attacking payee E to fool around with the update state machine to\n> make it difficult for C to report a willingness to close CE.\n>\n> In particular, I quote here the relevant passages from `lightning-rfc`,\n> `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update\n> mechanism:\n>\n> > Thus each update traverses through the following states:\n> >\n> > 1. pending on the receiver\n> > 2. in the receiver's latest commitment transaction\n> > 3. ... and the receiver's previous commitment transaction has been\n> revoked,\n> >    and the update is pending on the sender\n> > 4. ... and in the sender's latest commitment transaction\n> > 5. ... and the sender's previous commitment transaction has been revoked\n>\n> The payee E is the \"receiver\" in this context.\n>\n> In this case, once the update has reached step 2, then E has a commitment\n> transaction that it can put onchain, that contains an HTLC it can claim.\n> From this step onward, C cannot send a failure (i.e. it cannot send back\n> an `update_fail_htlc`) back to B, because E could drop its latest\n> commitment onchain and claim the HTLC onchain.\n>\n> However, until step 4, C does not have a unilateral close containing the\n> HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that\n> refers to the payment.\n>\n> Thus, between steps 2 to 4, C cannot safely respond to its own soft\n> timeout.\n> C cannot respond with a failure, as E could then drop its latest\n> commitment transaction onchain and claim the payment from C, and extract\n> money from C that way.\n> C also cannot respond with a proof-of-closure, as it does not have a\n> transaction that it can use to provide this proof.\n>\n> The best that C can do would be to impose an even shorter timeout between\n> steps 2 and 4 above, and to drop its current commitment transaction (which\n> does not contain the HTLC yet and thus does not constitute a valid\n> proof-of-closure) onchain.\n> In between the time it drops the commitment transaction and its own\n> incoming soft timeout, there is a chance, however small, that this\n> transaction will be confirmed, and the channel will (with high probability)\n> settle in a state where the HTLC is not instantiated, thus C can safely\n> fail its incoming HTLC (not show a proof-of-closure, since that is not\n> possible for C to do) without risk of loss, just prior to its own soft\n> timeout.\n>\n> Of course, C is still at risk here: E could collude with miners via a\n> side-channel fee offer to confirm its commitment transaction with the HTLC\n> present, and ensure that C is liable for the HTLC value.\n>\n> With Decker-Russell-Osuntokun, we can remove this risk by requiring a\n> ritual as follows:\n>\n> 1.  C requests exclusive access to update their single shared state.\n>   * This can be done via a variety of sub-protocols, including a fair coin\n> toss in case of near-simultaneous requests for exclusive locks on both\n> sides.\n> 2.  C provides the details of the new HTLC to E.\n> 3.  C and E generate the new state transaction and exchange signatures for\n> it.\n> 4.  C and E generate (without signing) the new update transaction.\n> 5.  E provides the signature (or share of signature, if MuSig) for the new\n> update transaction to C.\n> 6.  C provides the signature for the new update transaction to E, which\n> releases the exclusive lock on the shared state atomically with the\n> finalization of the new update transaction.\n>\n> Prior to step 5, C can simply fail the incoming HTLC from B in case its\n> own soft timeout is near.\n> Even if E performs step 5 after C has already failed the incoming HTLC\n> from B, C can simply not perform step 6 and drop the channel onchain with\n> the previous update and state transactions.\n>\n> With Poon-Dryja, we will have to rearrange the order in which we perform\n> things, effectively adding an extra communications turnaround between the\n> participants.\n> Specifically, the order would have to be revised to:\n>\n> > 1. pending on the sender\n> > 2. in the sender's latest commitment transaction\n> > 3. ... and the sender's previous commitment transaction has been revoked,\n> >    and the update is pending on the receiver\n> > 4. ... and in the receiver's latest commitment transaction\n> > 5. ... and the receiver's previous commitment transaction has been\n> revoked\n>\n> This allows the sender (C in our context) to provide a proof-of-closure\n> after step 2, and before step 2, C can safely return a failure with\n> `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it\n> can still use the previous commitment that still has no HTLC).\n>\n> Of course, this change will require redesigning the update state machine,\n> increasing the number of communication turnarounds, and creating a subtle\n> incompatbility when transitioning a payment from a hop that knows only the\n> old update state machine to a hop that knows the new update state machine.\n>\n> Purely Falsified Proof-Of-Closure\n> ---------------------------------\n>\n> Of course, the attacking node E might want to create a false\n> proof-of-closure.\n> E can do this by simulating a Lightning channel: lock an amount of funds\n> in a 2-of-2 (where E controls both keys), then spend it in a set of\n> transactions mimicking the unilateral close.\n>\n> We observe, however, that the overhead of simulating a Lightning channel\n> is the same as the overhead of actually creating and closing a Lightning\n> channel.\n> Since the punishment of proof-of-closure is to force attackers to have\n> their channels closed, we can consider that this simulation of a channel\n> open and close is sufficient as well.\n>\n> Future-Proofing\n> ---------------\n>\n> This sketch of proof-of-closure can be used for any update mechanism:\n>\n> * With Poon-Dryja, C can use its own commitment transaction as the\n> proof-of-closure.\n> * With Decker-Wattenhofer, C can give all the offchain transactions up to\n> the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> * With Deckker-Russell-Osuntokun, C can give the latest update and state\n> trnsaction.\n>\n> Basically, we expect that for now, and in the future, any update mechanism\n> worth consideration will have a concept of \"unilateral close\" where a\n> channel can be dropped onchain, using data that only one of the channel\n> participants holds.\n>\n> Such a unilateral close will be a sequence of one or more valid\n> transactions, terminating in a transaction containing an HTLC-like contract\n> in one of its outputs.\n>\n> Thus, to validate the unilateral close, it is only required to validate\n> all the transactions contained in the proof-of-closure, and see that the\n> last transaction has an HTLC output.\n>\n> The limitations are thus:\n>\n> * The acceptable forms of HTLC would need to be agreed-upon by the entire\n> network.\n> * Implementations would need to be able to assess, in a\n> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n>\n> Payment Decorrelation and Payment Points\n> ----------------------------------------\n>\n> Of course, having a single payment hash for the entire payment attempt is\n> a privacy loss, which we intend to fix in the near future by using payment\n> points, and adding a blinding scalar at each hop, aka. payment\n> decorrelation.\n>\n> Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> Further, the payment point at each hop will be changed at each hop, in\n> order to prevent decorrelation.\n>\n> Thus, C needs to provide proofs:\n>\n> * That an apparent singlesig on the unilateral close output is in fact a\n> PTLC.\n>   C needs to provide:\n>   * A target point P.\n>   * A partial signature that would spend that singlesig for a particular\n> sighash.\n>   * An adaptor signature which, with knowledge of the completed signature,\n> adaptor signature, and sighash message, would have revealed the scalar\n> behind P.\n> * That the PTLC belongs to the same payment attempt as what B offered to C.\n>   C needs to provide:\n>   * The C-only blinding factor that is the difference between the payment\n> point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n>\n> Then, when B needs to propagate the proof-of-closure back to A, B simply\n> adds its own blinding factor to the reported blinding factor, in order to\n> convince A that this is the same payment attempt.\n>\n> As we have brought up privacy, we observe that, when this mechanism\n> triggers, there is a mild privacy loss, in that intermediate nodes now know\n> some channel closure that is related to this payment, and can thus\n> determine the exact path that the payment attempt went through, at least\n> until the channel being closed.\n> However, proof-of-closure is only propagated in case of violation of the\n> soft timeout, so for normal non-malicious payments, proof-of-closure does\n> not cause any privacy loss.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200401/082a44f1/attachment-0001.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-04-01T20:07:51",
                "message_text_only": "I just thought of a potentially more serious problem, at least for\nPoon-Dryja channels, isn't it true that giving a proof of closure is\nequivalent to actually closing the channel since once other parties have\ncopies of the fully signed commitment transaction, it cannot be safely\nrevoked since other parties now have the ability to publish an old state? I\nmight be missing something but this seems like a big problem.\n\nBest,\nNadav\n\nOn Wed, Apr 1, 2020 at 1:07 PM Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hi ZmnSCPxj and list,\n>\n> Love the idea! I have a couple questions though:\n>\n> I'm not convinced that \"Purely Falsified Proof-Of-Closure\" aren't\n> effective. Consider a similar network to the one you described where we\n> have channels A - B - C and A - E - C but where we add a \"fake\" channel E -\n> E'. Now if the attacker sets up a payment from E to E' using the route E -\n> C - B - A - E - E', then the attacker can successfully lock up all of B's\n> channels (as is desirable to get rid of competition) and also generate a\n> false proof of closure for the E - E' channel. Even if this false proof\n> (which is a commitment tx) ends up being published on chain, E has lost no\n> ability to route and has successfully made B unable to route between A and\n> C. If my understanding of the proposal is correct, and it may not be, then\n> the punishment for grieving payments is the threat of closing channels that\n> would benefit from the grieving attack. But adding a new channel on the end\n> to be closed seems to invalidate this punishment?\n>\n> A second question I have is if you think that it would be advisable to use\n> up-front payments (pay for attempt, not just success) on payments with\n> abnormally high soft timeouts? If all this works, this combination seems to\n> be a way to enable hodl invoices under the proof of closure proposal.\n>\n> Best,\n> Nadav\n>\n> On Wed, Apr 1, 2020 at 1:19 AM ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Introduction\n>> ============\n>>\n>> Given the fact that contracts on offchain protocols need to be\n>> enforceable onchain as well, timelocks involved in multi-hop payments are\n>> measured in blocks.\n>> This is because the blockchain can only (third-party-verifiably) enforce\n>> timeouts in units of entire blocks.\n>> This leads to very long timeouts for payment delivery, thus multi-hop\n>> offchain payment attempts can be, deliberately or accidentally, be in a\n>> \"pending\" state up to the very large timeouts involved.\n>>\n>> Deliberately setting up a multi-hop payment such that it will be in a\n>> \"pending\" state for long periods of time is colloquially known as a\n>> \"griefing attack\".\n>> In this article, we assess various proposed solutions to mitigate the\n>> effects of griefing attacks, and propose a particular solution,\n>> proof-of-closure, as well, that requires significant changes to the update\n>> state machine.\n>>\n>> Digression: Why Grief?\n>> ======================\n>>\n>> Before embarking on our investigation for solutions to the griefing\n>> problem, we should first wonder if griefing is, in fact, a problem.\n>>\n>> This brings up the question of: why would anybody grief at all?\n>>\n>> Humans, like cats and other less-sapient pieces of walking meat, often\n>> find enjoyment in causing the suffering of others for no immediate direct\n>> gain to themselves, as a public demonstration of dominance over those they\n>> make suffer (aka \"shits and giggles\", which, if executed correctly, can\n>> lead to eventual direct gains to themselves or their progeny or relatives\n>> or allies, but such details are often outside the ken of the very beings\n>> who execute such survival strategies: brains are pieces of meat that have\n>> been hacked to act as action-reaction engines, but are not sophisticated\n>> enough to execute as pure rationality engines at all times).\n>> Fortunately, in the Bitcoin world, only purely rational beings of pure\n>> selfishness can exist in the long run, thus we can neglect such motivations\n>> as mere noise.\n>>\n>> First, let us investigate *how* griefing attacks can be performed.\n>>\n>> * An intermediate node in a multi-hop attempt can delay forwarding or\n>> failing an incoming HTLC.\n>> * A final node in a payment attempt can delay claiming an incoming HTLC.\n>>\n>> Let us consider a purely rational intermediate node of pure selfishness:\n>>\n>> * If it forwards as soon as possible, it can earn fees, and also speed up\n>> the release of the HTLC-locked funds so that they can reuse those funds as\n>> liquidity for further payment attempts.\n>> * Thus, delaying an HTLC is not selfishly-rational for an intermediate\n>> node.\n>>\n>> Thus, for an intermediate node, it seems there is no selfishly-rational\n>> motivation to execute a griefing attack on an arbitrary payment attempt.\n>> We can then conclude that an intermediate that delays a payment would do\n>> so, not of its own rational self-interest, but as an accident, such as an\n>> unforeseen connectivity or power failure.\n>>\n>> However, things are different when we consider a non-arbitrary payment.\n>> Suppose a node were to make a payment attempt to itself, and deliberately\n>> delay claiming this self-payment.\n>> This lets any single node, *who happens to own large liquidity*, to lock\n>> up the liquidity of other nodes.\n>>\n>> The motivation to lock up the liquidity of other nodes is to *eliminate\n>> competition*.\n>> Suppose we have a network as below:\n>>\n>>     A -- B -- C\n>>       \\     /\n>>        \\   /\n>>         \\ /\n>>          E\n>>\n>> When A and C want to transact with one another, they may choose to route\n>> via either B or E.\n>> B and E are therefore competitors in the business of forwarding payments.\n>>\n>> But suppose E has much larger channels AE and CE than the channels of AB\n>> and CB.\n>> For example, suppose E has 100mBTC perfectly-balanced channels while B\n>> has only 10mBTC perfectly-balanced channels, as all things should be in\n>> simplified models of reality.\n>> E can then \"take out the competition\" by making a 5mBTC self-payment\n>> along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then\n>> refusing to claim the payment, tying up all the liquidity of the channels\n>> of B.\n>> By doing so, it can ensure that A and C will always fail to pay via B,\n>> even if they wish to transact in amounts less than 5mBTC.\n>> E thereby eliminates B as a competitor.\n>>\n>> This demonstrates that griefing attacks will be motivated, such that such\n>> attacks will be performed by payers and payees *against intermediate nodes*.\n>> Intermediate nodes have no motivation to attack payers and payees (those\n>> are their potential customers in the business of forwarding payments, and\n>> attacking potential customers is bad business: such attacking intermediate\n>> nodes will be removed economically in the long run).\n>> However, payers and payees can become motivated to attack intermediate\n>> nodes, if the \"payer\" and \"payee\" are actually competitor intermediate\n>> nodes.\n>>\n>> (We can observe that this is always a possibility even outside of\n>> Lightning: a service or product provider has no incentive to attack its\n>> customers (\"the customer is always right\"), but have an incentive to\n>> *pretend* to be a customer of a competitor and attack them.)\n>>\n>> We will keep this fact in mind: active griefing attacks are attacks *on*\n>> intermediate nodes, not *by* intermediate nodes, because there is no\n>> economic incentive for intermediate nodes to attack their customers.\n>>\n>> Previous Proposed Solutions\n>> ===========================\n>>\n>> Time-Spent Reporting\n>> --------------------\n>>\n>> At each channel along the route, the time spent by a node to handle its\n>> forwarding is recorded, and reported upstream in the route.\n>>\n>> Unfortunately, this solution protects payers from intermediate nodes and\n>> payees: it does not protect intermediate nodes from colluding payers and\n>> payees.\n>> Even if an intermediate node knows that a particular node is consistently\n>> slow via a previous time-spent report, it will not be able, with our\n>> current onion routing, determine if an onion packet it just received will\n>> or will not go through the known-slow node.\n>> Thus, an intermediate node would not be able to defend against distant\n>> payees that, with a colluding payer, will not claim a particular payment.\n>>\n>> As we have established, an active griefing atttack will never be\n>> deliberately performed by a selfishly-rational intermediate node.\n>> Thus, this solution protects against the wrong thing: it protects payers\n>> against slow/unreliable intermediate nodes, it does not protect\n>> intermediate nodes against malicious payer/payee collusions.\n>> It protects only against intermediate nodes that inadvertently go offline\n>> during forwarding, but such nodes will inevitably lose out on the\n>> forwarding market anyway, and will disappear in the long run.\n>>\n>> Up-Front Payment\n>> ----------------\n>>\n>> Payers pay for an attempt, not just the successful completion of an\n>> attempt.\n>>\n>> A variation on this is that the payer (or payee) continuously pays as\n>> long as the payment is pending.\n>> Further variations include paying by other means, such as just locking\n>> funds or paying with proof-of-work.\n>>\n>> While it certainly erects economic barriers against payer/payee\n>> collusions attacking intermediate nodes, it *also* erects economic barriers\n>> against normal, non-malicious payments.\n>>\n>> We can consider that economic barriers against non-malicious, low-value,\n>> high-frequency payments (\"micropayments\") may be enough that such payments\n>> become infeasible if we impose up-front payment for mere attempts.\n>> Thus, while this solution is certainly something we can consider, we must\n>> be reluctant to use it due to its up-front, strict-evaluation behavior.\n>>\n>> Proof-Of-Closure\n>> ================\n>>\n>> Observing the above, we want the properties for a \"good\" solution to\n>> griefing attacks to be:\n>>\n>> * It should protect intermediate nodes against payer/payee collusions.\n>> * It should only come into play upon detection of an attack.\n>>\n>> We now present proof-of-closure, which (we hope) has the above properties.\n>>\n>> We can consider instead a softer timeout, distinct from the HTLC\n>> block-based timeout.\n>> This softer timeout is measurable in fractions of a second, e.g. units of\n>> 0.1 seconds.\n>>\n>> Each node on the network advertises, in addition to a block-based\n>> `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n>> Further, each invoice contains, in addition to a block-based\n>> `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n>>\n>> Thus, there are two timeouts:\n>>\n>> * The current \"hard\" block-based timeout that is enforceable onchain.\n>> * A new \"soft\" sidereal-time-based timeout that is not onchain\n>> enforceable.\n>>\n>> The soft timeout, as mentioned, is not enforceable onchain.\n>> Instead, enforcement of the soft timeout *is* the act of putting the\n>> channel state onchain.\n>>\n>> Now, for the current \"hard\" block-based timeout, we already have a\n>> reaction.\n>> If the HTLC \"hard\" timeout is approaching:\n>>\n>> * Drop the channel onchain and enforce the hard timeout onchain to\n>> reclaim the funds in the HTLCs.\n>> * Wait for the onchain action to be deeply resolved (either timelock or\n>> hashlock branch is confirmed deeply) and report the result (success or\n>> fail) upstream.\n>>\n>> What happens if the \"soft\" timeout is violated?\n>>\n>> * Drop the channel onchain.\n>> * Report the channel closure upstream.\n>>\n>> The \"hard\" timeout is cancelled in any of these two conditions:\n>>\n>> * A success is reported via `update_fulfill_htlc`, OR,\n>> * A failure is reported via `update_fail_htlc` AND the HTLC is\n>> irrevocably removed from the latest commitments/state(s) of the channel.\n>>\n>> The \"soft\" timeout is cancelled in any of these three conditions, the\n>> first two of which are the same as above:\n>>\n>> * A success is reported via `update_fulfill_htlc`, OR,\n>> * A failure is reported via `update_fail_htlc` AND the HTLC is\n>> irrevocably removed from the latest commitments/state(s) of the channel, OR\n>> * A channel closure is reported.\n>>\n>> Let us fill this in more detail.\n>>\n>> Suppose we have a payment route A->B->C->E.\n>>\n>> Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement\n>> monotonically at each hop.\n>> Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n>>\n>> * Suppose E then delays claiming the payment and violates the \"soft\"\n>> timeout.\n>> * C then drops the CE channel onchain.\n>> * C reports, before its own timeout (slightly larger than the timeout\n>> imposed on E), the closing of the channel CE, to B.\n>> * B validates this report, and if valid, propagates the report to A.\n>> * A validates this report, and if valid, accepts that the payment will be\n>> \"stuck\" for up to the hard timeout it imposed on B.\n>>\n>> C has to report back to B in order to prevent B from closing the BC\n>> channel, and B has to report back to A in order to prevent A from closing\n>> the AB channel.\n>> The decrementing seconds-unit timeouts are needed for each hop, for the\n>> same reason that decrementing block-unit timeouts are needed.\n>>\n>> Since E is motivated to attack intermediate nodes because it wants to\n>> redirect payment forwards through itself rather than its competitotrs,\n>> having one of its channels closed (which prevents it from being used for\n>> forwarding) is directly opposed to its end goal of getting more money,\n>> thus, we can believe the action of closing a channel involved in a griefing\n>> attack is sufficient disincentive.\n>>\n>> The major drawback is that enforcement of the soft timeout *is* a channel\n>> closure, which is generally a negative for the network.\n>> This is not a remote attack vector, since a node can only trigger this\n>> closure if it is able to stall the fulfillment or failure of an HTLC on a\n>> channel, which generally means the node triggering this closure can only do\n>> so for its own channels (or it is able to, via a separate mechanism,\n>> remotely crash a different node).\n>>\n>> Proving Channel Closes\n>> ----------------------\n>>\n>> What C *really* needs to prove is that:\n>>\n>> * It is *willing* to close a channel due to a violation of the soft\n>> timeout.\n>> * The channel it is willing to close was, in fact, involved in the same\n>> payment attempt.\n>>\n>> With the above, B can believe that C was innocent of wrongdoing, because:\n>>\n>> * C would only be wiling to close a channel in case of a protocol\n>> violation, in this case, a violation of the soft timeout.\n>> * The channel it closed was closed because of this payment attempt, and\n>> not because of another payment attempt, or some other unrelated channel\n>> being unilaterally closed.\n>>\n>> First, what C needs to prove is *NOT*, in fact, actual channel closure:\n>> it needs to prove a *willingness* to close a channel.\n>> Thus, it does not require the channel to actually be *closed* yet, i.e.\n>> it does not have to wait for onchain activity that the channel closure is\n>> in a mempool and is confirmed deeply onchain etc etc.\n>>\n>> Thus, to prove a *willingness to close* rather than an actual close, C\n>> can provide the unilateral close of the channel CE.\n>> The act of unilaterally closing a channel is the publication of the\n>> transaction(s) making up the unilateral close.\n>> Thus, if C is *willing* to close the channel, it is willing to publish\n>> the transaction(s) involved, and thus, providing the unilateral close to B\n>> and further upstream, shows a willingness to close the channel.\n>>\n>> B then validates the provided proof-of-closure by checking that the\n>> unilateral close transaction is either onchain, in the mempool, or that it\n>> spends a TXO that is not currently spent by another transaction.\n>> In the case the unilateral close transaction is not confirmed and in the\n>> mempool, B can speed up its propagation on the Bitcoin layer by putting it\n>> in its own mempool as well --- after all, C is willing to close the channel\n>> to exonerate itself and punish the actual culprit, and B putting the\n>> unilateral close in its own mempool can only help C in what it is willing\n>> to do.\n>>\n>> Secondly, C needs to prove that the channel it is willing to close\n>> involves the payment attempt, and is not some other channel closure that it\n>> is attempting to use to fulfill its own soft timeout.\n>> Since the unilateral close transaction *is* the proof-of-closure, B (and\n>> A) can inspect the transaction outputs and see (with some additional data\n>> from C) that one of the outputs is to an HTLC that matches the payment hash.\n>>\n>> Thus, B (and A) can believe that the proof-of-closure proves that whoever\n>> is presenting it is free of wrongdoing, as whoever is actually causing the\n>> delay has been punished (by someone being willing to close a channel with\n>> the culprit), and that the proof-of-closure commits to this particular\n>> payment attempt and no other (because it commits to a particular payment\n>> hash).\n>>\n>> Further, if CE is closed by E dropping it onchain rather than C, C will\n>> still be able to fulfill its own soft timeout by taking the closing\n>> transaction from E, which should still contain the HTLC.\n>> Indeed, neither A nor B will particularly care (nor need to know) who\n>> dropped the channel onchain, or (for A) that the channel participants are C\n>> and E.\n>>\n>> Update State Shenanigans\n>> ------------------------\n>>\n>> Bitcoin update mechanisms are complicated things, and it may be possible\n>> for an attacking payee E to fool around with the update state machine to\n>> make it difficult for C to report a willingness to close CE.\n>>\n>> In particular, I quote here the relevant passages from `lightning-rfc`,\n>> `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update\n>> mechanism:\n>>\n>> > Thus each update traverses through the following states:\n>> >\n>> > 1. pending on the receiver\n>> > 2. in the receiver's latest commitment transaction\n>> > 3. ... and the receiver's previous commitment transaction has been\n>> revoked,\n>> >    and the update is pending on the sender\n>> > 4. ... and in the sender's latest commitment transaction\n>> > 5. ... and the sender's previous commitment transaction has been revoked\n>>\n>> The payee E is the \"receiver\" in this context.\n>>\n>> In this case, once the update has reached step 2, then E has a commitment\n>> transaction that it can put onchain, that contains an HTLC it can claim.\n>> From this step onward, C cannot send a failure (i.e. it cannot send back\n>> an `update_fail_htlc`) back to B, because E could drop its latest\n>> commitment onchain and claim the HTLC onchain.\n>>\n>> However, until step 4, C does not have a unilateral close containing the\n>> HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that\n>> refers to the payment.\n>>\n>> Thus, between steps 2 to 4, C cannot safely respond to its own soft\n>> timeout.\n>> C cannot respond with a failure, as E could then drop its latest\n>> commitment transaction onchain and claim the payment from C, and extract\n>> money from C that way.\n>> C also cannot respond with a proof-of-closure, as it does not have a\n>> transaction that it can use to provide this proof.\n>>\n>> The best that C can do would be to impose an even shorter timeout between\n>> steps 2 and 4 above, and to drop its current commitment transaction (which\n>> does not contain the HTLC yet and thus does not constitute a valid\n>> proof-of-closure) onchain.\n>> In between the time it drops the commitment transaction and its own\n>> incoming soft timeout, there is a chance, however small, that this\n>> transaction will be confirmed, and the channel will (with high probability)\n>> settle in a state where the HTLC is not instantiated, thus C can safely\n>> fail its incoming HTLC (not show a proof-of-closure, since that is not\n>> possible for C to do) without risk of loss, just prior to its own soft\n>> timeout.\n>>\n>> Of course, C is still at risk here: E could collude with miners via a\n>> side-channel fee offer to confirm its commitment transaction with the HTLC\n>> present, and ensure that C is liable for the HTLC value.\n>>\n>> With Decker-Russell-Osuntokun, we can remove this risk by requiring a\n>> ritual as follows:\n>>\n>> 1.  C requests exclusive access to update their single shared state.\n>>   * This can be done via a variety of sub-protocols, including a fair\n>> coin toss in case of near-simultaneous requests for exclusive locks on both\n>> sides.\n>> 2.  C provides the details of the new HTLC to E.\n>> 3.  C and E generate the new state transaction and exchange signatures\n>> for it.\n>> 4.  C and E generate (without signing) the new update transaction.\n>> 5.  E provides the signature (or share of signature, if MuSig) for the\n>> new update transaction to C.\n>> 6.  C provides the signature for the new update transaction to E, which\n>> releases the exclusive lock on the shared state atomically with the\n>> finalization of the new update transaction.\n>>\n>> Prior to step 5, C can simply fail the incoming HTLC from B in case its\n>> own soft timeout is near.\n>> Even if E performs step 5 after C has already failed the incoming HTLC\n>> from B, C can simply not perform step 6 and drop the channel onchain with\n>> the previous update and state transactions.\n>>\n>> With Poon-Dryja, we will have to rearrange the order in which we perform\n>> things, effectively adding an extra communications turnaround between the\n>> participants.\n>> Specifically, the order would have to be revised to:\n>>\n>> > 1. pending on the sender\n>> > 2. in the sender's latest commitment transaction\n>> > 3. ... and the sender's previous commitment transaction has been\n>> revoked,\n>> >    and the update is pending on the receiver\n>> > 4. ... and in the receiver's latest commitment transaction\n>> > 5. ... and the receiver's previous commitment transaction has been\n>> revoked\n>>\n>> This allows the sender (C in our context) to provide a proof-of-closure\n>> after step 2, and before step 2, C can safely return a failure with\n>> `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it\n>> can still use the previous commitment that still has no HTLC).\n>>\n>> Of course, this change will require redesigning the update state machine,\n>> increasing the number of communication turnarounds, and creating a subtle\n>> incompatbility when transitioning a payment from a hop that knows only the\n>> old update state machine to a hop that knows the new update state machine.\n>>\n>> Purely Falsified Proof-Of-Closure\n>> ---------------------------------\n>>\n>> Of course, the attacking node E might want to create a false\n>> proof-of-closure.\n>> E can do this by simulating a Lightning channel: lock an amount of funds\n>> in a 2-of-2 (where E controls both keys), then spend it in a set of\n>> transactions mimicking the unilateral close.\n>>\n>> We observe, however, that the overhead of simulating a Lightning channel\n>> is the same as the overhead of actually creating and closing a Lightning\n>> channel.\n>> Since the punishment of proof-of-closure is to force attackers to have\n>> their channels closed, we can consider that this simulation of a channel\n>> open and close is sufficient as well.\n>>\n>> Future-Proofing\n>> ---------------\n>>\n>> This sketch of proof-of-closure can be used for any update mechanism:\n>>\n>> * With Poon-Dryja, C can use its own commitment transaction as the\n>> proof-of-closure.\n>> * With Decker-Wattenhofer, C can give all the offchain transactions up to\n>> the last stage in the multi-stage decrementing-`nSequence` mechanism.\n>> * With Deckker-Russell-Osuntokun, C can give the latest update and state\n>> trnsaction.\n>>\n>> Basically, we expect that for now, and in the future, any update\n>> mechanism worth consideration will have a concept of \"unilateral close\"\n>> where a channel can be dropped onchain, using data that only one of the\n>> channel participants holds.\n>>\n>> Such a unilateral close will be a sequence of one or more valid\n>> transactions, terminating in a transaction containing an HTLC-like contract\n>> in one of its outputs.\n>>\n>> Thus, to validate the unilateral close, it is only required to validate\n>> all the transactions contained in the proof-of-closure, and see that the\n>> last transaction has an HTLC output.\n>>\n>> The limitations are thus:\n>>\n>> * The acceptable forms of HTLC would need to be agreed-upon by the entire\n>> network.\n>> * Implementations would need to be able to assess, in a\n>> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n>>\n>> Payment Decorrelation and Payment Points\n>> ----------------------------------------\n>>\n>> Of course, having a single payment hash for the entire payment attempt is\n>> a privacy loss, which we intend to fix in the near future by using payment\n>> points, and adding a blinding scalar at each hop, aka. payment\n>> decorrelation.\n>>\n>> Thus, in the future, there will not be any HTLC, but instead a PTLC.\n>> Further, the payment point at each hop will be changed at each hop, in\n>> order to prevent decorrelation.\n>>\n>> Thus, C needs to provide proofs:\n>>\n>> * That an apparent singlesig on the unilateral close output is in fact a\n>> PTLC.\n>>   C needs to provide:\n>>   * A target point P.\n>>   * A partial signature that would spend that singlesig for a particular\n>> sighash.\n>>   * An adaptor signature which, with knowledge of the completed\n>> signature, adaptor signature, and sighash message, would have revealed the\n>> scalar behind P.\n>> * That the PTLC belongs to the same payment attempt as what B offered to\n>> C.\n>>   C needs to provide:\n>>   * The C-only blinding factor that is the difference between the payment\n>> point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n>>\n>> Then, when B needs to propagate the proof-of-closure back to A, B simply\n>> adds its own blinding factor to the reported blinding factor, in order to\n>> convince A that this is the same payment attempt.\n>>\n>> As we have brought up privacy, we observe that, when this mechanism\n>> triggers, there is a mild privacy loss, in that intermediate nodes now know\n>> some channel closure that is related to this payment, and can thus\n>> determine the exact path that the payment attempt went through, at least\n>> until the channel being closed.\n>> However, proof-of-closure is only propagated in case of violation of the\n>> soft timeout, so for normal non-malicious payments, proof-of-closure does\n>> not cause any privacy loss.\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200401/068762fe/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-02T00:43:11",
                "message_text_only": "Good morning Nadav,\n\n\n> Love the idea! I have a couple questions though:\n>\n> I'm not convinced that \"Purely Falsified Proof-Of-Closure\" aren't effective. Consider a similar network to the one you described where we have channels A - B - C and A - E - C but where we add a \"fake\" channel E - E'. Now if the attacker sets up a payment from E to E' using the route E - C - B - A - E - E', then the attacker can successfully lock up all of B's channels (as is desirable to get rid of competition) and also generate a false proof of closure for the E - E' channel. Even if this false proof (which is a commitment tx) ends up being published on chain, E has lost no ability to route and has successfully made B unable to route between A and C. If my understanding of the proposal is correct, and it may not be, then the punishment for grieving payments is the threat of closing channels that would benefit from the grieving attack. But adding a new channel on the end to be closed seems to invalidate this punishment?\n\nThe consideration is that much of the cost of a channel is with the setup and teardown --- E could always just reopen the CE channel again later.\nThus, the cost that E bears in setting up EE and tearing down EE would be still similar to the cost of losing CE and reestablishing it again.\nFurther, any amount it places in the EE channel would be an amount it could have been using as liquidity on Lightning, but which it cannot use for forwarding (because it is a channel to nowhere).\nUltimately, proof-of-closure is an economic mechanism, not an information-theoretic one.\n\nSo the mere existence of EE, to be later sacrificed, is enough punishment on E.\nI think.\n\n>\n> A second question I have is if you think that it would be advisable to use up-front payments (pay for attempt, not just success) on payments with abnormally high soft timeouts? If all this works, this combination seems to be a way to enable hodl invoices under the proof of closure proposal.\n\nPossibly, though this increases the complexity of the proposal even more.\n\n>I just thought of a potentially more serious problem, at least for Poon-Dryja channels, isn't it true that giving a proof of closure is equivalent to actually closing the channel since once other parties have copies of the fully signed commitment transaction, it cannot be safely revoked since other parties now have the ability to publish an old state? I might be missing something but this seems like a big problem.\n\nSince this is a proof-of-***closure***, this is indeed an actual closing of the channel.\nIt would not be proof-of-closure if the channel was not being closed, but proof-of-something-else.\n\nWhat is desired is simply that C can plausibly say \"I punished somebody else by closing on them, please do not punish me for punishing them\".\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-04-02T14:56:42",
                "message_text_only": "Good morning ZmnSCPxj,\n\n> The consideration is that much of the cost of a channel is with the setup\nand teardown --- E could always just reopen the CE channel again later.\n> Thus, the cost that E bears in setting up EE and tearing down EE would be\nstill similar to the cost of losing CE and reestablishing it again.\n> Further, any amount it places in the EE channel would be an amount it\ncould have been using as liquidity on Lightning, but which it cannot use\nfor forwarding (because it is a channel to nowhere).\n> Ultimately, proof-of-closure is an economic mechanism, not an\ninformation-theoretic one.\n\nOkay, I see what you mean now but I'm still a bit worried due to the\nfollowing: although it is true that the same nominal penalty is incurred,\nthe real economic value for the attacker in channel E-E' is significantly\nless than that in A-E, which can be used for routing. As such, a rich\nattacker who wishes to crowd out their competition might occasionally open\nchannels with themselves equal to the value needed to lock up a\ncompetitor's channels, then do such a payment to themselves (with a high\n\"hard\" locktime) and close their temporary channel, but still hold their\ncompetitor's funds hostage, and still have enough liquidity in the channels\nthey didn't have to close in order to facilitate all routing that was done\nby their competitor. Furthermore this route (for self-payment) could attack\nmultiple competitors at the same time (likely leaving some funds to all but\nthe least liquid competitor).\n\nI could be missing something, but it seems to me like the proposal to close\nchannels after a soft timeout unless non-cooperation can be proven upstream\nadds a cost to the attacker of two on-chain transactions, which they can\nimmediately revoke (as they know both pieces to the revocation priv key),\nbut still allows very long lock-ups of other's funds (with a 10x multiplier\nif they choose a long route). I do think that this is certainly an\nimprovement on what we have now but I'm not sure it properly punishes the\nattacker in its current form.\n\n> Since this is a proof-of-***closure***, this is indeed an actual closing\nof the channel.\n\nAh I see, I was misunderstanding a couple things, but I get it now, makes\nsense :)\n\nBest,\nNadav\n\nOn Wed, Apr 1, 2020 at 7:43 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Nadav,\n>\n>\n> > Love the idea! I have a couple questions though:\n> >\n> > I'm not convinced that \"Purely Falsified Proof-Of-Closure\" aren't\n> effective. Consider a similar network to the one you described where we\n> have channels A - B - C and A - E - C but where we add a \"fake\" channel E -\n> E'. Now if the attacker sets up a payment from E to E' using the route E -\n> C - B - A - E - E', then the attacker can successfully lock up all of B's\n> channels (as is desirable to get rid of competition) and also generate a\n> false proof of closure for the E - E' channel. Even if this false proof\n> (which is a commitment tx) ends up being published on chain, E has lost no\n> ability to route and has successfully made B unable to route between A and\n> C. If my understanding of the proposal is correct, and it may not be, then\n> the punishment for grieving payments is the threat of closing channels that\n> would benefit from the grieving attack. But adding a new channel on the end\n> to be closed seems to invalidate this punishment?\n>\n> The consideration is that much of the cost of a channel is with the setup\n> and teardown --- E could always just reopen the CE channel again later.\n> Thus, the cost that E bears in setting up EE and tearing down EE would be\n> still similar to the cost of losing CE and reestablishing it again.\n> Further, any amount it places in the EE channel would be an amount it\n> could have been using as liquidity on Lightning, but which it cannot use\n> for forwarding (because it is a channel to nowhere).\n> Ultimately, proof-of-closure is an economic mechanism, not an\n> information-theoretic one.\n>\n> So the mere existence of EE, to be later sacrificed, is enough punishment\n> on E.\n> I think.\n>\n> >\n> > A second question I have is if you think that it would be advisable to\n> use up-front payments (pay for attempt, not just success) on payments with\n> abnormally high soft timeouts? If all this works, this combination seems to\n> be a way to enable hodl invoices under the proof of closure proposal.\n>\n> Possibly, though this increases the complexity of the proposal even more.\n>\n> >I just thought of a potentially more serious problem, at least for\n> Poon-Dryja channels, isn't it true that giving a proof of closure is\n> equivalent to actually closing the channel since once other parties have\n> copies of the fully signed commitment transaction, it cannot be safely\n> revoked since other parties now have the ability to publish an old state? I\n> might be missing something but this seems like a big problem.\n>\n> Since this is a proof-of-***closure***, this is indeed an actual closing\n> of the channel.\n> It would not be proof-of-closure if the channel was not being closed, but\n> proof-of-something-else.\n>\n> What is desired is simply that C can plausibly say \"I punished somebody\n> else by closing on them, please do not punish me for punishing them\".\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200402/b6b6749a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-03T02:51:15",
                "message_text_only": "Good morning Nadav,\n\n> I could be missing something, but it seems to me like the proposal to close channels after a soft timeout unless non-cooperation can be proven upstream adds\u00a0a cost to the attacker of two on-chain transactions, which they can immediately revoke (as they know both pieces to the revocation priv key), but still allows very long lock-ups of other's funds (with a 10x multiplier if they choose a long route). I do think that this is certainly an improvement\u00a0on what we have now but I'm not sure it properly punishes the attacker in its current form.\n\nAh, right, E knows the revocation for the unilateral close of EE, because it is a self-channel, sigh.\nAnd by this revocation clause it can claim the money immediately and put it into a channel as well.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-04T16:05:46",
                "message_text_only": "On Fri, Apr 03, 2020 at 02:51:15AM +0000, ZmnSCPxj via Lightning-dev wrote:\n> Ah, right, E knows the revocation for the unilateral close of EE,\n> because it is a self-channel, sigh.  And by this revocation clause it\n> can claim the money immediately and put it into a channel as well.\n\nIf it's a self channel, E can also just RBF replace the close\ntransaction with a minimally-sized 1-input, 1-output transaction.\n\nIn addition, if typical mempools are full and the closing transaction\nfeerate is very low (i.e. because anchor outputs are meant to be used)\nE may also be able to create a close transaction that will be\ndropped from typical mempools in the near future and may never \nconfirm, allowing E to continue using the channel in attacks against its\nother peers.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200404/9350d3a0/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-05T00:54:28",
                "message_text_only": "Good morning Dave,\n\n> > Ah, right, E knows the revocation for the unilateral close of EE,\n> > because it is a self-channel, sigh. And by this revocation clause it\n> > can claim the money immediately and put it into a channel as well.\n>\n> If it's a self channel, E can also just RBF replace the close\n> transaction with a minimally-sized 1-input, 1-output transaction.\n>\n> In addition, if typical mempools are full and the closing transaction\n> feerate is very low (i.e. because anchor outputs are meant to be used)\n> E may also be able to create a close transaction that will be\n> dropped from typical mempools in the near future and may never\n> confirm, allowing E to continue using the channel in attacks against its\n> other peers.\n\nMost nodes are programmed to presume that once a possible close of a channel is seen on a mempool, the channel is closed and the node will no longer sign any updates on it, so this is only possible if E controls the other end of the channel, i.e. this is just another variant of the EE channel.\n\nIn particular, once E has released any closing transaction as proof-of-closure, C, B, A etc. can keep posting it to the mempool even if it drops out, so E would probably not want to revoke that closing transaction as its counterparty can then revoke it and take the funds in the channel.\nSo this is safe only if the counterparty cooperates, or in other words, if E and its counterparty are the same entity.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-12T08:30:29",
                "message_text_only": "Good morning Nadav, and list,\n\nThinking even further:\n\n* It is trivially cheap for E to start up new nodes F and G and start up channels FA and GC.\n* It then becomes possible for E to lock up funds of B via F->A->B->C->G and G->C->B->A->F.\n* Even closure of FA and GC does not affect EA and EB.\n\nSo I am not certain that this attack is solvable at all via inter-node interactions, since we must also consider the possibility of some throwaway node being created for the purpose of executing this attack.\n\nPerhaps the remaining possible solution is to require that nodes also lock up some funds (in a UTXO that is *separate* from any channels, and from other fidelity bonds, like what belcher suggests for JoinMarket makers, and what is intended for defiads).\nThis creates an economically-barred identity, which we might ascribe blame to, and perhaps with sufficient amount of proofs, allow someone to create a \"proof-of-bad-behavior\" that can be believed by other nodes on the network.\nThe locked up fidelity bonds are an additional cost that an attacker must bear which their possible victims will not bear.\n\nPerhaps the \"superbolt network\" idea might consider adding such a mitigation, as it also requires some form of persistent identity anyway.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-04-06T01:20:18",
                "message_text_only": "Hi ZmnSCPxj,\n\n        This is a rework of the old unwrap-the-onion proposal, with\nsome important bits missing.\n\n> Secondly, C needs to prove that the channel it is willing to close involves the payment attempt, and is not some other channel closure that it is attempting to use to fulfill its own soft timeout.\n> Since the unilateral close transaction *is* the proof-of-closure, B (and A) can inspect the transaction outputs and see (with some additional data from C) that one of the outputs is to an HTLC that matches the payment hash.\n>\n> Thus, B (and A) can believe that the proof-of-closure proves that whoever is presenting it is free of wrongdoing, as whoever is actually causing the delay has been punished (by someone being willing to close a channel with the culprit), and that the proof-of-closure commits to this particular payment attempt and no other (because it commits to a particular payment hash).\n\nAs you note below, the payment might be considered dust, or an\nunresponsive peer has not yet acked the HTLC.\n\nMy previous proposal was to limit the damage somewhat by requiring that\nC offer a signed list of some limited number of HTLCs it is claiming\nwere caught, alongside the closure proof (you can merkle this, but\nthat's a detail).  That closure claim gets socialized, and if there are\nmultiple different claim lists for the tx then C is a bad actor and we\nno longer respect its closure proof.\n\nYou also missed how the timeout would work, which is important.  How\nlong does node N wait for a proof?  In my construction, it's 30 seconds,\nplus get another 30 seconds for each decryption of the onion it\nreceives.\n\nOtherwise, you can't know how long you've got to provide this closure\nproof, or how long to wait for it.\n\nIn addition, for closure proofs to work, nodes need to agree on what is\na valid, standard, high-enough-fee commitment transaction.\n\nCheers,\nRusty."
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-13T02:27:59",
                "message_text_only": "Hello,\n      So based on what you have stated as possible scenario of griefing\nattack, does delay in providing the preimage also counted as a form of\ngriefing in htlc? Like given the path A->B->C->D, what if C and D has a\nlock time of 144 blocks and D responds after 142 block time elapses,\nclaiming the money locked with D?\n\nOn Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Introduction\n> ============\n>\n> Given the fact that contracts on offchain protocols need to be enforceable\n> onchain as well, timelocks involved in multi-hop payments are measured in\n> blocks.\n> This is because the blockchain can only (third-party-verifiably) enforce\n> timeouts in units of entire blocks.\n> This leads to very long timeouts for payment delivery, thus multi-hop\n> offchain payment attempts can be, deliberately or accidentally, be in a\n> \"pending\" state up to the very large timeouts involved.\n>\n> Deliberately setting up a multi-hop payment such that it will be in a\n> \"pending\" state for long periods of time is colloquially known as a\n> \"griefing attack\".\n> In this article, we assess various proposed solutions to mitigate the\n> effects of griefing attacks, and propose a particular solution,\n> proof-of-closure, as well, that requires significant changes to the update\n> state machine.\n>\n> Digression: Why Grief?\n> ======================\n>\n> Before embarking on our investigation for solutions to the griefing\n> problem, we should first wonder if griefing is, in fact, a problem.\n>\n> This brings up the question of: why would anybody grief at all?\n>\n> Humans, like cats and other less-sapient pieces of walking meat, often\n> find enjoyment in causing the suffering of others for no immediate direct\n> gain to themselves, as a public demonstration of dominance over those they\n> make suffer (aka \"shits and giggles\", which, if executed correctly, can\n> lead to eventual direct gains to themselves or their progeny or relatives\n> or allies, but such details are often outside the ken of the very beings\n> who execute such survival strategies: brains are pieces of meat that have\n> been hacked to act as action-reaction engines, but are not sophisticated\n> enough to execute as pure rationality engines at all times).\n> Fortunately, in the Bitcoin world, only purely rational beings of pure\n> selfishness can exist in the long run, thus we can neglect such motivations\n> as mere noise.\n>\n> First, let us investigate *how* griefing attacks can be performed.\n>\n> * An intermediate node in a multi-hop attempt can delay forwarding or\n> failing an incoming HTLC.\n> * A final node in a payment attempt can delay claiming an incoming HTLC.\n>\n> Let us consider a purely rational intermediate node of pure selfishness:\n>\n> * If it forwards as soon as possible, it can earn fees, and also speed up\n> the release of the HTLC-locked funds so that they can reuse those funds as\n> liquidity for further payment attempts.\n> * Thus, delaying an HTLC is not selfishly-rational for an intermediate\n> node.\n>\n> Thus, for an intermediate node, it seems there is no selfishly-rational\n> motivation to execute a griefing attack on an arbitrary payment attempt.\n> We can then conclude that an intermediate that delays a payment would do\n> so, not of its own rational self-interest, but as an accident, such as an\n> unforeseen connectivity or power failure.\n>\n> However, things are different when we consider a non-arbitrary payment.\n> Suppose a node were to make a payment attempt to itself, and deliberately\n> delay claiming this self-payment.\n> This lets any single node, *who happens to own large liquidity*, to lock\n> up the liquidity of other nodes.\n>\n> The motivation to lock up the liquidity of other nodes is to *eliminate\n> competition*.\n> Suppose we have a network as below:\n>\n>     A -- B -- C\n>       \\     /\n>        \\   /\n>         \\ /\n>          E\n>\n> When A and C want to transact with one another, they may choose to route\n> via either B or E.\n> B and E are therefore competitors in the business of forwarding payments.\n>\n> But suppose E has much larger channels AE and CE than the channels of AB\n> and CB.\n> For example, suppose E has 100mBTC perfectly-balanced channels while B has\n> only 10mBTC perfectly-balanced channels, as all things should be in\n> simplified models of reality.\n> E can then \"take out the competition\" by making a 5mBTC self-payment along\n> E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing\n> to claim the payment, tying up all the liquidity of the channels of B.\n> By doing so, it can ensure that A and C will always fail to pay via B,\n> even if they wish to transact in amounts less than 5mBTC.\n> E thereby eliminates B as a competitor.\n>\n> This demonstrates that griefing attacks will be motivated, such that such\n> attacks will be performed by payers and payees *against intermediate nodes*.\n> Intermediate nodes have no motivation to attack payers and payees (those\n> are their potential customers in the business of forwarding payments, and\n> attacking potential customers is bad business: such attacking intermediate\n> nodes will be removed economically in the long run).\n> However, payers and payees can become motivated to attack intermediate\n> nodes, if the \"payer\" and \"payee\" are actually competitor intermediate\n> nodes.\n>\n> (We can observe that this is always a possibility even outside of\n> Lightning: a service or product provider has no incentive to attack its\n> customers (\"the customer is always right\"), but have an incentive to\n> *pretend* to be a customer of a competitor and attack them.)\n>\n> We will keep this fact in mind: active griefing attacks are attacks *on*\n> intermediate nodes, not *by* intermediate nodes, because there is no\n> economic incentive for intermediate nodes to attack their customers.\n>\n> Previous Proposed Solutions\n> ===========================\n>\n> Time-Spent Reporting\n> --------------------\n>\n> At each channel along the route, the time spent by a node to handle its\n> forwarding is recorded, and reported upstream in the route.\n>\n> Unfortunately, this solution protects payers from intermediate nodes and\n> payees: it does not protect intermediate nodes from colluding payers and\n> payees.\n> Even if an intermediate node knows that a particular node is consistently\n> slow via a previous time-spent report, it will not be able, with our\n> current onion routing, determine if an onion packet it just received will\n> or will not go through the known-slow node.\n> Thus, an intermediate node would not be able to defend against distant\n> payees that, with a colluding payer, will not claim a particular payment.\n>\n> As we have established, an active griefing atttack will never be\n> deliberately performed by a selfishly-rational intermediate node.\n> Thus, this solution protects against the wrong thing: it protects payers\n> against slow/unreliable intermediate nodes, it does not protect\n> intermediate nodes against malicious payer/payee collusions.\n> It protects only against intermediate nodes that inadvertently go offline\n> during forwarding, but such nodes will inevitably lose out on the\n> forwarding market anyway, and will disappear in the long run.\n>\n> Up-Front Payment\n> ----------------\n>\n> Payers pay for an attempt, not just the successful completion of an\n> attempt.\n>\n> A variation on this is that the payer (or payee) continuously pays as long\n> as the payment is pending.\n> Further variations include paying by other means, such as just locking\n> funds or paying with proof-of-work.\n>\n> While it certainly erects economic barriers against payer/payee collusions\n> attacking intermediate nodes, it *also* erects economic barriers against\n> normal, non-malicious payments.\n>\n> We can consider that economic barriers against non-malicious, low-value,\n> high-frequency payments (\"micropayments\") may be enough that such payments\n> become infeasible if we impose up-front payment for mere attempts.\n> Thus, while this solution is certainly something we can consider, we must\n> be reluctant to use it due to its up-front, strict-evaluation behavior.\n>\n> Proof-Of-Closure\n> ================\n>\n> Observing the above, we want the properties for a \"good\" solution to\n> griefing attacks to be:\n>\n> * It should protect intermediate nodes against payer/payee collusions.\n> * It should only come into play upon detection of an attack.\n>\n> We now present proof-of-closure, which (we hope) has the above properties.\n>\n> We can consider instead a softer timeout, distinct from the HTLC\n> block-based timeout.\n> This softer timeout is measurable in fractions of a second, e.g. units of\n> 0.1 seconds.\n>\n> Each node on the network advertises, in addition to a block-based\n> `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> Further, each invoice contains, in addition to a block-based `final_cltv`,\n> a `final_timeout` in units of 0.1 seconds.\n>\n> Thus, there are two timeouts:\n>\n> * The current \"hard\" block-based timeout that is enforceable onchain.\n> * A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n>\n> The soft timeout, as mentioned, is not enforceable onchain.\n> Instead, enforcement of the soft timeout *is* the act of putting the\n> channel state onchain.\n>\n> Now, for the current \"hard\" block-based timeout, we already have a\n> reaction.\n> If the HTLC \"hard\" timeout is approaching:\n>\n> * Drop the channel onchain and enforce the hard timeout onchain to reclaim\n> the funds in the HTLCs.\n> * Wait for the onchain action to be deeply resolved (either timelock or\n> hashlock branch is confirmed deeply) and report the result (success or\n> fail) upstream.\n>\n> What happens if the \"soft\" timeout is violated?\n>\n> * Drop the channel onchain.\n> * Report the channel closure upstream.\n>\n> The \"hard\" timeout is cancelled in any of these two conditions:\n>\n> * A success is reported via `update_fulfill_htlc`, OR,\n> * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably\n> removed from the latest commitments/state(s) of the channel.\n>\n> The \"soft\" timeout is cancelled in any of these three conditions, the\n> first two of which are the same as above:\n>\n> * A success is reported via `update_fulfill_htlc`, OR,\n> * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably\n> removed from the latest commitments/state(s) of the channel, OR\n> * A channel closure is reported.\n>\n> Let us fill this in more detail.\n>\n> Suppose we have a payment route A->B->C->E.\n>\n> Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement\n> monotonically at each hop.\n> Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n>\n> * Suppose E then delays claiming the payment and violates the \"soft\"\n> timeout.\n> * C then drops the CE channel onchain.\n> * C reports, before its own timeout (slightly larger than the timeout\n> imposed on E), the closing of the channel CE, to B.\n> * B validates this report, and if valid, propagates the report to A.\n> * A validates this report, and if valid, accepts that the payment will be\n> \"stuck\" for up to the hard timeout it imposed on B.\n>\n> C has to report back to B in order to prevent B from closing the BC\n> channel, and B has to report back to A in order to prevent A from closing\n> the AB channel.\n> The decrementing seconds-unit timeouts are needed for each hop, for the\n> same reason that decrementing block-unit timeouts are needed.\n>\n> Since E is motivated to attack intermediate nodes because it wants to\n> redirect payment forwards through itself rather than its competitotrs,\n> having one of its channels closed (which prevents it from being used for\n> forwarding) is directly opposed to its end goal of getting more money,\n> thus, we can believe the action of closing a channel involved in a griefing\n> attack is sufficient disincentive.\n>\n> The major drawback is that enforcement of the soft timeout *is* a channel\n> closure, which is generally a negative for the network.\n> This is not a remote attack vector, since a node can only trigger this\n> closure if it is able to stall the fulfillment or failure of an HTLC on a\n> channel, which generally means the node triggering this closure can only do\n> so for its own channels (or it is able to, via a separate mechanism,\n> remotely crash a different node).\n>\n> Proving Channel Closes\n> ----------------------\n>\n> What C *really* needs to prove is that:\n>\n> * It is *willing* to close a channel due to a violation of the soft\n> timeout.\n> * The channel it is willing to close was, in fact, involved in the same\n> payment attempt.\n>\n> With the above, B can believe that C was innocent of wrongdoing, because:\n>\n> * C would only be wiling to close a channel in case of a protocol\n> violation, in this case, a violation of the soft timeout.\n> * The channel it closed was closed because of this payment attempt, and\n> not because of another payment attempt, or some other unrelated channel\n> being unilaterally closed.\n>\n> First, what C needs to prove is *NOT*, in fact, actual channel closure: it\n> needs to prove a *willingness* to close a channel.\n> Thus, it does not require the channel to actually be *closed* yet, i.e. it\n> does not have to wait for onchain activity that the channel closure is in a\n> mempool and is confirmed deeply onchain etc etc.\n>\n> Thus, to prove a *willingness to close* rather than an actual close, C can\n> provide the unilateral close of the channel CE.\n> The act of unilaterally closing a channel is the publication of the\n> transaction(s) making up the unilateral close.\n> Thus, if C is *willing* to close the channel, it is willing to publish the\n> transaction(s) involved, and thus, providing the unilateral close to B and\n> further upstream, shows a willingness to close the channel.\n>\n> B then validates the provided proof-of-closure by checking that the\n> unilateral close transaction is either onchain, in the mempool, or that it\n> spends a TXO that is not currently spent by another transaction.\n> In the case the unilateral close transaction is not confirmed and in the\n> mempool, B can speed up its propagation on the Bitcoin layer by putting it\n> in its own mempool as well --- after all, C is willing to close the channel\n> to exonerate itself and punish the actual culprit, and B putting the\n> unilateral close in its own mempool can only help C in what it is willing\n> to do.\n>\n> Secondly, C needs to prove that the channel it is willing to close\n> involves the payment attempt, and is not some other channel closure that it\n> is attempting to use to fulfill its own soft timeout.\n> Since the unilateral close transaction *is* the proof-of-closure, B (and\n> A) can inspect the transaction outputs and see (with some additional data\n> from C) that one of the outputs is to an HTLC that matches the payment hash.\n>\n> Thus, B (and A) can believe that the proof-of-closure proves that whoever\n> is presenting it is free of wrongdoing, as whoever is actually causing the\n> delay has been punished (by someone being willing to close a channel with\n> the culprit), and that the proof-of-closure commits to this particular\n> payment attempt and no other (because it commits to a particular payment\n> hash).\n>\n> Further, if CE is closed by E dropping it onchain rather than C, C will\n> still be able to fulfill its own soft timeout by taking the closing\n> transaction from E, which should still contain the HTLC.\n> Indeed, neither A nor B will particularly care (nor need to know) who\n> dropped the channel onchain, or (for A) that the channel participants are C\n> and E.\n>\n> Update State Shenanigans\n> ------------------------\n>\n> Bitcoin update mechanisms are complicated things, and it may be possible\n> for an attacking payee E to fool around with the update state machine to\n> make it difficult for C to report a willingness to close CE.\n>\n> In particular, I quote here the relevant passages from `lightning-rfc`,\n> `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update\n> mechanism:\n>\n> > Thus each update traverses through the following states:\n> >\n> > 1. pending on the receiver\n> > 2. in the receiver's latest commitment transaction\n> > 3. ... and the receiver's previous commitment transaction has been\n> revoked,\n> >    and the update is pending on the sender\n> > 4. ... and in the sender's latest commitment transaction\n> > 5. ... and the sender's previous commitment transaction has been revoked\n>\n> The payee E is the \"receiver\" in this context.\n>\n> In this case, once the update has reached step 2, then E has a commitment\n> transaction that it can put onchain, that contains an HTLC it can claim.\n> From this step onward, C cannot send a failure (i.e. it cannot send back\n> an `update_fail_htlc`) back to B, because E could drop its latest\n> commitment onchain and claim the HTLC onchain.\n>\n> However, until step 4, C does not have a unilateral close containing the\n> HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that\n> refers to the payment.\n>\n> Thus, between steps 2 to 4, C cannot safely respond to its own soft\n> timeout.\n> C cannot respond with a failure, as E could then drop its latest\n> commitment transaction onchain and claim the payment from C, and extract\n> money from C that way.\n> C also cannot respond with a proof-of-closure, as it does not have a\n> transaction that it can use to provide this proof.\n>\n> The best that C can do would be to impose an even shorter timeout between\n> steps 2 and 4 above, and to drop its current commitment transaction (which\n> does not contain the HTLC yet and thus does not constitute a valid\n> proof-of-closure) onchain.\n> In between the time it drops the commitment transaction and its own\n> incoming soft timeout, there is a chance, however small, that this\n> transaction will be confirmed, and the channel will (with high probability)\n> settle in a state where the HTLC is not instantiated, thus C can safely\n> fail its incoming HTLC (not show a proof-of-closure, since that is not\n> possible for C to do) without risk of loss, just prior to its own soft\n> timeout.\n>\n> Of course, C is still at risk here: E could collude with miners via a\n> side-channel fee offer to confirm its commitment transaction with the HTLC\n> present, and ensure that C is liable for the HTLC value.\n>\n> With Decker-Russell-Osuntokun, we can remove this risk by requiring a\n> ritual as follows:\n>\n> 1.  C requests exclusive access to update their single shared state.\n>   * This can be done via a variety of sub-protocols, including a fair coin\n> toss in case of near-simultaneous requests for exclusive locks on both\n> sides.\n> 2.  C provides the details of the new HTLC to E.\n> 3.  C and E generate the new state transaction and exchange signatures for\n> it.\n> 4.  C and E generate (without signing) the new update transaction.\n> 5.  E provides the signature (or share of signature, if MuSig) for the new\n> update transaction to C.\n> 6.  C provides the signature for the new update transaction to E, which\n> releases the exclusive lock on the shared state atomically with the\n> finalization of the new update transaction.\n>\n> Prior to step 5, C can simply fail the incoming HTLC from B in case its\n> own soft timeout is near.\n> Even if E performs step 5 after C has already failed the incoming HTLC\n> from B, C can simply not perform step 6 and drop the channel onchain with\n> the previous update and state transactions.\n>\n> With Poon-Dryja, we will have to rearrange the order in which we perform\n> things, effectively adding an extra communications turnaround between the\n> participants.\n> Specifically, the order would have to be revised to:\n>\n> > 1. pending on the sender\n> > 2. in the sender's latest commitment transaction\n> > 3. ... and the sender's previous commitment transaction has been revoked,\n> >    and the update is pending on the receiver\n> > 4. ... and in the receiver's latest commitment transaction\n> > 5. ... and the receiver's previous commitment transaction has been\n> revoked\n>\n> This allows the sender (C in our context) to provide a proof-of-closure\n> after step 2, and before step 2, C can safely return a failure with\n> `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it\n> can still use the previous commitment that still has no HTLC).\n>\n> Of course, this change will require redesigning the update state machine,\n> increasing the number of communication turnarounds, and creating a subtle\n> incompatbility when transitioning a payment from a hop that knows only the\n> old update state machine to a hop that knows the new update state machine.\n>\n> Purely Falsified Proof-Of-Closure\n> ---------------------------------\n>\n> Of course, the attacking node E might want to create a false\n> proof-of-closure.\n> E can do this by simulating a Lightning channel: lock an amount of funds\n> in a 2-of-2 (where E controls both keys), then spend it in a set of\n> transactions mimicking the unilateral close.\n>\n> We observe, however, that the overhead of simulating a Lightning channel\n> is the same as the overhead of actually creating and closing a Lightning\n> channel.\n> Since the punishment of proof-of-closure is to force attackers to have\n> their channels closed, we can consider that this simulation of a channel\n> open and close is sufficient as well.\n>\n> Future-Proofing\n> ---------------\n>\n> This sketch of proof-of-closure can be used for any update mechanism:\n>\n> * With Poon-Dryja, C can use its own commitment transaction as the\n> proof-of-closure.\n> * With Decker-Wattenhofer, C can give all the offchain transactions up to\n> the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> * With Deckker-Russell-Osuntokun, C can give the latest update and state\n> trnsaction.\n>\n> Basically, we expect that for now, and in the future, any update mechanism\n> worth consideration will have a concept of \"unilateral close\" where a\n> channel can be dropped onchain, using data that only one of the channel\n> participants holds.\n>\n> Such a unilateral close will be a sequence of one or more valid\n> transactions, terminating in a transaction containing an HTLC-like contract\n> in one of its outputs.\n>\n> Thus, to validate the unilateral close, it is only required to validate\n> all the transactions contained in the proof-of-closure, and see that the\n> last transaction has an HTLC output.\n>\n> The limitations are thus:\n>\n> * The acceptable forms of HTLC would need to be agreed-upon by the entire\n> network.\n> * Implementations would need to be able to assess, in a\n> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n>\n> Payment Decorrelation and Payment Points\n> ----------------------------------------\n>\n> Of course, having a single payment hash for the entire payment attempt is\n> a privacy loss, which we intend to fix in the near future by using payment\n> points, and adding a blinding scalar at each hop, aka. payment\n> decorrelation.\n>\n> Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> Further, the payment point at each hop will be changed at each hop, in\n> order to prevent decorrelation.\n>\n> Thus, C needs to provide proofs:\n>\n> * That an apparent singlesig on the unilateral close output is in fact a\n> PTLC.\n>   C needs to provide:\n>   * A target point P.\n>   * A partial signature that would spend that singlesig for a particular\n> sighash.\n>   * An adaptor signature which, with knowledge of the completed signature,\n> adaptor signature, and sighash message, would have revealed the scalar\n> behind P.\n> * That the PTLC belongs to the same payment attempt as what B offered to C.\n>   C needs to provide:\n>   * The C-only blinding factor that is the difference between the payment\n> point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n>\n> Then, when B needs to propagate the proof-of-closure back to A, B simply\n> adds its own blinding factor to the reported blinding factor, in order to\n> convince A that this is the same payment attempt.\n>\n> As we have brought up privacy, we observe that, when this mechanism\n> triggers, there is a mild privacy loss, in that intermediate nodes now know\n> some channel closure that is related to this payment, and can thus\n> determine the exact path that the payment attempt went through, at least\n> until the channel being closed.\n> However, proof-of-closure is only propagated in case of violation of the\n> soft timeout, so for normal non-malicious payments, proof-of-closure does\n> not cause any privacy loss.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200413/2826be68/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-13T02:50:57",
                "message_text_only": "Good morning Subhra,\n\n> Hello,\n> \u00a0 \u00a0 \u00a0 So based on what you have stated as possible scenario of griefing attack, does delay in providing the preimage also counted as a form of griefing in htlc? Like given the path A->B->C->D, what if C and D has a lock time of 144 blocks and D responds after 142 block time elapses, claiming the money locked with D?\n\nThat ***is*** the griefing attack.\n\nRegards,\nZmnSCPxj\n\n>\n> On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> > Introduction\n> > ============\n> >\n> > Given the fact that contracts on offchain protocols need to be enforceable onchain as well, timelocks involved in multi-hop payments are measured in blocks.\n> > This is because the blockchain can only (third-party-verifiably) enforce timeouts in units of entire blocks.\n> > This leads to very long timeouts for payment delivery, thus multi-hop offchain payment attempts can be, deliberately or accidentally, be in a \"pending\" state up to the very large timeouts involved.\n> >\n> > Deliberately setting up a multi-hop payment such that it will be in a \"pending\" state for long periods of time is colloquially known as a \"griefing attack\".\n> > In this article, we assess various proposed solutions to mitigate the effects of griefing attacks, and propose a particular solution, proof-of-closure, as well, that requires significant changes to the update state machine.\n> >\n> > Digression: Why Grief?\n> > ======================\n> >\n> > Before embarking on our investigation for solutions to the griefing problem, we should first wonder if griefing is, in fact, a problem.\n> >\n> > This brings up the question of: why would anybody grief at all?\n> >\n> > Humans, like cats and other less-sapient pieces of walking meat, often find enjoyment in causing the suffering of others for no immediate direct gain to themselves, as a public demonstration of dominance over those they make suffer (aka \"shits and giggles\", which, if executed correctly, can lead to eventual direct gains to themselves or their progeny or relatives or allies, but such details are often outside the ken of the very beings who execute such survival strategies: brains are pieces of meat that have been hacked to act as action-reaction engines, but are not sophisticated enough to execute as pure rationality engines at all times).\n> > Fortunately, in the Bitcoin world, only purely rational beings of pure selfishness can exist in the long run, thus we can neglect such motivations as mere noise.\n> >\n> > First, let us investigate *how* griefing attacks can be performed.\n> >\n> > * An intermediate node in a multi-hop attempt can delay forwarding or failing an incoming HTLC.\n> > * A final node in a payment attempt can delay claiming an incoming HTLC.\n> >\n> > Let us consider a purely rational intermediate node of pure selfishness:\n> >\n> > * If it forwards as soon as possible, it can earn fees, and also speed up the release of the HTLC-locked funds so that they can reuse those funds as liquidity for further payment attempts.\n> > * Thus, delaying an HTLC is not selfishly-rational for an intermediate node.\n> >\n> > Thus, for an intermediate node, it seems there is no selfishly-rational motivation to execute a griefing attack on an arbitrary payment attempt.\n> > We can then conclude that an intermediate that delays a payment would do so, not of its own rational self-interest, but as an accident, such as an unforeseen connectivity or power failure.\n> >\n> > However, things are different when we consider a non-arbitrary payment.\n> > Suppose a node were to make a payment attempt to itself, and deliberately delay claiming this self-payment.\n> > This lets any single node, *who happens to own large liquidity*, to lock up the liquidity of other nodes.\n> >\n> > The motivation to lock up the liquidity of other nodes is to *eliminate competition*.\n> > Suppose we have a network as below:\n> >\n> > \u00a0 \u00a0 A -- B -- C\n> > \u00a0 \u00a0 \u00a0 \\\u00a0 \u00a0 \u00a0/\n> > \u00a0 \u00a0 \u00a0 \u00a0\\\u00a0 \u00a0/\n> > \u00a0 \u00a0 \u00a0 \u00a0 \\ /\n> > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0E\n> >\n> > When A and C want to transact with one another, they may choose to route via either B or E.\n> > B and E are therefore competitors in the business of forwarding payments.\n> >\n> > But suppose E has much larger channels AE and CE than the channels of AB and CB.\n> > For example, suppose E has 100mBTC perfectly-balanced channels while B has only 10mBTC perfectly-balanced channels, as all things should be in simplified models of reality.\n> > E can then \"take out the competition\" by making a 5mBTC self-payment along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing to claim the payment, tying up all the liquidity of the channels of B.\n> > By doing so, it can ensure that A and C will always fail to pay via B, even if they wish to transact in amounts less than 5mBTC.\n> > E thereby eliminates B as a competitor.\n> >\n> > This demonstrates that griefing attacks will be motivated, such that such attacks will be performed by payers and payees *against intermediate nodes*.\n> > Intermediate nodes have no motivation to attack payers and payees (those are their potential customers in the business of forwarding payments, and attacking potential customers is bad business: such attacking intermediate nodes will be removed economically in the long run).\n> > However, payers and payees can become motivated to attack intermediate nodes, if the \"payer\" and \"payee\" are actually competitor intermediate nodes.\n> >\n> > (We can observe that this is always a possibility even outside of Lightning: a service or product provider has no incentive to attack its customers (\"the customer is always right\"), but have an incentive to *pretend* to be a customer of a competitor and attack them.)\n> >\n> > We will keep this fact in mind: active griefing attacks are attacks *on* intermediate nodes, not *by* intermediate nodes, because there is no economic incentive for intermediate nodes to attack their customers.\n> >\n> > Previous Proposed Solutions\n> > ===========================\n> >\n> > Time-Spent Reporting\n> > --------------------\n> >\n> > At each channel along the route, the time spent by a node to handle its forwarding is recorded, and reported upstream in the route.\n> >\n> > Unfortunately, this solution protects payers from intermediate nodes and payees: it does not protect intermediate nodes from colluding payers and payees.\n> > Even if an intermediate node knows that a particular node is consistently slow via a previous time-spent report, it will not be able, with our current onion routing, determine if an onion packet it just received will or will not go through the known-slow node.\n> > Thus, an intermediate node would not be able to defend against distant payees that, with a colluding payer, will not claim a particular payment.\n> >\n> > As we have established, an active griefing atttack will never be deliberately performed by a selfishly-rational intermediate node.\n> > Thus, this solution protects against the wrong thing: it protects payers against slow/unreliable intermediate nodes, it does not protect intermediate nodes against malicious payer/payee collusions.\n> > It protects only against intermediate nodes that inadvertently go offline during forwarding, but such nodes will inevitably lose out on the forwarding market anyway, and will disappear in the long run.\n> >\n> > Up-Front Payment\n> > ----------------\n> >\n> > Payers pay for an attempt, not just the successful completion of an attempt.\n> >\n> > A variation on this is that the payer (or payee) continuously pays as long as the payment is pending.\n> > Further variations include paying by other means, such as just locking funds or paying with proof-of-work.\n> >\n> > While it certainly erects economic barriers against payer/payee collusions attacking intermediate nodes, it *also* erects economic barriers against normal, non-malicious payments.\n> >\n> > We can consider that economic barriers against non-malicious, low-value, high-frequency payments (\"micropayments\") may be enough that such payments become infeasible if we impose up-front payment for mere attempts.\n> > Thus, while this solution is certainly something we can consider, we must be reluctant to use it due to its up-front, strict-evaluation behavior.\n> >\n> > Proof-Of-Closure\n> > ================\n> >\n> > Observing the above, we want the properties for a \"good\" solution to griefing attacks to be:\n> >\n> > * It should protect intermediate nodes against payer/payee collusions.\n> > * It should only come into play upon detection of an attack.\n> >\n> > We now present proof-of-closure, which (we hope) has the above properties.\n> >\n> > We can consider instead a softer timeout, distinct from the HTLC block-based timeout.\n> > This softer timeout is measurable in fractions of a second, e.g. units of 0.1 seconds.\n> >\n> > Each node on the network advertises, in addition to a block-based `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > Further, each invoice contains, in addition to a block-based `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> >\n> > Thus, there are two timeouts:\n> >\n> > * The current \"hard\" block-based timeout that is enforceable onchain.\n> > * A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n> >\n> > The soft timeout, as mentioned, is not enforceable onchain.\n> > Instead, enforcement of the soft timeout *is* the act of putting the channel state onchain.\n> >\n> > Now, for the current \"hard\" block-based timeout, we already have a reaction.\n> > If the HTLC \"hard\" timeout is approaching:\n> >\n> > * Drop the channel onchain and enforce the hard timeout onchain to reclaim the funds in the HTLCs.\n> > * Wait for the onchain action to be deeply resolved (either timelock or hashlock branch is confirmed deeply) and report the result (success or fail) upstream.\n> >\n> > What happens if the \"soft\" timeout is violated?\n> >\n> > * Drop the channel onchain.\n> > * Report the channel closure upstream.\n> >\n> > The \"hard\" timeout is cancelled in any of these two conditions:\n> >\n> > * A success is reported via `update_fulfill_htlc`, OR,\n> > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel.\n> >\n> > The \"soft\" timeout is cancelled in any of these three conditions, the first two of which are the same as above:\n> >\n> > * A success is reported via `update_fulfill_htlc`, OR,\n> > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > * A channel closure is reported.\n> >\n> > Let us fill this in more detail.\n> >\n> > Suppose we have a payment route A->B->C->E.\n> >\n> > Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement monotonically at each hop.\n> > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n> >\n> > * Suppose E then delays claiming the payment and violates the \"soft\" timeout.\n> > * C then drops the CE channel onchain.\n> > * C reports, before its own timeout (slightly larger than the timeout imposed on E), the closing of the channel CE, to B.\n> > * B validates this report, and if valid, propagates the report to A.\n> > * A validates this report, and if valid, accepts that the payment will be \"stuck\" for up to the hard timeout it imposed on B.\n> >\n> > C has to report back to B in order to prevent B from closing the BC channel, and B has to report back to A in order to prevent A from closing the AB channel.\n> > The decrementing seconds-unit timeouts are needed for each hop, for the same reason that decrementing block-unit timeouts are needed.\n> >\n> > Since E is motivated to attack intermediate nodes because it wants to redirect payment forwards through itself rather than its competitotrs, having one of its channels closed (which prevents it from being used for forwarding) is directly opposed to its end goal of getting more money, thus, we can believe the action of closing a channel involved in a griefing attack is sufficient disincentive.\n> >\n> > The major drawback is that enforcement of the soft timeout *is* a channel closure, which is generally a negative for the network.\n> > This is not a remote attack vector, since a node can only trigger this closure if it is able to stall the fulfillment or failure of an HTLC on a channel, which generally means the node triggering this closure can only do so for its own channels (or it is able to, via a separate mechanism, remotely crash a different node).\n> >\n> > Proving Channel Closes\n> > ----------------------\n> >\n> > What C *really* needs to prove is that:\n> >\n> > * It is *willing* to close a channel due to a violation of the soft timeout.\n> > * The channel it is willing to close was, in fact, involved in the same payment attempt.\n> >\n> > With the above, B can believe that C was innocent of wrongdoing, because:\n> >\n> > * C would only be wiling to close a channel in case of a protocol violation, in this case, a violation of the soft timeout.\n> > * The channel it closed was closed because of this payment attempt, and not because of another payment attempt, or some other unrelated channel being unilaterally closed.\n> >\n> > First, what C needs to prove is *NOT*, in fact, actual channel closure: it needs to prove a *willingness* to close a channel.\n> > Thus, it does not require the channel to actually be *closed* yet, i.e. it does not have to wait for onchain activity that the channel closure is in a mempool and is confirmed deeply onchain etc etc.\n> >\n> > Thus, to prove a *willingness to close* rather than an actual close, C can provide the unilateral close of the channel CE.\n> > The act of unilaterally closing a channel is the publication of the transaction(s) making up the unilateral close.\n> > Thus, if C is *willing* to close the channel, it is willing to publish the transaction(s) involved, and thus, providing the unilateral close to B and further upstream, shows a willingness to close the channel.\n> >\n> > B then validates the provided proof-of-closure by checking that the unilateral close transaction is either onchain, in the mempool, or that it spends a TXO that is not currently spent by another transaction.\n> > In the case the unilateral close transaction is not confirmed and in the mempool, B can speed up its propagation on the Bitcoin layer by putting it in its own mempool as well --- after all, C is willing to close the channel to exonerate itself and punish the actual culprit, and B putting the unilateral close in its own mempool can only help C in what it is willing to do.\n> >\n> > Secondly, C needs to prove that the channel it is willing to close involves the payment attempt, and is not some other channel closure that it is attempting to use to fulfill its own soft timeout.\n> > Since the unilateral close transaction *is* the proof-of-closure, B (and A) can inspect the transaction outputs and see (with some additional data from C) that one of the outputs is to an HTLC that matches the payment hash.\n> >\n> > Thus, B (and A) can believe that the proof-of-closure proves that whoever is presenting it is free of wrongdoing, as whoever is actually causing the delay has been punished (by someone being willing to close a channel with the culprit), and that the proof-of-closure commits to this particular payment attempt and no other (because it commits to a particular payment hash).\n> >\n> > Further, if CE is closed by E dropping it onchain rather than C, C will still be able to fulfill its own soft timeout by taking the closing transaction from E, which should still contain the HTLC.\n> > Indeed, neither A nor B will particularly care (nor need to know) who dropped the channel onchain, or (for A) that the channel participants are C and E.\n> >\n> > Update State Shenanigans\n> > ------------------------\n> >\n> > Bitcoin update mechanisms are complicated things, and it may be possible for an attacking payee E to fool around with the update state machine to make it difficult for C to report a willingness to close CE.\n> >\n> > In particular, I quote here the relevant passages from `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update mechanism:\n> >\n> > > Thus each update traverses through the following states:\n> > >\n> > > 1. pending on the receiver\n> > > 2. in the receiver's latest commitment transaction\n> > > 3. ... and the receiver's previous commitment transaction has been revoked,\n> > >\u00a0 \u00a0 and the update is pending on the sender\n> > > 4. ... and in the sender's latest commitment transaction\n> > > 5. ... and the sender's previous commitment transaction has been revoked\n> >\n> > The payee E is the \"receiver\" in this context.\n> >\n> > In this case, once the update has reached step 2, then E has a commitment transaction that it can put onchain, that contains an HTLC it can claim.\n> > From this step onward, C cannot send a failure (i.e. it cannot send back an `update_fail_htlc`) back to B, because E could drop its latest commitment onchain and claim the HTLC onchain.\n> >\n> > However, until step 4, C does not have a unilateral close containing the HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that refers to the payment.\n> >\n> > Thus, between steps 2 to 4, C cannot safely respond to its own soft timeout.\n> > C cannot respond with a failure, as E could then drop its latest commitment transaction onchain and claim the payment from C, and extract money from C that way.\n> > C also cannot respond with a proof-of-closure, as it does not have a transaction that it can use to provide this proof.\n> >\n> > The best that C can do would be to impose an even shorter timeout between steps 2 and 4 above, and to drop its current commitment transaction (which does not contain the HTLC yet and thus does not constitute a valid proof-of-closure) onchain.\n> > In between the time it drops the commitment transaction and its own incoming soft timeout, there is a chance, however small, that this transaction will be confirmed, and the channel will (with high probability) settle in a state where the HTLC is not instantiated, thus C can safely fail its incoming HTLC (not show a proof-of-closure, since that is not possible for C to do) without risk of loss, just prior to its own soft timeout.\n> >\n> > Of course, C is still at risk here: E could collude with miners via a side-channel fee offer to confirm its commitment transaction with the HTLC present, and ensure that C is liable for the HTLC value.\n> >\n> > With Decker-Russell-Osuntokun, we can remove this risk by requiring a ritual as follows:\n> >\n> > 1.\u00a0 C requests exclusive access to update their single shared state.\n> > \u00a0 * This can be done via a variety of sub-protocols, including a fair coin toss in case of near-simultaneous requests for exclusive locks on both sides.\n> > 2.\u00a0 C provides the details of the new HTLC to E.\n> > 3.\u00a0 C and E generate the new state transaction and exchange signatures for it.\n> > 4.\u00a0 C and E generate (without signing) the new update transaction.\n> > 5.\u00a0 E provides the signature (or share of signature, if MuSig) for the new update transaction to C.\n> > 6.\u00a0 C provides the signature for the new update transaction to E, which releases the exclusive lock on the shared state atomically with the finalization of the new update transaction.\n> >\n> > Prior to step 5, C can simply fail the incoming HTLC from B in case its own soft timeout is near.\n> > Even if E performs step 5 after C has already failed the incoming HTLC from B, C can simply not perform step 6 and drop the channel onchain with the previous update and state transactions.\n> >\n> > With Poon-Dryja, we will have to rearrange the order in which we perform things, effectively adding an extra communications turnaround between the participants.\n> > Specifically, the order would have to be revised to:\n> >\n> > > 1. pending on the sender\n> > > 2. in the sender's latest commitment transaction\n> > > 3. ... and the sender's previous commitment transaction has been revoked,\n> > >\u00a0 \u00a0 and the update is pending on the receiver\n> > > 4. ... and in the receiver's latest commitment transaction\n> > > 5. ... and the receiver's previous commitment transaction has been revoked\n> >\n> > This allows the sender (C in our context) to provide a proof-of-closure after step 2, and before step 2, C can safely return a failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it can still use the previous commitment that still has no HTLC).\n> >\n> > Of course, this change will require redesigning the update state machine, increasing the number of communication turnarounds, and creating a subtle incompatbility when transitioning a payment from a hop that knows only the old update state machine to a hop that knows the new update state machine.\n> >\n> > Purely Falsified Proof-Of-Closure\n> > ---------------------------------\n> >\n> > Of course, the attacking node E might want to create a false proof-of-closure.\n> > E can do this by simulating a Lightning channel: lock an amount of funds in a 2-of-2 (where E controls both keys), then spend it in a set of transactions mimicking the unilateral close.\n> >\n> > We observe, however, that the overhead of simulating a Lightning channel is the same as the overhead of actually creating and closing a Lightning channel.\n> > Since the punishment of proof-of-closure is to force attackers to have their channels closed, we can consider that this simulation of a channel open and close is sufficient as well.\n> >\n> > Future-Proofing\n> > ---------------\n> >\n> > This sketch of proof-of-closure can be used for any update mechanism:\n> >\n> > * With Poon-Dryja, C can use its own commitment transaction as the proof-of-closure.\n> > * With Decker-Wattenhofer, C can give all the offchain transactions up to the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> > * With Deckker-Russell-Osuntokun, C can give the latest update and state trnsaction.\n> >\n> > Basically, we expect that for now, and in the future, any update mechanism worth consideration will have a concept of \"unilateral close\" where a channel can be dropped onchain, using data that only one of the channel participants holds.\n> >\n> > Such a unilateral close will be a sequence of one or more valid transactions, terminating in a transaction containing an HTLC-like contract in one of its outputs.\n> >\n> > Thus, to validate the unilateral close, it is only required to validate all the transactions contained in the proof-of-closure, and see that the last transaction has an HTLC output.\n> >\n> > The limitations are thus:\n> >\n> > * The acceptable forms of HTLC would need to be agreed-upon by the entire network.\n> > * Implementations would need to be able to assess, in a Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> >\n> > Payment Decorrelation and Payment Points\n> > ----------------------------------------\n> >\n> > Of course, having a single payment hash for the entire payment attempt is a privacy loss, which we intend to fix in the near future by using payment points, and adding a blinding scalar at each hop, aka. payment decorrelation.\n> >\n> > Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> > Further, the payment point at each hop will be changed at each hop, in order to prevent decorrelation.\n> >\n> > Thus, C needs to provide proofs:\n> >\n> > * That an apparent singlesig on the unilateral close output is in fact a PTLC.\n> > \u00a0 C needs to provide:\n> > \u00a0 * A target point P.\n> > \u00a0 * A partial signature that would spend that singlesig for a particular sighash.\n> > \u00a0 * An adaptor signature which, with knowledge of the completed signature, adaptor signature, and sighash message, would have revealed the scalar behind P.\n> > * That the PTLC belongs to the same payment attempt as what B offered to C.\n> > \u00a0 C needs to provide:\n> > \u00a0 * The C-only blinding factor that is the difference between the payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n> >\n> > Then, when B needs to propagate the proof-of-closure back to A, B simply adds its own blinding factor to the reported blinding factor, in order to convince A that this is the same payment attempt.\n> >\n> > As we have brought up privacy, we observe that, when this mechanism triggers, there is a mild privacy loss, in that intermediate nodes now know some channel closure that is related to this payment, and can thus determine the exact path that the payment attempt went through, at least until the channel being closed.\n> > However, proof-of-closure is only propagated in case of violation of the soft timeout, so for normal non-malicious payments, proof-of-closure does not cause any privacy loss.\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-13T03:39:44",
                "message_text_only": "Ok. But this is a worse situation where C pays money to D but bound to keep\nits resource locked for a longer duration, unlike D not responding and C\nbeing able to unlock after the elapse of lock time.\n\nOn Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n> > Hello,\n> >       So based on what you have stated as possible scenario of griefing\n> attack, does delay in providing the preimage also counted as a form of\n> griefing in htlc? Like given the path A->B->C->D, what if C and D has a\n> lock time of 144 blocks and D responds after 142 block time elapses,\n> claiming the money locked with D?\n>\n> That ***is*** the griefing attack.\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Introduction\n> > > ============\n> > >\n> > > Given the fact that contracts on offchain protocols need to be\n> enforceable onchain as well, timelocks involved in multi-hop payments are\n> measured in blocks.\n> > > This is because the blockchain can only (third-party-verifiably)\n> enforce timeouts in units of entire blocks.\n> > > This leads to very long timeouts for payment delivery, thus multi-hop\n> offchain payment attempts can be, deliberately or accidentally, be in a\n> \"pending\" state up to the very large timeouts involved.\n> > >\n> > > Deliberately setting up a multi-hop payment such that it will be in a\n> \"pending\" state for long periods of time is colloquially known as a\n> \"griefing attack\".\n> > > In this article, we assess various proposed solutions to mitigate the\n> effects of griefing attacks, and propose a particular solution,\n> proof-of-closure, as well, that requires significant changes to the update\n> state machine.\n> > >\n> > > Digression: Why Grief?\n> > > ======================\n> > >\n> > > Before embarking on our investigation for solutions to the griefing\n> problem, we should first wonder if griefing is, in fact, a problem.\n> > >\n> > > This brings up the question of: why would anybody grief at all?\n> > >\n> > > Humans, like cats and other less-sapient pieces of walking meat, often\n> find enjoyment in causing the suffering of others for no immediate direct\n> gain to themselves, as a public demonstration of dominance over those they\n> make suffer (aka \"shits and giggles\", which, if executed correctly, can\n> lead to eventual direct gains to themselves or their progeny or relatives\n> or allies, but such details are often outside the ken of the very beings\n> who execute such survival strategies: brains are pieces of meat that have\n> been hacked to act as action-reaction engines, but are not sophisticated\n> enough to execute as pure rationality engines at all times).\n> > > Fortunately, in the Bitcoin world, only purely rational beings of pure\n> selfishness can exist in the long run, thus we can neglect such motivations\n> as mere noise.\n> > >\n> > > First, let us investigate *how* griefing attacks can be performed.\n> > >\n> > > * An intermediate node in a multi-hop attempt can delay forwarding or\n> failing an incoming HTLC.\n> > > * A final node in a payment attempt can delay claiming an incoming\n> HTLC.\n> > >\n> > > Let us consider a purely rational intermediate node of pure\n> selfishness:\n> > >\n> > > * If it forwards as soon as possible, it can earn fees, and also speed\n> up the release of the HTLC-locked funds so that they can reuse those funds\n> as liquidity for further payment attempts.\n> > > * Thus, delaying an HTLC is not selfishly-rational for an intermediate\n> node.\n> > >\n> > > Thus, for an intermediate node, it seems there is no\n> selfishly-rational motivation to execute a griefing attack on an arbitrary\n> payment attempt.\n> > > We can then conclude that an intermediate that delays a payment would\n> do so, not of its own rational self-interest, but as an accident, such as\n> an unforeseen connectivity or power failure.\n> > >\n> > > However, things are different when we consider a non-arbitrary payment.\n> > > Suppose a node were to make a payment attempt to itself, and\n> deliberately delay claiming this self-payment.\n> > > This lets any single node, *who happens to own large liquidity*, to\n> lock up the liquidity of other nodes.\n> > >\n> > > The motivation to lock up the liquidity of other nodes is to\n> *eliminate competition*.\n> > > Suppose we have a network as below:\n> > >\n> > >     A -- B -- C\n> > >       \\     /\n> > >        \\   /\n> > >         \\ /\n> > >          E\n> > >\n> > > When A and C want to transact with one another, they may choose to\n> route via either B or E.\n> > > B and E are therefore competitors in the business of forwarding\n> payments.\n> > >\n> > > But suppose E has much larger channels AE and CE than the channels of\n> AB and CB.\n> > > For example, suppose E has 100mBTC perfectly-balanced channels while B\n> has only 10mBTC perfectly-balanced channels, as all things should be in\n> simplified models of reality.\n> > > E can then \"take out the competition\" by making a 5mBTC self-payment\n> along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then\n> refusing to claim the payment, tying up all the liquidity of the channels\n> of B.\n> > > By doing so, it can ensure that A and C will always fail to pay via B,\n> even if they wish to transact in amounts less than 5mBTC.\n> > > E thereby eliminates B as a competitor.\n> > >\n> > > This demonstrates that griefing attacks will be motivated, such that\n> such attacks will be performed by payers and payees *against intermediate\n> nodes*.\n> > > Intermediate nodes have no motivation to attack payers and payees\n> (those are their potential customers in the business of forwarding\n> payments, and attacking potential customers is bad business: such attacking\n> intermediate nodes will be removed economically in the long run).\n> > > However, payers and payees can become motivated to attack intermediate\n> nodes, if the \"payer\" and \"payee\" are actually competitor intermediate\n> nodes.\n> > >\n> > > (We can observe that this is always a possibility even outside of\n> Lightning: a service or product provider has no incentive to attack its\n> customers (\"the customer is always right\"), but have an incentive to\n> *pretend* to be a customer of a competitor and attack them.)\n> > >\n> > > We will keep this fact in mind: active griefing attacks are attacks\n> *on* intermediate nodes, not *by* intermediate nodes, because there is no\n> economic incentive for intermediate nodes to attack their customers.\n> > >\n> > > Previous Proposed Solutions\n> > > ===========================\n> > >\n> > > Time-Spent Reporting\n> > > --------------------\n> > >\n> > > At each channel along the route, the time spent by a node to handle\n> its forwarding is recorded, and reported upstream in the route.\n> > >\n> > > Unfortunately, this solution protects payers from intermediate nodes\n> and payees: it does not protect intermediate nodes from colluding payers\n> and payees.\n> > > Even if an intermediate node knows that a particular node is\n> consistently slow via a previous time-spent report, it will not be able,\n> with our current onion routing, determine if an onion packet it just\n> received will or will not go through the known-slow node.\n> > > Thus, an intermediate node would not be able to defend against distant\n> payees that, with a colluding payer, will not claim a particular payment.\n> > >\n> > > As we have established, an active griefing atttack will never be\n> deliberately performed by a selfishly-rational intermediate node.\n> > > Thus, this solution protects against the wrong thing: it protects\n> payers against slow/unreliable intermediate nodes, it does not protect\n> intermediate nodes against malicious payer/payee collusions.\n> > > It protects only against intermediate nodes that inadvertently go\n> offline during forwarding, but such nodes will inevitably lose out on the\n> forwarding market anyway, and will disappear in the long run.\n> > >\n> > > Up-Front Payment\n> > > ----------------\n> > >\n> > > Payers pay for an attempt, not just the successful completion of an\n> attempt.\n> > >\n> > > A variation on this is that the payer (or payee) continuously pays as\n> long as the payment is pending.\n> > > Further variations include paying by other means, such as just locking\n> funds or paying with proof-of-work.\n> > >\n> > > While it certainly erects economic barriers against payer/payee\n> collusions attacking intermediate nodes, it *also* erects economic barriers\n> against normal, non-malicious payments.\n> > >\n> > > We can consider that economic barriers against non-malicious,\n> low-value, high-frequency payments (\"micropayments\") may be enough that\n> such payments become infeasible if we impose up-front payment for mere\n> attempts.\n> > > Thus, while this solution is certainly something we can consider, we\n> must be reluctant to use it due to its up-front, strict-evaluation behavior.\n> > >\n> > > Proof-Of-Closure\n> > > ================\n> > >\n> > > Observing the above, we want the properties for a \"good\" solution to\n> griefing attacks to be:\n> > >\n> > > * It should protect intermediate nodes against payer/payee collusions.\n> > > * It should only come into play upon detection of an attack.\n> > >\n> > > We now present proof-of-closure, which (we hope) has the above\n> properties.\n> > >\n> > > We can consider instead a softer timeout, distinct from the HTLC\n> block-based timeout.\n> > > This softer timeout is measurable in fractions of a second, e.g. units\n> of 0.1 seconds.\n> > >\n> > > Each node on the network advertises, in addition to a block-based\n> `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > Further, each invoice contains, in addition to a block-based\n> `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > >\n> > > Thus, there are two timeouts:\n> > >\n> > > * The current \"hard\" block-based timeout that is enforceable onchain.\n> > > * A new \"soft\" sidereal-time-based timeout that is not onchain\n> enforceable.\n> > >\n> > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > Instead, enforcement of the soft timeout *is* the act of putting the\n> channel state onchain.\n> > >\n> > > Now, for the current \"hard\" block-based timeout, we already have a\n> reaction.\n> > > If the HTLC \"hard\" timeout is approaching:\n> > >\n> > > * Drop the channel onchain and enforce the hard timeout onchain to\n> reclaim the funds in the HTLCs.\n> > > * Wait for the onchain action to be deeply resolved (either timelock\n> or hashlock branch is confirmed deeply) and report the result (success or\n> fail) upstream.\n> > >\n> > > What happens if the \"soft\" timeout is violated?\n> > >\n> > > * Drop the channel onchain.\n> > > * Report the channel closure upstream.\n> > >\n> > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > >\n> > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel.\n> > >\n> > > The \"soft\" timeout is cancelled in any of these three conditions, the\n> first two of which are the same as above:\n> > >\n> > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > * A channel closure is reported.\n> > >\n> > > Let us fill this in more detail.\n> > >\n> > > Suppose we have a payment route A->B->C->E.\n> > >\n> > > Both the \"hard\" block timeouts and the \"soft\" second timeouts\n> decrement monotonically at each hop.\n> > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as\n> normal).\n> > >\n> > > * Suppose E then delays claiming the payment and violates the \"soft\"\n> timeout.\n> > > * C then drops the CE channel onchain.\n> > > * C reports, before its own timeout (slightly larger than the timeout\n> imposed on E), the closing of the channel CE, to B.\n> > > * B validates this report, and if valid, propagates the report to A.\n> > > * A validates this report, and if valid, accepts that the payment will\n> be \"stuck\" for up to the hard timeout it imposed on B.\n> > >\n> > > C has to report back to B in order to prevent B from closing the BC\n> channel, and B has to report back to A in order to prevent A from closing\n> the AB channel.\n> > > The decrementing seconds-unit timeouts are needed for each hop, for\n> the same reason that decrementing block-unit timeouts are needed.\n> > >\n> > > Since E is motivated to attack intermediate nodes because it wants to\n> redirect payment forwards through itself rather than its competitotrs,\n> having one of its channels closed (which prevents it from being used for\n> forwarding) is directly opposed to its end goal of getting more money,\n> thus, we can believe the action of closing a channel involved in a griefing\n> attack is sufficient disincentive.\n> > >\n> > > The major drawback is that enforcement of the soft timeout *is* a\n> channel closure, which is generally a negative for the network.\n> > > This is not a remote attack vector, since a node can only trigger this\n> closure if it is able to stall the fulfillment or failure of an HTLC on a\n> channel, which generally means the node triggering this closure can only do\n> so for its own channels (or it is able to, via a separate mechanism,\n> remotely crash a different node).\n> > >\n> > > Proving Channel Closes\n> > > ----------------------\n> > >\n> > > What C *really* needs to prove is that:\n> > >\n> > > * It is *willing* to close a channel due to a violation of the soft\n> timeout.\n> > > * The channel it is willing to close was, in fact, involved in the\n> same payment attempt.\n> > >\n> > > With the above, B can believe that C was innocent of wrongdoing,\n> because:\n> > >\n> > > * C would only be wiling to close a channel in case of a protocol\n> violation, in this case, a violation of the soft timeout.\n> > > * The channel it closed was closed because of this payment attempt,\n> and not because of another payment attempt, or some other unrelated channel\n> being unilaterally closed.\n> > >\n> > > First, what C needs to prove is *NOT*, in fact, actual channel\n> closure: it needs to prove a *willingness* to close a channel.\n> > > Thus, it does not require the channel to actually be *closed* yet,\n> i.e. it does not have to wait for onchain activity that the channel closure\n> is in a mempool and is confirmed deeply onchain etc etc.\n> > >\n> > > Thus, to prove a *willingness to close* rather than an actual close, C\n> can provide the unilateral close of the channel CE.\n> > > The act of unilaterally closing a channel is the publication of the\n> transaction(s) making up the unilateral close.\n> > > Thus, if C is *willing* to close the channel, it is willing to publish\n> the transaction(s) involved, and thus, providing the unilateral close to B\n> and further upstream, shows a willingness to close the channel.\n> > >\n> > > B then validates the provided proof-of-closure by checking that the\n> unilateral close transaction is either onchain, in the mempool, or that it\n> spends a TXO that is not currently spent by another transaction.\n> > > In the case the unilateral close transaction is not confirmed and in\n> the mempool, B can speed up its propagation on the Bitcoin layer by putting\n> it in its own mempool as well --- after all, C is willing to close the\n> channel to exonerate itself and punish the actual culprit, and B putting\n> the unilateral close in its own mempool can only help C in what it is\n> willing to do.\n> > >\n> > > Secondly, C needs to prove that the channel it is willing to close\n> involves the payment attempt, and is not some other channel closure that it\n> is attempting to use to fulfill its own soft timeout.\n> > > Since the unilateral close transaction *is* the proof-of-closure, B\n> (and A) can inspect the transaction outputs and see (with some additional\n> data from C) that one of the outputs is to an HTLC that matches the payment\n> hash.\n> > >\n> > > Thus, B (and A) can believe that the proof-of-closure proves that\n> whoever is presenting it is free of wrongdoing, as whoever is actually\n> causing the delay has been punished (by someone being willing to close a\n> channel with the culprit), and that the proof-of-closure commits to this\n> particular payment attempt and no other (because it commits to a particular\n> payment hash).\n> > >\n> > > Further, if CE is closed by E dropping it onchain rather than C, C\n> will still be able to fulfill its own soft timeout by taking the closing\n> transaction from E, which should still contain the HTLC.\n> > > Indeed, neither A nor B will particularly care (nor need to know) who\n> dropped the channel onchain, or (for A) that the channel participants are C\n> and E.\n> > >\n> > > Update State Shenanigans\n> > > ------------------------\n> > >\n> > > Bitcoin update mechanisms are complicated things, and it may be\n> possible for an attacking payee E to fool around with the update state\n> machine to make it difficult for C to report a willingness to close CE.\n> > >\n> > > In particular, I quote here the relevant passages from\n> `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the\n> Poon-Dryja update mechanism:\n> > >\n> > > > Thus each update traverses through the following states:\n> > > >\n> > > > 1. pending on the receiver\n> > > > 2. in the receiver's latest commitment transaction\n> > > > 3. ... and the receiver's previous commitment transaction has been\n> revoked,\n> > > >    and the update is pending on the sender\n> > > > 4. ... and in the sender's latest commitment transaction\n> > > > 5. ... and the sender's previous commitment transaction has been\n> revoked\n> > >\n> > > The payee E is the \"receiver\" in this context.\n> > >\n> > > In this case, once the update has reached step 2, then E has a\n> commitment transaction that it can put onchain, that contains an HTLC it\n> can claim.\n> > > From this step onward, C cannot send a failure (i.e. it cannot send\n> back an `update_fail_htlc`) back to B, because E could drop its latest\n> commitment onchain and claim the HTLC onchain.\n> > >\n> > > However, until step 4, C does not have a unilateral close containing\n> the HTLC, and thus cannot provide a proof-of-closure that contains an HTLC\n> that refers to the payment.\n> > >\n> > > Thus, between steps 2 to 4, C cannot safely respond to its own soft\n> timeout.\n> > > C cannot respond with a failure, as E could then drop its latest\n> commitment transaction onchain and claim the payment from C, and extract\n> money from C that way.\n> > > C also cannot respond with a proof-of-closure, as it does not have a\n> transaction that it can use to provide this proof.\n> > >\n> > > The best that C can do would be to impose an even shorter timeout\n> between steps 2 and 4 above, and to drop its current commitment transaction\n> (which does not contain the HTLC yet and thus does not constitute a valid\n> proof-of-closure) onchain.\n> > > In between the time it drops the commitment transaction and its own\n> incoming soft timeout, there is a chance, however small, that this\n> transaction will be confirmed, and the channel will (with high probability)\n> settle in a state where the HTLC is not instantiated, thus C can safely\n> fail its incoming HTLC (not show a proof-of-closure, since that is not\n> possible for C to do) without risk of loss, just prior to its own soft\n> timeout.\n> > >\n> > > Of course, C is still at risk here: E could collude with miners via a\n> side-channel fee offer to confirm its commitment transaction with the HTLC\n> present, and ensure that C is liable for the HTLC value.\n> > >\n> > > With Decker-Russell-Osuntokun, we can remove this risk by requiring a\n> ritual as follows:\n> > >\n> > > 1.  C requests exclusive access to update their single shared state.\n> > >   * This can be done via a variety of sub-protocols, including a fair\n> coin toss in case of near-simultaneous requests for exclusive locks on both\n> sides.\n> > > 2.  C provides the details of the new HTLC to E.\n> > > 3.  C and E generate the new state transaction and exchange signatures\n> for it.\n> > > 4.  C and E generate (without signing) the new update transaction.\n> > > 5.  E provides the signature (or share of signature, if MuSig) for the\n> new update transaction to C.\n> > > 6.  C provides the signature for the new update transaction to E,\n> which releases the exclusive lock on the shared state atomically with the\n> finalization of the new update transaction.\n> > >\n> > > Prior to step 5, C can simply fail the incoming HTLC from B in case\n> its own soft timeout is near.\n> > > Even if E performs step 5 after C has already failed the incoming HTLC\n> from B, C can simply not perform step 6 and drop the channel onchain with\n> the previous update and state transactions.\n> > >\n> > > With Poon-Dryja, we will have to rearrange the order in which we\n> perform things, effectively adding an extra communications turnaround\n> between the participants.\n> > > Specifically, the order would have to be revised to:\n> > >\n> > > > 1. pending on the sender\n> > > > 2. in the sender's latest commitment transaction\n> > > > 3. ... and the sender's previous commitment transaction has been\n> revoked,\n> > > >    and the update is pending on the receiver\n> > > > 4. ... and in the receiver's latest commitment transaction\n> > > > 5. ... and the receiver's previous commitment transaction has been\n> revoked\n> > >\n> > > This allows the sender (C in our context) to provide a\n> proof-of-closure after step 2, and before step 2, C can safely return a\n> failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus\n> ensuring it can still use the previous commitment that still has no HTLC).\n> > >\n> > > Of course, this change will require redesigning the update state\n> machine, increasing the number of communication turnarounds, and creating a\n> subtle incompatbility when transitioning a payment from a hop that knows\n> only the old update state machine to a hop that knows the new update state\n> machine.\n> > >\n> > > Purely Falsified Proof-Of-Closure\n> > > ---------------------------------\n> > >\n> > > Of course, the attacking node E might want to create a false\n> proof-of-closure.\n> > > E can do this by simulating a Lightning channel: lock an amount of\n> funds in a 2-of-2 (where E controls both keys), then spend it in a set of\n> transactions mimicking the unilateral close.\n> > >\n> > > We observe, however, that the overhead of simulating a Lightning\n> channel is the same as the overhead of actually creating and closing a\n> Lightning channel.\n> > > Since the punishment of proof-of-closure is to force attackers to have\n> their channels closed, we can consider that this simulation of a channel\n> open and close is sufficient as well.\n> > >\n> > > Future-Proofing\n> > > ---------------\n> > >\n> > > This sketch of proof-of-closure can be used for any update mechanism:\n> > >\n> > > * With Poon-Dryja, C can use its own commitment transaction as the\n> proof-of-closure.\n> > > * With Decker-Wattenhofer, C can give all the offchain transactions up\n> to the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> > > * With Deckker-Russell-Osuntokun, C can give the latest update and\n> state trnsaction.\n> > >\n> > > Basically, we expect that for now, and in the future, any update\n> mechanism worth consideration will have a concept of \"unilateral close\"\n> where a channel can be dropped onchain, using data that only one of the\n> channel participants holds.\n> > >\n> > > Such a unilateral close will be a sequence of one or more valid\n> transactions, terminating in a transaction containing an HTLC-like contract\n> in one of its outputs.\n> > >\n> > > Thus, to validate the unilateral close, it is only required to\n> validate all the transactions contained in the proof-of-closure, and see\n> that the last transaction has an HTLC output.\n> > >\n> > > The limitations are thus:\n> > >\n> > > * The acceptable forms of HTLC would need to be agreed-upon by the\n> entire network.\n> > > * Implementations would need to be able to assess, in a\n> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > >\n> > > Payment Decorrelation and Payment Points\n> > > ----------------------------------------\n> > >\n> > > Of course, having a single payment hash for the entire payment attempt\n> is a privacy loss, which we intend to fix in the near future by using\n> payment points, and adding a blinding scalar at each hop, aka. payment\n> decorrelation.\n> > >\n> > > Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> > > Further, the payment point at each hop will be changed at each hop, in\n> order to prevent decorrelation.\n> > >\n> > > Thus, C needs to provide proofs:\n> > >\n> > > * That an apparent singlesig on the unilateral close output is in fact\n> a PTLC.\n> > >   C needs to provide:\n> > >   * A target point P.\n> > >   * A partial signature that would spend that singlesig for a\n> particular sighash.\n> > >   * An adaptor signature which, with knowledge of the completed\n> signature, adaptor signature, and sighash message, would have revealed the\n> scalar behind P.\n> > > * That the PTLC belongs to the same payment attempt as what B offered\n> to C.\n> > >   C needs to provide:\n> > >   * The C-only blinding factor that is the difference between the\n> payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral\n> close.\n> > >\n> > > Then, when B needs to propagate the proof-of-closure back to A, B\n> simply adds its own blinding factor to the reported blinding factor, in\n> order to convince A that this is the same payment attempt.\n> > >\n> > > As we have brought up privacy, we observe that, when this mechanism\n> triggers, there is a mild privacy loss, in that intermediate nodes now know\n> some channel closure that is related to this payment, and can thus\n> determine the exact path that the payment attempt went through, at least\n> until the channel being closed.\n> > > However, proof-of-closure is only propagated in case of violation of\n> the soft timeout, so for normal non-malicious payments, proof-of-closure\n> does not cause any privacy loss.\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200413/ae2be073/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-13T03:42:56",
                "message_text_only": "Good morning Subhra,\n\n\n> Ok. But this is a worse situation where C pays money to D but bound to keep its resource locked for a longer duration, unlike D not responding and C being able to unlock after the elapse of lock time.\n\nIt is exactly the griefing attack scenario: it is the lock time at D that is the problem.\nAs such, it is not \"worse\", it is ***exactly*** the griefing attack scenario.\n\nC cannot unlock until 144 blocks, so D can delay its response for up to 143 blocks without any effect on its channels, this is *exactly* the griefing attack.\n\nRegards,\nZmnSCPxj\n\n>\n> On Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Subhra,\n> >\n> > > Hello,\n> > > \u00a0 \u00a0 \u00a0 So based on what you have stated as possible scenario of griefing attack, does delay in providing the preimage also counted as a form of griefing in htlc? Like given the path A->B->C->D, what if C and D has a lock time of 144 blocks and D responds after 142 block time elapses, claiming the money locked with D?\n> >\n> > That ***is*** the griefing attack.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > >\n> > > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> > >\n> > > > Introduction\n> > > > ============\n> > > >\n> > > > Given the fact that contracts on offchain protocols need to be enforceable onchain as well, timelocks involved in multi-hop payments are measured in blocks.\n> > > > This is because the blockchain can only (third-party-verifiably) enforce timeouts in units of entire blocks.\n> > > > This leads to very long timeouts for payment delivery, thus multi-hop offchain payment attempts can be, deliberately or accidentally, be in a \"pending\" state up to the very large timeouts involved.\n> > > >\n> > > > Deliberately setting up a multi-hop payment such that it will be in a \"pending\" state for long periods of time is colloquially known as a \"griefing attack\".\n> > > > In this article, we assess various proposed solutions to mitigate the effects of griefing attacks, and propose a particular solution, proof-of-closure, as well, that requires significant changes to the update state machine.\n> > > >\n> > > > Digression: Why Grief?\n> > > > ======================\n> > > >\n> > > > Before embarking on our investigation for solutions to the griefing problem, we should first wonder if griefing is, in fact, a problem.\n> > > >\n> > > > This brings up the question of: why would anybody grief at all?\n> > > >\n> > > > Humans, like cats and other less-sapient pieces of walking meat, often find enjoyment in causing the suffering of others for no immediate direct gain to themselves, as a public demonstration of dominance over those they make suffer (aka \"shits and giggles\", which, if executed correctly, can lead to eventual direct gains to themselves or their progeny or relatives or allies, but such details are often outside the ken of the very beings who execute such survival strategies: brains are pieces of meat that have been hacked to act as action-reaction engines, but are not sophisticated enough to execute as pure rationality engines at all times).\n> > > > Fortunately, in the Bitcoin world, only purely rational beings of pure selfishness can exist in the long run, thus we can neglect such motivations as mere noise.\n> > > >\n> > > > First, let us investigate *how* griefing attacks can be performed.\n> > > >\n> > > > * An intermediate node in a multi-hop attempt can delay forwarding or failing an incoming HTLC.\n> > > > * A final node in a payment attempt can delay claiming an incoming HTLC.\n> > > >\n> > > > Let us consider a purely rational intermediate node of pure selfishness:\n> > > >\n> > > > * If it forwards as soon as possible, it can earn fees, and also speed up the release of the HTLC-locked funds so that they can reuse those funds as liquidity for further payment attempts.\n> > > > * Thus, delaying an HTLC is not selfishly-rational for an intermediate node.\n> > > >\n> > > > Thus, for an intermediate node, it seems there is no selfishly-rational motivation to execute a griefing attack on an arbitrary payment attempt.\n> > > > We can then conclude that an intermediate that delays a payment would do so, not of its own rational self-interest, but as an accident, such as an unforeseen connectivity or power failure.\n> > > >\n> > > > However, things are different when we consider a non-arbitrary payment.\n> > > > Suppose a node were to make a payment attempt to itself, and deliberately delay claiming this self-payment.\n> > > > This lets any single node, *who happens to own large liquidity*, to lock up the liquidity of other nodes.\n> > > >\n> > > > The motivation to lock up the liquidity of other nodes is to *eliminate competition*.\n> > > > Suppose we have a network as below:\n> > > >\n> > > > \u00a0 \u00a0 A -- B -- C\n> > > > \u00a0 \u00a0 \u00a0 \\\u00a0 \u00a0 \u00a0/\n> > > > \u00a0 \u00a0 \u00a0 \u00a0\\\u00a0 \u00a0/\n> > > > \u00a0 \u00a0 \u00a0 \u00a0 \\ /\n> > > > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0E\n> > > >\n> > > > When A and C want to transact with one another, they may choose to route via either B or E.\n> > > > B and E are therefore competitors in the business of forwarding payments.\n> > > >\n> > > > But suppose E has much larger channels AE and CE than the channels of AB and CB.\n> > > > For example, suppose E has 100mBTC perfectly-balanced channels while B has only 10mBTC perfectly-balanced channels, as all things should be in simplified models of reality.\n> > > > E can then \"take out the competition\" by making a 5mBTC self-payment along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing to claim the payment, tying up all the liquidity of the channels of B.\n> > > > By doing so, it can ensure that A and C will always fail to pay via B, even if they wish to transact in amounts less than 5mBTC.\n> > > > E thereby eliminates B as a competitor.\n> > > >\n> > > > This demonstrates that griefing attacks will be motivated, such that such attacks will be performed by payers and payees *against intermediate nodes*.\n> > > > Intermediate nodes have no motivation to attack payers and payees (those are their potential customers in the business of forwarding payments, and attacking potential customers is bad business: such attacking intermediate nodes will be removed economically in the long run).\n> > > > However, payers and payees can become motivated to attack intermediate nodes, if the \"payer\" and \"payee\" are actually competitor intermediate nodes.\n> > > >\n> > > > (We can observe that this is always a possibility even outside of Lightning: a service or product provider has no incentive to attack its customers (\"the customer is always right\"), but have an incentive to *pretend* to be a customer of a competitor and attack them.)\n> > > >\n> > > > We will keep this fact in mind: active griefing attacks are attacks *on* intermediate nodes, not *by* intermediate nodes, because there is no economic incentive for intermediate nodes to attack their customers.\n> > > >\n> > > > Previous Proposed Solutions\n> > > > ===========================\n> > > >\n> > > > Time-Spent Reporting\n> > > > --------------------\n> > > >\n> > > > At each channel along the route, the time spent by a node to handle its forwarding is recorded, and reported upstream in the route.\n> > > >\n> > > > Unfortunately, this solution protects payers from intermediate nodes and payees: it does not protect intermediate nodes from colluding payers and payees.\n> > > > Even if an intermediate node knows that a particular node is consistently slow via a previous time-spent report, it will not be able, with our current onion routing, determine if an onion packet it just received will or will not go through the known-slow node.\n> > > > Thus, an intermediate node would not be able to defend against distant payees that, with a colluding payer, will not claim a particular payment.\n> > > >\n> > > > As we have established, an active griefing atttack will never be deliberately performed by a selfishly-rational intermediate node.\n> > > > Thus, this solution protects against the wrong thing: it protects payers against slow/unreliable intermediate nodes, it does not protect intermediate nodes against malicious payer/payee collusions.\n> > > > It protects only against intermediate nodes that inadvertently go offline during forwarding, but such nodes will inevitably lose out on the forwarding market anyway, and will disappear in the long run.\n> > > >\n> > > > Up-Front Payment\n> > > > ----------------\n> > > >\n> > > > Payers pay for an attempt, not just the successful completion of an attempt.\n> > > >\n> > > > A variation on this is that the payer (or payee) continuously pays as long as the payment is pending.\n> > > > Further variations include paying by other means, such as just locking funds or paying with proof-of-work.\n> > > >\n> > > > While it certainly erects economic barriers against payer/payee collusions attacking intermediate nodes, it *also* erects economic barriers against normal, non-malicious payments.\n> > > >\n> > > > We can consider that economic barriers against non-malicious, low-value, high-frequency payments (\"micropayments\") may be enough that such payments become infeasible if we impose up-front payment for mere attempts.\n> > > > Thus, while this solution is certainly something we can consider, we must be reluctant to use it due to its up-front, strict-evaluation behavior.\n> > > >\n> > > > Proof-Of-Closure\n> > > > ================\n> > > >\n> > > > Observing the above, we want the properties for a \"good\" solution to griefing attacks to be:\n> > > >\n> > > > * It should protect intermediate nodes against payer/payee collusions.\n> > > > * It should only come into play upon detection of an attack.\n> > > >\n> > > > We now present proof-of-closure, which (we hope) has the above properties.\n> > > >\n> > > > We can consider instead a softer timeout, distinct from the HTLC block-based timeout.\n> > > > This softer timeout is measurable in fractions of a second, e.g. units of 0.1 seconds.\n> > > >\n> > > > Each node on the network advertises, in addition to a block-based `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > > Further, each invoice contains, in addition to a block-based `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > > >\n> > > > Thus, there are two timeouts:\n> > > >\n> > > > * The current \"hard\" block-based timeout that is enforceable onchain.\n> > > > * A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n> > > >\n> > > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > > Instead, enforcement of the soft timeout *is* the act of putting the channel state onchain.\n> > > >\n> > > > Now, for the current \"hard\" block-based timeout, we already have a reaction.\n> > > > If the HTLC \"hard\" timeout is approaching:\n> > > >\n> > > > * Drop the channel onchain and enforce the hard timeout onchain to reclaim the funds in the HTLCs.\n> > > > * Wait for the onchain action to be deeply resolved (either timelock or hashlock branch is confirmed deeply) and report the result (success or fail) upstream.\n> > > >\n> > > > What happens if the \"soft\" timeout is violated?\n> > > >\n> > > > * Drop the channel onchain.\n> > > > * Report the channel closure upstream.\n> > > >\n> > > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > > >\n> > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel.\n> > > >\n> > > > The \"soft\" timeout is cancelled in any of these three conditions, the first two of which are the same as above:\n> > > >\n> > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > > * A channel closure is reported.\n> > > >\n> > > > Let us fill this in more detail.\n> > > >\n> > > > Suppose we have a payment route A->B->C->E.\n> > > >\n> > > > Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement monotonically at each hop.\n> > > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n> > > >\n> > > > * Suppose E then delays claiming the payment and violates the \"soft\" timeout.\n> > > > * C then drops the CE channel onchain.\n> > > > * C reports, before its own timeout (slightly larger than the timeout imposed on E), the closing of the channel CE, to B.\n> > > > * B validates this report, and if valid, propagates the report to A.\n> > > > * A validates this report, and if valid, accepts that the payment will be \"stuck\" for up to the hard timeout it imposed on B.\n> > > >\n> > > > C has to report back to B in order to prevent B from closing the BC channel, and B has to report back to A in order to prevent A from closing the AB channel.\n> > > > The decrementing seconds-unit timeouts are needed for each hop, for the same reason that decrementing block-unit timeouts are needed.\n> > > >\n> > > > Since E is motivated to attack intermediate nodes because it wants to redirect payment forwards through itself rather than its competitotrs, having one of its channels closed (which prevents it from being used for forwarding) is directly opposed to its end goal of getting more money, thus, we can believe the action of closing a channel involved in a griefing attack is sufficient disincentive.\n> > > >\n> > > > The major drawback is that enforcement of the soft timeout *is* a channel closure, which is generally a negative for the network.\n> > > > This is not a remote attack vector, since a node can only trigger this closure if it is able to stall the fulfillment or failure of an HTLC on a channel, which generally means the node triggering this closure can only do so for its own channels (or it is able to, via a separate mechanism, remotely crash a different node).\n> > > >\n> > > > Proving Channel Closes\n> > > > ----------------------\n> > > >\n> > > > What C *really* needs to prove is that:\n> > > >\n> > > > * It is *willing* to close a channel due to a violation of the soft timeout.\n> > > > * The channel it is willing to close was, in fact, involved in the same payment attempt.\n> > > >\n> > > > With the above, B can believe that C was innocent of wrongdoing, because:\n> > > >\n> > > > * C would only be wiling to close a channel in case of a protocol violation, in this case, a violation of the soft timeout.\n> > > > * The channel it closed was closed because of this payment attempt, and not because of another payment attempt, or some other unrelated channel being unilaterally closed.\n> > > >\n> > > > First, what C needs to prove is *NOT*, in fact, actual channel closure: it needs to prove a *willingness* to close a channel.\n> > > > Thus, it does not require the channel to actually be *closed* yet, i.e. it does not have to wait for onchain activity that the channel closure is in a mempool and is confirmed deeply onchain etc etc.\n> > > >\n> > > > Thus, to prove a *willingness to close* rather than an actual close, C can provide the unilateral close of the channel CE.\n> > > > The act of unilaterally closing a channel is the publication of the transaction(s) making up the unilateral close.\n> > > > Thus, if C is *willing* to close the channel, it is willing to publish the transaction(s) involved, and thus, providing the unilateral close to B and further upstream, shows a willingness to close the channel.\n> > > >\n> > > > B then validates the provided proof-of-closure by checking that the unilateral close transaction is either onchain, in the mempool, or that it spends a TXO that is not currently spent by another transaction.\n> > > > In the case the unilateral close transaction is not confirmed and in the mempool, B can speed up its propagation on the Bitcoin layer by putting it in its own mempool as well --- after all, C is willing to close the channel to exonerate itself and punish the actual culprit, and B putting the unilateral close in its own mempool can only help C in what it is willing to do.\n> > > >\n> > > > Secondly, C needs to prove that the channel it is willing to close involves the payment attempt, and is not some other channel closure that it is attempting to use to fulfill its own soft timeout.\n> > > > Since the unilateral close transaction *is* the proof-of-closure, B (and A) can inspect the transaction outputs and see (with some additional data from C) that one of the outputs is to an HTLC that matches the payment hash.\n> > > >\n> > > > Thus, B (and A) can believe that the proof-of-closure proves that whoever is presenting it is free of wrongdoing, as whoever is actually causing the delay has been punished (by someone being willing to close a channel with the culprit), and that the proof-of-closure commits to this particular payment attempt and no other (because it commits to a particular payment hash).\n> > > >\n> > > > Further, if CE is closed by E dropping it onchain rather than C, C will still be able to fulfill its own soft timeout by taking the closing transaction from E, which should still contain the HTLC.\n> > > > Indeed, neither A nor B will particularly care (nor need to know) who dropped the channel onchain, or (for A) that the channel participants are C and E.\n> > > >\n> > > > Update State Shenanigans\n> > > > ------------------------\n> > > >\n> > > > Bitcoin update mechanisms are complicated things, and it may be possible for an attacking payee E to fool around with the update state machine to make it difficult for C to report a willingness to close CE.\n> > > >\n> > > > In particular, I quote here the relevant passages from `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update mechanism:\n> > > >\n> > > > > Thus each update traverses through the following states:\n> > > > >\n> > > > > 1. pending on the receiver\n> > > > > 2. in the receiver's latest commitment transaction\n> > > > > 3. ... and the receiver's previous commitment transaction has been revoked,\n> > > > >\u00a0 \u00a0 and the update is pending on the sender\n> > > > > 4. ... and in the sender's latest commitment transaction\n> > > > > 5. ... and the sender's previous commitment transaction has been revoked\n> > > >\n> > > > The payee E is the \"receiver\" in this context.\n> > > >\n> > > > In this case, once the update has reached step 2, then E has a commitment transaction that it can put onchain, that contains an HTLC it can claim.\n> > > > From this step onward, C cannot send a failure (i.e. it cannot send back an `update_fail_htlc`) back to B, because E could drop its latest commitment onchain and claim the HTLC onchain.\n> > > >\n> > > > However, until step 4, C does not have a unilateral close containing the HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that refers to the payment.\n> > > >\n> > > > Thus, between steps 2 to 4, C cannot safely respond to its own soft timeout.\n> > > > C cannot respond with a failure, as E could then drop its latest commitment transaction onchain and claim the payment from C, and extract money from C that way.\n> > > > C also cannot respond with a proof-of-closure, as it does not have a transaction that it can use to provide this proof.\n> > > >\n> > > > The best that C can do would be to impose an even shorter timeout between steps 2 and 4 above, and to drop its current commitment transaction (which does not contain the HTLC yet and thus does not constitute a valid proof-of-closure) onchain.\n> > > > In between the time it drops the commitment transaction and its own incoming soft timeout, there is a chance, however small, that this transaction will be confirmed, and the channel will (with high probability) settle in a state where the HTLC is not instantiated, thus C can safely fail its incoming HTLC (not show a proof-of-closure, since that is not possible for C to do) without risk of loss, just prior to its own soft timeout.\n> > > >\n> > > > Of course, C is still at risk here: E could collude with miners via a side-channel fee offer to confirm its commitment transaction with the HTLC present, and ensure that C is liable for the HTLC value.\n> > > >\n> > > > With Decker-Russell-Osuntokun, we can remove this risk by requiring a ritual as follows:\n> > > >\n> > > > 1.\u00a0 C requests exclusive access to update their single shared state.\n> > > > \u00a0 * This can be done via a variety of sub-protocols, including a fair coin toss in case of near-simultaneous requests for exclusive locks on both sides.\n> > > > 2.\u00a0 C provides the details of the new HTLC to E.\n> > > > 3.\u00a0 C and E generate the new state transaction and exchange signatures for it.\n> > > > 4.\u00a0 C and E generate (without signing) the new update transaction.\n> > > > 5.\u00a0 E provides the signature (or share of signature, if MuSig) for the new update transaction to C.\n> > > > 6.\u00a0 C provides the signature for the new update transaction to E, which releases the exclusive lock on the shared state atomically with the finalization of the new update transaction.\n> > > >\n> > > > Prior to step 5, C can simply fail the incoming HTLC from B in case its own soft timeout is near.\n> > > > Even if E performs step 5 after C has already failed the incoming HTLC from B, C can simply not perform step 6 and drop the channel onchain with the previous update and state transactions.\n> > > >\n> > > > With Poon-Dryja, we will have to rearrange the order in which we perform things, effectively adding an extra communications turnaround between the participants.\n> > > > Specifically, the order would have to be revised to:\n> > > >\n> > > > > 1. pending on the sender\n> > > > > 2. in the sender's latest commitment transaction\n> > > > > 3. ... and the sender's previous commitment transaction has been revoked,\n> > > > >\u00a0 \u00a0 and the update is pending on the receiver\n> > > > > 4. ... and in the receiver's latest commitment transaction\n> > > > > 5. ... and the receiver's previous commitment transaction has been revoked\n> > > >\n> > > > This allows the sender (C in our context) to provide a proof-of-closure after step 2, and before step 2, C can safely return a failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it can still use the previous commitment that still has no HTLC).\n> > > >\n> > > > Of course, this change will require redesigning the update state machine, increasing the number of communication turnarounds, and creating a subtle incompatbility when transitioning a payment from a hop that knows only the old update state machine to a hop that knows the new update state machine.\n> > > >\n> > > > Purely Falsified Proof-Of-Closure\n> > > > ---------------------------------\n> > > >\n> > > > Of course, the attacking node E might want to create a false proof-of-closure.\n> > > > E can do this by simulating a Lightning channel: lock an amount of funds in a 2-of-2 (where E controls both keys), then spend it in a set of transactions mimicking the unilateral close.\n> > > >\n> > > > We observe, however, that the overhead of simulating a Lightning channel is the same as the overhead of actually creating and closing a Lightning channel.\n> > > > Since the punishment of proof-of-closure is to force attackers to have their channels closed, we can consider that this simulation of a channel open and close is sufficient as well.\n> > > >\n> > > > Future-Proofing\n> > > > ---------------\n> > > >\n> > > > This sketch of proof-of-closure can be used for any update mechanism:\n> > > >\n> > > > * With Poon-Dryja, C can use its own commitment transaction as the proof-of-closure.\n> > > > * With Decker-Wattenhofer, C can give all the offchain transactions up to the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> > > > * With Deckker-Russell-Osuntokun, C can give the latest update and state trnsaction.\n> > > >\n> > > > Basically, we expect that for now, and in the future, any update mechanism worth consideration will have a concept of \"unilateral close\" where a channel can be dropped onchain, using data that only one of the channel participants holds.\n> > > >\n> > > > Such a unilateral close will be a sequence of one or more valid transactions, terminating in a transaction containing an HTLC-like contract in one of its outputs.\n> > > >\n> > > > Thus, to validate the unilateral close, it is only required to validate all the transactions contained in the proof-of-closure, and see that the last transaction has an HTLC output.\n> > > >\n> > > > The limitations are thus:\n> > > >\n> > > > * The acceptable forms of HTLC would need to be agreed-upon by the entire network.\n> > > > * Implementations would need to be able to assess, in a Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > > >\n> > > > Payment Decorrelation and Payment Points\n> > > > ----------------------------------------\n> > > >\n> > > > Of course, having a single payment hash for the entire payment attempt is a privacy loss, which we intend to fix in the near future by using payment points, and adding a blinding scalar at each hop, aka. payment decorrelation.\n> > > >\n> > > > Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> > > > Further, the payment point at each hop will be changed at each hop, in order to prevent decorrelation.\n> > > >\n> > > > Thus, C needs to provide proofs:\n> > > >\n> > > > * That an apparent singlesig on the unilateral close output is in fact a PTLC.\n> > > > \u00a0 C needs to provide:\n> > > > \u00a0 * A target point P.\n> > > > \u00a0 * A partial signature that would spend that singlesig for a particular sighash.\n> > > > \u00a0 * An adaptor signature which, with knowledge of the completed signature, adaptor signature, and sighash message, would have revealed the scalar behind P.\n> > > > * That the PTLC belongs to the same payment attempt as what B offered to C.\n> > > > \u00a0 C needs to provide:\n> > > > \u00a0 * The C-only blinding factor that is the difference between the payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n> > > >\n> > > > Then, when B needs to propagate the proof-of-closure back to A, B simply adds its own blinding factor to the reported blinding factor, in order to convince A that this is the same payment attempt.\n> > > >\n> > > > As we have brought up privacy, we observe that, when this mechanism triggers, there is a mild privacy loss, in that intermediate nodes now know some channel closure that is related to this payment, and can thus determine the exact path that the payment attempt went through, at least until the channel being closed.\n> > > > However, proof-of-closure is only propagated in case of violation of the soft timeout, so for normal non-malicious payments, proof-of-closure does not cause any privacy loss.\n> > > > _______________________________________________\n> > > > Lightning-dev mailing list\n> > > > Lightning-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-13T03:47:14",
                "message_text_only": "Ok got it. Sorry I missed out the points stated by you.\n\nOn Mon, Apr 13, 2020 at 9:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n>\n> > Ok. But this is a worse situation where C pays money to D but bound to\n> keep its resource locked for a longer duration, unlike D not responding and\n> C being able to unlock after the elapse of lock time.\n>\n> It is exactly the griefing attack scenario: it is the lock time at D that\n> is the problem.\n> As such, it is not \"worse\", it is ***exactly*** the griefing attack\n> scenario.\n>\n> C cannot unlock until 144 blocks, so D can delay its response for up to\n> 143 blocks without any effect on its channels, this is *exactly* the\n> griefing attack.\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > On Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > > Good morning Subhra,\n> > >\n> > > > Hello,\n> > > >       So based on what you have stated as possible scenario of\n> griefing attack, does delay in providing the preimage also counted as a\n> form of griefing in htlc? Like given the path A->B->C->D, what if C and D\n> has a lock time of 144 blocks and D responds after 142 block time elapses,\n> claiming the money locked with D?\n> > >\n> > > That ***is*** the griefing attack.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > >\n> > > > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> > > >\n> > > > > Introduction\n> > > > > ============\n> > > > >\n> > > > > Given the fact that contracts on offchain protocols need to be\n> enforceable onchain as well, timelocks involved in multi-hop payments are\n> measured in blocks.\n> > > > > This is because the blockchain can only (third-party-verifiably)\n> enforce timeouts in units of entire blocks.\n> > > > > This leads to very long timeouts for payment delivery, thus\n> multi-hop offchain payment attempts can be, deliberately or accidentally,\n> be in a \"pending\" state up to the very large timeouts involved.\n> > > > >\n> > > > > Deliberately setting up a multi-hop payment such that it will be\n> in a \"pending\" state for long periods of time is colloquially known as a\n> \"griefing attack\".\n> > > > > In this article, we assess various proposed solutions to mitigate\n> the effects of griefing attacks, and propose a particular solution,\n> proof-of-closure, as well, that requires significant changes to the update\n> state machine.\n> > > > >\n> > > > > Digression: Why Grief?\n> > > > > ======================\n> > > > >\n> > > > > Before embarking on our investigation for solutions to the\n> griefing problem, we should first wonder if griefing is, in fact, a problem.\n> > > > >\n> > > > > This brings up the question of: why would anybody grief at all?\n> > > > >\n> > > > > Humans, like cats and other less-sapient pieces of walking meat,\n> often find enjoyment in causing the suffering of others for no immediate\n> direct gain to themselves, as a public demonstration of dominance over\n> those they make suffer (aka \"shits and giggles\", which, if executed\n> correctly, can lead to eventual direct gains to themselves or their progeny\n> or relatives or allies, but such details are often outside the ken of the\n> very beings who execute such survival strategies: brains are pieces of meat\n> that have been hacked to act as action-reaction engines, but are not\n> sophisticated enough to execute as pure rationality engines at all times).\n> > > > > Fortunately, in the Bitcoin world, only purely rational beings of\n> pure selfishness can exist in the long run, thus we can neglect such\n> motivations as mere noise.\n> > > > >\n> > > > > First, let us investigate *how* griefing attacks can be performed.\n> > > > >\n> > > > > * An intermediate node in a multi-hop attempt can delay forwarding\n> or failing an incoming HTLC.\n> > > > > * A final node in a payment attempt can delay claiming an incoming\n> HTLC.\n> > > > >\n> > > > > Let us consider a purely rational intermediate node of pure\n> selfishness:\n> > > > >\n> > > > > * If it forwards as soon as possible, it can earn fees, and also\n> speed up the release of the HTLC-locked funds so that they can reuse those\n> funds as liquidity for further payment attempts.\n> > > > > * Thus, delaying an HTLC is not selfishly-rational for an\n> intermediate node.\n> > > > >\n> > > > > Thus, for an intermediate node, it seems there is no\n> selfishly-rational motivation to execute a griefing attack on an arbitrary\n> payment attempt.\n> > > > > We can then conclude that an intermediate that delays a payment\n> would do so, not of its own rational self-interest, but as an accident,\n> such as an unforeseen connectivity or power failure.\n> > > > >\n> > > > > However, things are different when we consider a non-arbitrary\n> payment.\n> > > > > Suppose a node were to make a payment attempt to itself, and\n> deliberately delay claiming this self-payment.\n> > > > > This lets any single node, *who happens to own large liquidity*,\n> to lock up the liquidity of other nodes.\n> > > > >\n> > > > > The motivation to lock up the liquidity of other nodes is to\n> *eliminate competition*.\n> > > > > Suppose we have a network as below:\n> > > > >\n> > > > >     A -- B -- C\n> > > > >       \\     /\n> > > > >        \\   /\n> > > > >         \\ /\n> > > > >          E\n> > > > >\n> > > > > When A and C want to transact with one another, they may choose to\n> route via either B or E.\n> > > > > B and E are therefore competitors in the business of forwarding\n> payments.\n> > > > >\n> > > > > But suppose E has much larger channels AE and CE than the channels\n> of AB and CB.\n> > > > > For example, suppose E has 100mBTC perfectly-balanced channels\n> while B has only 10mBTC perfectly-balanced channels, as all things should\n> be in simplified models of reality.\n> > > > > E can then \"take out the competition\" by making a 5mBTC\n> self-payment along E->A->B->C->E and a 5mBTC self-payment along\n> E->C->B->A->E, then refusing to claim the payment, tying up all the\n> liquidity of the channels of B.\n> > > > > By doing so, it can ensure that A and C will always fail to pay\n> via B, even if they wish to transact in amounts less than 5mBTC.\n> > > > > E thereby eliminates B as a competitor.\n> > > > >\n> > > > > This demonstrates that griefing attacks will be motivated, such\n> that such attacks will be performed by payers and payees *against\n> intermediate nodes*.\n> > > > > Intermediate nodes have no motivation to attack payers and payees\n> (those are their potential customers in the business of forwarding\n> payments, and attacking potential customers is bad business: such attacking\n> intermediate nodes will be removed economically in the long run).\n> > > > > However, payers and payees can become motivated to attack\n> intermediate nodes, if the \"payer\" and \"payee\" are actually competitor\n> intermediate nodes.\n> > > > >\n> > > > > (We can observe that this is always a possibility even outside of\n> Lightning: a service or product provider has no incentive to attack its\n> customers (\"the customer is always right\"), but have an incentive to\n> *pretend* to be a customer of a competitor and attack them.)\n> > > > >\n> > > > > We will keep this fact in mind: active griefing attacks are\n> attacks *on* intermediate nodes, not *by* intermediate nodes, because there\n> is no economic incentive for intermediate nodes to attack their customers.\n> > > > >\n> > > > > Previous Proposed Solutions\n> > > > > ===========================\n> > > > >\n> > > > > Time-Spent Reporting\n> > > > > --------------------\n> > > > >\n> > > > > At each channel along the route, the time spent by a node to\n> handle its forwarding is recorded, and reported upstream in the route.\n> > > > >\n> > > > > Unfortunately, this solution protects payers from intermediate\n> nodes and payees: it does not protect intermediate nodes from colluding\n> payers and payees.\n> > > > > Even if an intermediate node knows that a particular node is\n> consistently slow via a previous time-spent report, it will not be able,\n> with our current onion routing, determine if an onion packet it just\n> received will or will not go through the known-slow node.\n> > > > > Thus, an intermediate node would not be able to defend against\n> distant payees that, with a colluding payer, will not claim a particular\n> payment.\n> > > > >\n> > > > > As we have established, an active griefing atttack will never be\n> deliberately performed by a selfishly-rational intermediate node.\n> > > > > Thus, this solution protects against the wrong thing: it protects\n> payers against slow/unreliable intermediate nodes, it does not protect\n> intermediate nodes against malicious payer/payee collusions.\n> > > > > It protects only against intermediate nodes that inadvertently go\n> offline during forwarding, but such nodes will inevitably lose out on the\n> forwarding market anyway, and will disappear in the long run.\n> > > > >\n> > > > > Up-Front Payment\n> > > > > ----------------\n> > > > >\n> > > > > Payers pay for an attempt, not just the successful completion of\n> an attempt.\n> > > > >\n> > > > > A variation on this is that the payer (or payee) continuously pays\n> as long as the payment is pending.\n> > > > > Further variations include paying by other means, such as just\n> locking funds or paying with proof-of-work.\n> > > > >\n> > > > > While it certainly erects economic barriers against payer/payee\n> collusions attacking intermediate nodes, it *also* erects economic barriers\n> against normal, non-malicious payments.\n> > > > >\n> > > > > We can consider that economic barriers against non-malicious,\n> low-value, high-frequency payments (\"micropayments\") may be enough that\n> such payments become infeasible if we impose up-front payment for mere\n> attempts.\n> > > > > Thus, while this solution is certainly something we can consider,\n> we must be reluctant to use it due to its up-front, strict-evaluation\n> behavior.\n> > > > >\n> > > > > Proof-Of-Closure\n> > > > > ================\n> > > > >\n> > > > > Observing the above, we want the properties for a \"good\" solution\n> to griefing attacks to be:\n> > > > >\n> > > > > * It should protect intermediate nodes against payer/payee\n> collusions.\n> > > > > * It should only come into play upon detection of an attack.\n> > > > >\n> > > > > We now present proof-of-closure, which (we hope) has the above\n> properties.\n> > > > >\n> > > > > We can consider instead a softer timeout, distinct from the HTLC\n> block-based timeout.\n> > > > > This softer timeout is measurable in fractions of a second, e.g.\n> units of 0.1 seconds.\n> > > > >\n> > > > > Each node on the network advertises, in addition to a block-based\n> `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > > > Further, each invoice contains, in addition to a block-based\n> `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > > > >\n> > > > > Thus, there are two timeouts:\n> > > > >\n> > > > > * The current \"hard\" block-based timeout that is enforceable\n> onchain.\n> > > > > * A new \"soft\" sidereal-time-based timeout that is not onchain\n> enforceable.\n> > > > >\n> > > > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > > > Instead, enforcement of the soft timeout *is* the act of putting\n> the channel state onchain.\n> > > > >\n> > > > > Now, for the current \"hard\" block-based timeout, we already have a\n> reaction.\n> > > > > If the HTLC \"hard\" timeout is approaching:\n> > > > >\n> > > > > * Drop the channel onchain and enforce the hard timeout onchain to\n> reclaim the funds in the HTLCs.\n> > > > > * Wait for the onchain action to be deeply resolved (either\n> timelock or hashlock branch is confirmed deeply) and report the result\n> (success or fail) upstream.\n> > > > >\n> > > > > What happens if the \"soft\" timeout is violated?\n> > > > >\n> > > > > * Drop the channel onchain.\n> > > > > * Report the channel closure upstream.\n> > > > >\n> > > > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > > > >\n> > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel.\n> > > > >\n> > > > > The \"soft\" timeout is cancelled in any of these three conditions,\n> the first two of which are the same as above:\n> > > > >\n> > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > > > * A channel closure is reported.\n> > > > >\n> > > > > Let us fill this in more detail.\n> > > > >\n> > > > > Suppose we have a payment route A->B->C->E.\n> > > > >\n> > > > > Both the \"hard\" block timeouts and the \"soft\" second timeouts\n> decrement monotonically at each hop.\n> > > > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as\n> normal).\n> > > > >\n> > > > > * Suppose E then delays claiming the payment and violates the\n> \"soft\" timeout.\n> > > > > * C then drops the CE channel onchain.\n> > > > > * C reports, before its own timeout (slightly larger than the\n> timeout imposed on E), the closing of the channel CE, to B.\n> > > > > * B validates this report, and if valid, propagates the report to\n> A.\n> > > > > * A validates this report, and if valid, accepts that the payment\n> will be \"stuck\" for up to the hard timeout it imposed on B.\n> > > > >\n> > > > > C has to report back to B in order to prevent B from closing the\n> BC channel, and B has to report back to A in order to prevent A from\n> closing the AB channel.\n> > > > > The decrementing seconds-unit timeouts are needed for each hop,\n> for the same reason that decrementing block-unit timeouts are needed.\n> > > > >\n> > > > > Since E is motivated to attack intermediate nodes because it wants\n> to redirect payment forwards through itself rather than its competitotrs,\n> having one of its channels closed (which prevents it from being used for\n> forwarding) is directly opposed to its end goal of getting more money,\n> thus, we can believe the action of closing a channel involved in a griefing\n> attack is sufficient disincentive.\n> > > > >\n> > > > > The major drawback is that enforcement of the soft timeout *is* a\n> channel closure, which is generally a negative for the network.\n> > > > > This is not a remote attack vector, since a node can only trigger\n> this closure if it is able to stall the fulfillment or failure of an HTLC\n> on a channel, which generally means the node triggering this closure can\n> only do so for its own channels (or it is able to, via a separate\n> mechanism, remotely crash a different node).\n> > > > >\n> > > > > Proving Channel Closes\n> > > > > ----------------------\n> > > > >\n> > > > > What C *really* needs to prove is that:\n> > > > >\n> > > > > * It is *willing* to close a channel due to a violation of the\n> soft timeout.\n> > > > > * The channel it is willing to close was, in fact, involved in the\n> same payment attempt.\n> > > > >\n> > > > > With the above, B can believe that C was innocent of wrongdoing,\n> because:\n> > > > >\n> > > > > * C would only be wiling to close a channel in case of a protocol\n> violation, in this case, a violation of the soft timeout.\n> > > > > * The channel it closed was closed because of this payment\n> attempt, and not because of another payment attempt, or some other\n> unrelated channel being unilaterally closed.\n> > > > >\n> > > > > First, what C needs to prove is *NOT*, in fact, actual channel\n> closure: it needs to prove a *willingness* to close a channel.\n> > > > > Thus, it does not require the channel to actually be *closed* yet,\n> i.e. it does not have to wait for onchain activity that the channel closure\n> is in a mempool and is confirmed deeply onchain etc etc.\n> > > > >\n> > > > > Thus, to prove a *willingness to close* rather than an actual\n> close, C can provide the unilateral close of the channel CE.\n> > > > > The act of unilaterally closing a channel is the publication of\n> the transaction(s) making up the unilateral close.\n> > > > > Thus, if C is *willing* to close the channel, it is willing to\n> publish the transaction(s) involved, and thus, providing the unilateral\n> close to B and further upstream, shows a willingness to close the channel.\n> > > > >\n> > > > > B then validates the provided proof-of-closure by checking that\n> the unilateral close transaction is either onchain, in the mempool, or that\n> it spends a TXO that is not currently spent by another transaction.\n> > > > > In the case the unilateral close transaction is not confirmed and\n> in the mempool, B can speed up its propagation on the Bitcoin layer by\n> putting it in its own mempool as well --- after all, C is willing to close\n> the channel to exonerate itself and punish the actual culprit, and B\n> putting the unilateral close in its own mempool can only help C in what it\n> is willing to do.\n> > > > >\n> > > > > Secondly, C needs to prove that the channel it is willing to close\n> involves the payment attempt, and is not some other channel closure that it\n> is attempting to use to fulfill its own soft timeout.\n> > > > > Since the unilateral close transaction *is* the proof-of-closure,\n> B (and A) can inspect the transaction outputs and see (with some additional\n> data from C) that one of the outputs is to an HTLC that matches the payment\n> hash.\n> > > > >\n> > > > > Thus, B (and A) can believe that the proof-of-closure proves that\n> whoever is presenting it is free of wrongdoing, as whoever is actually\n> causing the delay has been punished (by someone being willing to close a\n> channel with the culprit), and that the proof-of-closure commits to this\n> particular payment attempt and no other (because it commits to a particular\n> payment hash).\n> > > > >\n> > > > > Further, if CE is closed by E dropping it onchain rather than C, C\n> will still be able to fulfill its own soft timeout by taking the closing\n> transaction from E, which should still contain the HTLC.\n> > > > > Indeed, neither A nor B will particularly care (nor need to know)\n> who dropped the channel onchain, or (for A) that the channel participants\n> are C and E.\n> > > > >\n> > > > > Update State Shenanigans\n> > > > > ------------------------\n> > > > >\n> > > > > Bitcoin update mechanisms are complicated things, and it may be\n> possible for an attacking payee E to fool around with the update state\n> machine to make it difficult for C to report a willingness to close CE.\n> > > > >\n> > > > > In particular, I quote here the relevant passages from\n> `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the\n> Poon-Dryja update mechanism:\n> > > > >\n> > > > > > Thus each update traverses through the following states:\n> > > > > >\n> > > > > > 1. pending on the receiver\n> > > > > > 2. in the receiver's latest commitment transaction\n> > > > > > 3. ... and the receiver's previous commitment transaction has\n> been revoked,\n> > > > > >    and the update is pending on the sender\n> > > > > > 4. ... and in the sender's latest commitment transaction\n> > > > > > 5. ... and the sender's previous commitment transaction has been\n> revoked\n> > > > >\n> > > > > The payee E is the \"receiver\" in this context.\n> > > > >\n> > > > > In this case, once the update has reached step 2, then E has a\n> commitment transaction that it can put onchain, that contains an HTLC it\n> can claim.\n> > > > > From this step onward, C cannot send a failure (i.e. it cannot\n> send back an `update_fail_htlc`) back to B, because E could drop its latest\n> commitment onchain and claim the HTLC onchain.\n> > > > >\n> > > > > However, until step 4, C does not have a unilateral close\n> containing the HTLC, and thus cannot provide a proof-of-closure that\n> contains an HTLC that refers to the payment.\n> > > > >\n> > > > > Thus, between steps 2 to 4, C cannot safely respond to its own\n> soft timeout.\n> > > > > C cannot respond with a failure, as E could then drop its latest\n> commitment transaction onchain and claim the payment from C, and extract\n> money from C that way.\n> > > > > C also cannot respond with a proof-of-closure, as it does not have\n> a transaction that it can use to provide this proof.\n> > > > >\n> > > > > The best that C can do would be to impose an even shorter timeout\n> between steps 2 and 4 above, and to drop its current commitment transaction\n> (which does not contain the HTLC yet and thus does not constitute a valid\n> proof-of-closure) onchain.\n> > > > > In between the time it drops the commitment transaction and its\n> own incoming soft timeout, there is a chance, however small, that this\n> transaction will be confirmed, and the channel will (with high probability)\n> settle in a state where the HTLC is not instantiated, thus C can safely\n> fail its incoming HTLC (not show a proof-of-closure, since that is not\n> possible for C to do) without risk of loss, just prior to its own soft\n> timeout.\n> > > > >\n> > > > > Of course, C is still at risk here: E could collude with miners\n> via a side-channel fee offer to confirm its commitment transaction with the\n> HTLC present, and ensure that C is liable for the HTLC value.\n> > > > >\n> > > > > With Decker-Russell-Osuntokun, we can remove this risk by\n> requiring a ritual as follows:\n> > > > >\n> > > > > 1.  C requests exclusive access to update their single shared\n> state.\n> > > > >   * This can be done via a variety of sub-protocols, including a\n> fair coin toss in case of near-simultaneous requests for exclusive locks on\n> both sides.\n> > > > > 2.  C provides the details of the new HTLC to E.\n> > > > > 3.  C and E generate the new state transaction and exchange\n> signatures for it.\n> > > > > 4.  C and E generate (without signing) the new update transaction.\n> > > > > 5.  E provides the signature (or share of signature, if MuSig) for\n> the new update transaction to C.\n> > > > > 6.  C provides the signature for the new update transaction to E,\n> which releases the exclusive lock on the shared state atomically with the\n> finalization of the new update transaction.\n> > > > >\n> > > > > Prior to step 5, C can simply fail the incoming HTLC from B in\n> case its own soft timeout is near.\n> > > > > Even if E performs step 5 after C has already failed the incoming\n> HTLC from B, C can simply not perform step 6 and drop the channel onchain\n> with the previous update and state transactions.\n> > > > >\n> > > > > With Poon-Dryja, we will have to rearrange the order in which we\n> perform things, effectively adding an extra communications turnaround\n> between the participants.\n> > > > > Specifically, the order would have to be revised to:\n> > > > >\n> > > > > > 1. pending on the sender\n> > > > > > 2. in the sender's latest commitment transaction\n> > > > > > 3. ... and the sender's previous commitment transaction has been\n> revoked,\n> > > > > >    and the update is pending on the receiver\n> > > > > > 4. ... and in the receiver's latest commitment transaction\n> > > > > > 5. ... and the receiver's previous commitment transaction has\n> been revoked\n> > > > >\n> > > > > This allows the sender (C in our context) to provide a\n> proof-of-closure after step 2, and before step 2, C can safely return a\n> failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus\n> ensuring it can still use the previous commitment that still has no HTLC).\n> > > > >\n> > > > > Of course, this change will require redesigning the update state\n> machine, increasing the number of communication turnarounds, and creating a\n> subtle incompatbility when transitioning a payment from a hop that knows\n> only the old update state machine to a hop that knows the new update state\n> machine.\n> > > > >\n> > > > > Purely Falsified Proof-Of-Closure\n> > > > > ---------------------------------\n> > > > >\n> > > > > Of course, the attacking node E might want to create a false\n> proof-of-closure.\n> > > > > E can do this by simulating a Lightning channel: lock an amount of\n> funds in a 2-of-2 (where E controls both keys), then spend it in a set of\n> transactions mimicking the unilateral close.\n> > > > >\n> > > > > We observe, however, that the overhead of simulating a Lightning\n> channel is the same as the overhead of actually creating and closing a\n> Lightning channel.\n> > > > > Since the punishment of proof-of-closure is to force attackers to\n> have their channels closed, we can consider that this simulation of a\n> channel open and close is sufficient as well.\n> > > > >\n> > > > > Future-Proofing\n> > > > > ---------------\n> > > > >\n> > > > > This sketch of proof-of-closure can be used for any update\n> mechanism:\n> > > > >\n> > > > > * With Poon-Dryja, C can use its own commitment transaction as the\n> proof-of-closure.\n> > > > > * With Decker-Wattenhofer, C can give all the offchain\n> transactions up to the last stage in the multi-stage\n> decrementing-`nSequence` mechanism.\n> > > > > * With Deckker-Russell-Osuntokun, C can give the latest update and\n> state trnsaction.\n> > > > >\n> > > > > Basically, we expect that for now, and in the future, any update\n> mechanism worth consideration will have a concept of \"unilateral close\"\n> where a channel can be dropped onchain, using data that only one of the\n> channel participants holds.\n> > > > >\n> > > > > Such a unilateral close will be a sequence of one or more valid\n> transactions, terminating in a transaction containing an HTLC-like contract\n> in one of its outputs.\n> > > > >\n> > > > > Thus, to validate the unilateral close, it is only required to\n> validate all the transactions contained in the proof-of-closure, and see\n> that the last transaction has an HTLC output.\n> > > > >\n> > > > > The limitations are thus:\n> > > > >\n> > > > > * The acceptable forms of HTLC would need to be agreed-upon by the\n> entire network.\n> > > > > * Implementations would need to be able to assess, in a\n> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > > > >\n> > > > > Payment Decorrelation and Payment Points\n> > > > > ----------------------------------------\n> > > > >\n> > > > > Of course, having a single payment hash for the entire payment\n> attempt is a privacy loss, which we intend to fix in the near future by\n> using payment points, and adding a blinding scalar at each hop, aka.\n> payment decorrelation.\n> > > > >\n> > > > > Thus, in the future, there will not be any HTLC, but instead a\n> PTLC.\n> > > > > Further, the payment point at each hop will be changed at each\n> hop, in order to prevent decorrelation.\n> > > > >\n> > > > > Thus, C needs to provide proofs:\n> > > > >\n> > > > > * That an apparent singlesig on the unilateral close output is in\n> fact a PTLC.\n> > > > >   C needs to provide:\n> > > > >   * A target point P.\n> > > > >   * A partial signature that would spend that singlesig for a\n> particular sighash.\n> > > > >   * An adaptor signature which, with knowledge of the completed\n> signature, adaptor signature, and sighash message, would have revealed the\n> scalar behind P.\n> > > > > * That the PTLC belongs to the same payment attempt as what B\n> offered to C.\n> > > > >   C needs to provide:\n> > > > >   * The C-only blinding factor that is the difference between the\n> payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral\n> close.\n> > > > >\n> > > > > Then, when B needs to propagate the proof-of-closure back to A, B\n> simply adds its own blinding factor to the reported blinding factor, in\n> order to convince A that this is the same payment attempt.\n> > > > >\n> > > > > As we have brought up privacy, we observe that, when this\n> mechanism triggers, there is a mild privacy loss, in that intermediate\n> nodes now know some channel closure that is related to this payment, and\n> can thus determine the exact path that the payment attempt went through, at\n> least until the channel being closed.\n> > > > > However, proof-of-closure is only propagated in case of violation\n> of the soft timeout, so for normal non-malicious payments, proof-of-closure\n> does not cause any privacy loss.\n> > > > > _______________________________________________\n> > > > > Lightning-dev mailing list\n> > > > > Lightning-dev at lists.linuxfoundation.org\n> > > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200413/1e4aa596/attachment-0001.html>"
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-16T04:23:41",
                "message_text_only": "\" C cannot unlock until 144 blocks, so D can delay its response for up to\n143 blocks without any effect on its channels, this is *exactly* the\ngriefing attack.\"- Is there any way to account for the amount of time\nelapsed in the redeem script so that when D goes on chain just before\nelapse of the locktime, a decision can be enforced like \"do not pay the\nfull amount to D because of the response delay \"?\n\nOn Mon, Apr 13, 2020 at 9:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n>\n> > Ok. But this is a worse situation where C pays money to D but bound to\n> keep its resource locked for a longer duration, unlike D not responding and\n> C being able to unlock after the elapse of lock time.\n>\n> It is exactly the griefing attack scenario: it is the lock time at D that\n> is the problem.\n> As such, it is not \"worse\", it is ***exactly*** the griefing attack\n> scenario.\n>\n> C cannot unlock until 144 blocks, so D can delay its response for up to\n> 143 blocks without any effect on its channels, this is *exactly* the\n> griefing attack.\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > On Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > > Good morning Subhra,\n> > >\n> > > > Hello,\n> > > >       So based on what you have stated as possible scenario of\n> griefing attack, does delay in providing the preimage also counted as a\n> form of griefing in htlc? Like given the path A->B->C->D, what if C and D\n> has a lock time of 144 blocks and D responds after 142 block time elapses,\n> claiming the money locked with D?\n> > >\n> > > That ***is*** the griefing attack.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > >\n> > > > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> > > >\n> > > > > Introduction\n> > > > > ============\n> > > > >\n> > > > > Given the fact that contracts on offchain protocols need to be\n> enforceable onchain as well, timelocks involved in multi-hop payments are\n> measured in blocks.\n> > > > > This is because the blockchain can only (third-party-verifiably)\n> enforce timeouts in units of entire blocks.\n> > > > > This leads to very long timeouts for payment delivery, thus\n> multi-hop offchain payment attempts can be, deliberately or accidentally,\n> be in a \"pending\" state up to the very large timeouts involved.\n> > > > >\n> > > > > Deliberately setting up a multi-hop payment such that it will be\n> in a \"pending\" state for long periods of time is colloquially known as a\n> \"griefing attack\".\n> > > > > In this article, we assess various proposed solutions to mitigate\n> the effects of griefing attacks, and propose a particular solution,\n> proof-of-closure, as well, that requires significant changes to the update\n> state machine.\n> > > > >\n> > > > > Digression: Why Grief?\n> > > > > ======================\n> > > > >\n> > > > > Before embarking on our investigation for solutions to the\n> griefing problem, we should first wonder if griefing is, in fact, a problem.\n> > > > >\n> > > > > This brings up the question of: why would anybody grief at all?\n> > > > >\n> > > > > Humans, like cats and other less-sapient pieces of walking meat,\n> often find enjoyment in causing the suffering of others for no immediate\n> direct gain to themselves, as a public demonstration of dominance over\n> those they make suffer (aka \"shits and giggles\", which, if executed\n> correctly, can lead to eventual direct gains to themselves or their progeny\n> or relatives or allies, but such details are often outside the ken of the\n> very beings who execute such survival strategies: brains are pieces of meat\n> that have been hacked to act as action-reaction engines, but are not\n> sophisticated enough to execute as pure rationality engines at all times).\n> > > > > Fortunately, in the Bitcoin world, only purely rational beings of\n> pure selfishness can exist in the long run, thus we can neglect such\n> motivations as mere noise.\n> > > > >\n> > > > > First, let us investigate *how* griefing attacks can be performed.\n> > > > >\n> > > > > * An intermediate node in a multi-hop attempt can delay forwarding\n> or failing an incoming HTLC.\n> > > > > * A final node in a payment attempt can delay claiming an incoming\n> HTLC.\n> > > > >\n> > > > > Let us consider a purely rational intermediate node of pure\n> selfishness:\n> > > > >\n> > > > > * If it forwards as soon as possible, it can earn fees, and also\n> speed up the release of the HTLC-locked funds so that they can reuse those\n> funds as liquidity for further payment attempts.\n> > > > > * Thus, delaying an HTLC is not selfishly-rational for an\n> intermediate node.\n> > > > >\n> > > > > Thus, for an intermediate node, it seems there is no\n> selfishly-rational motivation to execute a griefing attack on an arbitrary\n> payment attempt.\n> > > > > We can then conclude that an intermediate that delays a payment\n> would do so, not of its own rational self-interest, but as an accident,\n> such as an unforeseen connectivity or power failure.\n> > > > >\n> > > > > However, things are different when we consider a non-arbitrary\n> payment.\n> > > > > Suppose a node were to make a payment attempt to itself, and\n> deliberately delay claiming this self-payment.\n> > > > > This lets any single node, *who happens to own large liquidity*,\n> to lock up the liquidity of other nodes.\n> > > > >\n> > > > > The motivation to lock up the liquidity of other nodes is to\n> *eliminate competition*.\n> > > > > Suppose we have a network as below:\n> > > > >\n> > > > >     A -- B -- C\n> > > > >       \\     /\n> > > > >        \\   /\n> > > > >         \\ /\n> > > > >          E\n> > > > >\n> > > > > When A and C want to transact with one another, they may choose to\n> route via either B or E.\n> > > > > B and E are therefore competitors in the business of forwarding\n> payments.\n> > > > >\n> > > > > But suppose E has much larger channels AE and CE than the channels\n> of AB and CB.\n> > > > > For example, suppose E has 100mBTC perfectly-balanced channels\n> while B has only 10mBTC perfectly-balanced channels, as all things should\n> be in simplified models of reality.\n> > > > > E can then \"take out the competition\" by making a 5mBTC\n> self-payment along E->A->B->C->E and a 5mBTC self-payment along\n> E->C->B->A->E, then refusing to claim the payment, tying up all the\n> liquidity of the channels of B.\n> > > > > By doing so, it can ensure that A and C will always fail to pay\n> via B, even if they wish to transact in amounts less than 5mBTC.\n> > > > > E thereby eliminates B as a competitor.\n> > > > >\n> > > > > This demonstrates that griefing attacks will be motivated, such\n> that such attacks will be performed by payers and payees *against\n> intermediate nodes*.\n> > > > > Intermediate nodes have no motivation to attack payers and payees\n> (those are their potential customers in the business of forwarding\n> payments, and attacking potential customers is bad business: such attacking\n> intermediate nodes will be removed economically in the long run).\n> > > > > However, payers and payees can become motivated to attack\n> intermediate nodes, if the \"payer\" and \"payee\" are actually competitor\n> intermediate nodes.\n> > > > >\n> > > > > (We can observe that this is always a possibility even outside of\n> Lightning: a service or product provider has no incentive to attack its\n> customers (\"the customer is always right\"), but have an incentive to\n> *pretend* to be a customer of a competitor and attack them.)\n> > > > >\n> > > > > We will keep this fact in mind: active griefing attacks are\n> attacks *on* intermediate nodes, not *by* intermediate nodes, because there\n> is no economic incentive for intermediate nodes to attack their customers.\n> > > > >\n> > > > > Previous Proposed Solutions\n> > > > > ===========================\n> > > > >\n> > > > > Time-Spent Reporting\n> > > > > --------------------\n> > > > >\n> > > > > At each channel along the route, the time spent by a node to\n> handle its forwarding is recorded, and reported upstream in the route.\n> > > > >\n> > > > > Unfortunately, this solution protects payers from intermediate\n> nodes and payees: it does not protect intermediate nodes from colluding\n> payers and payees.\n> > > > > Even if an intermediate node knows that a particular node is\n> consistently slow via a previous time-spent report, it will not be able,\n> with our current onion routing, determine if an onion packet it just\n> received will or will not go through the known-slow node.\n> > > > > Thus, an intermediate node would not be able to defend against\n> distant payees that, with a colluding payer, will not claim a particular\n> payment.\n> > > > >\n> > > > > As we have established, an active griefing atttack will never be\n> deliberately performed by a selfishly-rational intermediate node.\n> > > > > Thus, this solution protects against the wrong thing: it protects\n> payers against slow/unreliable intermediate nodes, it does not protect\n> intermediate nodes against malicious payer/payee collusions.\n> > > > > It protects only against intermediate nodes that inadvertently go\n> offline during forwarding, but such nodes will inevitably lose out on the\n> forwarding market anyway, and will disappear in the long run.\n> > > > >\n> > > > > Up-Front Payment\n> > > > > ----------------\n> > > > >\n> > > > > Payers pay for an attempt, not just the successful completion of\n> an attempt.\n> > > > >\n> > > > > A variation on this is that the payer (or payee) continuously pays\n> as long as the payment is pending.\n> > > > > Further variations include paying by other means, such as just\n> locking funds or paying with proof-of-work.\n> > > > >\n> > > > > While it certainly erects economic barriers against payer/payee\n> collusions attacking intermediate nodes, it *also* erects economic barriers\n> against normal, non-malicious payments.\n> > > > >\n> > > > > We can consider that economic barriers against non-malicious,\n> low-value, high-frequency payments (\"micropayments\") may be enough that\n> such payments become infeasible if we impose up-front payment for mere\n> attempts.\n> > > > > Thus, while this solution is certainly something we can consider,\n> we must be reluctant to use it due to its up-front, strict-evaluation\n> behavior.\n> > > > >\n> > > > > Proof-Of-Closure\n> > > > > ================\n> > > > >\n> > > > > Observing the above, we want the properties for a \"good\" solution\n> to griefing attacks to be:\n> > > > >\n> > > > > * It should protect intermediate nodes against payer/payee\n> collusions.\n> > > > > * It should only come into play upon detection of an attack.\n> > > > >\n> > > > > We now present proof-of-closure, which (we hope) has the above\n> properties.\n> > > > >\n> > > > > We can consider instead a softer timeout, distinct from the HTLC\n> block-based timeout.\n> > > > > This softer timeout is measurable in fractions of a second, e.g.\n> units of 0.1 seconds.\n> > > > >\n> > > > > Each node on the network advertises, in addition to a block-based\n> `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > > > Further, each invoice contains, in addition to a block-based\n> `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > > > >\n> > > > > Thus, there are two timeouts:\n> > > > >\n> > > > > * The current \"hard\" block-based timeout that is enforceable\n> onchain.\n> > > > > * A new \"soft\" sidereal-time-based timeout that is not onchain\n> enforceable.\n> > > > >\n> > > > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > > > Instead, enforcement of the soft timeout *is* the act of putting\n> the channel state onchain.\n> > > > >\n> > > > > Now, for the current \"hard\" block-based timeout, we already have a\n> reaction.\n> > > > > If the HTLC \"hard\" timeout is approaching:\n> > > > >\n> > > > > * Drop the channel onchain and enforce the hard timeout onchain to\n> reclaim the funds in the HTLCs.\n> > > > > * Wait for the onchain action to be deeply resolved (either\n> timelock or hashlock branch is confirmed deeply) and report the result\n> (success or fail) upstream.\n> > > > >\n> > > > > What happens if the \"soft\" timeout is violated?\n> > > > >\n> > > > > * Drop the channel onchain.\n> > > > > * Report the channel closure upstream.\n> > > > >\n> > > > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > > > >\n> > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel.\n> > > > >\n> > > > > The \"soft\" timeout is cancelled in any of these three conditions,\n> the first two of which are the same as above:\n> > > > >\n> > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > > > * A channel closure is reported.\n> > > > >\n> > > > > Let us fill this in more detail.\n> > > > >\n> > > > > Suppose we have a payment route A->B->C->E.\n> > > > >\n> > > > > Both the \"hard\" block timeouts and the \"soft\" second timeouts\n> decrement monotonically at each hop.\n> > > > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as\n> normal).\n> > > > >\n> > > > > * Suppose E then delays claiming the payment and violates the\n> \"soft\" timeout.\n> > > > > * C then drops the CE channel onchain.\n> > > > > * C reports, before its own timeout (slightly larger than the\n> timeout imposed on E), the closing of the channel CE, to B.\n> > > > > * B validates this report, and if valid, propagates the report to\n> A.\n> > > > > * A validates this report, and if valid, accepts that the payment\n> will be \"stuck\" for up to the hard timeout it imposed on B.\n> > > > >\n> > > > > C has to report back to B in order to prevent B from closing the\n> BC channel, and B has to report back to A in order to prevent A from\n> closing the AB channel.\n> > > > > The decrementing seconds-unit timeouts are needed for each hop,\n> for the same reason that decrementing block-unit timeouts are needed.\n> > > > >\n> > > > > Since E is motivated to attack intermediate nodes because it wants\n> to redirect payment forwards through itself rather than its competitotrs,\n> having one of its channels closed (which prevents it from being used for\n> forwarding) is directly opposed to its end goal of getting more money,\n> thus, we can believe the action of closing a channel involved in a griefing\n> attack is sufficient disincentive.\n> > > > >\n> > > > > The major drawback is that enforcement of the soft timeout *is* a\n> channel closure, which is generally a negative for the network.\n> > > > > This is not a remote attack vector, since a node can only trigger\n> this closure if it is able to stall the fulfillment or failure of an HTLC\n> on a channel, which generally means the node triggering this closure can\n> only do so for its own channels (or it is able to, via a separate\n> mechanism, remotely crash a different node).\n> > > > >\n> > > > > Proving Channel Closes\n> > > > > ----------------------\n> > > > >\n> > > > > What C *really* needs to prove is that:\n> > > > >\n> > > > > * It is *willing* to close a channel due to a violation of the\n> soft timeout.\n> > > > > * The channel it is willing to close was, in fact, involved in the\n> same payment attempt.\n> > > > >\n> > > > > With the above, B can believe that C was innocent of wrongdoing,\n> because:\n> > > > >\n> > > > > * C would only be wiling to close a channel in case of a protocol\n> violation, in this case, a violation of the soft timeout.\n> > > > > * The channel it closed was closed because of this payment\n> attempt, and not because of another payment attempt, or some other\n> unrelated channel being unilaterally closed.\n> > > > >\n> > > > > First, what C needs to prove is *NOT*, in fact, actual channel\n> closure: it needs to prove a *willingness* to close a channel.\n> > > > > Thus, it does not require the channel to actually be *closed* yet,\n> i.e. it does not have to wait for onchain activity that the channel closure\n> is in a mempool and is confirmed deeply onchain etc etc.\n> > > > >\n> > > > > Thus, to prove a *willingness to close* rather than an actual\n> close, C can provide the unilateral close of the channel CE.\n> > > > > The act of unilaterally closing a channel is the publication of\n> the transaction(s) making up the unilateral close.\n> > > > > Thus, if C is *willing* to close the channel, it is willing to\n> publish the transaction(s) involved, and thus, providing the unilateral\n> close to B and further upstream, shows a willingness to close the channel.\n> > > > >\n> > > > > B then validates the provided proof-of-closure by checking that\n> the unilateral close transaction is either onchain, in the mempool, or that\n> it spends a TXO that is not currently spent by another transaction.\n> > > > > In the case the unilateral close transaction is not confirmed and\n> in the mempool, B can speed up its propagation on the Bitcoin layer by\n> putting it in its own mempool as well --- after all, C is willing to close\n> the channel to exonerate itself and punish the actual culprit, and B\n> putting the unilateral close in its own mempool can only help C in what it\n> is willing to do.\n> > > > >\n> > > > > Secondly, C needs to prove that the channel it is willing to close\n> involves the payment attempt, and is not some other channel closure that it\n> is attempting to use to fulfill its own soft timeout.\n> > > > > Since the unilateral close transaction *is* the proof-of-closure,\n> B (and A) can inspect the transaction outputs and see (with some additional\n> data from C) that one of the outputs is to an HTLC that matches the payment\n> hash.\n> > > > >\n> > > > > Thus, B (and A) can believe that the proof-of-closure proves that\n> whoever is presenting it is free of wrongdoing, as whoever is actually\n> causing the delay has been punished (by someone being willing to close a\n> channel with the culprit), and that the proof-of-closure commits to this\n> particular payment attempt and no other (because it commits to a particular\n> payment hash).\n> > > > >\n> > > > > Further, if CE is closed by E dropping it onchain rather than C, C\n> will still be able to fulfill its own soft timeout by taking the closing\n> transaction from E, which should still contain the HTLC.\n> > > > > Indeed, neither A nor B will particularly care (nor need to know)\n> who dropped the channel onchain, or (for A) that the channel participants\n> are C and E.\n> > > > >\n> > > > > Update State Shenanigans\n> > > > > ------------------------\n> > > > >\n> > > > > Bitcoin update mechanisms are complicated things, and it may be\n> possible for an attacking payee E to fool around with the update state\n> machine to make it difficult for C to report a willingness to close CE.\n> > > > >\n> > > > > In particular, I quote here the relevant passages from\n> `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the\n> Poon-Dryja update mechanism:\n> > > > >\n> > > > > > Thus each update traverses through the following states:\n> > > > > >\n> > > > > > 1. pending on the receiver\n> > > > > > 2. in the receiver's latest commitment transaction\n> > > > > > 3. ... and the receiver's previous commitment transaction has\n> been revoked,\n> > > > > >    and the update is pending on the sender\n> > > > > > 4. ... and in the sender's latest commitment transaction\n> > > > > > 5. ... and the sender's previous commitment transaction has been\n> revoked\n> > > > >\n> > > > > The payee E is the \"receiver\" in this context.\n> > > > >\n> > > > > In this case, once the update has reached step 2, then E has a\n> commitment transaction that it can put onchain, that contains an HTLC it\n> can claim.\n> > > > > From this step onward, C cannot send a failure (i.e. it cannot\n> send back an `update_fail_htlc`) back to B, because E could drop its latest\n> commitment onchain and claim the HTLC onchain.\n> > > > >\n> > > > > However, until step 4, C does not have a unilateral close\n> containing the HTLC, and thus cannot provide a proof-of-closure that\n> contains an HTLC that refers to the payment.\n> > > > >\n> > > > > Thus, between steps 2 to 4, C cannot safely respond to its own\n> soft timeout.\n> > > > > C cannot respond with a failure, as E could then drop its latest\n> commitment transaction onchain and claim the payment from C, and extract\n> money from C that way.\n> > > > > C also cannot respond with a proof-of-closure, as it does not have\n> a transaction that it can use to provide this proof.\n> > > > >\n> > > > > The best that C can do would be to impose an even shorter timeout\n> between steps 2 and 4 above, and to drop its current commitment transaction\n> (which does not contain the HTLC yet and thus does not constitute a valid\n> proof-of-closure) onchain.\n> > > > > In between the time it drops the commitment transaction and its\n> own incoming soft timeout, there is a chance, however small, that this\n> transaction will be confirmed, and the channel will (with high probability)\n> settle in a state where the HTLC is not instantiated, thus C can safely\n> fail its incoming HTLC (not show a proof-of-closure, since that is not\n> possible for C to do) without risk of loss, just prior to its own soft\n> timeout.\n> > > > >\n> > > > > Of course, C is still at risk here: E could collude with miners\n> via a side-channel fee offer to confirm its commitment transaction with the\n> HTLC present, and ensure that C is liable for the HTLC value.\n> > > > >\n> > > > > With Decker-Russell-Osuntokun, we can remove this risk by\n> requiring a ritual as follows:\n> > > > >\n> > > > > 1.  C requests exclusive access to update their single shared\n> state.\n> > > > >   * This can be done via a variety of sub-protocols, including a\n> fair coin toss in case of near-simultaneous requests for exclusive locks on\n> both sides.\n> > > > > 2.  C provides the details of the new HTLC to E.\n> > > > > 3.  C and E generate the new state transaction and exchange\n> signatures for it.\n> > > > > 4.  C and E generate (without signing) the new update transaction.\n> > > > > 5.  E provides the signature (or share of signature, if MuSig) for\n> the new update transaction to C.\n> > > > > 6.  C provides the signature for the new update transaction to E,\n> which releases the exclusive lock on the shared state atomically with the\n> finalization of the new update transaction.\n> > > > >\n> > > > > Prior to step 5, C can simply fail the incoming HTLC from B in\n> case its own soft timeout is near.\n> > > > > Even if E performs step 5 after C has already failed the incoming\n> HTLC from B, C can simply not perform step 6 and drop the channel onchain\n> with the previous update and state transactions.\n> > > > >\n> > > > > With Poon-Dryja, we will have to rearrange the order in which we\n> perform things, effectively adding an extra communications turnaround\n> between the participants.\n> > > > > Specifically, the order would have to be revised to:\n> > > > >\n> > > > > > 1. pending on the sender\n> > > > > > 2. in the sender's latest commitment transaction\n> > > > > > 3. ... and the sender's previous commitment transaction has been\n> revoked,\n> > > > > >    and the update is pending on the receiver\n> > > > > > 4. ... and in the receiver's latest commitment transaction\n> > > > > > 5. ... and the receiver's previous commitment transaction has\n> been revoked\n> > > > >\n> > > > > This allows the sender (C in our context) to provide a\n> proof-of-closure after step 2, and before step 2, C can safely return a\n> failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus\n> ensuring it can still use the previous commitment that still has no HTLC).\n> > > > >\n> > > > > Of course, this change will require redesigning the update state\n> machine, increasing the number of communication turnarounds, and creating a\n> subtle incompatbility when transitioning a payment from a hop that knows\n> only the old update state machine to a hop that knows the new update state\n> machine.\n> > > > >\n> > > > > Purely Falsified Proof-Of-Closure\n> > > > > ---------------------------------\n> > > > >\n> > > > > Of course, the attacking node E might want to create a false\n> proof-of-closure.\n> > > > > E can do this by simulating a Lightning channel: lock an amount of\n> funds in a 2-of-2 (where E controls both keys), then spend it in a set of\n> transactions mimicking the unilateral close.\n> > > > >\n> > > > > We observe, however, that the overhead of simulating a Lightning\n> channel is the same as the overhead of actually creating and closing a\n> Lightning channel.\n> > > > > Since the punishment of proof-of-closure is to force attackers to\n> have their channels closed, we can consider that this simulation of a\n> channel open and close is sufficient as well.\n> > > > >\n> > > > > Future-Proofing\n> > > > > ---------------\n> > > > >\n> > > > > This sketch of proof-of-closure can be used for any update\n> mechanism:\n> > > > >\n> > > > > * With Poon-Dryja, C can use its own commitment transaction as the\n> proof-of-closure.\n> > > > > * With Decker-Wattenhofer, C can give all the offchain\n> transactions up to the last stage in the multi-stage\n> decrementing-`nSequence` mechanism.\n> > > > > * With Deckker-Russell-Osuntokun, C can give the latest update and\n> state trnsaction.\n> > > > >\n> > > > > Basically, we expect that for now, and in the future, any update\n> mechanism worth consideration will have a concept of \"unilateral close\"\n> where a channel can be dropped onchain, using data that only one of the\n> channel participants holds.\n> > > > >\n> > > > > Such a unilateral close will be a sequence of one or more valid\n> transactions, terminating in a transaction containing an HTLC-like contract\n> in one of its outputs.\n> > > > >\n> > > > > Thus, to validate the unilateral close, it is only required to\n> validate all the transactions contained in the proof-of-closure, and see\n> that the last transaction has an HTLC output.\n> > > > >\n> > > > > The limitations are thus:\n> > > > >\n> > > > > * The acceptable forms of HTLC would need to be agreed-upon by the\n> entire network.\n> > > > > * Implementations would need to be able to assess, in a\n> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > > > >\n> > > > > Payment Decorrelation and Payment Points\n> > > > > ----------------------------------------\n> > > > >\n> > > > > Of course, having a single payment hash for the entire payment\n> attempt is a privacy loss, which we intend to fix in the near future by\n> using payment points, and adding a blinding scalar at each hop, aka.\n> payment decorrelation.\n> > > > >\n> > > > > Thus, in the future, there will not be any HTLC, but instead a\n> PTLC.\n> > > > > Further, the payment point at each hop will be changed at each\n> hop, in order to prevent decorrelation.\n> > > > >\n> > > > > Thus, C needs to provide proofs:\n> > > > >\n> > > > > * That an apparent singlesig on the unilateral close output is in\n> fact a PTLC.\n> > > > >   C needs to provide:\n> > > > >   * A target point P.\n> > > > >   * A partial signature that would spend that singlesig for a\n> particular sighash.\n> > > > >   * An adaptor signature which, with knowledge of the completed\n> signature, adaptor signature, and sighash message, would have revealed the\n> scalar behind P.\n> > > > > * That the PTLC belongs to the same payment attempt as what B\n> offered to C.\n> > > > >   C needs to provide:\n> > > > >   * The C-only blinding factor that is the difference between the\n> payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral\n> close.\n> > > > >\n> > > > > Then, when B needs to propagate the proof-of-closure back to A, B\n> simply adds its own blinding factor to the reported blinding factor, in\n> order to convince A that this is the same payment attempt.\n> > > > >\n> > > > > As we have brought up privacy, we observe that, when this\n> mechanism triggers, there is a mild privacy loss, in that intermediate\n> nodes now know some channel closure that is related to this payment, and\n> can thus determine the exact path that the payment attempt went through, at\n> least until the channel being closed.\n> > > > > However, proof-of-closure is only propagated in case of violation\n> of the soft timeout, so for normal non-malicious payments, proof-of-closure\n> does not cause any privacy loss.\n> > > > > _______________________________________________\n> > > > > Lightning-dev mailing list\n> > > > > Lightning-dev at lists.linuxfoundation.org\n> > > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200416/6e7099cf/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-16T05:09:21",
                "message_text_only": "Good morning Subhra,\n\n> \" C cannot unlock until 144 blocks, so D can delay its response for up to 143 blocks without any effect on its channels, this is *exactly* the griefing attack.\"- Is there any way to account for the amount of time elapsed in the redeem script so that when D goes on chain just before elapse of the locktime, a decision can be enforced like \"do not pay the full amount to D because of the response delay \"?\n>\n\nNo, not without breaking certain principles of Bitcoin.\n\nIn particular, one possible solution would be to have multiple staggered transactions that are timelocked at particular times, so for example if it responds at +1 it gets more money than if it responds at +2, +3, +4 etc.\n\nHowever, because of the way timelock works, the transaction that is valid at +1 remains valid at any future time.\nThis is the principle \"a transaction that becomes valid is always valid in the future unless double-spent\".\nBitcoin Core uses this to reduce validation overhead: it only needs to validate a transaction (i.e. execute the SCRIPT, which is one of the slower operations) on entry to the mempool.\nThen, once the transaction is in the mempool, it is known to be valid forever unless double-spent, so Bitcoin does not need to re-evaluate its SCRIPT.\n\nAny mechanism that requires invalidating previous transactions requires double-spending those transactions and using some other mechanism to ensure that the invalidated transaction is not useable again.\nThis involves significant amounts of transactions that will need to be presented onchain in this case (because D is expected to lose money in this mechanism, it will definitely not participate in consensus that will advance the channel state such that it loses money, so the channel has to be dropped onchain anyway to perform this enforcement).\n\nAnother principle is \"SCRIPT can only check the transaction it is executing for\".\nThus, a `redeemScript` will only be able to execute on the transaction that presents it, and a `scriptPubKey` can only be executed on the transaction spending that output.\nThis means that SCRIPT can only inspect the transaction that it is executing on, and cannot look at anything else in the universe.\nThis principle simplifies initial block download --- in order to validate a SCRIPT, you only need to look at each individual transaction in a block without having to know any data other than that specific transaction.\n\nFor example, `OP_CHECKLOCKTIMEVERIFY` does ***not*** work by checking the blockheight or claimed sidereal time that the block that contains it has.\nInstead, it works by checking the `nLockTime` field of the *transaction* it is executing under.\nBy this, the SCRIPT interpreter only needs to input the transaction that is triggering the execution of the SCRIPT, and does not need access to external state, time, etc. etc.\n\nThese two principles in combination make it difficult-to-impossible to create a mechanism to deduct funds from D because of response delay.\n\nRegards,\nZmnSCPxj\n\n> On Mon, Apr 13, 2020 at 9:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Subhra,\n> >\n> > > Ok. But this is a worse situation where C pays money to D but bound to keep its resource locked for a longer duration, unlike D not responding and C being able to unlock after the elapse of lock time.\n> >\n> > It is exactly the griefing attack scenario: it is the lock time at D that is the problem.\n> > As such, it is not \"worse\", it is ***exactly*** the griefing attack scenario.\n> >\n> > C cannot unlock until 144 blocks, so D can delay its response for up to 143 blocks without any effect on its channels, this is *exactly* the griefing attack.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > >\n> > > On Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > >\n> > > > Good morning Subhra,\n> > > >\n> > > > > Hello,\n> > > > > \u00a0 \u00a0 \u00a0 So based on what you have stated as possible scenario of griefing attack, does delay in providing the preimage also counted as a form of griefing in htlc? Like given the path A->B->C->D, what if C and D has a lock time of 144 blocks and D responds after 142 block time elapses, claiming the money locked with D?\n> > > >\n> > > > That ***is*** the griefing attack.\n> > > >\n> > > > Regards,\n> > > > ZmnSCPxj\n> > > >\n> > > > >\n> > > > > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> > > > >\n> > > > > > Introduction\n> > > > > > ============\n> > > > > >\n> > > > > > Given the fact that contracts on offchain protocols need to be enforceable onchain as well, timelocks involved in multi-hop payments are measured in blocks.\n> > > > > > This is because the blockchain can only (third-party-verifiably) enforce timeouts in units of entire blocks.\n> > > > > > This leads to very long timeouts for payment delivery, thus multi-hop offchain payment attempts can be, deliberately or accidentally, be in a \"pending\" state up to the very large timeouts involved.\n> > > > > >\n> > > > > > Deliberately setting up a multi-hop payment such that it will be in a \"pending\" state for long periods of time is colloquially known as a \"griefing attack\".\n> > > > > > In this article, we assess various proposed solutions to mitigate the effects of griefing attacks, and propose a particular solution, proof-of-closure, as well, that requires significant changes to the update state machine.\n> > > > > >\n> > > > > > Digression: Why Grief?\n> > > > > > ======================\n> > > > > >\n> > > > > > Before embarking on our investigation for solutions to the griefing problem, we should first wonder if griefing is, in fact, a problem.\n> > > > > >\n> > > > > > This brings up the question of: why would anybody grief at all?\n> > > > > >\n> > > > > > Humans, like cats and other less-sapient pieces of walking meat, often find enjoyment in causing the suffering of others for no immediate direct gain to themselves, as a public demonstration of dominance over those they make suffer (aka \"shits and giggles\", which, if executed correctly, can lead to eventual direct gains to themselves or their progeny or relatives or allies, but such details are often outside the ken of the very beings who execute such survival strategies: brains are pieces of meat that have been hacked to act as action-reaction engines, but are not sophisticated enough to execute as pure rationality engines at all times).\n> > > > > > Fortunately, in the Bitcoin world, only purely rational beings of pure selfishness can exist in the long run, thus we can neglect such motivations as mere noise.\n> > > > > >\n> > > > > > First, let us investigate *how* griefing attacks can be performed.\n> > > > > >\n> > > > > > * An intermediate node in a multi-hop attempt can delay forwarding or failing an incoming HTLC.\n> > > > > > * A final node in a payment attempt can delay claiming an incoming HTLC.\n> > > > > >\n> > > > > > Let us consider a purely rational intermediate node of pure selfishness:\n> > > > > >\n> > > > > > * If it forwards as soon as possible, it can earn fees, and also speed up the release of the HTLC-locked funds so that they can reuse those funds as liquidity for further payment attempts.\n> > > > > > * Thus, delaying an HTLC is not selfishly-rational for an intermediate node.\n> > > > > >\n> > > > > > Thus, for an intermediate node, it seems there is no selfishly-rational motivation to execute a griefing attack on an arbitrary payment attempt.\n> > > > > > We can then conclude that an intermediate that delays a payment would do so, not of its own rational self-interest, but as an accident, such as an unforeseen connectivity or power failure.\n> > > > > >\n> > > > > > However, things are different when we consider a non-arbitrary payment.\n> > > > > > Suppose a node were to make a payment attempt to itself, and deliberately delay claiming this self-payment.\n> > > > > > This lets any single node, *who happens to own large liquidity*, to lock up the liquidity of other nodes.\n> > > > > >\n> > > > > > The motivation to lock up the liquidity of other nodes is to *eliminate competition*.\n> > > > > > Suppose we have a network as below:\n> > > > > >\n> > > > > > \u00a0 \u00a0 A -- B -- C\n> > > > > > \u00a0 \u00a0 \u00a0 \\\u00a0 \u00a0 \u00a0/\n> > > > > > \u00a0 \u00a0 \u00a0 \u00a0\\\u00a0 \u00a0/\n> > > > > > \u00a0 \u00a0 \u00a0 \u00a0 \\ /\n> > > > > > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0E\n> > > > > >\n> > > > > > When A and C want to transact with one another, they may choose to route via either B or E.\n> > > > > > B and E are therefore competitors in the business of forwarding payments.\n> > > > > >\n> > > > > > But suppose E has much larger channels AE and CE than the channels of AB and CB.\n> > > > > > For example, suppose E has 100mBTC perfectly-balanced channels while B has only 10mBTC perfectly-balanced channels, as all things should be in simplified models of reality.\n> > > > > > E can then \"take out the competition\" by making a 5mBTC self-payment along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing to claim the payment, tying up all the liquidity of the channels of B.\n> > > > > > By doing so, it can ensure that A and C will always fail to pay via B, even if they wish to transact in amounts less than 5mBTC.\n> > > > > > E thereby eliminates B as a competitor.\n> > > > > >\n> > > > > > This demonstrates that griefing attacks will be motivated, such that such attacks will be performed by payers and payees *against intermediate nodes*.\n> > > > > > Intermediate nodes have no motivation to attack payers and payees (those are their potential customers in the business of forwarding payments, and attacking potential customers is bad business: such attacking intermediate nodes will be removed economically in the long run).\n> > > > > > However, payers and payees can become motivated to attack intermediate nodes, if the \"payer\" and \"payee\" are actually competitor intermediate nodes.\n> > > > > >\n> > > > > > (We can observe that this is always a possibility even outside of Lightning: a service or product provider has no incentive to attack its customers (\"the customer is always right\"), but have an incentive to *pretend* to be a customer of a competitor and attack them.)\n> > > > > >\n> > > > > > We will keep this fact in mind: active griefing attacks are attacks *on* intermediate nodes, not *by* intermediate nodes, because there is no economic incentive for intermediate nodes to attack their customers.\n> > > > > >\n> > > > > > Previous Proposed Solutions\n> > > > > > ===========================\n> > > > > >\n> > > > > > Time-Spent Reporting\n> > > > > > --------------------\n> > > > > >\n> > > > > > At each channel along the route, the time spent by a node to handle its forwarding is recorded, and reported upstream in the route.\n> > > > > >\n> > > > > > Unfortunately, this solution protects payers from intermediate nodes and payees: it does not protect intermediate nodes from colluding payers and payees.\n> > > > > > Even if an intermediate node knows that a particular node is consistently slow via a previous time-spent report, it will not be able, with our current onion routing, determine if an onion packet it just received will or will not go through the known-slow node.\n> > > > > > Thus, an intermediate node would not be able to defend against distant payees that, with a colluding payer, will not claim a particular payment.\n> > > > > >\n> > > > > > As we have established, an active griefing atttack will never be deliberately performed by a selfishly-rational intermediate node.\n> > > > > > Thus, this solution protects against the wrong thing: it protects payers against slow/unreliable intermediate nodes, it does not protect intermediate nodes against malicious payer/payee collusions.\n> > > > > > It protects only against intermediate nodes that inadvertently go offline during forwarding, but such nodes will inevitably lose out on the forwarding market anyway, and will disappear in the long run.\n> > > > > >\n> > > > > > Up-Front Payment\n> > > > > > ----------------\n> > > > > >\n> > > > > > Payers pay for an attempt, not just the successful completion of an attempt.\n> > > > > >\n> > > > > > A variation on this is that the payer (or payee) continuously pays as long as the payment is pending.\n> > > > > > Further variations include paying by other means, such as just locking funds or paying with proof-of-work.\n> > > > > >\n> > > > > > While it certainly erects economic barriers against payer/payee collusions attacking intermediate nodes, it *also* erects economic barriers against normal, non-malicious payments.\n> > > > > >\n> > > > > > We can consider that economic barriers against non-malicious, low-value, high-frequency payments (\"micropayments\") may be enough that such payments become infeasible if we impose up-front payment for mere attempts.\n> > > > > > Thus, while this solution is certainly something we can consider, we must be reluctant to use it due to its up-front, strict-evaluation behavior.\n> > > > > >\n> > > > > > Proof-Of-Closure\n> > > > > > ================\n> > > > > >\n> > > > > > Observing the above, we want the properties for a \"good\" solution to griefing attacks to be:\n> > > > > >\n> > > > > > * It should protect intermediate nodes against payer/payee collusions.\n> > > > > > * It should only come into play upon detection of an attack.\n> > > > > >\n> > > > > > We now present proof-of-closure, which (we hope) has the above properties.\n> > > > > >\n> > > > > > We can consider instead a softer timeout, distinct from the HTLC block-based timeout.\n> > > > > > This softer timeout is measurable in fractions of a second, e.g. units of 0.1 seconds.\n> > > > > >\n> > > > > > Each node on the network advertises, in addition to a block-based `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > > > > Further, each invoice contains, in addition to a block-based `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > > > > >\n> > > > > > Thus, there are two timeouts:\n> > > > > >\n> > > > > > * The current \"hard\" block-based timeout that is enforceable onchain.\n> > > > > > * A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n> > > > > >\n> > > > > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > > > > Instead, enforcement of the soft timeout *is* the act of putting the channel state onchain.\n> > > > > >\n> > > > > > Now, for the current \"hard\" block-based timeout, we already have a reaction.\n> > > > > > If the HTLC \"hard\" timeout is approaching:\n> > > > > >\n> > > > > > * Drop the channel onchain and enforce the hard timeout onchain to reclaim the funds in the HTLCs.\n> > > > > > * Wait for the onchain action to be deeply resolved (either timelock or hashlock branch is confirmed deeply) and report the result (success or fail) upstream.\n> > > > > >\n> > > > > > What happens if the \"soft\" timeout is violated?\n> > > > > >\n> > > > > > * Drop the channel onchain.\n> > > > > > * Report the channel closure upstream.\n> > > > > >\n> > > > > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > > > > >\n> > > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel.\n> > > > > >\n> > > > > > The \"soft\" timeout is cancelled in any of these three conditions, the first two of which are the same as above:\n> > > > > >\n> > > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > > > > * A channel closure is reported.\n> > > > > >\n> > > > > > Let us fill this in more detail.\n> > > > > >\n> > > > > > Suppose we have a payment route A->B->C->E.\n> > > > > >\n> > > > > > Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement monotonically at each hop.\n> > > > > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n> > > > > >\n> > > > > > * Suppose E then delays claiming the payment and violates the \"soft\" timeout.\n> > > > > > * C then drops the CE channel onchain.\n> > > > > > * C reports, before its own timeout (slightly larger than the timeout imposed on E), the closing of the channel CE, to B.\n> > > > > > * B validates this report, and if valid, propagates the report to A.\n> > > > > > * A validates this report, and if valid, accepts that the payment will be \"stuck\" for up to the hard timeout it imposed on B.\n> > > > > >\n> > > > > > C has to report back to B in order to prevent B from closing the BC channel, and B has to report back to A in order to prevent A from closing the AB channel.\n> > > > > > The decrementing seconds-unit timeouts are needed for each hop, for the same reason that decrementing block-unit timeouts are needed.\n> > > > > >\n> > > > > > Since E is motivated to attack intermediate nodes because it wants to redirect payment forwards through itself rather than its competitotrs, having one of its channels closed (which prevents it from being used for forwarding) is directly opposed to its end goal of getting more money, thus, we can believe the action of closing a channel involved in a griefing attack is sufficient disincentive.\n> > > > > >\n> > > > > > The major drawback is that enforcement of the soft timeout *is* a channel closure, which is generally a negative for the network.\n> > > > > > This is not a remote attack vector, since a node can only trigger this closure if it is able to stall the fulfillment or failure of an HTLC on a channel, which generally means the node triggering this closure can only do so for its own channels (or it is able to, via a separate mechanism, remotely crash a different node).\n> > > > > >\n> > > > > > Proving Channel Closes\n> > > > > > ----------------------\n> > > > > >\n> > > > > > What C *really* needs to prove is that:\n> > > > > >\n> > > > > > * It is *willing* to close a channel due to a violation of the soft timeout.\n> > > > > > * The channel it is willing to close was, in fact, involved in the same payment attempt.\n> > > > > >\n> > > > > > With the above, B can believe that C was innocent of wrongdoing, because:\n> > > > > >\n> > > > > > * C would only be wiling to close a channel in case of a protocol violation, in this case, a violation of the soft timeout.\n> > > > > > * The channel it closed was closed because of this payment attempt, and not because of another payment attempt, or some other unrelated channel being unilaterally closed.\n> > > > > >\n> > > > > > First, what C needs to prove is *NOT*, in fact, actual channel closure: it needs to prove a *willingness* to close a channel.\n> > > > > > Thus, it does not require the channel to actually be *closed* yet, i.e. it does not have to wait for onchain activity that the channel closure is in a mempool and is confirmed deeply onchain etc etc.\n> > > > > >\n> > > > > > Thus, to prove a *willingness to close* rather than an actual close, C can provide the unilateral close of the channel CE.\n> > > > > > The act of unilaterally closing a channel is the publication of the transaction(s) making up the unilateral close.\n> > > > > > Thus, if C is *willing* to close the channel, it is willing to publish the transaction(s) involved, and thus, providing the unilateral close to B and further upstream, shows a willingness to close the channel.\n> > > > > >\n> > > > > > B then validates the provided proof-of-closure by checking that the unilateral close transaction is either onchain, in the mempool, or that it spends a TXO that is not currently spent by another transaction.\n> > > > > > In the case the unilateral close transaction is not confirmed and in the mempool, B can speed up its propagation on the Bitcoin layer by putting it in its own mempool as well --- after all, C is willing to close the channel to exonerate itself and punish the actual culprit, and B putting the unilateral close in its own mempool can only help C in what it is willing to do.\n> > > > > >\n> > > > > > Secondly, C needs to prove that the channel it is willing to close involves the payment attempt, and is not some other channel closure that it is attempting to use to fulfill its own soft timeout.\n> > > > > > Since the unilateral close transaction *is* the proof-of-closure, B (and A) can inspect the transaction outputs and see (with some additional data from C) that one of the outputs is to an HTLC that matches the payment hash.\n> > > > > >\n> > > > > > Thus, B (and A) can believe that the proof-of-closure proves that whoever is presenting it is free of wrongdoing, as whoever is actually causing the delay has been punished (by someone being willing to close a channel with the culprit), and that the proof-of-closure commits to this particular payment attempt and no other (because it commits to a particular payment hash).\n> > > > > >\n> > > > > > Further, if CE is closed by E dropping it onchain rather than C, C will still be able to fulfill its own soft timeout by taking the closing transaction from E, which should still contain the HTLC.\n> > > > > > Indeed, neither A nor B will particularly care (nor need to know) who dropped the channel onchain, or (for A) that the channel participants are C and E.\n> > > > > >\n> > > > > > Update State Shenanigans\n> > > > > > ------------------------\n> > > > > >\n> > > > > > Bitcoin update mechanisms are complicated things, and it may be possible for an attacking payee E to fool around with the update state machine to make it difficult for C to report a willingness to close CE.\n> > > > > >\n> > > > > > In particular, I quote here the relevant passages from `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update mechanism:\n> > > > > >\n> > > > > > > Thus each update traverses through the following states:\n> > > > > > >\n> > > > > > > 1. pending on the receiver\n> > > > > > > 2. in the receiver's latest commitment transaction\n> > > > > > > 3. ... and the receiver's previous commitment transaction has been revoked,\n> > > > > > >\u00a0 \u00a0 and the update is pending on the sender\n> > > > > > > 4. ... and in the sender's latest commitment transaction\n> > > > > > > 5. ... and the sender's previous commitment transaction has been revoked\n> > > > > >\n> > > > > > The payee E is the \"receiver\" in this context.\n> > > > > >\n> > > > > > In this case, once the update has reached step 2, then E has a commitment transaction that it can put onchain, that contains an HTLC it can claim.\n> > > > > > From this step onward, C cannot send a failure (i.e. it cannot send back an `update_fail_htlc`) back to B, because E could drop its latest commitment onchain and claim the HTLC onchain.\n> > > > > >\n> > > > > > However, until step 4, C does not have a unilateral close containing the HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that refers to the payment.\n> > > > > >\n> > > > > > Thus, between steps 2 to 4, C cannot safely respond to its own soft timeout.\n> > > > > > C cannot respond with a failure, as E could then drop its latest commitment transaction onchain and claim the payment from C, and extract money from C that way.\n> > > > > > C also cannot respond with a proof-of-closure, as it does not have a transaction that it can use to provide this proof.\n> > > > > >\n> > > > > > The best that C can do would be to impose an even shorter timeout between steps 2 and 4 above, and to drop its current commitment transaction (which does not contain the HTLC yet and thus does not constitute a valid proof-of-closure) onchain.\n> > > > > > In between the time it drops the commitment transaction and its own incoming soft timeout, there is a chance, however small, that this transaction will be confirmed, and the channel will (with high probability) settle in a state where the HTLC is not instantiated, thus C can safely fail its incoming HTLC (not show a proof-of-closure, since that is not possible for C to do) without risk of loss, just prior to its own soft timeout.\n> > > > > >\n> > > > > > Of course, C is still at risk here: E could collude with miners via a side-channel fee offer to confirm its commitment transaction with the HTLC present, and ensure that C is liable for the HTLC value.\n> > > > > >\n> > > > > > With Decker-Russell-Osuntokun, we can remove this risk by requiring a ritual as follows:\n> > > > > >\n> > > > > > 1.\u00a0 C requests exclusive access to update their single shared state.\n> > > > > > \u00a0 * This can be done via a variety of sub-protocols, including a fair coin toss in case of near-simultaneous requests for exclusive locks on both sides.\n> > > > > > 2.\u00a0 C provides the details of the new HTLC to E.\n> > > > > > 3.\u00a0 C and E generate the new state transaction and exchange signatures for it.\n> > > > > > 4.\u00a0 C and E generate (without signing) the new update transaction.\n> > > > > > 5.\u00a0 E provides the signature (or share of signature, if MuSig) for the new update transaction to C.\n> > > > > > 6.\u00a0 C provides the signature for the new update transaction to E, which releases the exclusive lock on the shared state atomically with the finalization of the new update transaction.\n> > > > > >\n> > > > > > Prior to step 5, C can simply fail the incoming HTLC from B in case its own soft timeout is near.\n> > > > > > Even if E performs step 5 after C has already failed the incoming HTLC from B, C can simply not perform step 6 and drop the channel onchain with the previous update and state transactions.\n> > > > > >\n> > > > > > With Poon-Dryja, we will have to rearrange the order in which we perform things, effectively adding an extra communications turnaround between the participants.\n> > > > > > Specifically, the order would have to be revised to:\n> > > > > >\n> > > > > > > 1. pending on the sender\n> > > > > > > 2. in the sender's latest commitment transaction\n> > > > > > > 3. ... and the sender's previous commitment transaction has been revoked,\n> > > > > > >\u00a0 \u00a0 and the update is pending on the receiver\n> > > > > > > 4. ... and in the receiver's latest commitment transaction\n> > > > > > > 5. ... and the receiver's previous commitment transaction has been revoked\n> > > > > >\n> > > > > > This allows the sender (C in our context) to provide a proof-of-closure after step 2, and before step 2, C can safely return a failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it can still use the previous commitment that still has no HTLC).\n> > > > > >\n> > > > > > Of course, this change will require redesigning the update state machine, increasing the number of communication turnarounds, and creating a subtle incompatbility when transitioning a payment from a hop that knows only the old update state machine to a hop that knows the new update state machine.\n> > > > > >\n> > > > > > Purely Falsified Proof-Of-Closure\n> > > > > > ---------------------------------\n> > > > > >\n> > > > > > Of course, the attacking node E might want to create a false proof-of-closure.\n> > > > > > E can do this by simulating a Lightning channel: lock an amount of funds in a 2-of-2 (where E controls both keys), then spend it in a set of transactions mimicking the unilateral close.\n> > > > > >\n> > > > > > We observe, however, that the overhead of simulating a Lightning channel is the same as the overhead of actually creating and closing a Lightning channel.\n> > > > > > Since the punishment of proof-of-closure is to force attackers to have their channels closed, we can consider that this simulation of a channel open and close is sufficient as well.\n> > > > > >\n> > > > > > Future-Proofing\n> > > > > > ---------------\n> > > > > >\n> > > > > > This sketch of proof-of-closure can be used for any update mechanism:\n> > > > > >\n> > > > > > * With Poon-Dryja, C can use its own commitment transaction as the proof-of-closure.\n> > > > > > * With Decker-Wattenhofer, C can give all the offchain transactions up to the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> > > > > > * With Deckker-Russell-Osuntokun, C can give the latest update and state trnsaction.\n> > > > > >\n> > > > > > Basically, we expect that for now, and in the future, any update mechanism worth consideration will have a concept of \"unilateral close\" where a channel can be dropped onchain, using data that only one of the channel participants holds.\n> > > > > >\n> > > > > > Such a unilateral close will be a sequence of one or more valid transactions, terminating in a transaction containing an HTLC-like contract in one of its outputs.\n> > > > > >\n> > > > > > Thus, to validate the unilateral close, it is only required to validate all the transactions contained in the proof-of-closure, and see that the last transaction has an HTLC output.\n> > > > > >\n> > > > > > The limitations are thus:\n> > > > > >\n> > > > > > * The acceptable forms of HTLC would need to be agreed-upon by the entire network.\n> > > > > > * Implementations would need to be able to assess, in a Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > > > > >\n> > > > > > Payment Decorrelation and Payment Points\n> > > > > > ----------------------------------------\n> > > > > >\n> > > > > > Of course, having a single payment hash for the entire payment attempt is a privacy loss, which we intend to fix in the near future by using payment points, and adding a blinding scalar at each hop, aka. payment decorrelation.\n> > > > > >\n> > > > > > Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> > > > > > Further, the payment point at each hop will be changed at each hop, in order to prevent decorrelation.\n> > > > > >\n> > > > > > Thus, C needs to provide proofs:\n> > > > > >\n> > > > > > * That an apparent singlesig on the unilateral close output is in fact a PTLC.\n> > > > > > \u00a0 C needs to provide:\n> > > > > > \u00a0 * A target point P.\n> > > > > > \u00a0 * A partial signature that would spend that singlesig for a particular sighash.\n> > > > > > \u00a0 * An adaptor signature which, with knowledge of the completed signature, adaptor signature, and sighash message, would have revealed the scalar behind P.\n> > > > > > * That the PTLC belongs to the same payment attempt as what B offered to C.\n> > > > > > \u00a0 C needs to provide:\n> > > > > > \u00a0 * The C-only blinding factor that is the difference between the payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n> > > > > >\n> > > > > > Then, when B needs to propagate the proof-of-closure back to A, B simply adds its own blinding factor to the reported blinding factor, in order to convince A that this is the same payment attempt.\n> > > > > >\n> > > > > > As we have brought up privacy, we observe that, when this mechanism triggers, there is a mild privacy loss, in that intermediate nodes now know some channel closure that is related to this payment, and can thus determine the exact path that the payment attempt went through, at least until the channel being closed.\n> > > > > > However, proof-of-closure is only propagated in case of violation of the soft timeout, so for normal non-malicious payments, proof-of-closure does not cause any privacy loss.\n> > > > > > _______________________________________________\n> > > > > > Lightning-dev mailing list\n> > > > > > Lightning-dev at lists.linuxfoundation.org\n> > > > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> --\n> Yours sincerely,\n> Subhra Mazumdar."
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-16T06:09:35",
                "message_text_only": "Hello ZmnSCPxj,\n       Thanks for the clarification. So is there any way to check in the\nscript whether block height reported is same as the current block height?\nLike OP_CHECKLOCKTIMEVERIFY against the nLockTime field indirectly verifies\nwhether the desired block height or block time has been reached or not. So\nin a way it is definitely checking against the current block height right?\nWhy can't it be the something like just check the block count reported is\nlatest one or not without putting any restriction on when the transaction\ncan be spend?\n\nOn Thu, Apr 16, 2020 at 10:39 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n> > \" C cannot unlock until 144 blocks, so D can delay its response for up\n> to 143 blocks without any effect on its channels, this is *exactly* the\n> griefing attack.\"- Is there any way to account for the amount of time\n> elapsed in the redeem script so that when D goes on chain just before\n> elapse of the locktime, a decision can be enforced like \"do not pay the\n> full amount to D because of the response delay \"?\n> >\n>\n> No, not without breaking certain principles of Bitcoin.\n>\n> In particular, one possible solution would be to have multiple staggered\n> transactions that are timelocked at particular times, so for example if it\n> responds at +1 it gets more money than if it responds at +2, +3, +4 etc.\n>\n> However, because of the way timelock works, the transaction that is valid\n> at +1 remains valid at any future time.\n> This is the principle \"a transaction that becomes valid is always valid in\n> the future unless double-spent\".\n> Bitcoin Core uses this to reduce validation overhead: it only needs to\n> validate a transaction (i.e. execute the SCRIPT, which is one of the slower\n> operations) on entry to the mempool.\n> Then, once the transaction is in the mempool, it is known to be valid\n> forever unless double-spent, so Bitcoin does not need to re-evaluate its\n> SCRIPT.\n>\n> Any mechanism that requires invalidating previous transactions requires\n> double-spending those transactions and using some other mechanism to ensure\n> that the invalidated transaction is not useable again.\n> This involves significant amounts of transactions that will need to be\n> presented onchain in this case (because D is expected to lose money in this\n> mechanism, it will definitely not participate in consensus that will\n> advance the channel state such that it loses money, so the channel has to\n> be dropped onchain anyway to perform this enforcement).\n>\n> Another principle is \"SCRIPT can only check the transaction it is\n> executing for\".\n> Thus, a `redeemScript` will only be able to execute on the transaction\n> that presents it, and a `scriptPubKey` can only be executed on the\n> transaction spending that output.\n> This means that SCRIPT can only inspect the transaction that it is\n> executing on, and cannot look at anything else in the universe.\n> This principle simplifies initial block download --- in order to validate\n> a SCRIPT, you only need to look at each individual transaction in a block\n> without having to know any data other than that specific transaction.\n>\n> For example, `OP_CHECKLOCKTIMEVERIFY` does ***not*** work by checking the\n> blockheight or claimed sidereal time that the block that contains it has.\n> Instead, it works by checking the `nLockTime` field of the *transaction*\n> it is executing under.\n> By this, the SCRIPT interpreter only needs to input the transaction that\n> is triggering the execution of the SCRIPT, and does not need access to\n> external state, time, etc. etc.\n>\n> These two principles in combination make it difficult-to-impossible to\n> create a mechanism to deduct funds from D because of response delay.\n>\n> Regards,\n> ZmnSCPxj\n>\n> > On Mon, Apr 13, 2020 at 9:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> wrote:\n> >\n> > > Good morning Subhra,\n> > >\n> > > > Ok. But this is a worse situation where C pays money to D but bound\n> to keep its resource locked for a longer duration, unlike D not responding\n> and C being able to unlock after the elapse of lock time.\n> > >\n> > > It is exactly the griefing attack scenario: it is the lock time at D\n> that is the problem.\n> > > As such, it is not \"worse\", it is ***exactly*** the griefing attack\n> scenario.\n> > >\n> > > C cannot unlock until 144 blocks, so D can delay its response for up\n> to 143 blocks without any effect on its channels, this is *exactly* the\n> griefing attack.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > >\n> > > > On Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> wrote:\n> > > >\n> > > > > Good morning Subhra,\n> > > > >\n> > > > > > Hello,\n> > > > > >       So based on what you have stated as possible scenario of\n> griefing attack, does delay in providing the preimage also counted as a\n> form of griefing in htlc? Like given the path A->B->C->D, what if C and D\n> has a lock time of 144 blocks and D responds after 142 block time elapses,\n> claiming the money locked with D?\n> > > > >\n> > > > > That ***is*** the griefing attack.\n> > > > >\n> > > > > Regards,\n> > > > > ZmnSCPxj\n> > > > >\n> > > > > >\n> > > > > > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> > > > > >\n> > > > > > > Introduction\n> > > > > > > ============\n> > > > > > >\n> > > > > > > Given the fact that contracts on offchain protocols need to be\n> enforceable onchain as well, timelocks involved in multi-hop payments are\n> measured in blocks.\n> > > > > > > This is because the blockchain can only\n> (third-party-verifiably) enforce timeouts in units of entire blocks.\n> > > > > > > This leads to very long timeouts for payment delivery, thus\n> multi-hop offchain payment attempts can be, deliberately or accidentally,\n> be in a \"pending\" state up to the very large timeouts involved.\n> > > > > > >\n> > > > > > > Deliberately setting up a multi-hop payment such that it will\n> be in a \"pending\" state for long periods of time is colloquially known as a\n> \"griefing attack\".\n> > > > > > > In this article, we assess various proposed solutions to\n> mitigate the effects of griefing attacks, and propose a particular\n> solution, proof-of-closure, as well, that requires significant changes to\n> the update state machine.\n> > > > > > >\n> > > > > > > Digression: Why Grief?\n> > > > > > > ======================\n> > > > > > >\n> > > > > > > Before embarking on our investigation for solutions to the\n> griefing problem, we should first wonder if griefing is, in fact, a problem.\n> > > > > > >\n> > > > > > > This brings up the question of: why would anybody grief at all?\n> > > > > > >\n> > > > > > > Humans, like cats and other less-sapient pieces of walking\n> meat, often find enjoyment in causing the suffering of others for no\n> immediate direct gain to themselves, as a public demonstration of dominance\n> over those they make suffer (aka \"shits and giggles\", which, if executed\n> correctly, can lead to eventual direct gains to themselves or their progeny\n> or relatives or allies, but such details are often outside the ken of the\n> very beings who execute such survival strategies: brains are pieces of meat\n> that have been hacked to act as action-reaction engines, but are not\n> sophisticated enough to execute as pure rationality engines at all times).\n> > > > > > > Fortunately, in the Bitcoin world, only purely rational beings\n> of pure selfishness can exist in the long run, thus we can neglect such\n> motivations as mere noise.\n> > > > > > >\n> > > > > > > First, let us investigate *how* griefing attacks can be\n> performed.\n> > > > > > >\n> > > > > > > * An intermediate node in a multi-hop attempt can delay\n> forwarding or failing an incoming HTLC.\n> > > > > > > * A final node in a payment attempt can delay claiming an\n> incoming HTLC.\n> > > > > > >\n> > > > > > > Let us consider a purely rational intermediate node of pure\n> selfishness:\n> > > > > > >\n> > > > > > > * If it forwards as soon as possible, it can earn fees, and\n> also speed up the release of the HTLC-locked funds so that they can reuse\n> those funds as liquidity for further payment attempts.\n> > > > > > > * Thus, delaying an HTLC is not selfishly-rational for an\n> intermediate node.\n> > > > > > >\n> > > > > > > Thus, for an intermediate node, it seems there is no\n> selfishly-rational motivation to execute a griefing attack on an arbitrary\n> payment attempt.\n> > > > > > > We can then conclude that an intermediate that delays a\n> payment would do so, not of its own rational self-interest, but as an\n> accident, such as an unforeseen connectivity or power failure.\n> > > > > > >\n> > > > > > > However, things are different when we consider a non-arbitrary\n> payment.\n> > > > > > > Suppose a node were to make a payment attempt to itself, and\n> deliberately delay claiming this self-payment.\n> > > > > > > This lets any single node, *who happens to own large\n> liquidity*, to lock up the liquidity of other nodes.\n> > > > > > >\n> > > > > > > The motivation to lock up the liquidity of other nodes is to\n> *eliminate competition*.\n> > > > > > > Suppose we have a network as below:\n> > > > > > >\n> > > > > > >     A -- B -- C\n> > > > > > >       \\     /\n> > > > > > >        \\   /\n> > > > > > >         \\ /\n> > > > > > >          E\n> > > > > > >\n> > > > > > > When A and C want to transact with one another, they may\n> choose to route via either B or E.\n> > > > > > > B and E are therefore competitors in the business of\n> forwarding payments.\n> > > > > > >\n> > > > > > > But suppose E has much larger channels AE and CE than the\n> channels of AB and CB.\n> > > > > > > For example, suppose E has 100mBTC perfectly-balanced channels\n> while B has only 10mBTC perfectly-balanced channels, as all things should\n> be in simplified models of reality.\n> > > > > > > E can then \"take out the competition\" by making a 5mBTC\n> self-payment along E->A->B->C->E and a 5mBTC self-payment along\n> E->C->B->A->E, then refusing to claim the payment, tying up all the\n> liquidity of the channels of B.\n> > > > > > > By doing so, it can ensure that A and C will always fail to\n> pay via B, even if they wish to transact in amounts less than 5mBTC.\n> > > > > > > E thereby eliminates B as a competitor.\n> > > > > > >\n> > > > > > > This demonstrates that griefing attacks will be motivated,\n> such that such attacks will be performed by payers and payees *against\n> intermediate nodes*.\n> > > > > > > Intermediate nodes have no motivation to attack payers and\n> payees (those are their potential customers in the business of forwarding\n> payments, and attacking potential customers is bad business: such attacking\n> intermediate nodes will be removed economically in the long run).\n> > > > > > > However, payers and payees can become motivated to attack\n> intermediate nodes, if the \"payer\" and \"payee\" are actually competitor\n> intermediate nodes.\n> > > > > > >\n> > > > > > > (We can observe that this is always a possibility even outside\n> of Lightning: a service or product provider has no incentive to attack its\n> customers (\"the customer is always right\"), but have an incentive to\n> *pretend* to be a customer of a competitor and attack them.)\n> > > > > > >\n> > > > > > > We will keep this fact in mind: active griefing attacks are\n> attacks *on* intermediate nodes, not *by* intermediate nodes, because there\n> is no economic incentive for intermediate nodes to attack their customers.\n> > > > > > >\n> > > > > > > Previous Proposed Solutions\n> > > > > > > ===========================\n> > > > > > >\n> > > > > > > Time-Spent Reporting\n> > > > > > > --------------------\n> > > > > > >\n> > > > > > > At each channel along the route, the time spent by a node to\n> handle its forwarding is recorded, and reported upstream in the route.\n> > > > > > >\n> > > > > > > Unfortunately, this solution protects payers from intermediate\n> nodes and payees: it does not protect intermediate nodes from colluding\n> payers and payees.\n> > > > > > > Even if an intermediate node knows that a particular node is\n> consistently slow via a previous time-spent report, it will not be able,\n> with our current onion routing, determine if an onion packet it just\n> received will or will not go through the known-slow node.\n> > > > > > > Thus, an intermediate node would not be able to defend against\n> distant payees that, with a colluding payer, will not claim a particular\n> payment.\n> > > > > > >\n> > > > > > > As we have established, an active griefing atttack will never\n> be deliberately performed by a selfishly-rational intermediate node.\n> > > > > > > Thus, this solution protects against the wrong thing: it\n> protects payers against slow/unreliable intermediate nodes, it does not\n> protect intermediate nodes against malicious payer/payee collusions.\n> > > > > > > It protects only against intermediate nodes that inadvertently\n> go offline during forwarding, but such nodes will inevitably lose out on\n> the forwarding market anyway, and will disappear in the long run.\n> > > > > > >\n> > > > > > > Up-Front Payment\n> > > > > > > ----------------\n> > > > > > >\n> > > > > > > Payers pay for an attempt, not just the successful completion\n> of an attempt.\n> > > > > > >\n> > > > > > > A variation on this is that the payer (or payee) continuously\n> pays as long as the payment is pending.\n> > > > > > > Further variations include paying by other means, such as just\n> locking funds or paying with proof-of-work.\n> > > > > > >\n> > > > > > > While it certainly erects economic barriers against\n> payer/payee collusions attacking intermediate nodes, it *also* erects\n> economic barriers against normal, non-malicious payments.\n> > > > > > >\n> > > > > > > We can consider that economic barriers against non-malicious,\n> low-value, high-frequency payments (\"micropayments\") may be enough that\n> such payments become infeasible if we impose up-front payment for mere\n> attempts.\n> > > > > > > Thus, while this solution is certainly something we can\n> consider, we must be reluctant to use it due to its up-front,\n> strict-evaluation behavior.\n> > > > > > >\n> > > > > > > Proof-Of-Closure\n> > > > > > > ================\n> > > > > > >\n> > > > > > > Observing the above, we want the properties for a \"good\"\n> solution to griefing attacks to be:\n> > > > > > >\n> > > > > > > * It should protect intermediate nodes against payer/payee\n> collusions.\n> > > > > > > * It should only come into play upon detection of an attack.\n> > > > > > >\n> > > > > > > We now present proof-of-closure, which (we hope) has the above\n> properties.\n> > > > > > >\n> > > > > > > We can consider instead a softer timeout, distinct from the\n> HTLC block-based timeout.\n> > > > > > > This softer timeout is measurable in fractions of a second,\n> e.g. units of 0.1 seconds.\n> > > > > > >\n> > > > > > > Each node on the network advertises, in addition to a\n> block-based `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > > > > > Further, each invoice contains, in addition to a block-based\n> `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > > > > > >\n> > > > > > > Thus, there are two timeouts:\n> > > > > > >\n> > > > > > > * The current \"hard\" block-based timeout that is enforceable\n> onchain.\n> > > > > > > * A new \"soft\" sidereal-time-based timeout that is not onchain\n> enforceable.\n> > > > > > >\n> > > > > > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > > > > > Instead, enforcement of the soft timeout *is* the act of\n> putting the channel state onchain.\n> > > > > > >\n> > > > > > > Now, for the current \"hard\" block-based timeout, we already\n> have a reaction.\n> > > > > > > If the HTLC \"hard\" timeout is approaching:\n> > > > > > >\n> > > > > > > * Drop the channel onchain and enforce the hard timeout\n> onchain to reclaim the funds in the HTLCs.\n> > > > > > > * Wait for the onchain action to be deeply resolved (either\n> timelock or hashlock branch is confirmed deeply) and report the result\n> (success or fail) upstream.\n> > > > > > >\n> > > > > > > What happens if the \"soft\" timeout is violated?\n> > > > > > >\n> > > > > > > * Drop the channel onchain.\n> > > > > > > * Report the channel closure upstream.\n> > > > > > >\n> > > > > > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > > > > > >\n> > > > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel.\n> > > > > > >\n> > > > > > > The \"soft\" timeout is cancelled in any of these three\n> conditions, the first two of which are the same as above:\n> > > > > > >\n> > > > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is\n> irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > > > > > * A channel closure is reported.\n> > > > > > >\n> > > > > > > Let us fill this in more detail.\n> > > > > > >\n> > > > > > > Suppose we have a payment route A->B->C->E.\n> > > > > > >\n> > > > > > > Both the \"hard\" block timeouts and the \"soft\" second timeouts\n> decrement monotonically at each hop.\n> > > > > > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts\n> (as normal).\n> > > > > > >\n> > > > > > > * Suppose E then delays claiming the payment and violates the\n> \"soft\" timeout.\n> > > > > > > * C then drops the CE channel onchain.\n> > > > > > > * C reports, before its own timeout (slightly larger than the\n> timeout imposed on E), the closing of the channel CE, to B.\n> > > > > > > * B validates this report, and if valid, propagates the report\n> to A.\n> > > > > > > * A validates this report, and if valid, accepts that the\n> payment will be \"stuck\" for up to the hard timeout it imposed on B.\n> > > > > > >\n> > > > > > > C has to report back to B in order to prevent B from closing\n> the BC channel, and B has to report back to A in order to prevent A from\n> closing the AB channel.\n> > > > > > > The decrementing seconds-unit timeouts are needed for each\n> hop, for the same reason that decrementing block-unit timeouts are needed.\n> > > > > > >\n> > > > > > > Since E is motivated to attack intermediate nodes because it\n> wants to redirect payment forwards through itself rather than its\n> competitotrs, having one of its channels closed (which prevents it from\n> being used for forwarding) is directly opposed to its end goal of getting\n> more money, thus, we can believe the action of closing a channel involved\n> in a griefing attack is sufficient disincentive.\n> > > > > > >\n> > > > > > > The major drawback is that enforcement of the soft timeout\n> *is* a channel closure, which is generally a negative for the network.\n> > > > > > > This is not a remote attack vector, since a node can only\n> trigger this closure if it is able to stall the fulfillment or failure of\n> an HTLC on a channel, which generally means the node triggering this\n> closure can only do so for its own channels (or it is able to, via a\n> separate mechanism, remotely crash a different node).\n> > > > > > >\n> > > > > > > Proving Channel Closes\n> > > > > > > ----------------------\n> > > > > > >\n> > > > > > > What C *really* needs to prove is that:\n> > > > > > >\n> > > > > > > * It is *willing* to close a channel due to a violation of the\n> soft timeout.\n> > > > > > > * The channel it is willing to close was, in fact, involved in\n> the same payment attempt.\n> > > > > > >\n> > > > > > > With the above, B can believe that C was innocent of\n> wrongdoing, because:\n> > > > > > >\n> > > > > > > * C would only be wiling to close a channel in case of a\n> protocol violation, in this case, a violation of the soft timeout.\n> > > > > > > * The channel it closed was closed because of this payment\n> attempt, and not because of another payment attempt, or some other\n> unrelated channel being unilaterally closed.\n> > > > > > >\n> > > > > > > First, what C needs to prove is *NOT*, in fact, actual channel\n> closure: it needs to prove a *willingness* to close a channel.\n> > > > > > > Thus, it does not require the channel to actually be *closed*\n> yet, i.e. it does not have to wait for onchain activity that the channel\n> closure is in a mempool and is confirmed deeply onchain etc etc.\n> > > > > > >\n> > > > > > > Thus, to prove a *willingness to close* rather than an actual\n> close, C can provide the unilateral close of the channel CE.\n> > > > > > > The act of unilaterally closing a channel is the publication\n> of the transaction(s) making up the unilateral close.\n> > > > > > > Thus, if C is *willing* to close the channel, it is willing to\n> publish the transaction(s) involved, and thus, providing the unilateral\n> close to B and further upstream, shows a willingness to close the channel.\n> > > > > > >\n> > > > > > > B then validates the provided proof-of-closure by checking\n> that the unilateral close transaction is either onchain, in the mempool, or\n> that it spends a TXO that is not currently spent by another transaction.\n> > > > > > > In the case the unilateral close transaction is not confirmed\n> and in the mempool, B can speed up its propagation on the Bitcoin layer by\n> putting it in its own mempool as well --- after all, C is willing to close\n> the channel to exonerate itself and punish the actual culprit, and B\n> putting the unilateral close in its own mempool can only help C in what it\n> is willing to do.\n> > > > > > >\n> > > > > > > Secondly, C needs to prove that the channel it is willing to\n> close involves the payment attempt, and is not some other channel closure\n> that it is attempting to use to fulfill its own soft timeout.\n> > > > > > > Since the unilateral close transaction *is* the\n> proof-of-closure, B (and A) can inspect the transaction outputs and see\n> (with some additional data from C) that one of the outputs is to an HTLC\n> that matches the payment hash.\n> > > > > > >\n> > > > > > > Thus, B (and A) can believe that the proof-of-closure proves\n> that whoever is presenting it is free of wrongdoing, as whoever is actually\n> causing the delay has been punished (by someone being willing to close a\n> channel with the culprit), and that the proof-of-closure commits to this\n> particular payment attempt and no other (because it commits to a particular\n> payment hash).\n> > > > > > >\n> > > > > > > Further, if CE is closed by E dropping it onchain rather than\n> C, C will still be able to fulfill its own soft timeout by taking the\n> closing transaction from E, which should still contain the HTLC.\n> > > > > > > Indeed, neither A nor B will particularly care (nor need to\n> know) who dropped the channel onchain, or (for A) that the channel\n> participants are C and E.\n> > > > > > >\n> > > > > > > Update State Shenanigans\n> > > > > > > ------------------------\n> > > > > > >\n> > > > > > > Bitcoin update mechanisms are complicated things, and it may\n> be possible for an attacking payee E to fool around with the update state\n> machine to make it difficult for C to report a willingness to close CE.\n> > > > > > >\n> > > > > > > In particular, I quote here the relevant passages from\n> `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the\n> Poon-Dryja update mechanism:\n> > > > > > >\n> > > > > > > > Thus each update traverses through the following states:\n> > > > > > > >\n> > > > > > > > 1. pending on the receiver\n> > > > > > > > 2. in the receiver's latest commitment transaction\n> > > > > > > > 3. ... and the receiver's previous commitment transaction\n> has been revoked,\n> > > > > > > >    and the update is pending on the sender\n> > > > > > > > 4. ... and in the sender's latest commitment transaction\n> > > > > > > > 5. ... and the sender's previous commitment transaction has\n> been revoked\n> > > > > > >\n> > > > > > > The payee E is the \"receiver\" in this context.\n> > > > > > >\n> > > > > > > In this case, once the update has reached step 2, then E has a\n> commitment transaction that it can put onchain, that contains an HTLC it\n> can claim.\n> > > > > > > From this step onward, C cannot send a failure (i.e. it cannot\n> send back an `update_fail_htlc`) back to B, because E could drop its latest\n> commitment onchain and claim the HTLC onchain.\n> > > > > > >\n> > > > > > > However, until step 4, C does not have a unilateral close\n> containing the HTLC, and thus cannot provide a proof-of-closure that\n> contains an HTLC that refers to the payment.\n> > > > > > >\n> > > > > > > Thus, between steps 2 to 4, C cannot safely respond to its own\n> soft timeout.\n> > > > > > > C cannot respond with a failure, as E could then drop its\n> latest commitment transaction onchain and claim the payment from C, and\n> extract money from C that way.\n> > > > > > > C also cannot respond with a proof-of-closure, as it does not\n> have a transaction that it can use to provide this proof.\n> > > > > > >\n> > > > > > > The best that C can do would be to impose an even shorter\n> timeout between steps 2 and 4 above, and to drop its current commitment\n> transaction (which does not contain the HTLC yet and thus does not\n> constitute a valid proof-of-closure) onchain.\n> > > > > > > In between the time it drops the commitment transaction and\n> its own incoming soft timeout, there is a chance, however small, that this\n> transaction will be confirmed, and the channel will (with high probability)\n> settle in a state where the HTLC is not instantiated, thus C can safely\n> fail its incoming HTLC (not show a proof-of-closure, since that is not\n> possible for C to do) without risk of loss, just prior to its own soft\n> timeout.\n> > > > > > >\n> > > > > > > Of course, C is still at risk here: E could collude with\n> miners via a side-channel fee offer to confirm its commitment transaction\n> with the HTLC present, and ensure that C is liable for the HTLC value.\n> > > > > > >\n> > > > > > > With Decker-Russell-Osuntokun, we can remove this risk by\n> requiring a ritual as follows:\n> > > > > > >\n> > > > > > > 1.  C requests exclusive access to update their single shared\n> state.\n> > > > > > >   * This can be done via a variety of sub-protocols, including\n> a fair coin toss in case of near-simultaneous requests for exclusive locks\n> on both sides.\n> > > > > > > 2.  C provides the details of the new HTLC to E.\n> > > > > > > 3.  C and E generate the new state transaction and exchange\n> signatures for it.\n> > > > > > > 4.  C and E generate (without signing) the new update\n> transaction.\n> > > > > > > 5.  E provides the signature (or share of signature, if MuSig)\n> for the new update transaction to C.\n> > > > > > > 6.  C provides the signature for the new update transaction to\n> E, which releases the exclusive lock on the shared state atomically with\n> the finalization of the new update transaction.\n> > > > > > >\n> > > > > > > Prior to step 5, C can simply fail the incoming HTLC from B in\n> case its own soft timeout is near.\n> > > > > > > Even if E performs step 5 after C has already failed the\n> incoming HTLC from B, C can simply not perform step 6 and drop the channel\n> onchain with the previous update and state transactions.\n> > > > > > >\n> > > > > > > With Poon-Dryja, we will have to rearrange the order in which\n> we perform things, effectively adding an extra communications turnaround\n> between the participants.\n> > > > > > > Specifically, the order would have to be revised to:\n> > > > > > >\n> > > > > > > > 1. pending on the sender\n> > > > > > > > 2. in the sender's latest commitment transaction\n> > > > > > > > 3. ... and the sender's previous commitment transaction has\n> been revoked,\n> > > > > > > >    and the update is pending on the receiver\n> > > > > > > > 4. ... and in the receiver's latest commitment transaction\n> > > > > > > > 5. ... and the receiver's previous commitment transaction\n> has been revoked\n> > > > > > >\n> > > > > > > This allows the sender (C in our context) to provide a\n> proof-of-closure after step 2, and before step 2, C can safely return a\n> failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus\n> ensuring it can still use the previous commitment that still has no HTLC).\n> > > > > > >\n> > > > > > > Of course, this change will require redesigning the update\n> state machine, increasing the number of communication turnarounds, and\n> creating a subtle incompatbility when transitioning a payment from a hop\n> that knows only the old update state machine to a hop that knows the new\n> update state machine.\n> > > > > > >\n> > > > > > > Purely Falsified Proof-Of-Closure\n> > > > > > > ---------------------------------\n> > > > > > >\n> > > > > > > Of course, the attacking node E might want to create a false\n> proof-of-closure.\n> > > > > > > E can do this by simulating a Lightning channel: lock an\n> amount of funds in a 2-of-2 (where E controls both keys), then spend it in\n> a set of transactions mimicking the unilateral close.\n> > > > > > >\n> > > > > > > We observe, however, that the overhead of simulating a\n> Lightning channel is the same as the overhead of actually creating and\n> closing a Lightning channel.\n> > > > > > > Since the punishment of proof-of-closure is to force attackers\n> to have their channels closed, we can consider that this simulation of a\n> channel open and close is sufficient as well.\n> > > > > > >\n> > > > > > > Future-Proofing\n> > > > > > > ---------------\n> > > > > > >\n> > > > > > > This sketch of proof-of-closure can be used for any update\n> mechanism:\n> > > > > > >\n> > > > > > > * With Poon-Dryja, C can use its own commitment transaction as\n> the proof-of-closure.\n> > > > > > > * With Decker-Wattenhofer, C can give all the offchain\n> transactions up to the last stage in the multi-stage\n> decrementing-`nSequence` mechanism.\n> > > > > > > * With Deckker-Russell-Osuntokun, C can give the latest update\n> and state trnsaction.\n> > > > > > >\n> > > > > > > Basically, we expect that for now, and in the future, any\n> update mechanism worth consideration will have a concept of \"unilateral\n> close\" where a channel can be dropped onchain, using data that only one of\n> the channel participants holds.\n> > > > > > >\n> > > > > > > Such a unilateral close will be a sequence of one or more\n> valid transactions, terminating in a transaction containing an HTLC-like\n> contract in one of its outputs.\n> > > > > > >\n> > > > > > > Thus, to validate the unilateral close, it is only required to\n> validate all the transactions contained in the proof-of-closure, and see\n> that the last transaction has an HTLC output.\n> > > > > > >\n> > > > > > > The limitations are thus:\n> > > > > > >\n> > > > > > > * The acceptable forms of HTLC would need to be agreed-upon by\n> the entire network.\n> > > > > > > * Implementations would need to be able to assess, in a\n> Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > > > > > >\n> > > > > > > Payment Decorrelation and Payment Points\n> > > > > > > ----------------------------------------\n> > > > > > >\n> > > > > > > Of course, having a single payment hash for the entire payment\n> attempt is a privacy loss, which we intend to fix in the near future by\n> using payment points, and adding a blinding scalar at each hop, aka.\n> payment decorrelation.\n> > > > > > >\n> > > > > > > Thus, in the future, there will not be any HTLC, but instead a\n> PTLC.\n> > > > > > > Further, the payment point at each hop will be changed at each\n> hop, in order to prevent decorrelation.\n> > > > > > >\n> > > > > > > Thus, C needs to provide proofs:\n> > > > > > >\n> > > > > > > * That an apparent singlesig on the unilateral close output is\n> in fact a PTLC.\n> > > > > > >   C needs to provide:\n> > > > > > >   * A target point P.\n> > > > > > >   * A partial signature that would spend that singlesig for a\n> particular sighash.\n> > > > > > >   * An adaptor signature which, with knowledge of the\n> completed signature, adaptor signature, and sighash message, would have\n> revealed the scalar behind P.\n> > > > > > > * That the PTLC belongs to the same payment attempt as what B\n> offered to C.\n> > > > > > >   C needs to provide:\n> > > > > > >   * The C-only blinding factor that is the difference between\n> the payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral\n> close.\n> > > > > > >\n> > > > > > > Then, when B needs to propagate the proof-of-closure back to\n> A, B simply adds its own blinding factor to the reported blinding factor,\n> in order to convince A that this is the same payment attempt.\n> > > > > > >\n> > > > > > > As we have brought up privacy, we observe that, when this\n> mechanism triggers, there is a mild privacy loss, in that intermediate\n> nodes now know some channel closure that is related to this payment, and\n> can thus determine the exact path that the payment attempt went through, at\n> least until the channel being closed.\n> > > > > > > However, proof-of-closure is only propagated in case of\n> violation of the soft timeout, so for normal non-malicious payments,\n> proof-of-closure does not cause any privacy loss.\n> > > > > > > _______________________________________________\n> > > > > > > Lightning-dev mailing list\n> > > > > > > Lightning-dev at lists.linuxfoundation.org\n> > > > > > >\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > --\n> > Yours sincerely,\n> > Subhra Mazumdar.\n>\n>\n>\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200416/a29d6798/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-16T07:08:59",
                "message_text_only": "Good morning Subhra,\n\n> Hello ZmnSCPxj,\n> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Thanks for the clarification. So is there any way to check in the script whether block height reported is same as the current block height?\n> Like OP_CHECKLOCKTIMEVERIFY against the nLockTime field indirectly verifies whether the desired block height or block time has been reached or not. So in a way it is definitely checking against the current block height right? Why can't it be the something like just check the block count reported is latest one or not without putting any restriction on when the transaction can be spend?\n\nBecause if you can check the block height matches a particular number, then you can change which branch a SCRIPT goes to, and change its result.\nThis means it is possible for your transaction to then become invalid by using such an operation and then using an `OP_IF` to return `OP_FALSE` at a later time.\n\nThis violates the principle \"a transaction that is valid now is always valid later unless double-spent\".\n\nThere is no way to provide this information without violating this principle.\nAlways be afraid of additional power in SCRIPT.\n\nRegards,\nZmnSCPxj\n\n\n>\n> On Thu, Apr 16, 2020 at 10:39 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Subhra,\n> >\n> > > \" C cannot unlock until 144 blocks, so D can delay its response for up to 143 blocks without any effect on its channels, this is *exactly* the griefing attack.\"- Is there any way to account for the amount of time elapsed in the redeem script so that when D goes on chain just before elapse of the locktime, a decision can be enforced like \"do not pay the full amount to D because of the response delay \"?\n> > >\n> >\n> > No, not without breaking certain principles of Bitcoin.\n> >\n> > In particular, one possible solution would be to have multiple staggered transactions that are timelocked at particular times, so for example if it responds at +1 it gets more money than if it responds at +2, +3, +4 etc.\n> >\n> > However, because of the way timelock works, the transaction that is valid at +1 remains valid at any future time.\n> > This is the principle \"a transaction that becomes valid is always valid in the future unless double-spent\".\n> > Bitcoin Core uses this to reduce validation overhead: it only needs to validate a transaction (i.e. execute the SCRIPT, which is one of the slower operations) on entry to the mempool.\n> > Then, once the transaction is in the mempool, it is known to be valid forever unless double-spent, so Bitcoin does not need to re-evaluate its SCRIPT.\n> >\n> > Any mechanism that requires invalidating previous transactions requires double-spending those transactions and using some other mechanism to ensure that the invalidated transaction is not useable again.\n> > This involves significant amounts of transactions that will need to be presented onchain in this case (because D is expected to lose money in this mechanism, it will definitely not participate in consensus that will advance the channel state such that it loses money, so the channel has to be dropped onchain anyway to perform this enforcement).\n> >\n> > Another principle is \"SCRIPT can only check the transaction it is executing for\".\n> > Thus, a `redeemScript` will only be able to execute on the transaction that presents it, and a `scriptPubKey` can only be executed on the transaction spending that output.\n> > This means that SCRIPT can only inspect the transaction that it is executing on, and cannot look at anything else in the universe.\n> > This principle simplifies initial block download --- in order to validate a SCRIPT, you only need to look at each individual transaction in a block without having to know any data other than that specific transaction.\n> >\n> > For example, `OP_CHECKLOCKTIMEVERIFY` does ***not*** work by checking the blockheight or claimed sidereal time that the block that contains it has.\n> > Instead, it works by checking the `nLockTime` field of the *transaction* it is executing under.\n> > By this, the SCRIPT interpreter only needs to input the transaction that is triggering the execution of the SCRIPT, and does not need access to external state, time, etc. etc.\n> >\n> > These two principles in combination make it difficult-to-impossible to create a mechanism to deduct funds from D because of response delay.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > > On Mon, Apr 13, 2020 at 9:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > >\n> > > > Good morning Subhra,\n> > > >\n> > > > > Ok. But this is a worse situation where C pays money to D but bound to keep its resource locked for a longer duration, unlike D not responding and C being able to unlock after the elapse of lock time.\n> > > >\n> > > > It is exactly the griefing attack scenario: it is the lock time at D that is the problem.\n> > > > As such, it is not \"worse\", it is ***exactly*** the griefing attack scenario.\n> > > >\n> > > > C cannot unlock until 144 blocks, so D can delay its response for up to 143 blocks without any effect on its channels, this is *exactly* the griefing attack.\n> > > >\n> > > > Regards,\n> > > > ZmnSCPxj\n> > > >\n> > > > >\n> > > > > On Mon, Apr 13, 2020, 08:21 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > > > >\n> > > > > > Good morning Subhra,\n> > > > > >\n> > > > > > > Hello,\n> > > > > > > \u00a0 \u00a0 \u00a0 So based on what you have stated as possible scenario of griefing attack, does delay in providing the preimage also counted as a form of griefing in htlc? Like given the path A->B->C->D, what if C and D has a lock time of 144 blocks and D responds after 142 block time elapses, claiming the money locked with D?\n> > > > > >\n> > > > > > That ***is*** the griefing attack.\n> > > > > >\n> > > > > > Regards,\n> > > > > > ZmnSCPxj\n> > > > > >\n> > > > > > >\n> > > > > > > On Wed, Apr 1, 2020, 11:49 ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> > > > > > >\n> > > > > > > > Introduction\n> > > > > > > > ============\n> > > > > > > >\n> > > > > > > > Given the fact that contracts on offchain protocols need to be enforceable onchain as well, timelocks involved in multi-hop payments are measured in blocks.\n> > > > > > > > This is because the blockchain can only (third-party-verifiably) enforce timeouts in units of entire blocks.\n> > > > > > > > This leads to very long timeouts for payment delivery, thus multi-hop offchain payment attempts can be, deliberately or accidentally, be in a \"pending\" state up to the very large timeouts involved.\n> > > > > > > >\n> > > > > > > > Deliberately setting up a multi-hop payment such that it will be in a \"pending\" state for long periods of time is colloquially known as a \"griefing attack\".\n> > > > > > > > In this article, we assess various proposed solutions to mitigate the effects of griefing attacks, and propose a particular solution, proof-of-closure, as well, that requires significant changes to the update state machine.\n> > > > > > > >\n> > > > > > > > Digression: Why Grief?\n> > > > > > > > ======================\n> > > > > > > >\n> > > > > > > > Before embarking on our investigation for solutions to the griefing problem, we should first wonder if griefing is, in fact, a problem.\n> > > > > > > >\n> > > > > > > > This brings up the question of: why would anybody grief at all?\n> > > > > > > >\n> > > > > > > > Humans, like cats and other less-sapient pieces of walking meat, often find enjoyment in causing the suffering of others for no immediate direct gain to themselves, as a public demonstration of dominance over those they make suffer (aka \"shits and giggles\", which, if executed correctly, can lead to eventual direct gains to themselves or their progeny or relatives or allies, but such details are often outside the ken of the very beings who execute such survival strategies: brains are pieces of meat that have been hacked to act as action-reaction engines, but are not sophisticated enough to execute as pure rationality engines at all times).\n> > > > > > > > Fortunately, in the Bitcoin world, only purely rational beings of pure selfishness can exist in the long run, thus we can neglect such motivations as mere noise.\n> > > > > > > >\n> > > > > > > > First, let us investigate *how* griefing attacks can be performed.\n> > > > > > > >\n> > > > > > > > * An intermediate node in a multi-hop attempt can delay forwarding or failing an incoming HTLC.\n> > > > > > > > * A final node in a payment attempt can delay claiming an incoming HTLC.\n> > > > > > > >\n> > > > > > > > Let us consider a purely rational intermediate node of pure selfishness:\n> > > > > > > >\n> > > > > > > > * If it forwards as soon as possible, it can earn fees, and also speed up the release of the HTLC-locked funds so that they can reuse those funds as liquidity for further payment attempts.\n> > > > > > > > * Thus, delaying an HTLC is not selfishly-rational for an intermediate node.\n> > > > > > > >\n> > > > > > > > Thus, for an intermediate node, it seems there is no selfishly-rational motivation to execute a griefing attack on an arbitrary payment attempt.\n> > > > > > > > We can then conclude that an intermediate that delays a payment would do so, not of its own rational self-interest, but as an accident, such as an unforeseen connectivity or power failure.\n> > > > > > > >\n> > > > > > > > However, things are different when we consider a non-arbitrary payment.\n> > > > > > > > Suppose a node were to make a payment attempt to itself, and deliberately delay claiming this self-payment.\n> > > > > > > > This lets any single node, *who happens to own large liquidity*, to lock up the liquidity of other nodes.\n> > > > > > > >\n> > > > > > > > The motivation to lock up the liquidity of other nodes is to *eliminate competition*.\n> > > > > > > > Suppose we have a network as below:\n> > > > > > > >\n> > > > > > > > \u00a0 \u00a0 A -- B -- C\n> > > > > > > > \u00a0 \u00a0 \u00a0 \\\u00a0 \u00a0 \u00a0/\n> > > > > > > > \u00a0 \u00a0 \u00a0 \u00a0\\\u00a0 \u00a0/\n> > > > > > > > \u00a0 \u00a0 \u00a0 \u00a0 \\ /\n> > > > > > > > \u00a0 \u00a0 \u00a0 \u00a0 \u00a0E\n> > > > > > > >\n> > > > > > > > When A and C want to transact with one another, they may choose to route via either B or E.\n> > > > > > > > B and E are therefore competitors in the business of forwarding payments.\n> > > > > > > >\n> > > > > > > > But suppose E has much larger channels AE and CE than the channels of AB and CB.\n> > > > > > > > For example, suppose E has 100mBTC perfectly-balanced channels while B has only 10mBTC perfectly-balanced channels, as all things should be in simplified models of reality.\n> > > > > > > > E can then \"take out the competition\" by making a 5mBTC self-payment along E->A->B->C->E and a 5mBTC self-payment along E->C->B->A->E, then refusing to claim the payment, tying up all the liquidity of the channels of B.\n> > > > > > > > By doing so, it can ensure that A and C will always fail to pay via B, even if they wish to transact in amounts less than 5mBTC.\n> > > > > > > > E thereby eliminates B as a competitor.\n> > > > > > > >\n> > > > > > > > This demonstrates that griefing attacks will be motivated, such that such attacks will be performed by payers and payees *against intermediate nodes*.\n> > > > > > > > Intermediate nodes have no motivation to attack payers and payees (those are their potential customers in the business of forwarding payments, and attacking potential customers is bad business: such attacking intermediate nodes will be removed economically in the long run).\n> > > > > > > > However, payers and payees can become motivated to attack intermediate nodes, if the \"payer\" and \"payee\" are actually competitor intermediate nodes.\n> > > > > > > >\n> > > > > > > > (We can observe that this is always a possibility even outside of Lightning: a service or product provider has no incentive to attack its customers (\"the customer is always right\"), but have an incentive to *pretend* to be a customer of a competitor and attack them.)\n> > > > > > > >\n> > > > > > > > We will keep this fact in mind: active griefing attacks are attacks *on* intermediate nodes, not *by* intermediate nodes, because there is no economic incentive for intermediate nodes to attack their customers.\n> > > > > > > >\n> > > > > > > > Previous Proposed Solutions\n> > > > > > > > ===========================\n> > > > > > > >\n> > > > > > > > Time-Spent Reporting\n> > > > > > > > --------------------\n> > > > > > > >\n> > > > > > > > At each channel along the route, the time spent by a node to handle its forwarding is recorded, and reported upstream in the route.\n> > > > > > > >\n> > > > > > > > Unfortunately, this solution protects payers from intermediate nodes and payees: it does not protect intermediate nodes from colluding payers and payees.\n> > > > > > > > Even if an intermediate node knows that a particular node is consistently slow via a previous time-spent report, it will not be able, with our current onion routing, determine if an onion packet it just received will or will not go through the known-slow node.\n> > > > > > > > Thus, an intermediate node would not be able to defend against distant payees that, with a colluding payer, will not claim a particular payment.\n> > > > > > > >\n> > > > > > > > As we have established, an active griefing atttack will never be deliberately performed by a selfishly-rational intermediate node.\n> > > > > > > > Thus, this solution protects against the wrong thing: it protects payers against slow/unreliable intermediate nodes, it does not protect intermediate nodes against malicious payer/payee collusions.\n> > > > > > > > It protects only against intermediate nodes that inadvertently go offline during forwarding, but such nodes will inevitably lose out on the forwarding market anyway, and will disappear in the long run.\n> > > > > > > >\n> > > > > > > > Up-Front Payment\n> > > > > > > > ----------------\n> > > > > > > >\n> > > > > > > > Payers pay for an attempt, not just the successful completion of an attempt.\n> > > > > > > >\n> > > > > > > > A variation on this is that the payer (or payee) continuously pays as long as the payment is pending.\n> > > > > > > > Further variations include paying by other means, such as just locking funds or paying with proof-of-work.\n> > > > > > > >\n> > > > > > > > While it certainly erects economic barriers against payer/payee collusions attacking intermediate nodes, it *also* erects economic barriers against normal, non-malicious payments.\n> > > > > > > >\n> > > > > > > > We can consider that economic barriers against non-malicious, low-value, high-frequency payments (\"micropayments\") may be enough that such payments become infeasible if we impose up-front payment for mere attempts.\n> > > > > > > > Thus, while this solution is certainly something we can consider, we must be reluctant to use it due to its up-front, strict-evaluation behavior.\n> > > > > > > >\n> > > > > > > > Proof-Of-Closure\n> > > > > > > > ================\n> > > > > > > >\n> > > > > > > > Observing the above, we want the properties for a \"good\" solution to griefing attacks to be:\n> > > > > > > >\n> > > > > > > > * It should protect intermediate nodes against payer/payee collusions.\n> > > > > > > > * It should only come into play upon detection of an attack.\n> > > > > > > >\n> > > > > > > > We now present proof-of-closure, which (we hope) has the above properties.\n> > > > > > > >\n> > > > > > > > We can consider instead a softer timeout, distinct from the HTLC block-based timeout.\n> > > > > > > > This softer timeout is measurable in fractions of a second, e.g. units of 0.1 seconds.\n> > > > > > > >\n> > > > > > > > Each node on the network advertises, in addition to a block-based `cltv_delta`, a `timeout_delta` in units of 0.1 seconds.\n> > > > > > > > Further, each invoice contains, in addition to a block-based `final_cltv`, a `final_timeout` in units of 0.1 seconds.\n> > > > > > > >\n> > > > > > > > Thus, there are two timeouts:\n> > > > > > > >\n> > > > > > > > * The current \"hard\" block-based timeout that is enforceable onchain.\n> > > > > > > > * A new \"soft\" sidereal-time-based timeout that is not onchain enforceable.\n> > > > > > > >\n> > > > > > > > The soft timeout, as mentioned, is not enforceable onchain.\n> > > > > > > > Instead, enforcement of the soft timeout *is* the act of putting the channel state onchain.\n> > > > > > > >\n> > > > > > > > Now, for the current \"hard\" block-based timeout, we already have a reaction.\n> > > > > > > > If the HTLC \"hard\" timeout is approaching:\n> > > > > > > >\n> > > > > > > > * Drop the channel onchain and enforce the hard timeout onchain to reclaim the funds in the HTLCs.\n> > > > > > > > * Wait for the onchain action to be deeply resolved (either timelock or hashlock branch is confirmed deeply) and report the result (success or fail) upstream.\n> > > > > > > >\n> > > > > > > > What happens if the \"soft\" timeout is violated?\n> > > > > > > >\n> > > > > > > > * Drop the channel onchain.\n> > > > > > > > * Report the channel closure upstream.\n> > > > > > > >\n> > > > > > > > The \"hard\" timeout is cancelled in any of these two conditions:\n> > > > > > > >\n> > > > > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel.\n> > > > > > > >\n> > > > > > > > The \"soft\" timeout is cancelled in any of these three conditions, the first two of which are the same as above:\n> > > > > > > >\n> > > > > > > > * A success is reported via `update_fulfill_htlc`, OR,\n> > > > > > > > * A failure is reported via `update_fail_htlc` AND the HTLC is irrevocably removed from the latest commitments/state(s) of the channel, OR\n> > > > > > > > * A channel closure is reported.\n> > > > > > > >\n> > > > > > > > Let us fill this in more detail.\n> > > > > > > >\n> > > > > > > > Suppose we have a payment route A->B->C->E.\n> > > > > > > >\n> > > > > > > > Both the \"hard\" block timeouts and the \"soft\" second timeouts decrement monotonically at each hop.\n> > > > > > > > Thus, the payee E has the shortest \"hard\" and \"soft\" timeouts (as normal).\n> > > > > > > >\n> > > > > > > > * Suppose E then delays claiming the payment and violates the \"soft\" timeout.\n> > > > > > > > * C then drops the CE channel onchain.\n> > > > > > > > * C reports, before its own timeout (slightly larger than the timeout imposed on E), the closing of the channel CE, to B.\n> > > > > > > > * B validates this report, and if valid, propagates the report to A.\n> > > > > > > > * A validates this report, and if valid, accepts that the payment will be \"stuck\" for up to the hard timeout it imposed on B.\n> > > > > > > >\n> > > > > > > > C has to report back to B in order to prevent B from closing the BC channel, and B has to report back to A in order to prevent A from closing the AB channel.\n> > > > > > > > The decrementing seconds-unit timeouts are needed for each hop, for the same reason that decrementing block-unit timeouts are needed.\n> > > > > > > >\n> > > > > > > > Since E is motivated to attack intermediate nodes because it wants to redirect payment forwards through itself rather than its competitotrs, having one of its channels closed (which prevents it from being used for forwarding) is directly opposed to its end goal of getting more money, thus, we can believe the action of closing a channel involved in a griefing attack is sufficient disincentive.\n> > > > > > > >\n> > > > > > > > The major drawback is that enforcement of the soft timeout *is* a channel closure, which is generally a negative for the network.\n> > > > > > > > This is not a remote attack vector, since a node can only trigger this closure if it is able to stall the fulfillment or failure of an HTLC on a channel, which generally means the node triggering this closure can only do so for its own channels (or it is able to, via a separate mechanism, remotely crash a different node).\n> > > > > > > >\n> > > > > > > > Proving Channel Closes\n> > > > > > > > ----------------------\n> > > > > > > >\n> > > > > > > > What C *really* needs to prove is that:\n> > > > > > > >\n> > > > > > > > * It is *willing* to close a channel due to a violation of the soft timeout.\n> > > > > > > > * The channel it is willing to close was, in fact, involved in the same payment attempt.\n> > > > > > > >\n> > > > > > > > With the above, B can believe that C was innocent of wrongdoing, because:\n> > > > > > > >\n> > > > > > > > * C would only be wiling to close a channel in case of a protocol violation, in this case, a violation of the soft timeout.\n> > > > > > > > * The channel it closed was closed because of this payment attempt, and not because of another payment attempt, or some other unrelated channel being unilaterally closed.\n> > > > > > > >\n> > > > > > > > First, what C needs to prove is *NOT*, in fact, actual channel closure: it needs to prove a *willingness* to close a channel.\n> > > > > > > > Thus, it does not require the channel to actually be *closed* yet, i.e. it does not have to wait for onchain activity that the channel closure is in a mempool and is confirmed deeply onchain etc etc.\n> > > > > > > >\n> > > > > > > > Thus, to prove a *willingness to close* rather than an actual close, C can provide the unilateral close of the channel CE.\n> > > > > > > > The act of unilaterally closing a channel is the publication of the transaction(s) making up the unilateral close.\n> > > > > > > > Thus, if C is *willing* to close the channel, it is willing to publish the transaction(s) involved, and thus, providing the unilateral close to B and further upstream, shows a willingness to close the channel.\n> > > > > > > >\n> > > > > > > > B then validates the provided proof-of-closure by checking that the unilateral close transaction is either onchain, in the mempool, or that it spends a TXO that is not currently spent by another transaction.\n> > > > > > > > In the case the unilateral close transaction is not confirmed and in the mempool, B can speed up its propagation on the Bitcoin layer by putting it in its own mempool as well --- after all, C is willing to close the channel to exonerate itself and punish the actual culprit, and B putting the unilateral close in its own mempool can only help C in what it is willing to do.\n> > > > > > > >\n> > > > > > > > Secondly, C needs to prove that the channel it is willing to close involves the payment attempt, and is not some other channel closure that it is attempting to use to fulfill its own soft timeout.\n> > > > > > > > Since the unilateral close transaction *is* the proof-of-closure, B (and A) can inspect the transaction outputs and see (with some additional data from C) that one of the outputs is to an HTLC that matches the payment hash.\n> > > > > > > >\n> > > > > > > > Thus, B (and A) can believe that the proof-of-closure proves that whoever is presenting it is free of wrongdoing, as whoever is actually causing the delay has been punished (by someone being willing to close a channel with the culprit), and that the proof-of-closure commits to this particular payment attempt and no other (because it commits to a particular payment hash).\n> > > > > > > >\n> > > > > > > > Further, if CE is closed by E dropping it onchain rather than C, C will still be able to fulfill its own soft timeout by taking the closing transaction from E, which should still contain the HTLC.\n> > > > > > > > Indeed, neither A nor B will particularly care (nor need to know) who dropped the channel onchain, or (for A) that the channel participants are C and E.\n> > > > > > > >\n> > > > > > > > Update State Shenanigans\n> > > > > > > > ------------------------\n> > > > > > > >\n> > > > > > > > Bitcoin update mechanisms are complicated things, and it may be possible for an attacking payee E to fool around with the update state machine to make it difficult for C to report a willingness to close CE.\n> > > > > > > >\n> > > > > > > > In particular, I quote here the relevant passages from `lightning-rfc`, `02-peer-protocol.md`, which is an implementation of the Poon-Dryja update mechanism:\n> > > > > > > >\n> > > > > > > > > Thus each update traverses through the following states:\n> > > > > > > > >\n> > > > > > > > > 1. pending on the receiver\n> > > > > > > > > 2. in the receiver's latest commitment transaction\n> > > > > > > > > 3. ... and the receiver's previous commitment transaction has been revoked,\n> > > > > > > > >\u00a0 \u00a0 and the update is pending on the sender\n> > > > > > > > > 4. ... and in the sender's latest commitment transaction\n> > > > > > > > > 5. ... and the sender's previous commitment transaction has been revoked\n> > > > > > > >\n> > > > > > > > The payee E is the \"receiver\" in this context.\n> > > > > > > >\n> > > > > > > > In this case, once the update has reached step 2, then E has a commitment transaction that it can put onchain, that contains an HTLC it can claim.\n> > > > > > > > From this step onward, C cannot send a failure (i.e. it cannot send back an `update_fail_htlc`) back to B, because E could drop its latest commitment onchain and claim the HTLC onchain.\n> > > > > > > >\n> > > > > > > > However, until step 4, C does not have a unilateral close containing the HTLC, and thus cannot provide a proof-of-closure that contains an HTLC that refers to the payment.\n> > > > > > > >\n> > > > > > > > Thus, between steps 2 to 4, C cannot safely respond to its own soft timeout.\n> > > > > > > > C cannot respond with a failure, as E could then drop its latest commitment transaction onchain and claim the payment from C, and extract money from C that way.\n> > > > > > > > C also cannot respond with a proof-of-closure, as it does not have a transaction that it can use to provide this proof.\n> > > > > > > >\n> > > > > > > > The best that C can do would be to impose an even shorter timeout between steps 2 and 4 above, and to drop its current commitment transaction (which does not contain the HTLC yet and thus does not constitute a valid proof-of-closure) onchain.\n> > > > > > > > In between the time it drops the commitment transaction and its own incoming soft timeout, there is a chance, however small, that this transaction will be confirmed, and the channel will (with high probability) settle in a state where the HTLC is not instantiated, thus C can safely fail its incoming HTLC (not show a proof-of-closure, since that is not possible for C to do) without risk of loss, just prior to its own soft timeout.\n> > > > > > > >\n> > > > > > > > Of course, C is still at risk here: E could collude with miners via a side-channel fee offer to confirm its commitment transaction with the HTLC present, and ensure that C is liable for the HTLC value.\n> > > > > > > >\n> > > > > > > > With Decker-Russell-Osuntokun, we can remove this risk by requiring a ritual as follows:\n> > > > > > > >\n> > > > > > > > 1.\u00a0 C requests exclusive access to update their single shared state.\n> > > > > > > > \u00a0 * This can be done via a variety of sub-protocols, including a fair coin toss in case of near-simultaneous requests for exclusive locks on both sides.\n> > > > > > > > 2.\u00a0 C provides the details of the new HTLC to E.\n> > > > > > > > 3.\u00a0 C and E generate the new state transaction and exchange signatures for it.\n> > > > > > > > 4.\u00a0 C and E generate (without signing) the new update transaction.\n> > > > > > > > 5.\u00a0 E provides the signature (or share of signature, if MuSig) for the new update transaction to C.\n> > > > > > > > 6.\u00a0 C provides the signature for the new update transaction to E, which releases the exclusive lock on the shared state atomically with the finalization of the new update transaction.\n> > > > > > > >\n> > > > > > > > Prior to step 5, C can simply fail the incoming HTLC from B in case its own soft timeout is near.\n> > > > > > > > Even if E performs step 5 after C has already failed the incoming HTLC from B, C can simply not perform step 6 and drop the channel onchain with the previous update and state transactions.\n> > > > > > > >\n> > > > > > > > With Poon-Dryja, we will have to rearrange the order in which we perform things, effectively adding an extra communications turnaround between the participants.\n> > > > > > > > Specifically, the order would have to be revised to:\n> > > > > > > >\n> > > > > > > > > 1. pending on the sender\n> > > > > > > > > 2. in the sender's latest commitment transaction\n> > > > > > > > > 3. ... and the sender's previous commitment transaction has been revoked,\n> > > > > > > > >\u00a0 \u00a0 and the update is pending on the receiver\n> > > > > > > > > 4. ... and in the receiver's latest commitment transaction\n> > > > > > > > > 5. ... and the receiver's previous commitment transaction has been revoked\n> > > > > > > >\n> > > > > > > > This allows the sender (C in our context) to provide a proof-of-closure after step 2, and before step 2, C can safely return a failure with `update_fail_htlc` (and refuse to proceed beyond step 2, thus ensuring it can still use the previous commitment that still has no HTLC).\n> > > > > > > >\n> > > > > > > > Of course, this change will require redesigning the update state machine, increasing the number of communication turnarounds, and creating a subtle incompatbility when transitioning a payment from a hop that knows only the old update state machine to a hop that knows the new update state machine.\n> > > > > > > >\n> > > > > > > > Purely Falsified Proof-Of-Closure\n> > > > > > > > ---------------------------------\n> > > > > > > >\n> > > > > > > > Of course, the attacking node E might want to create a false proof-of-closure.\n> > > > > > > > E can do this by simulating a Lightning channel: lock an amount of funds in a 2-of-2 (where E controls both keys), then spend it in a set of transactions mimicking the unilateral close.\n> > > > > > > >\n> > > > > > > > We observe, however, that the overhead of simulating a Lightning channel is the same as the overhead of actually creating and closing a Lightning channel.\n> > > > > > > > Since the punishment of proof-of-closure is to force attackers to have their channels closed, we can consider that this simulation of a channel open and close is sufficient as well.\n> > > > > > > >\n> > > > > > > > Future-Proofing\n> > > > > > > > ---------------\n> > > > > > > >\n> > > > > > > > This sketch of proof-of-closure can be used for any update mechanism:\n> > > > > > > >\n> > > > > > > > * With Poon-Dryja, C can use its own commitment transaction as the proof-of-closure.\n> > > > > > > > * With Decker-Wattenhofer, C can give all the offchain transactions up to the last stage in the multi-stage decrementing-`nSequence` mechanism.\n> > > > > > > > * With Deckker-Russell-Osuntokun, C can give the latest update and state trnsaction.\n> > > > > > > >\n> > > > > > > > Basically, we expect that for now, and in the future, any update mechanism worth consideration will have a concept of \"unilateral close\" where a channel can be dropped onchain, using data that only one of the channel participants holds.\n> > > > > > > >\n> > > > > > > > Such a unilateral close will be a sequence of one or more valid transactions, terminating in a transaction containing an HTLC-like contract in one of its outputs.\n> > > > > > > >\n> > > > > > > > Thus, to validate the unilateral close, it is only required to validate all the transactions contained in the proof-of-closure, and see that the last transaction has an HTLC output.\n> > > > > > > >\n> > > > > > > > The limitations are thus:\n> > > > > > > >\n> > > > > > > > * The acceptable forms of HTLC would need to be agreed-upon by the entire network.\n> > > > > > > > * Implementations would need to be able to assess, in a Bitcoin-consensus-compatible way, whether a transaction is valid or not.\n> > > > > > > >\n> > > > > > > > Payment Decorrelation and Payment Points\n> > > > > > > > ----------------------------------------\n> > > > > > > >\n> > > > > > > > Of course, having a single payment hash for the entire payment attempt is a privacy loss, which we intend to fix in the near future by using payment points, and adding a blinding scalar at each hop, aka. payment decorrelation.\n> > > > > > > >\n> > > > > > > > Thus, in the future, there will not be any HTLC, but instead a PTLC.\n> > > > > > > > Further, the payment point at each hop will be changed at each hop, in order to prevent decorrelation.\n> > > > > > > >\n> > > > > > > > Thus, C needs to provide proofs:\n> > > > > > > >\n> > > > > > > > * That an apparent singlesig on the unilateral close output is in fact a PTLC.\n> > > > > > > > \u00a0 C needs to provide:\n> > > > > > > > \u00a0 * A target point P.\n> > > > > > > > \u00a0 * A partial signature that would spend that singlesig for a particular sighash.\n> > > > > > > > \u00a0 * An adaptor signature which, with knowledge of the completed signature, adaptor signature, and sighash message, would have revealed the scalar behind P.\n> > > > > > > > * That the PTLC belongs to the same payment attempt as what B offered to C.\n> > > > > > > > \u00a0 C needs to provide:\n> > > > > > > > \u00a0 * The C-only blinding factor that is the difference between the payment point of the B-to-C PTLC and the C-to-E PTLC on the unilateral close.\n> > > > > > > >\n> > > > > > > > Then, when B needs to propagate the proof-of-closure back to A, B simply adds its own blinding factor to the reported blinding factor, in order to convince A that this is the same payment attempt.\n> > > > > > > >\n> > > > > > > > As we have brought up privacy, we observe that, when this mechanism triggers, there is a mild privacy loss, in that intermediate nodes now know some channel closure that is related to this payment, and can thus determine the exact path that the payment attempt went through, at least until the channel being closed.\n> > > > > > > > However, proof-of-closure is only propagated in case of violation of the soft timeout, so for normal non-malicious payments, proof-of-closure does not cause any privacy loss.\n> > > > > > > > _______________________________________________\n> > > > > > > > Lightning-dev mailing list\n> > > > > > > > Lightning-dev at lists.linuxfoundation.org\n> > > > > > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > >\n> > > --\n> > > Yours sincerely,\n> > > Subhra Mazumdar.\n>\n> --\n> Yours sincerely,\n> Subhra Mazumdar."
            }
        ],
        "thread_summary": {
            "title": "Proof-of-closure as griefing attack mitigation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "David A. Harding",
                "Rusty Russell",
                "Subhra Mazumdar",
                "ZmnSCPxj"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 349386
        }
    },
    {
        "title": "[Lightning-dev] A better encoding for lightning invoices",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-04-01T07:59:00",
                "message_text_only": "Good morning list,\n\nIn Bolt 11 we decided to use bech32 to encode lightning invoices.\nWhile bech32 has some nice properties, it isn't well suited for invoices.\nThe main drawback of Bolt 11 invoices is their size: when you start adding\nrouting hints or rendezvous onions, invoices become huge and hard to share.\n\nEmpirical evidence shows that most lightning transactions are done over\nTwitter\n(73,41% of all lightning payments in 2019 were made via tweets).\nSince Twitter only allows up to 280 characters per tweet, this has severely\nimpacted\nthe development of new features for lightning. Anything that made an\ninvoice bigger\nended up being unused as users were left without any option to share those\ninvoices.\n\nAfter several months of research and experimentation at Acinq Research, we\nhave come\nup with a highly efficient invoice encoding, optimized primarily for\nTwitter. This has\ncaused further delays in the development of our iOS wallet, but we felt\nthis was a\nmuch higher priority.\n\nOur encoding uses an AI-optimized mapping from 11-bit words to Twitter\nemojis.\nEarly results show that emoji invoices are more than 2 times smaller than\nlegacy invoices.\n\nReckless users are already using this in production:\n\nhttps://twitter.com/realtbast/status/1245258812279398400?s=20\nhttps://twitter.com/acinq_co/status/1245258815597096960\n\nThere is a spec PR available at [1], along with reference eclair code [2].\nWe plan to release this feature in the next update of our Phoenix wallet\n[3].\n\nWe'd like feedback from this list on how to improve this further. We\nbelieve the\nsame encoding could be used to compress the bitcoin blockchain. With more\ntraining\ndata, we believe our AI-optimized mapping could allow bitcoin blocks to fit\nin a\nsingle tweet; we would then be able to use Twitter feeds to store the whole\nblockchain.\n\nCheers,\nBastien\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/762\n[2] https://github.com/ACINQ/eclair/tree/emoji-encoding\n[3] https://phoenix.acinq.co/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200401/57b78392/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-01T17:17:10",
                "message_text_only": "Good morning Bastien,\n\n> We believe the\n> same encoding could be used to compress the bitcoin blockchain. With more training\n> data, we believe our AI-optimized mapping could allow bitcoin blocks to fit in a\n> single tweet; we would then be able to use Twitter feeds to store the whole blockchain.\n\nAn utter derailment of this thread, but this claim seems to me a massive departure from my understanding of information theory.\nI am put to mind of the fable of the 1-bit image compressor, which can compress any image to just 1 bit; its decompression algorithm checked if the input bit is a 1 and if so, emitted the Lenna test image, and if the input bit was 0, would fail with a decompression error.\nSince the only requirement for publication in a journal is to be able to correctly compress and decompress the Lenna test image,  the image compressor achieves 1-bit compression of any image, as shown by the successful compression and decompression of the Lenna test image.\n\nI wonder if the blockchain data is stored in the tweet, or in the AI that decides how to store it in the tweet.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "A better encoding for lightning invoices",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3282
        }
    },
    {
        "title": "[Lightning-dev] Blind paths revisited",
        "thread_messages": [
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-01T15:42:18",
                "message_text_only": "Commenting on it : \"As for ZmnSCPxj's suggestion, I think there is the same\nkind of issue.\nThe secrets we establish with anonymous multi-hops locks are between the\n*sender*\nand each of the hops. In the route blinding case, what we're adding are\nsecrets\nbetween the *recipient* and the hops, and we don't want the sender to be\nable to\ninfluence those.\"\nIs it a good idea to rely entirely on the sender for sampling the secrets\nas well as generating the PTLC? As happens in anonymous multi-hops locks,\nfor example. Or as it has been discussed later in the thread, both receiver\nand sender must be involved in creation of PTLC? What happens if\nsender/receiver is/(or both are) corrupted? Can it leak secrets to other\nparties?\n\nOn Wed, Mar 11, 2020 at 9:57 PM Bastien TEINTURIER via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> Thanks Rusty for following up on this, I'm glad it may be useful for\n> offers!\n> I certainly want this as well for wallet users' privacy.\n>\n> I have gathered my proposal in a better format than my previous gist here:\n>\n> https://github.com/lightningnetwork/lightning-rfc/blob/route-blinding/proposals/route-blinding.md\n>\n> You will note that I've been able to simplify the scheme a bit compared to\n> my\n> gist. It's now very clear that this is exactly the same kind of secrets\n> derivation than what Sphinx does. I still have things I want to add to the\n> proposal, but at least the crypto part should be ready to review (and I\n> think\n> it does need more eyes on it).\n>\n> Feel free to add comments directly on the branch commits, it may be easier\n> to\n> review that way. Let me know if you think I should turn it into a draft PR\n> to\n> facilitate discussions. It kept it vague on some specific parts on purpose\n> (such as invoice fields, encrypted blob format); we will learn from early\n> prototype implementations and enrich the proposal as we go.\n>\n> A few comments on your previous mails. I have removed the (ab)use of\n> `payment_secret`, but I think your comment on using the `blinding` to\n> replace\n> it would not work because that blinding is known by the next-to-last node\n> (which computes it and forwards it to the final node).\n> The goal of `payment_secret` is explicitly to avoid having the\n> next-to-last node\n> discover it to prevent him from probing. But I think that you didn't plan\n> on\n> doing the blinding the same way I'm doing it, which may explain the\n> difference.\n>\n> As for ZmnSCPxj's suggestion, I think there is the same kind of issue.\n> The secrets we establish with anonymous multi-hops locks are between the\n> *sender*\n> and each of the hops. In the route blinding case, what we're adding are\n> secrets\n> between the *recipient* and the hops, and we don't want the sender to be\n> able to\n> influence those. It's a kind of reverse Sphinx. So I'm not sure yet the\n> recipient\n> could safely contribute to those secrets, but maybe we'll find a nice\n> trick in\n> the future!\n>\n> Cheers,\n> Bastien\n>\n> Le mer. 11 mars 2020 \u00e0 00:22, Rusty Russell <rusty at rustcorp.com.au> a\n> \u00e9crit :\n>\n>> ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n>> > Good morning Rusty, et al.,\n>> >\n>> >\n>> >> Note that this means no payment secret is necessary, since the incoming\n>> >> `blinding` serves the same purpose. If we wanted to, we could (ab)use\n>> >> payment_secret as the first 32-bytes to put in Carol's enc1 (i.e. it's\n>> >> the ECDH for Carol to decrypt enc1).\n>> >\n>> > I confess to not reading everything in detail, but it seems to me that,\n>> with payment point + scalar and path decorrelation, we need to establish a\n>> secret with each hop anyway (the blinding scalar for path decorrelation),\n>> so if you need a secret per hop, possibly this could be reused as well?\n>>\n>> Indeed, this could be used the same way, though for that secret it can\n>> simply be placed inside the onion rather than passed alongside.\n>>\n>> Cheers,\n>> Rusty.\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200401/1e7b9725/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-01T17:09:41",
                "message_text_only": "Good morning Subhra,\n\n> Commenting on it : \"As for ZmnSCPxj's suggestion, I think there is the same kind of issue.\n> The secrets we establish with anonymous multi-hops locks are between the *sender*\n> and each of the hops. In the route blinding case, what we're adding are secrets\n> between the *recipient* and the hops, and we don't want the sender to be able to\n> influence those.\"\n> Is it a good idea to rely entirely on the sender for sampling the secrets as well as generating the PTLC? As happens in anonymous multi-hops locks, for example. Or as it has been discussed later in the thread, both receiver and sender must be involved in creation of PTLC? What happens if sender/receiver is/(or both are) corrupted? Can it leak secrets to other parties?\n\nIf both are corrupted, this brings up the question: who are you hiding any information from?\nThe corruptor has already corrupted both: there is no security or privacy possible, the payment is already totally compromised.\n\nThe operation of forwarding nodes is simple enough that in general they cannot be attacked: sure, the sender and receiver together knows who they are, but forwarding nodes are the ones who advertise themselves in order to be forwarded through, so they already are known anyway.\n\nWhen considering privacy, we should always consider that it is the payment as a whole which we want to have privacy: we want that third parties will not be able to nail down which particular sender sent to which particular receiver.\nThus if the sender already leaks who it is paying to, that is pretty much the entire loss of privacy.\n\nNow, currently on Lightning, in general the receiver does not know the sender node.\n(Applications on top of Lightning might have the receiver require the sender to provide private data, such as a drop point to send a physical product to, but *looking only on Lightning* the sender does not send any of its information to the receiver).\n\nHowever, currently, the exact receiver node has to be known by the sender, in order for the sender to make a route to it.\nThis is a concern since it may be possible for layer-crossing shenanigans to be performed, for example the sender might attempt to eclipse the receiver on the Bitcoin blockchain layer and make it lose funds by not realizing that a PTLC/HTLC has been timed out (because the eclipse attack prevents new blocks from propagating to the receiver, who blithely continues to think that the timeout has not been reached when in fact it has).\n\nThe proposal to have a receiver provide a partial, blinded path gives the receiver better privacy protection against the sender: the sender knows it is one of a possible number of nodes within some number of hops from a particular node, but does not know if it is that exact node, one of its neighbors, or one of its neighbor neighbors (etc.) is the actual receiver.\nThis should make it harder for the sender to attack the receiver by attempting to locate its node and eclipse it at the Bitcoin layer, or other blockchain-layer shenanigans.\n\nNow, the argument I make is that while the blinding factors in a decorrelated PTLC-based payment may be generated by the sender in order for the sender to have path privacy, it is safe for the receiver to provide blinding factors to a partial path as well.\nWe should remember that the blinding factors are just scalars added to the final point/scalar at the ultimate recipient, and the final point/scalar pair is completely controlled by the recipient anyway, so it should not be an issue here: the point that the sender will target at the first node in the receiver-provided partial route is no different from the final point that the sender would have targeted if it knew exactly who the receiver is.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-01T17:44:41",
                "message_text_only": "Hi ZmnSCPxj,\n     Thanks for the explanation. Pardon my knowledge in this domain but\nwhat I meant is that sender has malicious intent and wants honest parties\nto suffer. So by leaking secrets, I meant not revealing its or receiver's\nidentity to the forwarding nodes, but somehow manipulating subset of the\nnodes so that an attack can be launched in the network. For example,\nconsider path S->A->B->C->D->E->F->R. If we consider the protocol anonymous\nmultihop lock, S samples secret x_a,x_b,x_c,x_d,x_e,x_f for the nodes\nA,B,C,D,E and F respectively. R gets the key k=x_a+x_b+x_c+x_d+x_e+x_f. If\nS colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B), lock\nfunds C,D,E but then not allowing it to relay funds (possibly do a griefing\nattack?). What I meant is that if one totally relies on S for the setup\nphase, won't it lead to other vulnerabilities? The situation might sound\nunrealistic but I still have doubt whether we guarantee fairness if put our\ntrust entirely on one single entity.\n\nOn Wed, Apr 1, 2020 at 10:39 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n> > Commenting on it : \"As for ZmnSCPxj's suggestion, I think there is the\n> same kind of issue.\n> > The secrets we establish with anonymous multi-hops locks are between the\n> *sender*\n> > and each of the hops. In the route blinding case, what we're adding are\n> secrets\n> > between the *recipient* and the hops, and we don't want the sender to be\n> able to\n> > influence those.\"\n> > Is it a good idea to rely entirely on the sender for sampling the\n> secrets as well as generating the PTLC? As happens in anonymous multi-hops\n> locks, for example. Or as it has been discussed later in the thread, both\n> receiver and sender must be involved in creation of PTLC? What happens if\n> sender/receiver is/(or both are) corrupted? Can it leak secrets to other\n> parties?\n>\n> If both are corrupted, this brings up the question: who are you hiding any\n> information from?\n> The corruptor has already corrupted both: there is no security or privacy\n> possible, the payment is already totally compromised.\n>\n> The operation of forwarding nodes is simple enough that in general they\n> cannot be attacked: sure, the sender and receiver together knows who they\n> are, but forwarding nodes are the ones who advertise themselves in order to\n> be forwarded through, so they already are known anyway.\n>\n> When considering privacy, we should always consider that it is the payment\n> as a whole which we want to have privacy: we want that third parties will\n> not be able to nail down which particular sender sent to which particular\n> receiver.\n> Thus if the sender already leaks who it is paying to, that is pretty much\n> the entire loss of privacy.\n>\n> Now, currently on Lightning, in general the receiver does not know the\n> sender node.\n> (Applications on top of Lightning might have the receiver require the\n> sender to provide private data, such as a drop point to send a physical\n> product to, but *looking only on Lightning* the sender does not send any of\n> its information to the receiver).\n>\n> However, currently, the exact receiver node has to be known by the sender,\n> in order for the sender to make a route to it.\n> This is a concern since it may be possible for layer-crossing shenanigans\n> to be performed, for example the sender might attempt to eclipse the\n> receiver on the Bitcoin blockchain layer and make it lose funds by not\n> realizing that a PTLC/HTLC has been timed out (because the eclipse attack\n> prevents new blocks from propagating to the receiver, who blithely\n> continues to think that the timeout has not been reached when in fact it\n> has).\n>\n> The proposal to have a receiver provide a partial, blinded path gives the\n> receiver better privacy protection against the sender: the sender knows it\n> is one of a possible number of nodes within some number of hops from a\n> particular node, but does not know if it is that exact node, one of its\n> neighbors, or one of its neighbor neighbors (etc.) is the actual receiver.\n> This should make it harder for the sender to attack the receiver by\n> attempting to locate its node and eclipse it at the Bitcoin layer, or other\n> blockchain-layer shenanigans.\n>\n> Now, the argument I make is that while the blinding factors in a\n> decorrelated PTLC-based payment may be generated by the sender in order for\n> the sender to have path privacy, it is safe for the receiver to provide\n> blinding factors to a partial path as well.\n> We should remember that the blinding factors are just scalars added to the\n> final point/scalar at the ultimate recipient, and the final point/scalar\n> pair is completely controlled by the recipient anyway, so it should not be\n> an issue here: the point that the sender will target at the first node in\n> the receiver-provided partial route is no different from the final point\n> that the sender would have targeted if it knew exactly who the receiver is.\n>\n> Regards,\n> ZmnSCPxj\n>\n\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200401/95a1e434/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-02T00:34:22",
                "message_text_only": "Good morning Subhra,\n\n> Hi ZmnSCPxj,\n> \u00a0\u00a0\u00a0\u00a0 Thanks for the explanation. Pardon my knowledge in this domain but what I meant is that sender has malicious intent and wants honest parties to suffer. So by leaking secrets, I meant not revealing its or receiver's identity to the forwarding nodes, but somehow manipulating subset of the nodes so that an attack can be launched in the network. For example, consider path S->A->B->C->D->E->F->R. If we consider the protocol anonymous multihop lock, S samples secret x_a,x_b,x_c,x_d,x_e,x_f for the nodes A,B,C,D,E and F respectively. R gets the key k=x_a+x_b+x_c+x_d+x_e+x_f. If S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B), lock funds C,D,E but then not allowing it to relay funds (possibly do a griefing attack?). What I meant is that if one totally relies on S for the setup phase, won't it lead to other vulnerabilities? The situation might sound unrealistic but I still have doubt whether we guarantee fairness if put our trust entirely on one single entity.\n\nNote that in the context of PTLCs, R does not get a key (as in private key) of x_a+x_b+x_c+x_d+x_e+x_f.\nInstead, R still continues to use its normal private key for claiming HTLC/PTLC.\nWe simply have R generate an adaptor signature first and hand that over to F, such that completing the signature and publishing it onchain will reveal a secret x_r (which is NOT the node privkey of R).\n\nWhat happens really here is that each hop sets up a PTLC.\nThe sender is responsible for ensuring that the F->R PTLC is equal to x_r * G, that E->F is equal to (x_f + x_r) * G, that D->E is equal to (x_e + x_f + x_r) * G, and so on.\nHowever,  the sender knows only (x_r * G) without knowing x_r, thus it never is able to completely control the secret at every point -- the receiver knows the other secret as well.\n\nThat is the entire crux of the argument --- *both* sender and receiver control the secrets anyway, so it is not controlled by a single entity, at least for non-self-payments.\n\n> If S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B), lock funds C,D,E but then not allowing it to relay funds (possibly do a griefing attack?).\n\nGriefing attacks are only possible by not claiming or forwarding the attack.\nIf S and B \"collude\" to perform a grief, then either B never forwards to C, in which case there is no possible way to attack, or C receives it and claims it but B does not claim it, in which case B paid out money and is now idiotically refusing to claim money.\n\nGrief attacks are attacks by payers and payees on intermediate nodes (S and R attacking A,B,C,D,E,F), and in that case the entire payment secret would be known by both S and R anyway.\n\nSo S and B cannot cooperate to perform a griefing attack on the path.\n\nRegards,\nZmnSCPxj\n\n>\n> On Wed, Apr 1, 2020 at 10:39 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Subhra,\n> >\n> > > Commenting on it : \"As for ZmnSCPxj's suggestion, I think there is the same kind of issue.\n> > > The secrets we establish with anonymous multi-hops locks are between the *sender*\n> > > and each of the hops. In the route blinding case, what we're adding are secrets\n> > > between the *recipient* and the hops, and we don't want the sender to be able to\n> > > influence those.\"\n> > > Is it a good idea to rely entirely on the sender for sampling the secrets as well as generating the PTLC? As happens in anonymous multi-hops locks, for example. Or as it has been discussed later in the thread, both receiver and sender must be involved in creation of PTLC? What happens if sender/receiver is/(or both are) corrupted? Can it leak secrets to other parties?\n> >\n> > If both are corrupted, this brings up the question: who are you hiding any information from?\n> > The corruptor has already corrupted both: there is no security or privacy possible, the payment is already totally compromised.\n> >\n> > The operation of forwarding nodes is simple enough that in general they cannot be attacked: sure, the sender and receiver together knows who they are, but forwarding nodes are the ones who advertise themselves in order to be forwarded through, so they already are known anyway.\n> >\n> > When considering privacy, we should always consider that it is the payment as a whole which we want to have privacy: we want that third parties will not be able to nail down which particular sender sent to which particular receiver.\n> > Thus if the sender already leaks who it is paying to, that is pretty much the entire loss of privacy.\n> >\n> > Now, currently on Lightning, in general the receiver does not know the sender node.\n> > (Applications on top of Lightning might have the receiver require the sender to provide private data, such as a drop point to send a physical product to, but *looking only on Lightning* the sender does not send any of its information to the receiver).\n> >\n> > However, currently, the exact receiver node has to be known by the sender, in order for the sender to make a route to it.\n> > This is a concern since it may be possible for layer-crossing shenanigans to be performed, for example the sender might attempt to eclipse the receiver on the Bitcoin blockchain layer and make it lose funds by not realizing that a PTLC/HTLC has been timed out (because the eclipse attack prevents new blocks from propagating to the receiver, who blithely continues to think that the timeout has not been reached when in fact it has).\n> >\n> > The proposal to have a receiver provide a partial, blinded path gives the receiver better privacy protection against the sender: the sender knows it is one of a possible number of nodes within some number of hops from a particular node, but does not know if it is that exact node, one of its neighbors, or one of its neighbor neighbors (etc.) is the actual receiver.\n> > This should make it harder for the sender to attack the receiver by attempting to locate its node and eclipse it at the Bitcoin layer, or other blockchain-layer shenanigans.\n> >\n> > Now, the argument I make is that while the blinding factors in a decorrelated PTLC-based payment may be generated by the sender in order for the sender to have path privacy, it is safe for the receiver to provide blinding factors to a partial path as well.\n> > We should remember that the blinding factors are just scalars added to the final point/scalar at the ultimate recipient, and the final point/scalar pair is completely controlled by the recipient anyway, so it should not be an issue here: the point that the sender will target at the first node in the receiver-provided partial route is no different from the final point that the sender would have targeted if it knew exactly who the receiver is.\n> >\n> > Regards,\n> > ZmnSCPxj\n>\n> --\n> Yours sincerely,\n> Subhra Mazumdar."
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-02T06:16:08",
                "message_text_only": "Thank you for the clarification. Sorry for misinterpreting the paper of\nanonymous multihop lock. A bit of rephrasing of what I exactly meant and\napologies for describing vaguely. Following your discussion on griefing\nattack, it is clear the payer and payee wants to intentionally deprive\nintermediate nodes, by colluding. However, by griefing (a misnomer for this\nsituation) I didn't mean exactly withholding the solution but something\nlike this:\nGiven S->A->B->C->D->E->F->R, S, B and F are controlled by the same\nadversary and considering all the parties have completed the lock phase.\nNow R triggers release phase and F gets x_r from R. However, F adds x_f to\nx_r forwards it directly to B, doesn't complete signature with E and\ncancels the HTLC just before the elapse of expiration time, E terminates\nits HTLC with D and so on. B has x_c+x_d+x_e+x_f+x_r (shared by F and\nshared by S). It continues normally completing payment with A and then S. I\nam not sure whether again this attack makes sense.\n\n\nOn Thu, Apr 2, 2020 at 6:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n> > Hi ZmnSCPxj,\n> >      Thanks for the explanation. Pardon my knowledge in this domain but\n> what I meant is that sender has malicious intent and wants honest parties\n> to suffer. So by leaking secrets, I meant not revealing its or receiver's\n> identity to the forwarding nodes, but somehow manipulating subset of the\n> nodes so that an attack can be launched in the network. For example,\n> consider path S->A->B->C->D->E->F->R. If we consider the protocol anonymous\n> multihop lock, S samples secret x_a,x_b,x_c,x_d,x_e,x_f for the nodes\n> A,B,C,D,E and F respectively. R gets the key k=x_a+x_b+x_c+x_d+x_e+x_f. If\n> S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B), lock\n> funds C,D,E but then not allowing it to relay funds (possibly do a griefing\n> attack?). What I meant is that if one totally relies on S for the setup\n> phase, won't it lead to other vulnerabilities? The situation might sound\n> unrealistic but I still have doubt whether we guarantee fairness if put our\n> trust entirely on one single entity.\n>\n> Note that in the context of PTLCs, R does not get a key (as in private\n> key) of x_a+x_b+x_c+x_d+x_e+x_f.\n> Instead, R still continues to use its normal private key for claiming\n> HTLC/PTLC.\n> We simply have R generate an adaptor signature first and hand that over to\n> F, such that completing the signature and publishing it onchain will reveal\n> a secret x_r (which is NOT the node privkey of R).\n>\n> What happens really here is that each hop sets up a PTLC.\n> The sender is responsible for ensuring that the F->R PTLC is equal to x_r\n> * G, that E->F is equal to (x_f + x_r) * G, that D->E is equal to (x_e +\n> x_f + x_r) * G, and so on.\n> However,  the sender knows only (x_r * G) without knowing x_r, thus it\n> never is able to completely control the secret at every point -- the\n> receiver knows the other secret as well.\n>\n> That is the entire crux of the argument --- *both* sender and receiver\n> control the secrets anyway, so it is not controlled by a single entity, at\n> least for non-self-payments.\n>\n> > If S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B),\n> lock funds C,D,E but then not allowing it to relay funds (possibly do a\n> griefing attack?).\n>\n> Griefing attacks are only possible by not claiming or forwarding the\n> attack.\n> If S and B \"collude\" to perform a grief, then either B never forwards to\n> C, in which case there is no possible way to attack, or C receives it and\n> claims it but B does not claim it, in which case B paid out money and is\n> now idiotically refusing to claim money.\n>\n> Grief attacks are attacks by payers and payees on intermediate nodes (S\n> and R attacking A,B,C,D,E,F), and in that case the entire payment secret\n> would be known by both S and R anyway.\n>\n> So S and B cannot cooperate to perform a griefing attack on the path.\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > On Wed, Apr 1, 2020 at 10:39 PM ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> wrote:\n> >\n> > > Good morning Subhra,\n> > >\n> > > > Commenting on it : \"As for ZmnSCPxj's suggestion, I think there is\n> the same kind of issue.\n> > > > The secrets we establish with anonymous multi-hops locks are between\n> the *sender*\n> > > > and each of the hops. In the route blinding case, what we're adding\n> are secrets\n> > > > between the *recipient* and the hops, and we don't want the sender\n> to be able to\n> > > > influence those.\"\n> > > > Is it a good idea to rely entirely on the sender for sampling the\n> secrets as well as generating the PTLC? As happens in anonymous multi-hops\n> locks, for example. Or as it has been discussed later in the thread, both\n> receiver and sender must be involved in creation of PTLC? What happens if\n> sender/receiver is/(or both are) corrupted? Can it leak secrets to other\n> parties?\n> > >\n> > > If both are corrupted, this brings up the question: who are you hiding\n> any information from?\n> > > The corruptor has already corrupted both: there is no security or\n> privacy possible, the payment is already totally compromised.\n> > >\n> > > The operation of forwarding nodes is simple enough that in general\n> they cannot be attacked: sure, the sender and receiver together knows who\n> they are, but forwarding nodes are the ones who advertise themselves in\n> order to be forwarded through, so they already are known anyway.\n> > >\n> > > When considering privacy, we should always consider that it is the\n> payment as a whole which we want to have privacy: we want that third\n> parties will not be able to nail down which particular sender sent to which\n> particular receiver.\n> > > Thus if the sender already leaks who it is paying to, that is pretty\n> much the entire loss of privacy.\n> > >\n> > > Now, currently on Lightning, in general the receiver does not know the\n> sender node.\n> > > (Applications on top of Lightning might have the receiver require the\n> sender to provide private data, such as a drop point to send a physical\n> product to, but *looking only on Lightning* the sender does not send any of\n> its information to the receiver).\n> > >\n> > > However, currently, the exact receiver node has to be known by the\n> sender, in order for the sender to make a route to it.\n> > > This is a concern since it may be possible for layer-crossing\n> shenanigans to be performed, for example the sender might attempt to\n> eclipse the receiver on the Bitcoin blockchain layer and make it lose funds\n> by not realizing that a PTLC/HTLC has been timed out (because the eclipse\n> attack prevents new blocks from propagating to the receiver, who blithely\n> continues to think that the timeout has not been reached when in fact it\n> has).\n> > >\n> > > The proposal to have a receiver provide a partial, blinded path gives\n> the receiver better privacy protection against the sender: the sender knows\n> it is one of a possible number of nodes within some number of hops from a\n> particular node, but does not know if it is that exact node, one of its\n> neighbors, or one of its neighbor neighbors (etc.) is the actual receiver.\n> > > This should make it harder for the sender to attack the receiver by\n> attempting to locate its node and eclipse it at the Bitcoin layer, or other\n> blockchain-layer shenanigans.\n> > >\n> > > Now, the argument I make is that while the blinding factors in a\n> decorrelated PTLC-based payment may be generated by the sender in order for\n> the sender to have path privacy, it is safe for the receiver to provide\n> blinding factors to a partial path as well.\n> > > We should remember that the blinding factors are just scalars added to\n> the final point/scalar at the ultimate recipient, and the final\n> point/scalar pair is completely controlled by the recipient anyway, so it\n> should not be an issue here: the point that the sender will target at the\n> first node in the receiver-provided partial route is no different from the\n> final point that the sender would have targeted if it knew exactly who the\n> receiver is.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> >\n> > --\n> > Yours sincerely,\n> > Subhra Mazumdar.\n>\n>\n>\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200402/8ca72e42/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-02T08:05:06",
                "message_text_only": "Good morning Subhra,\n\n> Thank you for the clarification. Sorry for misinterpreting the paper of anonymous multihop lock. A bit of rephrasing of what I exactly meant and apologies for describing vaguely. Following your discussion on griefing attack, it is clear the payer and payee wants to intentionally deprive intermediate nodes, by colluding. However, by griefing (a misnomer for this situation) I didn't mean exactly withholding the solution but something like this:\n> Given S->A->B->C->D->E->F->R, S, B and F are controlled by the same adversary and considering all the parties have completed the lock phase. Now R triggers release phase and F gets x_r from R. However, F adds x_f to x_r forwards it directly to B, doesn't complete signature with E and cancels the HTLC just before the elapse of expiration time, E terminates its HTLC with D and so on. B has x_c+x_d+x_e+x_f+x_r (shared by F and shared by S). It continues normally completing payment with A and then S. I am not sure whether again this attack makes sense.\n\nIf S controls F, then it could have just forwarded F->R directly without involving C D E at all, so in both cases C D E would also not earn any forwarding fees; instead now C D E learn of this payment, so the collusion S B F just unnecessarily leaks its intent to pay R by doing this.\n\nAgain, S B F cannot steal funds from C D E by this method, it can only grief them, but it could grief C D E by just B and F, not involving any S or R, so this does not increase the attack surface at all.\n\nSo I do not see the point of this exercise; S controls F anyway, so it could just as well have forwarded F->R directly.\n\nRegards,\nZmnSCPxj\n\n\n>\n> On Thu, Apr 2, 2020 at 6:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Subhra,\n> >\n> > > Hi ZmnSCPxj,\n> > > \u00a0\u00a0\u00a0\u00a0 Thanks for the explanation. Pardon my knowledge in this domain but what I meant is that sender has malicious intent and wants honest parties to suffer. So by leaking secrets, I meant not revealing its or receiver's identity to the forwarding nodes, but somehow manipulating subset of the nodes so that an attack can be launched in the network. For example, consider path S->A->B->C->D->E->F->R. If we consider the protocol anonymous multihop lock, S samples secret x_a,x_b,x_c,x_d,x_e,x_f for the nodes A,B,C,D,E and F respectively. R gets the key k=x_a+x_b+x_c+x_d+x_e+x_f. If S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B), lock funds C,D,E but then not allowing it to relay funds (possibly do a griefing attack?). What I meant is that if one totally relies on S for the setup phase, won't it lead to other vulnerabilities? The situation might sound unrealistic but I still have doubt whether we guarantee fairness if put our trust entirely on one single entity.\n> >\n> > Note that in the context of PTLCs, R does not get a key (as in private key) of x_a+x_b+x_c+x_d+x_e+x_f.\n> > Instead, R still continues to use its normal private key for claiming HTLC/PTLC.\n> > We simply have R generate an adaptor signature first and hand that over to F, such that completing the signature and publishing it onchain will reveal a secret x_r (which is NOT the node privkey of R).\n> >\n> > What happens really here is that each hop sets up a PTLC.\n> > The sender is responsible for ensuring that the F->R PTLC is equal to x_r * G, that E->F is equal to (x_f + x_r) * G, that D->E is equal to (x_e + x_f + x_r) * G, and so on.\n> > However,\u00a0 the sender knows only (x_r * G) without knowing x_r, thus it never is able to completely control the secret at every point -- the receiver knows the other secret as well.\n> >\n> > That is the entire crux of the argument --- *both* sender and receiver control the secrets anyway, so it is not controlled by a single entity, at least for non-self-payments.\n> >\n> > > If S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B), lock funds C,D,E but then not allowing it to relay funds (possibly do a griefing attack?).\n> >\n> > Griefing attacks are only possible by not claiming or forwarding the attack.\n> > If S and B \"collude\" to perform a grief, then either B never forwards to C, in which case there is no possible way to attack, or C receives it and claims it but B does not claim it, in which case B paid out money and is now idiotically refusing to claim money.\n> >\n> > Grief attacks are attacks by payers and payees on intermediate nodes (S and R attacking A,B,C,D,E,F), and in that case the entire payment secret would be known by both S and R anyway.\n> >\n> > So S and B cannot cooperate to perform a griefing attack on the path.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > >\n> > > On Wed, Apr 1, 2020 at 10:39 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > >\n> > > > Good morning Subhra,\n> > > >\n> > > > > Commenting on it : \"As for ZmnSCPxj's suggestion, I think there is the same kind of issue.\n> > > > > The secrets we establish with anonymous multi-hops locks are between the *sender*\n> > > > > and each of the hops. In the route blinding case, what we're adding are secrets\n> > > > > between the *recipient* and the hops, and we don't want the sender to be able to\n> > > > > influence those.\"\n> > > > > Is it a good idea to rely entirely on the sender for sampling the secrets as well as generating the PTLC? As happens in anonymous multi-hops locks, for example. Or as it has been discussed later in the thread, both receiver and sender must be involved in creation of PTLC? What happens if sender/receiver is/(or both are) corrupted? Can it leak secrets to other parties?\n> > > >\n> > > > If both are corrupted, this brings up the question: who are you hiding any information from?\n> > > > The corruptor has already corrupted both: there is no security or privacy possible, the payment is already totally compromised.\n> > > >\n> > > > The operation of forwarding nodes is simple enough that in general they cannot be attacked: sure, the sender and receiver together knows who they are, but forwarding nodes are the ones who advertise themselves in order to be forwarded through, so they already are known anyway.\n> > > >\n> > > > When considering privacy, we should always consider that it is the payment as a whole which we want to have privacy: we want that third parties will not be able to nail down which particular sender sent to which particular receiver.\n> > > > Thus if the sender already leaks who it is paying to, that is pretty much the entire loss of privacy.\n> > > >\n> > > > Now, currently on Lightning, in general the receiver does not know the sender node.\n> > > > (Applications on top of Lightning might have the receiver require the sender to provide private data, such as a drop point to send a physical product to, but *looking only on Lightning* the sender does not send any of its information to the receiver).\n> > > >\n> > > > However, currently, the exact receiver node has to be known by the sender, in order for the sender to make a route to it.\n> > > > This is a concern since it may be possible for layer-crossing shenanigans to be performed, for example the sender might attempt to eclipse the receiver on the Bitcoin blockchain layer and make it lose funds by not realizing that a PTLC/HTLC has been timed out (because the eclipse attack prevents new blocks from propagating to the receiver, who blithely continues to think that the timeout has not been reached when in fact it has).\n> > > >\n> > > > The proposal to have a receiver provide a partial, blinded path gives the receiver better privacy protection against the sender: the sender knows it is one of a possible number of nodes within some number of hops from a particular node, but does not know if it is that exact node, one of its neighbors, or one of its neighbor neighbors (etc.) is the actual receiver.\n> > > > This should make it harder for the sender to attack the receiver by attempting to locate its node and eclipse it at the Bitcoin layer, or other blockchain-layer shenanigans.\n> > > >\n> > > > Now, the argument I make is that while the blinding factors in a decorrelated PTLC-based payment may be generated by the sender in order for the sender to have path privacy, it is safe for the receiver to provide blinding factors to a partial path as well.\n> > > > We should remember that the blinding factors are just scalars added to the final point/scalar at the ultimate recipient, and the final point/scalar pair is completely controlled by the recipient anyway, so it should not be an issue here: the point that the sender will target at the first node in the receiver-provided partial route is no different from the final point that the sender would have targeted if it knew exactly who the receiver is.\n> > > >\n> > > > Regards,\n> > > > ZmnSCPxj\n> > >\n> > > --\n> > > Yours sincerely,\n> > > Subhra Mazumdar.\n>\n> --\n> Yours sincerely,\n> Subhra Mazumdar."
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-04-02T17:42:06",
                "message_text_only": "Hi ZmnSCPxj,\n       Thank you for the clarification.I got your point.\n\nOn Thu, Apr 2, 2020 at 1:35 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n> > Thank you for the clarification. Sorry for misinterpreting the paper of\n> anonymous multihop lock. A bit of rephrasing of what I exactly meant and\n> apologies for describing vaguely. Following your discussion on griefing\n> attack, it is clear the payer and payee wants to intentionally deprive\n> intermediate nodes, by colluding. However, by griefing (a misnomer for this\n> situation) I didn't mean exactly withholding the solution but something\n> like this:\n> > Given S->A->B->C->D->E->F->R, S, B and F are controlled by the same\n> adversary and considering all the parties have completed the lock phase.\n> Now R triggers release phase and F gets x_r from R. However, F adds x_f to\n> x_r forwards it directly to B, doesn't complete signature with E and\n> cancels the HTLC just before the elapse of expiration time, E terminates\n> its HTLC with D and so on. B has x_c+x_d+x_e+x_f+x_r (shared by F and\n> shared by S). It continues normally completing payment with A and then S. I\n> am not sure whether again this attack makes sense.\n>\n> If S controls F, then it could have just forwarded F->R directly without\n> involving C D E at all, so in both cases C D E would also not earn any\n> forwarding fees; instead now C D E learn of this payment, so the collusion\n> S B F just unnecessarily leaks its intent to pay R by doing this.\n>\n> Again, S B F cannot steal funds from C D E by this method, it can only\n> grief them, but it could grief C D E by just B and F, not involving any S\n> or R, so this does not increase the attack surface at all.\n>\n> So I do not see the point of this exercise; S controls F anyway, so it\n> could just as well have forwarded F->R directly.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> >\n> > On Thu, Apr 2, 2020 at 6:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > > Good morning Subhra,\n> > >\n> > > > Hi ZmnSCPxj,\n> > > >      Thanks for the explanation. Pardon my knowledge in this domain\n> but what I meant is that sender has malicious intent and wants honest\n> parties to suffer. So by leaking secrets, I meant not revealing its or\n> receiver's identity to the forwarding nodes, but somehow manipulating\n> subset of the nodes so that an attack can be launched in the network. For\n> example, consider path S->A->B->C->D->E->F->R. If we consider the protocol\n> anonymous multihop lock, S samples secret x_a,x_b,x_c,x_d,x_e,x_f for the\n> nodes A,B,C,D,E and F respectively. R gets the key\n> k=x_a+x_b+x_c+x_d+x_e+x_f. If S colludes with B (possibly leak the value\n> x_c,x_d,x_e,x_f to B), lock funds C,D,E but then not allowing it to relay\n> funds (possibly do a griefing attack?). What I meant is that if one totally\n> relies on S for the setup phase, won't it lead to other vulnerabilities?\n> The situation might sound unrealistic but I still have doubt whether we\n> guarantee fairness if put our trust entirely on one single entity.\n> > >\n> > > Note that in the context of PTLCs, R does not get a key (as in private\n> key) of x_a+x_b+x_c+x_d+x_e+x_f.\n> > > Instead, R still continues to use its normal private key for claiming\n> HTLC/PTLC.\n> > > We simply have R generate an adaptor signature first and hand that\n> over to F, such that completing the signature and publishing it onchain\n> will reveal a secret x_r (which is NOT the node privkey of R).\n> > >\n> > > What happens really here is that each hop sets up a PTLC.\n> > > The sender is responsible for ensuring that the F->R PTLC is equal to\n> x_r * G, that E->F is equal to (x_f + x_r) * G, that D->E is equal to (x_e\n> + x_f + x_r) * G, and so on.\n> > > However,  the sender knows only (x_r * G) without knowing x_r, thus it\n> never is able to completely control the secret at every point -- the\n> receiver knows the other secret as well.\n> > >\n> > > That is the entire crux of the argument --- *both* sender and receiver\n> control the secrets anyway, so it is not controlled by a single entity, at\n> least for non-self-payments.\n> > >\n> > > > If S colludes with B (possibly leak the value x_c,x_d,x_e,x_f to B),\n> lock funds C,D,E but then not allowing it to relay funds (possibly do a\n> griefing attack?).\n> > >\n> > > Griefing attacks are only possible by not claiming or forwarding the\n> attack.\n> > > If S and B \"collude\" to perform a grief, then either B never forwards\n> to C, in which case there is no possible way to attack, or C receives it\n> and claims it but B does not claim it, in which case B paid out money and\n> is now idiotically refusing to claim money.\n> > >\n> > > Grief attacks are attacks by payers and payees on intermediate nodes\n> (S and R attacking A,B,C,D,E,F), and in that case the entire payment secret\n> would be known by both S and R anyway.\n> > >\n> > > So S and B cannot cooperate to perform a griefing attack on the path.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > >\n> > > > On Wed, Apr 1, 2020 at 10:39 PM ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> wrote:\n> > > >\n> > > > > Good morning Subhra,\n> > > > >\n> > > > > > Commenting on it : \"As for ZmnSCPxj's suggestion, I think there\n> is the same kind of issue.\n> > > > > > The secrets we establish with anonymous multi-hops locks are\n> between the *sender*\n> > > > > > and each of the hops. In the route blinding case, what we're\n> adding are secrets\n> > > > > > between the *recipient* and the hops, and we don't want the\n> sender to be able to\n> > > > > > influence those.\"\n> > > > > > Is it a good idea to rely entirely on the sender for sampling\n> the secrets as well as generating the PTLC? As happens in anonymous\n> multi-hops locks, for example. Or as it has been discussed later in the\n> thread, both receiver and sender must be involved in creation of PTLC? What\n> happens if sender/receiver is/(or both are) corrupted? Can it leak secrets\n> to other parties?\n> > > > >\n> > > > > If both are corrupted, this brings up the question: who are you\n> hiding any information from?\n> > > > > The corruptor has already corrupted both: there is no security or\n> privacy possible, the payment is already totally compromised.\n> > > > >\n> > > > > The operation of forwarding nodes is simple enough that in general\n> they cannot be attacked: sure, the sender and receiver together knows who\n> they are, but forwarding nodes are the ones who advertise themselves in\n> order to be forwarded through, so they already are known anyway.\n> > > > >\n> > > > > When considering privacy, we should always consider that it is the\n> payment as a whole which we want to have privacy: we want that third\n> parties will not be able to nail down which particular sender sent to which\n> particular receiver.\n> > > > > Thus if the sender already leaks who it is paying to, that is\n> pretty much the entire loss of privacy.\n> > > > >\n> > > > > Now, currently on Lightning, in general the receiver does not know\n> the sender node.\n> > > > > (Applications on top of Lightning might have the receiver require\n> the sender to provide private data, such as a drop point to send a physical\n> product to, but *looking only on Lightning* the sender does not send any of\n> its information to the receiver).\n> > > > >\n> > > > > However, currently, the exact receiver node has to be known by the\n> sender, in order for the sender to make a route to it.\n> > > > > This is a concern since it may be possible for layer-crossing\n> shenanigans to be performed, for example the sender might attempt to\n> eclipse the receiver on the Bitcoin blockchain layer and make it lose funds\n> by not realizing that a PTLC/HTLC has been timed out (because the eclipse\n> attack prevents new blocks from propagating to the receiver, who blithely\n> continues to think that the timeout has not been reached when in fact it\n> has).\n> > > > >\n> > > > > The proposal to have a receiver provide a partial, blinded path\n> gives the receiver better privacy protection against the sender: the sender\n> knows it is one of a possible number of nodes within some number of hops\n> from a particular node, but does not know if it is that exact node, one of\n> its neighbors, or one of its neighbor neighbors (etc.) is the actual\n> receiver.\n> > > > > This should make it harder for the sender to attack the receiver\n> by attempting to locate its node and eclipse it at the Bitcoin layer, or\n> other blockchain-layer shenanigans.\n> > > > >\n> > > > > Now, the argument I make is that while the blinding factors in a\n> decorrelated PTLC-based payment may be generated by the sender in order for\n> the sender to have path privacy, it is safe for the receiver to provide\n> blinding factors to a partial path as well.\n> > > > > We should remember that the blinding factors are just scalars\n> added to the final point/scalar at the ultimate recipient, and the final\n> point/scalar pair is completely controlled by the recipient anyway, so it\n> should not be an issue here: the point that the sender will target at the\n> first node in the receiver-provided partial route is no different from the\n> final point that the sender would have targeted if it knew exactly who the\n> receiver is.\n> > > > >\n> > > > > Regards,\n> > > > > ZmnSCPxj\n> > > >\n> > > > --\n> > > > Yours sincerely,\n> > > > Subhra Mazumdar.\n> >\n> > --\n> > Yours sincerely,\n> > Subhra Mazumdar.\n>\n>\n>\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200402/0c9a9d1b/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Blind paths revisited",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Subhra Mazumdar",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 47018
        }
    },
    {
        "title": "[Lightning-dev] Barrier Escrow (Was: Re: A Payment Point Feature Family (MultiSig, DLC, Escrow, ...))",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-16T08:32:16",
                "message_text_only": "Good morning Nadav, and list,\n\nResurrecting this very old thread, but I have been thinking of barrier escrows again lately.\n\nThe mitigation in https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002215.html does not work, because one of the participants can always just create a single payment of the entire amount with its own generated `Z`, and the barrier escrow would be unable to differentiate this from the case where it \"should\" have gotten the payment from multiple participants.\nAdditional checks can be done to prevent this, but this moves the trust requirement to the barrier escrow.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-04-16T14:42:08",
                "message_text_only": "Good morning ZmnSCPxj and all,\n\nI had this thought too! I wrote a blog post series summarizing much of this\nold thread and here are the two posts about Barrier Escrows:\n\nhttps://suredbits.com/payment-points-and-barrier-escrows/\nhttps://suredbits.com/payment-points-implementing-barrier-escrows/\n\nWhat I end up proposing is that a barrier escrow implement the following\ninterface:\n\n\n   1. *barrier-commit* takes as input a list of points (P_1, \u2026, P_n) and\n   returns a point E if\n   a. None of the input points have been seen before\n   b. The exact inputs (P_1, \u2026,P_n) has been received before in which case\n   the point E returned is the same point as was returned last time\n   2. *barrier-reveal* takes as input a single scalar, x, and if it has\n   seen x*G as part of an input list to barrier-commit (P_1, \u2026, P_n), to which\n   it returned the point E, then it waits to receive barrier-reveal requests\n   for each of the n points before it then returns the scalar pre-image to E.\n\nIn this way, each participant contributes a point commitment and if any\nparty is cheating, it can be detected by the other parties. As I discuss in\nthe second post, the first interaction can happen in many ways but I\npersonally suggested something along the lines of using invoice offers if\npossible.\n\nBest,\nNadav\n\nOn Thu, Apr 16, 2020 at 3:32 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Nadav, and list,\n>\n> Resurrecting this very old thread, but I have been thinking of barrier\n> escrows again lately.\n>\n> The mitigation in\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002215.html\n> does not work, because one of the participants can always just create a\n> single payment of the entire amount with its own generated `Z`, and the\n> barrier escrow would be unable to differentiate this from the case where it\n> \"should\" have gotten the payment from multiple participants.\n> Additional checks can be done to prevent this, but this moves the trust\n> requirement to the barrier escrow.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200416/574fa4c6/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Barrier Escrow (Was: Re: A Payment Point Feature Family (MultiSig, DLC, Escrow, ...))",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2857
        }
    },
    {
        "title": "[Lightning-dev] Anchor Outputs Spec & Implementation Progress",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2020-04-17T03:07:37",
                "message_text_only": "Knee-jerk gut reaction replies inline :)\n\nMatt\n\nOn 3/30/20 3:00 PM, Olaoluwa Osuntokun wrote:\n\n-snip-\n\n> In response to the first concern: it is indeed the case that these new\n> commitments are more expensive, but they're only _slightly_ so. The new\n> default commitment weight is as if there're two HTLCs at all times on the\n> commitment transaction. Adding in the extra anchor cost (660 satoshis) is a\n> false equivalence as both parties are able to recover these funds if they\n> chose. It's also the case that force cases in the ideal case are only due to\n> nodes needing to go on-chain to sweep HTLCs, so the extra bytes may be\n> dwarfed by several HTLCs, particularly in a post MPP/AMP world. The extra\n> cost may seem large (relatively) when looking at a 1 sat/byte commitment\n> transaction. However, fees today in the system are on the rise, and if one\n> is actually in a situation where they need to resolve HTLCs on chain,\n> they'll likely require a fee rate higher than 1 sat/byte to have their\n> commitment confirm in a timely manner.\n\nIndeed, a few hundred sats isn't likely worth arguing about :)\n\n> On the topic of UTXO bloat, IMO re-purposing the to_remote output as an\n> anchor is arguably _worse_, as only a single party in the channel is able to\n> spend that output in order to remove its impact on the UTXO set. On the\n> other hand, using two anchors (with their special scripts) allows _anyone_\n> to sweep these outputs several blocks after the commitment transaction has\n> confirmed. In order to cover the case where the remote party has no balance,\n> but a single incoming HTLC, the channel initiator must either create a new\n> anchor output for this special case (creating a new type of ad-hoc reserve),\n> or always create a to_remote output for the other party (donating the 330\n> satoshis).\n\nThis seems like a straw-man. Going from 1 anyone-spendable + 1 such UTXO to 2 anyone-spendable UTXOs + 1 such UTXO does not seem like a\ndecrease to me. If you really want to nitpick, I have zero issue with having the to_remote+anchor revert to an anyone-can-spend form if it\nis of dust value. This may be a bit complicated for others, but with our new onchain stuff, it would be rather trivial for us to deal with.\n\n> The first option reduces down to having two anchors once again,\n> while the second option creates an output which is likely uneconomical to\n> sweep in isolation (compared to anchors which can be swept globally in the\n> system taking advantage of the input aggregation savings).\n> \n> The final factor to consider is if we wish to properly re-introduce a CSV\n> delay to the to_remote party in an attempt to remedy some game theoretical\n> issues w.r.t forcing one party to close early without a cost to the\n> instigator. In the past we made some headway in this direction, but then\n> reverted our changes as we discoverers some previously unknown gaming\n> vectors even with a symmetrical delay. If we keep two anchor as is, then we\n> leave this thread open to a comprehensive solution, as the dual anchor\n> format is fully decoupled from the rest of the commitment.\n\nIf we want to deploy an upgrade, the commitment transaction format will change. Lets not get excited about reducing the diff in such a\nchange for its own sake - the vast majority of the effort is the upgrade, not the diff of having an extra anchor."
            }
        ],
        "thread_summary": {
            "title": "Anchor Outputs Spec & Implementation Progress",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Matt Corallo"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3347
        }
    },
    {
        "title": "[Lightning-dev] RBF Pinning with Counterparties and Competing Interest",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2020-04-21T02:43:14",
                "message_text_only": "[Hi bitcoin-dev, in lightning-land we recently discovered some quite frustrating issues which I thought may merit\nbroader discussion]\n\nWhile reviewing the new anchor outputs spec [1] last week, I discovered it introduced a rather nasty ability for a user\nto use RBF Pinning to steal in-flight HTLCs which are being enforced on-chain. Sadly, Antoine pointed out that this is\nan issue in today's light as well, though see [2] for qualifications. After some back-and-forth with a few other\nlightning folks, it seems clear that there is no easy+sane fix (and the practicality of exploitation today seems\nincredibly low), so soliciting ideas publicly may be the best step forward.\n\nI've included lots of background for those who aren't super comfortable with lightning's current design, but if you\nalready know it well, you can skip at least background 1 & 2.\n\nBackground - Lightning's Transactions (you can skip this)\n=====================================\n\nAs many of you likely know, lightning today does all its update mechanics through:\n a) a 2-of-2 multisig output, locking in the channel,\n b) a \"commitment transaction\", which spends that output: i) back to its owners, ii) to \"HTLC outputs\",\n c) HTLC transactions which spend the relevant commitment transaction HTLC outputs.\n\nThis somewhat awkward third layer of transactions is required to allow HTLC timeouts to be significantly lower than the\ntime window during which a counterparty may be punished for broadcasting a revoked state. That is to say, you want to\n\"lock-in\" the resolution of an HTLC output (ie by providing the hash lock preimage on-chain) by a fixed block height\n(likely a few hours from the HTLC creation), but the punishment mechanism needs to occur based on a sequence height\n(possibly a day or more after transaction broadcast).\n\nAs Bitcoin has no covanents, this must occur using pre-signed transactions - namely \"HTLC-Success\" and \"HTLC-Timeout\"\ntransactions, which finalize the resolution of an HTLC, but have a sequence-lock for some time during which the funds\nmay be taken if they had previously been revoked. To avoid needless delays, if the counterparty which did *not*\nbroadcast the commitment transaction wishes to claim the HTLC value, they may do so immediately (as there is no reason\nto punish the non-broadcaster for having *not* broadcasted a revoked state). Thus, we have four possible HTLC\nresolutions depending on the combination of which side broadcast the HTLC and which side sent the HTLC (ie who can claim\nit vs who can claim it after time-out):\n\n 1) pre-signed HTLC-Success transaction, providing the preimage in the witness and sent to an output which is sequence-\n    locked for some time to provide the non-broadcasting side the opportunity to take the funds,\n 2) pre-signed HTLC-Timeout transaction, time-locked to N, providing no preimage, but with a similar sequence lock and\n    output as above,\n 3) non-pre-signed HTLC claim, providing the preimage in the witness and unencumbered by the broadcaster's signature,\n 4) non-pre-signed HTLC timeout, OP_CLTV to N, and similarly unencumbered.\n\nBackground 2 - RBF Pinning (you can skip this)\n==========================\n\nBitcoin Core's general policy on RBF transactions is that if a counterparty (either to the transaction, eg in lightning,\nor not, eg a P2P node which sees the transaction early) can modify a transaction, especially if they can add an input or\noutput, they can prevent it from confirming in a world where there exists a mempool (ie in a world where Bitcoin works).\nWhile this is somewhat unintuitive, there are any number of good anti-DoS reasons for this, eg:\n * (ok, this is a bad reason, but) a child transaction could be marked 'non-RBF', which would mean allowing the parent\n   be RBF'd would violate the assumptions those who look at the RBF opt-in marking make,\n * a parent may be very large, but low feerate - this requires the RBF attempt to \"pay for its own relay\" and include a\n   large absolute fee just to get into the mempool,\n * one of the various package size limits is at its maximum, and depending on the structure of the package the\n   computational complexity of calculation evictions may be more than we want to do for a given transaction.\n\nBackground 3 - \"The RBF Carve-Out\" (you can skip this)\n==================================\n\nIn today's lightning, we have a negotiation of what we expect the future feerate to be when one party goes to close the\nchannel. All the pre-signed transactions above are constructed with this fee-rate in mind, and, given they are all\npre-signed, adding additional fee to them is not generally an option. This is obviously a very maddening prediction\ngame, especially when the security consequences for negotiating a value which is wrong may allow your counterparty to\nbroadcast and time out HTLCs which you otherwise have the preimage for. To remove this quirk, we came up with an idea a\nyear or two back now called \"anchor outputs\" (aka the RBF carve-out for those in Bitcoin-land) - a neat trick to allow\nboth counterparties to add fees to a transaction which is being broadcast without getting into the quagmire that is RBF\npinning. Specifically, we added a rule to Bitcoin Core which allows for transactions which have a narrow structure to be\nCPFP'd trivially by either counterparty, irrespective of what the other counterparty does! In order to meet this\nstructure, the commitment transaction (b) must have two (potentially-)additional outputs, each which only one side can\nspend, and every other output must have a CSV lock associated with it. This is great and there is (finally) movement to\ndeploy this.\n\nRBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n=============================\n\nYou'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\nour HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\nlightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\nif B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\nAfter a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\nHTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n\nYou'll note that B would be just fine if they had a way to safely monitor the global mempool, and while this seems like\na prudent mitigation for lightning implementations to deploy today, it is itself a quagmire of complexity, especially\nwhen you consider differences in relay policy during an upgrade cycle and how those may effect propagation through the\nP2P network. Further, this is a really obnoxious assumption to hoist onto lightning nodes - having an active full node\nwith an in-sync mempool is a lot more CPU, bandwidth, and complexity than most lightning users were expecting to face.\n\nIt seems highly likely we could come up with some kind of variant of of the RBF Carve-Out to solve this problem, though\nprobably much more specific to this particular transaction structure - imagine a rule which allowed B to RBF C's low-fee\nHTLC claim transaction, without ever seeing it. This could be accomplished by locking down the transaction types in (3)\nand (4) by pre-signing them (just, like (1) and (2)) and then using some kind of policy rule to allow only the addition\nof additional confirmed inputs and one (small) output. This would mean that B knows that either C's transaction has high\nfee, or B's reasonably-higher-fee transaction will meet the RBF rules and replace C's maliciousness.\n\nWhile the original RBF Carve-Out was a little awkward, its structure was sufficiently generic that other off-chain\nprotocols could reasonably (need to) take advantage of it, however a rule to address this issue seems like it would need\nto be highly tailored to lightning, which doesn't seem acceptable (there appears to be a way to shoehorn the existing\ncarve-out, but it results in a ton of extra on-chain volume).\n\nStrategies involving full-RBF for transactions not at the top of the mempool, (slow-)full-mempool-sync allowing\nmempool-total-fee decreases and relaxations of the RBF rules would be welcome, but without a ton of legwork to include\nthings like package relay I'm not convinced they would suffice. This of course doesn't even account for the possibility\nof similar issues given rely policy differences.\n\nPS For Lightning-Dev Folks (aka \"An Alternative Anchor Proposal\")\n==========================\n\nGiven the anchor outputs proposal seeks to expand lightning's security in a world where Bitcoin is running at\nsteady-state and the mempool reliably has transactions in it, not fixing this issue seems to render the whole exercise\nsomewhat useless (not to mention that the current design makes this attack more obvious and provides several alternative\npaths to exploitation).\n\nAn alternative, albeit not ideal anchor outputs proposal is as follows:\n\n * Instead of making the HTLC output spending more free-form with SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need\n   to go the other direction - all HTLC output spends need to be pre-signed.\n * Sadly, and this really hurts from an on-chain-tx-size perspective, we have to include anchor outputs in the HTLC\n   transactions (intuitively I think all of them, but at least HTLC-fulfilling transactions definitely).\n * Our poor B, being exploited, above, will attempt to spend their anchor output with a CPFP even if they aren't sure C\n   has broadcast the HTLC-Success transaction! This is fine as B already knows the txid, and just wants to learn whats\n   in the witness (assuming there is one).\n\nFor those from bitcoin-dev still reading who are thinking \"blah, you clearly don't need anything else, you have a\nsolution!\" we're talking about extra outputs out the wazoo for hopefully-unnecessary edge cases involving transactions\nentering the mempool which a user wants to avoid confirming! This severely cuts into the lowest-value HTLCs which can be\nsent \"safely\" and adds a significant social cost of extra low-value, possibly-uneconomical outputs in the chain.\n\nStill, lacking a better idea, and with a strong desire to make lightning's security more practical in a world where\nBitcoin miners are paid to operate, we should probably start considering moving forward with this.\n\nThanks for reading,\nMatt\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/688\n\n[2] I'll note that while it is a \"severe issue\", given the general issues with fee-prediction described in background 3,\nits pretty hard to argue its really in the scope of the security model of lightning today. If there were an easy fix to\nit, we'd have deployed it by now in response to private discussion, but, sadly, there is not."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-22T04:12:59",
                "message_text_only": "Good morning Matt, and list,\n\n\n\n>     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n>     =============================\n>\n>     You'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\n>     our HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\n>     lightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\n>     if B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\n>     After a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\n>     HTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n\nMy (cached) understanding is that, since RBF is signalled using `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\nAdding that clause (2 bytes in witness if my math is correct) to the hashlock branch may be sufficient to prevent C from making an RBF-disabled transaction.\n\nBut then you mention out-of-band agreements with miners, which basically means the transaction might not be in the mempool at all, in which case the vulnerability is not really about RBF or relay, but sheer economics.\n\nThe payment is A->B->C, and the HTLC A->B must have a larger timeout (L + 1) than the HTLC B->C (L), in abstract non-block units.\nThe vulnerability you are describing means that the current time must now be L + 1 or greater (\"A could claim the HTLC from B via the timeout mechanism\", meaning the A->B HTLC has timed out already).\n\nIf so, then the B->C transaction has already timed out in the past and can be claimed in two ways, either via B timeout branch or C hashlock branch.\nThis sets up a game where B and C bid to miners to get their version of reality committed onchain.\n(We can neglect out-of-band agreements here; miners have the incentive to publicly leak such agreements so that other potential bidders can offer even higher fees for their versions of that transaction.)\n\nBefore L+1, C has no incentive to bid, since placing any bid at all will leak the preimage, which B can then turn around and use to spend from A, and A and C cannot steal from B.\n\nThus, B should ensure that *before* L+1, the HTLC-Timeout has been committed onchain, which outright prevents this bidding war from even starting.\n\nThe issue then is that B is using a pre-signed HTLC-timeout, which is needed since it is its commitment tx that was broadcast.\nThis prevents B from RBF-ing the HTLC-Timeout transaction.\n\nSo what is needed is to allow B to add fees to HTLC-Timeout:\n\n* We can add an RBF carve-out output to HTLC-Timeout, at the cost of more blockspace.\n* With `SIGHASH_NOINPUT` we can make the C-side signature `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side signature for a higher-fee version of HTLC-Timeout (assuming my cached understanding of `SIGHASH_NOINPUT` still holds).\n\nWith this, B can exponentially increase the fee as L+1 approaches.\nIf B can get HTLC-Timeout confirmed before L+1, then C cannot steal the HTLC value at all, since the UTXO it could steal from has already been spent.\n\nIn particular, it does not seem to me that it is necessary to change the hashlock-branch transaction of C at all, since this mechanism is enough to sidestep the issue (as I understand it).\nBut it does point to a need to make HTLC-Timeout (and possibly symmetrically, HTLC-Success) also fee-bumpable.\n\nNote as well that this does not require a mempool: B can run in `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout is not confirmed, feebump HTLC-Timeout.\nIn particular, HTLC-Timeout comes into play only if B broadcast its own commitment transaction, and B *should* be aware that it did so --- there is still no need for mempool monitoring here.\n\n\nNow, of course this only delays the war.\nLet us now consider what C can do to ensure that the bidding war will happen eventually.\n\n* C can bribe a miner to prevent HTLC-Timeout from confirming between L and L+1.\n  * Or in other words, this is a censorship attack.\n    * The Bitcoin censorship-resistance model is that censored transactions can be fee-bumped, which attracts non-censoring miners to try their luck at mining and evict the censoring miner.\n      * Thus, letting B bump the fee on HTLC-Timeout is precisely the mechanism we need.\n      * This sets up a bidding war between C requesting miners to censor, vs. B requesting miners to confirm, but that only sets the stage for a second bidding war later between C and B, thus C is at a disadvantage: it has to bribe miners to censor continuously from L to L+1 *and* additional bribe miners to confirm its transaction after L+1, whereas B can offer its bribe as being something that miners can claim now without waiting after L+1.\n\n\n\nThe issue of course is the additional output that bloats the UTXO set and requires another transaction to claim later.\nAnd if we have `SIGHASH_NOINPUT`, it seems to me that Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out HTLC can be claimed with a fee-bumpable transaction directly without RBF-carve-out.\n(As well, it seems to me that, if both nodes support doing so, a Poon-Dryja channel can be upgraded, without onchain activity, to a Decker-Russell-Osuntokun channel: sign a transaction spending the funding tx to a txo that has been set up as Decker-Russell-Osuntokun, do not broadcast that transaction, then revoke the latest Poon-Dryja commitment transactions, then switch the mechanism over to Decker-Russell-Osuntokun; you still need to monitor for previous Poon-Dryja commitment transactions, but HTLCs now sidestep the issue under discussion here.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T16:56:38",
                "message_text_only": "On 4/22/20 12:12 AM, ZmnSCPxj wrote:\n> Good morning Matt, and list,\n> \n> \n> \n>>     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n>>     =============================\n>>\n>>     You'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\n>>     our HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\n>>     lightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\n>>     if B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\n>>     After a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\n>>     HTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n> \n> My (cached) understanding is that, since RBF is signalled using `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> Adding that clause (2 bytes in witness if my math is correct) to the hashlock branch may be sufficient to prevent C from making an RBF-disabled transaction.\n\nHmm, indeed, though note that (IIRC) you can break this by adding children or parents which are *not* RBF-enabled and\nthen the package may lose the ability to be RBF'd.\n\n> But then you mention out-of-band agreements with miners, which basically means the transaction might not be in the mempool at all, in which case the vulnerability is not really about RBF or relay, but sheer economics.\n\nNo. The whole point of this attack is that you keep a transaction in the mempool but unconfirmed via RBF pinning, which\nprevents an *alternative* transaction from being confirmed. You then have plenty of time to go get it confirmed later.\n\n> The payment is A->B->C, and the HTLC A->B must have a larger timeout (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> The vulnerability you are describing means that the current time must now be L + 1 or greater (\"A could claim the HTLC from B via the timeout mechanism\", meaning the A->B HTLC has timed out already).\n> \n> If so, then the B->C transaction has already timed out in the past and can be claimed in two ways, either via B timeout branch or C hashlock branch.\n> This sets up a game where B and C bid to miners to get their version of reality committed onchain.\n> (We can neglect out-of-band agreements here; miners have the incentive to publicly leak such agreements so that other potential bidders can offer even higher fees for their versions of that transaction.)\n\nRight, I think I didn't explain clearly enough. The point is that, here, B tries to broadcast the timeout transaction\nbut cannot because there is an in-mempool conflict.\n\n> Before L+1, C has no incentive to bid, since placing any bid at all will leak the preimage, which B can then turn around and use to spend from A, and A and C cannot steal from B.\n> \n> Thus, B should ensure that *before* L+1, the HTLC-Timeout has been committed onchain, which outright prevents this bidding war from even starting.\n> \n> The issue then is that B is using a pre-signed HTLC-timeout, which is needed since it is its commitment tx that was broadcast.\n> This prevents B from RBF-ing the HTLC-Timeout transaction.\n> \n> So what is needed is to allow B to add fees to HTLC-Timeout:\n> \n> * We can add an RBF carve-out output to HTLC-Timeout, at the cost of more blockspace.\n> * With `SIGHASH_NOINPUT` we can make the C-side signature `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side signature for a higher-fee version of HTLC-Timeout (assuming my cached understanding of `SIGHASH_NOINPUT` still holds).\n\nThis does not solve the issue because you can add as many fees as you want, as long as the transaction is RBF-pinned,\nthere is not much you can do in an automated fashion.\n\n> With this, B can exponentially increase the fee as L+1 approaches.\n> If B can get HTLC-Timeout confirmed before L+1, then C cannot steal the HTLC value at all, since the UTXO it could steal from has already been spent.\n> \n> In particular, it does not seem to me that it is necessary to change the hashlock-branch transaction of C at all, since this mechanism is enough to sidestep the issue (as I understand it).\n> But it does point to a need to make HTLC-Timeout (and possibly symmetrically, HTLC-Success) also fee-bumpable.\n> \n> Note as well that this does not require a mempool: B can run in `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout is not confirmed, feebump HTLC-Timeout.\n> In particular, HTLC-Timeout comes into play only if B broadcast its own commitment transaction, and B *should* be aware that it did so --- there is still no need for mempool monitoring here.\n> \n> \n> Now, of course this only delays the war.\n> Let us now consider what C can do to ensure that the bidding war will happen eventually.\n> \n> * C can bribe a miner to prevent HTLC-Timeout from confirming between L and L+1.\n>   * Or in other words, this is a censorship attack.\n>     * The Bitcoin censorship-resistance model is that censored transactions can be fee-bumped, which attracts non-censoring miners to try their luck at mining and evict the censoring miner.\n>       * Thus, letting B bump the fee on HTLC-Timeout is precisely the mechanism we need.\n>       * This sets up a bidding war between C requesting miners to censor, vs. B requesting miners to confirm, but that only sets the stage for a second bidding war later between C and B, thus C is at a disadvantage: it has to bribe miners to censor continuously from L to L+1 *and* additional bribe miners to confirm its transaction after L+1, whereas B can offer its bribe as being something that miners can claim now without waiting after L+1.\n> \n> \n> \n> The issue of course is the additional output that bloats the UTXO set and requires another transaction to claim later.\n> And if we have `SIGHASH_NOINPUT`, it seems to me that Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out HTLC can be claimed with a fee-bumpable transaction directly without RBF-carve-out.\n> (As well, it seems to me that, if both nodes support doing so, a Poon-Dryja channel can be upgraded, without onchain activity, to a Decker-Russell-Osuntokun channel: sign a transaction spending the funding tx to a txo that has been set up as Decker-Russell-Osuntokun, do not broadcast that transaction, then revoke the latest Poon-Dryja commitment transactions, then switch the mechanism over to Decker-Russell-Osuntokun; you still need to monitor for previous Poon-Dryja commitment transactions, but HTLCs now sidestep the issue under discussion here.)\n> \n> Regards,\n> ZmnSCPxj\n>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-22T11:51:30",
                "message_text_only": "On Tue, Apr 21, 2020 at 09:13:34PM -0700, Olaoluwa Osuntokun wrote:\n> On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev wrote:\n> > While this is somewhat unintuitive, there are any number of good anti-DoS\n> > reasons for this, eg:\n> \n> None of these really strikes me as \"good\" reasons for this limitation\n> [...]\n> In the end, the simplest heuristic (accept the higher fee rate\n> package) side steps all these issues and is also the most economically\n> rationale from a miner's perspective. \n\nI think it's important to remember than mempool behavior affects not\njust miners but also relay nodes.  Miner costs, such as bandwidth usage,\ncan be directly offset by their earned block rewards, so miners can be\nmuch more tolerant of wasted bandwidth than relay nodes who receive no\ndirect financial compensation for the processing and relay of\nunconfirmed transactions.[1]\n\n> Why would one prefer a higher absolute fee package (which could be\n> very large) over another package with a higher total _fee rate_?\n\nTo avoid the excessive wasting of bandwidth.  Bitcoin Core's defaults\nrequire each replacement pay a feerate of 10 nBTC/vbyte over an existing\ntransaction or package, and the defaults also allow transactions or\npackages up to 100,000 vbytes in size (~400,000 bytes).  So, without\nenforcement of BIP125 rule 3, an attacker starting at the minimum\ndefault relay fee also of 10 nBTC/vbyte could do the following:\n\n- Create a ~400,000 bytes tx with feerate of 10 nBTC/vbyte (1 mBTC total\n  fee)\n\n- Replace that transaction with 400,000 new bytes at a feerate of 20\n  nBTC/vbyte (2 mBTC total fee)\n\n- Perform 998 additional replacements, each increasing the feerate by 10\n  nBTC/vbyte and the total fee by 1 mBTC, using a total of 400 megabytes\n  (including the original transaction and first replacement) to\n  ultimately produce a transaction with a feerate of 10,000 nBTC/vbyte\n  (1 BTC total fee)\n\n- Perform one final replacement of the latest 400,000 byte transaction\n  with a ~200-byte (~150 vbyte) 1-in, 1-out P2WPKH transaction that pays\n  a feerate of 10,010 nBTC/vbyte (1.5 mBTC total fee)\n\nAssuming 50,000 active relay nodes and today's BTC price of ~$7,000\nUSD/BTC, the above scenario would allow an attacker to waste a\ncollective 20 terabytes of network bandwidth for a total fee cost of\n$10.50.  And, of course, the attacker could run multiple attacks of this\nsort in parallel, quickly swamping the network.\n\nTo use the above concrete example to repeat the point made at the\nbeginning of this email: miners might be willing to accept the waste of\n400 MB of bandwidth in order to gain a $10.50 fee, but I think very few\nrelay nodes could function for long under an onslaught of such behavior.\n\n-Dave\n\n[1] The reward to relay nodes of maintaining the public relay network is\n    that it helps protect against miner centralization.  If there was no\n    public relay network, users would need to submit transactions\n    directly to miners or via a privately-controlled relay network.\n    Users desiring timely confirmation (and operators of private relay\n    networks) would have a large incentive to get transactions to the\n    largest miners but only a small incentive to get the transaction to\n    the smaller miners, increasing the economies of scale in mining and\n    furthering centralization.\n\n    Although users of Bitcoin benefit by reducing mining centralization\n    pressure, I don't think we can expect most users to be willing to\n    bear large costs in defense of benefits which are largely intangible\n    (until they're gone), so we must try to keep the cost of operating a\n    relay node within a reasonable margin of the cost of operating a\n    minimal-bandwidth blocks-only node.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/cbf63335/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-22T18:24:54",
                "message_text_only": "On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev wrote:\n> A lightning counterparty (C, who received the HTLC from B, who\n> received it from A) today could, if B broadcasts the commitment\n> transaction, spend an HTLC using the preimage with a low-fee,\n> RBF-disabled transaction.  After a few blocks, A could claim the HTLC\n> from B via the timeout mechanism, and then after a few days, C could\n> get the HTLC-claiming transaction mined via some out-of-band agreement\n> with a small miner. This leaves B short the HTLC value.\n\nIIUC, the main problem is honest Bob will broadcast a transaction\nwithout realizing it conflicts with a pinned transaction that's already\nin most node's mempools.  If Bob knew about the pinned transaction and\ncould get a copy of it, he'd be fine.\n\nIn that case, would it be worth re-implementing something like a BIP61\nreject message but with an extension that returns the txids of any\nconflicts?  For example, when Bob connects to a bunch of Bitcoin nodes\nand sends his conflicting transaction, the nodes would reply with\nsomething like \"rejected: code 123: conflicts with txid 0123...cdef\".\nBob could then reply with a a getdata('tx', '0123...cdef') to get the\npinned transaction, parse out its preimage, and resolve the HTLC.\n\nThis approach isn't perfect (if it even makes sense at all---I could be\nmisunderstanding the problem) because one of the problems that caused\nBIP61 to be disabled in Bitcoin Core was its unreliability, but I think\nif Bob had at least one honest peer that had the pinned transaction in\nits mempool and which implemented reject-with-conflicting-txid, Bob\nmight be ok.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/aa4c89f0/attachment.sig>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T22:53:37",
                "message_text_only": "\ufeffHmm, that's an interesting suggestion, it definitely raises the bar for attack execution rather significantly. Because lightning (and other second-layer systems) already relies heavily on uncensored access to blockchain data, its reasonable to extend the \"if you don't have enough blocks, aggressively query various sources to find new blocks, or, really just do it always\" solution to \"also send relevant transactions while we're at it\".\n\nSadly, unlike for block data, there is no consensus mechanism for nodes to ensure the transactions in their mempools are the same as others. Thus, if you focus on sending the pinning transaction to miner nodes directly (which isn't trivial, but also not nearly as hard as it sounds), you could still pull off the attack. However, to do it now, you'd need to\nwait for your counterparty to broadcast the corresponding timeout transaction (once it is confirmable, and can thus get into mempools), turning the whole thing into a mempool-acceptance race. Luckily there isn\u2019t much cost to *trying*, though it\u2019s less likely you\u2019ll succeed.\n\nThere are also practical design issues - if you\u2019re claiming multiple HTLC output in a single transaction the node would need to provide reject messages for each input which is conflicted, something which we\u2019d need to think hard about the DoS implications of.\n\nIn any case, while it\u2019s definitely better than nothing, it\u2019s unclear if it\u2019s really the kind of thing I\u2019d want to rely on for my own funds.\n\nMatt\n\n\n> On 4/22/20 2:24 PM, David A. Harding wrote:\n>> On Mon, Apr 20, 2020 at 10:43:14PM -0400, Matt Corallo via Lightning-dev wrote:\n>> A lightning counterparty (C, who received the HTLC from B, who\n>> received it from A) today could, if B broadcasts the commitment\n>> transaction, spend an HTLC using the preimage with a low-fee,\n>> RBF-disabled transaction.  After a few blocks, A could claim the HTLC\n>> from B via the timeout mechanism, and then after a few days, C could\n>> get the HTLC-claiming transaction mined via some out-of-band agreement\n>> with a small miner. This leaves B short the HTLC value.\n> \n> IIUC, the main problem is honest Bob will broadcast a transaction\n> without realizing it conflicts with a pinned transaction that's already\n> in most node's mempools.  If Bob knew about the pinned transaction and\n> could get a copy of it, he'd be fine.\n> \n> In that case, would it be worth re-implementing something like a BIP61\n> reject message but with an extension that returns the txids of any\n> conflicts?  For example, when Bob connects to a bunch of Bitcoin nodes\n> and sends his conflicting transaction, the nodes would reply with\n> something like \"rejected: code 123: conflicts with txid 0123...cdef\".\n> Bob could then reply with a a getdata('tx', '0123...cdef') to get the\n> pinned transaction, parse out its preimage, and resolve the HTLC.\n> \n> This approach isn't perfect (if it even makes sense at all---I could be\n> misunderstanding the problem) because one of the problems that caused\n> BIP61 to be disabled in Bitcoin Core was its unreliability, but I think\n> if Bob had at least one honest peer that had the pinned transaction in\n> its mempool and which implemented reject-with-conflicting-txid, Bob\n> might be ok.\n> \n> -Dave"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-23T09:59:57",
                "message_text_only": "On Wed, Apr 22, 2020 at 03:53:37PM -0700, Matt Corallo wrote:\n> if you focus on sending the pinning transaction to miner nodes\n> directly (which isn't trivial, but also not nearly as hard as it\n> sounds), you could still pull off the attack. \n\nIf the problem is that miners might have information not available to\nthe network in general, you could just bribe them for that knowledge.\nE.g. as Bob's refund deadline approaches and he begins to suspect that\nmempool shenanigans are preventing his refund transaction from\nconfirming, he takes a confirmed P2WPKH UTXO he's been saving for use in\nCPFP fee bumps and spends part of its value (say 1 mBTC) to the\nfollowing scriptPubKey[1],\n\n    OP_SHA256 <hash_whose_preimage_bob_wants> OP_EQUAL\n\nAssuming the feerate and the bribe amount are reasonable, any miner who\nknows the preimage is incentivized to include Bob's transaction and a\nchild transation spending from it in their next block.  That child\ntransaction will include the preimage, which Bob will see when he\nprocesses the block.\n\nIf any non-miner knows the preimage, they can also create that child\ntransaction.  The non-miner probably can't profit from this---miners can\njust rewrite the child transaction to pay themselves since there's no\nkey-based security---but the non-miner can at least pat themselves on\nthe back for being a good Summaritan.  Again Bob will learn the preimage\nonce the child transaction is included in a block, or earlier if his\nwallet is monitoring for relays of spends from his parent transaction.\n\nMoreover, Bob can first create a bribe via LN and, in that case, things\nare even better.  As Bob's deadline approaches, he uses one of his\nstill-working channels to send a bunch of max-length (20 hops?) probes\nthat reuse the earlier HTLC's <hash>.  If any hop along the path knows\nthe preimage, they can immediately claim the probe amount (and any\nrouting fees that were allocated to subsequent hops).  This not only\ngives smaller miners with LN nodes an equal chance of claiming the\nprobe-bribe as larger miners, but it also allows non-miners to profit\nfrom learning the preimage from miners.\n\nThat last part is useful because even if, as in your example, the\nadversary is able to send one version of the transaction just to miners\n(with the preimage) and another conflicting version to all relay nodes\n(without the preimage), miners will naturally attempt to relay the\npreimage version of the transaction to other users; if some of those\nusers run modified nodes that write all 32-byte witness data blobs to a\ndatabase---even if the transaction is ultimately rejected as a\nconflict---then targetted relay to miners may not be effective at\npreventing Bob from learning the preimage.\n\nObviously all of the above requires people run additional software to\nkeep track of potential preimages[2] and then compare them to hash\ncandidates, plus it requires additional complexity in LN clients, so I\ncan easily understand why it might be less desirable than the protocol\nchanges under discussion in other parts of this thread.  Still, with\nlots of effort already being put into watchtowers and other\nenforcement-assistance services, I wonder if this problem can be largely\naddressed in the same general way.\n\n-Dave\n\n[1] Requires a change to standard relay and mining policy.\n[2] Pretty easy, e.g.\n\n    bitcoin-cli getrawmempool \\\n    | jq -r .[] \\\n    | while read txid ; do\n      bitcoin-cli getrawtransaction $txid true | jq .vout[].scriptPubKey.asm\n    done \\\n    | grep -o '\\<[0-9a-f]\\{64\\}\\>'\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200423/9a20bfd7/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T12:52:57",
                "message_text_only": "Good morning David,\n\nUnfortunately this technique does not look like it is compatible to payment points rather than hashes, and we would really like to upgrade to payment points sooner rather than later.\nNobody but B can recognize the signature as revealing the scalar behind a particular point (the main privacy advantage of using points).\nEven variations on this are not useable with payment points.\n\nRegards,\nZmnSCPxj\n\n> On Wed, Apr 22, 2020 at 03:53:37PM -0700, Matt Corallo wrote:\n>\n> > if you focus on sending the pinning transaction to miner nodes\n> > directly (which isn't trivial, but also not nearly as hard as it\n> > sounds), you could still pull off the attack.\n>\n> If the problem is that miners might have information not available to\n> the network in general, you could just bribe them for that knowledge.\n> E.g. as Bob's refund deadline approaches and he begins to suspect that\n> mempool shenanigans are preventing his refund transaction from\n> confirming, he takes a confirmed P2WPKH UTXO he's been saving for use in\n> CPFP fee bumps and spends part of its value (say 1 mBTC) to the\n> following scriptPubKey[1],\n>\n> OP_SHA256 <hash_whose_preimage_bob_wants> OP_EQUAL\n>\n> Assuming the feerate and the bribe amount are reasonable, any miner who\n> knows the preimage is incentivized to include Bob's transaction and a\n> child transation spending from it in their next block. That child\n> transaction will include the preimage, which Bob will see when he\n> processes the block.\n>\n> If any non-miner knows the preimage, they can also create that child\n> transaction. The non-miner probably can't profit from this---miners can\n> just rewrite the child transaction to pay themselves since there's no\n> key-based security---but the non-miner can at least pat themselves on\n> the back for being a good Summaritan. Again Bob will learn the preimage\n> once the child transaction is included in a block, or earlier if his\n> wallet is monitoring for relays of spends from his parent transaction.\n>\n> Moreover, Bob can first create a bribe via LN and, in that case, things\n> are even better. As Bob's deadline approaches, he uses one of his\n> still-working channels to send a bunch of max-length (20 hops?) probes\n> that reuse the earlier HTLC's <hash>. If any hop along the path knows\n> the preimage, they can immediately claim the probe amount (and any\n> routing fees that were allocated to subsequent hops). This not only\n> gives smaller miners with LN nodes an equal chance of claiming the\n> probe-bribe as larger miners, but it also allows non-miners to profit\n> from learning the preimage from miners.\n>\n> That last part is useful because even if, as in your example, the\n> adversary is able to send one version of the transaction just to miners\n> (with the preimage) and another conflicting version to all relay nodes\n> (without the preimage), miners will naturally attempt to relay the\n> preimage version of the transaction to other users; if some of those\n> users run modified nodes that write all 32-byte witness data blobs to a\n> database---even if the transaction is ultimately rejected as a\n> conflict---then targetted relay to miners may not be effective at\n> preventing Bob from learning the preimage.\n>\n> Obviously all of the above requires people run additional software to\n> keep track of potential preimages[2] and then compare them to hash\n> candidates, plus it requires additional complexity in LN clients, so I\n> can easily understand why it might be less desirable than the protocol\n> changes under discussion in other parts of this thread. Still, with\n> lots of effort already being put into watchtowers and other\n> enforcement-assistance services, I wonder if this problem can be largely\n> addressed in the same general way.\n>\n> -Dave\n>\n> [1] Requires a change to standard relay and mining policy.\n> [2] Pretty easy, e.g.\n>\n> bitcoin-cli getrawmempool \\\n> | jq -r .[] \\\n> | while read txid ; do\n> bitcoin-cli getrawtransaction $txid true | jq .vout[].scriptPubKey.asm\n> done \\\n> | grep -o '\\<[0-9a-f]\\{64\\}\\>'\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "RBF Pinning with Counterparties and Competing Interest",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "David A. Harding",
                "Matt Corallo",
                "ZmnSCPxj"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 40920
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] RBF Pinning with Counterparties and Competing Interest",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T04:18:29",
                "message_text_only": "> So what is needed is to allow B to add fees to HTLC-Timeout:\n\nIndeed, anchors as defined in #lightning-rfc/688 allows this.\n\n>  * With `SIGHASH_NOINPUT` we can make the C-side signature\n>  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>  signature for a higher-fee version of HTLC-Timeout (assuming my cached\n>  understanding of `SIGHASH_NOINPUT` still holds).\n\nno_input isn't needed. With simply single+anyone can pay, then B can attach\na new input+output pair to increase the fees on their HTLC redemption\ntransaction. As you mention, they now enter into a race against this\nmalicious ndoe to bump up their fees in order to win over the other party.\n\nIf the malicious node uses a non-RBF signalled transaction to sweep their\nHTLC, then we enter into another level of race, but this time on the mempool\npropagation level. However, if there exists a relay path to a miner running\nfull RBF, then B's higher fee rate spend will win over.\n\n-- Laolu\n\nOn Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Matt, and list,\n>\n>\n>\n> >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds,\n> how, now?\")\n> >     =============================\n> >\n> >     You'll note that in the discussion of RBF pinning we were pretty\n> broad, and that that discussion seems to in fact cover\n> >     our HTLC outputs, at least when spent via (3) or (4). It does, and\n> in fact this is a pretty severe issue in today's\n> >     lightning protocol [2]. A lightning counterparty (C, who received\n> the HTLC from B, who received it from A) today could,\n> >     if B broadcasts the commitment transaction, spend an HTLC using the\n> preimage with a low-fee, RBF-disabled transaction.\n> >     After a few blocks, A could claim the HTLC from B via the timeout\n> mechanism, and then after a few days, C could get the\n> >     HTLC-claiming transaction mined via some out-of-band agreement with\n> a small miner. This leaves B short the HTLC value.\n>\n> My (cached) understanding is that, since RBF is signalled using\n> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> Adding that clause (2 bytes in witness if my math is correct) to the\n> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n> transaction.\n>\n> But then you mention out-of-band agreements with miners, which basically\n> means the transaction might not be in the mempool at all, in which case the\n> vulnerability is not really about RBF or relay, but sheer economics.\n>\n> The payment is A->B->C, and the HTLC A->B must have a larger timeout (L +\n> 1) than the HTLC B->C (L), in abstract non-block units.\n> The vulnerability you are describing means that the current time must now\n> be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n> mechanism\", meaning the A->B HTLC has timed out already).\n>\n> If so, then the B->C transaction has already timed out in the past and can\n> be claimed in two ways, either via B timeout branch or C hashlock branch.\n> This sets up a game where B and C bid to miners to get their version of\n> reality committed onchain.\n> (We can neglect out-of-band agreements here; miners have the incentive to\n> publicly leak such agreements so that other potential bidders can offer\n> even higher fees for their versions of that transaction.)\n>\n> Before L+1, C has no incentive to bid, since placing any bid at all will\n> leak the preimage, which B can then turn around and use to spend from A,\n> and A and C cannot steal from B.\n>\n> Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n> committed onchain, which outright prevents this bidding war from even\n> starting.\n>\n> The issue then is that B is using a pre-signed HTLC-timeout, which is\n> needed since it is its commitment tx that was broadcast.\n> This prevents B from RBF-ing the HTLC-Timeout transaction.\n>\n> So what is needed is to allow B to add fees to HTLC-Timeout:\n>\n> * We can add an RBF carve-out output to HTLC-Timeout, at the cost of more\n> blockspace.\n> * With `SIGHASH_NOINPUT` we can make the C-side signature\n> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> understanding of `SIGHASH_NOINPUT` still holds).\n>\n> With this, B can exponentially increase the fee as L+1 approaches.\n> If B can get HTLC-Timeout confirmed before L+1, then C cannot steal the\n> HTLC value at all, since the UTXO it could steal from has already been\n> spent.\n>\n> In particular, it does not seem to me that it is necessary to change the\n> hashlock-branch transaction of C at all, since this mechanism is enough to\n> sidestep the issue (as I understand it).\n> But it does point to a need to make HTLC-Timeout (and possibly\n> symmetrically, HTLC-Success) also fee-bumpable.\n>\n> Note as well that this does not require a mempool: B can run in\n> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n> is not confirmed, feebump HTLC-Timeout.\n> In particular, HTLC-Timeout comes into play only if B broadcast its own\n> commitment transaction, and B *should* be aware that it did so --- there is\n> still no need for mempool monitoring here.\n>\n>\n> Now, of course this only delays the war.\n> Let us now consider what C can do to ensure that the bidding war will\n> happen eventually.\n>\n> * C can bribe a miner to prevent HTLC-Timeout from confirming between L\n> and L+1.\n>   * Or in other words, this is a censorship attack.\n>     * The Bitcoin censorship-resistance model is that censored\n> transactions can be fee-bumped, which attracts non-censoring miners to try\n> their luck at mining and evict the censoring miner.\n>       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n> mechanism we need.\n>       * This sets up a bidding war between C requesting miners to censor,\n> vs. B requesting miners to confirm, but that only sets the stage for a\n> second bidding war later between C and B, thus C is at a disadvantage: it\n> has to bribe miners to censor continuously from L to L+1 *and* additional\n> bribe miners to confirm its transaction after L+1, whereas B can offer its\n> bribe as being something that miners can claim now without waiting after\n> L+1.\n>\n>\n>\n> The issue of course is the additional output that bloats the UTXO set and\n> requires another transaction to claim later.\n> And if we have `SIGHASH_NOINPUT`, it seems to me that\n> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n> HTLC can be claimed with a fee-bumpable transaction directly without\n> RBF-carve-out.\n> (As well, it seems to me that, if both nodes support doing so, a\n> Poon-Dryja channel can be upgraded, without onchain activity, to a\n> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n> you still need to monitor for previous Poon-Dryja commitment transactions,\n> but HTLCs now sidestep the issue under discussion here.)\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200421/fd98ca19/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-22T06:08:06",
                "message_text_only": "Good morning Laolu, Matt, and list,\n\n\n> > \u00a0* With `SIGHASH_NOINPUT` we can make the C-side signature\n> > \u00a0`SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> > \u00a0signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> > \u00a0understanding of `SIGHASH_NOINPUT` still holds).\n>\n> no_input isn't needed. With simply single+anyone can pay, then B can attach\n> a new input+output pair to increase the fees on their HTLC redemption\n> transaction. As you mention, they now enter into a race against this\n> malicious ndoe to bump up their fees in order to win over the other party.\n\nRight, right, that works as well.\n\n>\n> If the malicious node uses a non-RBF signalled transaction to sweep their\n> HTLC, then we enter into another level of race, but this time on the mempool\n> propagation level. However, if there exists a relay path to a miner running\n> full RBF, then B's higher fee rate spend will win over.\n\nHmm.\n\nSo basically:\n\n* B has no mempool, because it wants to reduce its costs and etc.\n* C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n* B does not notice this tx because:\n  1.  The tx is too low fee to be put in a block.\n  2.  B has no mempool so it cannot see the tx being propagated over the P2P network.\n* B tries to broadcast higher-fee HTLC-timeout, but fails because it cannot replace a non-RBF tx.\n* After L+1, C contacts the miners off-band and offers fee payment by other means.\n\nIt seems to me that, if my cached understanding that `<0> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty low-weight mitigation against this attack.\n\nSo I think the combination below gives us good size:\n\n* The HTLC-Timeout signature from C is flagged with `OP_SINGLE|OP_ANYONECANPAY`.\n  * Normally, the HTLC-Timeout still deducts the fee from the value of the UTXO being spent.\n  * However, if B notices that the L+1 timeout is approaching, it can fee-bump HTLC-Timeout with some onchain funds, recreating its own signature but reusing the (still valid) C signature.\n* The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`, preventing C from broadcasting a low-fee claim tx.\n\nThis has the advantages:\n\n* B does not need a mempool still and can run in `blocksonly`.\n* The normal path is still the same as current behavior, we \"only\" add a new path where if the L+1 timeout is approaching we fee-bump the HTLC-Timeout.\n* Costs are pretty low:\n  * No need for extra RBF carve-out txo.\n  * Just two additional witness bytes in the hashlock branch.\n* No mempool rule changes needed, can be done with the P2P network of today.\n  * Probably still resilient even with future changes in mempool rules, as long as typical RBF behaviors still remain.\n\nIs my understanding correct?\n\nRegards,\nZmnSCPxj\n\n>\n> -- Laolu\n>\n> On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Good morning Matt, and list,\n> >\n> > >\u00a0 \u00a0 \u00a0RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds, how, now?\")\n> > >\u00a0 \u00a0 \u00a0=============================\n> > >\n> > >\u00a0 \u00a0 \u00a0You'll note that in the discussion of RBF pinning we were pretty broad, and that that discussion seems to in fact cover\n> > >\u00a0 \u00a0 \u00a0our HTLC outputs, at least when spent via (3) or (4). It does, and in fact this is a pretty severe issue in today's\n> > >\u00a0 \u00a0 \u00a0lightning protocol [2]. A lightning counterparty (C, who received the HTLC from B, who received it from A) today could,\n> > >\u00a0 \u00a0 \u00a0if B broadcasts the commitment transaction, spend an HTLC using the preimage with a low-fee, RBF-disabled transaction.\n> > >\u00a0 \u00a0 \u00a0After a few blocks, A could claim the HTLC from B via the timeout mechanism, and then after a few days, C could get the\n> > >\u00a0 \u00a0 \u00a0HTLC-claiming transaction mined via some out-of-band agreement with a small miner. This leaves B short the HTLC value.\n> >\n> > My (cached) understanding is that, since RBF is signalled using `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> > Adding that clause (2 bytes in witness if my math is correct) to the hashlock branch may be sufficient to prevent C from making an RBF-disabled transaction.\n> >\n> > But then you mention out-of-band agreements with miners, which basically means the transaction might not be in the mempool at all, in which case the vulnerability is not really about RBF or relay, but sheer economics.\n> >\n> > The payment is A->B->C, and the HTLC A->B must have a larger timeout (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> > The vulnerability you are describing means that the current time must now be L + 1 or greater (\"A could claim the HTLC from B via the timeout mechanism\", meaning the A->B HTLC has timed out already).\n> >\n> > If so, then the B->C transaction has already timed out in the past and can be claimed in two ways, either via B timeout branch or C hashlock branch.\n> > This sets up a game where B and C bid to miners to get their version of reality committed onchain.\n> > (We can neglect out-of-band agreements here; miners have the incentive to publicly leak such agreements so that other potential bidders can offer even higher fees for their versions of that transaction.)\n> >\n> > Before L+1, C has no incentive to bid, since placing any bid at all will leak the preimage, which B can then turn around and use to spend from A, and A and C cannot steal from B.\n> >\n> > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been committed onchain, which outright prevents this bidding war from even starting.\n> >\n> > The issue then is that B is using a pre-signed HTLC-timeout, which is needed since it is its commitment tx that was broadcast.\n> > This prevents B from RBF-ing the HTLC-Timeout transaction.\n> >\n> > So what is needed is to allow B to add fees to HTLC-Timeout:\n> >\n> > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of more blockspace.\n> > * With `SIGHASH_NOINPUT` we can make the C-side signature `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side signature for a higher-fee version of HTLC-Timeout (assuming my cached understanding of `SIGHASH_NOINPUT` still holds).\n> >\n> > With this, B can exponentially increase the fee as L+1 approaches.\n> > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal the HTLC value at all, since the UTXO it could steal from has already been spent.\n> >\n> > In particular, it does not seem to me that it is necessary to change the hashlock-branch transaction of C at all, since this mechanism is enough to sidestep the issue (as I understand it).\n> > But it does point to a need to make HTLC-Timeout (and possibly symmetrically, HTLC-Success) also fee-bumpable.\n> >\n> > Note as well that this does not require a mempool: B can run in `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout is not confirmed, feebump HTLC-Timeout.\n> > In particular, HTLC-Timeout comes into play only if B broadcast its own commitment transaction, and B *should* be aware that it did so --- there is still no need for mempool monitoring here.\n> >\n> > Now, of course this only delays the war.\n> > Let us now consider what C can do to ensure that the bidding war will happen eventually.\n> >\n> > * C can bribe a miner to prevent HTLC-Timeout from confirming between L and L+1.\n> > \u00a0 * Or in other words, this is a censorship attack.\n> > \u00a0 \u00a0 * The Bitcoin censorship-resistance model is that censored transactions can be fee-bumped, which attracts non-censoring miners to try their luck at mining and evict the censoring miner.\n> > \u00a0 \u00a0 \u00a0 * Thus, letting B bump the fee on HTLC-Timeout is precisely the mechanism we need.\n> > \u00a0 \u00a0 \u00a0 * This sets up a bidding war between C requesting miners to censor, vs. B requesting miners to confirm, but that only sets the stage for a second bidding war later between C and B, thus C is at a disadvantage: it has to bribe miners to censor continuously from L to L+1 *and* additional bribe miners to confirm its transaction after L+1, whereas B can offer its bribe as being something that miners can claim now without waiting after L+1.\n> >\n> > The issue of course is the additional output that bloats the UTXO set and requires another transaction to claim later.\n> > And if we have `SIGHASH_NOINPUT`, it seems to me that Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out HTLC can be claimed with a fee-bumpable transaction directly without RBF-carve-out.\n> > (As well, it seems to me that, if both nodes support doing so, a Poon-Dryja channel can be upgraded, without onchain activity, to a Decker-Russell-Osuntokun channel: sign a transaction spending the funding tx to a txo that has been set up as Decker-Russell-Osuntokun, do not broadcast that transaction, then revoke the latest Poon-Dryja commitment transactions, then switch the mechanism over to Decker-Russell-Osuntokun; you still need to monitor for previous Poon-Dryja commitment transactions, but HTLCs now sidestep the issue under discussion here.)\n> >\n> > Regards,\n> > ZmnSCPxj\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-04-22T08:01:23",
                "message_text_only": "Personally, I would have wait a bit before to go public on this, like\nletting some implementations\nincreasing their CLTV deltas, but anyway, it's here now.\n\nMempool-pinning attacks were already discussed on this list [0], but what\nwe found is you\ncan _reverse_ the scenario, where it's not the malicious party delaying\nconfirmation of honest\nparty transactions but malicious deliberately stucking its own transactions\nin the mempool to avoid\nconfirmation of timeout. And therefore gaming inter-link timelock to\nprovoke an unbalanced\nsettlement for the victim (\"aka you pay forward, but don't get pay\nbackward\").\n\nHow much attacks are practical is based on how you can leverage mempool\nrules to pin your own\ntransaction. What you're looking for is a  _mempool-obstruction_ trick, i.e\na way to get honest party\ntransaction being bounce off due to your transaction being already there.\n\nBeyond disabling RBF on your transaction (with current protocol, not anchor\nproposal), there is\ntwo likely candidates:\n* BIP 125 rule 3: \"The replacement transaction pays an absolute fee of at\nleast the sum paid by the original transactions.\"\n* BIP 125 rule 5: \"The number of original transactions to be replaced and\ntheir descendant transactions which will be evicted from the mempool must\nnot exceed a total of 100 transactions.\"\n\nLet's go through whole scenario:\n* Mallory and Eve are colluding\n* Eve and Mallory are opening channels with Alice, Mallory do a bit of\nrebalancing\nto get full incoming capacity, like receiving funds on an onchain address\nthrough another Alice\nlink\n* Eve send a HTLC #1 to Mallory through Alice expirying at block 100\n* Eve send a second HTLC #2 to Mallory through Alice, expirying at block\n110 on outgoing link\n(A<->M), 120 on incoming link (E<->A)\n* Before block 100, without cancellation from Mallory, Alice will\nforce-close channel and broadcast\nher local commitment and HTLC-timeout to get back HTLC #1\n* Alice can't broadcast HTLC-timeout for HTLC #2 as it's only expires at 110\n* Mallory can broadcast its Pinning Preimage Tx on offered HTLC #2 output\non Alice's transaction,\nfeerate is maliciously chosen to get in network mempools but never to\nconfirm. Absolute fee must\nbe higher than HTLC-timeout #2, a fact known to Mallory. There is no p2p\nrace.\n* As Alice doesn't watch the mempool, she is never going to learn the\npreimage to redeeem incoming\nHTLC #2\n* At block 110, Alice is going to broadcast HTLC-timeout #2, feerate may be\nhigher but as absolute\nfee is lower, it's going to be rejected from network mempools as\nreplacement for Pinning Preimage\nTx (BIP 125 rule 3)\n* At block 120, Eve closes channel and HTLC-timeout HTLC #2\n* Mallory can RBF its Pinning Preimage Tx by a high-feerate one and get it\nconfirmed\n\nNew anchor_output proposal, by disabling RBF, forces attacker to bid on the\nabsolute fee. It may\nbe now a risk to loose the fee if Pinning Tx is confirming. You may extend\nyour \"pinning\nlease\" by ejecting your malicious tx, like conflicting or trimming out of\nthe mempool one of its\nparents. And then reannounce your preimage tx with a\nlower-feerate-but-still-high-fee before a\nnew block and a honest HTLC-timeout rebroadcast.\n\nAFAICT, even with anchor_output deployed, even assuming empty mempools,\nsuccess rate and economic\nrationality of attacks is finding such cheap, reliable \"pinning lease\nextension\" trick.\n\nI think any mempool watching mitigation is at best a cat-and-mouse hack.\nContrary to node\nadvancing towards a global blockchain view thanks to PoW, network mempools\ndon't have a convergence\nguarantee. This means,  in a distributed system like bitcoin, node don't\nsee events in the same\norder, Alice may observe tx X, tx Y, tx Z and Bob may observe tx Z, tx X,\ntx Y. And order of events\naffects if a future event is going to be rejected or not, like if tx Z\ndisable-RBF and tx X try to\nreplace Z, Alice accepts X and Bob rejects it. And this divergence may\nperserve until a new block.\n\nPractically, it means an attacker can provoke a local conflict to bounce\noff HTLC preimage tx out\nof your mempool while broadcasting preimage tx without conflict to the rest\nof the network by\ntweaking tx-relay protocol and so easily manipulating order of events for\nevery node. A local\nconflict is easy to provoke, just make tx A double-spent by both\nHTLC-preimage-tx and non-RBF-tx-B.\nAnnounce txA+txB to mempool victim and txA+HTLC-preimage-tx to rest of\nnetwork. When rest of\nnetwork announce HTLC-preimage-tx, it's going to rejected by your mempool.\n\nProvoking local conflict assumes of course _interlayer_ mapping by an\nattacker, i.e mapping your LN\nnode to your full-node(s). Last time, we check, there was 982 match by IP\nfor 4,500 LN/52,000\nfull-node. Mapping heuristics is an ongoing research subject and sadly\nseems affordable.\n\nYes a) you can enable full-RBF on your local node but blinding conflicting\nmay still be with higher\nfeerate as everything is attacker malleable b) you may want to catch tx and\nextract preimage\non the p2p wire, but processing raw transaction would be such a DoS\nvector...\n\nOverall, I think we all agree on the long term direction to get a\nContracting-Protocols-Enhanced\nmempool with a multiparty-safe-API, bundled with package relay deployment.\nEven if there is current\nmove toward this direction, this may take longer than expected as with any\ncritical-safety\ncomponent in Core.\n\nA temporary fix could be to resuscitate old work to ensure peering through\na full-RBF propagation path,\nbut p2p implications are hard to gauge, like wouldn't guarantee p2p\ncensorship resistance of this...\n\nIt's quite a tangled issue, with a good deal of both bitcoin and lightning\nknowledge so feel free\nto verify and double-check more than usual\n\nCheers\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html\n\nLe mer. 22 avr. 2020 \u00e0 02:08, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning Laolu, Matt, and list,\n>\n>\n> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> > >  signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> > >  understanding of `SIGHASH_NOINPUT` still holds).\n> >\n> > no_input isn't needed. With simply single+anyone can pay, then B can\n> attach\n> > a new input+output pair to increase the fees on their HTLC redemption\n> > transaction. As you mention, they now enter into a race against this\n> > malicious ndoe to bump up their fees in order to win over the other\n> party.\n>\n> Right, right, that works as well.\n>\n> >\n> > If the malicious node uses a non-RBF signalled transaction to sweep their\n> > HTLC, then we enter into another level of race, but this time on the\n> mempool\n> > propagation level. However, if there exists a relay path to a miner\n> running\n> > full RBF, then B's higher fee rate spend will win over.\n>\n> Hmm.\n>\n> So basically:\n>\n> * B has no mempool, because it wants to reduce its costs and etc.\n> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n> * B does not notice this tx because:\n>   1.  The tx is too low fee to be put in a block.\n>   2.  B has no mempool so it cannot see the tx being propagated over the\n> P2P network.\n> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n> cannot replace a non-RBF tx.\n> * After L+1, C contacts the miners off-band and offers fee payment by\n> other means.\n>\n> It seems to me that, if my cached understanding that `<0>\n> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n> low-weight mitigation against this attack.\n>\n> So I think the combination below gives us good size:\n>\n> * The HTLC-Timeout signature from C is flagged with\n> `OP_SINGLE|OP_ANYONECANPAY`.\n>   * Normally, the HTLC-Timeout still deducts the fee from the value of the\n> UTXO being spent.\n>   * However, if B notices that the L+1 timeout is approaching, it can\n> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n> but reusing the (still valid) C signature.\n> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n> preventing C from broadcasting a low-fee claim tx.\n>\n> This has the advantages:\n>\n> * B does not need a mempool still and can run in `blocksonly`.\n> * The normal path is still the same as current behavior, we \"only\" add a\n> new path where if the L+1 timeout is approaching we fee-bump the\n> HTLC-Timeout.\n> * Costs are pretty low:\n>   * No need for extra RBF carve-out txo.\n>   * Just two additional witness bytes in the hashlock branch.\n> * No mempool rule changes needed, can be done with the P2P network of\n> today.\n>   * Probably still resilient even with future changes in mempool rules, as\n> long as typical RBF behaviors still remain.\n>\n> Is my understanding correct?\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > -- Laolu\n> >\n> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good morning Matt, and list,\n> > >\n> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds,\n> how, now?\")\n> > > >     =============================\n> > > >\n> > > >     You'll note that in the discussion of RBF pinning we were pretty\n> broad, and that that discussion seems to in fact cover\n> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n> and in fact this is a pretty severe issue in today's\n> > > >     lightning protocol [2]. A lightning counterparty (C, who\n> received the HTLC from B, who received it from A) today could,\n> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n> the preimage with a low-fee, RBF-disabled transaction.\n> > > >     After a few blocks, A could claim the HTLC from B via the\n> timeout mechanism, and then after a few days, C could get the\n> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n> with a small miner. This leaves B short the HTLC value.\n> > >\n> > > My (cached) understanding is that, since RBF is signalled using\n> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> > > Adding that clause (2 bytes in witness if my math is correct) to the\n> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n> transaction.\n> > >\n> > > But then you mention out-of-band agreements with miners, which\n> basically means the transaction might not be in the mempool at all, in\n> which case the vulnerability is not really about RBF or relay, but sheer\n> economics.\n> > >\n> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> > > The vulnerability you are describing means that the current time must\n> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n> mechanism\", meaning the A->B HTLC has timed out already).\n> > >\n> > > If so, then the B->C transaction has already timed out in the past and\n> can be claimed in two ways, either via B timeout branch or C hashlock\n> branch.\n> > > This sets up a game where B and C bid to miners to get their version\n> of reality committed onchain.\n> > > (We can neglect out-of-band agreements here; miners have the incentive\n> to publicly leak such agreements so that other potential bidders can offer\n> even higher fees for their versions of that transaction.)\n> > >\n> > > Before L+1, C has no incentive to bid, since placing any bid at all\n> will leak the preimage, which B can then turn around and use to spend from\n> A, and A and C cannot steal from B.\n> > >\n> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n> committed onchain, which outright prevents this bidding war from even\n> starting.\n> > >\n> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n> needed since it is its commitment tx that was broadcast.\n> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n> > >\n> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n> > >\n> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n> more blockspace.\n> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> understanding of `SIGHASH_NOINPUT` still holds).\n> > >\n> > > With this, B can exponentially increase the fee as L+1 approaches.\n> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n> the HTLC value at all, since the UTXO it could steal from has already been\n> spent.\n> > >\n> > > In particular, it does not seem to me that it is necessary to change\n> the hashlock-branch transaction of C at all, since this mechanism is enough\n> to sidestep the issue (as I understand it).\n> > > But it does point to a need to make HTLC-Timeout (and possibly\n> symmetrically, HTLC-Success) also fee-bumpable.\n> > >\n> > > Note as well that this does not require a mempool: B can run in\n> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n> is not confirmed, feebump HTLC-Timeout.\n> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n> own commitment transaction, and B *should* be aware that it did so ---\n> there is still no need for mempool monitoring here.\n> > >\n> > > Now, of course this only delays the war.\n> > > Let us now consider what C can do to ensure that the bidding war will\n> happen eventually.\n> > >\n> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n> L and L+1.\n> > >   * Or in other words, this is a censorship attack.\n> > >     * The Bitcoin censorship-resistance model is that censored\n> transactions can be fee-bumped, which attracts non-censoring miners to try\n> their luck at mining and evict the censoring miner.\n> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n> mechanism we need.\n> > >       * This sets up a bidding war between C requesting miners to\n> censor, vs. B requesting miners to confirm, but that only sets the stage\n> for a second bidding war later between C and B, thus C is at a\n> disadvantage: it has to bribe miners to censor continuously from L to L+1\n> *and* additional bribe miners to confirm its transaction after L+1, whereas\n> B can offer its bribe as being something that miners can claim now without\n> waiting after L+1.\n> > >\n> > > The issue of course is the additional output that bloats the UTXO set\n> and requires another transaction to claim later.\n> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n> HTLC can be claimed with a fee-bumpable transaction directly without\n> RBF-carve-out.\n> > > (As well, it seems to me that, if both nodes support doing so, a\n> Poon-Dryja channel can be upgraded, without onchain activity, to a\n> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n> you still need to monitor for previous Poon-Dryja commitment transactions,\n> but HTLCs now sidestep the issue under discussion here.)\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/951291f7/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-04-22T08:55:42",
                "message_text_only": "Hi Antoine and list,\n\nThanks for raising this. There's one step I'd like to understand further:\n\n* Mallory can broadcast its Pinning Preimage Tx on offered HTLC #2 output\n> on Alice's transaction,\n> feerate is maliciously chosen to get in network mempools but never to\n> confirm. Absolute fee must\n> be higher than HTLC-timeout #2, a fact known to Mallory. There is no p2p\n> race.\n>\n\nCan you detail how the \"absolute fee\" is computed here?\nDoesn't that mean that if this had a higher fee than the htlc-timeout, and\nthe htlc-timeout fee was\nchosen to confirm quickly (that's why we have an annoying `update_fee`),\nthe htlc-success will confirm\nquickly (which makes the problem disappear)?\nBecause once the commit tx is confirmed, the \"package\" consists of only the\nhtlc-success, doesn't it?\n\nI think the devil will be in the details here, so it's worth expanding on\nthe fee calculation imho.\n\nThanks!\nBastien\n\nLe mer. 22 avr. 2020 \u00e0 10:01, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Personally, I would have wait a bit before to go public on this, like\n> letting some implementations\n> increasing their CLTV deltas, but anyway, it's here now.\n>\n> Mempool-pinning attacks were already discussed on this list [0], but what\n> we found is you\n> can _reverse_ the scenario, where it's not the malicious party delaying\n> confirmation of honest\n> party transactions but malicious deliberately stucking its own\n> transactions in the mempool to avoid\n> confirmation of timeout. And therefore gaming inter-link timelock to\n> provoke an unbalanced\n> settlement for the victim (\"aka you pay forward, but don't get pay\n> backward\").\n>\n> How much attacks are practical is based on how you can leverage mempool\n> rules to pin your own\n> transaction. What you're looking for is a  _mempool-obstruction_ trick,\n> i.e a way to get honest party\n> transaction being bounce off due to your transaction being already there.\n>\n> Beyond disabling RBF on your transaction (with current protocol, not\n> anchor proposal), there is\n> two likely candidates:\n> * BIP 125 rule 3: \"The replacement transaction pays an absolute fee of at\n> least the sum paid by the original transactions.\"\n> * BIP 125 rule 5: \"The number of original transactions to be replaced and\n> their descendant transactions which will be evicted from the mempool must\n> not exceed a total of 100 transactions.\"\n>\n> Let's go through whole scenario:\n> * Mallory and Eve are colluding\n> * Eve and Mallory are opening channels with Alice, Mallory do a bit of\n> rebalancing\n> to get full incoming capacity, like receiving funds on an onchain address\n> through another Alice\n> link\n> * Eve send a HTLC #1 to Mallory through Alice expirying at block 100\n> * Eve send a second HTLC #2 to Mallory through Alice, expirying at block\n> 110 on outgoing link\n> (A<->M), 120 on incoming link (E<->A)\n> * Before block 100, without cancellation from Mallory, Alice will\n> force-close channel and broadcast\n> her local commitment and HTLC-timeout to get back HTLC #1\n> * Alice can't broadcast HTLC-timeout for HTLC #2 as it's only expires at\n> 110\n> * Mallory can broadcast its Pinning Preimage Tx on offered HTLC #2 output\n> on Alice's transaction,\n> feerate is maliciously chosen to get in network mempools but never to\n> confirm. Absolute fee must\n> be higher than HTLC-timeout #2, a fact known to Mallory. There is no p2p\n> race.\n> * As Alice doesn't watch the mempool, she is never going to learn the\n> preimage to redeeem incoming\n> HTLC #2\n> * At block 110, Alice is going to broadcast HTLC-timeout #2, feerate may\n> be higher but as absolute\n> fee is lower, it's going to be rejected from network mempools as\n> replacement for Pinning Preimage\n> Tx (BIP 125 rule 3)\n> * At block 120, Eve closes channel and HTLC-timeout HTLC #2\n> * Mallory can RBF its Pinning Preimage Tx by a high-feerate one and get it\n> confirmed\n>\n> New anchor_output proposal, by disabling RBF, forces attacker to bid on\n> the absolute fee. It may\n> be now a risk to loose the fee if Pinning Tx is confirming. You may extend\n> your \"pinning\n> lease\" by ejecting your malicious tx, like conflicting or trimming out of\n> the mempool one of its\n> parents. And then reannounce your preimage tx with a\n> lower-feerate-but-still-high-fee before a\n> new block and a honest HTLC-timeout rebroadcast.\n>\n> AFAICT, even with anchor_output deployed, even assuming empty mempools,\n> success rate and economic\n> rationality of attacks is finding such cheap, reliable \"pinning lease\n> extension\" trick.\n>\n> I think any mempool watching mitigation is at best a cat-and-mouse hack.\n> Contrary to node\n> advancing towards a global blockchain view thanks to PoW, network mempools\n> don't have a convergence\n> guarantee. This means,  in a distributed system like bitcoin, node don't\n> see events in the same\n> order, Alice may observe tx X, tx Y, tx Z and Bob may observe tx Z, tx X,\n> tx Y. And order of events\n> affects if a future event is going to be rejected or not, like if tx Z\n> disable-RBF and tx X try to\n> replace Z, Alice accepts X and Bob rejects it. And this divergence may\n> perserve until a new block.\n>\n> Practically, it means an attacker can provoke a local conflict to bounce\n> off HTLC preimage tx out\n> of your mempool while broadcasting preimage tx without conflict to the\n> rest of the network by\n> tweaking tx-relay protocol and so easily manipulating order of events for\n> every node. A local\n> conflict is easy to provoke, just make tx A double-spent by both\n> HTLC-preimage-tx and non-RBF-tx-B.\n> Announce txA+txB to mempool victim and txA+HTLC-preimage-tx to rest of\n> network. When rest of\n> network announce HTLC-preimage-tx, it's going to rejected by your mempool.\n>\n> Provoking local conflict assumes of course _interlayer_ mapping by an\n> attacker, i.e mapping your LN\n> node to your full-node(s). Last time, we check, there was 982 match by IP\n> for 4,500 LN/52,000\n> full-node. Mapping heuristics is an ongoing research subject and sadly\n> seems affordable.\n>\n> Yes a) you can enable full-RBF on your local node but blinding conflicting\n> may still be with higher\n> feerate as everything is attacker malleable b) you may want to catch tx\n> and extract preimage\n> on the p2p wire, but processing raw transaction would be such a DoS\n> vector...\n>\n> Overall, I think we all agree on the long term direction to get a\n> Contracting-Protocols-Enhanced\n> mempool with a multiparty-safe-API, bundled with package relay deployment.\n> Even if there is current\n> move toward this direction, this may take longer than expected as with any\n> critical-safety\n> component in Core.\n>\n> A temporary fix could be to resuscitate old work to ensure peering through\n> a full-RBF propagation path,\n> but p2p implications are hard to gauge, like wouldn't guarantee p2p\n> censorship resistance of this...\n>\n> It's quite a tangled issue, with a good deal of both bitcoin and lightning\n> knowledge so feel free\n> to verify and double-check more than usual\n>\n> Cheers\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html\n>\n> Le mer. 22 avr. 2020 \u00e0 02:08, ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Good morning Laolu, Matt, and list,\n>>\n>>\n>> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> > >  signature for a higher-fee version of HTLC-Timeout (assuming my\n>> cached\n>> > >  understanding of `SIGHASH_NOINPUT` still holds).\n>> >\n>> > no_input isn't needed. With simply single+anyone can pay, then B can\n>> attach\n>> > a new input+output pair to increase the fees on their HTLC redemption\n>> > transaction. As you mention, they now enter into a race against this\n>> > malicious ndoe to bump up their fees in order to win over the other\n>> party.\n>>\n>> Right, right, that works as well.\n>>\n>> >\n>> > If the malicious node uses a non-RBF signalled transaction to sweep\n>> their\n>> > HTLC, then we enter into another level of race, but this time on the\n>> mempool\n>> > propagation level. However, if there exists a relay path to a miner\n>> running\n>> > full RBF, then B's higher fee rate spend will win over.\n>>\n>> Hmm.\n>>\n>> So basically:\n>>\n>> * B has no mempool, because it wants to reduce its costs and etc.\n>> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n>> * B does not notice this tx because:\n>>   1.  The tx is too low fee to be put in a block.\n>>   2.  B has no mempool so it cannot see the tx being propagated over the\n>> P2P network.\n>> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n>> cannot replace a non-RBF tx.\n>> * After L+1, C contacts the miners off-band and offers fee payment by\n>> other means.\n>>\n>> It seems to me that, if my cached understanding that `<0>\n>> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n>> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n>> low-weight mitigation against this attack.\n>>\n>> So I think the combination below gives us good size:\n>>\n>> * The HTLC-Timeout signature from C is flagged with\n>> `OP_SINGLE|OP_ANYONECANPAY`.\n>>   * Normally, the HTLC-Timeout still deducts the fee from the value of\n>> the UTXO being spent.\n>>   * However, if B notices that the L+1 timeout is approaching, it can\n>> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n>> but reusing the (still valid) C signature.\n>> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n>> preventing C from broadcasting a low-fee claim tx.\n>>\n>> This has the advantages:\n>>\n>> * B does not need a mempool still and can run in `blocksonly`.\n>> * The normal path is still the same as current behavior, we \"only\" add a\n>> new path where if the L+1 timeout is approaching we fee-bump the\n>> HTLC-Timeout.\n>> * Costs are pretty low:\n>>   * No need for extra RBF carve-out txo.\n>>   * Just two additional witness bytes in the hashlock branch.\n>> * No mempool rule changes needed, can be done with the P2P network of\n>> today.\n>>   * Probably still resilient even with future changes in mempool rules,\n>> as long as typical RBF behaviors still remain.\n>>\n>> Is my understanding correct?\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> >\n>> > -- Laolu\n>> >\n>> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> > > Good morning Matt, and list,\n>> > >\n>> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal\n>> funds, how, now?\")\n>> > > >     =============================\n>> > > >\n>> > > >     You'll note that in the discussion of RBF pinning we were\n>> pretty broad, and that that discussion seems to in fact cover\n>> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n>> and in fact this is a pretty severe issue in today's\n>> > > >     lightning protocol [2]. A lightning counterparty (C, who\n>> received the HTLC from B, who received it from A) today could,\n>> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n>> the preimage with a low-fee, RBF-disabled transaction.\n>> > > >     After a few blocks, A could claim the HTLC from B via the\n>> timeout mechanism, and then after a few days, C could get the\n>> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n>> with a small miner. This leaves B short the HTLC value.\n>> > >\n>> > > My (cached) understanding is that, since RBF is signalled using\n>> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n>> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n>> > > Adding that clause (2 bytes in witness if my math is correct) to the\n>> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n>> transaction.\n>> > >\n>> > > But then you mention out-of-band agreements with miners, which\n>> basically means the transaction might not be in the mempool at all, in\n>> which case the vulnerability is not really about RBF or relay, but sheer\n>> economics.\n>> > >\n>> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n>> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n>> > > The vulnerability you are describing means that the current time must\n>> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n>> mechanism\", meaning the A->B HTLC has timed out already).\n>> > >\n>> > > If so, then the B->C transaction has already timed out in the past\n>> and can be claimed in two ways, either via B timeout branch or C hashlock\n>> branch.\n>> > > This sets up a game where B and C bid to miners to get their version\n>> of reality committed onchain.\n>> > > (We can neglect out-of-band agreements here; miners have the\n>> incentive to publicly leak such agreements so that other potential bidders\n>> can offer even higher fees for their versions of that transaction.)\n>> > >\n>> > > Before L+1, C has no incentive to bid, since placing any bid at all\n>> will leak the preimage, which B can then turn around and use to spend from\n>> A, and A and C cannot steal from B.\n>> > >\n>> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n>> committed onchain, which outright prevents this bidding war from even\n>> starting.\n>> > >\n>> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n>> needed since it is its commitment tx that was broadcast.\n>> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n>> > >\n>> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n>> > >\n>> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n>> more blockspace.\n>> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n>> understanding of `SIGHASH_NOINPUT` still holds).\n>> > >\n>> > > With this, B can exponentially increase the fee as L+1 approaches.\n>> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n>> the HTLC value at all, since the UTXO it could steal from has already been\n>> spent.\n>> > >\n>> > > In particular, it does not seem to me that it is necessary to change\n>> the hashlock-branch transaction of C at all, since this mechanism is enough\n>> to sidestep the issue (as I understand it).\n>> > > But it does point to a need to make HTLC-Timeout (and possibly\n>> symmetrically, HTLC-Success) also fee-bumpable.\n>> > >\n>> > > Note as well that this does not require a mempool: B can run in\n>> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n>> is not confirmed, feebump HTLC-Timeout.\n>> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n>> own commitment transaction, and B *should* be aware that it did so ---\n>> there is still no need for mempool monitoring here.\n>> > >\n>> > > Now, of course this only delays the war.\n>> > > Let us now consider what C can do to ensure that the bidding war will\n>> happen eventually.\n>> > >\n>> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n>> L and L+1.\n>> > >   * Or in other words, this is a censorship attack.\n>> > >     * The Bitcoin censorship-resistance model is that censored\n>> transactions can be fee-bumped, which attracts non-censoring miners to try\n>> their luck at mining and evict the censoring miner.\n>> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n>> mechanism we need.\n>> > >       * This sets up a bidding war between C requesting miners to\n>> censor, vs. B requesting miners to confirm, but that only sets the stage\n>> for a second bidding war later between C and B, thus C is at a\n>> disadvantage: it has to bribe miners to censor continuously from L to L+1\n>> *and* additional bribe miners to confirm its transaction after L+1, whereas\n>> B can offer its bribe as being something that miners can claim now without\n>> waiting after L+1.\n>> > >\n>> > > The issue of course is the additional output that bloats the UTXO set\n>> and requires another transaction to claim later.\n>> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n>> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n>> HTLC can be claimed with a fee-bumpable transaction directly without\n>> RBF-carve-out.\n>> > > (As well, it seems to me that, if both nodes support doing so, a\n>> Poon-Dryja channel can be upgraded, without onchain activity, to a\n>> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n>> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n>> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n>> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n>> you still need to monitor for previous Poon-Dryja commitment transactions,\n>> but HTLCs now sidestep the issue under discussion here.)\n>> > >\n>> > > Regards,\n>> > > ZmnSCPxj\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/cdacdb19/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:05:17",
                "message_text_only": "Hi Z,\n\n> It seems to me that, if my cached understanding that `<0>\n> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a\npretty\n> low-weight mitigation against this attack.\n\nI think this works...so they're forced to spend the output with a non-final\nsequence number, meaning it *must* signal RBF. In this case, now it's the\ntimeout-er vs the success-er racing based on fee rate. If the honest party\n(the\none trying to time out the HTLC) bids a fee rate higher (need to also\naccount\nfor the whole absolute fee replacement thing), then things should generally\nwork out in their favor.\n\n-- Laolu\n\n\nOn Tue, Apr 21, 2020 at 11:08 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Laolu, Matt, and list,\n>\n>\n> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> > >  signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> > >  understanding of `SIGHASH_NOINPUT` still holds).\n> >\n> > no_input isn't needed. With simply single+anyone can pay, then B can\n> attach\n> > a new input+output pair to increase the fees on their HTLC redemption\n> > transaction. As you mention, they now enter into a race against this\n> > malicious ndoe to bump up their fees in order to win over the other\n> party.\n>\n> Right, right, that works as well.\n>\n> >\n> > If the malicious node uses a non-RBF signalled transaction to sweep their\n> > HTLC, then we enter into another level of race, but this time on the\n> mempool\n> > propagation level. However, if there exists a relay path to a miner\n> running\n> > full RBF, then B's higher fee rate spend will win over.\n>\n> Hmm.\n>\n> So basically:\n>\n> * B has no mempool, because it wants to reduce its costs and etc.\n> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n> * B does not notice this tx because:\n>   1.  The tx is too low fee to be put in a block.\n>   2.  B has no mempool so it cannot see the tx being propagated over the\n> P2P network.\n> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n> cannot replace a non-RBF tx.\n> * After L+1, C contacts the miners off-band and offers fee payment by\n> other means.\n>\n> It seems to me that, if my cached understanding that `<0>\n> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n> low-weight mitigation against this attack.\n>\n> So I think the combination below gives us good size:\n>\n> * The HTLC-Timeout signature from C is flagged with\n> `OP_SINGLE|OP_ANYONECANPAY`.\n>   * Normally, the HTLC-Timeout still deducts the fee from the value of the\n> UTXO being spent.\n>   * However, if B notices that the L+1 timeout is approaching, it can\n> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n> but reusing the (still valid) C signature.\n> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n> preventing C from broadcasting a low-fee claim tx.\n>\n> This has the advantages:\n>\n> * B does not need a mempool still and can run in `blocksonly`.\n> * The normal path is still the same as current behavior, we \"only\" add a\n> new path where if the L+1 timeout is approaching we fee-bump the\n> HTLC-Timeout.\n> * Costs are pretty low:\n>   * No need for extra RBF carve-out txo.\n>   * Just two additional witness bytes in the hashlock branch.\n> * No mempool rule changes needed, can be done with the P2P network of\n> today.\n>   * Probably still resilient even with future changes in mempool rules, as\n> long as typical RBF behaviors still remain.\n>\n> Is my understanding correct?\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > -- Laolu\n> >\n> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good morning Matt, and list,\n> > >\n> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal funds,\n> how, now?\")\n> > > >     =============================\n> > > >\n> > > >     You'll note that in the discussion of RBF pinning we were pretty\n> broad, and that that discussion seems to in fact cover\n> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n> and in fact this is a pretty severe issue in today's\n> > > >     lightning protocol [2]. A lightning counterparty (C, who\n> received the HTLC from B, who received it from A) today could,\n> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n> the preimage with a low-fee, RBF-disabled transaction.\n> > > >     After a few blocks, A could claim the HTLC from B via the\n> timeout mechanism, and then after a few days, C could get the\n> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n> with a small miner. This leaves B short the HTLC value.\n> > >\n> > > My (cached) understanding is that, since RBF is signalled using\n> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n> > > Adding that clause (2 bytes in witness if my math is correct) to the\n> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n> transaction.\n> > >\n> > > But then you mention out-of-band agreements with miners, which\n> basically means the transaction might not be in the mempool at all, in\n> which case the vulnerability is not really about RBF or relay, but sheer\n> economics.\n> > >\n> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n> > > The vulnerability you are describing means that the current time must\n> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n> mechanism\", meaning the A->B HTLC has timed out already).\n> > >\n> > > If so, then the B->C transaction has already timed out in the past and\n> can be claimed in two ways, either via B timeout branch or C hashlock\n> branch.\n> > > This sets up a game where B and C bid to miners to get their version\n> of reality committed onchain.\n> > > (We can neglect out-of-band agreements here; miners have the incentive\n> to publicly leak such agreements so that other potential bidders can offer\n> even higher fees for their versions of that transaction.)\n> > >\n> > > Before L+1, C has no incentive to bid, since placing any bid at all\n> will leak the preimage, which B can then turn around and use to spend from\n> A, and A and C cannot steal from B.\n> > >\n> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n> committed onchain, which outright prevents this bidding war from even\n> starting.\n> > >\n> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n> needed since it is its commitment tx that was broadcast.\n> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n> > >\n> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n> > >\n> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n> more blockspace.\n> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n> understanding of `SIGHASH_NOINPUT` still holds).\n> > >\n> > > With this, B can exponentially increase the fee as L+1 approaches.\n> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n> the HTLC value at all, since the UTXO it could steal from has already been\n> spent.\n> > >\n> > > In particular, it does not seem to me that it is necessary to change\n> the hashlock-branch transaction of C at all, since this mechanism is enough\n> to sidestep the issue (as I understand it).\n> > > But it does point to a need to make HTLC-Timeout (and possibly\n> symmetrically, HTLC-Success) also fee-bumpable.\n> > >\n> > > Note as well that this does not require a mempool: B can run in\n> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n> is not confirmed, feebump HTLC-Timeout.\n> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n> own commitment transaction, and B *should* be aware that it did so ---\n> there is still no need for mempool monitoring here.\n> > >\n> > > Now, of course this only delays the war.\n> > > Let us now consider what C can do to ensure that the bidding war will\n> happen eventually.\n> > >\n> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n> L and L+1.\n> > >   * Or in other words, this is a censorship attack.\n> > >     * The Bitcoin censorship-resistance model is that censored\n> transactions can be fee-bumped, which attracts non-censoring miners to try\n> their luck at mining and evict the censoring miner.\n> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n> mechanism we need.\n> > >       * This sets up a bidding war between C requesting miners to\n> censor, vs. B requesting miners to confirm, but that only sets the stage\n> for a second bidding war later between C and B, thus C is at a\n> disadvantage: it has to bribe miners to censor continuously from L to L+1\n> *and* additional bribe miners to confirm its transaction after L+1, whereas\n> B can offer its bribe as being something that miners can claim now without\n> waiting after L+1.\n> > >\n> > > The issue of course is the additional output that bloats the UTXO set\n> and requires another transaction to claim later.\n> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n> HTLC can be claimed with a fee-bumpable transaction directly without\n> RBF-carve-out.\n> > > (As well, it seems to me that, if both nodes support doing so, a\n> Poon-Dryja channel can be upgraded, without onchain activity, to a\n> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n> you still need to monitor for previous Poon-Dryja commitment transactions,\n> but HTLCs now sidestep the issue under discussion here.)\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/3fdeb85d/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:11:08",
                "message_text_only": "Hi z,\n\nActually, the current anchors proposal already does this, since it enforces\na\nCSV of 1 block before the HTLCs can be spent (the block after\nconfirmation). So\nI think we already do this, meaning the malicious node is already forced to\nuse\nan RBF-replaceable transaction.\n\n-- Laolu\n\n\nOn Wed, Apr 22, 2020 at 4:05 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Hi Z,\n>\n> > It seems to me that, if my cached understanding that `<0>\n> > OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then\n> adding\n> > that to the hashlock branch (2 witness bytes, 0.5 weight) would be a\n> pretty\n> > low-weight mitigation against this attack.\n>\n> I think this works...so they're forced to spend the output with a non-final\n> sequence number, meaning it *must* signal RBF. In this case, now it's the\n> timeout-er vs the success-er racing based on fee rate. If the honest party\n> (the\n> one trying to time out the HTLC) bids a fee rate higher (need to also\n> account\n> for the whole absolute fee replacement thing), then things should generally\n> work out in their favor.\n>\n> -- Laolu\n>\n>\n> On Tue, Apr 21, 2020 at 11:08 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Laolu, Matt, and list,\n>>\n>>\n>> > >  * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> > >  `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> > >  signature for a higher-fee version of HTLC-Timeout (assuming my\n>> cached\n>> > >  understanding of `SIGHASH_NOINPUT` still holds).\n>> >\n>> > no_input isn't needed. With simply single+anyone can pay, then B can\n>> attach\n>> > a new input+output pair to increase the fees on their HTLC redemption\n>> > transaction. As you mention, they now enter into a race against this\n>> > malicious ndoe to bump up their fees in order to win over the other\n>> party.\n>>\n>> Right, right, that works as well.\n>>\n>> >\n>> > If the malicious node uses a non-RBF signalled transaction to sweep\n>> their\n>> > HTLC, then we enter into another level of race, but this time on the\n>> mempool\n>> > propagation level. However, if there exists a relay path to a miner\n>> running\n>> > full RBF, then B's higher fee rate spend will win over.\n>>\n>> Hmm.\n>>\n>> So basically:\n>>\n>> * B has no mempool, because it wants to reduce its costs and etc.\n>> * C broadcasts a non-RBF claim tx with low fee before A->B locktime (L+1).\n>> * B does not notice this tx because:\n>>   1.  The tx is too low fee to be put in a block.\n>>   2.  B has no mempool so it cannot see the tx being propagated over the\n>> P2P network.\n>> * B tries to broadcast higher-fee HTLC-timeout, but fails because it\n>> cannot replace a non-RBF tx.\n>> * After L+1, C contacts the miners off-band and offers fee payment by\n>> other means.\n>>\n>> It seems to me that, if my cached understanding that `<0>\n>> OP_CHECKSEQUENCEVERIFY` is sufficient to require RBF-flagging, then adding\n>> that to the hashlock branch (2 witness bytes, 0.5 weight) would be a pretty\n>> low-weight mitigation against this attack.\n>>\n>> So I think the combination below gives us good size:\n>>\n>> * The HTLC-Timeout signature from C is flagged with\n>> `OP_SINGLE|OP_ANYONECANPAY`.\n>>   * Normally, the HTLC-Timeout still deducts the fee from the value of\n>> the UTXO being spent.\n>>   * However, if B notices that the L+1 timeout is approaching, it can\n>> fee-bump HTLC-Timeout with some onchain funds, recreating its own signature\n>> but reusing the (still valid) C signature.\n>> * The hashlock branch in this case includes `<0> OP_CHECKSEQUENCEVERIFY`,\n>> preventing C from broadcasting a low-fee claim tx.\n>>\n>> This has the advantages:\n>>\n>> * B does not need a mempool still and can run in `blocksonly`.\n>> * The normal path is still the same as current behavior, we \"only\" add a\n>> new path where if the L+1 timeout is approaching we fee-bump the\n>> HTLC-Timeout.\n>> * Costs are pretty low:\n>>   * No need for extra RBF carve-out txo.\n>>   * Just two additional witness bytes in the hashlock branch.\n>> * No mempool rule changes needed, can be done with the P2P network of\n>> today.\n>>   * Probably still resilient even with future changes in mempool rules,\n>> as long as typical RBF behaviors still remain.\n>>\n>> Is my understanding correct?\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> >\n>> > -- Laolu\n>> >\n>> > On Tue, Apr 21, 2020 at 9:13 PM ZmnSCPxj via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> > > Good morning Matt, and list,\n>> > >\n>> > > >     RBF Pinning HTLC Transactions (aka \"Oh, wait, I can steal\n>> funds, how, now?\")\n>> > > >     =============================\n>> > > >\n>> > > >     You'll note that in the discussion of RBF pinning we were\n>> pretty broad, and that that discussion seems to in fact cover\n>> > > >     our HTLC outputs, at least when spent via (3) or (4). It does,\n>> and in fact this is a pretty severe issue in today's\n>> > > >     lightning protocol [2]. A lightning counterparty (C, who\n>> received the HTLC from B, who received it from A) today could,\n>> > > >     if B broadcasts the commitment transaction, spend an HTLC using\n>> the preimage with a low-fee, RBF-disabled transaction.\n>> > > >     After a few blocks, A could claim the HTLC from B via the\n>> timeout mechanism, and then after a few days, C could get the\n>> > > >     HTLC-claiming transaction mined via some out-of-band agreement\n>> with a small miner. This leaves B short the HTLC value.\n>> > >\n>> > > My (cached) understanding is that, since RBF is signalled using\n>> `nSequence`, any `OP_CHECKSEQUENCEVERIFY` also automatically imposes the\n>> requirement \"must be RBF-enabled\", including `<0> OP_CHECKSEQUENCEVERIFY`.\n>> > > Adding that clause (2 bytes in witness if my math is correct) to the\n>> hashlock branch may be sufficient to prevent C from making an RBF-disabled\n>> transaction.\n>> > >\n>> > > But then you mention out-of-band agreements with miners, which\n>> basically means the transaction might not be in the mempool at all, in\n>> which case the vulnerability is not really about RBF or relay, but sheer\n>> economics.\n>> > >\n>> > > The payment is A->B->C, and the HTLC A->B must have a larger timeout\n>> (L + 1) than the HTLC B->C (L), in abstract non-block units.\n>> > > The vulnerability you are describing means that the current time must\n>> now be L + 1 or greater (\"A could claim the HTLC from B via the timeout\n>> mechanism\", meaning the A->B HTLC has timed out already).\n>> > >\n>> > > If so, then the B->C transaction has already timed out in the past\n>> and can be claimed in two ways, either via B timeout branch or C hashlock\n>> branch.\n>> > > This sets up a game where B and C bid to miners to get their version\n>> of reality committed onchain.\n>> > > (We can neglect out-of-band agreements here; miners have the\n>> incentive to publicly leak such agreements so that other potential bidders\n>> can offer even higher fees for their versions of that transaction.)\n>> > >\n>> > > Before L+1, C has no incentive to bid, since placing any bid at all\n>> will leak the preimage, which B can then turn around and use to spend from\n>> A, and A and C cannot steal from B.\n>> > >\n>> > > Thus, B should ensure that *before* L+1, the HTLC-Timeout has been\n>> committed onchain, which outright prevents this bidding war from even\n>> starting.\n>> > >\n>> > > The issue then is that B is using a pre-signed HTLC-timeout, which is\n>> needed since it is its commitment tx that was broadcast.\n>> > > This prevents B from RBF-ing the HTLC-Timeout transaction.\n>> > >\n>> > > So what is needed is to allow B to add fees to HTLC-Timeout:\n>> > >\n>> > > * We can add an RBF carve-out output to HTLC-Timeout, at the cost of\n>> more blockspace.\n>> > > * With `SIGHASH_NOINPUT` we can make the C-side signature\n>> `SIGHASH_NOINPUT|SIGHASH_SINGLE` and allow B to re-sign the B-side\n>> signature for a higher-fee version of HTLC-Timeout (assuming my cached\n>> understanding of `SIGHASH_NOINPUT` still holds).\n>> > >\n>> > > With this, B can exponentially increase the fee as L+1 approaches.\n>> > > If B can get HTLC-Timeout confirmed before L+1, then C cannot steal\n>> the HTLC value at all, since the UTXO it could steal from has already been\n>> spent.\n>> > >\n>> > > In particular, it does not seem to me that it is necessary to change\n>> the hashlock-branch transaction of C at all, since this mechanism is enough\n>> to sidestep the issue (as I understand it).\n>> > > But it does point to a need to make HTLC-Timeout (and possibly\n>> symmetrically, HTLC-Success) also fee-bumpable.\n>> > >\n>> > > Note as well that this does not require a mempool: B can run in\n>> `blocksonly` mode and as each block comes in from L to L+1, if HTLC-Timeout\n>> is not confirmed, feebump HTLC-Timeout.\n>> > > In particular, HTLC-Timeout comes into play only if B broadcast its\n>> own commitment transaction, and B *should* be aware that it did so ---\n>> there is still no need for mempool monitoring here.\n>> > >\n>> > > Now, of course this only delays the war.\n>> > > Let us now consider what C can do to ensure that the bidding war will\n>> happen eventually.\n>> > >\n>> > > * C can bribe a miner to prevent HTLC-Timeout from confirming between\n>> L and L+1.\n>> > >   * Or in other words, this is a censorship attack.\n>> > >     * The Bitcoin censorship-resistance model is that censored\n>> transactions can be fee-bumped, which attracts non-censoring miners to try\n>> their luck at mining and evict the censoring miner.\n>> > >       * Thus, letting B bump the fee on HTLC-Timeout is precisely the\n>> mechanism we need.\n>> > >       * This sets up a bidding war between C requesting miners to\n>> censor, vs. B requesting miners to confirm, but that only sets the stage\n>> for a second bidding war later between C and B, thus C is at a\n>> disadvantage: it has to bribe miners to censor continuously from L to L+1\n>> *and* additional bribe miners to confirm its transaction after L+1, whereas\n>> B can offer its bribe as being something that miners can claim now without\n>> waiting after L+1.\n>> > >\n>> > > The issue of course is the additional output that bloats the UTXO set\n>> and requires another transaction to claim later.\n>> > > And if we have `SIGHASH_NOINPUT`, it seems to me that\n>> Decker-Russell-Osuntokun sidesteps this issue as well, as any timed-out\n>> HTLC can be claimed with a fee-bumpable transaction directly without\n>> RBF-carve-out.\n>> > > (As well, it seems to me that, if both nodes support doing so, a\n>> Poon-Dryja channel can be upgraded, without onchain activity, to a\n>> Decker-Russell-Osuntokun channel: sign a transaction spending the funding\n>> tx to a txo that has been set up as Decker-Russell-Osuntokun, do not\n>> broadcast that transaction, then revoke the latest Poon-Dryja commitment\n>> transactions, then switch the mechanism over to Decker-Russell-Osuntokun;\n>> you still need to monitor for previous Poon-Dryja commitment transactions,\n>> but HTLCs now sidestep the issue under discussion here.)\n>> > >\n>> > > Regards,\n>> > > ZmnSCPxj\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/b51b1fe1/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T04:13:34",
                "message_text_only": "Hi Matt,\n\n\n> While this is somewhat unintuitive, there are any number of good anti-DoS\n> reasons for this, eg:\n\nNone of these really strikes me as \"good\" reasons for this limitation, which\nis at the root of this issue, and will also plague any more complex Bitcoin\ncontracts which rely on nested trees of transaction to confirm (CTV, Duplex,\nchannel factories, etc). Regarding the various (seemingly arbitrary) package\nlimits it's likely the case that any issues w.r.t computational complexity\nthat may arise when trying to calculate evictions can be ameliorated with\nbetter choice of internal data structures.\n\nIn the end, the simplest heuristic (accept the higher fee rate package) side\nsteps all these issues and is also the most economically rationale from a\nminer's perspective. Why would one prefer a higher absolute fee package\n(which could be very large) over another package with a higher total _fee\nrate_?\n\n> You'll note that B would be just fine if they had a way to safely monitor\nthe\n> global mempool, and while this seems like a prudent mitigation for\n> lightning implementations to deploy today, it is itself a quagmire of\n> complexity\n\nIs it really all that complex? Assuming we're talking about just watching\nfor a certain script template (the HTLC scipt) in the mempool to be able to\npull a pre-image as soon as possible. Early versions of lnd used the mempool\nfor commitment broadcast detection (which turned out to be a bad idea so we\nremoved it), but at a glance I don't see why watching the mempool is so\ncomplex.\n\n> Further, this is a really obnoxious assumption to hoist onto lightning\n> nodes - having an active full node with an in-sync mempool is a lot more\n> CPU, bandwidth, and complexity than most lightning users were expecting to\n> face.\n\nThis would only be a requirement for Lightning nodes that seek to be a part\nof the public routing network with a desire to _forward_ HTLCs. This isn't\ndoesn't affect laptops or mobile phones which likely mostly have private\nchannels and don't participate in HTLC forwarding. I think it's pretty\nreasonable to expect a \"proper\" routing node on the network to be backed by\na full-node. The bandwidth concern is valid, but we'd need concrete numbers\nthat compare the bandwidth over head of mempool awareness (assuming the\nlatest and greatest mempool syncing) compared with the overhead of the\nchannel update gossip and gossip queries over head which LN nodes face today\nas is to see how much worse off they really would be.\n\nAs detailed a bit below, if nodes watch the mempool, then this class of\nattack assuming the anchor output format as described in the open\nlightning-rfc PR is mitigated. At a glance, watching the mempool seems like\na far less involved process compared to modifying the state machine as its\ndefined today. By watching the mempool and implementing the changes in\n#lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\ndoesn't yet watch the mempool (but does include anchors [1]), but unless I'm\nmissing something it should be pretty straight forward to add which mor or\nless\nresolves this issue all together.\n\n> not fixing this issue seems to render the whole exercise somewhat useless\n\nDepends on if one considers watching the mempool a fix. But even with that a\nbase version of anchors still resolves a number of issues including:\neliminating the commitment fee guessing game, allowing users to pay less on\nforce close, being able to coalesce 2nd level HTLC transactions with the\nsame CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\nresolution.\n\n> Instead of making the HTLC output spending more free-form with\n> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n> direction - all HTLC output spends need to be pre-signed.\n\nI'm not sure this is actually immediately workable (need to think about it\nmore). To see why, remember that the commit_sig message includes HTLC\nsignatures for the _remote_ party's commitment transaction, so they can\nspend the HTLCs if they broadcast their version of the commitment (force\nclose). If we don't somehow also _gain_ signatures (our new HTLC signatures)\nallowing us to spend HTLCs on _their_ version of the commitment, then if\nthey broadcast that commitment (without revoking), then we're unable to\nredeem any of those HTLCs at all, possibly losing money.\n\nIn an attempt to counteract this, we might say ok, the revoke message also\nnow includes HTLC signatures for their new commitment allowing us to spend\nour HTLCs. This resolves things in a weaker security model, but doesn't\naddress the issue generally, as after they receive the commit_sig, they can\nbroadcast immediately, again leaving us without a way to redeem our HTLCs.\n\nI'd need to think about it more, but it seems that following this path would\nrequire an overhaul in the channel state machine to make presenting a new\ncommitment actually take at least _two phases_ (at least a full round trip).\nThe first phase would tender the commitment, but render them unable to\nbroadcast it. The second phase would then <insert something something\nscriptless scripts here> enter a new sub-protocol which upon conclusion,\ngives the commitment proposer valid HTLC signatures, and gives the responder\nwhat they need to be able to broadcast their commitment and claim their\nHTCLs in an atomic manner.\n\n-- Laolu\n\n[1]: https://github.com/lightningnetwork/lnd/pull/3821\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200421/6cae2a06/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-04-27T21:26:19",
                "message_text_only": "\"David A. Harding via bitcoin-dev\" <bitcoin-dev at lists.linuxfoundation.org> writes:\n> To avoid the excessive wasting of bandwidth.  Bitcoin Core's defaults\n> require each replacement pay a feerate of 10 nBTC/vbyte over an existing\n> transaction or package, and the defaults also allow transactions or\n> packages up to 100,000 vbytes in size (~400,000 bytes).  So, without\n> enforcement of BIP125 rule 3, an attacker starting at the minimum\n> default relay fee also of 10 nBTC/vbyte could do the following:\n>\n> - Create a ~400,000 bytes tx with feerate of 10 nBTC/vbyte (1 mBTC total\n>   fee)\n>\n> - Replace that transaction with 400,000 new bytes at a feerate of 20\n>   nBTC/vbyte (2 mBTC total fee)\n>\n> - Perform 998 additional replacements, each increasing the feerate by 10\n>   nBTC/vbyte and the total fee by 1 mBTC, using a total of 400 megabytes\n>   (including the original transaction and first replacement) to\n>   ultimately produce a transaction with a feerate of 10,000 nBTC/vbyte\n>   (1 BTC total fee)\n>\n> - Perform one final replacement of the latest 400,000 byte transaction\n>   with a ~200-byte (~150 vbyte) 1-in, 1-out P2WPKH transaction that pays\n>   a feerate of 10,010 nBTC/vbyte (1.5 mBTC total fee)\n\nTo be fair, if the feerate you want is 100x the minimum permitted, you\ncan always use 100x as much bandwidth as necessary without extra cost.\nIf everyone (or some major tx producers) were to do that, it would suck.\n\nTo fix this properly, you really need to agressively delay processing\n(thus propagation) of transactions which aren't likely to be in the next\n(few?) blocks.  This is a more miner incentive compatible scheme.\n\nHowever, I realize this is a complete rewrite of bitcoind's logic, and\nI'm not volunteering to do it!\n\nCheers,\nRusty,"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T16:50:46",
                "message_text_only": "A few replies inline.\n\nOn 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n> Hi Matt,\n> \n> \n>> While this is somewhat unintuitive, there are any number of good anti-DoS\n>> reasons for this, eg:\n> \n> None of these really strikes me as \"good\" reasons for this limitation, which\n> is at the root of this issue, and will also plague any more complex Bitcoin\n> contracts which rely on nested trees of transaction to confirm (CTV, Duplex,\n> channel factories, etc). Regarding the various (seemingly arbitrary) package\n> limits it's likely the case that any issues w.r.t computational complexity\n> that may arise when trying to calculate evictions can be ameliorated with\n> better choice of internal data structures.\n> \n> In the end, the simplest heuristic (accept the higher fee rate package) side\n> steps all these issues and is also the most economically rationale from a\n> miner's perspective. Why would one prefer a higher absolute fee package\n> (which could be very large) over another package with a higher total _fee\n> rate_?\n\nThis seems like a somewhat unnecessary drive-by insult of a project you don't contribute to, but feel free to start with\na concrete suggestion here :).\n\n>> You'll note that B would be just fine if they had a way to safely monitor the\n>> global mempool, and while this seems like a prudent mitigation for\n>> lightning implementations to deploy today, it is itself a quagmire of\n>> complexity\n> \n> Is it really all that complex? Assuming we're talking about just watching\n> for a certain script template (the HTLC scipt) in the mempool to be able to\n> pull a pre-image as soon as possible. Early versions of lnd used the mempool\n> for commitment broadcast detection (which turned out to be a bad idea so we\n> removed it), but at a glance I don't see why watching the mempool is so\n> complex.\n\nBecause watching your own mempool is not guaranteed to work, and during upgrade cycles that include changes to the\npolicy rules an attacker could exploit your upgraded/non-upgraded status to perform the same attack.\n\n>> Further, this is a really obnoxious assumption to hoist onto lightning\n>> nodes - having an active full node with an in-sync mempool is a lot more\n>> CPU, bandwidth, and complexity than most lightning users were expecting to\n>> face.\n> \n> This would only be a requirement for Lightning nodes that seek to be a part\n> of the public routing network with a desire to _forward_ HTLCs. This isn't\n> doesn't affect laptops or mobile phones which likely mostly have private\n> channels and don't participate in HTLC forwarding. I think it's pretty\n> reasonable to expect a \"proper\" routing node on the network to be backed by\n> a full-node. The bandwidth concern is valid, but we'd need concrete numbers\n> that compare the bandwidth over head of mempool awareness (assuming the\n> latest and greatest mempool syncing) compared with the overhead of the\n> channel update gossip and gossip queries over head which LN nodes face today\n> as is to see how much worse off they really would be.\n\nIf mempool-watching were practical, maybe, though there are a number of folks who are talking about designing\npartially-offline local lightning hubs which would be rendered impractical.\n\n> As detailed a bit below, if nodes watch the mempool, then this class of\n> attack assuming the anchor output format as described in the open\n> lightning-rfc PR is mitigated. At a glance, watching the mempool seems like\n> a far less involved process compared to modifying the state machine as its\n> defined today. By watching the mempool and implementing the changes in\n> #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n> doesn't yet watch the mempool (but does include anchors [1]), but unless I'm\n> missing something it should be pretty straight forward to add which mor or less\n> resolves this issue all together.\n> \n>> not fixing this issue seems to render the whole exercise somewhat useless\n> \n> Depends on if one considers watching the mempool a fix. But even with that a\n> base version of anchors still resolves a number of issues including:\n> eliminating the commitment fee guessing game, allowing users to pay less on\n> force close, being able to coalesce 2nd level HTLC transactions with the\n> same CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\n> resolution.\n> \n>> Instead of making the HTLC output spending more free-form with\n>> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>> direction - all HTLC output spends need to be pre-signed.\n> \n> I'm not sure this is actually immediately workable (need to think about it\n> more). To see why, remember that the commit_sig message includes HTLC\n> signatures for the _remote_ party's commitment transaction, so they can\n> spend the HTLCs if they broadcast their version of the commitment (force\n> close). If we don't somehow also _gain_ signatures (our new HTLC signatures)\n> allowing us to spend HTLCs on _their_ version of the commitment, then if\n> they broadcast that commitment (without revoking), then we're unable to\n> redeem any of those HTLCs at all, possibly losing money.\n\nHmm, maybe the proposal wasn't clear. The idea isn't to add signatures to braodcasted transactions, but instead to CPFP\na maybe-broadcasted transaction by sending a transaction which spends it and seeing if it is accepted. You only need to\nknow the transaction's exact format (ie txid, which we do, since we sent a signature for it long ago) to do this, you\ndon't have to actually *have* the fully-signed transaction (and you don't).\n\n> In an attempt to counteract this, we might say ok, the revoke message also\n> now includes HTLC signatures for their new commitment allowing us to spend\n> our HTLCs. This resolves things in a weaker security model, but doesn't\n> address the issue generally, as after they receive the commit_sig, they can\n> broadcast immediately, again leaving us without a way to redeem our HTLCs.\n> \n> I'd need to think about it more, but it seems that following this path would\n> require an overhaul in the channel state machine to make presenting a new\n> commitment actually take at least _two phases_ (at least a full round trip).\n> The first phase would tender the commitment, but render them unable to\n> broadcast it. The second phase would then <insert something something\n> scriptless scripts here> enter a new sub-protocol which upon conclusion,\n> gives the commitment proposer valid HTLC signatures, and gives the responder\n> what they need to be able to broadcast their commitment and claim their\n> HTCLs in an atomic manner.\n> \n> -- Laolu\n> \n> [1]: https://github.com/lightningnetwork/lnd/pull/3821"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:13:01",
                "message_text_only": "> This seems like a somewhat unnecessary drive-by insult of a project you\n> don't contribute to, but feel free to start with a concrete suggestion\n> here :).\n\nThis wasn't intended as an insult at all. I'm simply saying if there's\nconcern about worst case eviction/replacement, optimizations likely exist.\nOther developers that are interested in more complex multi-transaction\ncontracts have realized this as well, and there're various open PRs that\nattempt to propose such optimizations [1].\n\n> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> braodcasted transactions, but instead to CPFP a maybe-broadcasted\n> transaction by sending a transaction which spends it and seeing if it is\n> accepted\n\nSorry I still don't follow. By \"we clearly need to go the other direction -\nall HTLC output spends need to be pre-signed.\", you don't mean that the HTLC\nspends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\ncovenant? If the other party isn't restricted w.r.t _how_ they can spend the\noutput (non-rbf'd, ect), then I don't see how that addresses anything.\n\nAlso see my mail elsewhere in the thread that the other party is actually\nforced to spend their HTLC output using an RBF-replaceable transaction. With\nthat, I think we're all good here? In the end both sides have the ability to\nraise the fee rate of their spending transactions with the highest winning.\nAs long as one of them confirms within the CLTV-delta, then everyone is\nmade whole.\n\n\n[1]: https://github.com/bitcoin/bitcoin/pull/18191\n\n\nOn Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> A few replies inline.\n>\n> On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n> > Hi Matt,\n> >\n> >\n> >> While this is somewhat unintuitive, there are any number of good\n> anti-DoS\n> >> reasons for this, eg:\n> >\n> > None of these really strikes me as \"good\" reasons for this limitation,\n> which\n> > is at the root of this issue, and will also plague any more complex\n> Bitcoin\n> > contracts which rely on nested trees of transaction to confirm (CTV,\n> Duplex,\n> > channel factories, etc). Regarding the various (seemingly arbitrary)\n> package\n> > limits it's likely the case that any issues w.r.t computational\n> complexity\n> > that may arise when trying to calculate evictions can be ameliorated with\n> > better choice of internal data structures.\n> >\n> > In the end, the simplest heuristic (accept the higher fee rate package)\n> side\n> > steps all these issues and is also the most economically rationale from a\n> > miner's perspective. Why would one prefer a higher absolute fee package\n> > (which could be very large) over another package with a higher total _fee\n> > rate_?\n>\n> This seems like a somewhat unnecessary drive-by insult of a project you\n> don't contribute to, but feel free to start with\n> a concrete suggestion here :).\n>\n> >> You'll note that B would be just fine if they had a way to safely\n> monitor the\n> >> global mempool, and while this seems like a prudent mitigation for\n> >> lightning implementations to deploy today, it is itself a quagmire of\n> >> complexity\n> >\n> > Is it really all that complex? Assuming we're talking about just watching\n> > for a certain script template (the HTLC scipt) in the mempool to be able\n> to\n> > pull a pre-image as soon as possible. Early versions of lnd used the\n> mempool\n> > for commitment broadcast detection (which turned out to be a bad idea so\n> we\n> > removed it), but at a glance I don't see why watching the mempool is so\n> > complex.\n>\n> Because watching your own mempool is not guaranteed to work, and during\n> upgrade cycles that include changes to the\n> policy rules an attacker could exploit your upgraded/non-upgraded status\n> to perform the same attack.\n>\n> >> Further, this is a really obnoxious assumption to hoist onto lightning\n> >> nodes - having an active full node with an in-sync mempool is a lot more\n> >> CPU, bandwidth, and complexity than most lightning users were expecting\n> to\n> >> face.\n> >\n> > This would only be a requirement for Lightning nodes that seek to be a\n> part\n> > of the public routing network with a desire to _forward_ HTLCs. This\n> isn't\n> > doesn't affect laptops or mobile phones which likely mostly have private\n> > channels and don't participate in HTLC forwarding. I think it's pretty\n> > reasonable to expect a \"proper\" routing node on the network to be backed\n> by\n> > a full-node. The bandwidth concern is valid, but we'd need concrete\n> numbers\n> > that compare the bandwidth over head of mempool awareness (assuming the\n> > latest and greatest mempool syncing) compared with the overhead of the\n> > channel update gossip and gossip queries over head which LN nodes face\n> today\n> > as is to see how much worse off they really would be.\n>\n> If mempool-watching were practical, maybe, though there are a number of\n> folks who are talking about designing\n> partially-offline local lightning hubs which would be rendered impractical.\n>\n> > As detailed a bit below, if nodes watch the mempool, then this class of\n> > attack assuming the anchor output format as described in the open\n> > lightning-rfc PR is mitigated. At a glance, watching the mempool seems\n> like\n> > a far less involved process compared to modifying the state machine as\n> its\n> > defined today. By watching the mempool and implementing the changes in\n> > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n> > doesn't yet watch the mempool (but does include anchors [1]), but unless\n> I'm\n> > missing something it should be pretty straight forward to add which mor\n> or less\n> > resolves this issue all together.\n> >\n> >> not fixing this issue seems to render the whole exercise somewhat\n> useless\n> >\n> > Depends on if one considers watching the mempool a fix. But even with\n> that a\n> > base version of anchors still resolves a number of issues including:\n> > eliminating the commitment fee guessing game, allowing users to pay less\n> on\n> > force close, being able to coalesce 2nd level HTLC transactions with the\n> > same CLTV expiry, and actually being able to reliably enforce multi-hop\n> HTLC\n> > resolution.\n> >\n> >> Instead of making the HTLC output spending more free-form with\n> >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n> >> direction - all HTLC output spends need to be pre-signed.\n> >\n> > I'm not sure this is actually immediately workable (need to think about\n> it\n> > more). To see why, remember that the commit_sig message includes HTLC\n> > signatures for the _remote_ party's commitment transaction, so they can\n> > spend the HTLCs if they broadcast their version of the commitment (force\n> > close). If we don't somehow also _gain_ signatures (our new HTLC\n> signatures)\n> > allowing us to spend HTLCs on _their_ version of the commitment, then if\n> > they broadcast that commitment (without revoking), then we're unable to\n> > redeem any of those HTLCs at all, possibly losing money.\n>\n> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> braodcasted transactions, but instead to CPFP\n> a maybe-broadcasted transaction by sending a transaction which spends it\n> and seeing if it is accepted. You only need to\n> know the transaction's exact format (ie txid, which we do, since we sent a\n> signature for it long ago) to do this, you\n> don't have to actually *have* the fully-signed transaction (and you don't).\n>\n> > In an attempt to counteract this, we might say ok, the revoke message\n> also\n> > now includes HTLC signatures for their new commitment allowing us to\n> spend\n> > our HTLCs. This resolves things in a weaker security model, but doesn't\n> > address the issue generally, as after they receive the commit_sig, they\n> can\n> > broadcast immediately, again leaving us without a way to redeem our\n> HTLCs.\n> >\n> > I'd need to think about it more, but it seems that following this path\n> would\n> > require an overhaul in the channel state machine to make presenting a new\n> > commitment actually take at least _two phases_ (at least a full round\n> trip).\n> > The first phase would tender the commitment, but render them unable to\n> > broadcast it. The second phase would then <insert something something\n> > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n> > gives the commitment proposer valid HTLC signatures, and gives the\n> responder\n> > what they need to be able to broadcast their commitment and claim their\n> > HTCLs in an atomic manner.\n> >\n> > -- Laolu\n> >\n> > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/2392c438/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-22T23:20:03",
                "message_text_only": "> On Apr 22, 2020, at 16:13, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n> \n> > Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> > braodcasted transactions, but instead to CPFP a maybe-broadcasted\n> > transaction by sending a transaction which spends it and seeing if it is\n> > accepted\n> \n> Sorry I still don't follow. By \"we clearly need to go the other direction -\n> all HTLC output spends need to be pre-signed.\", you don't mean that the HTLC\n> spends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\n> covenant? If the other party isn't restricted w.r.t _how_ they can spend the\n> output (non-rbf'd, ect), then I don't see how that addresses anything.\n\nIndeed, that is what I\u2019m suggesting. Anchor output and all. One thing we could think about is only turning it on over a certain threshold, and having a separate \u201conly-kinda-enforceable-on-chain-HTLC-in-flight\u201d limit.\n\n> Also see my mail elsewhere in the thread that the other party is actually\n> forced to spend their HTLC output using an RBF-replaceable transaction. With\n> that, I think we're all good here? In the end both sides have the ability to\n> raise the fee rate of their spending transactions with the highest winning.\n> As long as one of them confirms within the CLTV-delta, then everyone is\n> made whole.\n\nIt does seem like my cached recollection of RBF opt-in was incorrect but please re-read the intro email. There are a bunch of ways of doing pinning - just opting into RBF isn\u2019t even close to enough.\n\n> [1]: https://github.com/bitcoin/bitcoin/pull/18191\n> \n> \n>> On Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com> wrote:\n>> A few replies inline.\n>> \n>> On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n>> > Hi Matt,\n>> > \n>> > \n>> >> While this is somewhat unintuitive, there are any number of good anti-DoS\n>> >> reasons for this, eg:\n>> > \n>> > None of these really strikes me as \"good\" reasons for this limitation, which\n>> > is at the root of this issue, and will also plague any more complex Bitcoin\n>> > contracts which rely on nested trees of transaction to confirm (CTV, Duplex,\n>> > channel factories, etc). Regarding the various (seemingly arbitrary) package\n>> > limits it's likely the case that any issues w.r.t computational complexity\n>> > that may arise when trying to calculate evictions can be ameliorated with\n>> > better choice of internal data structures.\n>> > \n>> > In the end, the simplest heuristic (accept the higher fee rate package) side\n>> > steps all these issues and is also the most economically rationale from a\n>> > miner's perspective. Why would one prefer a higher absolute fee package\n>> > (which could be very large) over another package with a higher total _fee\n>> > rate_?\n>> \n>> This seems like a somewhat unnecessary drive-by insult of a project you don't contribute to, but feel free to start with\n>> a concrete suggestion here :).\n>> \n>> >> You'll note that B would be just fine if they had a way to safely monitor the\n>> >> global mempool, and while this seems like a prudent mitigation for\n>> >> lightning implementations to deploy today, it is itself a quagmire of\n>> >> complexity\n>> > \n>> > Is it really all that complex? Assuming we're talking about just watching\n>> > for a certain script template (the HTLC scipt) in the mempool to be able to\n>> > pull a pre-image as soon as possible. Early versions of lnd used the mempool\n>> > for commitment broadcast detection (which turned out to be a bad idea so we\n>> > removed it), but at a glance I don't see why watching the mempool is so\n>> > complex.\n>> \n>> Because watching your own mempool is not guaranteed to work, and during upgrade cycles that include changes to the\n>> policy rules an attacker could exploit your upgraded/non-upgraded status to perform the same attack.\n>> \n>> >> Further, this is a really obnoxious assumption to hoist onto lightning\n>> >> nodes - having an active full node with an in-sync mempool is a lot more\n>> >> CPU, bandwidth, and complexity than most lightning users were expecting to\n>> >> face.\n>> > \n>> > This would only be a requirement for Lightning nodes that seek to be a part\n>> > of the public routing network with a desire to _forward_ HTLCs. This isn't\n>> > doesn't affect laptops or mobile phones which likely mostly have private\n>> > channels and don't participate in HTLC forwarding. I think it's pretty\n>> > reasonable to expect a \"proper\" routing node on the network to be backed by\n>> > a full-node. The bandwidth concern is valid, but we'd need concrete numbers\n>> > that compare the bandwidth over head of mempool awareness (assuming the\n>> > latest and greatest mempool syncing) compared with the overhead of the\n>> > channel update gossip and gossip queries over head which LN nodes face today\n>> > as is to see how much worse off they really would be.\n>> \n>> If mempool-watching were practical, maybe, though there are a number of folks who are talking about designing\n>> partially-offline local lightning hubs which would be rendered impractical.\n>> \n>> > As detailed a bit below, if nodes watch the mempool, then this class of\n>> > attack assuming the anchor output format as described in the open\n>> > lightning-rfc PR is mitigated. At a glance, watching the mempool seems like\n>> > a far less involved process compared to modifying the state machine as its\n>> > defined today. By watching the mempool and implementing the changes in\n>> > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n>> > doesn't yet watch the mempool (but does include anchors [1]), but unless I'm\n>> > missing something it should be pretty straight forward to add which mor or less\n>> > resolves this issue all together.\n>> > \n>> >> not fixing this issue seems to render the whole exercise somewhat useless\n>> > \n>> > Depends on if one considers watching the mempool a fix. But even with that a\n>> > base version of anchors still resolves a number of issues including:\n>> > eliminating the commitment fee guessing game, allowing users to pay less on\n>> > force close, being able to coalesce 2nd level HTLC transactions with the\n>> > same CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\n>> > resolution.\n>> > \n>> >> Instead of making the HTLC output spending more free-form with\n>> >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>> >> direction - all HTLC output spends need to be pre-signed.\n>> > \n>> > I'm not sure this is actually immediately workable (need to think about it\n>> > more). To see why, remember that the commit_sig message includes HTLC\n>> > signatures for the _remote_ party's commitment transaction, so they can\n>> > spend the HTLCs if they broadcast their version of the commitment (force\n>> > close). If we don't somehow also _gain_ signatures (our new HTLC signatures)\n>> > allowing us to spend HTLCs on _their_ version of the commitment, then if\n>> > they broadcast that commitment (without revoking), then we're unable to\n>> > redeem any of those HTLCs at all, possibly losing money.\n>> \n>> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to braodcasted transactions, but instead to CPFP\n>> a maybe-broadcasted transaction by sending a transaction which spends it and seeing if it is accepted. You only need to\n>> know the transaction's exact format (ie txid, which we do, since we sent a signature for it long ago) to do this, you\n>> don't have to actually *have* the fully-signed transaction (and you don't).\n>> \n>> > In an attempt to counteract this, we might say ok, the revoke message also\n>> > now includes HTLC signatures for their new commitment allowing us to spend\n>> > our HTLCs. This resolves things in a weaker security model, but doesn't\n>> > address the issue generally, as after they receive the commit_sig, they can\n>> > broadcast immediately, again leaving us without a way to redeem our HTLCs.\n>> > \n>> > I'd need to think about it more, but it seems that following this path would\n>> > require an overhaul in the channel state machine to make presenting a new\n>> > commitment actually take at least _two phases_ (at least a full round trip).\n>> > The first phase would tender the commitment, but render them unable to\n>> > broadcast it. The second phase would then <insert something something\n>> > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n>> > gives the commitment proposer valid HTLC signatures, and gives the responder\n>> > what they need to be able to broadcast their commitment and claim their\n>> > HTCLs in an atomic manner.\n>> > \n>> > -- Laolu\n>> > \n>> > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/428e7a28/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-22T23:27:49",
                "message_text_only": "> Indeed, that is what I\u2019m suggesting\n\nGotcha, if this is indeed what you're suggesting (all HTLC spends are now\n2-of-2 multi-sig), then I think the modifications to the state machine I\nsketched out in an earlier email are required. An exact construction which\nachieves the requirements of \"you can't broadcast until you have a secret\nwhich I can obtain from the htlc sig for your commitment transaction, and my\nsecret is revealed with another swap\", appears to be an open problem, atm.\n\nEven if they're restricted in this fashion (must be a 1-in-1 out,\nsighashall, fees are pre agreed upon), they can still spend that with a CPFP\n(while still unconfirmed in the mempool) and create another heavy tree,\nwhich puts us right back at the same bidding war scenario?\n\n> There are a bunch of ways of doing pinning - just opting into RBF isn\u2019t\n> even close to enough.\n\nMhmm, there're other ways of doing pinning. But with anchors as is defined\nin that spec PR, they're forced to spend with an RBF-replaceable\ntransaction, which means the party wishing to time things out can enter into\na bidding war. If the party trying to impeded things participates in this\nprogressive absolute fee increase, it's likely that the war terminates\nwith _one_ of them getting into the block, which seems to resolve\neverything?\n\n-- Laolu\n\n\nOn Wed, Apr 22, 2020 at 4:20 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n>\n>\n> On Apr 22, 2020, at 16:13, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>\n>\n> > Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n> > braodcasted transactions, but instead to CPFP a maybe-broadcasted\n> > transaction by sending a transaction which spends it and seeing if it is\n> > accepted\n>\n> Sorry I still don't follow. By \"we clearly need to go the other direction -\n> all HTLC output spends need to be pre-signed.\", you don't mean that the\n> HTLC\n> spends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\n> covenant? If the other party isn't restricted w.r.t _how_ they can spend\n> the\n> output (non-rbf'd, ect), then I don't see how that addresses anything.\n>\n>\n> Indeed, that is what I\u2019m suggesting. Anchor output and all. One thing we\n> could think about is only turning it on over a certain threshold, and\n> having a separate \u201conly-kinda-enforceable-on-chain-HTLC-in-flight\u201d limit.\n>\n> Also see my mail elsewhere in the thread that the other party is actually\n> forced to spend their HTLC output using an RBF-replaceable transaction.\n> With\n> that, I think we're all good here? In the end both sides have the ability\n> to\n> raise the fee rate of their spending transactions with the highest winning.\n> As long as one of them confirms within the CLTV-delta, then everyone is\n> made whole.\n>\n>\n> It does seem like my cached recollection of RBF opt-in was incorrect but\n> please re-read the intro email. There are a bunch of ways of doing pinning\n> - just opting into RBF isn\u2019t even close to enough.\n>\n> [1]: https://github.com/bitcoin/bitcoin/pull/18191\n>\n>\n> On Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n>\n>> A few replies inline.\n>>\n>> On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n>> > Hi Matt,\n>> >\n>> >\n>> >> While this is somewhat unintuitive, there are any number of good\n>> anti-DoS\n>> >> reasons for this, eg:\n>> >\n>> > None of these really strikes me as \"good\" reasons for this limitation,\n>> which\n>> > is at the root of this issue, and will also plague any more complex\n>> Bitcoin\n>> > contracts which rely on nested trees of transaction to confirm (CTV,\n>> Duplex,\n>> > channel factories, etc). Regarding the various (seemingly arbitrary)\n>> package\n>> > limits it's likely the case that any issues w.r.t computational\n>> complexity\n>> > that may arise when trying to calculate evictions can be ameliorated\n>> with\n>> > better choice of internal data structures.\n>> >\n>> > In the end, the simplest heuristic (accept the higher fee rate package)\n>> side\n>> > steps all these issues and is also the most economically rationale from\n>> a\n>> > miner's perspective. Why would one prefer a higher absolute fee package\n>> > (which could be very large) over another package with a higher total\n>> _fee\n>> > rate_?\n>>\n>> This seems like a somewhat unnecessary drive-by insult of a project you\n>> don't contribute to, but feel free to start with\n>> a concrete suggestion here :).\n>>\n>> >> You'll note that B would be just fine if they had a way to safely\n>> monitor the\n>> >> global mempool, and while this seems like a prudent mitigation for\n>> >> lightning implementations to deploy today, it is itself a quagmire of\n>> >> complexity\n>> >\n>> > Is it really all that complex? Assuming we're talking about just\n>> watching\n>> > for a certain script template (the HTLC scipt) in the mempool to be\n>> able to\n>> > pull a pre-image as soon as possible. Early versions of lnd used the\n>> mempool\n>> > for commitment broadcast detection (which turned out to be a bad idea\n>> so we\n>> > removed it), but at a glance I don't see why watching the mempool is so\n>> > complex.\n>>\n>> Because watching your own mempool is not guaranteed to work, and during\n>> upgrade cycles that include changes to the\n>> policy rules an attacker could exploit your upgraded/non-upgraded status\n>> to perform the same attack.\n>>\n>> >> Further, this is a really obnoxious assumption to hoist onto lightning\n>> >> nodes - having an active full node with an in-sync mempool is a lot\n>> more\n>> >> CPU, bandwidth, and complexity than most lightning users were\n>> expecting to\n>> >> face.\n>> >\n>> > This would only be a requirement for Lightning nodes that seek to be a\n>> part\n>> > of the public routing network with a desire to _forward_ HTLCs. This\n>> isn't\n>> > doesn't affect laptops or mobile phones which likely mostly have private\n>> > channels and don't participate in HTLC forwarding. I think it's pretty\n>> > reasonable to expect a \"proper\" routing node on the network to be\n>> backed by\n>> > a full-node. The bandwidth concern is valid, but we'd need concrete\n>> numbers\n>> > that compare the bandwidth over head of mempool awareness (assuming the\n>> > latest and greatest mempool syncing) compared with the overhead of the\n>> > channel update gossip and gossip queries over head which LN nodes face\n>> today\n>> > as is to see how much worse off they really would be.\n>>\n>> If mempool-watching were practical, maybe, though there are a number of\n>> folks who are talking about designing\n>> partially-offline local lightning hubs which would be rendered\n>> impractical.\n>>\n>> > As detailed a bit below, if nodes watch the mempool, then this class of\n>> > attack assuming the anchor output format as described in the open\n>> > lightning-rfc PR is mitigated. At a glance, watching the mempool seems\n>> like\n>> > a far less involved process compared to modifying the state machine as\n>> its\n>> > defined today. By watching the mempool and implementing the changes in\n>> > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n>> > doesn't yet watch the mempool (but does include anchors [1]), but\n>> unless I'm\n>> > missing something it should be pretty straight forward to add which mor\n>> or less\n>> > resolves this issue all together.\n>> >\n>> >> not fixing this issue seems to render the whole exercise somewhat\n>> useless\n>> >\n>> > Depends on if one considers watching the mempool a fix. But even with\n>> that a\n>> > base version of anchors still resolves a number of issues including:\n>> > eliminating the commitment fee guessing game, allowing users to pay\n>> less on\n>> > force close, being able to coalesce 2nd level HTLC transactions with the\n>> > same CLTV expiry, and actually being able to reliably enforce multi-hop\n>> HTLC\n>> > resolution.\n>> >\n>> >> Instead of making the HTLC output spending more free-form with\n>> >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>> >> direction - all HTLC output spends need to be pre-signed.\n>> >\n>> > I'm not sure this is actually immediately workable (need to think about\n>> it\n>> > more). To see why, remember that the commit_sig message includes HTLC\n>> > signatures for the _remote_ party's commitment transaction, so they can\n>> > spend the HTLCs if they broadcast their version of the commitment (force\n>> > close). If we don't somehow also _gain_ signatures (our new HTLC\n>> signatures)\n>> > allowing us to spend HTLCs on _their_ version of the commitment, then if\n>> > they broadcast that commitment (without revoking), then we're unable to\n>> > redeem any of those HTLCs at all, possibly losing money.\n>>\n>> Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n>> braodcasted transactions, but instead to CPFP\n>> a maybe-broadcasted transaction by sending a transaction which spends it\n>> and seeing if it is accepted. You only need to\n>> know the transaction's exact format (ie txid, which we do, since we sent\n>> a signature for it long ago) to do this, you\n>> don't have to actually *have* the fully-signed transaction (and you\n>> don't).\n>>\n>> > In an attempt to counteract this, we might say ok, the revoke message\n>> also\n>> > now includes HTLC signatures for their new commitment allowing us to\n>> spend\n>> > our HTLCs. This resolves things in a weaker security model, but doesn't\n>> > address the issue generally, as after they receive the commit_sig, they\n>> can\n>> > broadcast immediately, again leaving us without a way to redeem our\n>> HTLCs.\n>> >\n>> > I'd need to think about it more, but it seems that following this path\n>> would\n>> > require an overhaul in the channel state machine to make presenting a\n>> new\n>> > commitment actually take at least _two phases_ (at least a full round\n>> trip).\n>> > The first phase would tender the commitment, but render them unable to\n>> > broadcast it. The second phase would then <insert something something\n>> > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n>> > gives the commitment proposer valid HTLC signatures, and gives the\n>> responder\n>> > what they need to be able to broadcast their commitment and claim their\n>> > HTCLs in an atomic manner.\n>> >\n>> > -- Laolu\n>> >\n>> > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/ec41b541/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-23T01:10:47",
                "message_text_only": "On 4/22/20 7:27 PM, Olaoluwa Osuntokun wrote:\n> \n>> Indeed, that is what I\u2019m suggesting\n> \n> Gotcha, if this is indeed what you're suggesting (all HTLC spends are now\n> 2-of-2 multi-sig), then I think the modifications to the state machine I\n> sketched out in an earlier email are required. An exact construction which\n> achieves the requirements of \"you can't broadcast until you have a secret\n> which I can obtain from the htlc sig for your commitment transaction, and my\n> secret is revealed with another swap\", appears to be an open problem, atm.\n\nHmm, indeed, it does seem to require a change to the state machine, but I don't think a very interesting one. Because B\nproviding A an HTLC signature spending a commitment transaction B will broadcast does not allow A to actually broadcast\nsaid HTLC transaction, B can be rather liberal with it. Indeed, however, it would require that B provide such a\nsignature before A can send the commitment_signed that exists today.\n\n> Even if they're restricted in this fashion (must be a 1-in-1 out,\n> sighashall, fees are pre agreed upon), they can still spend that with a CPFP\n> (while still unconfirmed in the mempool) and create another heavy tree,\n> which puts us right back at the same bidding war scenario?\n\nRight, you'd have to use anchor outputs just like we do on the commitment transaction :).\n\n>> There are a bunch of ways of doing pinning - just opting into RBF isn\u2019t\n>> even close to enough.\n> \n> Mhmm, there're other ways of doing pinning. But with anchors as is defined\n> in that spec PR, they're forced to spend with an RBF-replaceable\n> transaction, which means the party wishing to time things out can enter into\n> a bidding war. If the party trying to impeded things participates in this\n> progressive absolute fee increase, it's likely that the war terminates\n> with _one_ of them getting into the block, which seems to resolve\n> everything?\n\nNo? Even if we assume there are no tricks that you can play with, eg, the package limits duri eviction, which I'd be\nsurprised about, the \"absolute fee/feerate\" thing still screws you. The attacker here gets to hold something at the\nbottom of the mempool and the poor honest party is going to have to pay an absurd (likely more than the HTLC value) fee\njust to get it unstuck, whereas the attacker never would have had to pay said fee.\n\n> -- Laolung\n> \n> \n> On Wed, Apr 22, 2020 at 4:20 PM Matt Corallo <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:\n> \n> \n> \n>>     On Apr 22, 2020, at 16:13, Olaoluwa Osuntokun <laolu32 at gmail.com <mailto:laolu32 at gmail.com>> wrote:\n>>\n>>     > Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to\n>>     > braodcasted transactions, but instead to CPFP a maybe-broadcasted\n>>     > transaction by sending a transaction which spends it and seeing if it is\n>>     > accepted\n>>\n>>     Sorry I still don't follow. By \"we clearly need to go the other direction -\n>>     all HTLC output spends need to be pre-signed.\", you don't mean that the HTLC\n>>     spends of the non-broadcaster also need to be an off-chain 2-of-2 multi-sig\n>>     covenant? If the other party isn't restricted w.r.t _how_ they can spend the\n>>     output (non-rbf'd, ect), then I don't see how that addresses anything.\n> \n>     Indeed, that is what I\u2019m suggesting. Anchor output and all. One thing we could think about is only turning it on\n>     over a certain threshold, and having a separate \u201conly-kinda-enforceable-on-chain-HTLC-in-flight\u201d limit.\n> \n>>     Also see my mail elsewhere in the thread that the other party is actually\n>>     forced to spend their HTLC output using an RBF-replaceable transaction. With\n>>     that, I think we're all good here? In the end both sides have the ability to\n>>     raise the fee rate of their spending transactions with the highest winning.\n>>     As long as one of them confirms within the CLTV-delta, then everyone is\n>>     made whole.\n> \n>     It does seem like my cached recollection of RBF opt-in was incorrect but please re-read the intro email. There are a\n>     bunch of ways of doing pinning - just opting into RBF isn\u2019t even close to enough.\n> \n>>     [1]: https://github.com/bitcoin/bitcoin/pull/18191\n>>\n>>\n>>     On Wed, Apr 22, 2020 at 9:50 AM Matt Corallo <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:\n>>\n>>         A few replies inline.\n>>\n>>         On 4/22/20 12:13 AM, Olaoluwa Osuntokun wrote:\n>>         > Hi Matt,\n>>         >\n>>         >\n>>         >> While this is somewhat unintuitive, there are any number of good anti-DoS\n>>         >> reasons for this, eg:\n>>         >\n>>         > None of these really strikes me as \"good\" reasons for this limitation, which\n>>         > is at the root of this issue, and will also plague any more complex Bitcoin\n>>         > contracts which rely on nested trees of transaction to confirm (CTV, Duplex,\n>>         > channel factories, etc). Regarding the various (seemingly arbitrary) package\n>>         > limits it's likely the case that any issues w.r.t computational complexity\n>>         > that may arise when trying to calculate evictions can be ameliorated with\n>>         > better choice of internal data structures.\n>>         >\n>>         > In the end, the simplest heuristic (accept the higher fee rate package) side\n>>         > steps all these issues and is also the most economically rationale from a\n>>         > miner's perspective. Why would one prefer a higher absolute fee package\n>>         > (which could be very large) over another package with a higher total _fee\n>>         > rate_?\n>>\n>>         This seems like a somewhat unnecessary drive-by insult of a project you don't contribute to, but feel free to\n>>         start with\n>>         a concrete suggestion here :).\n>>\n>>         >> You'll note that B would be just fine if they had a way to safely monitor the\n>>         >> global mempool, and while this seems like a prudent mitigation for\n>>         >> lightning implementations to deploy today, it is itself a quagmire of\n>>         >> complexity\n>>         >\n>>         > Is it really all that complex? Assuming we're talking about just watching\n>>         > for a certain script template (the HTLC scipt) in the mempool to be able to\n>>         > pull a pre-image as soon as possible. Early versions of lnd used the mempool\n>>         > for commitment broadcast detection (which turned out to be a bad idea so we\n>>         > removed it), but at a glance I don't see why watching the mempool is so\n>>         > complex.\n>>\n>>         Because watching your own mempool is not guaranteed to work, and during upgrade cycles that include changes to the\n>>         policy rules an attacker could exploit your upgraded/non-upgraded status to perform the same attack.\n>>\n>>         >> Further, this is a really obnoxious assumption to hoist onto lightning\n>>         >> nodes - having an active full node with an in-sync mempool is a lot more\n>>         >> CPU, bandwidth, and complexity than most lightning users were expecting to\n>>         >> face.\n>>         >\n>>         > This would only be a requirement for Lightning nodes that seek to be a part\n>>         > of the public routing network with a desire to _forward_ HTLCs. This isn't\n>>         > doesn't affect laptops or mobile phones which likely mostly have private\n>>         > channels and don't participate in HTLC forwarding. I think it's pretty\n>>         > reasonable to expect a \"proper\" routing node on the network to be backed by\n>>         > a full-node. The bandwidth concern is valid, but we'd need concrete numbers\n>>         > that compare the bandwidth over head of mempool awareness (assuming the\n>>         > latest and greatest mempool syncing) compared with the overhead of the\n>>         > channel update gossip and gossip queries over head which LN nodes face today\n>>         > as is to see how much worse off they really would be.\n>>\n>>         If mempool-watching were practical, maybe, though there are a number of folks who are talking about designing\n>>         partially-offline local lightning hubs which would be rendered impractical.\n>>\n>>         > As detailed a bit below, if nodes watch the mempool, then this class of\n>>         > attack assuming the anchor output format as described in the open\n>>         > lightning-rfc PR is mitigated. At a glance, watching the mempool seems like\n>>         > a far less involved process compared to modifying the state machine as its\n>>         > defined today. By watching the mempool and implementing the changes in\n>>         > #lightning-rfc/688, then this issue can be mitigated _today_. lnd 0.10\n>>         > doesn't yet watch the mempool (but does include anchors [1]), but unless I'm\n>>         > missing something it should be pretty straight forward to add which mor or less\n>>         > resolves this issue all together.\n>>         >\n>>         >> not fixing this issue seems to render the whole exercise somewhat useless\n>>         >\n>>         > Depends on if one considers watching the mempool a fix. But even with that a\n>>         > base version of anchors still resolves a number of issues including:\n>>         > eliminating the commitment fee guessing game, allowing users to pay less on\n>>         > force close, being able to coalesce 2nd level HTLC transactions with the\n>>         > same CLTV expiry, and actually being able to reliably enforce multi-hop HTLC\n>>         > resolution.\n>>         >\n>>         >> Instead of making the HTLC output spending more free-form with\n>>         >> SIGHASH_ANYONECAN_PAY|SIGHASH_SINGLE, we clearly need to go the other\n>>         >> direction - all HTLC output spends need to be pre-signed.\n>>         >\n>>         > I'm not sure this is actually immediately workable (need to think about it\n>>         > more). To see why, remember that the commit_sig message includes HTLC\n>>         > signatures for the _remote_ party's commitment transaction, so they can\n>>         > spend the HTLCs if they broadcast their version of the commitment (force\n>>         > close). If we don't somehow also _gain_ signatures (our new HTLC signatures)\n>>         > allowing us to spend HTLCs on _their_ version of the commitment, then if\n>>         > they broadcast that commitment (without revoking), then we're unable to\n>>         > redeem any of those HTLCs at all, possibly losing money.\n>>\n>>         Hmm, maybe the proposal wasn't clear. The idea isn't to add signatures to braodcasted transactions, but\n>>         instead to CPFP\n>>         a maybe-broadcasted transaction by sending a transaction which spends it and seeing if it is accepted. You\n>>         only need to\n>>         know the transaction's exact format (ie txid, which we do, since we sent a signature for it long ago) to do\n>>         this, you\n>>         don't have to actually *have* the fully-signed transaction (and you don't).\n>>\n>>         > In an attempt to counteract this, we might say ok, the revoke message also\n>>         > now includes HTLC signatures for their new commitment allowing us to spend\n>>         > our HTLCs. This resolves things in a weaker security model, but doesn't\n>>         > address the issue generally, as after they receive the commit_sig, they can\n>>         > broadcast immediately, again leaving us without a way to redeem our HTLCs.\n>>         >\n>>         > I'd need to think about it more, but it seems that following this path would\n>>         > require an overhaul in the channel state machine to make presenting a new\n>>         > commitment actually take at least _two phases_ (at least a full round trip).\n>>         > The first phase would tender the commitment, but render them unable to\n>>         > broadcast it. The second phase would then <insert something something\n>>         > scriptless scripts here> enter a new sub-protocol which upon conclusion,\n>>         > gives the commitment proposer valid HTLC signatures, and gives the responder\n>>         > what they need to be able to broadcast their commitment and claim their\n>>         > HTCLs in an atomic manner.\n>>         >\n>>         > -- Laolu\n>>         >\n>>         > [1]: https://github.com/lightningnetwork/lnd/pull/3821\n>>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T04:50:09",
                "message_text_only": "Good morning lists et al,\n\nLet me try to summarize things a little:\n\n* Suppose we have a forwarding payment A->B->C.\n* Suppose B does not want to maintain a mempool and is running in `blocksonly` mode to reduce operational costs.\n* C triggers B somehow dropping the B<->C channel, such as by sending an `error` message, which will usually cause the other side to drop the channel onchain using its commitment transaction.\n* The dropped B<->C channel has an HTLC (that was set up during the A->B->C forwarding).\n* The HTLC, being used in a Poon-Dryja channel, actually has the following contract text:\n  * The fund may be claimed by either of these clauses:\n    * C can claim, if C shows the preimage of some hash H (hashlock branch).\n    * B and C must agree, and claim after time L (timelock branch).\n* B holds a signature from C that can claim the timelock branch of the HTLC, for a transaction that spends to an output with an `OP_CHECKSEQUENCEVERIFY`.\n  * The signature is `SIGHASH_ALL`, so the transaction has a fixed feerate.\n* C can \"pin\" the HTLC output by spending using the hashlock branch, and creating a large fee, low fee-rate (tree of) transactions.\n  * As it is a low fee-rate, miners have no incentive to put this in a block, especially if unrelated higher-fee-rate transactions exist that would earn them more money.\n  * Even in a full RBF universe, because of the anti-DoS mempool rules, B cannot evict this pinned transaction by just bidding up the feerate.\n    * A replacing transaction cannot evict alternatives unless its absolute fee is greater than the absolute fee of the alternative.\n    * The pinning transaction has a high fee, but is blockspace-wasteful, so it is:\n      * Undesirable to mine (low feerate).\n      * Difficult to evict (high fee).\n* Thus, B is unable to get its timelock-branch transaction in the mempools of miners.\n* C waits until the A->B HTLC times out, then:\n  * C directly contacts miners with an out-of-band proposal to replace its transaction with an alternative that is much smaller and has a low fee, but much better feerate.\n  * Miners, being economically rational, accept this proposal and include this in a block.\n\nThe proposal by Matt is then:\n\n* The hashlock branch should instead be:\n  * B and C must agree, and show the preimage of some hash H (hashlock branch).\n* Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n  * Normal payment to C.\n  * Hook output to B, which B can use to CPFP this transaction.\n  * Hook output to C, which C can use to CPFP this transaction.\n* B can still (somehow) not maintain a mempool, by:\n  * B broadcasts its timelock transaction.\n  * B tries to CPFP the above hashlock transaction.\n    * If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n\nIs that a fair summary?\n\n--\n\nNaively, and remembering I am completely ignorant of the exact details of the mempool rules, it seems to me quite strange that we are allowing an undesirable transaction (tree) into the mempool:\n\n* Undesirable to mine (low fee-rate).\n* Difficult to evict (high fee).\n\nMiners are not interested in low fee-rate transactions, as long as higher fee-rate transactions exist.\nAnd being difficult to evict means miners cannot get alternatives that are more lucrative for them.\n\nThe reason (as I understand it) eviction is purposely made difficult here is to prevent certain DoS attacks on Bitcoin nodes, specifically:\n\n1. Attacker sends a low fee-rate tx as a \"root\" transaction.\n2  Attacker sends thousands of low fee-rate tx that build off the above root.\n3. Attacker sends a slightly higher fee-rate alternative to the root, evicting the above tree of txes.\n4. Attacker sends thousands of low fee-rate tx that build off the latest root.\n5. GOTO 3.\n\nHowever, it seems to me, naively, that \"an ounce of prevention is worth a pound of cure\".\n\nAs I understand it, the mempool is organized already into \"packages\" of transactions, and adding a transaction into the mempool involves extending and merging packages.\nPerhaps the size of a package with low fee-rate (relative to the other packages in the mempool) can be limited, so that mempools drop incoming txes that extend a low-fee-rate tree of transactions.\nThis means an attacker cannot send thousands of low fee-rate tx that build off some low fee-rate root tx in the first place, so it can still be evicted easily later without much impact.\n\nNaively, it seems to me to prevent the DoS attack as well, as at step 2 it would be prevented from sending thousands of low fee-rate tx building off the root.\n\nAs well, as I understand it, this merely tightens the mempool acceptance rules, preventing low fee-rate packages from growing (analogous to a consensus-layer softfork).\nThe \"cannot evict high absolute fee\" rule can be retained, as the low-fee-rate package is prevented from reaching a large size.\n\nWould that be workable as a general solution to solve (what I think is) the root cause of this problem?\n\n(This assumes full RBF, I suppose.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-23T06:21:50",
                "message_text_only": "Great summary, a few notes inline.\n\n> On Apr 22, 2020, at 21:50, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> \ufeffGood morning lists et al,\n> \n> Let me try to summarize things a little:\n> \n> * Suppose we have a forwarding payment A->B->C.\n> * Suppose B does not want to maintain a mempool and is running in `blocksonly` mode to reduce operational costs.\n\nQuick point of clarification, due to the mempool lacking a consensus system (that\u2019s the whole point, after all :p), there are several reasons to that just running a full node/having a mempool isn\u2019t sufficient.\n\n> * C triggers B somehow dropping the B<->C channel, such as by sending an `error` message, which will usually cause the other side to drop the channel onchain using its commitment transaction.\n> * The dropped B<->C channel has an HTLC (that was set up during the A->B->C forwarding).\n> * The HTLC, being used in a Poon-Dryja channel, actually has the following contract text:\n> * The fund may be claimed by either of these clauses:\n> * C can claim, if C shows the preimage of some hash H (hashlock branch).\n> * B and C must agree, and claim after time L (timelock branch).\n> * B holds a signature from C that can claim the timelock branch of the HTLC, for a transaction that spends to an output with an `OP_CHECKSEQUENCEVERIFY`.\n> * The signature is `SIGHASH_ALL`, so the transaction has a fixed feerate.\n> * C can \"pin\" the HTLC output by spending using the hashlock branch, and creating a large fee, low fee-rate (tree of) transactions.\n\nAnother: this is the simplest example. There are also games around the package size limits if I recall correctly.\n\n> * As it is a low fee-rate, miners have no incentive to put this in a block, especially if unrelated higher-fee-rate transactions exist that would earn them more money.\n> * Even in a full RBF universe, because of the anti-DoS mempool rules, B cannot evict this pinned transaction by just bidding up the feerate.\n> * A replacing transaction cannot evict alternatives unless its absolute fee is greater than the absolute fee of the alternative.\n> * The pinning transaction has a high fee, but is blockspace-wasteful, so it is:\n>   * Undesirable to mine (low feerate).\n>   * Difficult to evict (high fee).\n> * Thus, B is unable to get its timelock-branch transaction in the mempools of miners.\n> * C waits until the A->B HTLC times out, then:\n> * C directly contacts miners with an out-of-band proposal to replace its transaction with an alternative that is much smaller and has a low fee, but much better feerate.\n\nOr they can just wait. For example in today\u2019s mempool it would not be strange for a transaction at 1 sat/vbyte to wait a day but eventually confirm.\n\n> * Miners, being economically rational, accept this proposal and include this in a block.\n> \n> The proposal by Matt is then:\n> \n> * The hashlock branch should instead be:\n> * B and C must agree, and show the preimage of some hash H (hashlock branch).\n> * Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n> * Normal payment to C.\n> * Hook output to B, which B can use to CPFP this transaction.\n> * Hook output to C, which C can use to CPFP this transaction.\n> * B can still (somehow) not maintain a mempool, by:\n> * B broadcasts its timelock transaction.\n> * B tries to CPFP the above hashlock transaction.\n> * If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n\nNote that no query is required. The problem has been solved and the preimage-containing transaction should now confirm just fine.\n\n> Is that a fair summary?\n\nYep!\n\n> --\n> \n> Naively, and remembering I am completely ignorant of the exact details of the mempool rules, it seems to me quite strange that we are allowing an undesirable transaction (tree) into the mempool:\n> \n> * Undesirable to mine (low fee-rate).\n> * Difficult to evict (high fee).\n\nAs noted, such transactions today are profit in 10 hours. Just because they\u2019re big doesn\u2019t mean they don\u2019t pay.\n\n> Miners are not interested in low fee-rate transactions, as long as higher fee-rate transactions exist.\n> And being difficult to evict means miners cannot get alternatives that are more lucrative for them.\n> \n> The reason (as I understand it) eviction is purposely made difficult here is to prevent certain DoS attacks on Bitcoin nodes, specifically:\n> \n> 1. Attacker sends a low fee-rate tx as a \"root\" transaction.\n> 2  Attacker sends thousands of low fee-rate tx that build off the above root.\n\nI believe the limit is 25, though the point stands, mostly from a total-size perspective.\n\n> 3. Attacker sends a slightly higher fee-rate alternative to the root, evicting the above tree of txes.\n> 4. Attacker sends thousands of low fee-rate tx that build off the latest root.\n> 5. GOTO 3.\n> \n> However, it seems to me, naively, that \"an ounce of prevention is worth a pound of cure\".\n\nSadly, it\u2019s very very easy for this to be a huge amount of CPU + bandwidth.\n\n> As I understand it, the mempool is organized already into \"packages\" of transactions, and adding a transaction into the mempool involves extending and merging packages.\n> Perhaps the size of a package with low fee-rate (relative to the other packages in the mempool) can be limited, so that mempools drop incoming txes that extend a low-fee-rate tree of transactions.\n> This means an attacker cannot send thousands of low fee-rate tx that build off some low fee-rate root tx in the first place, so it can still be evicted easily later without much impact.\n\nThere have been several proposals before around considering a transactions position in the mempool for various similar criteria. The extreme version being simply heavily rate-limiting transaction relay at low feerates and allowing much more liberal replacement of such packages. It isn\u2019t quite perfect for this issue, though, as it may be easy for the attacker to just fill that rate-limit bucket.\n\n> Naively, it seems to me to prevent the DoS attack as well, as at step 2 it would be prevented from sending thousands of low fee-rate tx building off the root.\n> \n> As well, as I understand it, this merely tightens the mempool acceptance rules, preventing low fee-rate packages from growing (analogous to a consensus-layer softfork).\n> The \"cannot evict high absolute fee\" rule can be retained, as the low-fee-rate package is prevented from reaching a large size.\n> \n> Would that be workable as a general solution to solve (what I think is) the root cause of this problem?\n\nIt\u2019s not clear to me that tightening the acceptance rules wouldn\u2019t break other existing uses. Historically the 25 package size limit has proven to be an issue for users doing (somewhat na\u00efve) centralized wallet withdraws. Sadly many users want that \u201cpayment pending\u201d notification instantly, even if we know it to be somewhat lacking in security. Wallets which have over-compacted their UTXOs are thus stuck making long chains.\n\nTo revive an old discussion, on the original thread proposing the CPFP Carve-Out, I said this:\n\n> As an alternative proposal, at various points there have been discussions around solving the \"RBF-pinning\" problem by allowing transactors to mark their transactions as \"likely-to-be-RBF'ed\", which could enable a relay policy where children of such transactions would be rejected unless the resulting package would be \"near the top of the mempool\". This would theoretically imply such attacks are not possible to pull off consistently, as any \"transaction-delaying\" channel participant will have to place the package containing A at an effective feerate which makes confirmation to occur soon with some likelihood. It is, however, possible to pull off this attack with low probability in case of feerate spikes right after broadcast.\n\nTo which Rusty responded (and I may be paraphrasing here): \u201cFuck Yea\u201d. I\u2019m still not much of a fan of this idea as it introduces too many constants (what is \u201cthe top of the mempool\u201d, anyway?), and it\u2019s unclear to me what you do as the mempool prevailing feerate changes, but it seems more along the lines or what you\u2019re looking for here."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-23T12:46:59",
                "message_text_only": "Good morning Matt,\n\n> > -   C directly contacts miners with an out-of-band proposal to replace its transaction with an alternative that is much smaller and has a low fee, but much better feerate.\n>\n> Or they can just wait. For example in today\u2019s mempool it would not be strange for a transaction at 1 sat/vbyte to wait a day but eventually confirm.\n\nThat introduces the possibility that the entire tree (with high total fee, remember) gets confirmed, so it would be better for C to replace it with an alternative to a different address C still controls, with a slightly better fee rate but smaller (no child transactions) and lower total fee, so an economically-rational C will make that effort (and if there are still other transactions in the mempool, an economically-rational miner will accept this proposal).\n\nBut in any case this is a minor detail and the attack will work either way.\n\n>\n> > -   Miners, being economically rational, accept this proposal and include this in a block.\n> >\n> > The proposal by Matt is then:\n> >\n> > -   The hashlock branch should instead be:\n> > -   B and C must agree, and show the preimage of some hash H (hashlock branch).\n> > -   Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n> > -   Normal payment to C.\n> > -   Hook output to B, which B can use to CPFP this transaction.\n> > -   Hook output to C, which C can use to CPFP this transaction.\n> > -   B can still (somehow) not maintain a mempool, by:\n> > -   B broadcasts its timelock transaction.\n> > -   B tries to CPFP the above hashlock transaction.\n> > -   If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n>\n> Note that no query is required. The problem has been solved and the preimage-containing transaction should now confirm just fine.\n\nAh, right, so it gets confirmed and the `blocksonly` B sees it in a block.\n\nEven if C hooks a tree of low-fee transactions on its hook output or normal payment, miners will still be willing to confirm this and the B hook CPFP transaction without, right?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-04-23T22:47:46",
                "message_text_only": "On 4/23/20 8:46 AM, ZmnSCPxj wrote:\n>>> -   Miners, being economically rational, accept this proposal and include this in a block.\n>>>\n>>> The proposal by Matt is then:\n>>>\n>>> -   The hashlock branch should instead be:\n>>> -   B and C must agree, and show the preimage of some hash H (hashlock branch).\n>>> -   Then B and C agree that B provides a signature spending the hashlock branch, to a transaction with the outputs:\n>>> -   Normal payment to C.\n>>> -   Hook output to B, which B can use to CPFP this transaction.\n>>> -   Hook output to C, which C can use to CPFP this transaction.\n>>> -   B can still (somehow) not maintain a mempool, by:\n>>> -   B broadcasts its timelock transaction.\n>>> -   B tries to CPFP the above hashlock transaction.\n>>> -   If CPFP succeeds, it means the above hashlock transaction exists and B queries the peer for this transaction, extracting the preimage and claiming the A->B HTLC.\n>>\n>> Note that no query is required. The problem has been solved and the preimage-containing transaction should now confirm just fine.\n> \n> Ah, right, so it gets confirmed and the `blocksonly` B sees it in a block.\n> \n> Even if C hooks a tree of low-fee transactions on its hook output or normal payment, miners will still be willing to confirm this and the B hook CPFP transaction without, right?\n\nCorrect, once it makes it into the mempool we can CPFP it and all the regular sub-package CPFP calculation will pick it\nand its descendants up. Of course this relies on it not spending any other unconfirmed inputs."
            },
            {
                "author": "Jeremy",
                "date": "2020-04-23T01:18:05",
                "message_text_only": "Hi everyone,\n\nSorry to just be getting to a response here. Hadn't noticed it till now.\n\n*(Plug: If anyone or their organizations would like to assist in funding\nthe work described below for a group of developers, I've been working to\nput resources together for funding the above for a few months now, and I\nthink it would be high leverage towards seeing this through. There are a\nlot of unsexy tasks to do  that aren't coming up with a solution\n(e.g.,writing a myriad of Mempool stress test scenarios) that can be a well\ndefined full-time job for someone to do.)*\n\nI've been working on exactly this problem in the mempool for months now.\nI'm deeply familiar with the issues here and the types of pinning possible.\nI think everyone can recognize that with my work on OP_CTV I want nothing\nmore than the mempool to be able to accept whatever long chains we can\nthrow at it, but I'm pretty well steeped at this point in the obstacles to\ndoing that.\n\nI don't think that we should be entertaining further carve outs at the\nmoment, unless it is really trivial. Every new carve out rule added to the\nway that the mempool operates is removing complexity invariants we aim to\npreserve in the mempool in order to keep nodes operational. Many of these\ninvariants are well documented, some are not. I'm happy to go off list for\na more thorough discussion with anyone qualified to have it; this isn't the\nbest venue for that discussion.\n\n>From my point of view the path forward here is to dedicate more development\nresources towards finishing the mempool project I began. You can see the\noutstanding work here: https://github.com/bitcoin/bitcoin/projects/14,\ncontributing review towards moving those PRs forward will greatly improve\nour ability to consider a stopgap carve out measure.\n\nThe current focus of this work is primarily on:\n\n1) Testing Construction to better test & catch regressions or\nvulnerabilities introduced or extant in mempool\n2) Refactoring algorithms in mempool to reduce constant factors &\nasymptotics\n3) Package Relay\n\n\nNone of these fix the exact problem at hand though, but here's part of how\nthey can help us:\n\nIf we finish up the algorithmic refactors I've been working on it seems\nplausible to do a one-off increase of descendants limits to say, 100\ndescendants with no restriction. However, we could use the opportunity to\nuse the 75 descendant increase exclusively for a new carve out, and apply\nsome new stricter rules in that extra space. There are a few anti-pinning\ncountermeasures that you can apply in that space that you would not\ngenerally want in the mempool. An example of one is that any new\ntransaction must pay more feerate and absolute fee than every child in that\nspace. Or that only the highest fee paying branch of the excess\ntransactions are mineable, no others. Another would be disabling RBF past\nthat watermark. In all likelihood, different subsystems interacting with\nthe mempool will require a different set of restrictions each with the\ncurrent architecture, I don't think there's a magic bullet.\n\nPackage relay is a promising approach for a future pinning solution as\nthere are opportunities to attach to packages compact proofs of improved\nfee efficiency for pinned transactions. But the ground work for package\nrelay needs to come first. This is theoretically possible with our current\narchitecture of the mempool and can probably address much of the pinning\nconcerns by replacing pinning with more rational eviction policies.\n\nLonger term I've been working on plans and designs to completely re-do the\nmempool's architecture to make it behave for arbitrary cases. It's possible\nto one day lift all preemptively enforced (e.g., before acceptance)\ndescendants limits, which can solve this problem for good. There is more\nthan one potentially good solution here, and a conjunction of them can be\nused as they affect independent sub systems. But this work will probably\ntake years to complete to the point where restrictions can realistically be\nlifted.\n\nIf developers would like to coordinate resources around completing this\nwork and making more regular progress on it I'm happy to help point people\nto specific tasks that need to be done in order to accelerate this and help\nserialize the work so that we can not get into rebase hell.\n\nOriginally I had the plug at the top as a closing note, but I figured\npeople might miss it.\n\nBest,\n\nJeremy\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/a1e156ab/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-04-22T20:28:13",
                "message_text_only": "On Wed, Apr 22, 2020 at 03:03:29PM -0400, Antoine Riard wrote:\n> > In that case, would it be worth re-implementing something like a BIP61\n> reject message but with an extension that returns the txids of any\n> conflicts?\n> \n> That's an interesting idea, but an attacker can create a local conflict in\n> your mempool\n\nYou don't need a mempool to send a transaction.  You can just open\nconnections to random Bitcoin nodes directly and try sending your\ntransaction.  That's what a lite client is going to do anyway.  If the\npinned transaction is in the mempools of a significant number of Bitcoin\nnodes, then it should take just a few random connections to find one of\nthose nodes, learn about the conflict, and download the pinned\ntransaction.\n\nIf that's not acceptable, you could find some other way to poll a\nsignificant number of people with mempools, e.g. BIP35 mempool messages\nor reusing the payment hash in a bunch of 1 msat probes to LN nodes who\nopt-in to scanning their bitcoind's mempools for a corresponding\npreimage.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/2f72c33e/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "RBF Pinning with Counterparties and Competing Interest",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Matt Corallo",
                "Antoine Riard",
                "Jeremy",
                "Bastien TEINTURIER",
                "David A. Harding",
                "Rusty Russell",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 150133
        }
    },
    {
        "title": "[Lightning-dev] An update on PTLCs",
        "thread_messages": [
            {
                "author": "Nadav Kohen",
                "date": "2020-04-22T14:41:29",
                "message_text_only": "Hello all,\n\nI'd like to give an update on the current state of thinking and coding\nsurrounding replacing Hash-TimeLock Contracts (HTLCs) with Point-TimeLock\nContracts (PTLCs) (aka Payment Hashes -> Payment Points) in hopes of\nsparking interest, discussion, development, etc.\n\n\nWe Want Payment Points!\n-----------------------\n\nUsing point-locks (in PTLCs) instead of hash-locks (in HTLCs) for lightning\npayments is an all around improvement. HTLCs require the use of the same\nhash across payment routes (barring fancy ZKPs which are inferior to PTLCs)\nwhile PTLCs allow for payment de-correlation along routes. For an\nintroduction to the topic, see https://suredbits.com/payment-points-part-1/.\n\nIn addition to improving privacy in this way and protecting against\nwormhole attacks, PTLC-based lightning channels open the door to a large\nvariety of interesting applications that cannot be accomplished with HTLCs:\n\nStuckless (retry-able) Payments with proof of payment (\nhttps://suredbits.com/payment-points-part-2-stuckless-payments/)\n\nEscrow contracts over Lightning (\nhttps://suredbits.com/payment-points-part-3-escrow-contracts/)\n\nHigh/DLOG AMP (\nhttps://docs.google.com/presentation/d/15l4h2_zEY4zXC6n1NqsImcjgA0fovl_lkgkKu1O3QT0/edit#slide=id.g64c15419e7_0_40\n)\n\nStuckless + AMP (an improvement on Boomerang) (\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002239.html\n)\n\nPay-for-signature (\nhttps://suredbits.com/payment-points-part-4-selling-signatures/)\n\nPay-for-commitment (\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002166.html\n)\n\nMonotonic access structures on payment completion (\nhttps://suredbits.com/payment-points-monotone-access-structures/)\n\nIdeal Barrier Escrow Implementation (\nhttps://suredbits.com/payment-points-implementing-barrier-escrows/)\n\nAnd allowing for Barrier Escrows, we can even have\n\nAtomic multi-payment setup (\nhttps://suredbits.com/payment-points-and-barrier-escrows/)\n\nLightning Discreet Log Contract (\nhttps://suredbits.com/discreet-log-contracts-on-lightning-network/)\n\nAtomic multi-payment update (\nhttps://suredbits.com/updating-and-transferring-lightning-payments/)\n\nLightning Discreet Log Contract Novation/Transfer (\nhttps://suredbits.com/transferring-lightning-dlcs/)\n\nThere are likely even more things that can be done with Payment Points so\nmake sure to respond if I've missed any known ones.\n\n\nHow Do We Get Payment Points?\n-----------------------------\n\nEventually, once we have Taproot, we can use 2p-Schnorr adaptor signatures\nin Lightning channels. For a detailed thread by ZmnSCPxj, see here\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n\nIn the meantime, Lloyd has written about a way to do 1p-ECDSA adaptor sigs (\nhttps://github.com/LLFourn/one-time-VES) which can be paired with\nOP_CHECKMULTISIG to allows us to execute PTLCs on Bitcoin today!\n\nNickler has implemented this in a branch of secp256k1 (\nhttps://github.com/jonasnick/secp256k1/pull/14) and I have implemented it\nin Bouncy Castle in Bitcoin-S with some testing against this branch (\nhttps://github.com/nkohen/bitcoin-s-core/tree/bouncy-adaptor). Do note that\nas nickler states on his PR, \"IT IS EXTREMELY DANGEROUS AND RECKLESS TO USE\nTHIS MODULE IN PRODUCTION. DON'T!\"\n\nA demo of an on-chain PTLC I executed using nickler's implementation on the\nbackend + bitcoin-s can be seen here https://youtu.be/w9o4v7Idjno\n\nAnd waxwing did a lovely write-up about the crypto itself\nhttps://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/\n\nI would be very interested in having a fork of (at least) one lightning\nimplementation (or Rust Lightning) to be a proof of concept ECDSA-PTLC node\nwith which we can test and play with the plethora of PTLC-based proposals\nabove.\n\nI believe this would only require a few changes to existing nodes:\n\n1) update_add_ptlc will have a 32 byte x-coordinate (of a point) rather\nthan a 32 byte hash. Additionally the onion's hop_data will contain a 32\nbyte scalar tweak for each hop. As per [link multi-hop locks]. The last\nhop_data will instead include a 32 byte scalar equal to the sum of all\ntweaks.\n\n2) commitment_signed will have 162 byte adaptor ptlc_signatures rather than\nvalid (71/72 byte) ECDSA signatures on PTLC-success transactions.\n\n3) The in-flight outputs on the commitment transaction itself become a\nlittle simpler as we no longer need to explicitly check the payment\npre-image against a hash. Instead, delete all instances of \"OP_HASH160\n<RIPEMD160(payment_hash)> OP_EQUALVERIFY\" in the scripts (leaving the rest\nthe same) and require no pre-image in the witness, only a valid signature.\nThe pre-image check is implicitly enforced by the <remoteptlc_sig> witness\nsince only an adaptor signature was provided by remote so that the payment\npre-image is required to create the valid signature (from which the\npre-image can be then deduced by comparing adaptor and valid signatures).\n\nIf I've missed any other changes that need to happen, do respond with them!\n\nI hope that as a community we can work towards having a PTLC-based\nLightning Network that is safe and stable as soon as possible, and so I\nencourage further thinking, development and expirementation with PTLCs now\nso that when Taproot is finally at our disposal we can cleanly start moving\ntowards a more ideal Lightning :)\n\nBest,\nNadav\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/a0197f12/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-23T01:16:44",
                "message_text_only": "Hi Nadav,\n\nThanks for the updates! Super cool to see this concept continue to evolve\nand integrate new technologies as they pop up.\n\n> I believe this would only require a few changes to existing nodes:\n\nRather than a \"few changes\", this would to date be the largest network-level\nupdate undertaken to the Lightning Network thus far. In the past, we rolled\nout the new onion blob format (which enables changes like this), but none of\nthe intermediate nodes actually need to modify their behavior. New payment\ntypes like MPP+AMP only needed the _end points_ to update making this an\nend-to-end update that has been rolled out so far in a de-synchronized\nmanner.\n\nRe-phrasing deploying this requires changes to: the core channel state\nmachine (the protocol we use to make commitment updates), HTLC scripts,\non-chain HTLC handling and resolution, path finding algorithms (to only see\nout the new PTLC-enabled nodes), invoice changes and onion blob processing.\nI'd caution against underestimating how long all of this will take in\npractice, and the degree of synchronization required to pull it all off\nproperly.\n\nFor a few years now the question we've all been pondering is: do we wait for\nscnhorr to roll out multi-hop locks, or just use the latest ECDSA based\ntechnique? As dual deployment is compatible (we can make the onion blobs for\nboth types the same), a path has always existed to first roll out with the\nlatest ECDSA based technique then follow up later to roll out the schnorr\nversion as well. However there's also a risk here as depending on how\nquickly things can be rolled out, schnorr may become available\nmid-development, which would possibly cause us to reconsider the ECDSA path\nand have the network purely use scnhorr to make things nice and uniform.\n\nZooming out for a bit, the solution space of \"how channels can look post\nscriptless-scripts + taproot\" is rather large [1], and the addition of this\nnew technique allows for an even larger set of deployment possibilities.\nThis latest ECDSA variant is much simpler than the prior ones (which had a\nfew rounds of more involved ZKPs), but since it still uses OP_CMS, it can't\nbe used to modify the funding output.\n\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n\n-- Laolu\n\n\nOn Wed, Apr 22, 2020 at 8:13 AM Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hello all,\n>\n> I'd like to give an update on the current state of thinking and coding\n> surrounding replacing Hash-TimeLock Contracts (HTLCs) with Point-TimeLock\n> Contracts (PTLCs) (aka Payment Hashes -> Payment Points) in hopes of\n> sparking interest, discussion, development, etc.\n>\n>\n> We Want Payment Points!\n> -----------------------\n>\n> Using point-locks (in PTLCs) instead of hash-locks (in HTLCs) for\n> lightning payments is an all around improvement. HTLCs require the use of\n> the same hash across payment routes (barring fancy ZKPs which are inferior\n> to PTLCs) while PTLCs allow for payment de-correlation along routes. For an\n> introduction to the topic, see\n> https://suredbits.com/payment-points-part-1/.\n>\n> In addition to improving privacy in this way and protecting against\n> wormhole attacks, PTLC-based lightning channels open the door to a large\n> variety of interesting applications that cannot be accomplished with HTLCs:\n>\n> Stuckless (retry-able) Payments with proof of payment (\n> https://suredbits.com/payment-points-part-2-stuckless-payments/)\n>\n> Escrow contracts over Lightning (\n> https://suredbits.com/payment-points-part-3-escrow-contracts/)\n>\n> High/DLOG AMP (\n> https://docs.google.com/presentation/d/15l4h2_zEY4zXC6n1NqsImcjgA0fovl_lkgkKu1O3QT0/edit#slide=id.g64c15419e7_0_40\n> )\n>\n> Stuckless + AMP (an improvement on Boomerang) (\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002239.html\n> )\n>\n> Pay-for-signature (\n> https://suredbits.com/payment-points-part-4-selling-signatures/)\n>\n> Pay-for-commitment (\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002166.html\n> )\n>\n> Monotonic access structures on payment completion (\n> https://suredbits.com/payment-points-monotone-access-structures/)\n>\n> Ideal Barrier Escrow Implementation (\n> https://suredbits.com/payment-points-implementing-barrier-escrows/)\n>\n> And allowing for Barrier Escrows, we can even have\n>\n> Atomic multi-payment setup (\n> https://suredbits.com/payment-points-and-barrier-escrows/)\n>\n> Lightning Discreet Log Contract (\n> https://suredbits.com/discreet-log-contracts-on-lightning-network/)\n>\n> Atomic multi-payment update (\n> https://suredbits.com/updating-and-transferring-lightning-payments/)\n>\n> Lightning Discreet Log Contract Novation/Transfer (\n> https://suredbits.com/transferring-lightning-dlcs/)\n>\n> There are likely even more things that can be done with Payment Points so\n> make sure to respond if I've missed any known ones.\n>\n>\n> How Do We Get Payment Points?\n> -----------------------------\n>\n> Eventually, once we have Taproot, we can use 2p-Schnorr adaptor signatures\n> in Lightning channels. For a detailed thread by ZmnSCPxj, see here\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>\n> In the meantime, Lloyd has written about a way to do 1p-ECDSA adaptor sigs\n> (https://github.com/LLFourn/one-time-VES) which can be paired with\n> OP_CHECKMULTISIG to allows us to execute PTLCs on Bitcoin today!\n>\n> Nickler has implemented this in a branch of secp256k1 (\n> https://github.com/jonasnick/secp256k1/pull/14) and I have implemented it\n> in Bouncy Castle in Bitcoin-S with some testing against this branch (\n> https://github.com/nkohen/bitcoin-s-core/tree/bouncy-adaptor). Do note\n> that as nickler states on his PR, \"IT IS EXTREMELY DANGEROUS AND RECKLESS\n> TO USE THIS MODULE IN PRODUCTION. DON'T!\"\n>\n> A demo of an on-chain PTLC I executed using nickler's implementation on\n> the backend + bitcoin-s can be seen here https://youtu.be/w9o4v7Idjno\n>\n> And waxwing did a lovely write-up about the crypto itself\n> https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/\n>\n> I would be very interested in having a fork of (at least) one lightning\n> implementation (or Rust Lightning) to be a proof of concept ECDSA-PTLC node\n> with which we can test and play with the plethora of PTLC-based proposals\n> above.\n>\n> I believe this would only require a few changes to existing nodes:\n>\n> 1) update_add_ptlc will have a 32 byte x-coordinate (of a point) rather\n> than a 32 byte hash. Additionally the onion's hop_data will contain a 32\n> byte scalar tweak for each hop. As per [link multi-hop locks]. The last\n> hop_data will instead include a 32 byte scalar equal to the sum of all\n> tweaks.\n>\n> 2) commitment_signed will have 162 byte adaptor ptlc_signatures rather\n> than valid (71/72 byte) ECDSA signatures on PTLC-success transactions.\n>\n> 3) The in-flight outputs on the commitment transaction itself become a\n> little simpler as we no longer need to explicitly check the payment\n> pre-image against a hash. Instead, delete all instances of \"OP_HASH160\n> <RIPEMD160(payment_hash)> OP_EQUALVERIFY\" in the scripts (leaving the rest\n> the same) and require no pre-image in the witness, only a valid signature.\n> The pre-image check is implicitly enforced by the <remoteptlc_sig> witness\n> since only an adaptor signature was provided by remote so that the payment\n> pre-image is required to create the valid signature (from which the\n> pre-image can be then deduced by comparing adaptor and valid signatures).\n>\n> If I've missed any other changes that need to happen, do respond with them!\n>\n> I hope that as a community we can work towards having a PTLC-based\n> Lightning Network that is safe and stable as soon as possible, and so I\n> encourage further thinking, development and expirementation with PTLCs now\n> so that when Taproot is finally at our disposal we can cleanly start moving\n> towards a more ideal Lightning :)\n>\n> Best,\n> Nadav\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200422/9849bd91/attachment-0001.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-04-23T14:52:31",
                "message_text_only": "Hi Laolu,\n\nThanks for the response :)\n\nI agree that some more framing probably would have been good to have in my\nupdate.\n\nFirst, I want to clarify that my intention is not to implement a PTLC-based\nlightning network on top of ECDSA adaptor signatures, as I do believe that\nusing Schnorr will be superior, but rather I wish to get some PoC sandbox\nwith which to start implementing and testing out the long list of currently\ntheoretical proposals surrounding PTLCs, most of which are implementation\nagnostic (to a degree anyway). I think it would be super beneficial to have\nmore fleshed out with respect to what some challenges of a Payment Point LN\nare going to be than we understand now, before Schnorr is implemented and\nit is time to commit to some PTLC scheme for real.\n\nSecond, I agree that I've probably understated somewhat the changes that\nwill be needed in most implementations as I was mostly thinking about what\nwould need to change in the BOLTs, which does actually seem relatively\nminimal (although as you mention, these minimal changes to the BOLTs do\ntrigger large changes in many implementations). Also, good point on how\nBOLT 11 (invoicing) will have to be altered as well, must've slipped my\nmind.\n\nBest,\nNadav\n\nOn Wed, Apr 22, 2020 at 8:17 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Hi Nadav,\n>\n> Thanks for the updates! Super cool to see this concept continue to evolve\n> and integrate new technologies as they pop up.\n>\n> > I believe this would only require a few changes to existing nodes:\n>\n> Rather than a \"few changes\", this would to date be the largest\n> network-level\n> update undertaken to the Lightning Network thus far. In the past, we rolled\n> out the new onion blob format (which enables changes like this), but none\n> of\n> the intermediate nodes actually need to modify their behavior. New payment\n> types like MPP+AMP only needed the _end points_ to update making this an\n> end-to-end update that has been rolled out so far in a de-synchronized\n> manner.\n>\n> Re-phrasing deploying this requires changes to: the core channel state\n> machine (the protocol we use to make commitment updates), HTLC scripts,\n> on-chain HTLC handling and resolution, path finding algorithms (to only see\n> out the new PTLC-enabled nodes), invoice changes and onion blob processing.\n> I'd caution against underestimating how long all of this will take in\n> practice, and the degree of synchronization required to pull it all off\n> properly.\n>\n> For a few years now the question we've all been pondering is: do we wait\n> for\n> scnhorr to roll out multi-hop locks, or just use the latest ECDSA based\n> technique? As dual deployment is compatible (we can make the onion blobs\n> for\n> both types the same), a path has always existed to first roll out with the\n> latest ECDSA based technique then follow up later to roll out the schnorr\n> version as well. However there's also a risk here as depending on how\n> quickly things can be rolled out, schnorr may become available\n> mid-development, which would possibly cause us to reconsider the ECDSA path\n> and have the network purely use scnhorr to make things nice and uniform.\n>\n> Zooming out for a bit, the solution space of \"how channels can look post\n> scriptless-scripts + taproot\" is rather large [1], and the addition of this\n> new technique allows for an even larger set of deployment possibilities.\n> This latest ECDSA variant is much simpler than the prior ones (which had a\n> few rounds of more involved ZKPs), but since it still uses OP_CMS, it can't\n> be used to modify the funding output.\n>\n> [1]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>\n> -- Laolu\n>\n>\n> On Wed, Apr 22, 2020 at 8:13 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>\n>> Hello all,\n>>\n>> I'd like to give an update on the current state of thinking and coding\n>> surrounding replacing Hash-TimeLock Contracts (HTLCs) with Point-TimeLock\n>> Contracts (PTLCs) (aka Payment Hashes -> Payment Points) in hopes of\n>> sparking interest, discussion, development, etc.\n>>\n>>\n>> We Want Payment Points!\n>> -----------------------\n>>\n>> Using point-locks (in PTLCs) instead of hash-locks (in HTLCs) for\n>> lightning payments is an all around improvement. HTLCs require the use of\n>> the same hash across payment routes (barring fancy ZKPs which are inferior\n>> to PTLCs) while PTLCs allow for payment de-correlation along routes. For an\n>> introduction to the topic, see\n>> https://suredbits.com/payment-points-part-1/.\n>>\n>> In addition to improving privacy in this way and protecting against\n>> wormhole attacks, PTLC-based lightning channels open the door to a large\n>> variety of interesting applications that cannot be accomplished with HTLCs:\n>>\n>> Stuckless (retry-able) Payments with proof of payment (\n>> https://suredbits.com/payment-points-part-2-stuckless-payments/)\n>>\n>> Escrow contracts over Lightning (\n>> https://suredbits.com/payment-points-part-3-escrow-contracts/)\n>>\n>> High/DLOG AMP (\n>> https://docs.google.com/presentation/d/15l4h2_zEY4zXC6n1NqsImcjgA0fovl_lkgkKu1O3QT0/edit#slide=id.g64c15419e7_0_40\n>> )\n>>\n>> Stuckless + AMP (an improvement on Boomerang) (\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002239.html\n>> )\n>>\n>> Pay-for-signature (\n>> https://suredbits.com/payment-points-part-4-selling-signatures/)\n>>\n>> Pay-for-commitment (\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002166.html\n>> )\n>>\n>> Monotonic access structures on payment completion (\n>> https://suredbits.com/payment-points-monotone-access-structures/)\n>>\n>> Ideal Barrier Escrow Implementation (\n>> https://suredbits.com/payment-points-implementing-barrier-escrows/)\n>>\n>> And allowing for Barrier Escrows, we can even have\n>>\n>> Atomic multi-payment setup (\n>> https://suredbits.com/payment-points-and-barrier-escrows/)\n>>\n>> Lightning Discreet Log Contract (\n>> https://suredbits.com/discreet-log-contracts-on-lightning-network/)\n>>\n>> Atomic multi-payment update (\n>> https://suredbits.com/updating-and-transferring-lightning-payments/)\n>>\n>> Lightning Discreet Log Contract Novation/Transfer (\n>> https://suredbits.com/transferring-lightning-dlcs/)\n>>\n>> There are likely even more things that can be done with Payment Points so\n>> make sure to respond if I've missed any known ones.\n>>\n>>\n>> How Do We Get Payment Points?\n>> -----------------------------\n>>\n>> Eventually, once we have Taproot, we can use 2p-Schnorr adaptor\n>> signatures in Lightning channels. For a detailed thread by ZmnSCPxj, see\n>> here\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>>\n>> In the meantime, Lloyd has written about a way to do 1p-ECDSA adaptor\n>> sigs (https://github.com/LLFourn/one-time-VES) which can be paired with\n>> OP_CHECKMULTISIG to allows us to execute PTLCs on Bitcoin today!\n>>\n>> Nickler has implemented this in a branch of secp256k1 (\n>> https://github.com/jonasnick/secp256k1/pull/14) and I have implemented\n>> it in Bouncy Castle in Bitcoin-S with some testing against this branch (\n>> https://github.com/nkohen/bitcoin-s-core/tree/bouncy-adaptor). Do note\n>> that as nickler states on his PR, \"IT IS EXTREMELY DANGEROUS AND RECKLESS\n>> TO USE THIS MODULE IN PRODUCTION. DON'T!\"\n>>\n>> A demo of an on-chain PTLC I executed using nickler's implementation on\n>> the backend + bitcoin-s can be seen here https://youtu.be/w9o4v7Idjno\n>>\n>> And waxwing did a lovely write-up about the crypto itself\n>> https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/\n>>\n>> I would be very interested in having a fork of (at least) one lightning\n>> implementation (or Rust Lightning) to be a proof of concept ECDSA-PTLC node\n>> with which we can test and play with the plethora of PTLC-based proposals\n>> above.\n>>\n>> I believe this would only require a few changes to existing nodes:\n>>\n>> 1) update_add_ptlc will have a 32 byte x-coordinate (of a point) rather\n>> than a 32 byte hash. Additionally the onion's hop_data will contain a 32\n>> byte scalar tweak for each hop. As per [link multi-hop locks]. The last\n>> hop_data will instead include a 32 byte scalar equal to the sum of all\n>> tweaks.\n>>\n>> 2) commitment_signed will have 162 byte adaptor ptlc_signatures rather\n>> than valid (71/72 byte) ECDSA signatures on PTLC-success transactions.\n>>\n>> 3) The in-flight outputs on the commitment transaction itself become a\n>> little simpler as we no longer need to explicitly check the payment\n>> pre-image against a hash. Instead, delete all instances of \"OP_HASH160\n>> <RIPEMD160(payment_hash)> OP_EQUALVERIFY\" in the scripts (leaving the rest\n>> the same) and require no pre-image in the witness, only a valid signature.\n>> The pre-image check is implicitly enforced by the <remoteptlc_sig> witness\n>> since only an adaptor signature was provided by remote so that the payment\n>> pre-image is required to create the valid signature (from which the\n>> pre-image can be then deduced by comparing adaptor and valid signatures).\n>>\n>> If I've missed any other changes that need to happen, do respond with\n>> them!\n>>\n>> I hope that as a community we can work towards having a PTLC-based\n>> Lightning Network that is safe and stable as soon as possible, and so I\n>> encourage further thinking, development and expirementation with PTLCs now\n>> so that when Taproot is finally at our disposal we can cleanly start moving\n>> towards a more ideal Lightning :)\n>>\n>> Best,\n>> Nadav\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200423/a75c29ad/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-04-24T02:41:53",
                "message_text_only": "(this may be kind of off-topic, more about DLC deployment than PTLCs\nthemselves)\n\n>From my PoV, new technologies aren't what has held back DLC deployment to\nthis date since the paper was originally released. Tadge has had working\ncode than can be deployed today for some time now, and other parties like\nDG-Lab have created full-fledge demos with the system working end to end.\nInstead, the real impediment has been the bootstrapping of the oracles\nwhich the scheme critically depends upon.\n\nWithout oracles, none of it really works. Although, it's also the case that\nthere're measures to prevent the oracles from equivocating (reporting two\nconflicting prices/events for a particular instance), bootstrapping a new\noracle still requires a very high degree of trust as they can lie or report\nincorrect data. As a result, actually deploying an oracle for a system like\nthis is tricky business, as it's a trusted centralized entity, so it will\nrun into all the normal meatspace/legal/operational risk that any trusted\ncentralized service would encounter.\n\nEarlier today, Coinbase announced that they were releasing a new price\noracle for the ETH ecosystem [1]. This caught my attention as one can\nimagine, that it would be even simpler for them to deploy a DLC oracle which\nexports an API to obtain signed prices/events. As an existing large company\nin the space (depending on who you talk to), they're a trusted entity, which\nhas earned a good reputation over the years (solving this\nbootstrapping/trust issue). If they do eventually grow the service to also\nencompass this use case, then it enables a number of possibilities, as\nthere's still a ton of value in just base DLC-specific channels (or one off\ncontracts), without all the fancy barrier escrow scriptless scipts swappy\nswap swap stuff.\n\n-- Laolu\n\n[1]:\nhttps://blog.coinbase.com/introducing-the-coinbase-price-oracle-6d1ee22c7068\n\n\nOn Thu, Apr 23, 2020 at 7:52 AM Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hi Laolu,\n>\n> Thanks for the response :)\n>\n> I agree that some more framing probably would have been good to have in my\n> update.\n>\n> First, I want to clarify that my intention is not to implement a\n> PTLC-based lightning network on top of ECDSA adaptor signatures, as I do\n> believe that using Schnorr will be superior, but rather I wish to get some\n> PoC sandbox with which to start implementing and testing out the long list\n> of currently theoretical proposals surrounding PTLCs, most of which are\n> implementation agnostic (to a degree anyway). I think it would be super\n> beneficial to have more fleshed out with respect to what some challenges of\n> a Payment Point LN are going to be than we understand now, before Schnorr\n> is implemented and it is time to commit to some PTLC scheme for real.\n>\n> Second, I agree that I've probably understated somewhat the changes that\n> will be needed in most implementations as I was mostly thinking about what\n> would need to change in the BOLTs, which does actually seem relatively\n> minimal (although as you mention, these minimal changes to the BOLTs do\n> trigger large changes in many implementations). Also, good point on how\n> BOLT 11 (invoicing) will have to be altered as well, must've slipped my\n> mind.\n>\n> Best,\n> Nadav\n>\n> On Wed, Apr 22, 2020 at 8:17 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n> wrote:\n>\n>> Hi Nadav,\n>>\n>> Thanks for the updates! Super cool to see this concept continue to evolve\n>> and integrate new technologies as they pop up.\n>>\n>> > I believe this would only require a few changes to existing nodes:\n>>\n>> Rather than a \"few changes\", this would to date be the largest\n>> network-level\n>> update undertaken to the Lightning Network thus far. In the past, we\n>> rolled\n>> out the new onion blob format (which enables changes like this), but none\n>> of\n>> the intermediate nodes actually need to modify their behavior. New payment\n>> types like MPP+AMP only needed the _end points_ to update making this an\n>> end-to-end update that has been rolled out so far in a de-synchronized\n>> manner.\n>>\n>> Re-phrasing deploying this requires changes to: the core channel state\n>> machine (the protocol we use to make commitment updates), HTLC scripts,\n>> on-chain HTLC handling and resolution, path finding algorithms (to only\n>> see\n>> out the new PTLC-enabled nodes), invoice changes and onion blob\n>> processing.\n>> I'd caution against underestimating how long all of this will take in\n>> practice, and the degree of synchronization required to pull it all off\n>> properly.\n>>\n>> For a few years now the question we've all been pondering is: do we wait\n>> for\n>> scnhorr to roll out multi-hop locks, or just use the latest ECDSA based\n>> technique? As dual deployment is compatible (we can make the onion blobs\n>> for\n>> both types the same), a path has always existed to first roll out with the\n>> latest ECDSA based technique then follow up later to roll out the schnorr\n>> version as well. However there's also a risk here as depending on how\n>> quickly things can be rolled out, schnorr may become available\n>> mid-development, which would possibly cause us to reconsider the ECDSA\n>> path\n>> and have the network purely use scnhorr to make things nice and uniform.\n>>\n>> Zooming out for a bit, the solution space of \"how channels can look post\n>> scriptless-scripts + taproot\" is rather large [1], and the addition of\n>> this\n>> new technique allows for an even larger set of deployment possibilities.\n>> This latest ECDSA variant is much simpler than the prior ones (which had a\n>> few rounds of more involved ZKPs), but since it still uses OP_CMS, it\n>> can't\n>> be used to modify the funding output.\n>>\n>> [1]:\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>>\n>> -- Laolu\n>>\n>>\n>> On Wed, Apr 22, 2020 at 8:13 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>>\n>>> Hello all,\n>>>\n>>> I'd like to give an update on the current state of thinking and coding\n>>> surrounding replacing Hash-TimeLock Contracts (HTLCs) with Point-TimeLock\n>>> Contracts (PTLCs) (aka Payment Hashes -> Payment Points) in hopes of\n>>> sparking interest, discussion, development, etc.\n>>>\n>>>\n>>> We Want Payment Points!\n>>> -----------------------\n>>>\n>>> Using point-locks (in PTLCs) instead of hash-locks (in HTLCs) for\n>>> lightning payments is an all around improvement. HTLCs require the use of\n>>> the same hash across payment routes (barring fancy ZKPs which are inferior\n>>> to PTLCs) while PTLCs allow for payment de-correlation along routes. For an\n>>> introduction to the topic, see\n>>> https://suredbits.com/payment-points-part-1/.\n>>>\n>>> In addition to improving privacy in this way and protecting against\n>>> wormhole attacks, PTLC-based lightning channels open the door to a large\n>>> variety of interesting applications that cannot be accomplished with HTLCs:\n>>>\n>>> Stuckless (retry-able) Payments with proof of payment (\n>>> https://suredbits.com/payment-points-part-2-stuckless-payments/)\n>>>\n>>> Escrow contracts over Lightning (\n>>> https://suredbits.com/payment-points-part-3-escrow-contracts/)\n>>>\n>>> High/DLOG AMP (\n>>> https://docs.google.com/presentation/d/15l4h2_zEY4zXC6n1NqsImcjgA0fovl_lkgkKu1O3QT0/edit#slide=id.g64c15419e7_0_40\n>>> )\n>>>\n>>> Stuckless + AMP (an improvement on Boomerang) (\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002239.html\n>>> )\n>>>\n>>> Pay-for-signature (\n>>> https://suredbits.com/payment-points-part-4-selling-signatures/)\n>>>\n>>> Pay-for-commitment (\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002166.html\n>>> )\n>>>\n>>> Monotonic access structures on payment completion (\n>>> https://suredbits.com/payment-points-monotone-access-structures/)\n>>>\n>>> Ideal Barrier Escrow Implementation (\n>>> https://suredbits.com/payment-points-implementing-barrier-escrows/)\n>>>\n>>> And allowing for Barrier Escrows, we can even have\n>>>\n>>> Atomic multi-payment setup (\n>>> https://suredbits.com/payment-points-and-barrier-escrows/)\n>>>\n>>> Lightning Discreet Log Contract (\n>>> https://suredbits.com/discreet-log-contracts-on-lightning-network/)\n>>>\n>>> Atomic multi-payment update (\n>>> https://suredbits.com/updating-and-transferring-lightning-payments/)\n>>>\n>>> Lightning Discreet Log Contract Novation/Transfer (\n>>> https://suredbits.com/transferring-lightning-dlcs/)\n>>>\n>>> There are likely even more things that can be done with Payment Points\n>>> so make sure to respond if I've missed any known ones.\n>>>\n>>>\n>>> How Do We Get Payment Points?\n>>> -----------------------------\n>>>\n>>> Eventually, once we have Taproot, we can use 2p-Schnorr adaptor\n>>> signatures in Lightning channels. For a detailed thread by ZmnSCPxj, see\n>>> here\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>>>\n>>> In the meantime, Lloyd has written about a way to do 1p-ECDSA adaptor\n>>> sigs (https://github.com/LLFourn/one-time-VES) which can be paired with\n>>> OP_CHECKMULTISIG to allows us to execute PTLCs on Bitcoin today!\n>>>\n>>> Nickler has implemented this in a branch of secp256k1 (\n>>> https://github.com/jonasnick/secp256k1/pull/14) and I have implemented\n>>> it in Bouncy Castle in Bitcoin-S with some testing against this branch (\n>>> https://github.com/nkohen/bitcoin-s-core/tree/bouncy-adaptor). Do note\n>>> that as nickler states on his PR, \"IT IS EXTREMELY DANGEROUS AND RECKLESS\n>>> TO USE THIS MODULE IN PRODUCTION. DON'T!\"\n>>>\n>>> A demo of an on-chain PTLC I executed using nickler's implementation on\n>>> the backend + bitcoin-s can be seen here https://youtu.be/w9o4v7Idjno\n>>>\n>>> And waxwing did a lovely write-up about the crypto itself\n>>> https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/\n>>>\n>>> I would be very interested in having a fork of (at least) one lightning\n>>> implementation (or Rust Lightning) to be a proof of concept ECDSA-PTLC node\n>>> with which we can test and play with the plethora of PTLC-based proposals\n>>> above.\n>>>\n>>> I believe this would only require a few changes to existing nodes:\n>>>\n>>> 1) update_add_ptlc will have a 32 byte x-coordinate (of a point) rather\n>>> than a 32 byte hash. Additionally the onion's hop_data will contain a 32\n>>> byte scalar tweak for each hop. As per [link multi-hop locks]. The last\n>>> hop_data will instead include a 32 byte scalar equal to the sum of all\n>>> tweaks.\n>>>\n>>> 2) commitment_signed will have 162 byte adaptor ptlc_signatures rather\n>>> than valid (71/72 byte) ECDSA signatures on PTLC-success transactions.\n>>>\n>>> 3) The in-flight outputs on the commitment transaction itself become a\n>>> little simpler as we no longer need to explicitly check the payment\n>>> pre-image against a hash. Instead, delete all instances of \"OP_HASH160\n>>> <RIPEMD160(payment_hash)> OP_EQUALVERIFY\" in the scripts (leaving the rest\n>>> the same) and require no pre-image in the witness, only a valid signature.\n>>> The pre-image check is implicitly enforced by the <remoteptlc_sig> witness\n>>> since only an adaptor signature was provided by remote so that the payment\n>>> pre-image is required to create the valid signature (from which the\n>>> pre-image can be then deduced by comparing adaptor and valid signatures).\n>>>\n>>> If I've missed any other changes that need to happen, do respond with\n>>> them!\n>>>\n>>> I hope that as a community we can work towards having a PTLC-based\n>>> Lightning Network that is safe and stable as soon as possible, and so I\n>>> encourage further thinking, development and expirementation with PTLCs now\n>>> so that when Taproot is finally at our disposal we can cleanly start moving\n>>> towards a more ideal Lightning :)\n>>>\n>>> Best,\n>>> Nadav\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200423/61661e72/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-04-24T07:17:07",
                "message_text_only": "Good morning Laolu, and list,\n\n\n> (this may be kind of off-topic, more about DLC deployment than PTLCs\n> themselves)\n>\n> From my PoV, new technologies aren't what has held back DLC deployment to\n> this date since the paper was originally released. Tadge has had working\n> code than can be deployed today for some time now, and other parties like\n> DG-Lab have created full-fledge demos with the system working end to end.\n> Instead, the real impediment has been the bootstrapping of the oracles\n> which the scheme critically depends upon.\n>\n> Without oracles, none of it really works. Although, it's also the case that\n> there're measures to prevent the oracles from equivocating (reporting two\n> conflicting prices/events for a particular instance), bootstrapping a new\n> oracle still requires a very high degree of trust as they can lie or report\n> incorrect data. As a result, actually deploying an oracle for a system like\n> this is tricky business, as it's a trusted centralized entity, so it will\n> run into all the normal meatspace/legal/operational risk that any trusted\n> centralized service would encounter.\n>\n> Earlier today, Coinbase announced that they were releasing a new price\n> oracle for the ETH ecosystem [1]. This caught my attention as one can\n> imagine, that it would be even simpler for them to deploy a DLC oracle which\n> exports an API to obtain signed prices/events. As an existing large company\n> in the space (depending on who you talk to), they're a trusted entity, which\n> has earned a good reputation over the years (solving this\n> bootstrapping/trust issue). If they do eventually grow the service to also\n> encompass this use case, then it enables a number of possibilities, as\n> there's still a ton of value in just base DLC-specific channels (or one off\n> contracts), without all the fancy barrier escrow scriptless scipts swappy\n> swap swap stuff.\n\nGoing even further off-topic, in theory the defiads project could help with this.\nAn oracle service could advertise itself on defiads, using a timelocked fidelity bond to back up the advertisement, which is a claim-to-truth (that they are trustworthy etc etc).\n\nEquivocation protection in DLC is done by forcing the revelation of a scalar behind a point.\nAs the defiads fidelity bond also includes a point (where signing with the scalar is needed to reclaim the bond after the timelock period ends), then we can force revelation of the private key protecting the fidelity bond in case of equivocation.\n\nUnfortunately, the oracle can simply outright lie, without equivocating between different segments of its users.\n\nRegards,\nZmnSCPxj\n\n>\n> -- Laolu\n>\n> [1]: https://blog.coinbase.com/introducing-the-coinbase-price-oracle-6d1ee22c7068\n>\n> On Thu, Apr 23, 2020 at 7:52 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>\n> > Hi Laolu,\n> >\n> > Thanks for the response :)\n> >\n> > I agree that some more framing probably would have been good to have in my update.\n> >\n> > First, I want to clarify that my intention is not to implement a PTLC-based lightning network on top of ECDSA adaptor signatures, as I do believe\u00a0that using Schnorr will be superior, but rather I wish to get some PoC sandbox with which to start implementing and testing out the long list of currently theoretical proposals surrounding PTLCs, most of which are implementation agnostic (to a degree anyway). I think it would be super beneficial\u00a0to have more fleshed out with respect to what some challenges of a Payment Point LN are going to be than we understand now, before Schnorr is implemented and it is time to commit to some PTLC scheme for real.\n> >\n> > Second, I agree that I've probably understated somewhat the changes that will be needed in most implementations as I was mostly thinking about what would need to change in the BOLTs, which does actually seem relatively minimal (although as you mention, these minimal changes to the BOLTs do trigger large changes in many implementations). Also, good point on how BOLT 11 (invoicing) will have to be altered as well, must've slipped my mind.\n> >\n> > Best,\n> > Nadav\n> >\n> > On Wed, Apr 22, 2020 at 8:17 PM Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n> >\n> > > Hi Nadav,\n> > >\n> > > Thanks for the updates! Super cool to see this concept continue to evolve\n> > > and integrate new technologies as they pop up.\n> > >\n> > > > I believe this would only require a few changes to existing nodes:\n> > >\n> > > Rather than a \"few changes\", this would to date be the largest network-level\n> > > update undertaken to the Lightning Network thus far. In the past, we rolled\n> > > out the new onion blob format (which enables changes like this), but none of\n> > > the intermediate nodes actually need to modify their behavior. New payment\n> > > types like MPP+AMP only needed the _end points_ to update making this an\n> > > end-to-end update that has been rolled out so far in a de-synchronized\n> > > manner.\n> > >\n> > > Re-phrasing deploying this requires changes to: the core channel state\n> > > machine (the protocol we use to make commitment updates), HTLC scripts,\n> > > on-chain HTLC handling and resolution, path finding algorithms (to only see\n> > > out the new PTLC-enabled nodes), invoice changes and onion blob processing.\n> > > I'd caution against underestimating how long all of this will take in\n> > > practice, and the degree of synchronization required to pull it all off\n> > > properly.\n> > >\n> > > For a few years now the question we've all been pondering is: do we wait for\n> > > scnhorr to roll out multi-hop locks, or just use the latest ECDSA based\n> > > technique? As dual deployment is compatible (we can make the onion blobs for\n> > > both types the same), a path has always existed to first roll out with the\n> > > latest ECDSA based technique then follow up later to roll out the schnorr\n> > > version as well. However there's also a risk here as depending on how\n> > > quickly things can be rolled out, schnorr may become available\n> > > mid-development, which would possibly cause us to reconsider the ECDSA path\n> > > and have the network purely use scnhorr to make things nice and uniform.\n> > >\n> > > Zooming out for a bit, the solution space of \"how channels can look post\n> > > scriptless-scripts + taproot\" is rather large [1], and the addition of this\n> > > new technique allows for an even larger set of deployment possibilities.\n> > > This latest ECDSA variant is much simpler than the prior ones (which had a\n> > > few rounds of more involved ZKPs), but since it still uses OP_CMS, it can't\n> > > be used to modify the funding output.\n> > >\n> > > [1]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n> > >\n> > > -- Laolu\n> > >\n> > > On Wed, Apr 22, 2020 at 8:13 AM Nadav Kohen <nadav at suredbits.com> wrote:\n> > >\n> > > > Hello all,\n> > > >\n> > > > I'd like to give an update on the current state of thinking and coding surrounding replacing Hash-TimeLock Contracts (HTLCs) with Point-TimeLock Contracts (PTLCs) (aka Payment Hashes -> Payment Points) in hopes of sparking interest, discussion, development, etc.\n> > > >\n> > > > We Want Payment Points!\n> > > > -----------------------\n> > > >\n> > > > Using point-locks (in PTLCs) instead of hash-locks (in HTLCs) for lightning payments is an all around improvement. HTLCs require the use of the same hash across payment routes (barring fancy ZKPs which are inferior to PTLCs) while PTLCs allow for payment de-correlation along routes. For an introduction to the topic, see https://suredbits.com/payment-points-part-1/.\n> > > >\n> > > > In addition to improving privacy in this way and protecting against wormhole attacks, PTLC-based lightning channels open the door to a large variety of interesting applications that cannot be accomplished with HTLCs:\n> > > >\n> > > > Stuckless (retry-able) Payments with proof of payment (https://suredbits.com/payment-points-part-2-stuckless-payments/)\n> > > >\n> > > > Escrow contracts over Lightning (https://suredbits.com/payment-points-part-3-escrow-contracts/)\n> > > >\n> > > > High/DLOG AMP (https://docs.google.com/presentation/d/15l4h2_zEY4zXC6n1NqsImcjgA0fovl_lkgkKu1O3QT0/edit#slide=id.g64c15419e7_0_40)\n> > > >\n> > > > Stuckless + AMP (an improvement on Boomerang) (https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002239.html)\n> > > >\n> > > > Pay-for-signature (https://suredbits.com/payment-points-part-4-selling-signatures/)\n> > > >\n> > > > Pay-for-commitment (https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002166.html)\n> > > >\n> > > > Monotonic access structures on payment completion (https://suredbits.com/payment-points-monotone-access-structures/)\n> > > >\n> > > > Ideal Barrier Escrow Implementation (https://suredbits.com/payment-points-implementing-barrier-escrows/)\n> > > >\n> > > > And allowing for Barrier Escrows, we can even have\n> > > >\n> > > > Atomic multi-payment setup (https://suredbits.com/payment-points-and-barrier-escrows/)\n> > > >\n> > > > Lightning Discreet Log Contract (https://suredbits.com/discreet-log-contracts-on-lightning-network/)\n> > > >\n> > > > Atomic multi-payment update (https://suredbits.com/updating-and-transferring-lightning-payments/)\n> > > >\n> > > > Lightning Discreet Log Contract Novation/Transfer (https://suredbits.com/transferring-lightning-dlcs/)\n> > > >\n> > > > There are likely even more things that can be done with Payment Points so make sure to respond if I've missed any known ones.\n> > > >\n> > > > How Do We Get Payment Points?\n> > > > -----------------------------\n> > > >\n> > > > Eventually, once we have Taproot, we can use 2p-Schnorr adaptor signatures in Lightning channels. For a detailed thread by ZmnSCPxj, see here https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n> > > >\n> > > > In the meantime, Lloyd has written about a way to do 1p-ECDSA adaptor sigs (https://github.com/LLFourn/one-time-VES) which can be paired with OP_CHECKMULTISIG to allows us to execute PTLCs on Bitcoin today!\n> > > >\n> > > > Nickler has implemented this in a branch of secp256k1 (https://github.com/jonasnick/secp256k1/pull/14) and I have implemented it in Bouncy Castle in Bitcoin-S with some testing against this branch (https://github.com/nkohen/bitcoin-s-core/tree/bouncy-adaptor). Do note that as nickler states on his PR, \"IT IS EXTREMELY DANGEROUS AND RECKLESS TO USE THIS MODULE IN PRODUCTION. DON'T!\"\n> > > >\n> > > > A demo of an on-chain PTLC I executed using nickler's implementation on the backend + bitcoin-s can be seen here https://youtu.be/w9o4v7Idjno\n> > > >\n> > > > And waxwing did a lovely write-up about the crypto itself https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/\n> > > >\n> > > > I would be very interested in having a fork of (at least) one lightning implementation (or Rust Lightning) to be a proof of concept ECDSA-PTLC node with which we can test and play with the plethora of PTLC-based proposals above.\n> > > >\n> > > > I believe this would only require a few changes to existing nodes:\n> > > >\n> > > > 1) update_add_ptlc will have a 32 byte x-coordinate (of a point) rather than a 32 byte hash. Additionally the onion's hop_data will contain a 32 byte scalar tweak for each hop. As per [link multi-hop locks]. The last hop_data will instead include a 32 byte scalar equal to the sum of all tweaks.\n> > > >\n> > > > 2) commitment_signed will have 162 byte adaptor ptlc_signatures rather than valid (71/72 byte) ECDSA signatures on PTLC-success transactions.\n> > > >\n> > > > 3) The in-flight outputs on the commitment transaction itself become a little simpler as we no longer need to explicitly check the payment pre-image against a hash. Instead, delete all instances of \"OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY\" in the scripts (leaving the rest the same) and require no pre-image in the witness, only a valid signature. The pre-image check is implicitly enforced by the <remoteptlc_sig> witness since only an adaptor signature was provided by remote so that the payment pre-image is required to create the valid signature (from which the pre-image can be then deduced by comparing adaptor and valid signatures).\n> > > >\n> > > > If I've missed any other changes that need to happen, do respond with them!\n> > > >\n> > > > I hope that as a community we can work towards having a PTLC-based Lightning Network that is safe and stable as soon as possible, and so I encourage further thinking, development and expirementation with PTLCs now so that when Taproot is finally at our disposal we can cleanly start moving towards a more ideal Lightning :)\n> > > >\n> > > > Best,\n> > > > Nadav\n> > > > _______________________________________________\n> > > > Lightning-dev mailing list\n> > > > Lightning-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-04-28T08:22:46",
                "message_text_only": "Hi Laolu,\n\n>From my PoV, new technologies aren't what has held back DLC deployment to\n> this date since the paper was originally released. Tadge has had working\n> code than can be deployed today for some time now, and other parties like\n> DG-Lab have created full-fledge demos with the system working end to end.\n> Instead, the real impediment has been the bootstrapping of the oracles\n> which the scheme critically depends upon.\n>\n\nOracles certainly require a huge bootstrapping effort but I think that some\nof the limitations of the original also hurt the progress of DLCs. The\noriginal protocol requires three on-chain transactions, asymmetric state\nand punishment transactions (i.e. you have to run a node to watch the\nchain). The original DLC is also easy to get wrong:\nhttps://github.com/mit-dci/dlcspec/issues/5.\n\nThe PTLC based DLC on the other hand is rather straightforward with only\ntwo transactions, symmetric state and no penalty transactions. Even more\nimportantly, it has no liveness requirement after the funding transaction\nis down (assuming there are no refund transactions) -- you can wait as long\nas you want before claims funds. For me, this makes the whole idea far more\nattractive both as a user and developer.\n\nSelf plugs: I wrote a short paper on how to optimise the DLCs so they could\nget more adoption:\nhttps://github.com/LLFourn/two-round-dlc/blob/master/main.pdf. I am also\nworking on a framework for oracle deployment which will be ready soon\u2122.\n\nLL\n\n\n\n>\n> On Thu, Apr 23, 2020 at 7:52 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>\n>> Hi Laolu,\n>>\n>> Thanks for the response :)\n>>\n>> I agree that some more framing probably would have been good to have in\n>> my update.\n>>\n>> First, I want to clarify that my intention is not to implement a\n>> PTLC-based lightning network on top of ECDSA adaptor signatures, as I do\n>> believe that using Schnorr will be superior, but rather I wish to get some\n>> PoC sandbox with which to start implementing and testing out the long list\n>> of currently theoretical proposals surrounding PTLCs, most of which are\n>> implementation agnostic (to a degree anyway). I think it would be super\n>> beneficial to have more fleshed out with respect to what some challenges of\n>> a Payment Point LN are going to be than we understand now, before Schnorr\n>> is implemented and it is time to commit to some PTLC scheme for real.\n>>\n>> Second, I agree that I've probably understated somewhat the changes that\n>> will be needed in most implementations as I was mostly thinking about what\n>> would need to change in the BOLTs, which does actually seem relatively\n>> minimal (although as you mention, these minimal changes to the BOLTs do\n>> trigger large changes in many implementations). Also, good point on how\n>> BOLT 11 (invoicing) will have to be altered as well, must've slipped my\n>> mind.\n>>\n>> Best,\n>> Nadav\n>>\n>> On Wed, Apr 22, 2020 at 8:17 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n>> wrote:\n>>\n>>> Hi Nadav,\n>>>\n>>> Thanks for the updates! Super cool to see this concept continue to evolve\n>>> and integrate new technologies as they pop up.\n>>>\n>>> > I believe this would only require a few changes to existing nodes:\n>>>\n>>> Rather than a \"few changes\", this would to date be the largest\n>>> network-level\n>>> update undertaken to the Lightning Network thus far. In the past, we\n>>> rolled\n>>> out the new onion blob format (which enables changes like this), but\n>>> none of\n>>> the intermediate nodes actually need to modify their behavior. New\n>>> payment\n>>> types like MPP+AMP only needed the _end points_ to update making this an\n>>> end-to-end update that has been rolled out so far in a de-synchronized\n>>> manner.\n>>>\n>>> Re-phrasing deploying this requires changes to: the core channel state\n>>> machine (the protocol we use to make commitment updates), HTLC scripts,\n>>> on-chain HTLC handling and resolution, path finding algorithms (to only\n>>> see\n>>> out the new PTLC-enabled nodes), invoice changes and onion blob\n>>> processing.\n>>> I'd caution against underestimating how long all of this will take in\n>>> practice, and the degree of synchronization required to pull it all off\n>>> properly.\n>>>\n>>> For a few years now the question we've all been pondering is: do we wait\n>>> for\n>>> scnhorr to roll out multi-hop locks, or just use the latest ECDSA based\n>>> technique? As dual deployment is compatible (we can make the onion blobs\n>>> for\n>>> both types the same), a path has always existed to first roll out with\n>>> the\n>>> latest ECDSA based technique then follow up later to roll out the schnorr\n>>> version as well. However there's also a risk here as depending on how\n>>> quickly things can be rolled out, schnorr may become available\n>>> mid-development, which would possibly cause us to reconsider the ECDSA\n>>> path\n>>> and have the network purely use scnhorr to make things nice and uniform.\n>>>\n>>> Zooming out for a bit, the solution space of \"how channels can look post\n>>> scriptless-scripts + taproot\" is rather large [1], and the addition of\n>>> this\n>>> new technique allows for an even larger set of deployment possibilities.\n>>> This latest ECDSA variant is much simpler than the prior ones (which had\n>>> a\n>>> few rounds of more involved ZKPs), but since it still uses OP_CMS, it\n>>> can't\n>>> be used to modify the funding output.\n>>>\n>>> [1]:\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>>>\n>>> -- Laolu\n>>>\n>>>\n>>> On Wed, Apr 22, 2020 at 8:13 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>>>\n>>>> Hello all,\n>>>>\n>>>> I'd like to give an update on the current state of thinking and coding\n>>>> surrounding replacing Hash-TimeLock Contracts (HTLCs) with Point-TimeLock\n>>>> Contracts (PTLCs) (aka Payment Hashes -> Payment Points) in hopes of\n>>>> sparking interest, discussion, development, etc.\n>>>>\n>>>>\n>>>> We Want Payment Points!\n>>>> -----------------------\n>>>>\n>>>> Using point-locks (in PTLCs) instead of hash-locks (in HTLCs) for\n>>>> lightning payments is an all around improvement. HTLCs require the use of\n>>>> the same hash across payment routes (barring fancy ZKPs which are inferior\n>>>> to PTLCs) while PTLCs allow for payment de-correlation along routes. For an\n>>>> introduction to the topic, see\n>>>> https://suredbits.com/payment-points-part-1/.\n>>>>\n>>>> In addition to improving privacy in this way and protecting against\n>>>> wormhole attacks, PTLC-based lightning channels open the door to a large\n>>>> variety of interesting applications that cannot be accomplished with HTLCs:\n>>>>\n>>>> Stuckless (retry-able) Payments with proof of payment (\n>>>> https://suredbits.com/payment-points-part-2-stuckless-payments/)\n>>>>\n>>>> Escrow contracts over Lightning (\n>>>> https://suredbits.com/payment-points-part-3-escrow-contracts/)\n>>>>\n>>>> High/DLOG AMP (\n>>>> https://docs.google.com/presentation/d/15l4h2_zEY4zXC6n1NqsImcjgA0fovl_lkgkKu1O3QT0/edit#slide=id.g64c15419e7_0_40\n>>>> )\n>>>>\n>>>> Stuckless + AMP (an improvement on Boomerang) (\n>>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002239.html\n>>>> )\n>>>>\n>>>> Pay-for-signature (\n>>>> https://suredbits.com/payment-points-part-4-selling-signatures/)\n>>>>\n>>>> Pay-for-commitment (\n>>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002166.html\n>>>> )\n>>>>\n>>>> Monotonic access structures on payment completion (\n>>>> https://suredbits.com/payment-points-monotone-access-structures/)\n>>>>\n>>>> Ideal Barrier Escrow Implementation (\n>>>> https://suredbits.com/payment-points-implementing-barrier-escrows/)\n>>>>\n>>>> And allowing for Barrier Escrows, we can even have\n>>>>\n>>>> Atomic multi-payment setup (\n>>>> https://suredbits.com/payment-points-and-barrier-escrows/)\n>>>>\n>>>> Lightning Discreet Log Contract (\n>>>> https://suredbits.com/discreet-log-contracts-on-lightning-network/)\n>>>>\n>>>> Atomic multi-payment update (\n>>>> https://suredbits.com/updating-and-transferring-lightning-payments/)\n>>>>\n>>>> Lightning Discreet Log Contract Novation/Transfer (\n>>>> https://suredbits.com/transferring-lightning-dlcs/)\n>>>>\n>>>> There are likely even more things that can be done with Payment Points\n>>>> so make sure to respond if I've missed any known ones.\n>>>>\n>>>>\n>>>> How Do We Get Payment Points?\n>>>> -----------------------------\n>>>>\n>>>> Eventually, once we have Taproot, we can use 2p-Schnorr adaptor\n>>>> signatures in Lightning channels. For a detailed thread by ZmnSCPxj, see\n>>>> here\n>>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n>>>>\n>>>> In the meantime, Lloyd has written about a way to do 1p-ECDSA adaptor\n>>>> sigs (https://github.com/LLFourn/one-time-VES) which can be paired\n>>>> with OP_CHECKMULTISIG to allows us to execute PTLCs on Bitcoin today!\n>>>>\n>>>> Nickler has implemented this in a branch of secp256k1 (\n>>>> https://github.com/jonasnick/secp256k1/pull/14) and I have implemented\n>>>> it in Bouncy Castle in Bitcoin-S with some testing against this branch (\n>>>> https://github.com/nkohen/bitcoin-s-core/tree/bouncy-adaptor). Do note\n>>>> that as nickler states on his PR, \"IT IS EXTREMELY DANGEROUS AND RECKLESS\n>>>> TO USE THIS MODULE IN PRODUCTION. DON'T!\"\n>>>>\n>>>> A demo of an on-chain PTLC I executed using nickler's implementation on\n>>>> the backend + bitcoin-s can be seen here https://youtu.be/w9o4v7Idjno\n>>>>\n>>>> And waxwing did a lovely write-up about the crypto itself\n>>>> https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/\n>>>>\n>>>> I would be very interested in having a fork of (at least) one lightning\n>>>> implementation (or Rust Lightning) to be a proof of concept ECDSA-PTLC node\n>>>> with which we can test and play with the plethora of PTLC-based proposals\n>>>> above.\n>>>>\n>>>> I believe this would only require a few changes to existing nodes:\n>>>>\n>>>> 1) update_add_ptlc will have a 32 byte x-coordinate (of a point) rather\n>>>> than a 32 byte hash. Additionally the onion's hop_data will contain a 32\n>>>> byte scalar tweak for each hop. As per [link multi-hop locks]. The last\n>>>> hop_data will instead include a 32 byte scalar equal to the sum of all\n>>>> tweaks.\n>>>>\n>>>> 2) commitment_signed will have 162 byte adaptor ptlc_signatures rather\n>>>> than valid (71/72 byte) ECDSA signatures on PTLC-success transactions.\n>>>>\n>>>> 3) The in-flight outputs on the commitment transaction itself become a\n>>>> little simpler as we no longer need to explicitly check the payment\n>>>> pre-image against a hash. Instead, delete all instances of \"OP_HASH160\n>>>> <RIPEMD160(payment_hash)> OP_EQUALVERIFY\" in the scripts (leaving the rest\n>>>> the same) and require no pre-image in the witness, only a valid signature.\n>>>> The pre-image check is implicitly enforced by the <remoteptlc_sig> witness\n>>>> since only an adaptor signature was provided by remote so that the payment\n>>>> pre-image is required to create the valid signature (from which the\n>>>> pre-image can be then deduced by comparing adaptor and valid signatures).\n>>>>\n>>>> If I've missed any other changes that need to happen, do respond with\n>>>> them!\n>>>>\n>>>> I hope that as a community we can work towards having a PTLC-based\n>>>> Lightning Network that is safe and stable as soon as possible, and so I\n>>>> encourage further thinking, development and expirementation with PTLCs now\n>>>> so that when Taproot is finally at our disposal we can cleanly start moving\n>>>> towards a more ideal Lightning :)\n>>>>\n>>>> Best,\n>>>> Nadav\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200428/e304daeb/attachment-0001.html>"
            },
            {
                "author": "Matheus Degiovani",
                "date": "2020-04-23T10:40:47",
                "message_text_only": "Hello Nadav and List,\n\nA quick introduction since this is my first message on the list. My name is Matheus Degiovani and I'm currently the maintainer of Decred's port of lnd (https://github.com/decred/dcrlnd). \n\nWe're still playing catch-up with the entirety of the LN ecosystem but I'm very interested in PoC'ing PTLCs. We already have Schnorr sigs on our chain (though no taproot yet). And given we still have a very small network, we have more leeway on playing around with the base protocols and seeing what sticks.\n\nHit me up if you want more details or if you want to spitball ideas for a prototype. Otherwise, once I have some bare minimum work done I'll give a ping here.\n\nRegards,\nMatheus.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200423/7085061f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "An update on PTLCs",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "Olaoluwa Osuntokun",
                "Matheus Degiovani",
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 61642
        }
    },
    {
        "title": "[Lightning-dev] DLC channels and integration in the Lightning Network",
        "thread_messages": [
            {
                "author": "LE GUILLY THIBAUT",
                "date": "2020-04-28T09:33:35",
                "message_text_only": "Hi list,\n\n\nFirst let me introduce myself as this is my first time posting. My name is\nThibaut and I\u2019ve been working at Crypto Garage for some time, mainly\nfocusing on DLC. With my colleagues Ichiro Kuwahara and Takatoshi Nakagawa, we\nhave been researching on how to construct DLC channels, and how such\nchannels could be integrated in the Lightning network. As there are\ncurrently quite some discussions around DLC, we thought that it was a good\ntime to share the result of this research. You can find the paper on github\n(\nhttps://github.com/p2pderivatives/offchain-dlc-paper/blob/master/offchaindlc.pdf\n) , and I\u2019ll try to summarize it here (if you\u2019re not familiar with DLC I\nrecommend going for the paper as I\u2019ll assume some knowledge in the following\n, also it has nice figures and everything so nice to skim through as a\nsupport for the description here). We\u2019d be happy to hear feedback from the\ncommunity on the feasibility of the approach we propose, both theoretically\nand practically.\n\n\nMotivation\n\n==================================\n\n\nAt the moment, once a DLC expires, both parties need to close and open a\nnew one in order to re-enter in a contract. This is wasteful as it requires\nat the minimum two extra on-chain transactions (one for mutual closing, and\na new funding tx). So one would like to have a way to have actual DLC\nchannels, where two parties can keep establishing contracts between\nthemselves as long as the balance in the channel allows it. Creating such\nchannels is less trivial than it may seem at first glance, as one tricky\npart is to ensure that no party can ever have the possibility of both\nenforcing the outcome of a previous contract or that of the latest contract\n(so they could pick the most favorable to them). I\u2019ll refer to this issue\nas the \u201cfree option\u201d problem hereafter, but it shouldn\u2019t be confused with\nthe free option problem of atomic swaps.\n\n\nIn addition, if we are to implement such DLC channels, we would like to\navoid having to re-do all the work and instead take advantage of the\nexisting Lightning Network infrastructure. Note that the integration\nsolution we propose is generic and would work to integrate other types of\nlayer 2 protocol in LN. It also permits the existence of multiple\nconcurrent channels, so two parties could have multiple DLC at the same\ntime using a single fund transaction.\n\n\nNote that one of our motivation was also to come up with something that\ndoesn\u2019t require any changes to the Bitcoin transaction structure or SIGHASH\nor any new cryptographic operation, as it is rather trivial to implement in\nan eltoo context for example.\n\n\nRelated Work\n\n==================================\n\n\nJuraj Bedn\u00e1r and Ren\u00e9 Pickhardt previously proposed Lightning DLC channels [\n1]. Their construction works by adding an output to a LN commitment\ntransaction, from which the regular set of DLC transactions can be\nattached. Our approach differs in two ways:\n\n   1. Our DLC channel construction can be made standalone, meaning they\n   could be deployed outside (or alongside) of the LN\n   2. The integration with LN that we propose allow for more separation of\n   concerns between the channels, as they can be updated separately without\n   influencing each others (their construction requires re-building all\n   transactions for any update, we only require this for opening/closing\n   and re-balancing).\n\n\nBedn\u00e1r and Pickhardt approach is similar to the one briefly described by\nBen Carman of Suredbit in the first section of [2]. He then proposes routed\nDLC that require PTLC and barrier escrow. While our proposal only works for\ndirect channels (so no routing), it also doesn\u2019t require any intermediary, and\nonly basic ECDSA.\n\n\nAs already mentioned, both DLC channels and their integration in LN could\nbe made much more easily in an eltoo world, as eltoo can be used as a\ngeneric framework for building off-chain contracts [3].\n\n\nDLC Channels\n\n==================================\n\nI\u2019ll skip the part about the broken naive construction (that has the free\noption problem), and go directly for the one that actually works. The main\ntrick revolves around adding two types of transaction to the regular DLC\nconstruction:\n\n   1. The first type of transaction is the update transaction. It\u2019s pretty\n   much the same as an LN commitment transaction, and serves a similar\n   purpose, that is keeping the balance of the channel. It is also revokable\n   , meaning that each party holds a different version.\n   2. The second type is the buffer transaction, which spends both outputs\n   of the update transactions to produce one output that will be consumed by\n   the Contract Execution Transactions (CETs). The main point of the buffer\n   transaction is to solve the free option problem in the protocol.\n\n\nUsing these two new transaction types we can now describe the update\nprotocol (please refer to figure 2 of the paper for some illustration). I\nskip the establishment protocol here as the update protocol is the crispy\npart, but the establishment is described in the paper as well.\n\n   1. Alice and Bob generate the set of transactions (update, buffer, CETs\n   and refund) for the new contract, with the update transactions having\n   output values equal to the outcome of the previous contract,\n   2. Alice sends her signatures for Bob\u2019s update transaction, all CETs and\n   the refund transactions,\n   3. Bob sends his signatures for Alice\u2019s update transaction, all CETs, the\n   refund transactions, as well as the revocation key for his previous\n   update transaction,\n   4. Alice sends the revocation key for her previous update transaction, as\n   well as the signature for her buffer transaction,\n   5. Bob sends his signatures for both buffer transactions.\n   6. Alice sends her signature for Bob\u2019s buffer transaction.\n\nAn informal analysis of the protocol is provided in the paper (Section 3.2.4\n), but the main point is that it\u2019s always the case that for both\nparties, either\nthey can enforce the outcome of the previous contract (and so close the\nchannel in case of an uncooperative counter party), either they can force\ntheir counter party into the new contract, but there is no point at which a\nparty can pick which one to enforce (the free option problem).\n\n\nIn the non-cooperative case, a DLC channel requires 5 on-chain\ntransaction (from\nopening to close), while in the cooperative case it\u2019s still only two. That\nmeans two more transactions in the worst case compared to the on-chain\nversion, but we believe this is offset by the ability to establish\nconsecutive contracts (even with two consecutive contracts, the number of\ntransaction is reduced).\n\n\nIntegration to the Lightning Network\n\n==================================\n\n\nOur proposed solution to integrate the DLC channels in LN is quite simple, but\nto the best of our knowledge has not been proposed before (apologies if that\n\u2019s wrong, and happy to be corrected). The idea is to use a \u201csplit\u201d\n transaction, which spends the output of the fund transaction, and contains\na single output for every channel to be created (a basic example would be\none LN channel and one DLC channel), which works as the new funding for\nthese channel. In the paper, we made this split transaction revokable so\nthat it\u2019s possible to reallocate funds between the channels, and close/open\nchannels as desired. Writing this I realized it might also be possible to\nnot make it revokable, which would make it less flexible but would remove\nthe drawback of doubling the number of transactions to be created and\nmonitored.\n\n\nThe advantage of this construction is that you can support as many\nsub-channels as you want for a single fund transaction, and have the\nability to rebalance between the channels. The disadvantage is that you\nneed to create and keep track of twice as many transactions due to the\nrevocation mechanism in the split transaction (though as just mentioned if\nyou don\u2019t want to rebalance and/or add/remove channels this issue is removed\n).\n\n\nConclusion and Questions\n\n==================================\n\n\nWe proposed a way to create DLC channels, and to integrate them in the\nLightning Network. Both can be done with existing cryptographic constructs\nand Bitcoin transactions. We\u2019d be happy to hear what people think of this\napproach, whether it is worth pursuing considering the recent development\nof ECDSA adaptor signatures which would enable simpler constructions, and\nhow complex it would be to implement in practice.\n\n\nRegards,\n\n\nThibaut\n\n\n[1] https://hackmd.io/@lpQxZaCeTG6OJZI3awxQPQ/LN-DLC\n\n[2] https://suredbits.com/discreet-log-contracts-on-lightning-network/\n\n[3]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002136.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200428/2ef726cc/attachment-0001.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-04-29T10:24:25",
                "message_text_only": "Hi Thibaut,\n\nThanks for carrying out this research. I have not finished reading the\npaper but have a question about what you call the \"straw man\" proposal\nearly on:\n\n\"At the end of this protocol, both Alice and Bob have the set of signed\ntransactions for the second DLC, and the transactions for the previous one\nare revoked. However, there is an issue at step 6. After sending her\nrevocation secret to Bob, Alice cannot anymore enforce the result from the\nfirst contract. However, as Bob has not yet revealed his secret, he still\nhas the ability to do so, in addition to having the ability to enforce the\nsecond one. If Bob is dishonest, he could thus choose not to reveal his\nrevocation key, and wait until just before the maturity of the second\ncontract to execute the one that is most favorable to him (he could also\npotentially use the previous refund transaction if the time lock expired).\"\n\nSince Alice has the signed transactions for the new state, if Bob refuses\nto revoke the old state why can't she just post the new state on chain\nimmediately? This limits Bob's \"option\" and I thought is the optimal\nsolution whenever this problem occurs.\n\nCheers,\n\nLL\n\nOn Tue, Apr 28, 2020 at 5:43 PM LE GUILLY THIBAUT <\nthibaut at cryptogarage.co.jp> wrote:\n\n> Hi list,\n>\n>\n> First let me introduce myself as this is my first time posting. My name is\n> Thibaut and I\u2019ve been working at Crypto Garage for some time, mainly\n> focusing on DLC. With my colleagues Ichiro Kuwahara and Takatoshi Nakagawa\n> , we have been researching on how to construct DLC channels, and how such\n> channels could be integrated in the Lightning network. As there are\n> currently quite some discussions around DLC, we thought that it was a\n> good time to share the result of this research. You can find the paper on\n> github (\n> https://github.com/p2pderivatives/offchain-dlc-paper/blob/master/offchaindlc.pdf\n> ) , and I\u2019ll try to summarize it here (if you\u2019re not familiar with DLC I\n> recommend going for the paper as I\u2019ll assume some knowledge in the\n> following, also it has nice figures and everything so nice to skim\n> through as a support for the description here). We\u2019d be happy to hear\n> feedback from the community on the feasibility of the approach we propose, both\n> theoretically and practically.\n>\n>\n> Motivation\n>\n> ==================================\n>\n>\n> At the moment, once a DLC expires, both parties need to close and open a\n> new one in order to re-enter in a contract. This is wasteful as it requires\n> at the minimum two extra on-chain transactions (one for mutual closing, and\n> a new funding tx). So one would like to have a way to have actual DLC\n> channels, where two parties can keep establishing contracts between\n> themselves as long as the balance in the channel allows it. Creating such\n> channels is less trivial than it may seem at first glance, as one tricky\n> part is to ensure that no party can ever have the possibility of both\n> enforcing the outcome of a previous contract or that of the latest contract\n> (so they could pick the most favorable to them). I\u2019ll refer to this issue\n> as the \u201cfree option\u201d problem hereafter, but it shouldn\u2019t be confused with\n> the free option problem of atomic swaps.\n>\n>\n> In addition, if we are to implement such DLC channels, we would like to\n> avoid having to re-do all the work and instead take advantage of the\n> existing Lightning Network infrastructure. Note that the integration\n> solution we propose is generic and would work to integrate other types of\n> layer 2 protocol in LN. It also permits the existence of multiple\n> concurrent channels, so two parties could have multiple DLC at the same\n> time using a single fund transaction.\n>\n>\n> Note that one of our motivation was also to come up with something that\n> doesn\u2019t require any changes to the Bitcoin transaction structure or\n> SIGHASH or any new cryptographic operation, as it is rather trivial to\n> implement in an eltoo context for example.\n>\n>\n> Related Work\n>\n> ==================================\n>\n>\n> Juraj Bedn\u00e1r and Ren\u00e9 Pickhardt previously proposed Lightning DLC channels\n> [1]. Their construction works by adding an output to a LN commitment\n> transaction, from which the regular set of DLC transactions can be\n> attached. Our approach differs in two ways:\n>\n>    1. Our DLC channel construction can be made standalone, meaning they\n>    could be deployed outside (or alongside) of the LN\n>    2. The integration with LN that we propose allow for more separation\n>    of concerns between the channels, as they can be updated separately\n>    without influencing each others (their construction requires\n>    re-building all transactions for any update, we only require this for\n>    opening/closing and re-balancing).\n>\n>\n> Bedn\u00e1r and Pickhardt approach is similar to the one briefly described by\n> Ben Carman of Suredbit in the first section of [2]. He then proposes\n> routed DLC that require PTLC and barrier escrow. While our proposal only\n> works for direct channels (so no routing), it also doesn\u2019t require any\n> intermediary, and only basic ECDSA.\n>\n>\n> As already mentioned, both DLC channels and their integration in LN could\n> be made much more easily in an eltoo world, as eltoo can be used as a\n> generic framework for building off-chain contracts [3].\n>\n>\n> DLC Channels\n>\n> ==================================\n>\n> I\u2019ll skip the part about the broken naive construction (that has the free\n> option problem), and go directly for the one that actually works. The\n> main trick revolves around adding two types of transaction to the regular\n> DLC construction:\n>\n>    1. The first type of transaction is the update transaction. It\u2019s\n>    pretty much the same as an LN commitment transaction, and serves a\n>    similar purpose, that is keeping the balance of the channel. It is\n>    also revokable, meaning that each party holds a different version.\n>    2. The second type is the buffer transaction, which spends both\n>    outputs of the update transactions to produce one output that will be\n>    consumed by the Contract Execution Transactions (CETs). The main point\n>    of the buffer transaction is to solve the free option problem in the\n>    protocol.\n>\n>\n> Using these two new transaction types we can now describe the update\n> protocol (please refer to figure 2 of the paper for some illustration). I\n> skip the establishment protocol here as the update protocol is the crispy\n> part, but the establishment is described in the paper as well.\n>\n>    1. Alice and Bob generate the set of transactions (update, buffer, CETs\n>    and refund) for the new contract, with the update transactions having\n>    output values equal to the outcome of the previous contract,\n>    2. Alice sends her signatures for Bob\u2019s update transaction, all CETs\n>    and the refund transactions,\n>    3. Bob sends his signatures for Alice\u2019s update transaction, all CETs, the\n>    refund transactions, as well as the revocation key for his previous\n>    update transaction,\n>    4. Alice sends the revocation key for her previous update transaction, as\n>    well as the signature for her buffer transaction,\n>    5. Bob sends his signatures for both buffer transactions.\n>    6. Alice sends her signature for Bob\u2019s buffer transaction.\n>\n> An informal analysis of the protocol is provided in the paper (Section\n> 3.2.4), but the main point is that it\u2019s always the case that for both\n> parties, either they can enforce the outcome of the previous contract (and\n> so close the channel in case of an uncooperative counter party), either\n> they can force their counter party into the new contract, but there is no\n> point at which a party can pick which one to enforce (the free option\n> problem).\n>\n>\n> In the non-cooperative case, a DLC channel requires 5 on-chain\n> transaction (from opening to close), while in the cooperative case it\u2019s\n> still only two. That means two more transactions in the worst case compared\n> to the on-chain version, but we believe this is offset by the ability to\n> establish consecutive contracts (even with two consecutive contracts, the\n> number of transaction is reduced).\n>\n>\n> Integration to the Lightning Network\n>\n> ==================================\n>\n>\n> Our proposed solution to integrate the DLC channels in LN is quite simple, but\n> to the best of our knowledge has not been proposed before (apologies if\n> that\u2019s wrong, and happy to be corrected). The idea is to use a \u201csplit\u201d\n>  transaction, which spends the output of the fund transaction, and\n> contains a single output for every channel to be created (a basic example\n> would be one LN channel and one DLC channel), which works as the new\n> funding for these channel. In the paper, we made this split transaction\n> revokable so that it\u2019s possible to reallocate funds between the channels, and\n> close/open channels as desired. Writing this I realized it might also be\n> possible to not make it revokable, which would make it less flexible but\n> would remove the drawback of doubling the number of transactions to be\n> created and monitored.\n>\n>\n> The advantage of this construction is that you can support as many\n> sub-channels as you want for a single fund transaction, and have the\n> ability to rebalance between the channels. The disadvantage is that you\n> need to create and keep track of twice as many transactions due to the\n> revocation mechanism in the split transaction (though as just mentioned\n> if you don\u2019t want to rebalance and/or add/remove channels this issue is\n> removed).\n>\n>\n> Conclusion and Questions\n>\n> ==================================\n>\n>\n> We proposed a way to create DLC channels, and to integrate them in the\n> Lightning Network. Both can be done with existing cryptographic constructs\n> and Bitcoin transactions. We\u2019d be happy to hear what people think of this\n> approach, whether it is worth pursuing considering the recent development\n> of ECDSA adaptor signatures which would enable simpler constructions, and\n> how complex it would be to implement in practice.\n>\n>\n> Regards,\n>\n>\n> Thibaut\n>\n>\n> [1] https://hackmd.io/@lpQxZaCeTG6OJZI3awxQPQ/LN-DLC\n>\n> [2] https://suredbits.com/discreet-log-contracts-on-lightning-network/\n>\n> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002136.html\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200429/2d32b18e/attachment-0001.html>"
            },
            {
                "author": "LE GUILLY THIBAUT",
                "date": "2020-04-29T13:14:25",
                "message_text_only": "Hi Lloyd,\n\nThanks for taking the time to read!\n\nWhat we were trying to describe in this section is the failure to construct\na DLC channel by using only a fund transaction (on-chain), CETs and a\nrefund transaction (same as the on-chain version), but adding revocation\nsecrets to the CETs and the refund transaction. So the signed transactions\nthat Alice holds are the CETs and the refund transaction for the second\nDLC, but she cannot use them since the CETs require the oracle signature to\nbe published and the refund transaction is timed lock to after the contract\nmaturity. So Alice is stuck in the second DLC, but Bob still has the\npossibility to close the channel on the previous state (using a CET from\nthe first DLC since he has not revealed the revocation secret).\n\nThat's why we add the update and buffer transactions in the construction\n(the buffer transaction is required to prevent the parties from closing the\nchannel with the update transaction before the maturity of the contract).\n\nHope that clarifies a bit.\n\nCheers,\n\nThibaut\n\nOn Wed, Apr 29, 2020 at 7:24 PM Lloyd Fournier <lloyd.fourn at gmail.com>\nwrote:\n\n> Hi Thibaut,\n>\n> Thanks for carrying out this research. I have not finished reading the\n> paper but have a question about what you call the \"straw man\" proposal\n> early on:\n>\n> \"At the end of this protocol, both Alice and Bob have the set of signed\n> transactions for the second DLC, and the transactions for the previous one\n> are revoked. However, there is an issue at step 6. After sending her\n> revocation secret to Bob, Alice cannot anymore enforce the result from the\n> first contract. However, as Bob has not yet revealed his secret, he still\n> has the ability to do so, in addition to having the ability to enforce the\n> second one. If Bob is dishonest, he could thus choose not to reveal his\n> revocation key, and wait until just before the maturity of the second\n> contract to execute the one that is most favorable to him (he could also\n> potentially use the previous refund transaction if the time lock expired).\"\n>\n> Since Alice has the signed transactions for the new state, if Bob refuses\n> to revoke the old state why can't she just post the new state on chain\n> immediately? This limits Bob's \"option\" and I thought is the optimal\n> solution whenever this problem occurs.\n>\n> Cheers,\n>\n> LL\n>\n> On Tue, Apr 28, 2020 at 5:43 PM LE GUILLY THIBAUT <\n> thibaut at cryptogarage.co.jp> wrote:\n>\n>> Hi list,\n>>\n>>\n>> First let me introduce myself as this is my first time posting. My name\n>> is Thibaut and I\u2019ve been working at Crypto Garage for some time, mainly\n>> focusing on DLC. With my colleagues Ichiro Kuwahara and Takatoshi Nakagawa\n>> , we have been researching on how to construct DLC channels, and how\n>> such channels could be integrated in the Lightning network. As there are\n>> currently quite some discussions around DLC, we thought that it was a\n>> good time to share the result of this research. You can find the paper on\n>> github (\n>> https://github.com/p2pderivatives/offchain-dlc-paper/blob/master/offchaindlc.pdf\n>> ) , and I\u2019ll try to summarize it here (if you\u2019re not familiar with DLC I\n>> recommend going for the paper as I\u2019ll assume some knowledge in the\n>> following, also it has nice figures and everything so nice to skim\n>> through as a support for the description here). We\u2019d be happy to hear\n>> feedback from the community on the feasibility of the approach we propose\n>> , both theoretically and practically.\n>>\n>>\n>> Motivation\n>>\n>> ==================================\n>>\n>>\n>> At the moment, once a DLC expires, both parties need to close and open a\n>> new one in order to re-enter in a contract. This is wasteful as it requires\n>> at the minimum two extra on-chain transactions (one for mutual closing, and\n>> a new funding tx). So one would like to have a way to have actual DLC\n>> channels, where two parties can keep establishing contracts between\n>> themselves as long as the balance in the channel allows it. Creating such\n>> channels is less trivial than it may seem at first glance, as one tricky\n>> part is to ensure that no party can ever have the possibility of both\n>> enforcing the outcome of a previous contract or that of the latest contract\n>> (so they could pick the most favorable to them). I\u2019ll refer to this\n>> issue as the \u201cfree option\u201d problem hereafter, but it shouldn\u2019t be\n>> confused with the free option problem of atomic swaps.\n>>\n>>\n>> In addition, if we are to implement such DLC channels, we would like to\n>> avoid having to re-do all the work and instead take advantage of the\n>> existing Lightning Network infrastructure. Note that the integration\n>> solution we propose is generic and would work to integrate other types of\n>> layer 2 protocol in LN. It also permits the existence of multiple\n>> concurrent channels, so two parties could have multiple DLC at the same\n>> time using a single fund transaction.\n>>\n>>\n>> Note that one of our motivation was also to come up with something that\n>> doesn\u2019t require any changes to the Bitcoin transaction structure or\n>> SIGHASH or any new cryptographic operation, as it is rather trivial to\n>> implement in an eltoo context for example.\n>>\n>>\n>> Related Work\n>>\n>> ==================================\n>>\n>>\n>> Juraj Bedn\u00e1r and Ren\u00e9 Pickhardt previously proposed Lightning DLC\n>> channels [1]. Their construction works by adding an output to a LN\n>> commitment transaction, from which the regular set of DLC transactions\n>> can be attached. Our approach differs in two ways:\n>>\n>>    1. Our DLC channel construction can be made standalone, meaning they\n>>    could be deployed outside (or alongside) of the LN\n>>    2. The integration with LN that we propose allow for more separation\n>>    of concerns between the channels, as they can be updated separately\n>>    without influencing each others (their construction requires\n>>    re-building all transactions for any update, we only require this for\n>>    opening/closing and re-balancing).\n>>\n>>\n>> Bedn\u00e1r and Pickhardt approach is similar to the one briefly described by\n>> Ben Carman of Suredbit in the first section of [2]. He then proposes\n>> routed DLC that require PTLC and barrier escrow. While our proposal only\n>> works for direct channels (so no routing), it also doesn\u2019t require any\n>> intermediary, and only basic ECDSA.\n>>\n>>\n>> As already mentioned, both DLC channels and their integration in LN\n>> could be made much more easily in an eltoo world, as eltoo can be used\n>> as a generic framework for building off-chain contracts [3].\n>>\n>>\n>> DLC Channels\n>>\n>> ==================================\n>>\n>> I\u2019ll skip the part about the broken naive construction (that has the\n>> free option problem), and go directly for the one that actually works.\n>> The main trick revolves around adding two types of transaction to the\n>> regular DLC construction:\n>>\n>>    1. The first type of transaction is the update transaction. It\u2019s\n>>    pretty much the same as an LN commitment transaction, and serves a\n>>    similar purpose, that is keeping the balance of the channel. It is\n>>    also revokable, meaning that each party holds a different version.\n>>    2. The second type is the buffer transaction, which spends both\n>>    outputs of the update transactions to produce one output that will be\n>>    consumed by the Contract Execution Transactions (CETs). The main\n>>    point of the buffer transaction is to solve the free option problem in the\n>>    protocol.\n>>\n>>\n>> Using these two new transaction types we can now describe the update\n>> protocol (please refer to figure 2 of the paper for some illustration).\n>> I skip the establishment protocol here as the update protocol is the crispy\n>> part, but the establishment is described in the paper as well.\n>>\n>>    1. Alice and Bob generate the set of transactions (update, buffer, CETs\n>>    and refund) for the new contract, with the update transactions having\n>>    output values equal to the outcome of the previous contract,\n>>    2. Alice sends her signatures for Bob\u2019s update transaction, all CETs\n>>    and the refund transactions,\n>>    3. Bob sends his signatures for Alice\u2019s update transaction, all CETs, the\n>>    refund transactions, as well as the revocation key for his previous\n>>    update transaction,\n>>    4. Alice sends the revocation key for her previous update transaction, as\n>>    well as the signature for her buffer transaction,\n>>    5. Bob sends his signatures for both buffer transactions.\n>>    6. Alice sends her signature for Bob\u2019s buffer transaction.\n>>\n>> An informal analysis of the protocol is provided in the paper (Section\n>> 3.2.4), but the main point is that it\u2019s always the case that for both\n>> parties, either they can enforce the outcome of the previous contract (and\n>> so close the channel in case of an uncooperative counter party), either\n>> they can force their counter party into the new contract, but there is\n>> no point at which a party can pick which one to enforce (the free option\n>> problem).\n>>\n>>\n>> In the non-cooperative case, a DLC channel requires 5 on-chain\n>> transaction (from opening to close), while in the cooperative case it\u2019s\n>> still only two. That means two more transactions in the worst case compared\n>> to the on-chain version, but we believe this is offset by the ability to\n>> establish consecutive contracts (even with two consecutive contracts, the\n>> number of transaction is reduced).\n>>\n>>\n>> Integration to the Lightning Network\n>>\n>> ==================================\n>>\n>>\n>> Our proposed solution to integrate the DLC channels in LN is quite simple\n>> , but to the best of our knowledge has not been proposed before (apologies\n>> if that\u2019s wrong, and happy to be corrected). The idea is to use a \u201csplit\u201d\n>>  transaction, which spends the output of the fund transaction, and\n>> contains a single output for every channel to be created (a basic\n>> example would be one LN channel and one DLC channel), which works as the\n>> new funding for these channel. In the paper, we made this split\n>> transaction revokable so that it\u2019s possible to reallocate funds between\n>> the channels, and close/open channels as desired. Writing this I\n>> realized it might also be possible to not make it revokable, which would\n>> make it less flexible but would remove the drawback of doubling the number\n>> of transactions to be created and monitored.\n>>\n>>\n>> The advantage of this construction is that you can support as many\n>> sub-channels as you want for a single fund transaction, and have the\n>> ability to rebalance between the channels. The disadvantage is that you\n>> need to create and keep track of twice as many transactions due to the\n>> revocation mechanism in the split transaction (though as just mentioned\n>> if you don\u2019t want to rebalance and/or add/remove channels this issue is\n>> removed).\n>>\n>>\n>> Conclusion and Questions\n>>\n>> ==================================\n>>\n>>\n>> We proposed a way to create DLC channels, and to integrate them in the\n>> Lightning Network. Both can be done with existing cryptographic constructs\n>> and Bitcoin transactions. We\u2019d be happy to hear what people think of\n>> this approach, whether it is worth pursuing considering the recent\n>> development of ECDSA adaptor signatures which would enable simpler\n>> constructions, and how complex it would be to implement in practice.\n>>\n>>\n>> Regards,\n>>\n>>\n>> Thibaut\n>>\n>>\n>> [1] https://hackmd.io/@lpQxZaCeTG6OJZI3awxQPQ/LN-DLC\n>>\n>> [2] https://suredbits.com/discreet-log-contracts-on-lightning-network/\n>>\n>> [3]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002136.html\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200429/821b2f29/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "DLC channels and integration in the Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "LE GUILLY THIBAUT",
                "Lloyd Fournier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 31520
        }
    }
]