[
    {
        "title": "[Lightning-dev] Arbitrary Bitcoin Contracts over LN",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-08-01T10:36:22",
                "message_text_only": "Good morning list,\n\nRecently, somebody on the IRC channel, asked regarding smart contracts being transported via LN.\n\nIndeed, this is theoretically possible, provided the \"smart contract\" is implementable as a Bitcoin SCRIPT.\n\nAfterwards, I opined that, for transportation of *arbitrary* contracts, Poon-Dryja is superior to either Decker-Wattenhofer or Decker-Osuntokun-Russell.\n\nSo, first, my other opinions:\n\n1.  The only smart contract you really want to transport is HTLC (or equivalent in scriptless script).  There really is no point in transporting any other contract on LN.  HTLCs can even be used to implement (nontransferable) swap options, and can be composed (at the cost of increasing CLTV limits on backoff) to create multi-step swaps.\n\n2.  Decker-Osuntokun-Russell \"eltoo\" is far superior to Poon-Dryja \"LN-penalty\" in everything else, except transportation of *arbitrary* contracts.\n\nNow, ultimately any Bitcoin SCRIPT may be expressed as a Boolean computation whether or not the contract has been fulfilled by the transaction that attempts to claim it.\n\nSo I introduce, an arbitrary contract C, ostensibly to be transported over LN.\n\nAnd I introduce our transactions, as so: [scriptSig, redeemScript] -> redeeming transaction\n\nTo transport C over a channel between nodes A and B, under Poon-Dryja, we first have a channel anchoring transaction onchain:\n\n[/*arbitrary*/, A && B] ->\n\nNow suppose the entire output is to be put into a contract C. Under Poon-Dryja, we create the below symmetrical series of transactions, with only the anchoring transaction existing onchain:\n\n[/*arbitrary*/, A && B] -> [signA signB, (revoke) || (A && B && C)] -> [signA signB witnessCbyA, revoke || (A && CSV)] /* held by A */\n\n[/*arbitrary*/, A && B] -> [signA signB, (revoke) || (A && B && C)] -> [signA signB witnessCbyB, revoke || (B && CSV)] /* held by B */\n\nWhere (revoke) is the revocation key, whose derivation requires both A and B, and whose half is kept secret by the A (resp. B) until they both agree to revoke the old state.\n\nOf note is that the only additional condition added to C is (A && B), which makes sense since the contract is between nodes A and B (and which would be implicitly required by the funding transaction anyway).  The (revoke) || does not affect the enforcement of C if the revocation key is not yet revealed; once the revocation key is revealed, that revokes the entire sequence of transactions (which is why (revoke) || appears in both the second and third transactions above).  In particular, the CSV-encumberance does not affect claiming of C; it encumbers the claiming of the money, but does not interact with C itself.  Thus, any CLTV conditions in C will not be interefered with by the CSV-encumberance on the *next* transaction.\n\nNote also that only signA and signB for the final transaction needs to be shared; the witnessC can presumably be fulfilled by each side themselves automatically.\n\nOn the other hand, under Decker-Osuntokun-Russell eltoo, the transaction series is:\n\n[/*arbitrary*/, A && B] -> [signA signB, (CSV && A && B) || (CLTV && A && B)] -> [nSequence signA signB, C]\n\nNow the above is massively simpler with no additional SCRIPT that needs to be written, around the transported contract C --- but the CSV in the second transaction, is now potentially interfering with the operation of the contract C, as the final transaction cannot be enforced onchain until the CSV has been satisfied.  This is in contrast with the Poon-Dryja case, where the contract C appears immediately on the second transaction in the sequence, and can be enforced, as soon as it appears onchain.\n\n(In eltoo, the (CTLV && A && B) branch of the intermediate contract is the \"update\" path, and the CLTV required is always a past Unix Epoch time, so this CLTV cannot interfere with the contract C).\n\nThe above consideration, is why I suppose that, *for arbitrary contracts*, Poon-Dryja is superior.\n\nSimply, the conclusion is that Decker-Osuntokun-Russell channels require a CSV that may interfere with the contract C if C is time-sensitive (i.e. has a CLTV or CSV itself), whereas Poon-Dryja requires CSV only for revocability, and the CSV cannot prevent the enforcement of time-sensitive C.\n\nIndeed, as I pointed out, even when transporting HTLCs, Decker-Osuntokun-Russell will require consideration of the CSV on top of the CLTV-deltas imposed by intermediary nodes, with weights complicated by the fact that CLTV-deltas are summed together but the highest CSV is added to the CLTV total, which does not mix well with typical route-finding algorithms (most of which assume a simple summing of costs, which CLTV-deltas use but CSVs on Decker-Osuntokun-Russell do not since highest is used).\n\nIn almost all other ways, Poon-Dryja is inferior:\n\n1.  Does not use nLockTime in a sufficiently clever way.\n2.  Dangerous \"toxic waste\" (old revoked transactions) which (1) you should not recover from your backups and (2) you should not let your worst enemy find, because they can publish those onchain and make you LOSE MONEY.\n3.  Symmetrical chains of transactions, different for both parties, instead of a single chain.\n\nIn addition, arbitrary contracts are not really particularly useful.  HTLCs seem to me an important building block for digital value transfers, and they (and their equivalents under scriptless) are sufficient for most practical transfers.  Thus, moving forward, Decker-Osuntokun-Russell remains a superior technology over Poon-Dryja.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180801/a56d613f/attachment.html>"
            },
            {
                "author": "Michael Folkson",
                "date": "2018-08-01T11:11:08",
                "message_text_only": "Thanks for this ZmnSCPxj, very interesting.\n\nA couple of follow ups please:\n\n1) Poon-Dryja (LN penalty), Decker-Wattenhofer and Decker-Osuntokun-Russell\n(eltoo) just refer to the process for claiming funds when an old state is\nbroadcast? Poon-Dryja doesn't require a soft fork but\nDecker-Osuntokun-Russell does?\n2) How does Decker-Wattenhofer claim funds when an old state is broadcast?\n\nOn Wed, Aug 1, 2018 at 11:36 AM, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> Recently, somebody on the IRC channel, asked regarding smart contracts\n> being transported via LN.\n>\n> Indeed, this is theoretically possible, provided the \"smart contract\" is\n> implementable as a Bitcoin SCRIPT.\n>\n> Afterwards, I opined that, for transportation of *arbitrary* contracts,\n> Poon-Dryja is superior to either Decker-Wattenhofer or\n> Decker-Osuntokun-Russell.\n>\n> So, first, my other opinions:\n>\n> 1.  The only smart contract you really want to transport is HTLC (or\n> equivalent in scriptless script).  There really is no point in transporting\n> any other contract on LN.  HTLCs can even be used to implement\n> (nontransferable) swap options, and can be composed (at the cost of\n> increasing CLTV limits on backoff) to create multi-step swaps.\n>\n> 2.  Decker-Osuntokun-Russell \"eltoo\" is far superior to Poon-Dryja\n> \"LN-penalty\" in everything else, except transportation of *arbitrary*\n> contracts.\n>\n> Now, ultimately any Bitcoin SCRIPT may be expressed as a Boolean\n> computation whether or not the contract has been fulfilled by the\n> transaction that attempts to claim it.\n>\n> So I introduce, an arbitrary contract C, ostensibly to be transported over\n> LN.\n>\n> And I introduce our transactions, as so: [scriptSig, redeemScript] ->\n> redeeming transaction\n>\n> To transport C over a channel between nodes A and B, under Poon-Dryja, we\n> first have a channel anchoring transaction onchain:\n>\n> [/*arbitrary*/, A && B] ->\n>\n> Now suppose the entire output is to be put into a contract C. Under\n> Poon-Dryja, we create the below symmetrical series of transactions, with\n> only the anchoring transaction existing onchain:\n>\n> [/*arbitrary*/, A && B] -> [signA signB, (revoke) || (A && B && C)] ->\n> [signA signB witnessCbyA, revoke || (A && CSV)] /* held by A */\n>\n> [/*arbitrary*/, A && B] -> [signA signB, (revoke) || (A && B && C)] ->\n> [signA signB witnessCbyB, revoke || (B && CSV)] /* held by B */\n>\n> Where (revoke) is the revocation key, whose derivation requires both A and\n> B, and whose half is kept secret by the A (resp. B) until they both agree\n> to revoke the old state.\n>\n> Of note is that the only additional condition added to C is (A && B),\n> which makes sense since the contract is between nodes A and B (and which\n> would be implicitly required by the funding transaction anyway).  The\n> (revoke) || does not affect the enforcement of C if the revocation key is\n> not yet revealed; once the revocation key is revealed, that revokes the\n> entire sequence of transactions (which is why (revoke) || appears in both\n> the second and third transactions above).  In particular, the\n> CSV-encumberance does not affect claiming of C; it encumbers the claiming\n> of the money, but does not interact with C itself.  Thus, any CLTV\n> conditions in C will not be interefered with by the CSV-encumberance on the\n> *next* transaction.\n>\n> Note also that only signA and signB for the final transaction needs to be\n> shared; the witnessC can presumably be fulfilled by each side themselves\n> automatically.\n>\n> On the other hand, under Decker-Osuntokun-Russell eltoo, the transaction\n> series is:\n>\n> [/*arbitrary*/, A && B] -> [signA signB, (CSV && A && B) || (CLTV && A &&\n> B)] -> [nSequence signA signB, C]\n>\n> Now the above is massively simpler with no additional SCRIPT that needs to\n> be written, around the transported contract C --- but the CSV in the second\n> transaction, is now potentially interfering with the operation of the\n> contract C, as the final transaction cannot be enforced onchain until the\n> CSV has been satisfied.  This is in contrast with the Poon-Dryja case,\n> where the contract C appears immediately on the second transaction in the\n> sequence, and can be enforced, as soon as it appears onchain.\n>\n> (In eltoo, the (CTLV && A && B) branch of the intermediate contract is the\n> \"update\" path, and the CLTV required is always a past Unix Epoch time, so\n> this CLTV cannot interfere with the contract C).\n>\n> The above consideration, is why I suppose that, *for arbitrary contracts*,\n> Poon-Dryja is superior.\n>\n> Simply, the conclusion is that Decker-Osuntokun-Russell channels require a\n> CSV that may interfere with the contract C if C is time-sensitive (i.e. has\n> a CLTV or CSV itself), whereas Poon-Dryja requires CSV only for\n> revocability, and the CSV cannot prevent the enforcement of time-sensitive\n> C.\n>\n> Indeed, as I pointed out, even when transporting HTLCs,\n> Decker-Osuntokun-Russell will require consideration of the CSV on top of\n> the CLTV-deltas imposed by intermediary nodes, with weights complicated by\n> the fact that CLTV-deltas are summed together but the highest CSV is added\n> to the CLTV total, which does not mix well with typical route-finding\n> algorithms (most of which assume a simple summing of costs, which\n> CLTV-deltas use but CSVs on Decker-Osuntokun-Russell do not since highest\n> is used).\n>\n> In almost all other ways, Poon-Dryja is inferior:\n>\n> 1.  Does not use nLockTime in a sufficiently clever way.\n> 2.  Dangerous \"toxic waste\" (old revoked transactions) which (1) you\n> should not recover from your backups and (2) you should not let your worst\n> enemy find, because they can publish those onchain and make you LOSE MONEY.\n> 3.  Symmetrical chains of transactions, different for both parties,\n> instead of a single chain.\n>\n> In addition, arbitrary contracts are not really particularly useful.\n> HTLCs seem to me an important building block for digital value transfers,\n> and they (and their equivalents under scriptless) are sufficient for most\n> practical transfers.  Thus, moving forward, Decker-Osuntokun-Russell\n> remains a superior technology over Poon-Dryja.\n>\n> Regards,\n> ZmnSCPxj\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 92D6 0159 214C FEE3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180801/47c76b51/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-08-02T03:56:56",
                "message_text_only": "Good morning Michael,\n\n> A couple of follow ups please:\n>\n> 1) Poon-Dryja (LN penalty), Decker-Wattenhofer and Decker-Osuntokun-Russell (eltoo) just refer to the process for claiming funds when an old state is broadcast? Poon-Dryja doesn't require a soft fork but Decker-Osuntokun-Russell does?\n\nThey are different channel protocols with various tradeoffs.  Poon-Dryja, as mentioned, does not have a CSV that interferes with transported contracts, and generally can get away with smaller practical timeouts on unilateral closes.  Decker-Wattenhofer channels have no \"toxic waste\", i.e. old transactions that are dangerous for you to accidentally use or malicious third parties to maliciously use, and can use existing Bitcoin, but timeouts on unilateral closes are longer and need to be the same for both parties, also that timeout affects HTLC delay routing (the highest such timeout on a route is added to the total practical HTLC delay).  Decker-Wattenhofer channels are also extendable to multi-party Burchert-Decker-Wattenhofer channel factories; there is no credible method of extending Poon-Dryja to multiparty similarly.\n\nThe new Decker-Osuntokun-Russell combines the smaller practical timeouts on unilateral closes with the lack of toxic waste, but requires SIGHASH_NOINPUT_UNSAFE softfork in the base layer.  I believe they can also be used to host channel factories too in the same manner Burchert-Decker-Wattenhofer extends Decker-Wattenhofer.\n\n> 2) How does Decker-Wattenhofer claim funds when an old state is broadcast?\n\nOld states are impossible to broadcast if new states are already known.  The final contract in the chains that Decker-Wattenhofer is a decrementing timelock, with each newer version having a shorter timelock.  This means that as long as your node is online, old states cannot be published without the new state having gotten published first (since the new state has a shorter timelock).  Since both the old and new state consume the same UTXO, the new state being published leads to the old state being impossible to publish.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180802/50ba2a40/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-08-01T12:04:47",
                "message_text_only": "Thanks for the excellent writeup ZmnSCPxj, I just have a minor issue\nwith your characterization that LN-penalty is to be preferred.\n\nMy issue is with the fact that CLTV-branches and nLocktimed spending\ntransactions also need to be guarded with a further `OP_CSV` condition,\nsince they may leak on-chain, and be immediately valid. This is the\nreason why we introduced the two stage HTLC resolution, with the first\nstage acting as the `OP_CSV` guard, and keeping the second stage clean.\n\nI think therefore the construction of the contract ought to be this:\n\n[/*arbitrary*/, A && B] -> [signA signB, (revoke) || (CSV && A && B && C)] -> [signA signB witnessCbyA, revoke || A] /* held by A */\n[/*arbitrary*/, A && B] -> [signA signB, (revoke) || (CSV && A && B && C)] -> [signA signB witnessCbyB, revoke || B] /* held by B */\n\nNamely the CSV belongs in the output script, not the input script (which\nis under the control of the spending party). Notice that I might have\nmisgroked your syntax :-) If C now contains a CLTV-branch whose timeout\nexpires before we attempt the on-chain mediation, suddenly both branches\nbecome valid and we have a race.\n\nTake this for example:\n\n```\nOP_IF\n  x OP_CLTV\n  <checksigs>\nOP_ELSE\n  <checksigs>\nOP_END\n```\n\nIf we wait until block x was found, we attempt to cheat by publishing\nthis state, and suddenly both prepared reaction transactions are valid,\nresulting in a race. This is simply due to the fact that transactions\ncan leak. To fix this we'd have to encumber the OP_IF branch with an\nadditional CSV. So it's not really like we can just add an OR-clause to\nan arbitrary contract and we're safe, we actually have to weave it into\nthe logic, or create a second stage that just disambiguates the cheat\nand the non-cheat unilateral case.\n\nWith eltoo this sort of weaving falls away, since we guarantee that the\nold state can never leak on-chain. If we squint at it we can see that\nwe have effectively pushed down the second stage into the on-chain state\nresolution, allowing us to keep the contracts clean.\n\nCheers,\nChristian\nZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n\n> Good morning list,\n>\n> Recently, somebody on the IRC channel, asked regarding smart contracts\n> being transported via LN.\n>\n> Indeed, this is theoretically possible, provided the \"smart contract\"\n> is implementable as a Bitcoin SCRIPT.\n>\n> Afterwards, I opined that, for transportation of *arbitrary*\n> contracts, Poon-Dryja is superior to either Decker-Wattenhofer or\n> Decker-Osuntokun-Russell.\n>\n> So, first, my other opinions:\n>\n> 1.  The only smart contract you really want to transport is HTLC (or\n> equivalent in scriptless script).  There really is no point in\n> transporting any other contract on LN.  HTLCs can even be used to\n> implement (nontransferable) swap options, and can be composed (at the\n> cost of increasing CLTV limits on backoff) to create multi-step swaps.\n>\n> 2.  Decker-Osuntokun-Russell \"eltoo\" is far superior to Poon-Dryja\n> \"LN-penalty\" in everything else, except transportation of *arbitrary*\n> contracts.\n>\n> Now, ultimately any Bitcoin SCRIPT may be expressed as a Boolean\n> computation whether or not the contract has been fulfilled by the\n> transaction that attempts to claim it.\n>\n> So I introduce, an arbitrary contract C, ostensibly to be transported\n> over LN.\n>\n> And I introduce our transactions, as so: [scriptSig, redeemScript] ->\n> redeeming transaction\n>\n> To transport C over a channel between nodes A and B, under Poon-Dryja,\n> we first have a channel anchoring transaction onchain:\n>\n> [/*arbitrary*/, A && B] ->\n>\n> Now suppose the entire output is to be put into a contract C. Under\n> Poon-Dryja, we create the below symmetrical series of transactions,\n> with only the anchoring transaction existing onchain:\n>\n> [/*arbitrary*/, A && B] -> [signA signB, (revoke) || (A && B && C)] ->\n> [signA signB witnessCbyA, revoke || (A && CSV)] /* held by A */\n>\n> [/*arbitrary*/, A && B] -> [signA signB, (revoke) || (A && B && C)] ->\n> [signA signB witnessCbyB, revoke || (B && CSV)] /* held by B */\n>\n> Where (revoke) is the revocation key, whose derivation requires both A\n> and B, and whose half is kept secret by the A (resp. B) until they\n> both agree to revoke the old state.\n>\n> Of note is that the only additional condition added to C is (A && B),\n> which makes sense since the contract is between nodes A and B (and\n> which would be implicitly required by the funding transaction anyway).\n> The (revoke) || does not affect the enforcement of C if the revocation\n> key is not yet revealed; once the revocation key is revealed, that\n> revokes the entire sequence of transactions (which is why (revoke) ||\n> appears in both the second and third transactions above).  In\n> particular, the CSV-encumberance does not affect claiming of C; it\n> encumbers the claiming of the money, but does not interact with C\n> itself.  Thus, any CLTV conditions in C will not be interefered with\n> by the CSV-encumberance on the *next* transaction.\n>\n> Note also that only signA and signB for the final transaction needs to\n> be shared; the witnessC can presumably be fulfilled by each side\n> themselves automatically.\n>\n> On the other hand, under Decker-Osuntokun-Russell eltoo, the\n> transaction series is:\n>\n> [/*arbitrary*/, A && B] -> [signA signB, (CSV && A && B) || (CLTV && A\n> && B)] -> [nSequence signA signB, C]\n>\n> Now the above is massively simpler with no additional SCRIPT that\n> needs to be written, around the transported contract C --- but the CSV\n> in the second transaction, is now potentially interfering with the\n> operation of the contract C, as the final transaction cannot be\n> enforced onchain until the CSV has been satisfied.  This is in\n> contrast with the Poon-Dryja case, where the contract C appears\n> immediately on the second transaction in the sequence, and can be\n> enforced, as soon as it appears onchain.\n>\n> (In eltoo, the (CTLV && A && B) branch of the intermediate contract is\n> the \"update\" path, and the CLTV required is always a past Unix Epoch\n> time, so this CLTV cannot interfere with the contract C).\n>\n> The above consideration, is why I suppose that, *for arbitrary\n> contracts*, Poon-Dryja is superior.\n>\n> Simply, the conclusion is that Decker-Osuntokun-Russell channels\n> require a CSV that may interfere with the contract C if C is\n> time-sensitive (i.e. has a CLTV or CSV itself), whereas Poon-Dryja\n> requires CSV only for revocability, and the CSV cannot prevent the\n> enforcement of time-sensitive C.\n>\n> Indeed, as I pointed out, even when transporting HTLCs,\n> Decker-Osuntokun-Russell will require consideration of the CSV on top\n> of the CLTV-deltas imposed by intermediary nodes, with weights\n> complicated by the fact that CLTV-deltas are summed together but the\n> highest CSV is added to the CLTV total, which does not mix well with\n> typical route-finding algorithms (most of which assume a simple\n> summing of costs, which CLTV-deltas use but CSVs on\n> Decker-Osuntokun-Russell do not since highest is used).\n>\n> In almost all other ways, Poon-Dryja is inferior:\n>\n> 1.  Does not use nLockTime in a sufficiently clever way.  2.\n> Dangerous \"toxic waste\" (old revoked transactions) which (1) you\n> should not recover from your backups and (2) you should not let your\n> worst enemy find, because they can publish those onchain and make you\n> LOSE MONEY.  3.  Symmetrical chains of transactions, different for\n> both parties, instead of a single chain.\n>\n> In addition, arbitrary contracts are not really particularly useful.\n> HTLCs seem to me an important building block for digital value\n> transfers, and they (and their equivalents under scriptless) are\n> sufficient for most practical transfers.  Thus, moving forward,\n> Decker-Osuntokun-Russell remains a superior technology over\n> Poon-Dryja.\n>\n> Regards, ZmnSCPxj _______________________________________________\n> Lightning-dev mailing list Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-08-02T03:43:23",
                "message_text_only": "Good morning Christian,\n\n> My issue is with the fact that CLTV-branches and nLocktimed spending\n> transactions also need to be guarded with a further `OP_CSV` condition,\n> since they may leak on-chain, and be immediately valid. This is the\n> reason why we introduced the two stage HTLC resolution, with the first\n> stage acting as the `OP_CSV` guard, and keeping the second stage clean.\n>\n> I think therefore the construction of the contract ought to be this:\n>\n> [/arbitrary/, A && B] -> [signA signB, (revoke) || (CSV && A && B && C)] -> [signA signB witnessCbyA, revoke || A] /* held by A */\n> [/arbitrary/, A && B] -> [signA signB, (revoke) || (CSV && A && B && C)] -> [signA signB witnessCbyB, revoke || B] /* held by B */\n>\n> Namely the CSV belongs in the output script, not the input script (which\n> is under the control of the spending party). Notice that I might have\n> misgroked your syntax :-) If C now contains a CLTV-branch whose timeout\n> expires before we attempt the on-chain mediation, suddenly both branches\n> become valid and we have a race.\n\nI believe not.  In the BOLT #3, a received HTLC looks like this:\n\n    ## (revoke) ||\n    OP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL\n    OP_IF\n        OP_CHECKSIG\n    OP_ELSE\n        ## B &&\n        <remote_htlcpubkey> OP_SWAP\n            OP_SIZE 32 OP_EQUAL\n        ## C\n        OP_IF\n            # To local node via HTLC-success transaction.\n            OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY\n            2 OP_SWAP <local_htlcpubkey> 2 OP_CHECKMULTISIG\n        OP_ELSE\n            # To remote node after timeout.\n            OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP\n            OP_CHECKSIG\n        OP_ENDIF\n    OP_ENDIF\n\nThe above contains no CSV, and is the output of the second transaction (the one that spends the funding transaction directly).  I annotated the SCRIPT with ## of what I consider each component to be (with A=local, B=remote).  I believe it is equivalent to ((revoke) || B && C), where C is the HTLC (A && (x == H(x))) || (CLTV)), with the requirement of A included within C and that this is \"simply\" an optimization (in principle, we could have required both local and remote HTLC pubkeys for the HTLC, but that just makes our witnesses unnecessarily larger).\n\nIt is instead the HTLC-timeout/HTLC-success transactions (which spends from the above script) that have a CSV:\n\n    OP_IF\n        ## (revoke) ||\n        # Penalty transaction\n        <revocationpubkey>\n    OP_ELSE\n        ## (CSV && A)\n        `to_self_delay`\n        OP_CSV\n        OP_DROP\n        <local_delayedpubkey>\n    OP_ENDIF\n    OP_CHECKSIG\n\nWhich I render as ((revoke) || (CSV && A)).\n\nThe need for the CSV here is precisely what you described, but it comes *after* the contract being enforced, not before.\n\nThus under Poon-Dryja the CSV occurs on a transaction that is dependent on a CLTV, not the other way around, and the CSV does not interfere with the CLTV. (indeed with current LN the CSV never comes into play during routing; if CSV interfered with CLTV here, then it should have been considered in our routing algorithm. instead we need to plan out this CSV-interference when we eventually move to Decker-Osuntokun-Russell eltoo channels.)\n\nThe drawback is that the condition in the second transaction becomes complicated, and thus cleverness like the above eliding of A from A && B && C is needed to keep witnesses and script size down.\n\nSincerely,\nAmkG"
            }
        ],
        "thread_summary": {
            "title": "Arbitrary Bitcoin Contracts over LN",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Michael Folkson",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 26169
        }
    },
    {
        "title": "[Lightning-dev] Lack of capacity field in channel_announcement makes life difficult. Why is it not there?",
        "thread_messages": [
            {
                "author": "Sjors Provoost",
                "date": "2018-08-01T18:28:41",
                "message_text_only": "+1 on this idea, no opinion on data structure\n\n> Op 29 jul. 2018, om 15:43 heeft Robert Olsson <robban at robtex.com> het volgende geschreven:\n> \n> \n> Regarding abuse:\n> Nodes checking blockchain can discard erroneous messages. If the messages slip thru to a wallet that doesn't verify, how much could this possibly hurt and where? Today for instance Eclair assumes all channels are wide enough anyhows.\n> \n> Regarding bandwidth:\n> Nodes should not broadcast updates after every packet, but do it wisely. And optionally. You could just announce the original capacity.\n\n\nAnd Christian Decker wrote:\n\n> (incidentally that is the main reason we started tracking an internal\n> UTXO set so we can stop asking bitcoind for full blocks just to check a\n> channel's capacity).\n\nThis could be very useful for fresh pruned nodes. When they receive gossip from before their birth, they would simply take notice in order to construct a map of the network, but hold off on fetching historical blocks to verify. Only when they need to make a payment, they would generate a bunch of candidate routes and fetch the relevant blocks to see if those channels were really created (and the UTXO set to make sure it's not closed).\n\nIt could still leave a bit of DOS risk if you gossip lies about lots of potentially useful channels in every historical block, forcing the pruned node to fetch these blocks one by one. Perhaps that can mitigated by a strong preference for channels created after wallet birth. There could also be cap on how many historical blocks are fetched before giving up. Anyway, this proposal doesn\u2019t change that risk profile.\n\nSjors\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180801/d3405fae/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Lack of capacity field in channel_announcement makes life difficult. Why is it not there?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Sjors Provoost"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1920
        }
    },
    {
        "title": "[Lightning-dev] Free Rebalancing Proposals",
        "thread_messages": [
            {
                "author": "Robert Olsson",
                "date": "2018-08-11T23:31:52",
                "message_text_only": "Dear All,\n\nI'd like to suggest a new function in the network, \"Free Rebalancing\nProposals\"\nIt is a fee-less, omni-beneficial rebalancing scheme\n\nBackground:\n\nI currently balance my nodes in the following way, extremely simplified:\n\n1) Identify channels that have too low remote_balance (A) and too low\nlocal_balance (B) for being of any use (in that direction)\n2) Find potential routes and amounts between all channels A and all\nchannels B that would optimize at least one of them\n3) Send a payment along those possible routes for different amounts, sorted\nafter fee, until one succeeds\n\nIt works quite good and is quite straight forward until the third step. So\nI would like to propose a better solution which works like this:\n\nSend a proposal-for-balancing-message over channel A, and the max amount\nyou would propose to balance in that direction.\n\nEach node analyses the in and out channels and adjusts the max to it's own\ndesire to balance. Max can only be adjusted down. Let's say the function is\n`int freeBalancerMax(channel in,channel out)`. It could be as simple as\nchecking how near \"in\" is to 100ksat local_balance and \"out\" is to 100ksat\nremote_balance. The node passes that message with new max value on to the\nnext node, much like a normal payment.\n\nWhen this packet comes back to the origin it will know how much the\nintermediate nodes are willing to let you balance, or if someone is\nreluctant to balance (and the final max value would be 0)\n\nIf everyone is happy (i.e. max>0), the origin node sends a payment along\nthis node, *without* dropping off any fees along the way, since all nodes\nagreed and benefit from the rebalancing act.\n\nSince all intermediate nodes benefit they are happy to do this without\nfees. Since they adjust max values to their desire it will stop multiple\nattempts from different nodes from starting to oscillate the balances in\nthe channels, but will instead reach some kind of equilibrium as long as\nthe node suggesting proposal uses it's freeBalancerMax when proposing and\naccepting proposals.\n\nThe intermediate nodes might not need to keep track of any agreements to\nbalancing proposals, it can simply call the freeBalancerMax function, and\nif the payment is lower, it passes on the payment even if it didn't get any\nfees, otherwise it fails as usual. If someone tries to send a non agreed\npayment without fees, but it coincides with the nodes own desire to\nrebalance, there is no harm done. Only problem with that is that senders\nmight flood a path with creative attempts trying to find a path with a\nfee-free hop. I think things like that will be stopped by a general\nthrottle functionality which probably will be needed anyhow.\n\nBest regards\nRobert Olsson\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180812/3c451db0/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-08-13T10:16:10",
                "message_text_only": "Good morning Robert,\n\nI assume, this functionality is transported also via the same onion-routing-packet style that current payment routing uses?\n\nIf so, then it seems this feature can be used by a payer and payee to coordinate to locate some route that would, if paid normally, charge fees, but if using the \"free rebalancing\" could be made free.  The payer simply locates some route, adds a synthetic initial balance that is much higher than the payment to be forwarded, and then request for a \"free rebalancing\" from the payer to the payee.  If at the payee node, the resulting \"max\" is greater than the actual payment being sent, then the payer and payee have found a fee-free route between them.\n\nAfter all, since the functionality is transported by onion-routing-packet, then intermediate hop routes cannot know that the ultimate source and ultimate destination are different nodes.\n\nNote that intermediate nodes cannot detect this at all.  A fee-free rebalance request that follows the fee-free rebalance query may be lower than the max it forwarded, since, a later intermediate node on the route might have lowered the maximum already.\n\n--\n\nFor myself, I think rebalancing is not a particular good solution to anything (similar to splice).\n\nImagine a simple 3-member cyclic-superhub network composed of A -> B -> C (looping back to -> A).  Node A may pay node C via B, and so on.  Now if C is a popular merchant for both B and A, then both the B-C and C-A channels will saturate in favor of C.  In such a case, no rebalancing is possible.\n\nA better solution is for C to purchase more incoming balance by asking either of B or A to transfer onchain funds in exchange for a preimage (i.e. swap offchain funds for onchain funds).  This is effectively \"batching\" the earnings that C gains in LN: C might earn a lot of small amounts, each one too small individually to justify onchain transfers, but which batched together can justify the onchain transfer.  Further, this batching is noncustodial and C can close the channel at any time (incurring an onchain fee), unlike current payment processors (PayPal, credit cards) where payment batching is custodial and may be frozen by the custodian; on LN, at worst the money will be locked for a few days or weeks, but will definitely be returned to you as long as you did not actually cheat.\n\nFurther this swapping can be done on a separate layer/software that interacts with ordinary existing LN software without requiring additional changes at the LN protocol level, which is always a good thing: I believe we should prefer to make LN a layer that supports further layers, not put every possible feature into LN.\n\nThis off-to-on and on-to-off swapping solves the same problems that both rebalancing and splcing do (channel balancing, incoming channels, channel reloading) without requiring changes at the LN layer, merely adding an application on top of LN.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn August 12, 2018 7:31 AM, Robert Olsson <robban at robtex.com> wrote:\n\n> Dear All,\n>\n> I'd like to suggest a new function in the network, \"Free Rebalancing Proposals\"\n> It is a fee-less, omni-beneficial rebalancing scheme\n>\n> Background:\n>\n> I currently balance my nodes in the following way, extremely simplified:\n>\n> 1) Identify channels that have too low remote_balance (A) and too low local_balance (B) for being of any use (in that direction)\n> 2) Find potential routes and amounts between all channels A and all channels B that would optimize at least one of them\n> 3) Send a payment along those possible routes for different amounts, sorted after fee, until one succeeds\n>\n> It works quite good and is quite straight forward until the third step. So I would like to propose a better solution which works like this:\n>\n> Send a proposal-for-balancing-message over channel A, and the max amount you would propose to balance in that direction.\n>\n> Each node analyses the in and out channels and adjusts the max to it's own desire to balance. Max can only be adjusted down. Let's say the function is `int freeBalancerMax(channel in,channel out)`. It could be as simple as checking how near \"in\" is to 100ksat local_balance and \"out\" is to 100ksat remote_balance. The node passes that message with new max value on to the next node, much like a normal payment.\n>\n> When this packet comes back to the origin it will know how much the intermediate nodes are willing to let you balance, or if someone is reluctant to balance (and the final max value would be 0)\n>\n> If everyone is happy (i.e. max>0), the origin node sends a payment along this node, *without* dropping off any fees along the way, since all nodes agreed and benefit from the rebalancing act.\n>\n> Since all intermediate nodes benefit they are happy to do this without fees. Since they adjust max values to their desire it will stop multiple attempts from different nodes from starting to oscillate the balances in the channels, but will instead reach some kind of equilibrium as long as the node suggesting proposal uses it's freeBalancerMax when proposing and accepting proposals.\n>\n> The intermediate nodes might not need to keep track of any agreements to balancing proposals, it can simply call the freeBalancerMax function, and if the payment is lower, it passes on the payment even if it didn't get any fees, otherwise it fails as usual. If someone tries to send a non agreed payment without fees, but it coincides with the nodes own desire to rebalance, there is no harm done. Only problem with that is that senders might flood a path with creative attempts trying to find a path with a fee-free hop. I think things like that will be stopped by a general throttle functionality which probably will be needed anyhow.\n>\n> Best regards\n> Robert Olsson\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180813/3661bd2a/attachment.html>"
            },
            {
                "author": "Robert Olsson",
                "date": "2018-08-13T12:24:45",
                "message_text_only": "Good Morning ZmnSCPxj!\n\nI was thinking using the normal onion-routing, probably modified in some\nway so it can read and modify max. Must admit I haven't studied that part\nat that level at all.\n\nFor simple three-member constructs it could be enough with a simple\nnon-onion message that A asks B if it would like to rebalance AB,BC and A\nasks C if it would like to balance BC,CA.\n\nBut first it seems I have to at least try to convince you that rebalancing\ndoes help solve some problems.\n\nI think rebalancing is good for many reasons.\nConsider a node A that has the following channel balances. It initiated A-B\nwith 100sat and used that up instantly. C initiated an inbound channel of\n200sat. A made a new channel A-D with 300sat\nIt ended up looking like the following:\n\nA-B     0-100\nA-C     0-200\nA-D     300-0\n\nFor simplicity in this case the total balance is 300-300. Also lets say\n\"balanced\" means \"able to send and receive 25 sat\". Achieving total balance\non all channels is not realistic. It's up to each node to decide their own\ndefinition.\n\nA has only one channel to send out via. If D goes down it has even fewer.\nSo my idea is: A finds if there exists any D-C channel (or multi-hop), and\npolitely asks whomever it may concern if sending 100 sat A->D->C->A would\nbenefit them as well. if it does you send over 100 sat and will end up with\n\nA-B     0-100\nA-C     100-100\nA-D     200-100\n\nIf the agreed max along the path is lower, it will have to do, it helped a\nlittle bit, but lets say 100sat was ok with everyone\nRepeat for A->D->B->A and 50sat and you will have\n\nA-B     50-50\nA-C     100-100\nA-D     150-150\n\nNow A instantly have 3 times as many possible routes out, and 50% more\npossible routes in, nobody had to go to the chain to close/open/splice, and\nnobodys channel went unbalanced, and nobody paid anyone.\n\nThe possibilites for others in the network to actually route via A\nincreases to all 6 paths from 2, before only B->A->D and C->A->D would\nsucceed. So there is also a 3-fold increase.\n\nConsider a bigger node with say 40 channels where 10 has too low local\nbalance and 30 has too low remote balance. It would have 300 working paths\nout of 1560, so about 80% failure rate.\n\nSo, for redundancy and maximum possible routes, I think rebalancing is good.\n\nThe main difference with this protocol compared to how we balance lightning\nchannels today is\n\n* that everyone benefits from it (or else would deny to be a part of it) so\nthere are not any fees\n* today channel balances sometimes start oscillating if two nodes try to\nbalance a channel somewhere in the network according to their own will,\nwithout caring/knowing about the intermediates wishes or eachothers. now we\ncare.\n* less trial and error since you know the perfect amount to send\n\n---\n\nIn the case you describe, it is a feature, not a bug.\nIf you find a path A->B->C->D\nC would like to balance BC against CD so it offers a rebalance and accepts\nfee-free transactions for things coming in BC and goes out CD. But maybe DB\nchannel doesn't exist or have too little capacity.\nIt's wishes to rebalance the channel remains. Then suddenly your payment\ngoes thru and achieves the same goal, I don't see a problem.\nif C did *not* want to balance in that direction, it would have rejected\npassing the payment for free\nif two payments pass thru the same channels, the second one will be\nrejected as normal with \"feeinsufficient\"\n\nIf we do want to avoid this (maybe because too many flood the network\nprobing to find a free hop), you can send the future payment hash, or part\nof it, in the proposal message, and whitelist that hash for 1337 seconds.\nEven if whitelisted, when/if the payment packet arrives, the node shall\ncheck in&out channel and amount to see if it is still beneficial, otherwise\njust reject it. The agreed max is a soft promise.\n\nRegarding receive-only or send-only nodes and on/off swapping, I think\nthose are entirely separate problems. My solution only aims at spreading\nthe existing grease around the layer two for smoother operation.\n\nBest Regards\nRobert Olsson\n\n\n\n\n\nOn Mon, Aug 13, 2018 at 1:16 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Robert,\n>\n> I assume, this functionality is transported also via the same\n> onion-routing-packet style that current payment routing uses?\n>\n> If so, then it seems this feature can be used by a payer and payee to\n> coordinate to locate some route that would, if paid normally, charge fees,\n> but if using the \"free rebalancing\" could be made free.  The payer simply\n> locates some route, adds a synthetic initial balance that is much higher\n> than the payment to be forwarded, and then request for a \"free rebalancing\"\n> from the payer to the payee.  If at the payee node, the resulting \"max\" is\n> greater than the actual payment being sent, then the payer and payee have\n> found a fee-free route between them.\n>\n> After all, since the functionality is transported by onion-routing-packet,\n> then intermediate hop routes cannot know that the ultimate source and\n> ultimate destination are different nodes.\n>\n> Note that intermediate nodes cannot detect this at all.  A fee-free\n> rebalance request that follows the fee-free rebalance query may be lower\n> than the max it forwarded, since, a later intermediate node on the route\n> might have lowered the maximum already.\n>\n> --\n>\n> For myself, I think rebalancing is not a particular good solution to\n> anything (similar to splice).\n>\n> Imagine a simple 3-member cyclic-superhub network composed of A -> B -> C\n> (looping back to -> A).  Node A may pay node C via B, and so on.  Now if C\n> is a popular merchant for both B and A, then both the B-C and C-A channels\n> will saturate in favor of C.  In such a case, no rebalancing is possible.\n>\n> A better solution is for C to purchase more incoming balance by asking\n> either of B or A to transfer onchain funds in exchange for a preimage (i.e.\n> swap offchain funds for onchain funds).  This is effectively \"batching\" the\n> earnings that C gains in LN: C might earn a lot of small amounts, each one\n> too small individually to justify onchain transfers, but which batched\n> together can justify the onchain transfer.  Further, this batching is\n> noncustodial and C can close the channel at any time (incurring an onchain\n> fee), unlike current payment processors (PayPal, credit cards) where\n> payment batching is custodial and may be frozen by the custodian; on LN, at\n> worst the money will be locked for a few days or weeks, but will definitely\n> be returned to you as long as you did not actually cheat.\n>\n> Further this swapping can be done on a separate layer/software that\n> interacts with ordinary existing LN software without requiring additional\n> changes at the LN protocol level, which is always a good thing: I believe\n> we should prefer to make LN a layer that supports further layers, not put\n> every possible feature into LN.\n>\n> This off-to-on and on-to-off swapping solves the same problems that both\n> rebalancing and splcing do (channel balancing, incoming channels, channel\n> reloading) without requiring changes at the LN layer, merely adding an\n> application on top of LN.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n>\n> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On August 12, 2018 7:31 AM, Robert Olsson <robban at robtex.com> wrote:\n>\n> Dear All,\n>\n> I'd like to suggest a new function in the network, \"Free Rebalancing\n> Proposals\"\n> It is a fee-less, omni-beneficial rebalancing scheme\n>\n> Background:\n>\n> I currently balance my nodes in the following way, extremely simplified:\n>\n> 1) Identify channels that have too low remote_balance (A) and too low\n> local_balance (B) for being of any use (in that direction)\n> 2) Find potential routes and amounts between all channels A and all\n> channels B that would optimize at least one of them\n> 3) Send a payment along those possible routes for different amounts,\n> sorted after fee, until one succeeds\n>\n> It works quite good and is quite straight forward until the third step. So\n> I would like to propose a better solution which works like this:\n>\n> Send a proposal-for-balancing-message over channel A, and the max amount\n> you would propose to balance in that direction.\n>\n> Each node analyses the in and out channels and adjusts the max to it's own\n> desire to balance. Max can only be adjusted down. Let's say the function is\n> `int freeBalancerMax(channel in,channel out)`. It could be as simple as\n> checking how near \"in\" is to 100ksat local_balance and \"out\" is to 100ksat\n> remote_balance. The node passes that message with new max value on to the\n> next node, much like a normal payment.\n>\n> When this packet comes back to the origin it will know how much the\n> intermediate nodes are willing to let you balance, or if someone is\n> reluctant to balance (and the final max value would be 0)\n>\n> If everyone is happy (i.e. max>0), the origin node sends a payment along\n> this node, *without* dropping off any fees along the way, since all nodes\n> agreed and benefit from the rebalancing act.\n>\n> Since all intermediate nodes benefit they are happy to do this without\n> fees. Since they adjust max values to their desire it will stop multiple\n> attempts from different nodes from starting to oscillate the balances in\n> the channels, but will instead reach some kind of equilibrium as long as\n> the node suggesting proposal uses it's freeBalancerMax when proposing and\n> accepting proposals.\n>\n> The intermediate nodes might not need to keep track of any agreements to\n> balancing proposals, it can simply call the freeBalancerMax function, and\n> if the payment is lower, it passes on the payment even if it didn't get any\n> fees, otherwise it fails as usual. If someone tries to send a non agreed\n> payment without fees, but it coincides with the nodes own desire to\n> rebalance, there is no harm done. Only problem with that is that senders\n> might flood a path with creative attempts trying to find a path with a\n> fee-free hop. I think things like that will be stopped by a general\n> throttle functionality which probably will be needed anyhow.\n>\n> Best regards\n> Robert Olsson\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180813/8b2ce414/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-08-14T02:46:45",
                "message_text_only": "Good morning Robert,\n\n> Good Morning ZmnSCPxj!\n>\n> I was thinking using the normal onion-routing, probably modified in some way so it can read and modify max. Must admit I haven't studied that part at that level at all.\n>\n> For simple three-member constructs it could be enough with a simple non-onion message that A asks B if it would like to rebalance AB,BC and A asks C if it would like to balance BC,CA.\n>\n> But first it seems I have to at least try to convince you that rebalancing does help solve some problems.\n>\n> I think rebalancing is good for many reasons.\n> Consider a node A that has the following channel balances. It initiated A-B with 100sat and used that up instantly. C initiated an inbound channel of 200sat. A made a new channel A-D with 300sat\n> It ended up looking like the following:\n>\n> A-B     0-100\n> A-C     0-200\n> A-D     300-0\n>\n> For simplicity in this case the total balance is 300-300. Also lets say \"balanced\" means \"able to send and receive 25 sat\". Achieving total balance on all channels is not realistic. It's up to each node to decide their own definition.\n>\n> A has only one channel to send out via. If D goes down it has even fewer.\n> So my idea is: A finds if there exists any D-C channel (or multi-hop), and politely asks whomever it may concern if sending 100 sat A->D->C->A would benefit them as well. if it does you send over 100 sat and will end up with\n>\n> A-B     0-100\n> A-C     100-100\n> A-D     200-100\n\nBut what is the state before and the state after of channel D-C?  Have you considered?\n\nI postulate that in any case where rebalancing is possible, then a payment route exists that is sufficient for payment to the network, and in the end, the purpose of LN is payment, not some ideal of channel balance.  This idea is a consequence of studying what I call \"cyclic superhubs\" where cycles of channels start with each channel consistently unbalanced in one direction and yet every node on that cycle is capable of paying to every other node on that cycle without need of explicit rebalancing.  Hence my reluctance to consider the addition of rebalancing at all.\n\nI think dynamic fee changing (lowering and increasing fees for channel directions you wish to rebalance away/towards you) is sufficient, and requires no update to the base LN protocol (but requires updating of actual implementations, since they all use fixed fees).\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180814/04d54db2/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Free Rebalancing Proposals",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Robert Olsson",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 21884
        }
    },
    {
        "title": "[Lightning-dev] Measuring Lightning Nodes",
        "thread_messages": [
            {
                "author": "Alex Evanovic",
                "date": "2018-08-17T09:34:12",
                "message_text_only": "Hi, I will actually be interested in measuring the network topology. Can I\nget a graph (or) all measurements of the lightning network topology from\nexplorer sites such as www.1ml.com?\n\nThanks,\nSwayam\n\nOn Sun, Jul 29, 2018 at 11:04 PM, Davison <otoburb at gmail.com> wrote:\n\n> >>If you want to just get the information without doing anything or\n> running a node, then you can look it up on explorer sites, like **1ml dot\n> org.**\n>\n> I believe Artem meant 1ml dot com.\n>\n> On Sun, Jul 29, 2018 at 11:37 AM \u0410\u0440\u0442\u0451\u043c \u041b\u0438\u0442\u0432\u0438\u043d\u043e\u0432\u0438\u0447 <theartlav at gmail.com>\n> wrote:\n> >\n> > Define \"measure\".\n> >\n> > If you want to know how many nodes and channels are there, you need to\n> connect to any LN node and set initial_routing_sync flag in init message.\n> This will prompt the peer to send you the whole gossip dump, containing\n> node and channel info of every public node/channel (sans channel\n> capacities).\n> >\n> > If you don't want to make stuff but just to query your c-lightning node,\n> then use listnodes and listchannels commands with lightning-cli.\n> >\n> > If you want to just get the information without doing anything or\n> running a node, then you can look it up on explorer sites, like 1ml dot org.\n> >\n> >\n> > -Artem\n> >\n> > 2018-07-29 17:21 GMT+03:00 Alex Evanovic <alex.evanovic.151 at gmail.com>:\n> >>\n> >> Hi all,\n> >>\n> >> Hope you are well.\n> >>\n> >> Can you please suggest how can I measure lightning nodes, in its\n> current state?\n> >>\n> >> Best,\n> >> Alex\n> >> \u1427\n> >>\n> >> _______________________________________________\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180817/45bd20dd/attachment.html>"
            },
            {
                "author": "Robert Olsson",
                "date": "2018-08-17T09:51:04",
                "message_text_only": "If you don't have a node yourself and just want the raw graph data you can\nget it from one of my lnd nodes at https://rompert.com/networkgraph\n(Same data that feeds the https://rompert.com/recksplorer/  )\n\nBest regards\nRobert Olsson\n\n\nOn Fri, Aug 17, 2018 at 12:34 PM, Alex Evanovic <alex.evanovic.151 at gmail.com\n> wrote:\n\n> Hi, I will actually be interested in measuring the network topology. Can I\n> get a graph (or) all measurements of the lightning network topology from\n> explorer sites such as www.1ml.com?\n>\n> Thanks,\n> Swayam\n>\n> On Sun, Jul 29, 2018 at 11:04 PM, Davison <otoburb at gmail.com> wrote:\n>\n>> >>If you want to just get the information without doing anything or\n>> running a node, then you can look it up on explorer sites, like **1ml dot\n>> org.**\n>>\n>> I believe Artem meant 1ml dot com.\n>>\n>> On Sun, Jul 29, 2018 at 11:37 AM \u0410\u0440\u0442\u0451\u043c \u041b\u0438\u0442\u0432\u0438\u043d\u043e\u0432\u0438\u0447 <theartlav at gmail.com>\n>> wrote:\n>> >\n>> > Define \"measure\".\n>> >\n>> > If you want to know how many nodes and channels are there, you need to\n>> connect to any LN node and set initial_routing_sync flag in init message.\n>> This will prompt the peer to send you the whole gossip dump, containing\n>> node and channel info of every public node/channel (sans channel\n>> capacities).\n>> >\n>> > If you don't want to make stuff but just to query your c-lightning\n>> node, then use listnodes and listchannels commands with lightning-cli.\n>> >\n>> > If you want to just get the information without doing anything or\n>> running a node, then you can look it up on explorer sites, like 1ml dot org.\n>> >\n>> >\n>> > -Artem\n>> >\n>> > 2018-07-29 17:21 GMT+03:00 Alex Evanovic <alex.evanovic.151 at gmail.com>:\n>> >>\n>> >> Hi all,\n>> >>\n>> >> Hope you are well.\n>> >>\n>> >> Can you please suggest how can I measure lightning nodes, in its\n>> current state?\n>> >>\n>> >> Best,\n>> >> Alex\n>> >> \u1427\n>> >>\n>> >> _______________________________________________\n>> >> Lightning-dev mailing list\n>> >> Lightning-dev at lists.linuxfoundation.org\n>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180817/837b24b3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Measuring Lightning Nodes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Robert Olsson",
                "Alex Evanovic"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4729
        }
    },
    {
        "title": "[Lightning-dev] [announce] LNvis alpha - A Lightning Network Visualizer",
        "thread_messages": [
            {
                "author": "William Casarin",
                "date": "2018-08-17T15:51:31",
                "message_text_only": "Hello lightning/bitcoin devs,\n\nI've been working on an OpenGL Lighting Network visualizer written in C\n+ nanovg with no dependencies except for glfw. I thought I would release\nthe alpha here first for testing.\n\nRight now it only parses c-lightning channels and node json, but I'm\ncurrently adding support for LND. I've only tested on linux, so it would\nbe great if we could get this working on macos/windows as well.\n\nPicture: https://jb55.com/s/abe49a248360d41c.png\nCode: https://github.com/jb55/lnvis\n\n\nHow it works\n------------\n\nLNvis renders the Lightning Network channel gossip, which include nodes\nand the edges (channels) between those nodes.\n\n- Channels are colored by the node that opened the channel\n- Channel widths are rendered proportional to the capacity\n- Right clicking a node filters the view to that node and its neighbors\n- Dragging a node in any view will focus that node and its neihbors\n\nThat's about it for now. Next things that I think would be fun to have:\n\n- Filter by alias/id in the UI\n- \"Google Maps\" mode for highlighting potential routes between nodes\n- Realtime channel updates from network gossip\n\nAny other ideas and suggesstions would be great.\n\nContributors welcome!\n\nCheers,\nWill"
            }
        ],
        "thread_summary": {
            "title": "LNvis alpha - A Lightning Network Visualizer",
            "categories": [
                "Lightning-dev",
                "announce"
            ],
            "authors": [
                "William Casarin"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1216
        }
    },
    {
        "title": "[Lightning-dev] W3C Web Payments Working Group / Payment Request API",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-08-23T21:15:04",
                "message_text_only": "Hey lightning devs,\n\nI was wondering if any of the companies here are members of W3C  and if\nanyone here could be member of the W3C Web Payments Working Group (c.f.:\nhttps://www.w3.org/Payments/WG/ )? According to this mail\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March.txt\nChristian Decker is a member. Which I think would be awesome!\n\nThey have just released their candidate recommendation for a payment API\nat: https://www.w3.org/TR/payment-request/ According to their site the\nproposed recommendation will be published not earlier than October 31st\n2018. They are currently looking for feedback in their github repository\nat: https://github.com/w3c/payment-request/\n\nI can see that they have bitcoin somewhat on their mind. But I guess it\nwould be even cooler if we could make sure that lightning payments will\nalso be compatible with their recommendation.\n\nChristian - if you really are a member -  could you give us an update on\nthat work? How relevant is it for us?\n\nbest Rene\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180823/b8855da4/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-08-30T14:15:52",
                "message_text_only": "Just a quick followup on this: yes, I am indeed a member of the W3C Web\nPayments Working Group, though not a very active one. I am following the\ndiscussion as best I can, and try to figure out what changes and special\nconsiderations, if any, are needed for both Bitcoin and Lightning to\nwork correctly, when the spec is finalized and deployed.\n\nAs it stands today the spec should be Bitcoin and Lightning compatible,\nwith the following considerations:\n\n - A special Payment Method ID [1] must be assigned to Bitcoin and\n   Lightning since we cannot rely on a centralized URL to act as a\n   payment method for these decentralized networks. Currently only the\n   `basic-card` identifier has been assigned, but we can apply for one\n   eventually;\n - As far as I see a local handler can be specified as Payment Handler\n   [2] allowing us to have a Bitcoin or Lightning daemon running locally\n   that is invoked for payment requests;\n - The Payment Request API [3] even mentions XBT as a supported\n   currency, in addition to ISO4217 codes, so if a vendor publishes a\n   Bitcoin amount and a matching Payment Method, we should be able to\n   perform the payment;\n - Since we require special handling for Bitcoin and Lightning\n   w.r.t. the Payment Method, the Payment Method Manifest [4] doesn't\n   apply to us.\n\nSo all in all, we should be able to get Bitcoin and Lightning working\nwith the spec without any major roadblocks. Notice that this is based\nsolely on my current understanding of the spec, and I'd love for others\nto chime in and point out anything that I might have missed.\n\nCheers,\nChristian\n\n[1] https://www.w3.org/TR/payment-method-id/\n[2] https://www.w3.org/TR/payment-handler/\n[3] https://www.w3.org/TR/payment-request/\n[4] https://www.w3.org/TR/payment-method-manifest/\n\nRen\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n\n> Hey lightning devs,\n>\n> I was wondering if any of the companies here are members of W3C  and if\n> anyone here could be member of the W3C Web Payments Working Group (c.f.:\n> https://www.w3.org/Payments/WG/ )? According to this mail\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March.txt\n> Christian Decker is a member. Which I think would be awesome!\n>\n> They have just released their candidate recommendation for a payment API\n> at: https://www.w3.org/TR/payment-request/ According to their site the\n> proposed recommendation will be published not earlier than October 31st\n> 2018. They are currently looking for feedback in their github repository\n> at: https://github.com/w3c/payment-request/\n>\n> I can see that they have bitcoin somewhat on their mind. But I guess it\n> would be even cooler if we could make sure that lightning payments will\n> also be compatible with their recommendation.\n>\n> Christian - if you really are a member -  could you give us an update on\n> that work? How relevant is it for us?\n>\n> best Rene\n>\n> -- \n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "W3C Web Payments Working Group / Payment Request API",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "Christian Decker"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4484
        }
    },
    {
        "title": "[Lightning-dev] Including a Protocol for splicing to BOLT",
        "thread_messages": [
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-08-27T12:52:43",
                "message_text_only": "> Aside from that, spontaneous payments is amongst the most request feature\n> request I get from users and developers.\n\nA while ago I realized that spontaneous payments (without proof of\npayment, mostly for donations only) can be realized quite easily if the\npayer generates the preimage and hash, and includes the preimage in the\nsphinx message to the payee node. If the payee node recognizes the\nsphinx message format, it can use the preimage to claim the payment.\n\nCJP"
            },
            {
                "author": "Christian Decker",
                "date": "2018-08-27T13:19:16",
                "message_text_only": "Corn\u00e9 Plooy via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n>> Aside from that, spontaneous payments is amongst the most request feature\n>> request I get from users and developers.\n>\n> A while ago I realized that spontaneous payments (without proof of\n> payment, mostly for donations only) can be realized quite easily if the\n> payer generates the preimage and hash, and includes the preimage in the\n> sphinx message to the payee node. If the payee node recognizes the\n> sphinx message format, it can use the preimage to claim the payment.\n>\n> CJP\n\nYou mean like we describe in the Brainstorming wiki [1]? We definitely\nneed to make the Wiki more prominent :-)\n\n[1] https://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming#passing-a-transfer-secret-in-the-onion"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-08-27T13:22:49",
                "message_text_only": "Now that you remind me of the wiki: I remember we discussed this before,\nso maybe I was just repeating myself (sorry). It is true the wiki should\nbe more prominent.\n\n\nCJP\n\n\nOp 27-08-18 om 15:19 schreef Christian Decker:\n> Corn\u00e9 Plooy via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n> writes:\n>>> Aside from that, spontaneous payments is amongst the most request feature\n>>> request I get from users and developers.\n>> A while ago I realized that spontaneous payments (without proof of\n>> payment, mostly for donations only) can be realized quite easily if the\n>> payer generates the preimage and hash, and includes the preimage in the\n>> sphinx message to the payee node. If the payee node recognizes the\n>> sphinx message format, it can use the preimage to claim the payment.\n>>\n>> CJP\n> You mean like we describe in the Brainstorming wiki [1]? We definitely\n> need to make the Wiki more prominent :-)\n>\n> [1] https://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming#passing-a-transfer-secret-in-the-onion"
            }
        ],
        "thread_summary": {
            "title": "Including a Protocol for splicing to BOLT",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Corn\u00e9 Plooy",
                "Christian Decker"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2300
        }
    },
    {
        "title": "[Lightning-dev] Measuring centrality of nodes in LN graph",
        "thread_messages": [
            {
                "author": "Kulpreet Singh",
                "date": "2018-08-27T21:59:12",
                "message_text_only": "Hi all,\n\nI have been thinking about how we could measure the centrality of\nvarious nodes in the LN graph and the dependence on some nodes to\nroute payments and to prevent network partitions. I think measuring\nand tracking the changes in key metrics could help the community\ndecide on which nodes to open new channels with.\n\nI measured the centrality of nodes and the central point dominance as\ndefined in the seminal paper by Lindon C. Freeman, \"A Set of Measures\nof Centrality Based on Betweenness\", Sociometry 40, pp. 35-41, 1977.\n\nI also measured the number of articulation points in the network as\nper Robert E. Tarjan, \"Depth first search and linear graph algorithms\"\nSIAM Journal on Computing, 1(2):146-160, 1972.\n\nI want to add, that this is just a start, I understand that we should\nprobably look at treating LN as a directed graph and that we should do\nsome work in trying to do some analysis based on treating LN as a flow\nnetwork.\n\nHowever, I am eager to share my early results and would welcome any\nfeedback or suggestions on the way forward.\n\nI wrote a medium post describing the approach and show my results\nthere. I also elaborate on the choice of the two metrics and what they\nmean for LN. The post is available here:\nhttps://medium.com/@jungly/measuring-node-centrality-in-lightning-network-8102a59999f0\n\nLooking forward to your suggestions and feedback.\n\nThanks\nKulpreet"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-08-27T22:30:52",
                "message_text_only": "Hey Kulpreet,\n\nthanks for this nice overview article! I have just today implemented a\nfirst draft for the c-lightning autopilot [0]. I have implemented 4\nheuristics to select nodes to which one could connect. On of those [1]\nsamples from the nodes that contribute to the high diameter. This heuristic\nwas included not to increase the utility of the node that is running the\nautopilot but to improve the network properties. I believe that this\nheuristic should also reduce the articulation points and biconnected\ncomponents that you mention in your article. As endpoints of longest\nshortest paths will most likely be in two different biconnectivity\ncomponents (at least if those exist and have a certain size).\n\nRegarding the centrality. I also calculated the betweeness centrality and\nhave similar results  [2] to yours. I guess the difference will be due to\nthe fact that we don't work on the exact same snapshot. My autopilot\nimplementation also connects to a few rather central nodes. I doubt this is\nuseful for the network but I guess it is good for the node running the\nautopilot since it gains access to many nodes. ( Actually I think - but\ndon't know - that in combination with [1] it even helps the network).\n\nRegarding your 200 Articulation points I would guess that many of those are\njust nodes that only have one channel with the node that acts as an\narticulation point. I guess this is not something that we would need to\ntake care of so much since it is also in the responsibility of those nodes\nto have more than one channel. for larger biconnectivity components the\nproblem would probably be resolved with the above mentioned heuristic.\nTherefor I believe looking at the articulation points should not be our\nmain focus.\n\nSomething that (regarding the autopilot) I am currently missing in your\narticle is how much funds should be allocated for the suggested channels. I\nam currently experimenting with a probability density function that is\nproportional to the average capacity of each node in the candidate set. I\nsmooth this with a uniform distribution. However simulations at this point\nare quite expensive (if done primitively since the centralities have to be\nrecomputed) I guess this would be a nice future work. I will probably\ntomorrow publish the rest of the code for the lib-autopilot that uses this\nheuristic for channel balances since I am currently still working on it.\n\nIf you consider working more on the autopilot but also on research related\nto this I would also suggest the following resources [3],[4] and [5]\n\n[0] https://github.com/ElementsProject/lightning/pull/1888\n[1]\nhttps://github.com/renepickhardt/lightning/blob/8c91f57490b51f772513a274d679d3ab62e7201a/contrib/lib-autopilot.py#L205\n[2] https://twitter.com/renepickhardt/status/1034066602273193985\n[3] https://github.com/lightningnetwork/lnd/issues/677\n[4]\nhttps://github.com/renepickhardt/Automatically-Generating-a-Robust-Topology-for-the-Lightning-Network-on-top-of-Bitcoin\n[5]\nhttps://www.rene-pickhardt.de/improve-the-autopilot-of-bitcoins-lightning-network-summary-of-the-bar-camp-session-at-the-2nd-lightninghackday-in-berlin/\n\nbest regards Rene\n\n\nOn Mon, Aug 27, 2018 at 11:59 PM Kulpreet Singh <zapfmann at gmail.com> wrote:\n\n> Hi all,\n>\n> I have been thinking about how we could measure the centrality of\n> various nodes in the LN graph and the dependence on some nodes to\n> route payments and to prevent network partitions. I think measuring\n> and tracking the changes in key metrics could help the community\n> decide on which nodes to open new channels with.\n>\n> I measured the centrality of nodes and the central point dominance as\n> defined in the seminal paper by Lindon C. Freeman, \"A Set of Measures\n> of Centrality Based on Betweenness\", Sociometry 40, pp. 35-41, 1977.\n>\n> I also measured the number of articulation points in the network as\n> per Robert E. Tarjan, \"Depth first search and linear graph algorithms\"\n> SIAM Journal on Computing, 1(2):146-160, 1972.\n>\n> I want to add, that this is just a start, I understand that we should\n> probably look at treating LN as a directed graph and that we should do\n> some work in trying to do some analysis based on treating LN as a flow\n> network.\n>\n> However, I am eager to share my early results and would welcome any\n> feedback or suggestions on the way forward.\n>\n> I wrote a medium post describing the approach and show my results\n> there. I also elaborate on the choice of the two metrics and what they\n> mean for LN. The post is available here:\n>\n> https://medium.com/@jungly/measuring-node-centrality-in-lightning-network-8102a59999f0\n>\n> Looking forward to your suggestions and feedback.\n>\n> Thanks\n> Kulpreet\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180828/83b36302/attachment-0001.html>"
            },
            {
                "author": "Kulpreet Singh",
                "date": "2018-08-29T06:40:21",
                "message_text_only": "Hi Ren\u00e9,\n\nThanks for sharing the links to the issues and the excellent work you are doing.\n\nI see that you are quite interested in helping autopilot create a\ngraph such that is provides certain characteristics. It is quite a\nchallenging task, and I admire your courage to take it on. I saw your\nlib-autopilot too, though I didn't take a closer look at the code yet.\n\nI am focussing on a much simpler task of figuring out which metrics\nthe community will find useful and then trying to determine which\nalgorithms we could quickly run to get some initial results while we\ntry to develop more pertinent analysis algorithms.\n\nI focussed on betweeness centrality and articulation points as\npersonally I was most curious about those. Next I want to try and\nfigure out which max-flow algorithm might suit LN the best. Have you\nlooked at this? I might have missed something you might have already\npointed to.\n\nI noticed your concern about tracking articulation points. I agree,\nthat once central point dominance goes down the dependence on some\nimportant articulation points will go down too. But as I noticed in my\nresults, some nodes are high in the list of articulation points sorted\nby the number of atleast 5 node biconnected components they connect\nto. But their centrality is not that high. For example,\nmainnet.lightningconductor.net is in the list of top articulation\npoints but does not make it to the list of top 20 nodes by centrality.\n\nI am still curious about articulation points and want to keep tracking\nit, who knows we might learn something interesting by tracking the\ninformation.\n\nI am curious how are you running your graph evaluations. Are you using\npython binding to BGL or python networkx?\n\nI imagine we got slightly different results also because we used data\nfrom different times. I intend to publish the json output I got from\nLND when I get around to plotting my results on a chart so we can\nverify I am not making an error somewhere.\n\nThanks and regards\nKulpreet\n\n\nOn Tue, 28 Aug 2018 at 00:31, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com> wrote:\n>\n> Hey Kulpreet,\n>\n> thanks for this nice overview article! I have just today implemented a first draft for the c-lightning autopilot [0]. I have implemented 4 heuristics to select nodes to which one could connect. On of those [1] samples from the nodes that contribute to the high diameter. This heuristic was included not to increase the utility of the node that is running the autopilot but to improve the network properties. I believe that this heuristic should also reduce the articulation points and biconnected components that you mention in your article. As endpoints of longest shortest paths will most likely be in two different biconnectivity components (at least if those exist and have a certain size).\n>\n> Regarding the centrality. I also calculated the betweeness centrality and have similar results  [2] to yours. I guess the difference will be due to the fact that we don't work on the exact same snapshot. My autopilot implementation also connects to a few rather central nodes. I doubt this is useful for the network but I guess it is good for the node running the autopilot since it gains access to many nodes. ( Actually I think - but don't know - that in combination with [1] it even helps the network).\n>\n> Regarding your 200 Articulation points I would guess that many of those are just nodes that only have one channel with the node that acts as an articulation point. I guess this is not something that we would need to take care of so much since it is also in the responsibility of those nodes to have more than one channel. for larger biconnectivity components the problem would probably be resolved with the above mentioned heuristic. Therefor I believe looking at the articulation points should not be our main focus.\n>\n> Something that (regarding the autopilot) I am currently missing in your article is how much funds should be allocated for the suggested channels. I am currently experimenting with a probability density function that is proportional to the average capacity of each node in the candidate set. I smooth this with a uniform distribution. However simulations at this point are quite expensive (if done primitively since the centralities have to be recomputed) I guess this would be a nice future work. I will probably tomorrow publish the rest of the code for the lib-autopilot that uses this heuristic for channel balances since I am currently still working on it.\n>\n> If you consider working more on the autopilot but also on research related to this I would also suggest the following resources [3],[4] and [5]\n>\n> [0] https://github.com/ElementsProject/lightning/pull/1888\n> [1] https://github.com/renepickhardt/lightning/blob/8c91f57490b51f772513a274d679d3ab62e7201a/contrib/lib-autopilot.py#L205\n> [2] https://twitter.com/renepickhardt/status/1034066602273193985\n> [3] https://github.com/lightningnetwork/lnd/issues/677\n> [4] https://github.com/renepickhardt/Automatically-Generating-a-Robust-Topology-for-the-Lightning-Network-on-top-of-Bitcoin\n> [5] https://www.rene-pickhardt.de/improve-the-autopilot-of-bitcoins-lightning-network-summary-of-the-bar-camp-session-at-the-2nd-lightninghackday-in-berlin/\n>\n> best regards Rene\n>\n>\n> On Mon, Aug 27, 2018 at 11:59 PM Kulpreet Singh <zapfmann at gmail.com> wrote:\n>>\n>> Hi all,\n>>\n>> I have been thinking about how we could measure the centrality of\n>> various nodes in the LN graph and the dependence on some nodes to\n>> route payments and to prevent network partitions. I think measuring\n>> and tracking the changes in key metrics could help the community\n>> decide on which nodes to open new channels with.\n>>\n>> I measured the centrality of nodes and the central point dominance as\n>> defined in the seminal paper by Lindon C. Freeman, \"A Set of Measures\n>> of Centrality Based on Betweenness\", Sociometry 40, pp. 35-41, 1977.\n>>\n>> I also measured the number of articulation points in the network as\n>> per Robert E. Tarjan, \"Depth first search and linear graph algorithms\"\n>> SIAM Journal on Computing, 1(2):146-160, 1972.\n>>\n>> I want to add, that this is just a start, I understand that we should\n>> probably look at treating LN as a directed graph and that we should do\n>> some work in trying to do some analysis based on treating LN as a flow\n>> network.\n>>\n>> However, I am eager to share my early results and would welcome any\n>> feedback or suggestions on the way forward.\n>>\n>> I wrote a medium post describing the approach and show my results\n>> there. I also elaborate on the choice of the two metrics and what they\n>> mean for LN. The post is available here:\n>> https://medium.com/@jungly/measuring-node-centrality-in-lightning-network-8102a59999f0\n>>\n>> Looking forward to your suggestions and feedback.\n>>\n>> Thanks\n>> Kulpreet\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618"
            },
            {
                "author": "Elias Rohrer",
                "date": "2018-08-29T09:45:24",
                "message_text_only": "Hello Kulpreet,\n\nthank you a lot for your work, your post highlights some really interesting results.\n\nI'm looking forward to your future work measuring the network's structure and decentralization. Moreover, I find thinking about the LN as a flow network to be a real interesting perspective. In fact, as an initial entry towards this direction, we did some work on a multi-path routing algorithm based on the push-relabel algorithm (cf. [1]). However, I think there is much room for improvement and other flow algorithms could turn out to be promising candidates for routing in the LN.\n\nAs far as I understood, you would be using flow algorithms for a more in-depth analysis of the networks graph structure?\n\nKind Regards,\n\nElias\n\n[1]: https://arxiv.org/abs/1708.02419\n\n\nOn 29 Aug 2018, at 8:40, Kulpreet Singh wrote:\n\n> Hi Ren\u00e9,\n>\n> Thanks for sharing the links to the issues and the excellent work you are doing.\n>\n> I see that you are quite interested in helping autopilot create a\n> graph such that is provides certain characteristics. It is quite a\n> challenging task, and I admire your courage to take it on. I saw your\n> lib-autopilot too, though I didn't take a closer look at the code yet.\n>\n> I am focussing on a much simpler task of figuring out which metrics\n> the community will find useful and then trying to determine which\n> algorithms we could quickly run to get some initial results while we\n> try to develop more pertinent analysis algorithms.\n>\n> I focussed on betweeness centrality and articulation points as\n> personally I was most curious about those. Next I want to try and\n> figure out which max-flow algorithm might suit LN the best. Have you\n> looked at this? I might have missed something you might have already\n> pointed to.\n>\n> I noticed your concern about tracking articulation points. I agree,\n> that once central point dominance goes down the dependence on some\n> important articulation points will go down too. But as I noticed in my\n> results, some nodes are high in the list of articulation points sorted\n> by the number of atleast 5 node biconnected components they connect\n> to. But their centrality is not that high. For example,\n> mainnet.lightningconductor.net is in the list of top articulation\n> points but does not make it to the list of top 20 nodes by centrality.\n>\n> I am still curious about articulation points and want to keep tracking\n> it, who knows we might learn something interesting by tracking the\n> information.\n>\n> I am curious how are you running your graph evaluations. Are you using\n> python binding to BGL or python networkx?\n>\n> I imagine we got slightly different results also because we used data\n> from different times. I intend to publish the json output I got from\n> LND when I get around to plotting my results on a chart so we can\n> verify I am not making an error somewhere.\n>\n> Thanks and regards\n> Kulpreet\n>\n>\n> On Tue, 28 Aug 2018 at 00:31, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com> wrote:\n>>\n>> Hey Kulpreet,\n>>\n>> thanks for this nice overview article! I have just today implemented a first draft for the c-lightning autopilot [0]. I have implemented 4 heuristics to select nodes to which one could connect. On of those [1] samples from the nodes that contribute to the high diameter. This heuristic was included not to increase the utility of the node that is running the autopilot but to improve the network properties. I believe that this heuristic should also reduce the articulation points and biconnected components that you mention in your article. As endpoints of longest shortest paths will most likely be in two different biconnectivity components (at least if those exist and have a certain size).\n>>\n>> Regarding the centrality. I also calculated the betweeness centrality and have similar results  [2] to yours. I guess the difference will be due to the fact that we don't work on the exact same snapshot. My autopilot implementation also connects to a few rather central nodes. I doubt this is useful for the network but I guess it is good for the node running the autopilot since it gains access to many nodes. ( Actually I think - but don't know - that in combination with [1] it even helps the network).\n>>\n>> Regarding your 200 Articulation points I would guess that many of those are just nodes that only have one channel with the node that acts as an articulation point. I guess this is not something that we would need to take care of so much since it is also in the responsibility of those nodes to have more than one channel. for larger biconnectivity components the problem would probably be resolved with the above mentioned heuristic. Therefor I believe looking at the articulation points should not be our main focus.\n>>\n>> Something that (regarding the autopilot) I am currently missing in your article is how much funds should be allocated for the suggested channels. I am currently experimenting with a probability density function that is proportional to the average capacity of each node in the candidate set. I smooth this with a uniform distribution. However simulations at this point are quite expensive (if done primitively since the centralities have to be recomputed) I guess this would be a nice future work. I will probably tomorrow publish the rest of the code for the lib-autopilot that uses this heuristic for channel balances since I am currently still working on it.\n>>\n>> If you consider working more on the autopilot but also on research related to this I would also suggest the following resources [3],[4] and [5]\n>>\n>> [0] https://github.com/ElementsProject/lightning/pull/1888\n>> [1] https://github.com/renepickhardt/lightning/blob/8c91f57490b51f772513a274d679d3ab62e7201a/contrib/lib-autopilot.py#L205\n>> [2] https://twitter.com/renepickhardt/status/1034066602273193985\n>> [3] https://github.com/lightningnetwork/lnd/issues/677\n>> [4] https://github.com/renepickhardt/Automatically-Generating-a-Robust-Topology-for-the-Lightning-Network-on-top-of-Bitcoin\n>> [5] https://www.rene-pickhardt.de/improve-the-autopilot-of-bitcoins-lightning-network-summary-of-the-bar-camp-session-at-the-2nd-lightninghackday-in-berlin/\n>>\n>> best regards Rene\n>>\n>>\n>> On Mon, Aug 27, 2018 at 11:59 PM Kulpreet Singh <zapfmann at gmail.com> wrote:\n>>>\n>>> Hi all,\n>>>\n>>> I have been thinking about how we could measure the centrality of\n>>> various nodes in the LN graph and the dependence on some nodes to\n>>> route payments and to prevent network partitions. I think measuring\n>>> and tracking the changes in key metrics could help the community\n>>> decide on which nodes to open new channels with.\n>>>\n>>> I measured the centrality of nodes and the central point dominance as\n>>> defined in the seminal paper by Lindon C. Freeman, \"A Set of Measures\n>>> of Centrality Based on Betweenness\", Sociometry 40, pp. 35-41, 1977.\n>>>\n>>> I also measured the number of articulation points in the network as\n>>> per Robert E. Tarjan, \"Depth first search and linear graph algorithms\"\n>>> SIAM Journal on Computing, 1(2):146-160, 1972.\n>>>\n>>> I want to add, that this is just a start, I understand that we should\n>>> probably look at treating LN as a directed graph and that we should do\n>>> some work in trying to do some analysis based on treating LN as a flow\n>>> network.\n>>>\n>>> However, I am eager to share my early results and would welcome any\n>>> feedback or suggestions on the way forward.\n>>>\n>>> I wrote a medium post describing the approach and show my results\n>>> there. I also elaborate on the choice of the two metrics and what they\n>>> mean for LN. The post is available here:\n>>> https://medium.com/@jungly/measuring-node-centrality-in-lightning-network-8102a59999f0\n>>>\n>>> Looking forward to your suggestions and feedback.\n>>>\n>>> Thanks\n>>> Kulpreet\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>> --\n>> https://www.rene-pickhardt.de\n>>\n>> Skype: rene.pickhardt\n>>\n>> mobile: +49 (0)176 5762 3618\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180829/3c71f054/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 4970 bytes\nDesc: S/MIME digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180829/3c71f054/attachment-0001.p7s>"
            }
        ],
        "thread_summary": {
            "title": "Measuring centrality of nodes in LN graph",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "Elias Rohrer",
                "Kulpreet Singh"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 22410
        }
    }
]