[
    {
        "title": "[Lightning-dev] OP_CHECKSPVPROOFVERIFY",
        "thread_messages": [
            {
                "author": "Eric Lombrozo",
                "date": "2015-08-01T04:29:24",
                "message_text_only": "Minor script corrections:\n\nOP_IF\n\tOP_IF\n\t\tOP_HASH160 <VerifierRevocationHash> OP_EQUALVERIFY\n\tOP_ELSE\n\t\t<transaction> OP_CHECKSPVPROOFVERIFY OP_DROP OP_DROP OP_DROP\n\tOP_ENDIF\n\t<ProverPubKey> OP_CHECKSIG\nOP_ELSE\n\t<timeout> OP_CHECKLOCKTIMEVERIFY OP_DROP\n\t<VerifierPubKey> OP_CHECKSIG\nOP_ENDIF\n\n\n> On Jul 30, 2015, at 5:18 AM, Eric Lombrozo <elombrozo at gmail.com> wrote:\n> \n> Let me elaborate more on the way I see this working in practice. I\u2019ll ignore fees for now. Given that sending the proof on the blockchain is expensive, the parties need to negotiate how they split the risk. Moreover, once revoked, we want to encourage the second outputs to be claimed using the revocation secret, not the SPV proof\u2026but we\u2019ll ignore this detail for now.\n> \n> We have two parties, Prover and Verifier. Verifier wants to pay Prover one currency unit for an SPV proof. Assume they have an open channel with each party having 10 currency units.\n> \n> \n> Here are the commitment transactions:\n> \n> Verifier Commitment Transaction\n> =========================\n> 10\tProverSig\n> 1\tProverSig + VerifierRevocation || ProverSig + SPV proof || VerifierSig + timeout\n> 9\tProverSig + VerifierRevocation || VerifierSig + timeout\n> \n> Prover Commitment Transaction\n> =========================\n> 9\tVerifierSig\n> 1\tVerifierSig + ProverRevocation || ProverSig + SPV proof || VerifierSig + timeout\n> 10\tVerifierSig + ProverRevocation || ProverSig + timeout\n> \n> \n> A script for [ProverSig + VerifierRevocation || ProverSig + SPV proof || VerifierSig + timeout] could look like:\n> \n> OP_IF\n> \tOP_IF\n> \t\tOP_HASH160 <VerifierRevocation> OP_EQUALVERIFY\n> \tOP_ELSE\n> \t\t<transaction hash> OP_CHECKSPVPROOFVERIFY OP_DROP\n> \tOP_ENDIF\n> \t<ProverPubKey> OP_CHECKSIG\n> OP_ELSE\n> \t<timeout> OP_CHECKLOCKTIMEVERIFY OP_DROP\n> \t<VerifierPubKey> OP_CHECKSIG\n> OP_ENDIF\n> \n> \n> To redeem this output using the SPV proof, the Prover uses:\n> \n> <ProverSig> <block hash> <partial merkle tree for transaction> <0> <1>\n> \n> \n> Once the commitment transactions are created, the Prover gives the Verifier the SPV proof, then they negotiate settlement transactions and exchange revocations.\n> \n> Would something like this work?\n> \n>> On Jul 29, 2015, at 11:38 PM, Eric Lombrozo <elombrozo at gmail.com> wrote:\n>> \n>> I\u2019m not entirely clear on how you intended to use OP_CAT.\n>> \n>> I was thinking something along the lines of\n>> \n>> <block hash> <partial merkle tree for transaction> <transaction> OP_CHECKSPVPROOFVERIFY OP_DROP\n>> \n>> \n>> \n>> - Eric\n>> \n>> \n>>> On Jul 29, 2015, at 6:19 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>> \n>>> Eric Lombrozo <elombrozo at gmail.com> writes:\n>>>> I don\u2019t know if anyone has done any research or published anything in\n>>>> this regard, but one of the major issues with bitcoin I\u2019ve been trying\n>>>> to solve is how to properly incentivize nodes to construct SPV proofs.\n>>> \n>>> This can almost be done via P2SH, but not quite:\n>>> \n>>> 1) OP_CAT is disabled :(\n>>> 2) The txlen limit might bite, I'd have to do the maths.\n>>> \n>>> Cheers,\n>>> Rusty.\n>> \n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150731/5cfa2cc0/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-01T11:01:36",
                "message_text_only": "Eric Lombrozo <elombrozo at gmail.com> writes:\n> I\u2019m not entirely clear on how you intended to use OP_CAT.\n\nYou can open-code a merkle tree calculation using OP_CAT and OP_HASH256.\nNo need for a new OP (though that may be more efficient).\n\nAnyway, I think we're getting off-topic for this list.  AFAICT, this is\nnot lightning-specific.\n\nCheers,\nRusty."
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-08-01T11:04:58",
                "message_text_only": "> On Aug 1, 2015, at 4:01 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Eric Lombrozo <elombrozo at gmail.com> writes:\n>> I\u2019m not entirely clear on how you intended to use OP_CAT.\n> \n> You can open-code a merkle tree calculation using OP_CAT and OP_HASH256.\n> No need for a new OP (though that may be more efficient).\n\nGotcha.\n\n\n> Anyway, I think we're getting off-topic for this list.  AFAICT, this is\n> not lightning-specific.\n\nYou\u2019re right, this might not be the best place to discuss it - but I\u2019m not sure where to discuss it since such an idea doesn\u2019t make sense outside the context of a level 2 protocol.\n\n\n> Cheers,\n> Rusty.\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150801/5c3a1273/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "OP_CHECKSPVPROOFVERIFY",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Eric Lombrozo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4656
        }
    },
    {
        "title": "[Lightning-dev] Stealing money from a hub?",
        "thread_messages": [
            {
                "author": "Christopher Jamthagen",
                "date": "2015-08-01T09:37:50",
                "message_text_only": "> Sent:\u00a0Friday, July 31, 2015 at 1:48 AM\n> From:\u00a0\"Rusty Russell\" <rusty at rustcorp.com.au>\n> To:\u00a0\"Christopher Jamthagen\" <cjamthagen at gmx.com>\n> Cc:\u00a0\"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n> Subject:\u00a0Re: [Lightning-dev] Stealing money from a hub?\n> Christopher Jamthagen <cjamthagen at gmx.com> writes:\n>> Would it be desirable/possible to implement the timestop feature for\n>> CLTV as well? That would make the difference between the number of\n>> blocks until either expiration the same in case of a block-filling\n>> attack. If I'm not mistaken Peter Todds BIP is already merged, but\n>> this feature could be implemented with another soft fork.\n\n> Yes, timestop would logically be a softfork add, and it should apply to\n> both (same logic applies).\n\nIf the timestop feature would activate only when the CLTV transaction is included in a block, it would allow for a pretty serious DoS attack vector where hubs can be forced to close channels with other hubs by having the attacker, as the receiver, never reveal R and create a block-filling attack. This would force the hub connected to the receiver to broadcast the commitment transaction, but since there is a block-filling attack going on, the hub can't settle with the next hub because the first hubs CSV and CLTV are being pushed beyond the second hubs CLTV (which isn't broadcasted or included in a block yet, so the timestop feature doesn't apply) and so it goes on forcing every hub along the payment path back to the sender to broadcast their commitment transactions and closing the channels. It would be cheap to amplify this attack since the attacker only need to make enough HTLC transactions including as many hubs in LN as possible to take out a large portion of the network for a while.\n\nCLTV transactions would need to include the current block-height immediately when a commitment transaction is signed, so that miners can know where to start counting full blocks from as soon as it is broadcast. So my question is: Is such an upgrade for CLTV, as it is now, soft-forkable as it requires additional arguments? I am not totally clear on when upgrades are soft-forkable vs. hard-forkable.\n\n>> Speaking of being online all the time, checking the blockchain is\n>> outsourceable, right? So it seems that miners would be the perfect\n>> third party to check for cheaters in LN. By offering them a nice chunk\n>> of our counterparty's funds as fees, they should be incentiviced\n>> enough to keep an extra eye for us on the blockchain.\n\n> Outsourcability scales really well; once you're full-time monitoring the\n> blockchain, might as well get as many clients as possible. You can also\n> automate the outsourcee's fee, by including it in the \"steal\" tx.\n\nDoes it scale that well? I guess looking up pre-images in the shachain is fast, but what about R values in HTLCs? Would the third party have to store all those values or is there a nice optimization I have missed?\n\n> But I realized yesterday, outsourcing needs a new sighash op mode (or\n> normalized txids), so it's not really something to design a deployable\n> system around today.\n\nSo it is. What a shame.\n\n> Cheers,\n> Rusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-01T11:49:14",
                "message_text_only": "Christopher Jamthagen <cjamthagen at gmx.com> writes:\n>> Sent:\u00a0Friday, July 31, 2015 at 1:48 AM\n>> From:\u00a0\"Rusty Russell\" <rusty at rustcorp.com.au>\n>> To:\u00a0\"Christopher Jamthagen\" <cjamthagen at gmx.com>\n>> Cc:\u00a0\"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n>> Subject:\u00a0Re: [Lightning-dev] Stealing money from a hub?\n>> Christopher Jamthagen <cjamthagen at gmx.com> writes:\n>>> Would it be desirable/possible to implement the timestop feature for\n>>> CLTV as well? That would make the difference between the number of\n>>> blocks until either expiration the same in case of a block-filling\n>>> attack. If I'm not mistaken Peter Todds BIP is already merged, but\n>>> this feature could be implemented with another soft fork.\n>\n>> Yes, timestop would logically be a softfork add, and it should apply to\n>> both (same logic applies).\n>\n> If the timestop feature would activate only when the CLTV transaction\n> is included in a block, it would allow for a pretty serious DoS attack\n> vector where hubs can be forced to close channels with other hubs by\n> having the attacker, as the receiver, never reveal R and create a\n> block-filling attack.\n\nI don't think so.  Let's say the rule is \"time doesn't pass if a block\nis full\".\n\n> This would force the hub connected to the receiver to broadcast the\n> commitment transaction\n\nWhy?  The HTLC wouldn't expire, which would be a pain, but there's no\nreason to panic and dump transactions.  By definition, during a block\nfilling attack you've got all the time in the world.\n\nNow, preventing HTLCs from expiring is a DoS, but a lesser one.\n\nWhat am I missing?\n\n> CLTV transactions would need to include the current block-height\n> immediately when a commitment transaction is signed, so that miners\n> can know where to start counting full blocks from as soon as it is\n> broadcast. So my question is: Is such an upgrade for CLTV, as it is\n> now, soft-forkable as it requires additional arguments? I am not\n> totally clear on when upgrades are soft-forkable vs. hard-forkable.\n\nAnything which is a furthur restriction (as in \"this used to be valid,\nand no longer is\") is soft-forkable.  So delaying timeouts is a soft-fork.\n\n>>> Speaking of being online all the time, checking the blockchain is\n>>> outsourceable, right? So it seems that miners would be the perfect\n>>> third party to check for cheaters in LN. By offering them a nice chunk\n>>> of our counterparty's funds as fees, they should be incentiviced\n>>> enough to keep an extra eye for us on the blockchain.\n>\n>> Outsourcability scales really well; once you're full-time monitoring the\n>> blockchain, might as well get as many clients as possible. You can also\n>> automate the outsourcee's fee, by including it in the \"steal\" tx.\n>\n> Does it scale that well? I guess looking up pre-images in the shachain is fast, but what about R values in HTLCs? Would the third party have to store all those values or is there a nice optimization I have missed?\n\nIndeed, there's a separate thread where Anthony Towns points out that\nremembering R values and timeouts is an issue.\n\nI was referring to the part where you watch the chain for spends on the\nanchor outputs.  You only need to do work to check what happened when\none of them gets spent, should almost never happen (since the client\nshould tell you they're going to close the channel cooperatively).\n\nCheers,\nRusty."
            },
            {
                "author": "Christopher Jamthagen",
                "date": "2015-08-02T18:36:07",
                "message_text_only": ">> If the timestop feature would activate only when the CLTV transaction\n>> is included in a block, it would allow for a pretty serious DoS attack\n>> vector where hubs can be forced to close channels with other hubs by\n>> having the attacker, as the receiver, never reveal R and create a\n>> block-filling attack.\n\n> I don't think so. Let's say the rule is \"time doesn't pass if a block\n> is full\".\n\nBut it would be necessary to explicitly supply the block-height at which the transaction that includes the CLTV was signed. Otherwise miners would have no other info but the block it is included in from which to count the number of full blocks to add to the expiration time of the CLTV.\n\n>> This would force the hub connected to the receiver to broadcast the\n>> commitment transaction\n\n> Why? The HTLC wouldn't expire, which would be a pain, but there's no\n> reason to panic and dump transactions. By definition, during a block\n> filling attack you've got all the time in the world.\n\nRight, the HTLC in the broadcasted commitment transaction between receiver and closest hub wouldn't expire, but the HTLC between the closest and second-closest hub would expire in a block-filling attack. Just to clarify, my example was with the timestop feature, but a CLTV implementation without announcement of explicit block at which the transaction was signed. \n\n> Now, preventing HTLCs from expiring is a DoS, but a lesser one.\n\n> What am I missing?\n\nProbably me who is missing something :)\n\n>> CLTV transactions would need to include the current block-height\n>> immediately when a commitment transaction is signed, so that miners\n>> can know where to start counting full blocks from as soon as it is\n>> broadcast. So my question is: Is such an upgrade for CLTV, as it is\n>> now, soft-forkable as it requires additional arguments? I am not\n>> totally clear on when upgrades are soft-forkable vs. hard-forkable.\n\n> Anything which is a furthur restriction (as in \"this used to be valid,\n> and no longer is\") is soft-forkable. So delaying timeouts is a soft-fork.\n\nGot it. Thanks.\n\n>>> Outsourcability scales really well; once you're full-time monitoring the\n>>> blockchain, might as well get as many clients as possible. You can also\n>>> automate the outsourcee's fee, by including it in the \"steal\" tx.\n>>\n>> Does it scale that well? I guess looking up pre-images in the shachain is fast, but what about R values in HTLCs? Would the third party have to store all those values or is there a nice optimization I have missed?\n\n> Indeed, there's a separate thread where Anthony Towns points out that\n> remembering R values and timeouts is an issue.\n\nOk, will have to find time to plow through the mailing list.\n\n> I was referring to the part where you watch the chain for spends on the\n> anchor outputs. You only need to do work to check what happened when\n> one of them gets spent, should almost never happen (since the client\n> should tell you they're going to close the channel cooperatively).\n\n> Cheers,\n> Rusty.\n\n\n\nAm I missing something when I claim that another input is necessary for the CLTV to make timestop work properly?"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-02T20:56:04",
                "message_text_only": "Christopher Jamthagen <cjamthagen at gmx.com> writes:\n>>> If the timestop feature would activate only when the CLTV transaction\n>>> is included in a block, it would allow for a pretty serious DoS attack\n>>> vector where hubs can be forced to close channels with other hubs by\n>>> having the attacker, as the receiver, never reveal R and create a\n>>> block-filling attack.\n>\n>> I don't think so. Let's say the rule is \"time doesn't pass if a block\n>> is full\".\n>\n> But it would be necessary to explicitly supply the block-height at which the transaction that includes the CLTV was signed. Otherwise miners would have no other info but the block it is included in from which to count the number of full blocks to add to the expiration time of the CLTV.\n\nNo, it would increase over time.  The CLTV block time and real block\ntime would diverge by 1 block / ~ 10 minutes every time a block is full.\n\nIt's the only sane way to do it, as you point out.\n\nIt doesn't help that we don't have a formal BIP to point at, but it's\nprobably a bit premature.\n\nHope that helps,\nRusty."
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-08-01T09:57:10",
                "message_text_only": "> On Jul 30, 2015, at 4:48 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> But I realized yesterday, outsourcing needs a new sighash op mode (or\n> normalized txids), so it's not really something to design a deployable\n> system around today.\n\nCan you elaborate on this, Rusty?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150801/f828e56a/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150801/f828e56a/attachment.sig>"
            },
            {
                "author": "Christopher Jamthagen",
                "date": "2015-08-01T10:30:16",
                "message_text_only": "> Sent:\u00a0Saturday, August 01, 2015 at 11:57 AM\n> From:\u00a0\"Eric Lombrozo\" <elombrozo at gmail.com>\n> To:\u00a0\"Rusty Russell\" <rusty at rustcorp.com.au>\n> Cc:\u00a0\"Christopher Jamthagen\" <cjamthagen at gmx.com>, \"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n> Subject:\u00a0Re: [Lightning-dev] Stealing money from a hub?\n\n\u00a0\n\n> On Jul 30, 2015, at 4:48 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\u00a0\n> But I realized yesterday, outsourcing needs a new sighash op mode (or\n> normalized txids), so it's not really something to design a deployable\n> system around today.\u00a0\n> Can you elaborate on this, Rusty?\n\nWe wont know the txid of the revoked commitment transaction until the cheater signs and broadcasts it, thus we cannot pre-sign the stealing transaction for the third party."
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-08-01T10:41:21",
                "message_text_only": "> On Aug 1, 2015, at 3:30 AM, Christopher Jamthagen <cjamthagen at gmx.com> wrote:\n> \n>> Sent: Saturday, August 01, 2015 at 11:57 AM\n>> From: \"Eric Lombrozo\" <elombrozo at gmail.com>\n>> To: \"Rusty Russell\" <rusty at rustcorp.com.au>\n>> Cc: \"Christopher Jamthagen\" <cjamthagen at gmx.com>, \"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n>> Subject: Re: [Lightning-dev] Stealing money from a hub?\n> \n> \n> \n>> On Jul 30, 2015, at 4:48 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>> But I realized yesterday, outsourcing needs a new sighash op mode (or\n>> normalized txids), so it's not really something to design a deployable\n>> system around today.\n>> Can you elaborate on this, Rusty?\n> \n> We wont know the txid of the revoked commitment transaction until the cheater signs and broadcasts it, thus we cannot pre-sign the stealing transaction for the third party.\n\nGot it. I suppose it would still be possible to have the third party notify you and request a signature when it occurs so that your device doesn\u2019t have to sit and monitor the network and do the filtering, etc...\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150801/45729f48/attachment-0001.sig>"
            },
            {
                "author": "Christopher Jamthagen",
                "date": "2015-08-01T10:46:59",
                "message_text_only": "> Sent:\u00a0Saturday, August 01, 2015 at 12:41 PM\n> From:\u00a0\"Eric Lombrozo\" <elombrozo at gmail.com>\n> To:\u00a0\"Christopher Jamthagen\" <cjamthagen at gmx.com>\n> Cc:\u00a0\"Rusty Russell\" <rusty at rustcorp.com.au>, \"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n> Subject:\u00a0Re: [Lightning-dev] Stealing money from a hub?\n>> On Aug 1, 2015, at 3:30 AM, Christopher Jamthagen <cjamthagen at gmx.com> wrote:\n>>\n>>> Sent: Saturday, August 01, 2015 at 11:57 AM\n>>> From: \"Eric Lombrozo\" <elombrozo at gmail.com>\n>>> To: \"Rusty Russell\" <rusty at rustcorp.com.au>\n>>> Cc: \"Christopher Jamthagen\" <cjamthagen at gmx.com>, \"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n>>> Subject: Re: [Lightning-dev] Stealing money from a hub?\n>>\n>>\n>>\n>>> On Jul 30, 2015, at 4:48 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>> But I realized yesterday, outsourcing needs a new sighash op mode (or\n>>> normalized txids), so it's not really something to design a deployable\n>>> system around today.\n>>> Can you elaborate on this, Rusty?\n>>\n>> We wont know the txid of the revoked commitment transaction until the cheater signs and broadcasts it, thus we cannot pre-sign the stealing transaction for the third party.\n\n> Got it. I suppose it would still be possible to have the third party notify you and request a signature when it occurs so that your device doesn\u2019t have to sit and monitor the network and do the > filtering, etc...\n\nOnce notified I could just sign the stealing transaction and take all the money myself."
            },
            {
                "author": "Eric Lombrozo",
                "date": "2015-08-01T10:58:11",
                "message_text_only": "> On Aug 1, 2015, at 3:46 AM, Christopher Jamthagen <cjamthagen at gmx.com> wrote:\n> \n> \n> \n> \n> \n>> Sent: Saturday, August 01, 2015 at 12:41 PM\n>> From: \"Eric Lombrozo\" <elombrozo at gmail.com>\n>> To: \"Christopher Jamthagen\" <cjamthagen at gmx.com>\n>> Cc: \"Rusty Russell\" <rusty at rustcorp.com.au>, \"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n>> Subject: Re: [Lightning-dev] Stealing money from a hub?\n>>> On Aug 1, 2015, at 3:30 AM, Christopher Jamthagen <cjamthagen at gmx.com> wrote:\n>>> \n>>>> Sent: Saturday, August 01, 2015 at 11:57 AM\n>>>> From: \"Eric Lombrozo\" <elombrozo at gmail.com>\n>>>> To: \"Rusty Russell\" <rusty at rustcorp.com.au>\n>>>> Cc: \"Christopher Jamthagen\" <cjamthagen at gmx.com>, \"lightning-dev at lists.linuxfoundation.org\" <lightning-dev at lists.linuxfoundation.org>\n>>>> Subject: Re: [Lightning-dev] Stealing money from a hub?\n>>> \n>>> \n>>> \n>>>> On Jul 30, 2015, at 4:48 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>>> But I realized yesterday, outsourcing needs a new sighash op mode (or\n>>>> normalized txids), so it's not really something to design a deployable\n>>>> system around today.\n>>>> Can you elaborate on this, Rusty?\n>>> \n>>> We wont know the txid of the revoked commitment transaction until the cheater signs and broadcasts it, thus we cannot pre-sign the stealing transaction for the third party.\n> \n>> Got it. I suppose it would still be possible to have the third party notify you and request a signature when it occurs so that your device doesn\u2019t have to sit and monitor the network and do the > filtering, etc...\n> \n> Once notified I could just sign the stealing transaction and take all the money myself.\n\nArgh\u2026it almost feels like there ought to be a clever way around these obstacles\u2026\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150801/d5fe2ea3/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-01T11:59:32",
                "message_text_only": "Eric Lombrozo <elombrozo at gmail.com> writes:\n>> On Aug 1, 2015, at 3:46 AM, Christopher Jamthagen <cjamthagen at gmx.com> wrote:\n>>> Got it. I suppose it would still be possible to have the third party notify you and request a signature when it occurs so that your device doesn\u2019t have to sit and monitor the network and do the > filtering, etc...\n>> \n>> Once notified I could just sign the stealing transaction and take all the money myself.\n>\n> Argh\u2026it almost feels like there ought to be a clever way around these obstacles\u2026\n\nI think if the system works the \"they tried to cheat!\" case never\nhappens, so anyone relying on income from that event will go broke.\n\nAnd it's possible for you to prove you paid the watcher, and possible\nfor watcher to prove they were watching, but not possible for the\nwatcher to prove they notified you.\n\nThus I think it's more likely you pay a tiny amount in advance every\nmonth.  Fortunately, I know some clever people designing a micropayment\nnetwork we can use...\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Stealing money from a hub?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Christopher Jamthagen",
                "Eric Lombrozo"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 18471
        }
    },
    {
        "title": "[Lightning-dev] v0.1 aka. \"MtGox's Cold Wallet\"",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-08-09T20:39:39",
                "message_text_only": "Hi all,\n\n        https://github.com/ElementsProject/lightning/commit/1cb147c5b87969ffa22ea0cdbdc3d9fdfd5b4c97\n\nIt's more a milestone than a \"release\".  This has test utilities for the\nHTLC outputs as well as the commitment transaction protocol which was\nthere before.  It uses a single-sided anchor.  You can see the current\nprotocol at:\n\n        https://github.com/ElementsProject/lightning/blob/1cb147c5b87969ffa22ea0cdbdc3d9fdfd5b4c97/lightning.proto      \n\nThe next milestone is to put the protocol into action as a real daemon.\nThat means developing a state machine for the protocol, which handles\ndisconnects, retransmissions, and all that fun stuff.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "v0.1 aka. \"MtGox's Cold Wallet\"",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 672
        }
    },
    {
        "title": "[Lightning-dev] A couple questions about sequence number:",
        "thread_messages": [
            {
                "author": "Jeremy Rubin",
                "date": "2015-08-10T15:03:56",
                "message_text_only": "Hi! A couple questions about the use of sequence numbers in lightning.\nPlease forgive me if these are somewhat rudimentary.\n\n1) Can someone better outline what the race conditions are? It seems\ncertain things time out w.r.t. the bitcoin blockchain height, which seems\nnegative with respect to censorship vulnerability. How is this addressed?\nSection 9.5 of the paper seems unsatisfactory.\n\n2) Using sequence numbers to select the right transaction to include is\ngood, but it would seem to leak information about how many LN transactions\ntook place, which could then make it meterable by external parties. (eg, a\nminer could make the fee for settling proportional to it). Perhaps\nincrementing by a random amount would alleviate the ability to reliably\nmeter. Maybe it is good that this can be metered?\n\nCheers,\n\nJeremy\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150810/eab58e4e/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2015-08-10T15:58:36",
                "message_text_only": "I believe there may be a misconception in your understanding. Lightning as\nimplemented by Rusty uses the sequence number field of the transaction\nformat, but not as an increment-on-each-transaction sequence number in the\ntraditional sense. Rather, BIP 68 (\nhttps://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki) specifies a\nnew consensus rule by which the sequence number field can mandate a\nrequired minimum age for each input, thereby achieving a relative\nlock-time. Lightning uses these relative lock-times.\n\nA sequence number of MAX_INT is allowed to confirm on the block chain in\nthe same block or later as its parent. A sequence number one less than that\ncannot confirm any earlier than one block AFTER its parent. A sequence\nnumber two less than MAX_INT requires two blocks to elapse, etc.\n\nSo let's say that you want a certain script pathway to only take effect 30\ndays after confirmation of the parent. You achieve this by checking in the\nscript that the sequence number of the spending transaction (the child) is\nequal to MAX_INT - 4320 (= 144 * 30). In the case of a bidirectional\npayment channel, this is a value that is ratcheted up (bringing the\nconfirmation delay down) each time the payment channel switches direction.\nSo for example, you might increment sequence number / decrement the time to\nconfirmation by 144 blocks (1 day) each time the payment channel switches\ndirection, regardless of the number of off-chain transactions that have\nelapsed in-between.\n\nOn Mon, Aug 10, 2015 at 8:03 AM, Jeremy Rubin <jr at mit.edu> wrote:\n\n> Hi! A couple questions about the use of sequence numbers in lightning.\n> Please forgive me if these are somewhat rudimentary.\n>\n> 1) Can someone better outline what the race conditions are? It seems\n> certain things time out w.r.t. the bitcoin blockchain height, which seems\n> negative with respect to censorship vulnerability. How is this addressed?\n> Section 9.5 of the paper seems unsatisfactory.\n>\n> 2) Using sequence numbers to select the right transaction to include is\n> good, but it would seem to leak information about how many LN transactions\n> took place, which could then make it meterable by external parties. (eg, a\n> miner could make the fee for settling proportional to it). Perhaps\n> incrementing by a random amount would alleviate the ability to reliably\n> meter. Maybe it is good that this can be metered?\n>\n> Cheers,\n>\n> Jeremy\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150810/6e33ee28/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-08-10T18:04:27",
                "message_text_only": "I really think the number inversion to \"preserve the old nSequence\nsemantics\" is not worth it. It's less usable and harder to understand.\nRenaming nSequence to nMaturity and \"check sequence verify\" to \"verify\ninput maturity\" (or something of the sort) may seem just\nbike-shedding, but I believe could greatly simplify the documentation.\nMaybe not the right thread to repeat this...\n\nOn Mon, Aug 10, 2015 at 5:58 PM, Mark Friedenbach <mark at friedenbach.org> wrote:\n> I believe there may be a misconception in your understanding. Lightning as\n> implemented by Rusty uses the sequence number field of the transaction\n> format, but not as an increment-on-each-transaction sequence number in the\n> traditional sense. Rather, BIP 68\n> (https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki) specifies a\n> new consensus rule by which the sequence number field can mandate a required\n> minimum age for each input, thereby achieving a relative lock-time.\n> Lightning uses these relative lock-times.\n>\n> A sequence number of MAX_INT is allowed to confirm on the block chain in the\n> same block or later as its parent. A sequence number one less than that\n> cannot confirm any earlier than one block AFTER its parent. A sequence\n> number two less than MAX_INT requires two blocks to elapse, etc.\n>\n> So let's say that you want a certain script pathway to only take effect 30\n> days after confirmation of the parent. You achieve this by checking in the\n> script that the sequence number of the spending transaction (the child) is\n> equal to MAX_INT - 4320 (= 144 * 30). In the case of a bidirectional payment\n> channel, this is a value that is ratcheted up (bringing the confirmation\n> delay down) each time the payment channel switches direction. So for\n> example, you might increment sequence number / decrement the time to\n> confirmation by 144 blocks (1 day) each time the payment channel switches\n> direction, regardless of the number of off-chain transactions that have\n> elapsed in-between.\n>\n> On Mon, Aug 10, 2015 at 8:03 AM, Jeremy Rubin <jr at mit.edu> wrote:\n>>\n>> Hi! A couple questions about the use of sequence numbers in lightning.\n>> Please forgive me if these are somewhat rudimentary.\n>>\n>> 1) Can someone better outline what the race conditions are? It seems\n>> certain things time out w.r.t. the bitcoin blockchain height, which seems\n>> negative with respect to censorship vulnerability. How is this addressed?\n>> Section 9.5 of the paper seems unsatisfactory.\n>>\n>> 2) Using sequence numbers to select the right transaction to include is\n>> good, but it would seem to leak information about how many LN transactions\n>> took place, which could then make it meterable by external parties. (eg, a\n>> miner could make the fee for settling proportional to it). Perhaps\n>> incrementing by a random amount would alleviate the ability to reliably\n>> meter. Maybe it is good that this can be metered?\n>>\n>> Cheers,\n>>\n>> Jeremy\n>> --\n>> @JeremyRubin\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2015-08-10T18:09:33",
                "message_text_only": "No I think it's a valid place to talk about it, and it helps clarify the\nfunctional goals.\n\nI need to dive in a little bit deeper into the implementation to really see\nwhat is going on, I didn't pick up on the sequence being only for direction\nflipping. Where should I look to observe this?\n\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\nOn Mon, Aug 10, 2015 at 2:04 PM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n\n> I really think the number inversion to \"preserve the old nSequence\n> semantics\" is not worth it. It's less usable and harder to understand.\n> Renaming nSequence to nMaturity and \"check sequence verify\" to \"verify\n> input maturity\" (or something of the sort) may seem just\n> bike-shedding, but I believe could greatly simplify the documentation.\n> Maybe not the right thread to repeat this...\n>\n> On Mon, Aug 10, 2015 at 5:58 PM, Mark Friedenbach <mark at friedenbach.org>\n> wrote:\n> > I believe there may be a misconception in your understanding. Lightning\n> as\n> > implemented by Rusty uses the sequence number field of the transaction\n> > format, but not as an increment-on-each-transaction sequence number in\n> the\n> > traditional sense. Rather, BIP 68\n> > (https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)\n> specifies a\n> > new consensus rule by which the sequence number field can mandate a\n> required\n> > minimum age for each input, thereby achieving a relative lock-time.\n> > Lightning uses these relative lock-times.\n> >\n> > A sequence number of MAX_INT is allowed to confirm on the block chain in\n> the\n> > same block or later as its parent. A sequence number one less than that\n> > cannot confirm any earlier than one block AFTER its parent. A sequence\n> > number two less than MAX_INT requires two blocks to elapse, etc.\n> >\n> > So let's say that you want a certain script pathway to only take effect\n> 30\n> > days after confirmation of the parent. You achieve this by checking in\n> the\n> > script that the sequence number of the spending transaction (the child)\n> is\n> > equal to MAX_INT - 4320 (= 144 * 30). In the case of a bidirectional\n> payment\n> > channel, this is a value that is ratcheted up (bringing the confirmation\n> > delay down) each time the payment channel switches direction. So for\n> > example, you might increment sequence number / decrement the time to\n> > confirmation by 144 blocks (1 day) each time the payment channel switches\n> > direction, regardless of the number of off-chain transactions that have\n> > elapsed in-between.\n> >\n> > On Mon, Aug 10, 2015 at 8:03 AM, Jeremy Rubin <jr at mit.edu> wrote:\n> >>\n> >> Hi! A couple questions about the use of sequence numbers in lightning.\n> >> Please forgive me if these are somewhat rudimentary.\n> >>\n> >> 1) Can someone better outline what the race conditions are? It seems\n> >> certain things time out w.r.t. the bitcoin blockchain height, which\n> seems\n> >> negative with respect to censorship vulnerability. How is this\n> addressed?\n> >> Section 9.5 of the paper seems unsatisfactory.\n> >>\n> >> 2) Using sequence numbers to select the right transaction to include is\n> >> good, but it would seem to leak information about how many LN\n> transactions\n> >> took place, which could then make it meterable by external parties.\n> (eg, a\n> >> miner could make the fee for settling proportional to it). Perhaps\n> >> incrementing by a random amount would alleviate the ability to reliably\n> >> meter. Maybe it is good that this can be metered?\n> >>\n> >> Cheers,\n> >>\n> >> Jeremy\n> >> --\n> >> @JeremyRubin\n> >>\n> >> _______________________________________________\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>\n> >\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150810/09f4bb9d/attachment-0001.html>"
            },
            {
                "author": "Adam Back",
                "date": "2015-08-10T19:08:38",
                "message_text_only": "The relative lock time is used so that channels do not automatically\nexpire.  With out RCLTV then new channels need to be established\nperiodically as they expire because expiry is a specific point in\ntime.\n\nWith RCLTV then the channel can stay running until a need arises to\nreclaim funds due from a hub that goes permanently offline.  Subject\nto rebalancing of funds that is achievable via users having mulitple\nchannels and being paid negative fees to move funds back to a channel\nthat is running low on liquidity then channels could potentially stay\nup indefinitely.\n\nAdam\n\n\nOn 10 August 2015 at 19:09, Jeremy Rubin <jr at mit.edu> wrote:\n> No I think it's a valid place to talk about it, and it helps clarify the\n> functional goals.\n>\n> I need to dive in a little bit deeper into the implementation to really see\n> what is going on, I didn't pick up on the sequence being only for direction\n> flipping. Where should I look to observe this?\n>\n>\n>\n> --\n> @JeremyRubin\n>\n> On Mon, Aug 10, 2015 at 2:04 PM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n>>\n>> I really think the number inversion to \"preserve the old nSequence\n>> semantics\" is not worth it. It's less usable and harder to understand.\n>> Renaming nSequence to nMaturity and \"check sequence verify\" to \"verify\n>> input maturity\" (or something of the sort) may seem just\n>> bike-shedding, but I believe could greatly simplify the documentation.\n>> Maybe not the right thread to repeat this...\n>>\n>> On Mon, Aug 10, 2015 at 5:58 PM, Mark Friedenbach <mark at friedenbach.org>\n>> wrote:\n>> > I believe there may be a misconception in your understanding. Lightning\n>> > as\n>> > implemented by Rusty uses the sequence number field of the transaction\n>> > format, but not as an increment-on-each-transaction sequence number in\n>> > the\n>> > traditional sense. Rather, BIP 68\n>> > (https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)\n>> > specifies a\n>> > new consensus rule by which the sequence number field can mandate a\n>> > required\n>> > minimum age for each input, thereby achieving a relative lock-time.\n>> > Lightning uses these relative lock-times.\n>> >\n>> > A sequence number of MAX_INT is allowed to confirm on the block chain in\n>> > the\n>> > same block or later as its parent. A sequence number one less than that\n>> > cannot confirm any earlier than one block AFTER its parent. A sequence\n>> > number two less than MAX_INT requires two blocks to elapse, etc.\n>> >\n>> > So let's say that you want a certain script pathway to only take effect\n>> > 30\n>> > days after confirmation of the parent. You achieve this by checking in\n>> > the\n>> > script that the sequence number of the spending transaction (the child)\n>> > is\n>> > equal to MAX_INT - 4320 (= 144 * 30). In the case of a bidirectional\n>> > payment\n>> > channel, this is a value that is ratcheted up (bringing the confirmation\n>> > delay down) each time the payment channel switches direction. So for\n>> > example, you might increment sequence number / decrement the time to\n>> > confirmation by 144 blocks (1 day) each time the payment channel\n>> > switches\n>> > direction, regardless of the number of off-chain transactions that have\n>> > elapsed in-between.\n>> >\n>> > On Mon, Aug 10, 2015 at 8:03 AM, Jeremy Rubin <jr at mit.edu> wrote:\n>> >>\n>> >> Hi! A couple questions about the use of sequence numbers in lightning.\n>> >> Please forgive me if these are somewhat rudimentary.\n>> >>\n>> >> 1) Can someone better outline what the race conditions are? It seems\n>> >> certain things time out w.r.t. the bitcoin blockchain height, which\n>> >> seems\n>> >> negative with respect to censorship vulnerability. How is this\n>> >> addressed?\n>> >> Section 9.5 of the paper seems unsatisfactory.\n>> >>\n>> >> 2) Using sequence numbers to select the right transaction to include is\n>> >> good, but it would seem to leak information about how many LN\n>> >> transactions\n>> >> took place, which could then make it meterable by external parties.\n>> >> (eg, a\n>> >> miner could make the fee for settling proportional to it). Perhaps\n>> >> incrementing by a random amount would alleviate the ability to reliably\n>> >> meter. Maybe it is good that this can be metered?\n>> >>\n>> >> Cheers,\n>> >>\n>> >> Jeremy\n>> >> --\n>> >> @JeremyRubin\n>> >>\n>> >> _______________________________________________\n>> >> Lightning-dev mailing list\n>> >> Lightning-dev at lists.linuxfoundation.org\n>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>\n>> >\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "A couple questions about sequence number:",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Adam Back",
                "Mark Friedenbach",
                "Jorge Tim\u00f3n",
                "Jeremy Rubin"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 16383
        }
    },
    {
        "title": "[Lightning-dev] ThunderNetwork - A Java LightningNetwork Implementation Working Today",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-11T16:12:04",
                "message_text_only": "Good Day everybody\n\nI present you a implementation for a Lightning Network Payment-Hub +\nClient. Everything is written in Java and can be accessed on\n\nhttp://thunder.network\n\nhttps://github.com/matsjj/thundernetwork\n\nI made some changes to the channel design to have everything working\non the current Blockchain, without the need for softforks. Due to\nthat, the network is no longer no-trust, but low-trust. This will\nchange with the upcoming new OP_CODES.\n\nThe provided wallet is just a prototype, I will focus on building a\npotent backend in the future. There are many wallets out there\nalready, it will be much more useful if those add these\nfunctionalities.\n\nUsing such a payment network will help to greatly release the pressure\nin the blocksize-debate. Furthermore, as there are less everyday\npayments on the blockchain, there is more space for important\ntransactions of higher value.\n\nI'm sure there is a lot I'm missing to explain. I'm also around in\nmost IRC-Channels ( mjerr )."
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T18:30:47",
                "message_text_only": "Hi Mats,\n\nInteresting work on payment channels, I think a lot of the bitcoinj code\ncan be used for further development as the necessary bitcoin softforks\nfor LN are incorporated. A bitcoinj implementation for lightning would\nbe great!\n\nOn Tue, Aug 11, 2015 at 06:12:04PM +0200, Mats Jerratsch wrote:\n> I present you a implementation for a Lightning Network Payment-Hub +\n> Client. Everything is written in Java and can be accessed on\n\nCan you do me a big favor and not call this an implementation for\nLightning Network, though? I would prefer some name like \"payment\nchannel networks\" or something similar, as it's materially different in\ndesign and trust models. In particular, if exit scams occur, I don't\nwant it to be associated with Lightning Network.\n\n> I made some changes to the channel design to have everything working\n> on the current Blockchain, without the need for softforks. Due to\n> that, the network is no longer no-trust, but low-trust. This will\n> change with the upcoming new OP_CODES.\n\nYeah, a lot of the code can definitely be used for a full LN\nimplementation when the opcodes come in for sure!\n\n> The provided wallet is just a prototype, I will focus on building a\n> potent backend in the future. There are many wallets out there\n> already, it will be much more useful if those add these\n> functionalities.\n\nSome quick feedback (might have more later):\n* I don't think a dual-Commitment structure is necessary if only one\n  party can close out the channel. The purpose of having two Commitments\n  is so that the payout structure is different. In this case, since only\n  the server can broadcast the final balance (and the client has no way\n  to close out the channel), only the B Commitment is necessary).\n* HTLCs have significant malleability risks with malicious servers\n  (hostage scenarios).\n* If you presume full-RBF (which I think is a game-theoretic\n  eventuality), clients can pay a higher fee to mutate the server's\n  broadcast of the Commitment, which will result in the server's funds\n  being held up permanently until the server is willing to negotiate\n  (malleability hostage scenario).\n* Exit Scamming is a distinct and likely possibility. The server can\n  develop a good reputation for a while, then decide to screw over\n  everyone. The server refuses to do any further transactions in any\n  channel which has funds in the clients favor (current channel balance\n  for the client is above what was funded). With the timeout, the server\n  gets the original deposit back, which is above what they should get\n  back, in other words, the server steals your money.\n* This creates an asymmetric playing field. If one cannot be confident\n  they will receive their funds back, this is similar to depositing your\n  money on a hosted wallet such as Coinbase or whatever. The primary\n  value of transacting on bitcoin is that the social costs of\n  counterparty risks are minimized -- and counterparty risk is one of\n  the primary inputs on interest rates (remove trust -> remove\n  counterparty risk -> remove fees/interest). This can only exist if\n  you're sufficiently willing to transact with nearly anyone (minimal\n  underwriting).\n\n> Furthermore, as there are less everyday payments on the blockchain,\n> there is more space for important transactions of higher value.\n\nI agree that this is one of the primary values of payment channel based\nsystems. To extend and take your point in a different direction, there\nis a risk if everyone uses blockchain transactions for every day\npurchases, that high-value transactions will crowd out low-value\ntransactions. There is a tension that exists between the need for\nsufficiently high fees to pay miners (when the block rewards decline)\nand allowing low-fee transactions to be on-chain in a timely manner.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-11T18:42:50",
                "message_text_only": "Hey Joseph,\n\nthank you very much for your invaluable feedback!\n\nCan you elaborate, why you think that the client is not able to close\nthe channel? I think this is a misunderstanding on your side, which\nmost of the rest of your post argues from. While there is a slight\nfavor for the server in the channel design, there is nothing what\nprevents the client from broadcasting (and enforcing) the channel.\n\nI will of course respect your inquiry - if you really mean it after\nthat misunderstanding - and stop calling it a Lightning Network\nimplementation as long as it does not provide the complete no-trust.\n\nI have thought a lot about RBF, and it is definitely a problem with\nthis implementation.\n\n2015-08-11 20:30 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n> Hi Mats,\n>\n> Interesting work on payment channels, I think a lot of the bitcoinj code\n> can be used for further development as the necessary bitcoin softforks\n> for LN are incorporated. A bitcoinj implementation for lightning would\n> be great!\n>\n> On Tue, Aug 11, 2015 at 06:12:04PM +0200, Mats Jerratsch wrote:\n>> I present you a implementation for a Lightning Network Payment-Hub +\n>> Client. Everything is written in Java and can be accessed on\n>\n> Can you do me a big favor and not call this an implementation for\n> Lightning Network, though? I would prefer some name like \"payment\n> channel networks\" or something similar, as it's materially different in\n> design and trust models. In particular, if exit scams occur, I don't\n> want it to be associated with Lightning Network.\n>\n>> I made some changes to the channel design to have everything working\n>> on the current Blockchain, without the need for softforks. Due to\n>> that, the network is no longer no-trust, but low-trust. This will\n>> change with the upcoming new OP_CODES.\n>\n> Yeah, a lot of the code can definitely be used for a full LN\n> implementation when the opcodes come in for sure!\n>\n>> The provided wallet is just a prototype, I will focus on building a\n>> potent backend in the future. There are many wallets out there\n>> already, it will be much more useful if those add these\n>> functionalities.\n>\n> Some quick feedback (might have more later):\n> * I don't think a dual-Commitment structure is necessary if only one\n>   party can close out the channel. The purpose of having two Commitments\n>   is so that the payout structure is different. In this case, since only\n>   the server can broadcast the final balance (and the client has no way\n>   to close out the channel), only the B Commitment is necessary).\n> * HTLCs have significant malleability risks with malicious servers\n>   (hostage scenarios).\n> * If you presume full-RBF (which I think is a game-theoretic\n>   eventuality), clients can pay a higher fee to mutate the server's\n>   broadcast of the Commitment, which will result in the server's funds\n>   being held up permanently until the server is willing to negotiate\n>   (malleability hostage scenario).\n> * Exit Scamming is a distinct and likely possibility. The server can\n>   develop a good reputation for a while, then decide to screw over\n>   everyone. The server refuses to do any further transactions in any\n>   channel which has funds in the clients favor (current channel balance\n>   for the client is above what was funded). With the timeout, the server\n>   gets the original deposit back, which is above what they should get\n>   back, in other words, the server steals your money.\n> * This creates an asymmetric playing field. If one cannot be confident\n>   they will receive their funds back, this is similar to depositing your\n>   money on a hosted wallet such as Coinbase or whatever. The primary\n>   value of transacting on bitcoin is that the social costs of\n>   counterparty risks are minimized -- and counterparty risk is one of\n>   the primary inputs on interest rates (remove trust -> remove\n>   counterparty risk -> remove fees/interest). This can only exist if\n>   you're sufficiently willing to transact with nearly anyone (minimal\n>   underwriting).\n>\n>> Furthermore, as there are less everyday payments on the blockchain,\n>> there is more space for important transactions of higher value.\n>\n> I agree that this is one of the primary values of payment channel based\n> systems. To extend and take your point in a different direction, there\n> is a risk if everyone uses blockchain transactions for every day\n> purchases, that high-value transactions will crowd out low-value\n> transactions. There is a tension that exists between the need for\n> sufficiently high fees to pay miners (when the block rewards decline)\n> and allowing low-fee transactions to be on-chain in a timely manner.\n>\n> --\n> Joseph Poon"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T19:16:07",
                "message_text_only": "On Tue, Aug 11, 2015 at 08:42:50PM +0200, Mats Jerratsch wrote:\n> Can you elaborate, why you think that the client is not able to close\n> the channel? I think this is a misunderstanding on your side, which\n> most of the rest of your post argues from. While there is a slight\n> favor for the server in the channel design, there is nothing what\n> prevents the client from broadcasting (and enforcing) the channel.\n\nAh, sorry, i'm reading it more closely now. I assumed only the server\nhad a copy since that what made the most sense to me under this kind of\nasymmetric model, since it makes sense to not trust the client.\n\nIn this case, the client can hold up funds from the server completely\nand attack the server by mutating their transaction.\n\nPresume Alice and Bob have a channel open together. They both\ncontributed 0.5 bitcoin for a total balance of 1 BTC.\n\nAt Commitment 20, the channel state is 0 BTC to Alice and 1 to Bob.\nAt commitment 31, the channel state is 1 BTC to Alice and 0 to Bob.\n\nAlice is the client and Bob is the server.\n\nPresume Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\nversion of Commitment 20. The server is out 1 BTC! This is now a hostage\nnegotiation.\n\nLet's presume that you set up some kind of reserve requirement instead:\nAt Commitment 20, the channel state is 0.05 BTC to Alice and 0.95 to Bob.\nAt commitment 31, the channel state is 0.95 BTC to Alice and 0.05 to Bob.\n\nAgain, Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\nversion of Commitment 20. The server is out 0.95 BTC! But wait, you say,\nAlice might be out 0.05 of her own BTC. This model breaks down because\nit's still a hostage scenario! Alice tells Bob, \"hey, I know I have 0.05\nBTC stuck here (and you have 0.9 stuck), but I'm rich. I don't care how\nlong it takes, how about you give me a 'tax' of 0.1 BTC. You'll get your\nmoney back... well most of it, just sign this transaction where I get\n0.15\".\n\n-- \nJoseph Poon"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-11T19:26:43",
                "message_text_only": "2015-08-11 21:16 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n> On Tue, Aug 11, 2015 at 08:42:50PM +0200, Mats Jerratsch wrote:\n>> Can you elaborate, why you think that the client is not able to close\n>> the channel? I think this is a misunderstanding on your side, which\n>> most of the rest of your post argues from. While there is a slight\n>> favor for the server in the channel design, there is nothing what\n>> prevents the client from broadcasting (and enforcing) the channel.\n>\n> Ah, sorry, i'm reading it more closely now. I assumed only the server\n> had a copy since that what made the most sense to me under this kind of\n> asymmetric model, since it makes sense to not trust the client.\n\nAh I see, yes, theres a lot of additional documentation needed. When\nyou have your head that deep into some topic for months, you assume\neveryone looks at your notes and understands everything just\nperfectly.\n\n[...]\n\n> At Commitment 20, the channel state is 0 BTC to Alice and 1 to Bob.\n> At commitment 31, the channel state is 1 BTC to Alice and 0 to Bob.\n>\n> Alice is the client and Bob is the server.\n>\n> Presume Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\n> version of Commitment 20. The server is out 1 BTC! This is now a hostage\n> negotiation.\n\nBut the 1 BTC of Commitment 20 goes straight to Bob (and not to a\nmulti-sig address). Mutating a channel transaction only hurts the\nparty that is doing the mutation. This is why RBF is a major problem,\nif it ever gets deployed.\n\n\n> Let's presume that you set up some kind of reserve requirement instead:\n> At Commitment 20, the channel state is 0.05 BTC to Alice and 0.95 to Bob.\n> At commitment 31, the channel state is 0.95 BTC to Alice and 0.05 to Bob.\n>\n> Again, Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\n> version of Commitment 20. The server is out 0.95 BTC! But wait, you say,\n> Alice might be out 0.05 of her own BTC. This model breaks down because\n> it's still a hostage scenario! Alice tells Bob, \"hey, I know I have 0.05\n> BTC stuck here (and you have 0.9 stuck), but I'm rich. I don't care how\n> long it takes, how about you give me a 'tax' of 0.1 BTC. You'll get your\n> money back... well most of it, just sign this transaction where I get\n> 0.15\".\n\nThe same as above, if she resignes commitment 20, she is losing 0.05\nBTC, while Bob does still get the 0.95 BTC.\n\nThere is a problem with channel histories, where Alice holds all the\nfunds at one point, and Bob holds all the funds at some later point,\nas open payments are not as secure as those settled balances. I\nmitigate this by setting a hard requirement on the spendable amount. I\nwill describe this in more detail soon.\n\nBest Regards,\nMats Jerratsch\n\n>\n> --\n> Joseph Poon"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T20:06:23",
                "message_text_only": "On Tue, Aug 11, 2015 at 09:26:43PM +0200, Mats Jerratsch wrote:\n> > At Commitment 20, the channel state is 0 BTC to Alice and 1 to Bob.\n> > At commitment 31, the channel state is 1 BTC to Alice and 0 to Bob.\n> >\n> > Alice is the client and Bob is the server.\n> >\n> > Presume Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\n> > version of Commitment 20. The server is out 1 BTC! This is now a hostage\n> > negotiation.\n> \n> But the 1 BTC of Commitment 20 goes straight to Bob (and not to a\n> multi-sig address). Mutating a channel transaction only hurts the\n> party that is doing the mutation. This is why RBF is a major problem,\n> if it ever gets deployed.\n\nSorry, I usually use Bob as the attacker in my examples and Alice as the\nclient, so I got mixed up there. I meant:\nAt Commitment 20, the channel state is 1 BTC to Alice and 0 to Bob.\nAt commitment 31, the channel state is 0 BTC to Alice and 1 to Bob.\n\nIn this case, if Alice attacks Bob she's not out any money, but Bob has\nfunds locked up in a 2-of-2. Bob must now negotiate with Alice to get\nhis money back. Alice will probably want some 'convenience fee'.\n\n> \n> > Let's presume that you set up some kind of reserve requirement instead:\n> > At Commitment 20, the channel state is 0.05 BTC to Alice and 0.95 to Bob.\n> > At commitment 31, the channel state is 0.95 BTC to Alice and 0.05 to Bob.\n> >\n> > Again, Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\n> > version of Commitment 20. The server is out 0.95 BTC! But wait, you say,\n> > Alice might be out 0.05 of her own BTC. This model breaks down because\n> > it's still a hostage scenario! Alice tells Bob, \"hey, I know I have 0.05\n> > BTC stuck here (and you have 0.9 stuck), but I'm rich. I don't care how\n> > long it takes, how about you give me a 'tax' of 0.1 BTC. You'll get your\n> > money back... well most of it, just sign this transaction where I get\n> > 0.15\".\n> \n> The same as above, if she resignes commitment 20, she is losing 0.05\n> BTC, while Bob does still get the 0.95 BTC.\n\nAt Commitment 20, the channel state is 0.95 BTC to Alice and 0.05 to Bob.\nAt commitment 31, the channel state is 0.05 BTC to Alice and 0.95 to Bob.\n\n> There is a problem with channel histories, where Alice holds all the\n> funds at one point, and Bob holds all the funds at some later point,\n> as open payments are not as secure as those settled balances. I\n> mitigate this by setting a hard requirement on the spendable amount. I\n> will describe this in more detail soon.\n\nYou can't mitigate this by setting some reserve requirement, though. So\nlong as Alice has more money than Bob, she can do it. If Alice is 10x\nricher than Bob, she doesn't *care* and she knows Bob will eventually\ngive up. \"Two-party escrow\" doesn't work because one party can have more\nmoney and less time-value than another. Time-value is not a universal\nvalue.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-11T20:19:24",
                "message_text_only": "2015-08-11 22:06 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n> On Tue, Aug 11, 2015 at 09:26:43PM +0200, Mats Jerratsch wrote:\n>> > At Commitment 20, the channel state is 0 BTC to Alice and 1 to Bob.\n>> > At commitment 31, the channel state is 1 BTC to Alice and 0 to Bob.\n>> >\n>> > Alice is the client and Bob is the server.\n>> >\n>> > Presume Alice deicdes to be a jerk! She broadcasts a mutated (re-signed)\n>> > version of Commitment 20. The server is out 1 BTC! This is now a hostage\n>> > negotiation.\n>>\n>> But the 1 BTC of Commitment 20 goes straight to Bob (and not to a\n>> multi-sig address). Mutating a channel transaction only hurts the\n>> party that is doing the mutation. This is why RBF is a major problem,\n>> if it ever gets deployed.\n>\n> Sorry, I usually use Bob as the attacker in my examples and Alice as the\n> client, so I got mixed up there. I meant:\n> At Commitment 20, the channel state is 1 BTC to Alice and 0 to Bob.\n> At commitment 31, the channel state is 0 BTC to Alice and 1 to Bob.\n>\n> In this case, if Alice attacks Bob she's not out any money, but Bob has\n> funds locked up in a 2-of-2. Bob must now negotiate with Alice to get\n> his money back. Alice will probably want some 'convenience fee'.\n>\n\nBut Bob has both keys of the 2-of-2 multisig. One is his (main) key,\nand the other one was supplied by Alice as a requirement to update the\nchannel and move funds.\nBut that is what I meant with mitigate it. Even if Bob claims all\npayments, he will lose funds due to blockchain fees. (see below)\n\n> You can't mitigate this by setting some reserve requirement, though. So\n> long as Alice has more money than Bob, she can do it. If Alice is 10x\n> richer than Bob, she doesn't *care* and she knows Bob will eventually\n> give up. \"Two-party escrow\" doesn't work because one party can have more\n> money and less time-value than another. Time-value is not a universal\n> value.\n\nIt is possible to say that the minimum (stealable) amount of Alice\nmust be higher than any sum of concurrent payments minus the\nblockchain fees. This way Bob can always claim all the payments of all\nCommitments of the Channel and still stay in positive net balance. It\nreally comes down to having an incentive to clear out payments of the\nchannel. Only open payments are problematic, settled balance can\nalways be stealed with just one transaction.\n\nMats Jerratsch"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T20:33:05",
                "message_text_only": "Ah I see, if you use a hash-based revocation, then the only primary\nattack vector left is with the Funding and HTLCs (which can be\npartially mitigated with a reserve)\n\nOn 8/11/15, Mats Jerratsch <matsjj at gmail.com> wrote:\n> 2015-08-11 22:06 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n>> On Tue, Aug 11, 2015 at 09:26:43PM +0200, Mats Jerratsch wrote:\n>>> > At Commitment 20, the channel state is 0 BTC to Alice and 1 to Bob.\n>>> > At commitment 31, the channel state is 1 BTC to Alice and 0 to Bob.\n>>> >\n>>> > Alice is the client and Bob is the server.\n>>> >\n>>> > Presume Alice deicdes to be a jerk! She broadcasts a mutated\n>>> > (re-signed)\n>>> > version of Commitment 20. The server is out 1 BTC! This is now a\n>>> > hostage\n>>> > negotiation.\n>>>\n>>> But the 1 BTC of Commitment 20 goes straight to Bob (and not to a\n>>> multi-sig address). Mutating a channel transaction only hurts the\n>>> party that is doing the mutation. This is why RBF is a major problem,\n>>> if it ever gets deployed.\n>>\n>> Sorry, I usually use Bob as the attacker in my examples and Alice as the\n>> client, so I got mixed up there. I meant:\n>> At Commitment 20, the channel state is 1 BTC to Alice and 0 to Bob.\n>> At commitment 31, the channel state is 0 BTC to Alice and 1 to Bob.\n>>\n>> In this case, if Alice attacks Bob she's not out any money, but Bob has\n>> funds locked up in a 2-of-2. Bob must now negotiate with Alice to get\n>> his money back. Alice will probably want some 'convenience fee'.\n>>\n>\n> But Bob has both keys of the 2-of-2 multisig. One is his (main) key,\n> and the other one was supplied by Alice as a requirement to update the\n> channel and move funds.\n> But that is what I meant with mitigate it. Even if Bob claims all\n> payments, he will lose funds due to blockchain fees. (see below)\n>\n>> You can't mitigate this by setting some reserve requirement, though. So\n>> long as Alice has more money than Bob, she can do it. If Alice is 10x\n>> richer than Bob, she doesn't *care* and she knows Bob will eventually\n>> give up. \"Two-party escrow\" doesn't work because one party can have more\n>> money and less time-value than another. Time-value is not a universal\n>> value.\n>\n> It is possible to say that the minimum (stealable) amount of Alice\n> must be higher than any sum of concurrent payments minus the\n> blockchain fees. This way Bob can always claim all the payments of all\n> Commitments of the Channel and still stay in positive net balance. It\n> really comes down to having an incentive to clear out payments of the\n> channel. Only open payments are problematic, settled balance can\n> always be stealed with just one transaction.\n>\n> Mats Jerratsch\n>"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-11T20:44:27",
                "message_text_only": "Sweet!\n\nDo you mind if I start calling it a Lightning Network Implementation then? ;)\n\nAlso note that both these problems can be eliminated with OP_CLTV,\nwhich will be implemented at least somewhat soon.\n\n2015-08-11 22:33 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n> Ah I see, if you use a hash-based revocation, then the only primary\n> attack vector left is with the Funding and HTLCs (which can be\n> partially mitigated with a reserve)\n>\n> On 8/11/15, Mats Jerratsch <matsjj at gmail.com> wrote:\n>> 2015-08-11 22:06 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n>>> On Tue, Aug 11, 2015 at 09:26:43PM +0200, Mats Jerratsch wrote:\n>>>> > At Commitment 20, the channel state is 0 BTC to Alice and 1 to Bob.\n>>>> > At commitment 31, the channel state is 1 BTC to Alice and 0 to Bob.\n>>>> >\n>>>> > Alice is the client and Bob is the server.\n>>>> >\n>>>> > Presume Alice deicdes to be a jerk! She broadcasts a mutated\n>>>> > (re-signed)\n>>>> > version of Commitment 20. The server is out 1 BTC! This is now a\n>>>> > hostage\n>>>> > negotiation.\n>>>>\n>>>> But the 1 BTC of Commitment 20 goes straight to Bob (and not to a\n>>>> multi-sig address). Mutating a channel transaction only hurts the\n>>>> party that is doing the mutation. This is why RBF is a major problem,\n>>>> if it ever gets deployed.\n>>>\n>>> Sorry, I usually use Bob as the attacker in my examples and Alice as the\n>>> client, so I got mixed up there. I meant:\n>>> At Commitment 20, the channel state is 1 BTC to Alice and 0 to Bob.\n>>> At commitment 31, the channel state is 0 BTC to Alice and 1 to Bob.\n>>>\n>>> In this case, if Alice attacks Bob she's not out any money, but Bob has\n>>> funds locked up in a 2-of-2. Bob must now negotiate with Alice to get\n>>> his money back. Alice will probably want some 'convenience fee'.\n>>>\n>>\n>> But Bob has both keys of the 2-of-2 multisig. One is his (main) key,\n>> and the other one was supplied by Alice as a requirement to update the\n>> channel and move funds.\n>> But that is what I meant with mitigate it. Even if Bob claims all\n>> payments, he will lose funds due to blockchain fees. (see below)\n>>\n>>> You can't mitigate this by setting some reserve requirement, though. So\n>>> long as Alice has more money than Bob, she can do it. If Alice is 10x\n>>> richer than Bob, she doesn't *care* and she knows Bob will eventually\n>>> give up. \"Two-party escrow\" doesn't work because one party can have more\n>>> money and less time-value than another. Time-value is not a universal\n>>> value.\n>>\n>> It is possible to say that the minimum (stealable) amount of Alice\n>> must be higher than any sum of concurrent payments minus the\n>> blockchain fees. This way Bob can always claim all the payments of all\n>> Commitments of the Channel and still stay in positive net balance. It\n>> really comes down to having an incentive to clear out payments of the\n>> channel. Only open payments are problematic, settled balance can\n>> always be stealed with just one transaction.\n>>\n>> Mats Jerratsch\n>>"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T23:50:29",
                "message_text_only": "Hi Mats,\n\nOn Tue, Aug 11, 2015 at 10:44:27PM +0200, Mats Jerratsch wrote:\n> Do you mind if I start calling it a Lightning Network Implementation\n> then? ;)\n\nI can't stop you from calling it whatever you want, however, I'm just\nconcerned with any system which has some implicit level of trust,\nespecially with long-term systemic risks (e.g. implications for\nfungibility, and other social accessibility costs). The goal of LN is to\nallow you to connect to anyone without the risk of the counterparty\noutright stealing or encumbering funds. \n\nSo if the purpose is to get it working today with some trust\ncompromises, then any potential design trust issues may be associated\nwith LN. I don't want to encourage the use of systems which lets you\nmaliciously encumber HTLC funds in transit and funding on main-net. As\nmuch as I would absolutely appreciate how a semi-trusted implementation\nwould help counter the \"Lightning doesn't exist\" meme, it seems simpler\nto test with the new opcodes using dummy opcodes on testnet. I think we\nneed not only the opcodes, but also long-term I see some kind of\nmalleability fix and timestop as ideal if not necessary.\n\n> Also note that both these problems can be eliminated with OP_CLTV,\n> which will be implemented at least somewhat soon.\n\nYes, if it uses the new opcodes similar to Rusty's construction, then\nit's a LN implementation for sure (it will especially help with HTLCs in\ntransit). Do you expect any significant differences (beyond a balance\nreserve for just OP_CLTV)? I think a bitcoinj implementation of\nLightning is sorely needed, for sure, and greatly appreciate any\nimplementation, as it's a huge positive step for the bitcoin ecosystem!\nI feel like we might have gotten off on the wrong foot here (partially\ndue to me misunderstanding the design), I think we both agree that\nscalability of bitcoin micropayments is something that is very important\nto the wider ecosystem and I'm looking forward to continuing developing\nthese techonlogies with you!\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-14T01:26:44",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> I think a bitcoinj implementation of\n> Lightning is sorely needed, for sure, and greatly appreciate any\n> implementation, as it's a huge positive step for the bitcoin\n> ecosystem!\n\nMe too!\n\nSorry I've been a bit non-responsive: I really want to make sure I'm\nhappy with the basic inter-node protocol so we can start sharing it\n(yay, a bakeoff!).\n\nI love doing protocol design with fellow implementers: it tends to cut\nthrough the crap and get a good result.  And protocols are hard...\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "ThunderNetwork - A Java LightningNetwork Implementation Working Today",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Mats Jerratsch",
                "Joseph Poon"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 27655
        }
    },
    {
        "title": "[Lightning-dev] Python LightningNetwork implementation",
        "thread_messages": [
            {
                "author": "Jasper Hugunin",
                "date": "2015-08-11T17:48:57",
                "message_text_only": "Hi all,\n\nI'm Jasper Hugunin, a developer at HashPlex. I have implemented a full\nprototype Lightning node in Python and will be releasing tomorrow.\n\nFeatures include:\nMicropayment channels supporting unilateral close.\nBasic routing support which allows payment to be routed multiple hops.\nIntegration tests.\nMIT License.\n\nPlease be looking forward to it,\n- Jasper\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150811/ad83066f/attachment.html>"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T17:58:27",
                "message_text_only": "Hi Jasper,\n\nOn Tue, Aug 11, 2015 at 10:48:57AM -0700, Jasper Hugunin wrote:\n> I'm Jasper Hugunin, a developer at HashPlex. I have implemented a full\n> prototype Lightning node in Python and will be releasing tomorrow.\n> \n> Features include:\n> Micropayment channels supporting unilateral close.\n> Basic routing support which allows payment to be routed multiple hops.\n> Integration tests.\n> MIT License.\n\nVery cool, I'm looking forward to it!!\n\n-- \nJoseph Poon"
            },
            {
                "author": "Jasper Hugunin",
                "date": "2015-08-12T16:12:16",
                "message_text_only": "Sorry for the wait.\n\nHere is the repo: https://github.com/hashplex/Lightning\n\nThis version is meant to be a minimal node able to send payment across\nmultiple hops in the network. I intend to follow Rusty's micro-payment\nchannel design, but revocation and HTLCs have not yet been implemented.\nRouting also uses an insecure payment forwarding algorithm (since HTLCs are\nmissing), and does not handle channels closing. See the GitHub issue\ntracker for more details.\n\nI have attempted to split the server, the UI, the channel protocol, and the\nrouting protocol into separate modules so that they can be developed\nindependently. My hope is that someone interested in routing can work on\nthe routing protocol before micro-payment channels are fully secured.\n\nI look forward to working with you all,\n- Jasper\n\n\n\nOn Tue, Aug 11, 2015 at 10:58 AM, Joseph Poon <joseph at lightning.network>\nwrote:\n\n> Hi Jasper,\n>\n> On Tue, Aug 11, 2015 at 10:48:57AM -0700, Jasper Hugunin wrote:\n> > I'm Jasper Hugunin, a developer at HashPlex. I have implemented a full\n> > prototype Lightning node in Python and will be releasing tomorrow.\n> >\n> > Features include:\n> > Micropayment channels supporting unilateral close.\n> > Basic routing support which allows payment to be routed multiple hops.\n> > Integration tests.\n> > MIT License.\n>\n> Very cool, I'm looking forward to it!!\n>\n> --\n> Joseph Poon\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150812/53aab9cc/attachment.html>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2015-08-12T16:31:10",
                "message_text_only": "On Wed, Aug 12, 2015 at 11:12 AM, Jasper Hugunin <jasper at hashplex.com>\nwrote:\n\n> Here is the repo: https://github.com/hashplex/Lightning\n>\n\nThe routing seems to only send to one peer. What happens if that peer does\nnot know the destination either? or what if you have more than one peer?\n\nhttps://github.com/hashplex/Lightning/blob/fa94a05170faa954d3f6505265d34ac97983f083/lightning.py#L99\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150812/62d90baa/attachment.html>"
            },
            {
                "author": "Jasper Hugunin",
                "date": "2015-08-12T16:48:20",
                "message_text_only": "The routing protocol is a variant of distance-vector routing\n<https://en.wikipedia.org/wiki/Distance-vector_routing_protocol>. The idea\nis that nodes tell their peers beforehand \"I know how to get to node X, and\nit will cost you this much.\" Nodes use this information to build a routing\ntable saying \"If I want to send payment to node X, I should forward payment\nto node B.\" Then when payment needs to be sent, the node looks up \"Which of\nmy peers do I forward to?\" That is done by the \"SELECT nexthop, cost FROM\nROUTES WHERE address = ?\" query. If the peer you select does not know the\ndestination, they lied to you. If you have more than one peer, you choose\nthe cheapest one.\nThat said, the current routing protocol is something of a hack to\ndemonstrate potential, rather than a final solution.\n\nThanks,\n- Jasper\n\nOn Wed, Aug 12, 2015 at 9:31 AM, Bryan Bishop <kanzure at gmail.com> wrote:\n\n> On Wed, Aug 12, 2015 at 11:12 AM, Jasper Hugunin <jasper at hashplex.com>\n> wrote:\n>\n>> Here is the repo: https://github.com/hashplex/Lightning\n>>\n>\n> The routing seems to only send to one peer. What happens if that peer does\n> not know the destination either? or what if you have more than one peer?\n>\n>\n> https://github.com/hashplex/Lightning/blob/fa94a05170faa954d3f6505265d34ac97983f083/lightning.py#L99\n>\n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150812/bab6697b/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-14T01:28:30",
                "message_text_only": "Jasper Hugunin <jasper at hashplex.com> writes:\n> The routing protocol is a variant of distance-vector routing\n> <https://en.wikipedia.org/wiki/Distance-vector_routing_protocol>. The idea\n> is that nodes tell their peers beforehand \"I know how to get to node X, and\n> it will cost you this much.\" Nodes use this information to build a routing\n> table saying \"If I want to send payment to node X, I should forward payment\n> to node B.\" Then when payment needs to be sent, the node looks up \"Which of\n> my peers do I forward to?\" That is done by the \"SELECT nexthop, cost FROM\n> ROUTES WHERE address = ?\" query. If the peer you select does not know the\n> destination, they lied to you. If you have more than one peer, you choose\n> the cheapest one.\n> That said, the current routing protocol is something of a hack to\n> demonstrate potential, rather than a final solution.\n\nHi Jasper,\n\n        Yeah, routing is going to be hard, this seems perfectly workable\nfor bootstrapping.\n\nI'm hoping to review your code next week, once I've got my own protocol\nstate machine tested.\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Python LightningNetwork implementation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Jasper Hugunin",
                "Bryan Bishop",
                "Joseph Poon"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 5817
        }
    },
    {
        "title": "[Lightning-dev] Attacking the lightning network",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-08-11T19:38:16",
                "message_text_only": "Hi,\n\nThis is probably just stating the obvious. Sometimes that's useful though,\nand maybe this is one of those times!\n\nWhen setting up a new channel with an untrusted counterparty, you will wait\nfor N confirmations of their anchor transactions. Further, N might be well\nknown and common amongst a lot of lightning hubs (if it's not, then it will\nbe hard to know how long setting up a channel will take). What if N is too\nsmall, and I can afford to do a double-spend despite M (M > N)\nconfirmations as long as it gains me $X?\n\nThen I do the following:\n\n - I open one or more anonymous channels, capable of receiving at least $X\n - I start the doublespend fork\n - I then simultaneously construct multiple lightning channels, funding\nthem at $d each.\n - I wait for N confirmations so my new channels are active.\n - I quickly route multiple payments from my new channels to my anonymous\nchannels until I can't send anymore\n - I publish the doublespending fork, so that my $d*n never got spent\n - I close my original anonymous channels gaining $X <= $d*n\n\nThe only people worse off are the ones who opened the $d channels after N\nconfirmations -- any intermediary hubs are fine. Those hubs didn't have to\ncommit any funds to the new channels for the attack to work; the money they\nlose was that in other channels they used to route my payments forwards.\n\nWith onion routing, none of the ripped off hubs need know where the money\nended up, so there's not a lot of potential to do iron pipe cryptography to\nget your money back.\n\nThe only constraints here (I think) are:\n\n - how many channels you can open in M-N blocks\n - you have to have >$X funds available in the first place to commit to the\ndouble spend\n - how much capacity the lightning network actually has in routable bitcoin\n\nIf it costs 1.4*25*M bitcoin to mount a doublespend attack over M blocks\n(ie bribing 67% of hashpower for the time it normally takes to do 2*M\nblocks), and you can open 2000 channels per block, then that gives\n\n X > 1.4*25*M\n n < 2000*(M-N)\n\n X < d*n = d*2000*(M-N)\n\n 1.4*25*M < X < d*2000*(M-N)\n 35/2000 * M < d * (M-N)\n 35/2000 * (1 + N/(M-N)) < d\u200b\n\nSetting N = 12, M = 15 gives:\n\n d = 35/2000 * (1+4) = 7/80\n n = 6000\n\nso you're putting up 525 bitcoin by flooding the blockchain with anchor\ntransactions, sending it to yourself over lightning, then doublespending\nthe original 525 btc at a cost of spending ~505 btc on hashpower. Expensive\n($157k capital to make $6k profit), but still worthwhile (3.8% ROI in ~6\nhours is 16% a day, or about 5e25 % annualised...)\n\nMaybe if you make N depend on d you could mitigate this though -- something\nlike, if you to put \"$d\" on your side of the channel, you'll have to wait\nfor 5+(d*2000/25)*2 confirmations. So a $50 channel is d=.2 BTC, which is\n~37 confirmations, or about 6 hours. Increasing the blocksize (number of\nchannels openable per block) or lowering the block reward (decreasing the\ncost of a doublespend fork) increases the confirmations required though...\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150812/d8e1d102/attachment.html>"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-11T20:15:47",
                "message_text_only": "Hi Anthony,\n\nYes, reorg attacks are definitely a known with Bitcoin. You can send\nmoney to an exchange and then double-spend withdraw several\nconfirmations later if you have infinite hashrate.\n\nWith lightning, I think to fund the channel, the minimum confirmation\ntimes should be fairly high (even above 6 confirms). If a 120-block\nreorg occurs, bitcoin is pretty busted anyway, might be of out-of-scope\nwith Lightning. IMO, lightning reduces this attack.\n\nThe nice thing about payment channels is that after it's set up, you\ndon't worry about confirmation times if it's off-chain. For that reason,\nconfirmation times (and block mining rate, ~10 minutes) matters a lot\nless.\n\nOn Wed, Aug 12, 2015 at 03:38:16AM +0800, Anthony Towns wrote:\n> Hi,\n> \n> This is probably just stating the obvious. Sometimes that's useful though,\n> and maybe this is one of those times!\n> \n> When setting up a new channel with an untrusted counterparty, you will wait\n> for N confirmations of their anchor transactions. Further, N might be well\n> known and common amongst a lot of lightning hubs (if it's not, then it will\n> be hard to know how long setting up a channel will take). What if N is too\n> small, and I can afford to do a double-spend despite M (M > N)\n> confirmations as long as it gains me $X?\n> \n> Then I do the following:\n> \n>  - I open one or more anonymous channels, capable of receiving at least $X\n>  - I start the doublespend fork\n>  - I then simultaneously construct multiple lightning channels, funding\n> them at $d each.\n>  - I wait for N confirmations so my new channels are active.\n>  - I quickly route multiple payments from my new channels to my anonymous\n> channels until I can't send anymore\n>  - I publish the doublespending fork, so that my $d*n never got spent\n>  - I close my original anonymous channels gaining $X <= $d*n\n> \n> The only people worse off are the ones who opened the $d channels after N\n> confirmations -- any intermediary hubs are fine. Those hubs didn't have to\n> commit any funds to the new channels for the attack to work; the money they\n> lose was that in other channels they used to route my payments forwards.\n> \n> With onion routing, none of the ripped off hubs need know where the money\n> ended up, so there's not a lot of potential to do iron pipe cryptography to\n> get your money back.\n> \n> The only constraints here (I think) are:\n> \n>  - how many channels you can open in M-N blocks\n>  - you have to have >$X funds available in the first place to commit to the\n> double spend\n>  - how much capacity the lightning network actually has in routable bitcoin\n> \n> If it costs 1.4*25*M bitcoin to mount a doublespend attack over M blocks\n> (ie bribing 67% of hashpower for the time it normally takes to do 2*M\n> blocks), and you can open 2000 channels per block, then that gives\n> \n>  X > 1.4*25*M\n>  n < 2000*(M-N)\n> \n>  X < d*n = d*2000*(M-N)\n> \n>  1.4*25*M < X < d*2000*(M-N)\n>  35/2000 * M < d * (M-N)\n>  35/2000 * (1 + N/(M-N)) < d???\n> \n> Setting N = 12, M = 15 gives:\n> \n>  d = 35/2000 * (1+4) = 7/80\n>  n = 6000\n> \n> so you're putting up 525 bitcoin by flooding the blockchain with anchor\n> transactions, sending it to yourself over lightning, then doublespending\n> the original 525 btc at a cost of spending ~505 btc on hashpower. Expensive\n> ($157k capital to make $6k profit), but still worthwhile (3.8% ROI in ~6\n> hours is 16% a day, or about 5e25 % annualised...)\n> \n> Maybe if you make N depend on d you could mitigate this though -- something\n> like, if you to put \"$d\" on your side of the channel, you'll have to wait\n> for 5+(d*2000/25)*2 confirmations. So a $50 channel is d=.2 BTC, which is\n> ~37 confirmations, or about 6 hours. Increasing the blocksize (number of\n> channels openable per block) or lowering the block reward (decreasing the\n> cost of a doublespend fork) increases the confirmations required though...\n> \n> Cheers,\n> aj\n> \n> -- \n> Anthony Towns <aj at erisian.com.au>\n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-12T01:06:57",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> Hi Anthony,\n>\n> Yes, reorg attacks are definitely a known with Bitcoin. You can send\n> money to an exchange and then double-spend withdraw several\n> confirmations later if you have infinite hashrate.\n>\n> With lightning, I think to fund the channel, the minimum confirmation\n> times should be fairly high (even above 6 confirms).\n\nI'm not so sure: speed matters, and I expect that there will be some\ncompetition on this basis.\n\nThere's a significant benefit in taking single-block confirms under\nnormal circumstances: the median wait will be 3.5 minutes.  With 6\nblocks, it's closer to 53 minutes (I think?)\n\nYou don't need to allow them to spend their entire anchor from the\nstart though, I guess.  Risk management *handwave*\n\nCheers,\nRusty.\n\n\n\n\n\n\n\nI assumed you'd\n\n>\n> The nice thing about payment channels is that after it's set up, you\n> don't worry about confirmation times if it's off-chain. For that reason,\n> confirmation times (and block mining rate, ~10 minutes) matters a lot\n> less.\n>\n> On Wed, Aug 12, 2015 at 03:38:16AM +0800, Anthony Towns wrote:\n>> Hi,\n>> \n>> This is probably just stating the obvious. Sometimes that's useful though,\n>> and maybe this is one of those times!\n>> \n>> When setting up a new channel with an untrusted counterparty, you will wait\n>> for N confirmations of their anchor transactions. Further, N might be well\n>> known and common amongst a lot of lightning hubs (if it's not, then it will\n>> be hard to know how long setting up a channel will take). What if N is too\n>> small, and I can afford to do a double-spend despite M (M > N)\n>> confirmations as long as it gains me $X?\n>> \n>> Then I do the following:\n>> \n>>  - I open one or more anonymous channels, capable of receiving at least $X\n>>  - I start the doublespend fork\n>>  - I then simultaneously construct multiple lightning channels, funding\n>> them at $d each.\n>>  - I wait for N confirmations so my new channels are active.\n>>  - I quickly route multiple payments from my new channels to my anonymous\n>> channels until I can't send anymore\n>>  - I publish the doublespending fork, so that my $d*n never got spent\n>>  - I close my original anonymous channels gaining $X <= $d*n\n>> \n>> The only people worse off are the ones who opened the $d channels after N\n>> confirmations -- any intermediary hubs are fine. Those hubs didn't have to\n>> commit any funds to the new channels for the attack to work; the money they\n>> lose was that in other channels they used to route my payments forwards.\n>> \n>> With onion routing, none of the ripped off hubs need know where the money\n>> ended up, so there's not a lot of potential to do iron pipe cryptography to\n>> get your money back.\n>> \n>> The only constraints here (I think) are:\n>> \n>>  - how many channels you can open in M-N blocks\n>>  - you have to have >$X funds available in the first place to commit to the\n>> double spend\n>>  - how much capacity the lightning network actually has in routable bitcoin\n>> \n>> If it costs 1.4*25*M bitcoin to mount a doublespend attack over M blocks\n>> (ie bribing 67% of hashpower for the time it normally takes to do 2*M\n>> blocks), and you can open 2000 channels per block, then that gives\n>> \n>>  X > 1.4*25*M\n>>  n < 2000*(M-N)\n>> \n>>  X < d*n = d*2000*(M-N)\n>> \n>>  1.4*25*M < X < d*2000*(M-N)\n>>  35/2000 * M < d * (M-N)\n>>  35/2000 * (1 + N/(M-N)) < d???\n>> \n>> Setting N = 12, M = 15 gives:\n>> \n>>  d = 35/2000 * (1+4) = 7/80\n>>  n = 6000\n>> \n>> so you're putting up 525 bitcoin by flooding the blockchain with anchor\n>> transactions, sending it to yourself over lightning, then doublespending\n>> the original 525 btc at a cost of spending ~505 btc on hashpower. Expensive\n>> ($157k capital to make $6k profit), but still worthwhile (3.8% ROI in ~6\n>> hours is 16% a day, or about 5e25 % annualised...)\n>> \n>> Maybe if you make N depend on d you could mitigate this though -- something\n>> like, if you to put \"$d\" on your side of the channel, you'll have to wait\n>> for 5+(d*2000/25)*2 confirmations. So a $50 channel is d=.2 BTC, which is\n>> ~37 confirmations, or about 6 hours. Increasing the blocksize (number of\n>> channels openable per block) or lowering the block reward (decreasing the\n>> cost of a doublespend fork) increases the confirmations required though...\n>> \n>> Cheers,\n>> aj\n>> \n>> -- \n>> Anthony Towns <aj at erisian.com.au>\n>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> -- \n> Joseph Poon\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Attacking the lightning network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "Joseph Poon"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12178
        }
    },
    {
        "title": "[Lightning-dev] Pure No-Trust Solution using only OP_CLTV",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-13T18:37:18",
                "message_text_only": "Joseph asked, what changes OP_CLTV would bring to my Thunder proposal,\nand I started working out, how much is actually possible with only\nCLTV implemented.\n\nIt is still unclear, how CLTV and CSV are activated, and there are\ndiscussions about adding them in one single softfork, rendering this\ndesign useless of course. Nevertheless, maybe someone can find some\ninterest in it, I wasn't able to find it on the mailing list or in any\npaper.\n\nExcerpt from thunder.network:\n\nChannel Design:\nhttp://thunder.network/images/image09.png\nhttp://imgur.com/nmpRYSe (Mirror)\n\nWith OP_CLTV it is possible to replace the\npayout-to-multisig-and-give-timelocked-partly-signed-transaction with\na simple OP-code, specifying for how long the output should not be\nspent. With this it is able to completely mitigate all the\nmalleability problems we have in our current solution. Let\u2019s take a\nlook into some of the changes made and their implications.\n\nOpening Transaction\n\nThere are no longer refund transactions that needs to get\ninterchanged. It is possible to directly make the refund to both\nparties part of the opening transaction. This completely removes any\nrisk problems and allows for large amount of funds within the channel.\nAs soon as the refund time has come, both parties can get their\nrespective funds back with just their sole private key. As we cannot\naccomplish the exact distribution with just one output and CLTV, we\nuse two outputs that only differ in the refund private key. By doing\nso, any channel transaction has to include both these outputs (and of\ncourse both has to be signed accordingly), leading to (slightly)\nlarger transactions.\n\nChannel Transaction\n\nSettled Funds\n\nWe use the same mechanism as in the opening transaction here, and\nadded a multi-sig output to ensure that these funds are revocable. If\nboth parties agree on a new version of the channel, they release their\ntemporary signatures A2 and B2. If a party broadcasts a channel that\nwas marked as revoked, the other party can steal those funds.\nFurthermore, malleability is no longer an issue, as refunds are only\ntimelocked using CLTV, and in case of a revoke, the other party has\nboth private keys. In any case, we are no longer depending on having a\nspecific transaction presigned by the other party.\n\nSending HTLC\n\nMaking a payment now consists of 3 outputs. We combine the mechanism\nfor refunds and for revocable transactions (see above) with the\nability of the receiver to claim the payments in case he knows the\nsecret R. We lowered the refund time to the general timeframe of a\npayment, such that it is enforceable by the sender. Again, as we don\u2019t\ndepend on presigned transactions, malleability is no longer an issue.\n\nReceiving HTLC\n\nThe outputs of a receiving HTLC are very similar to those of a sending\none, but with the private keys set accordingly. Also the timeframe is\ndown to 6 days, such that we have plenty of time to determine if a\npayment will get refunded or not.\n\nNow there are a couple of problems with this design, mainly that HTLCs\nare not strictly revocable. If one party broadcasts a revoked\ntransactions with HTLCs inside, the other party can just try to race\nagainst the propagation of the claiming transactions, which will often\nbe fruitless. This goes for receiving payments, where the party can\nclaim the funds with the secret R and also for sending payments, where\nhe can use the refund option (for revoked channels which are older\nthan the refund timeout). This can however completely mitigated using\na simple reserve strategy (see below for details, it can be applied\nfor payments in both directions).\n\nAdditionally, this new channel design means that a channel will get\nclosed and broadcasted completely, as soon as the refund condition for\nany payment in your channel is met. To counter this as a receiver of a\npayment, you have to reveal the secret or settle a new channel without\nthe payment (manual refund) in time with the other party. As a sender,\nyou have to check back the payment before the refund, to work out with\nthe other party if the payment should refund or settle.\n\nThose timeframes are just for illustration, it might be preferable to\nplay along with those numbers a bit. For example, the one day\ndifference between the sender and the receiver means that in extreme\ncases the sender only has one day for updating his channel.\nFurthermore, there isn\u2019t really a reason the receiver has 6 days time\nto reveal his secret, where 6 hours would be plenty of time as well.\nFinally, we can also extend the period for a payment, resulting in a\nlonger lock-up time frame at the end of the channel.\n\nWith channels being strictly no-trust, we can move towards larger\namounts of funds inside the channels, mitigating the problem with\nnon-revocable HTLCs and the workaround. It just becomes one additional\nrule we have to apply among all the others that are apparent already.\n\nImplementing these changes in the current Thunder implementations is\ntrivial. It comes down to deleting a lot of methods currently\nnecessary and switching to the new scripts. This goes for most channel\ndesign changes, as the design of Rusty for example.\n\n\nAppendix: Payments in older Channel Versions\n\nThere is a problem, as settlement transactions are not time-encumbered\n(we want that whoever deserves the output of a payment to be able to\nclaim it instantly, with no one possibly interfering). This means if\none party has a channel transaction with a payments towards it, he can\nclaim this payment under any circumstances. However, if this party\ndoes broadcast a revoked channel to claim such an output, the\ncounterparty can still steal all settled funds and all funds towards\nhis channel.\n\nIt is therefore important to keep track of the amounts the other party\nis receiving. We have to know, which is the highest amount the other\nparty ever had as receiving payments in his channel, and we must make\nsure that we decline any attempts of him spending money, such that his\nbalance would drop below this amount.\n\nThis will be more clear using this example:\n\nWe start with a channel, with Alice and Bob, and both fund the mutual\nchannel with 10 BTC.\n\nSo at t=0 we are at\n\n        Alice         -        10 BTC\n\n        Bob         -        10 BTC\n\nNow imagine that for some reason, Alice received payments, such that\nshe has 5 BTC as uncleared payments in her channel.\n\nt=t1\n\n        Alice         -          10  BTC ( +5 BTC uncleared )\n\n        Bob         -          5    BTC\n\nShe reveals the secrets and Alice and Bob settle those payments, leading to\n\nt=t2\n\n        Alice         -          15  BTC\n\n        Bob         -          5    BTC\n\nNow if Alice were to be free to spend all her money, if we don\u2019t\nenforce the above rules, she could spend all her money (leading to\nlegitimate payment contracts in other channels that we are obliged\nto).\n\nt=t3\n\n        Alice         -        0   BTC\n\n        Bob        -        20 BTC\n\nBut, as reasoned above, payments towards Alice can always be claimed\nby Alice, such that she can claim the 5 BTC from the t=t1 channel\ntransaction and Bob losing those 5 BTC. The t=t1 transaction does\nspend 5 BTC directly towards Bob, and he can also claim the 10 BTC\nsettled balance from Alice, but his net balance compared to the t=t3\nis -5 BTC.\n\nTo defend against this kind of attack, it is important to keep track\nof the maximum the other party has as receiving uncleared payments in\nhis channel. In this case, the maximum Alice has as uncleared\nreceiving payments is at t=t1, 5 BTC. This means, we have to make sure\nher balance does not drop below 5 BTC anymore. As agreeing on a\nchannel with a payment is a mutual action, Bob can just refuse to\naccept a new channel transaction, where the balance of Alice would\ndrop below 5 BTC.\n\nThis rule also serves as an incentive to clear out receiving payments\nas soon as possible. The party who has sent a payment (Carol in this\nexample) can only remove settle the payment after the receiving party\nhas cleared the payment, and we don\u2019t want the channel to clog."
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-13T20:06:37",
                "message_text_only": "Hi Mats,\n\nYes, I agree that this is a possibility. \n\nI had discussed this model of OP_CLTV without OP_CSV using a balance\nreserve on the mailing list, along with some caveats on the\nrisks/effects of doing so.\n\nMessage ID: 20150727193714.GA16768 at lightning.network\nLink:\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000070.html\n\nOn Thu, Aug 13, 2015 at 08:37:18PM +0200, Mats Jerratsch wrote:\n> Joseph asked, what changes OP_CLTV would bring to my Thunder proposal,\n> and I started working out, how much is actually possible with only\n> CLTV implemented.\n\nI think very minor changes to the code would result in full lightning\nchannels, as per Rusty's doc, yes. I think there will be huge benefits\nto Bitcoin if bitcoinj has an implementation ready when OP_CLTV/OP_CSV\nis implemented.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-08-13T20:29:06",
                "message_text_only": "Ah nice,\n\nYea this is pretty much the same. :)\nIt seemed too trivial for me as well. I wonder why everyone thinks\nthat CLTV+CSV is the mandatory minimum we need for a full LN though.\nGranted, it's not as much 'fun' as you put it, but it would work very\nnice in most instances.\n\n2015-08-13 22:06 GMT+02:00 Joseph Poon <joseph at lightning.network>:\n> Hi Mats,\n>\n> Yes, I agree that this is a possibility.\n>\n> I had discussed this model of OP_CLTV without OP_CSV using a balance\n> reserve on the mailing list, along with some caveats on the\n> risks/effects of doing so.\n>\n> Message ID: 20150727193714.GA16768 at lightning.network\n> Link:\n> http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000070.html\n>\n> On Thu, Aug 13, 2015 at 08:37:18PM +0200, Mats Jerratsch wrote:\n>> Joseph asked, what changes OP_CLTV would bring to my Thunder proposal,\n>> and I started working out, how much is actually possible with only\n>> CLTV implemented.\n>\n> I think very minor changes to the code would result in full lightning\n> channels, as per Rusty's doc, yes. I think there will be huge benefits\n> to Bitcoin if bitcoinj has an implementation ready when OP_CLTV/OP_CSV\n> is implemented.\n>\n> --\n> Joseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-14T01:23:03",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> Joseph asked, what changes OP_CLTV would bring to my Thunder proposal,\n> and I started working out, how much is actually possible with only\n> CLTV implemented.\n\nYes, you can always replace CSV with CLTV.  The downside is that if\nsomething goes wrong with channel negotiation you need to wait for much\nlonger, and you need to reopen the channel fairly regularly (which has\nits own problems, since you can't accept a HTLC which passes your CLTV\ntimeout, so you probably want overlapping channels).\n\nI am really hoping that OP_CSV gets deployed in time to avoid such a\nhack.  There's plenty of work in the mean time!\n\nCheers,\nRusty."
            },
            {
                "author": "Btc Drak",
                "date": "2015-08-17T19:23:53",
                "message_text_only": "On Fri, Aug 14, 2015 at 2:23 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> I am really hoping that OP_CSV gets deployed in time to avoid such a\n> hack.  There's plenty of work in the mean time!\n\nSorry to gatecrash, but it would really help matters if those\ninterested in OP_CSV could review the OP_CSV BIP[1], the pull\nrequest[2] and also the related BIP68 PR[3].\n\nThere will also be a BIP proposal for median-past-timelock shortly\nwhich will need review.\n\nLastly there is growing support for the idea of a feature-pack\nsoftfork which includes CLTV+CSV+BIP68+median_past_timelock as a\nsingle softfork so your thoughts about this deployment option would\nalso greatly contribute towards establishing consensus on how to move\nforward.\n\nRegards,\n\nDrak\n\n[1] http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010198.html\n[2] https://github.com/bitcoin/bitcoin/pull/6564\n[3] https://github.com/bitcoin/bitcoin/pull/6312"
            },
            {
                "author": "Btc Drak",
                "date": "2015-08-19T11:03:07",
                "message_text_only": "On Mon, Aug 17, 2015 at 8:23 PM, Btc Drak <btcdrak at gmail.com> wrote:\n\n> On Fri, Aug 14, 2015 at 2:23 AM, Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n> > I am really hoping that OP_CSV gets deployed in time to avoid such a\n> > hack.  There's plenty of work in the mean time!\n>\n> Sorry to gatecrash, but it would really help matters if those\n> interested in OP_CSV could review the OP_CSV BIP[1], the pull\n> request[2] and also the related BIP68 PR[3].\n>\n> There will also be a BIP proposal for median-past-timelock shortly\n> which will need review.\n>\n> Lastly there is growing support for the idea of a feature-pack\n> softfork which includes CLTV+CSV+BIP68+median_past_timelock as a\n> single softfork so your thoughts about this deployment option would\n> also greatly contribute towards establishing consensus on how to move\n> forward.\n>\n> Regards,\n>\n> Drak\n>\n> [1]\n> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010198.html\n> [2] https://github.com/bitcoin/bitcoin/pull/6564\n> [3] https://github.com/bitcoin/bitcoin/pull/6312\n\n\nGentlemen,\n\nThe \"median-past-locktime\" pull requests are now available as well for\nreview. I'm posting because it has direct relevance to Lightning as it\nforms part of the locktime featureset referenced above:\n\nBIP discussion:\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010348.html\nCore pull request: https://github.com/bitcoin/bitcoin/pull/6566\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150819/ec53cf3a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Pure No-Trust Solution using only OP_CLTV",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Btc Drak",
                "Mats Jerratsch",
                "Joseph Poon"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 13286
        }
    },
    {
        "title": "[Lightning-dev] Loop attack with onion routing..",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-08-20T05:49:29",
                "message_text_only": "Hi all!\n\n        So, with some prompting from AJ who has been working on node\nincentives, I realized there's a nasty attack available to the network.\nYou simply route a payment back to another channel you own, then refuse\nto dislose R.\n\nYou have to lock up N bitcoins, but so does every node in the path (and\nnobody gets paid!).  Onion routing means nobody knows who to blame (you\ncan simply claim there's another hop after you).\n\nI think in this case we need to peel the onion[1]: if a payment takes\ntoo long you tell the previous node where you sent it (and relay where\nit sent it, etc.)  If you're the last in the queue, you also need to\nprove that you closed the channel to the offender[2] (which costs you a\ntxfee, providing disincentive).\n\nAnyone see any other problems?\n\nThanks,\nRusty.\n\n[1] Which means exposing a set of hashes corresponding to hashes of the\n    route steps, and including a nonce inside each route step, so you\n    can prove you decrypted it.\n[2] eg. provide the commitment tx or mutual close tx, and a signature\n    from that node's key provign that they created it with you."
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-20T21:08:23",
                "message_text_only": "On Thu, Aug 20, 2015 at 03:19:29PM +0930, Rusty Russell wrote:\n>         So, with some prompting from AJ who has been working on node\n> incentives, I realized there's a nasty attack available to the\n> network. You simply route a payment back to another channel you own,\n> then refuse to dislose R.\n> \n> You have to lock up N bitcoins, but so does every node in the path\n> (and nobody gets paid!).  Onion routing means nobody knows who to\n> blame (you can simply claim there's another hop after you).\n\nThis can be defined as a feature, though. If one expects the coins to be\nlocked up for the duration from the outset, the risk models are a lot\nmore clear.\n\nIt forces the graph to be more diffuse. It also forces intermediate\nnodes who are well-connected (who therefore also are the most likely\nsubject of attacks) to offload their HTLCs to 3rd party channel\nliquidity providers.\n\nE.g. If Mallory tries to tie up the Alice<->Bob link, then if Carol is\nconnected to both Alice and Bob, she can take the HTLC to be\nAlice->Carol->Bob, so that the Alice<->Bob link is clear.\n\n> I think in this case we need to peel the onion[1]: if a payment takes\n> too long you tell the previous node where you sent it (and relay where\n> it sent it, etc.)  If you're the last in the queue, you also need to\n> prove that you closed the channel to the offender[2] (which costs you\n> a txfee, providing disincentive).\n\nMy concern with mitigating this by establishing blame via information\ndisclosure is that it will encourage graph centralization.\n\n> Anyone see any other problems?\n\nI see the primary problem with \"onion\" routing is that some parts of the\ngraph may be faster with disclosure of R. In effect, some people may\nhave higher costs in the \"time\" part of \"time-value\"\n\nE.g. A->B->C->D->E. If C, D, and E are colluding participants to each\nother, and their R gets disclosed immediately, their channel's value\npermits much lower fees. They can collude to be dishonest with B, so\nthat B's channel is tied up for the maximum period of time. This\nincreases the costs for B and biases channels to use the C,D,E cartel\ndue to lower costs (since the channels aren't locked up as long). \n\nHowever! The effect isn't necessarily that the cartel is successful,\nthere are always second order effects in preventing potential problems.\nIt's possible that B mitigates this by biasing the routing towards\ncertain participants that B \"likes\" (IOW, trusts to not withhold R to the\nmaximum time), which is where I think the real complexity with\nincentives lie -- B will discourage using onion routing entirely.\n\nI see the tradeoffs as having both as an option may make sense, the\nsecond order effect gives you an option for either (with one possibly\nbeing slightly more expensive due to the withholding risks), whereas\nforcing onion *only* on everything may create emergent cartelization\nincentives. I haven't fully thought out the implications, and not\nparticularly attached to this viewpoint, though.\n\nThaddeus mentioned a possible solution to all this being funds sent to\neach participant with multiple signatures for different times of\ndisclosure of R (having the spending transaction be double-spent with\ndifferent locktimes, this is dependent upon a longer-term malleability\nfix and may require a more elaborate tree structure for the HTLC\nspends). E.g. release within 4 hours will have each hop make slightly\nmore money in fees. It doesn't guarantee against withholding, it just\ncreates a material cost to do so. I don't think we've really fleshed out\nthe idea, though AFAIK.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-20T22:12:15",
                "message_text_only": "On 20 August 2015 at 23:08, Joseph Poon <joseph at lightning.network> wrote:\n\n> I see the primary problem with \"onion\" routing is that some parts of the\n> graph may be faster with disclosure of R. In effect, some people may\n> have higher costs in the \"time\" part of \"time-value\"\n>\n> E.g. A->B->C->D->E. If C, D, and E are colluding participants to each\n> other, and their R gets disclosed immediately, their channel's value\n> permits much lower fees. They can collude to be dishonest with B, so\n> that B's channel is tied up for the maximum period of time.\n\n\n\u200bIf they do that, C doesn't get paid until the timeout; and the only way D\ngets paid is from C, and the only way E gets paid is from D. So I don't see\nwhat good colluding actually does them? ie you just get:\n\nImmediate:\n  D pays E\n  C pays D\nLater:\n  B pays C\n  A pays B\n\nBut C could achieve that outcome on its own, just by delaying notifying B\nuntil near the timeout; no collusion necessary. In any event, if the\ntransaction's going to succeed, the money on the B-C channel's HTLC is\ngoing to be C's, so C is mainly depriving itself by filing to communicate.\n\nIf you have B and D collude instead, so that E reveals R to D, and D\nreveals R to B instead of C, then the payments could go:\n\n  D pays E\n  D reveals R to B\n  A pays B\n  B pays D\n\nwith the transaction from B->C and C->D remaining open until the timeout,\nbut everyone else is square.\u200b That would inconvenience C, possibly cheaply\nfor B and D. If there's already a channel between B and D (for the \"B pays\nD\" step), I'm not sure why B and D wouldn't just announce that, and once it\nwas announced, I don't see why A would route via C anyway...\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150821/80d29a60/attachment.html>"
            },
            {
                "author": "Joseph Poon",
                "date": "2015-08-20T23:57:23",
                "message_text_only": "On Fri, Aug 21, 2015 at 12:12:15AM +0200, Anthony Towns wrote:\n> But C could achieve that outcome on its own, just by delaying\n> notifying B until near the timeout; no collusion necessary. In any\n> event, if the transaction's going to succeed, the money on the B-C\n> channel's HTLC is going to be C's, so C is mainly depriving itself by\n> filing to communicate.\n\nYes, the point is that pending sends between participants in this cartel\nhave a shorter time than outside this cartel. So the point is that\nC<->D<->E links will always have shorter HTLCs in transit than B's. It's\nonly C holding it up, but before that D and E decided not to hold it up.\n\n> If you have B and D collude instead, so that E reveals R to D, and D\n> reveals R to B instead of C, then the payments could go:\n> \n>   D pays E\n>   D reveals R to B\n>   A pays B\n>   B pays D\n> \n> with the transaction from B->C and C->D remaining open until the\n> timeout, but everyone else is square.??? That would inconvenience C,\n> possibly cheaply for B and D. If there's already a channel between B\n> and D (for the \"B pays D\" step), I'm not sure why B and D wouldn't\n> just announce that, and once it was announced, I don't see why A would\n> route via C anyway...\n\nPerhaps I may be misunderstanding things, but the purpose of not\nannouncing is to collectively make any paths to C delay closing out the\nHTLC as long as possible, so that anyone that transacts with C has to\nwait a long time, which will decrease the incentive to transact with C.\nSo the threat is that if C is being attacked, and B is not colluding,\nthen A and B will dislike transacting with C, even though it's not C's\nfault. There's insufficient incentive to push funds when closing out the\nHTLC (as opposed to pulling), e.g. A->B, due to the off-chance they\nforget, but I may be wrong here, this is a bit speculative.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-21T11:32:50",
                "message_text_only": "On 21 August 2015 at 01:57, Joseph Poon <joseph at lightning.network> wrote:\n\n> On Fri, Aug 21, 2015 at 12:12:15AM +0200, Anthony Towns wrote:\n> > But C could achieve that outcome on its own, just by delaying\n> > notifying B until near the timeout; no collusion necessary. In any\n> > event, if the transaction's going to succeed, the money on the B-C\n> > channel's HTLC is going to be C's, so C is mainly depriving itself by\n> > filing to communicate.\n> Yes, the point is that pending sends between participants in this cartel\n> have a shorter time than outside this cartel. So the point is that\n> C<->D<->E links will always have shorter HTLCs in transit than B's. It's\n> only C holding it up, but before that D and E decided not to hold it up.\n>\n\n\u200bI'm still not following how that's a problem? If C/D and D/E are really\nquick and reliable, isn't it desirable to send more transactions their way\nanyway?\u200b\n\n(a) \u200bAssuming source routing. A chooses to route a payment. Her options are\n\"A->B->C->D->E\" or \"A->C->D->E\". Based on time, she presumably chooses the\nlatter. Based on cost, maybe A->B or B->C has negative fees involved, so\nshe /might/ choose the longer path for slightly lower fees.\n\nIn that case either B is paying A to get funds on the B side of A->B or C\nis paying A to get funds on the C side of B->C. In the latter case, I can't\nimagine why C would want to punish B when she's desperate for funds that\nshe's offering negative fees. So afaics the only case is if B is paying A\nto get funds to send back to A,\n\nSo, fund status is:\n\n  D->E paid\n  B->C locked\n  A->B locked\n\nand C->D is either paid or locked, leaving one of C or D out of pocket.\nThat's a cost to C or D of TIMEOUT*AMOUNT worth of funds on the B/C or C/D\nchannels, in order to encourage future transactions to deposit funds on C's\nside of the A/C channel rather than the B/C channel. Since D doesn't\nbenefit directly, I don't see why he'd suffer the loss rather than letting\nC do it.\n\nBut if C's willing to lose TIMEOUT*AMOUNT worth of time-value-of-bitcoin,\nto encourage transactions over A/C rather than B/C, why doesn't she just\noffer reduced/negative fees?\n\n(b) Assuming onion routing, C/D don't actually know who A is -- it may be\nsomeone that only has a connection to B; so if they delay transactions,\nthey run the risk that future txns will be routed A->B->F->E bypassing them\ncompletely.\n\n(c) Assuming non-source routing, by delaying transactions, they risk B\nchoosing a different route for future transactions, rather than A doing so.\nI'm not sure how the liklihoods balance out there though.\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150821/6196d80d/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-21T02:22:54",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> On Thu, Aug 20, 2015 at 03:19:29PM +0930, Rusty Russell wrote:\n>>         So, with some prompting from AJ who has been working on node\n>> incentives, I realized there's a nasty attack available to the\n>> network. You simply route a payment back to another channel you own,\n>> then refuse to dislose R.\n>> \n>> You have to lock up N bitcoins, but so does every node in the path\n>> (and nobody gets paid!).  Onion routing means nobody knows who to\n>> blame (you can simply claim there's another hop after you).\n>\n> This can be defined as a feature, though. If one expects the coins to be\n> locked up for the duration from the outset, the risk models are a lot\n> more clear.\n\nMy concern is that the risk model is \"good txs take < 30 seconds, bad\ntake 4 days\".  And you have no way of judging which side of that 10,000\nfactor this is...\n\n> It forces the graph to be more diffuse. It also forces intermediate\n> nodes who are well-connected (who therefore also are the most likely\n> subject of attacks) to offload their HTLCs to 3rd party channel\n> liquidity providers.\n>\n> E.g. If Mallory tries to tie up the Alice<->Bob link, then if Carol is\n> connected to both Alice and Bob, she can take the HTLC to be\n> Alice->Carol->Bob, so that the Alice<->Bob link is clear.\n\nIt's not clear to me how you would atomically move an HTLC?  Or are you\nassuming you know in advance?\n\n>> I think in this case we need to peel the onion[1]: if a payment takes\n>> too long you tell the previous node where you sent it (and relay where\n>> it sent it, etc.)  If you're the last in the queue, you also need to\n>> prove that you closed the channel to the offender[2] (which costs you\n>> a txfee, providing disincentive).\n>\n> My concern with mitigating this by establishing blame via information\n> disclosure is that it will encourage graph centralization.\n\nYou lost me between these two statements?\n\nThough the important point is that some channel gets closed for slow\npayments, to produce disincentive.  I think that's sufficient, and\npotentially leaks less information?\n\nBut unacceptable risk levels will lead to onion protocol deprecation\n(thus, no financial privacy), so you can prevent attacks.  The onion\nprotocol will be so much more expensive because it's only used by\nMallory and co, so you have to assume every HTLC will timeout.  Everyone\nloses.\n\n>> Anyone see any other problems?\n>\n> I see the primary problem with \"onion\" routing is that some parts of the\n> graph may be faster with disclosure of R. In effect, some people may\n> have higher costs in the \"time\" part of \"time-value\"\n>\n> E.g. A->B->C->D->E. If C, D, and E are colluding participants to each\n> other, and their R gets disclosed immediately, their channel's value\n> permits much lower fees. They can collude to be dishonest with B, so\n> that B's channel is tied up for the maximum period of time. This\n> increases the costs for B and biases channels to use the C,D,E cartel\n> due to lower costs (since the channels aren't locked up as long). \n\nFirst time they do this, if they don't close a channel (costing them\non-blockchain fees), B closes connection to C as dishonest?\n\nThat seems to work...\n\n> However! The effect isn't necessarily that the cartel is successful,\n> there are always second order effects in preventing potential problems.\n> It's possible that B mitigates this by biasing the routing towards\n> certain participants that B \"likes\" (IOW, trusts to not withhold R to the\n> maximum time), which is where I think the real complexity with\n> incentives lie -- B will discourage using onion routing entirely.\n>\n> I see the tradeoffs as having both as an option may make sense, the\n> second order effect gives you an option for either (with one possibly\n> being slightly more expensive due to the withholding risks), whereas\n> forcing onion *only* on everything may create emergent cartelization\n> incentives. I haven't fully thought out the implications, and not\n> particularly attached to this viewpoint, though.\n\nI worry about not having onion because as we've seen in bitcoin, your\nprivacy matters to my privacy: I can't be the only private one on the\nnetwork.  And onion is basically free on a technology level.\n\n> Thaddeus mentioned a possible solution to all this being funds sent to\n> each participant with multiple signatures for different times of\n> disclosure of R (having the spending transaction be double-spent with\n> different locktimes, this is dependent upon a longer-term malleability\n> fix and may require a more elaborate tree structure for the HTLC\n> spends). E.g. release within 4 hours will have each hop make slightly\n> more money in fees. It doesn't guarantee against withholding, it just\n> creates a material cost to do so. I don't think we've really fleshed out\n> the idea, though AFAIK.\n\nAJ has been assuming similar per-hop contracts, but I'd like to simplify\nfor the first attempt if I can.\n\nSo I think it makes sense to begin with to have a \"per hop maxdelay\" (so\nyou can indicate, and be charged appropriately, if this is expected to\nbe slow).  Think \"20 seconds\".\n\nIf you can't complete the HTLC with the next node in maxdelay seconds,\nyou return route fail.  If the next node doesn't complete or routefail\nin maxdelay * MAX_HOPS (aka \"20\") seconds, you unilaterally close the\nchannel and send that tx in your \"delay\" message back.\n\nI *think* this works?\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-21T13:26:41",
                "message_text_only": "On 21 August 2015 at 04:22, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> My concern is that the risk model is \"good txs take < 30 seconds, bad\n> take 4 days\".  And you have no way of judging which side of that 10,000\n> factor this is...\n\n\n\u200bYou charge fees for 4 days, and if it only takes <30s you get a bunch of\nprofit, yay!\n\nThose fees are still pretty reasonable: 20% ROI per year is just 0.2% over\nfour days; .2% times 8 hops is 1.6% which is still much better than\nVisa/Paypal etc, even without the benefit of scaling to microtransactions.\n\nAlso, the extra profit on fast transactions is the only thing that you've\ngot to pay for the coins in your channel(s) that aren't currently doing\nanything.\n\n> It forces the graph to be more diffuse. It also forces intermediate\n> > nodes who are well-connected (who therefore also are the most likely\n> > subject of attacks) to offload their HTLCs to 3rd party channel\n> > liquidity providers.\n> > E.g. If Mallory tries to tie up the Alice<->Bob link, then if Carol is\n> > connected to both Alice and Bob, she can take the HTLC to be\n> > Alice->Carol->Bob, so that the Alice<->Bob link is clear.\n> It's not clear to me how you would atomically move an HTLC?  Or are you\n> assuming you know in advance?\n>\n\n/Alice/ always knows in advance -- she knows the state of the Alice/Bob\nchannel before she tries adding an HTLC. I think she can just add a hop in\nthe route even under onion routing with no particular problems.\n\n>> Anyone see any other problems?\n>\n> I see the primary problem with \"onion\" routing is that some parts of the\n> > graph may be faster with disclosure of R. In effect, some people may\n> > have higher costs in the \"time\" part of \"time-value\"\n> > E.g. A->B->C->D->E. If C, D, and E are colluding participants to each\n> > other, and their R gets disclosed immediately, their channel's value\n> > permits much lower fees. They can collude to be dishonest with B, so\n> > that B's channel is tied up for the maximum period of time. This\n> > increases the costs for B and biases channels to use the C,D,E cartel\n> > due to lower costs (since the channels aren't locked up as long).\n> First time they do this, if they don't close a channel (costing them\n> on-blockchain fees), B closes connection to C as dishonest?\n>\n\n\u200bHow does B know C is dishonest, and not D or E? How does B know someone\nwas dishonest, and that the delay wasn't desired by both of A and E?\u200b\n\n(Delays might be desirable if they assist with privacy by resisting traffic\nanalysis)\n\n\n> AJ has been assuming similar per-hop contracts, but I'd like to simplify\n> for the first attempt if I can.\n>\n\n\u200bI think you need to have \"reputation\" as part of the routing service at\nthat point; but while lightning is small, that's probably trivial, IMHO.\n\nSo I think it makes sense to begin with to have a \"per hop maxdelay\" (so\n> you can indicate, and be charged appropriately, if this is expected to\n> be slow).  Think \"20 seconds\".\n>\n\n\u200bHmm. You'd have to have that be cumulative:\n\n A -> B -> C -> D\n\n  A: I expect a response in 2 days + 40s\n  B: you can expect a response in 2 days + 20s\n  C: you can expect a response in 2 days\n\nBut what happens if D takes longer than 2 days 90 seconds? C accuses D o\nbeing unreliable and maybe closes the channel. But does B also close the\nchannel with C? Or does C say \"Hey, D didn't contact me\" at 2 days and 10s\nand get let off? (What happens if C is lying?) In either event, B only\ncharged fees for 2 days + 20s of time-value, but still has to wait for the\ntimeout, no matter how nice C is.\n\nIf you can't complete the HTLC with the next node in maxdelay seconds,\n> you return route fail.  If the next node doesn't complete or routefail\n> in maxdelay * MAX_HOPS (aka \"20\") seconds, you unilaterally close the\n> channel and send that tx in your \"delay\" message back.\n> I *think* this works?\n>\n\n\u200bClosing the channel doesn't give you your money back any earlier, so\nafaics you still need to charge fees for the full timeout. I don't /think/\na separate pretend-timeout makes things any less exploitable.\n\nIf people get over-confident and run hubs at rates assuming the timeout\nwill never get hit, I think you have to treat them as effectively\nsubsidising the network; eventually they'll hit a bunch of slow\ntransactions in a row either by happenstance or enemy action, and end up\nlosing money.\u200b\n\n\u200bCheers,\naj\u200b\n\n\u200b-\u200b\n-\nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150821/ddd98ebf/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-21T14:29:08",
                "message_text_only": "On 20 August 2015 at 07:49, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> I think in this case we need to peel the onion[1]:\n\n\n\u200bOkay, so how might this actually work?\n\nAlice sends a payment to Emma, via Bob, Carol and Dave.\n\nCase 1: Dave misbehaves by taking a few minutes rather than a few seconds\nto talk to Emma.\n\n * Carol decides that's unacceptable and asks Dave for an excuse. Dave\ncannot provide one. Carol closes the channel (unilaterally, or with Dave's\ngrudging cooperation)\n * At this point Bob believes Carol has taken too long too, so he asks\nCarol for an excuses. Carol says its Dave's fault, and points to the\ntransaction closing the Carol/Dave channel as evidence; Bob knows that Dave\nwas cheating because the HTLC is still present in that transaction (Carol\nreveals the P2SH script if necessary); Bob knows that Dave was who Carol\nwas forwarding to, because Carol provides a verifiable decryption of the\nonion routing message Bob passed on to Carol.\n * Bob likewise passes this back on to Alice as the explanation of why it's\ntaking so long.\n\nCase 2: Carol misbehaves by pretending Dave was misbehaving, when he wasn't.\n\n \u200b* Carol closes the channel with Dave before accepting Dave's resolution\nof the HTLC, passing the info to Bob as before.\n\u200b * \u200bSince he's not cheating, Dave claims the HTLC output on the blockchain.\n * Bob sees the HTLC output Carol was pointing at has been spent in a\ntimely fashion, indicating Carol is cheating.\n * Bob claims funds from Alice in a timely fashion, so does not have to\njustify being a cheat himself.\n * Bob closes the channel with Carol since she's being weird.\n\n\u200bThat seems like it works as expected to me?\u200b\n\n\u200bBut this reveals the chain of payees all the way back to the root. If you\nwere routing a payment from\n\n Joe Commie -> Bank of America -> Deutsche Bank -> Central Bank of Cuba ->\nCuba Communist Party\n\nthen you might find that a network hiccup in Cuba might cause BoA to\nrealise you're sending money to Cuba, and be forced to cease their\nrelationship with you. This potentially gets worse if you're not actually\ntrying to send money to some forbidden organisation, but you just happened\nto randomly choose a route that looks suspicious to hide your payments to\nAshley Madison or your donation in support of traditional marriage.\n\nBut if that's okay, and you don't mind BoA (or someone snooping on BoA's\ntraffic) knowing who you're sending money too, why do onion routing in the\nfirst place?\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150821/0a2ccdb5/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-24T00:59:09",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 20 August 2015 at 07:49, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>> I think in this case we need to peel the onion[1]:\n\nI changed my mind by the way.  You don't need to peel the onion, you\njust need the commit transaction + htlc transactions tied to the closure\n(and you can see the HTLC is yours, by the R value).\n\n> \u200bOkay, so how might this actually work?\n>\n> Alice sends a payment to Emma, via Bob, Carol and Dave.\n>\n> Case 1: Dave misbehaves by taking a few minutes rather than a few seconds\n> to talk to Emma.\n>\n>  * Carol decides that's unacceptable and asks Dave for an excuse. Dave\n> cannot provide one. Carol closes the channel (unilaterally, or with Dave's\n> grudging cooperation)\n\nA -> B -> C XXX D -> E\n\n>  * At this point Bob believes Carol has taken too long too, so he asks\n> Carol for an excuses. Carol says its Dave's fault, and points to the\n> transaction closing the Carol/Dave channel as evidence; Bob knows that Dave\n> was cheating because the HTLC is still present in that transaction (Carol\n> reveals the P2SH script if necessary); Bob knows that Dave was who Carol\n> was forwarding to, because Carol provides a verifiable decryption of the\n> onion routing message Bob passed on to Carol.\n>  * Bob likewise passes this back on to Alice as the explanation of why it's\n> taking so long.\n\nYep, seems to work.\n\n> Case 2: Carol misbehaves by pretending Dave was misbehaving, when he wasn't.\n>\n>  \u200b* Carol closes the channel with Dave before accepting Dave's resolution\n> of the HTLC, passing the info to Bob as before.\n> \u200b * \u200bSince he's not cheating, Dave claims the HTLC output on the blockchain.\n>  * Bob sees the HTLC output Carol was pointing at has been spent in a\n> timely fashion, indicating Carol is cheating.\n>  * Bob claims funds from Alice in a timely fashion, so does not have to\n> justify being a cheat himself.\n>  * Bob closes the channel with Carol since she's being weird.\n>\n> \u200bThat seems like it works as expected to me?\u200b\n\nNo, that doesn't work: Bob can't tell if Dave really sent it to Carol or\nnot.  But Alice doesn't care: she just knows that someone paid 2 txfees\nin apology money for the delay.\n\nTo recap (mainly for others), there are two failure cases:\n\nThe good one:\n1) Carol can't reach Dave in 20 seconds (no timely response to the\n   update_add_htlc packet).  She send update_remove_htlc() back to Bob,\n   who sends it back to Alice, undoing all the HTLCs just like any\n   route or fee failure.\n\nThe bad one:\n2) Dave starts the HTLC process, but then times out (doesn't resolve\n   HTLC in 20*11 seconds, and doesn't send back a blame\n   packet from Emma, either).\n\nIn the latter case, Carol dumps the commit tx to the blockchain, and the\nscrewed-up HTLC (and any other casualty HTLCs in progress, sorry).  She\ncan include this commit tx + htlc txs in the blame packet back to Bob;\nthere's no reason to name Dave AFAICT[1].\n\nIf Carol values Dave too much to drop the channel, she risks that Bob\nwill drop the channel with her.  It's not foolproof, but it provides\nsome disincentive.  I'm hoping that along with the profit motive, it's\nsufficient.\n\nCheers,\nRusty.\n[1] Normal bitcoin coin analysis might reveal who Dave is, of course..."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-24T10:06:25",
                "message_text_only": "On 24 August 2015 at 02:59, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On 20 August 2015 at 07:49, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> >> I think in this case we need to peel the onion[1]:\n> I changed my mind by the way.  You don't need to peel the onion, you\n> just need the commit transaction + htlc transactions tied to the closure\n> (and you can see the HTLC is yours, by the R value).\n>\n\n(\u200bI'm counting anything that reveals multiple forward steps in the chain as\nunpeeling the onion)\u200b\n\n\n> > Case 2: Carol misbehaves by pretending Dave was misbehaving, when he\n> wasn't.\n> >  \u200b* Carol closes the channel with Dave before accepting Dave's resolution\n> > of the HTLC, passing the info to Bob as before.\n> > \u200b * \u200bSince he's not cheating, Dave claims the HTLC output on the\n> blockchain.\n> >  * Bob sees the HTLC output Carol was pointing at has been spent in a\n> > timely fashion, indicating Carol is cheating.\n> >  * Bob claims funds from Alice in a timely fashion, so does not have\n> \u200bI\u200b\n> to\n> > justify being a cheat himself.\n> >  * Bob closes the channel with Carol since she's being weird.\n> > \u200bThat seems like it works as expected to me?\u200b\n>\n> No, that doesn't work: Bob can't tell if Dave really sent it to Carol or\n> not.\n\n\n\u200bDave didn't send anything to Carol; he resolved the transaction on the\nblockchain. Bob can tell this, because Carol pointed Bob at the exact\ntransaction that Dave spent, and the fact that Dave spent it reveals R and\nthe time at which Dave spent it (either included in the blockchain or with\n0-confirmations)\u200b indicates that Dave wasn't very delayed.\n\n\n> \u200b\u200b\n>  But Alice doesn't care: she just knows that someone paid 2 txfees\n> in apology money for the delay.\n>\n\n\u200bI'm not sure where the apology money comes from? Why would Bob or Carol\npay Alice when Alice was the one who chose to route via Dave? Why would\nDave pay if his channel's getting closed anyway?\n\nThe bad one:\n> 2) Dave starts the HTLC process, but then times out (doesn't resolve\n>    HTLC in 20*11 seconds, and doesn't send back a blame\n>    packet from Emma, either).\n> In the latter case, Carol dumps the commit tx to the blockchain, and the\n> screwed-up HTLC (and any other casualty HTLCs in progress, sorry).  She\n> can include this commit tx + htlc txs in the blame packet back to Bob;\n> there's no reason to name Dave AFAICT[1].\n>\n\n\u200bThe HTLC txn provides Dave's public key id though (assuming you un-P2SH\nit, which you need to to prove that it corresponds with the R you expect),\nwhich is the only name for Dave that matters, isn't it?\u200b\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150824/6285cfa4/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-24T10:58:36",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 24 August 2015 at 02:59, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>> 2) Dave starts the HTLC process, but then times out (doesn't resolve\n>>    HTLC in 20*11 seconds, and doesn't send back a blame\n>>    packet from Emma, either).\n>> In the latter case, Carol dumps the commit tx to the blockchain, and the\n>> screwed-up HTLC (and any other casualty HTLCs in progress, sorry).  She\n>> can include this commit tx + htlc txs in the blame packet back to Bob;\n>> there's no reason to name Dave AFAICT[1].\n>\n> \u200bThe HTLC txn provides Dave's public key id though (assuming you un-P2SH\n> it, which you need to to prove that it corresponds with the R you expect),\n> which is the only name for Dave that matters, isn't it?\u200b\n\nThere's no reason for the two to be connected.  You have a pubkey as\nyour ID for network and routing encryption, but you can offer any\ntransaction as an anchor, and use any keys you want.\n\nNow, Joseph was suggested that it doesn't *have* to be this way, such\nthat the blockchain would show all the channels open, but while that's a\ncute hack I don't think it's necessary.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-24T11:36:53",
                "message_text_only": "On 24 August 2015 at 12:58, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On 24 August 2015 at 02:59, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> >> 2) Dave starts the HTLC process, but then times out (doesn't resolve\n> >>    HTLC in 20*11 seconds, and doesn't send back a blame\n> >>    packet from Emma, either).\n> >> In the latter case, Carol dumps the commit tx to the blockchain, and the\n> >> screwed-up HTLC (and any other casualty HTLCs in progress, sorry).  She\n> >> can include this commit tx + htlc txs in the blame packet back to Bob;\n> >> there's no reason to name Dave AFAICT[1].\n> >\n> > \u200bThe HTLC txn provides Dave's public key id though (assuming you un-P2SH\n> > it, which you need to to prove that it corresponds with the R you\n> expect),\n> > which is the only name for Dave that matters, isn't it?\u200b\n>\n> There's no reason for the two to be connected.  You have a pubkey as\n> your ID for network and routing encryption, but you can offer any\n> transaction as an anchor, and use any keys you want.\n>\n\n\u200bAre we talking about different transactions? I'm thinking:\n\n T1: Carol+Dave\u200b Anchor(s)\n  Inputs: whatever\n  Output: requires Carol + Dave\n\n T2: Channel closure\n  Inputs: T1\n  Outputs:\n    Carol balance\n    Dave balance\n    HTLC 1\n    HTLC 2\n    HTLC 3\n    ...\n\n T3: Dave cashing in HTLC 2\n  Input: T2 HTLC 2; R, Dave's key\n  Outputs: whatever\n\nFor Carol to prove to Bob that she closed the channel, she points Bob at\nT2/HTLC 3 providing the expanded P2SH as necessary, which reveals Dave's\n\"lightning\" key as well as R. The anchor isn't really relevant.\n\nBut maybe Dave could have a different key for each channel, and choose them\nindependently of his lightning network id as used for routing (and the\ncorresponding public key used for onion routing)?\n\nBut if the key isn't linked, then Carol could construct her own\n\"Carol-in-a-Dave-suit\" set of keys, and make a fake \"channel closure\"\ntransaction to convince Bob that Dave was being bad, It would cost a\nbitcoin transaction and lock up her bitcoins for the timeout period\n(assuming she never finds out R), though -- but I'm not sure that's enough?\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150824/7cdb7201/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-25T01:20:50",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 24 August 2015 at 12:58, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> But maybe Dave could have a different key for each channel, and choose them\n> independently of his lightning network id as used for routing (and the\n> corresponding public key used for onion routing)?\n\nYep.\n\n> But if the key isn't linked, then Carol could construct her own\n> \"Carol-in-a-Dave-suit\" set of keys, and make a fake \"channel closure\"\n> transaction to convince Bob that Dave was being bad,\n\nAs I said before, you could never use this to convince anyone that\nanyone was bad anyway.\n\nMaybe Carol ignored Dave's perfectly valid reply.  Maybe Dave didn't\nreply.  You can't tell.\n\n> It would cost a\n> bitcoin transaction and lock up her bitcoins for the timeout period\n> (assuming she never finds out R), though -- but I'm not sure that's enough?\n\nSomeone bled (in fees and delayed funds).  That's hopefully enough; at\nleast it cost them to inconvenience you.\n\nCheers,\nRusty."
            },
            {
                "author": "CJP",
                "date": "2015-08-29T17:50:52",
                "message_text_only": ">         So, with some prompting from AJ who has been working on node\n> incentives, I realized there's a nasty attack available to the network.\n> You simply route a payment back to another channel you own, then refuse\n> to dislose R.\n> \n> You have to lock up N bitcoins, but so does every node in the path (and\n> nobody gets paid!).  Onion routing means nobody knows who to blame (you\n> can simply claim there's another hop after you).\n\nYes, that's a nasty one: the total damage to the network is much larger\nthan the damage to the attacker, especially when the attacker is free to\nchoose a very long route. This could be used to perform a DoS attack on\nthe network.\n\n> I think in this case we need to peel the onion[1]: if a payment takes\n> too long you tell the previous node where you sent it (and relay where\n> it sent it, etc.)  If you're the last in the queue, you also need to\n> prove that you closed the channel to the offender[2] (which costs you a\n> txfee, providing disincentive).\n> \n> Anyone see any other problems?\n\nI don't like the \"peeling the onion\" idea, since it breaks down a very\nimportant privacy layer. This privacy is necessary e.g. to make sure the\nnetwork remains open for new participants to start routing, even against\nthe will of an existing cartel of routers.\n\nMaybe I'm overlooking something, but wouldn't it be enough to add a\nfine, to be paid from payee-side of a single link to the payer-side of\nthe link, if the R value is delayed? It wouldn't even be necessary to\ncryptographically enforce such a fine: if the fine isn't paid, the other\nnode can simply close the channel, isolating the misbehaving node.\nWell-behaving nodes will always pay the fine, thereby keeping their link\nintact and keeping a healthy network of well-behaving nodes.\n\nIn order to punish the attacker, these fines should be accumulated\ntowards the payee side of the route; this sounds like a similar problem\nas the accumulation of ordinary transaction fees across a route. \n\nIntuitively I'd say that, for a mixed source/non-source routing network,\nit'd be reasonable that the endpoints of the transaction (final payer\nand payee) explicitly pay fees to the source-routed nodes in a route,\nand that any fees of non-source routed nodes are covered by the fees\npaid to their closest source-routed nodes(**). Explicitly paying fines\nto source-routed nodes also provides an incentive(*) to keep routes\nshort.\n\nCJP\n\n(*) unless the explicit fee is negative of course, but that's a feature,\nnot a bug.\n\n(**) Example (for ordinary fees, but could be similar for fines):\ncapitals are source-routed nodes\n\nA - b - c - D - e - F - g - H\n\nA pays 1.000 mBTC to H (main payment from payer A to payee H)\nA pays 0.003 mBTC to D (explicit source routing fee; D is the \"meeting\npoint\" agreed by A and H)\nH pays 0.003 mBTC to F (explicit source routing fee; H selected F for\nonion-routing towards D, without A's knowledge)\nA pays 0.002 mBTC to b (non-source routing fee)\nb pays 0.001 mBTC to c (non-source routing fee)\nD pays 0.001 mBTC to c (non-source routing fee)\nD pays 0.001 mBTC to e (non-source routing fee)\nF pays 0.001 mBTC to e (non-source routing fee)\nF pays 0.001 mBTC to g (non-source routing fee)\nH pays 0.001 mBTC to g (non-source routing fee)\n\nNet result:\nA: -1.005\nb: +0.001\nc: +0.002\nD: +0.001\ne: +0.002\nF: +0.001\ng: +0.002\nH: +0.996"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-30T00:34:37",
                "message_text_only": "On 30 August 2015 at 03:50, CJP <cjp at ultimatestunts.nl> wrote:\n\n> Maybe I'm overlooking something, but wouldn't it be enough to add a\n> fine, to be paid from payee-side of a single link to the payer-side of\n> the link, if the R value is delayed?\n\nIt wouldn't even be necessary to\n> cryptographically enforce such a fine: if the fine isn't paid, the other\n> node can simply close the channel, isolating the misbehaving node.\n>\n\n\u200bI think that gives the following choices for the payee:\n\n a) acts quickly, everyone's happy!\n b) reveal R later, get less money due to having to pay a fine\n c) fail the payment /and/ pay a fine for taking so long\n d) pay the fine and close the channel cooperatively\n e) close the channel unilaterally\n\nI think (b) or (c) is better than (d) always.\n\nIf the fine is small (relative to bitcoin blockchain fees), then (d) should\nalways be better than (e).\n\nBetween (b) and (c), I think the fine is just a sunk cost, so (b) is\nprobably always better than (c), assuming you know R.\n\nI'm not sure the fine is necessarily small relative to the blockchain fees,\nthough (especially if the blockchain fee is zero...)? A long chain might\nget fees into the 1% range, and for a moderate sized payment ($5 coffee, 20\nmBTC) that would be .2 mBTC, exceeding a 1kB txn fee of .1 mBTC...\n\n\n> Well-behaving nodes will always pay the fine, thereby keeping their link\n> intact and keeping a healthy network of well-behaving nodes.\n>\n\n\u200bThe thing that I can't get to work out here is when you have a misbehaving\nnode at the end of a chain, who doesn't pay their fine, but well-behaved\nnodes making up the rest of the chain.\n\n\n> A - b - c - D - e - F - g - H\n\nH pays 0.003 mBTC to F (explicit source routing fee; H selected F for\n> onion-routing towards D, without A's knowledge)\n>\n\nYou mean \"D selected F for onion-routing towards H\" here, surely?\n\n\n> A pays 0.002 mBTC to b (non-source routing fee)\n> b pays 0.001 mBTC to c (non-source routing fee)\n> D pays 0.001 mBTC to c (non-source routing fee)\n> D pays 0.001 mBTC to e (non-source routing fee)\n> F pays 0.001 mBTC to e (non-source routing fee)\n> F pays 0.001 mBTC to g (non-source routing fee)\n> H pays 0.001 mBTC to g (non-source routing fee)\n>\n\nThese fees still don't vary with time\u200b, so a 30s result versus a 4 day\nresult still has a factor of 10k difference in cost vs revenue. I think\nover 4 days, a 0.20% fee is about reasonable matching the 0.002 fees that\nc, e and g end up with above (0.20%/4 days works out to a 20% ROI per annum\nif all your channels are constantly at 100% use), so linearising to an hour\nthat's a 0.002% fee, which works out to 2 satoshi per mBTC per hour.\n\nHmm, you /could/ actually lock those fees in cryptographically just by\nupdating the channel once an hour with the fees applied to the balances --\nat the above rate, accepting the update would be cheaper than paying a\n0.1mBTC blockchain txn fee, as long as you had less than 10 BTC worth of\nactive transactions that you're paying fines on.\n\n\u200bCheers,\naj\u200b\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150830/3a200b75/attachment-0001.html>"
            },
            {
                "author": "CJP",
                "date": "2015-08-30T17:18:27",
                "message_text_only": "> \n> I'm not sure the fine is necessarily small relative to the blockchain\n> fees, though (especially if the blockchain fee is zero...)? A long\n> chain might get fees into the 1% range, and for a moderate sized\n> payment ($5 coffee, 20 mBTC) that would be .2 mBTC, exceeding a 1kB\n> txn fee of .1 mBTC...\n\nYou assume the present-day exchange rate. When scaling towards larger\nnumbers of users and transactions, the exchange rate will increase a\nlot. This will make the blockchain tx fee much worse. With increasing\nnumbers of users the route length in Lightning might also increase a bit\n(hence increase its tx fee too), but the situation is much better than\nwith in-blockchain transactions.\n\nA very simplistic estimate of the exchange rate in a very ambitious\nscenario: assume a future world of 10e9 people, who have all reached\ndeveloped-nation wealth, and who use Bitcoin for all their finances.\nEach of them can have 2.1 mBTC of savings. Assuming the average\ndeveloped-nation person has about $10e3 savings in today's dollars, 2.1\nmBTC savings in our scenario should be equivalent to $10e3 in today's\ndollars. So that is $4800 / mBTC = $4.8 mln / BTC! Note that the actual\nexchange rate in our hypothetical scenario will be much higher, since\nthe dollar will have become worthless.\n\nCJP\n\n>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-31T21:41:00",
                "message_text_only": "On 31 August 2015 at 03:18, CJP <cjp at ultimatestunts.nl> wrote:\n\n> > I'm not sure the fine is necessarily small relative to the blockchain\n> > fees, though (especially if the blockchain fee is zero...)? A long\n> > chain might get fees into the 1% range, and for a moderate sized\n> > payment ($5 coffee, 20 mBTC) that would be .2 mBTC, exceeding a 1kB\n> > txn fee of .1 mBTC...\n> You assume the present-day exchange rate.\n\n\n\u200bWell for concreteness, sure, but what I'm really assuming is that\nblockchain txn fees maintain a small real value.\n\nI think that's a reasonable assumption to some degree, though, because\nwe're assuming end users will bump their lightning channels at least once\nevery couple of years. That makes the blockchain fee comparable to an\nannual account keeping fee on a bank account, which puts a ceiling of maybe\n$10-$20 on blockchain fees. (If bitcoins fees go higher, then presumably\nyou'd be running lightning nodes off of a sidechain or altcoin with lower\nfees, or you wouldn't be using lightning at all because debit cards are\ncheaper).\n\nA very simplistic estimate of the exchange rate in a very ambitious\n> scenario: assume a future world of 10e9 people, who have all reached\n> developed-nation wealth, and who use Bitcoin for all their finances.\n> Each of them can have 2.1 mBTC of savings. Assuming the average\n> developed-nation person has about $10e3 savings in today's dollars, 2.1\n> mBTC savings in our scenario should be equivalent to $10e3 in today's\n> dollars. So that is $4800 / mBTC\n\n\nIn that case $1 uBTC is $4.80, and 1 satoshi is about 5c; so you couldn't\ncharge a fee less than 1% for a $5 coffee, and couldn't spend less than 5c\nwhen doing microtransactions.\n\n(Well, obviously if you got to that point you'd *actually* either add more\nprecision to bitcoin, or use sidechains or altcoins at that point.\nActually, I guess you could just add more precision to lightning, but round\nit off for the blockchain transactions)\n\n\n> = $4.8 mln / BTC!\n\n\n\u200bList etiquette question: when people post numbers like this is it required\nto drink a shot of whisky/tequilla and shout \"to the moon!\" ? ;)\u200b\n\n\u200bCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150901/f7f6eb4e/attachment-0001.html>"
            },
            {
                "author": "CJP",
                "date": "2015-08-30T17:30:09",
                "message_text_only": ">         Well-behaving nodes will always pay the fine, thereby keeping\n>         their link\n>         intact and keeping a healthy network of well-behaving nodes.\n> \n> \n> \u200bThe thing that I can't get to work out here is when you have a\n> misbehaving node at the end of a chain, who doesn't pay their fine,\n> but well-behaved nodes making up the rest of the chain. \n>  \n\nIf all fines are accumulated towards the payee side, the effect would be\nthat the last well-behaving node has to pay the fine. So we've punished\nan innocent party. Luckily, this innocent party can prevent further\ndamage by closing the channel to the real bad guy. If the risk of paying\nfines because of mis-behaving neighbors is really significant, you could\ndemand non-trusted (e.g. anonymous) neighbors to pre-pay a fine fund to\nyou, before you start routing payments towards them.\n\nOf course you could also try to design a cryptographic payment channel\nmethod for enforcing fine payment, but I think that, by now, we're\nalready so deep into 2nd-order, 3rd-order etc. effects that it might not\nbe worth the added complexity. You should keep things simple to make\nthem work reliably and have them implemented in time.\n\nCJP"
            },
            {
                "author": "CJP",
                "date": "2015-08-30T18:01:19",
                "message_text_only": ">         A - b - c - D - e - F - g - H\n>         H pays 0.003 mBTC to F (explicit source routing fee; H\n>         selected F for\n>         onion-routing towards D, without A's knowledge)\n> \n> \n> You mean \"D selected F for onion-routing towards H\" here, surely?\n\nNo :-)\n\nBoth sides of a payment may value their privacy, so both sides may want\nto perform onion routing independently. It's a bit similar to TOR hidden\nservices: you route from both sides towards a \"meeting point\" somewhere\non the route, which is not necessarily one of the end points.\n\nNote that, because locking of transaction funds is always done in payer\n-> payee direction, this requires a separate routing phase before the\nlocking. So, first you find a route (where all parties say they agree to\nfees, tx amount, timeouts and other conditions), and then you start\nperforming transaction-channel actions.\n\n> \n>         A pays 0.002 mBTC to b (non-source routing fee)\n>         b pays 0.001 mBTC to c (non-source routing fee)\n>         D pays 0.001 mBTC to c (non-source routing fee)\n>         D pays 0.001 mBTC to e (non-source routing fee)\n>         F pays 0.001 mBTC to e (non-source routing fee)\n>         F pays 0.001 mBTC to g (non-source routing fee)\n>         H pays 0.001 mBTC to g (non-source routing fee)\n> \n> \n> These fees still don't vary with time\u200b, so a 30s result versus a 4 day\n> result still has a factor of 10k difference in cost vs revenue. I\n> think over 4 days, a 0.20% fee is about reasonable matching the 0.002\n> fees that c, e and g end up with above (0.20%/4 days works out to a\n> 20% ROI per annum if all your channels are constantly at 100% use), so\n> linearising to an hour that's a 0.002% fee, which works out to 2\n> satoshi per mBTC per hour.\n\nYeah, after writing that e-mail, I realized I was contradicting myself a\nbit. That system is OK for normal tx fees, but it doesn't seem to work\nfor \"delayed tx fines\". It's a bit of an open question for me how to\ndistribute these fines on a mixed source/non-source routing network.\n\nOn the non-source routed parts, you can't check whether intermediate\nnodes are honest when calculating the to-be-paid fines. Is that a\nproblem, or is it good enough to let the free market do its job, so that\nnodes who demand too high fines will lose connections, just like with tx\nfees? Anyway, I think that for the non-source routing parts, the height\nof the fine (as a function of tx amount and delay) should be agreed\nprior to performing a transaction. An intermediate node can demand a\npayee-side fine that includes a weighed average of the fines it has to\npay payer-side on its other links, to stay profitable. This is the same\nas with regular tx fees.\n\nOn the source-routed parts, the fines seem to end up with the end\npoints. Problems:\n1. There is no persistent business / trust relationship and no payment\nchannel between endpoint and intermediate source-routed node. So there\nis no way to enforce fine payment?\n2. The payee endpoint is not always the bad guy in a delayed payment\nscenario. It could be that fund locking from payer to payee stopped\nsomewhere in the middle of the route: in that case, the payee endpoint\nrightfully never discloses R.\n\nYou could of course ignore source routing for the fines, and distribute\nthe fines as if it is only a non-source routing path. The problem is\nthat an attacker can create an arbitrarily long path with source\nrouting, thereby creating arbitrarily large total damage to the network,\ncorresponding to arbitrarily large total fines. If you use\npre-calculated fine amounts, an attacker can always make a route that\nwill result in a (large) loss for some intermediate nodes.\n\nCJP"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-31T21:08:58",
                "message_text_only": "On 31 August 2015 at 04:01, CJP <cjp at ultimatestunts.nl> wrote:\n\n> >         A - b - c - D - e - F - g - H\n> >         H pays 0.003 mBTC to F (explicit source routing fee; H\n> >         selected F for\n> >         onion-routing towards D, without A's knowledge)\n> > You mean \"D selected F for onion-routing towards H\" here, surely?\n> No :-)\n> Both sides of a payment may value their privacy, so both sides may want\n> to perform onion routing independently.\n> \u200b \u200b\n> It's a bit similar to TOR hidden\n\nservices: you route from both sides towards a \"meeting point\" somewhere\n> on the route, which is not necessarily one of the end points.\n>\n\nHmm. I would look at that more like:\n\nSetup:\n - H wants to be secretive.\n - H establishes a channel with g\n - H tells F he can route to H via g\n - H tells D he can route to H via F\n\nAnnouncement:\n - H tells other people (such as A) they can route to H via D\n\nThen A sends a txn for H to D as instructed, and D chooses to forward it on\nvia F.\n\n(Hmm. In that scenario, if e tried to send a txn to H, she would route via\nD, then find D routed the txn back to it -- using the same R -- and that F\nwas the next destination. This would be an information leak, arguably.\nLikewise for anyone whose cheapest path to D was through e)\n\nNote that, because locking of transaction funds is always done in payer\n> -> payee direction, this requires a separate routing phase before the\n> locking. So, first you find a route (where all parties say they agree to\n> fees, tx amount, timeouts and other conditions), and then you start\n> performing transaction-channel actions.\n>\n\nIsn't that a bit circular -- \"you obtain the route by sending messages\nalong the route\" ?\n\nIt also relies on end-to-end communication in realtime, which wouldn't work\nfor paying to a cold-wallet lightning channel that's only occassionally\nonline.\n\nIf you *did* assume everything is in realtime, you could avoid fines\nentirely just by having the protocol be something like:\n\n - the official timeout was 4 days, the unofficial timeout is 4 minutes\n - ...\n - okay 4 minutes is up, do you know R?\n - no, okay, we're revoking the transaction.\n - you don't want to? fine, channel is closed.\n\nMaybe that's what the default protocol should be anyway, and fines are just\nan extension to that to bribe the payer not to close the channel...\n\nYou could of course ignore source routing for the fines, and distribute\n> the fines as if it is only a non-source routing path. The problem is\n> that an attacker can create an arbitrarily long path with source\n> routing, thereby creating arbitrarily large total damage to the network,\n> corresponding to arbitrarily large total fines.\n\n\n\u200bI don't think it can go arbitrarily large -- if the recipient is paying\nthe fines at each point, then the scenario is:\n\n incoming HTLC: (Alice to Bob)\n   timeout T\n   X (onward funds) + f (Bob's fees) on success\n   x*t (fine Bob pays Alice) if it takes a long time, t\n\n forwarded HTLC (Bob to Carol)\n   timeout T'\n   X (onward funds)\n   (x+y)*t' (fine Carol pays Bob) if it takes a long time, t'\n\nSo Bob can set T' <= M/x where M is the maximum fine I'm willing to pay\nAlice to keep the channel open, if Carol fails to pay the fine and just\ncloses the channel. If T'<=1 hour or similar, you just return a\nPKT_ROUTE_FAIL quickly and don't pay any fines.\n\n\u200bCarol is faced with T'' <= M/(x+y) which is likely smaller still, and s on.\n\nIn the case where a node \u200bis expected to take a while, the original payer\nshould be able to send a fee along to cover that node's fines.\n\nIf you use\n> pre-calculated fine amounts, an attacker can always make a route that\n> will result in a (large) loss for some intermediate nodes.\n>\n\n\u200bOnly by sacrificing a channel, though.\u200b If you set\n\n  commit_fee = 1 mBTC   (how much a unilateral channel close costs)\n  close_fee = 0.1 mBTC  (fees on a cooperative close)\n\nthen if you've got N open HTLC's on your channel with Mallory, then you can\nset M=0.8/N mBTC and offer Mallory the following options:\n\n  a) he pays you the fines he owes, and everyone's happy\n  b) he closes the channel unilaterally and gets whatever he can\n  c) you both close the channel cooperatively, splitting the 0.9 mBTC in\nfees as 0.8 to you, 0.1 to him.\n\nMallory's better off in c) than b), and with c) you can afford to pay your\nfines. Active HTLCs in both directions complicate matters, and 0.8/N mBTC\nstill isn't very much, though.\n\n\u200bCheers,\naj\u200b\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150901/3b9dbce4/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-31T02:16:38",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n>>         So, with some prompting from AJ who has been working on node\n>> incentives, I realized there's a nasty attack available to the network.\n>> You simply route a payment back to another channel you own, then refuse\n>> to dislose R.\n>> \n>> You have to lock up N bitcoins, but so does every node in the path (and\n>> nobody gets paid!).  Onion routing means nobody knows who to blame (you\n>> can simply claim there's another hop after you).\n>\n> Yes, that's a nasty one: the total damage to the network is much larger\n> than the damage to the attacker, especially when the attacker is free to\n> choose a very long route. This could be used to perform a DoS attack on\n> the network.\n\nIndeed.\n\n>> I think in this case we need to peel the onion[1]: if a payment takes\n>> too long you tell the previous node where you sent it (and relay where\n>> it sent it, etc.)  If you're the last in the queue, you also need to\n>> prove that you closed the channel to the offender[2] (which costs you a\n>> txfee, providing disincentive).\n>> \n>> Anyone see any other problems?\n>\n> I don't like the \"peeling the onion\" idea, since it breaks down a very\n\nMe too.\n\n> important privacy layer. This privacy is necessary e.g. to make sure the\n> network remains open for new participants to start routing, even against\n> the will of an existing cartel of routers.\n\nFortunately, I've abandoned it :)\n\nMy latest scheme simply requires you to return some valid unilateral\nclose transaction.  If you don't, I will close the channel to you, and\nuse that unilateral close to prevent my upstream from closing on me.\n\nI think this has the right incentive; unilateral closes are painful in\nlocked funds, fees and opportunity cost.\n\nWe might need to get more sophisticated eventually, but I think it's\nenough for now?\n\nThanks,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-31T21:42:55",
                "message_text_only": "On 31 August 2015 at 12:16, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> My latest scheme simply requires you to return some valid unilateral\n> close transaction.  If you don't, I will close the channel to you, and\n> use that unilateral close to prevent my upstream from closing on me.\n>\n> I think this has the right incentive; unilateral closes are painful in\n> locked funds, fees and opportunity cost.\n>\n> We might need to get more sophisticated eventually, but I think it's\n> enough for now?\n>\n\n\u200b+1\n\n(I think it's actually *more* than enough for now tbh)\n\nCheers,\naj\u200b\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150901/19ad5ad8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Loop attack with onion routing..",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "CJP",
                "Joseph Poon"
            ],
            "messages_count": 22,
            "total_messages_chars_count": 56981
        }
    },
    {
        "title": "[Lightning-dev] A state machine.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-08-20T07:52:11",
                "message_text_only": "Hi all,\n\n        I've written a state machine for the wire protocol (though it\ncovers more than that).  It's a bit of a monster, handling all the\ncommands as well as bitcoin event notifications.  It's had some\nsimulation testing, but it's not wired up to anything yet.\n\nYou can read it in all its glory in my \"state\" branch:\n\nhttps://github.com/ElementsProject/lightning/tree/state\n\nIn particular, I've pasted state_types.h below.\n\nI'll do a proper RFC eventually, including all the transactions, but\nhere's a quick protocol summary:\n\nThe basic protocol state alternates between high and low priority: this\nresolves the conflict if they both try to do an update at once.  They\nrespond to protocol violations with an error packet and unilateral\nclose.\n\nSimplified (high and low prio merged):\n        http://ozlabs.org/~rusty/diagrams/lightning/simplified-states.svg\nNormal:\n        http://ozlabs.org/~rusty/diagrams/lightning/normal-states.svg\nEverything (don't bother opening):\n        http://ozlabs.org/~rusty/diagrams/lightning/full-states.svg\n\nPKT_CLOSE is allowed at any time, though currently if you want to close\nwith outstanding HTLCs you need to do so unilaterally.\n\nThe protocol should handle re-transmits (for which the response is to\nretransmit any packet since that packet was received).  This means if\nyou save state after every transition, you should be able to recover.\n\nCheers,\nRusty.\n\n#define STATE_CLOSE_STEAL_BIT 1\n#define STATE_CLOSE_SPENDTHEM_BIT 2\n#define STATE_CLOSE_CLOSE_BIT 4\n#define STATE_CLOSE_OURCOMMIT_BIT 8\n#define STATE_CLOSE_SPENDOURS_BIT 16\n\nenum state {\n\tSTATE_INIT_NOANCHOR,\n\tSTATE_INIT_WITHANCHOR,\n\n\t/*\n\t * Opening.\n\t */\n\tSTATE_OPEN_WAIT_FOR_OPEN_NOANCHOR,\n\tSTATE_OPEN_WAIT_FOR_OPEN_WITHANCHOR,\n\tSTATE_OPEN_WAIT_FOR_ANCHOR,\n\tSTATE_OPEN_WAIT_FOR_COMMIT_SIG,\n\tSTATE_OPEN_WAITING_OURANCHOR,\n\tSTATE_OPEN_WAITING_THEIRANCHOR,\n\tSTATE_OPEN_WAIT_FOR_COMPLETE_OURANCHOR,\n\tSTATE_OPEN_WAIT_FOR_COMPLETE_THEIRANCHOR,\n\n\t/*\n\t * Normal update loop.\n\t *\n\t * NOTE: High and low prios must alternate!\n\t */\n\tSTATE_NORMAL_LOWPRIO,\n\tSTATE_NORMAL_HIGHPRIO,\n\n\tSTATE_WAIT_FOR_HTLC_ACCEPT_LOWPRIO,\n\tSTATE_WAIT_FOR_HTLC_ACCEPT_HIGHPRIO,\n\n\tSTATE_WAIT_FOR_UPDATE_ACCEPT_LOWPRIO,\n\tSTATE_WAIT_FOR_UPDATE_ACCEPT_HIGHPRIO,\n\n\tSTATE_WAIT_FOR_UPDATE_COMPLETE_LOWPRIO,\n\tSTATE_WAIT_FOR_UPDATE_COMPLETE_HIGHPRIO,\n\n\tSTATE_WAIT_FOR_UPDATE_SIG_LOWPRIO,\n\tSTATE_WAIT_FOR_UPDATE_SIG_HIGHPRIO,\n\n\t/*\n\t * Closing.\n\t */\n\t/* We told them to close, waiting for complete msg. */\n\tSTATE_WAIT_FOR_CLOSE_COMPLETE,\n\t/* They told us to close, waiting for ack msg. */\n\tSTATE_WAIT_FOR_CLOSE_ACK,\t\n\n\t/*\n\t * They can broadcast one or more revoked commit tx, or their latest\n\t * commit tx at any time.  We respond to revoked commit txs by stealing\n\t * their funds (steal).  We respond to their latest commit tx by\n\t * spending (spend_them).  They can also (with our help) broadcast\n\t * a mutual close tx (mutual_close).\n\t *\n\t * We can also broadcast one of the following:\n\t * 1) Our latest commit tx (our_commit).\n\t * 2) After delay has passed, spend of our tx (spend_ours).\n\t * 3) Mutual close tx (mutual_close), already covered above.\n\t *\n\t * Thus, we could be waiting for the following combinations:\n\t * - steal\n\t * - spend_them\n\t * - steal + spend_them\n\t * - mutual_close\n\t * - steal + mutual_close\n\t * - spend_them + mutual_close\n\t * - steal + spend_them + mutual_close\n\t *\n\t * - our_commit\n\t * - steal + our_commit\n\t * - spend_them + our_commit\n\t * - steal + spend_them + our_commit\n\t * - mutual_close + our_commit\n\t * - steal + mutual_close + our_commit\n\t * - spend_them + mutual_close + our_commit\n\t * - steal + spend_them + mutual_close + our_commit\n\t *\n\t * - spend_ours\n\t * - steal + spend_ours\n\t * - spend_them + spend_ours\n\t * - steal + spend_them + spend_ours\n\t * - mutual_close + spend_ours\n\t * - steal + mutual_close + spend_ours\n\t * - spend_them + mutual_close + spend_ours\n\t * - steal + spend_them + mutual_close + spend_ours\n\t */\n\tSTATE_CLOSE_WAIT_STEAL,\n\tSTATE_CLOSE_WAIT_SPENDTHEM,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDTHEM,\n\tSTATE_CLOSE_WAIT_CLOSE,\n\tSTATE_CLOSE_WAIT_STEAL_CLOSE,\n\tSTATE_CLOSE_WAIT_SPENDTHEM_CLOSE,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE,\n\n\tSTATE_CLOSE_WAIT_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_STEAL_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_SPENDTHEM_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_CLOSE_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_STEAL_CLOSE_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT,\n\n\tSTATE_CLOSE_WAIT_SPENDOURS,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDOURS,\n\tSTATE_CLOSE_WAIT_SPENDTHEM_SPENDOURS,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS,\n\tSTATE_CLOSE_WAIT_CLOSE_SPENDOURS,\n\tSTATE_CLOSE_WAIT_STEAL_CLOSE_SPENDOURS,\n\tSTATE_CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS,\n\tSTATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS,\n\n\t/* All closed. */\n\tSTATE_CLOSED,\n\n\t/*\n\t * Where angels fear to tread.\n\t */\n\t/* Their anchor didn't reach blockchain in reasonable time. */\n\tSTATE_ERR_ANCHOR_TIMEOUT,\n\t/* Anchor was double-spent, after both considered it sufficient depth. */\n\tSTATE_ERR_ANCHOR_LOST,\n\t/* A commitment tx we didn't recognise spent the anchor (impossible) */\n\tSTATE_ERR_INFORMATION_LEAK,\n\t/* We ended up in an unexpected state. */\n\tSTATE_ERR_INTERNAL,\n\n\tSTATE_MAX\n};\n\nenum state_input {\n\t/* Packet inputs. */\n\tPKT_OPEN = PKT__PKT_OPEN,\n\tPKT_OPEN_ANCHOR = PKT__PKT_OPEN_ANCHOR,\n\tPKT_OPEN_COMMIT_SIG = PKT__PKT_OPEN_COMMIT_SIG,\n\tPKT_OPEN_COMPLETE = PKT__PKT_OPEN_COMPLETE,\n\tPKT_UPDATE = PKT__PKT_UPDATE,\n\tPKT_UPDATE_ADD_HTLC = PKT__PKT_UPDATE_ADD_HTLC,\n\tPKT_UPDATE_ACCEPT = PKT__PKT_UPDATE_ACCEPT,\n\tPKT_UPDATE_SIGNATURE = PKT__PKT_UPDATE_SIGNATURE,\n\tPKT_UPDATE_COMPLETE = PKT__PKT_UPDATE_COMPLETE,\n\tPKT_UPDATE_COMPLETE_HTLC = PKT__PKT_UPDATE_COMPLETE_HTLC,\n\tPKT_UPDATE_TIMEDOUT_HTLC = PKT__PKT_UPDATE_TIMEDOUT_HTLC,\n\tPKT_UPDATE_ROUTEFAIL_HTLC = PKT__PKT_UPDATE_ROUTEFAIL_HTLC,\n\tPKT_UPDATE_DECLINE_HTLC = PKT__PKT_UPDATE_DECLINE_HTLC,\n\tPKT_CLOSE = PKT__PKT_CLOSE,\n\tPKT_CLOSE_COMPLETE = PKT__PKT_CLOSE_COMPLETE,\n\tPKT_CLOSE_ACK = PKT__PKT_CLOSE_ACK,\n\tPKT_ERROR = PKT__PKT_ERROR,\n\n\t/* Non-packet inputs. */\t\n\tINPUT_NONE,\n\n\t/*\n\t * Bitcoin events\n\t */\n\t/* It reached the required depth. */\n\tBITCOIN_ANCHOR_DEPTHOK,\n\t/* It didn't reach the required depth in time. */\n\tBITCOIN_ANCHOR_TIMEOUT,\n\t/* It reached the required depth, then was forked off. */\n\tBITCOIN_ANCHOR_UNSPENT,\n\t/* Anchor was spent by our commit, and we can now spend it. */\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED,\n\t/* Anchor was spent by their commit tx. */\n\tBITCOIN_ANCHOR_THEIRSPEND,\n\t/* Anchor was spent by another commit tx (eg. expired). */\n\tBITCOIN_ANCHOR_OTHERSPEND,\n\n\t/* Our spend of their commit tx is completely buried. */\n\tBITCOIN_SPEND_THEIRS_DONE,\n\t/* Our spend of our own tx is completely buried. */\n\tBITCOIN_SPEND_OURS_DONE,\n\t/* Our spend of their revoked tx is completely buried. */\n\tBITCOIN_STEAL_DONE,\n\t/* Bitcoin close transaction considered completely buried. */\n\tBITCOIN_CLOSE_DONE,\n\n\t/*\n\t * Timeouts.\n\t */\n\tINPUT_CLOSE_COMPLETE_TIMEOUT,\n\t\n\t/* Commands */\n\tCMD_SEND_UPDATE,\n\tCMD_SEND_HTLC_UPDATE,\n\tCMD_SEND_HTLC_COMPLETE,\n\tCMD_SEND_HTLC_TIMEDOUT,\n\tCMD_SEND_HTLC_ROUTEFAIL,\n\tCMD_CLOSE,\n\n\tINPUT_MAX\n};"
            },
            {
                "author": "Pierre",
                "date": "2015-08-20T18:20:04",
                "message_text_only": "Hello all,\n\nFirst, bravo for the great work on lightning ! @Rusty I'm the guy who\nrecently made two dummy PR on your github project, thanks for merging them\n;-)\n\nI've just got one remark : from OPEN_WAITING state, you seem to be assuming\nthat the event BITCOIN_ANCHOR_DEPTHOK will always happen before receiving\nthe other party's PKT_OPEN_COMPLETE ; but that won't necessarily be the\ncase depending on each party's minDepth, right ?\n\nAlso, can you please confirm that the following is correct in an\nAlice->Bob->Carol->Dave scenario if we look at the state of *Bob* ?\n\n1) Bob is in NORMAL state\n- Bob receives update_add_htlc from Alice\n- Bob sends update_accept to Alice\n\n2) Bob switches to WAIT_FOR_UPDATE_SIG state\n- Bob receives update_signature from Alice\n\n- (Bob sends update_add_htlc to Carol on another channel)\n- (Bob receives update_complete_htlc on another channel)\n\n3) Bob switches to NORMAL state\n- Bob sends update_accept to Alice\n\n4) Bob switches to WAIT_FOR_UPDATE_SIG state\n- Bob receives update_signature from Alice\n\n5) Bob switches to NORMAL state\n\nThanks,\n\nPierre\n\n2015-08-20 9:52 GMT+02:00 Rusty Russell <rusty at rustcorp.com.au>:\n\n> Hi all,\n>\n>         I've written a state machine for the wire protocol (though it\n> covers more than that).  It's a bit of a monster, handling all the\n> commands as well as bitcoin event notifications.  It's had some\n> simulation testing, but it's not wired up to anything yet.\n>\n> You can read it in all its glory in my \"state\" branch:\n>\n> https://github.com/ElementsProject/lightning/tree/state\n>\n> In particular, I've pasted state_types.h below.\n>\n> I'll do a proper RFC eventually, including all the transactions, but\n> here's a quick protocol summary:\n>\n> The basic protocol state alternates between high and low priority: this\n> resolves the conflict if they both try to do an update at once.  They\n> respond to protocol violations with an error packet and unilateral\n> close.\n>\n> Simplified (high and low prio merged):\n>         http://ozlabs.org/~rusty/diagrams/lightning/simplified-states.svg\n> Normal:\n>         http://ozlabs.org/~rusty/diagrams/lightning/normal-states.svg\n> Everything (don't bother opening):\n>         http://ozlabs.org/~rusty/diagrams/lightning/full-states.svg\n>\n> PKT_CLOSE is allowed at any time, though currently if you want to close\n> with outstanding HTLCs you need to do so unilaterally.\n>\n> The protocol should handle re-transmits (for which the response is to\n> retransmit any packet since that packet was received).  This means if\n> you save state after every transition, you should be able to recover.\n>\n> Cheers,\n> Rusty.\n>\n> #define STATE_CLOSE_STEAL_BIT 1\n> #define STATE_CLOSE_SPENDTHEM_BIT 2\n> #define STATE_CLOSE_CLOSE_BIT 4\n> #define STATE_CLOSE_OURCOMMIT_BIT 8\n> #define STATE_CLOSE_SPENDOURS_BIT 16\n>\n> enum state {\n>         STATE_INIT_NOANCHOR,\n>         STATE_INIT_WITHANCHOR,\n>\n>         /*\n>          * Opening.\n>          */\n>         STATE_OPEN_WAIT_FOR_OPEN_NOANCHOR,\n>         STATE_OPEN_WAIT_FOR_OPEN_WITHANCHOR,\n>         STATE_OPEN_WAIT_FOR_ANCHOR,\n>         STATE_OPEN_WAIT_FOR_COMMIT_SIG,\n>         STATE_OPEN_WAITING_OURANCHOR,\n>         STATE_OPEN_WAITING_THEIRANCHOR,\n>         STATE_OPEN_WAIT_FOR_COMPLETE_OURANCHOR,\n>         STATE_OPEN_WAIT_FOR_COMPLETE_THEIRANCHOR,\n>\n>         /*\n>          * Normal update loop.\n>          *\n>          * NOTE: High and low prios must alternate!\n>          */\n>         STATE_NORMAL_LOWPRIO,\n>         STATE_NORMAL_HIGHPRIO,\n>\n>         STATE_WAIT_FOR_HTLC_ACCEPT_LOWPRIO,\n>         STATE_WAIT_FOR_HTLC_ACCEPT_HIGHPRIO,\n>\n>         STATE_WAIT_FOR_UPDATE_ACCEPT_LOWPRIO,\n>         STATE_WAIT_FOR_UPDATE_ACCEPT_HIGHPRIO,\n>\n>         STATE_WAIT_FOR_UPDATE_COMPLETE_LOWPRIO,\n>         STATE_WAIT_FOR_UPDATE_COMPLETE_HIGHPRIO,\n>\n>         STATE_WAIT_FOR_UPDATE_SIG_LOWPRIO,\n>         STATE_WAIT_FOR_UPDATE_SIG_HIGHPRIO,\n>\n>         /*\n>          * Closing.\n>          */\n>         /* We told them to close, waiting for complete msg. */\n>         STATE_WAIT_FOR_CLOSE_COMPLETE,\n>         /* They told us to close, waiting for ack msg. */\n>         STATE_WAIT_FOR_CLOSE_ACK,\n>\n>         /*\n>          * They can broadcast one or more revoked commit tx, or their\n> latest\n>          * commit tx at any time.  We respond to revoked commit txs by\n> stealing\n>          * their funds (steal).  We respond to their latest commit tx by\n>          * spending (spend_them).  They can also (with our help) broadcast\n>          * a mutual close tx (mutual_close).\n>          *\n>          * We can also broadcast one of the following:\n>          * 1) Our latest commit tx (our_commit).\n>          * 2) After delay has passed, spend of our tx (spend_ours).\n>          * 3) Mutual close tx (mutual_close), already covered above.\n>          *\n>          * Thus, we could be waiting for the following combinations:\n>          * - steal\n>          * - spend_them\n>          * - steal + spend_them\n>          * - mutual_close\n>          * - steal + mutual_close\n>          * - spend_them + mutual_close\n>          * - steal + spend_them + mutual_close\n>          *\n>          * - our_commit\n>          * - steal + our_commit\n>          * - spend_them + our_commit\n>          * - steal + spend_them + our_commit\n>          * - mutual_close + our_commit\n>          * - steal + mutual_close + our_commit\n>          * - spend_them + mutual_close + our_commit\n>          * - steal + spend_them + mutual_close + our_commit\n>          *\n>          * - spend_ours\n>          * - steal + spend_ours\n>          * - spend_them + spend_ours\n>          * - steal + spend_them + spend_ours\n>          * - mutual_close + spend_ours\n>          * - steal + mutual_close + spend_ours\n>          * - spend_them + mutual_close + spend_ours\n>          * - steal + spend_them + mutual_close + spend_ours\n>          */\n>         STATE_CLOSE_WAIT_STEAL,\n>         STATE_CLOSE_WAIT_SPENDTHEM,\n>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM,\n>         STATE_CLOSE_WAIT_CLOSE,\n>         STATE_CLOSE_WAIT_STEAL_CLOSE,\n>         STATE_CLOSE_WAIT_SPENDTHEM_CLOSE,\n>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE,\n>\n>         STATE_CLOSE_WAIT_OURCOMMIT,\n>         STATE_CLOSE_WAIT_STEAL_OURCOMMIT,\n>         STATE_CLOSE_WAIT_SPENDTHEM_OURCOMMIT,\n>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT,\n>         STATE_CLOSE_WAIT_CLOSE_OURCOMMIT,\n>         STATE_CLOSE_WAIT_STEAL_CLOSE_OURCOMMIT,\n>         STATE_CLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT,\n>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT,\n>\n>         STATE_CLOSE_WAIT_SPENDOURS,\n>         STATE_CLOSE_WAIT_STEAL_SPENDOURS,\n>         STATE_CLOSE_WAIT_SPENDTHEM_SPENDOURS,\n>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS,\n>         STATE_CLOSE_WAIT_CLOSE_SPENDOURS,\n>         STATE_CLOSE_WAIT_STEAL_CLOSE_SPENDOURS,\n>         STATE_CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS,\n>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS,\n>\n>         /* All closed. */\n>         STATE_CLOSED,\n>\n>         /*\n>          * Where angels fear to tread.\n>          */\n>         /* Their anchor didn't reach blockchain in reasonable time. */\n>         STATE_ERR_ANCHOR_TIMEOUT,\n>         /* Anchor was double-spent, after both considered it sufficient\n> depth. */\n>         STATE_ERR_ANCHOR_LOST,\n>         /* A commitment tx we didn't recognise spent the anchor\n> (impossible) */\n>         STATE_ERR_INFORMATION_LEAK,\n>         /* We ended up in an unexpected state. */\n>         STATE_ERR_INTERNAL,\n>\n>         STATE_MAX\n> };\n>\n> enum state_input {\n>         /* Packet inputs. */\n>         PKT_OPEN = PKT__PKT_OPEN,\n>         PKT_OPEN_ANCHOR = PKT__PKT_OPEN_ANCHOR,\n>         PKT_OPEN_COMMIT_SIG = PKT__PKT_OPEN_COMMIT_SIG,\n>         PKT_OPEN_COMPLETE = PKT__PKT_OPEN_COMPLETE,\n>         PKT_UPDATE = PKT__PKT_UPDATE,\n>         PKT_UPDATE_ADD_HTLC = PKT__PKT_UPDATE_ADD_HTLC,\n>         PKT_UPDATE_ACCEPT = PKT__PKT_UPDATE_ACCEPT,\n>         PKT_UPDATE_SIGNATURE = PKT__PKT_UPDATE_SIGNATURE,\n>         PKT_UPDATE_COMPLETE = PKT__PKT_UPDATE_COMPLETE,\n>         PKT_UPDATE_COMPLETE_HTLC = PKT__PKT_UPDATE_COMPLETE_HTLC,\n>         PKT_UPDATE_TIMEDOUT_HTLC = PKT__PKT_UPDATE_TIMEDOUT_HTLC,\n>         PKT_UPDATE_ROUTEFAIL_HTLC = PKT__PKT_UPDATE_ROUTEFAIL_HTLC,\n>         PKT_UPDATE_DECLINE_HTLC = PKT__PKT_UPDATE_DECLINE_HTLC,\n>         PKT_CLOSE = PKT__PKT_CLOSE,\n>         PKT_CLOSE_COMPLETE = PKT__PKT_CLOSE_COMPLETE,\n>         PKT_CLOSE_ACK = PKT__PKT_CLOSE_ACK,\n>         PKT_ERROR = PKT__PKT_ERROR,\n>\n>         /* Non-packet inputs. */\n>         INPUT_NONE,\n>\n>         /*\n>          * Bitcoin events\n>          */\n>         /* It reached the required depth. */\n>         BITCOIN_ANCHOR_DEPTHOK,\n>         /* It didn't reach the required depth in time. */\n>         BITCOIN_ANCHOR_TIMEOUT,\n>         /* It reached the required depth, then was forked off. */\n>         BITCOIN_ANCHOR_UNSPENT,\n>         /* Anchor was spent by our commit, and we can now spend it. */\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED,\n>         /* Anchor was spent by their commit tx. */\n>         BITCOIN_ANCHOR_THEIRSPEND,\n>         /* Anchor was spent by another commit tx (eg. expired). */\n>         BITCOIN_ANCHOR_OTHERSPEND,\n>\n>         /* Our spend of their commit tx is completely buried. */\n>         BITCOIN_SPEND_THEIRS_DONE,\n>         /* Our spend of our own tx is completely buried. */\n>         BITCOIN_SPEND_OURS_DONE,\n>         /* Our spend of their revoked tx is completely buried. */\n>         BITCOIN_STEAL_DONE,\n>         /* Bitcoin close transaction considered completely buried. */\n>         BITCOIN_CLOSE_DONE,\n>\n>         /*\n>          * Timeouts.\n>          */\n>         INPUT_CLOSE_COMPLETE_TIMEOUT,\n>\n>         /* Commands */\n>         CMD_SEND_UPDATE,\n>         CMD_SEND_HTLC_UPDATE,\n>         CMD_SEND_HTLC_COMPLETE,\n>         CMD_SEND_HTLC_TIMEDOUT,\n>         CMD_SEND_HTLC_ROUTEFAIL,\n>         CMD_CLOSE,\n>\n>         INPUT_MAX\n> };\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150820/608ed0f0/attachment.html>"
            },
            {
                "author": "Pierre",
                "date": "2015-08-20T18:36:09",
                "message_text_only": "Sorry I messed things up, let me try again !\n\n1) Bob is in NORMAL state\n- Bob receives update_add_htlc from Alice\n- Bob sends update_accept to Alice\n\n2) Bob switches to WAIT_FOR_UPDATE_SIG state\n- Bob receives update_signature from Alice\n- Bob sends update_complete to Alice\n\n3) Bob switches to NORMAL state\n- (Bob sends update_add_htlc to Carol on another channel)\n- (Bob receives update_complete_htlc from Carol on another channel)\n- Bob sends update_complete_htlc to Alice\n\n4) Bob switches to WAIT_FOR_HTLC_ACCEPT state\n- Bob receives update_accept from Alice\n- Bob sends update_signature to Alice\n\n5) Bob switches to WAIT_FOR_UPDATE_COMPLETE state\n- Bob receives update_complete from Alice\n\n6) Bob switches to NORMAL state\n\nPhew, does that make sense ?\n\nPierre\n\n2015-08-20 20:20 GMT+02:00 Pierre <pm+lists at acinq.fr>:\n\n> Hello all,\n>\n> First, bravo for the great work on lightning ! @Rusty I'm the guy who\n> recently made two dummy PR on your github project, thanks for merging them\n> ;-)\n>\n> I've just got one remark : from OPEN_WAITING state, you seem to be\n> assuming that the event BITCOIN_ANCHOR_DEPTHOK will always happen before\n> receiving the other party's PKT_OPEN_COMPLETE ; but that won't necessarily\n> be the case depending on each party's minDepth, right ?\n>\n> Also, can you please confirm that the following is correct in an\n> Alice->Bob->Carol->Dave scenario if we look at the state of *Bob* ?\n>\n> 1) Bob is in NORMAL state\n> - Bob receives update_add_htlc from Alice\n> - Bob sends update_accept to Alice\n>\n> 2) Bob switches to WAIT_FOR_UPDATE_SIG state\n> - Bob receives update_signature from Alice\n>\n> - (Bob sends update_add_htlc to Carol on another channel)\n> - (Bob receives update_complete_htlc on another channel)\n>\n> 3) Bob switches to NORMAL state\n> - Bob sends update_accept to Alice\n>\n> 4) Bob switches to WAIT_FOR_UPDATE_SIG state\n> - Bob receives update_signature from Alice\n>\n> 5) Bob switches to NORMAL state\n>\n> Thanks,\n>\n> Pierre\n>\n> 2015-08-20 9:52 GMT+02:00 Rusty Russell <rusty at rustcorp.com.au>:\n>\n>> Hi all,\n>>\n>>         I've written a state machine for the wire protocol (though it\n>> covers more than that).  It's a bit of a monster, handling all the\n>> commands as well as bitcoin event notifications.  It's had some\n>> simulation testing, but it's not wired up to anything yet.\n>>\n>> You can read it in all its glory in my \"state\" branch:\n>>\n>> https://github.com/ElementsProject/lightning/tree/state\n>>\n>> In particular, I've pasted state_types.h below.\n>>\n>> I'll do a proper RFC eventually, including all the transactions, but\n>> here's a quick protocol summary:\n>>\n>> The basic protocol state alternates between high and low priority: this\n>> resolves the conflict if they both try to do an update at once.  They\n>> respond to protocol violations with an error packet and unilateral\n>> close.\n>>\n>> Simplified (high and low prio merged):\n>>         http://ozlabs.org/~rusty/diagrams/lightning/simplified-states.svg\n>> Normal:\n>>         http://ozlabs.org/~rusty/diagrams/lightning/normal-states.svg\n>> Everything (don't bother opening):\n>>         http://ozlabs.org/~rusty/diagrams/lightning/full-states.svg\n>>\n>> PKT_CLOSE is allowed at any time, though currently if you want to close\n>> with outstanding HTLCs you need to do so unilaterally.\n>>\n>> The protocol should handle re-transmits (for which the response is to\n>> retransmit any packet since that packet was received).  This means if\n>> you save state after every transition, you should be able to recover.\n>>\n>> Cheers,\n>> Rusty.\n>>\n>> #define STATE_CLOSE_STEAL_BIT 1\n>> #define STATE_CLOSE_SPENDTHEM_BIT 2\n>> #define STATE_CLOSE_CLOSE_BIT 4\n>> #define STATE_CLOSE_OURCOMMIT_BIT 8\n>> #define STATE_CLOSE_SPENDOURS_BIT 16\n>>\n>> enum state {\n>>         STATE_INIT_NOANCHOR,\n>>         STATE_INIT_WITHANCHOR,\n>>\n>>         /*\n>>          * Opening.\n>>          */\n>>         STATE_OPEN_WAIT_FOR_OPEN_NOANCHOR,\n>>         STATE_OPEN_WAIT_FOR_OPEN_WITHANCHOR,\n>>         STATE_OPEN_WAIT_FOR_ANCHOR,\n>>         STATE_OPEN_WAIT_FOR_COMMIT_SIG,\n>>         STATE_OPEN_WAITING_OURANCHOR,\n>>         STATE_OPEN_WAITING_THEIRANCHOR,\n>>         STATE_OPEN_WAIT_FOR_COMPLETE_OURANCHOR,\n>>         STATE_OPEN_WAIT_FOR_COMPLETE_THEIRANCHOR,\n>>\n>>         /*\n>>          * Normal update loop.\n>>          *\n>>          * NOTE: High and low prios must alternate!\n>>          */\n>>         STATE_NORMAL_LOWPRIO,\n>>         STATE_NORMAL_HIGHPRIO,\n>>\n>>         STATE_WAIT_FOR_HTLC_ACCEPT_LOWPRIO,\n>>         STATE_WAIT_FOR_HTLC_ACCEPT_HIGHPRIO,\n>>\n>>         STATE_WAIT_FOR_UPDATE_ACCEPT_LOWPRIO,\n>>         STATE_WAIT_FOR_UPDATE_ACCEPT_HIGHPRIO,\n>>\n>>         STATE_WAIT_FOR_UPDATE_COMPLETE_LOWPRIO,\n>>         STATE_WAIT_FOR_UPDATE_COMPLETE_HIGHPRIO,\n>>\n>>         STATE_WAIT_FOR_UPDATE_SIG_LOWPRIO,\n>>         STATE_WAIT_FOR_UPDATE_SIG_HIGHPRIO,\n>>\n>>         /*\n>>          * Closing.\n>>          */\n>>         /* We told them to close, waiting for complete msg. */\n>>         STATE_WAIT_FOR_CLOSE_COMPLETE,\n>>         /* They told us to close, waiting for ack msg. */\n>>         STATE_WAIT_FOR_CLOSE_ACK,\n>>\n>>         /*\n>>          * They can broadcast one or more revoked commit tx, or their\n>> latest\n>>          * commit tx at any time.  We respond to revoked commit txs by\n>> stealing\n>>          * their funds (steal).  We respond to their latest commit tx by\n>>          * spending (spend_them).  They can also (with our help) broadcast\n>>          * a mutual close tx (mutual_close).\n>>          *\n>>          * We can also broadcast one of the following:\n>>          * 1) Our latest commit tx (our_commit).\n>>          * 2) After delay has passed, spend of our tx (spend_ours).\n>>          * 3) Mutual close tx (mutual_close), already covered above.\n>>          *\n>>          * Thus, we could be waiting for the following combinations:\n>>          * - steal\n>>          * - spend_them\n>>          * - steal + spend_them\n>>          * - mutual_close\n>>          * - steal + mutual_close\n>>          * - spend_them + mutual_close\n>>          * - steal + spend_them + mutual_close\n>>          *\n>>          * - our_commit\n>>          * - steal + our_commit\n>>          * - spend_them + our_commit\n>>          * - steal + spend_them + our_commit\n>>          * - mutual_close + our_commit\n>>          * - steal + mutual_close + our_commit\n>>          * - spend_them + mutual_close + our_commit\n>>          * - steal + spend_them + mutual_close + our_commit\n>>          *\n>>          * - spend_ours\n>>          * - steal + spend_ours\n>>          * - spend_them + spend_ours\n>>          * - steal + spend_them + spend_ours\n>>          * - mutual_close + spend_ours\n>>          * - steal + mutual_close + spend_ours\n>>          * - spend_them + mutual_close + spend_ours\n>>          * - steal + spend_them + mutual_close + spend_ours\n>>          */\n>>         STATE_CLOSE_WAIT_STEAL,\n>>         STATE_CLOSE_WAIT_SPENDTHEM,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM,\n>>         STATE_CLOSE_WAIT_CLOSE,\n>>         STATE_CLOSE_WAIT_STEAL_CLOSE,\n>>         STATE_CLOSE_WAIT_SPENDTHEM_CLOSE,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE,\n>>\n>>         STATE_CLOSE_WAIT_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_STEAL_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_SPENDTHEM_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_CLOSE_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_STEAL_CLOSE_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT,\n>>\n>>         STATE_CLOSE_WAIT_SPENDOURS,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDOURS,\n>>         STATE_CLOSE_WAIT_SPENDTHEM_SPENDOURS,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS,\n>>         STATE_CLOSE_WAIT_CLOSE_SPENDOURS,\n>>         STATE_CLOSE_WAIT_STEAL_CLOSE_SPENDOURS,\n>>         STATE_CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS,\n>>         STATE_CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS,\n>>\n>>         /* All closed. */\n>>         STATE_CLOSED,\n>>\n>>         /*\n>>          * Where angels fear to tread.\n>>          */\n>>         /* Their anchor didn't reach blockchain in reasonable time. */\n>>         STATE_ERR_ANCHOR_TIMEOUT,\n>>         /* Anchor was double-spent, after both considered it sufficient\n>> depth. */\n>>         STATE_ERR_ANCHOR_LOST,\n>>         /* A commitment tx we didn't recognise spent the anchor\n>> (impossible) */\n>>         STATE_ERR_INFORMATION_LEAK,\n>>         /* We ended up in an unexpected state. */\n>>         STATE_ERR_INTERNAL,\n>>\n>>         STATE_MAX\n>> };\n>>\n>> enum state_input {\n>>         /* Packet inputs. */\n>>         PKT_OPEN = PKT__PKT_OPEN,\n>>         PKT_OPEN_ANCHOR = PKT__PKT_OPEN_ANCHOR,\n>>         PKT_OPEN_COMMIT_SIG = PKT__PKT_OPEN_COMMIT_SIG,\n>>         PKT_OPEN_COMPLETE = PKT__PKT_OPEN_COMPLETE,\n>>         PKT_UPDATE = PKT__PKT_UPDATE,\n>>         PKT_UPDATE_ADD_HTLC = PKT__PKT_UPDATE_ADD_HTLC,\n>>         PKT_UPDATE_ACCEPT = PKT__PKT_UPDATE_ACCEPT,\n>>         PKT_UPDATE_SIGNATURE = PKT__PKT_UPDATE_SIGNATURE,\n>>         PKT_UPDATE_COMPLETE = PKT__PKT_UPDATE_COMPLETE,\n>>         PKT_UPDATE_COMPLETE_HTLC = PKT__PKT_UPDATE_COMPLETE_HTLC,\n>>         PKT_UPDATE_TIMEDOUT_HTLC = PKT__PKT_UPDATE_TIMEDOUT_HTLC,\n>>         PKT_UPDATE_ROUTEFAIL_HTLC = PKT__PKT_UPDATE_ROUTEFAIL_HTLC,\n>>         PKT_UPDATE_DECLINE_HTLC = PKT__PKT_UPDATE_DECLINE_HTLC,\n>>         PKT_CLOSE = PKT__PKT_CLOSE,\n>>         PKT_CLOSE_COMPLETE = PKT__PKT_CLOSE_COMPLETE,\n>>         PKT_CLOSE_ACK = PKT__PKT_CLOSE_ACK,\n>>         PKT_ERROR = PKT__PKT_ERROR,\n>>\n>>         /* Non-packet inputs. */\n>>         INPUT_NONE,\n>>\n>>         /*\n>>          * Bitcoin events\n>>          */\n>>         /* It reached the required depth. */\n>>         BITCOIN_ANCHOR_DEPTHOK,\n>>         /* It didn't reach the required depth in time. */\n>>         BITCOIN_ANCHOR_TIMEOUT,\n>>         /* It reached the required depth, then was forked off. */\n>>         BITCOIN_ANCHOR_UNSPENT,\n>>         /* Anchor was spent by our commit, and we can now spend it. */\n>>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED,\n>>         /* Anchor was spent by their commit tx. */\n>>         BITCOIN_ANCHOR_THEIRSPEND,\n>>         /* Anchor was spent by another commit tx (eg. expired). */\n>>         BITCOIN_ANCHOR_OTHERSPEND,\n>>\n>>         /* Our spend of their commit tx is completely buried. */\n>>         BITCOIN_SPEND_THEIRS_DONE,\n>>         /* Our spend of our own tx is completely buried. */\n>>         BITCOIN_SPEND_OURS_DONE,\n>>         /* Our spend of their revoked tx is completely buried. */\n>>         BITCOIN_STEAL_DONE,\n>>         /* Bitcoin close transaction considered completely buried. */\n>>         BITCOIN_CLOSE_DONE,\n>>\n>>         /*\n>>          * Timeouts.\n>>          */\n>>         INPUT_CLOSE_COMPLETE_TIMEOUT,\n>>\n>>         /* Commands */\n>>         CMD_SEND_UPDATE,\n>>         CMD_SEND_HTLC_UPDATE,\n>>         CMD_SEND_HTLC_COMPLETE,\n>>         CMD_SEND_HTLC_TIMEDOUT,\n>>         CMD_SEND_HTLC_ROUTEFAIL,\n>>         CMD_CLOSE,\n>>\n>>         INPUT_MAX\n>> };\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150820/9b067b43/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-21T01:33:52",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Sorry I messed things up, let me try again !\n>\n> 1) Bob is in NORMAL state\n> - Bob receives update_add_htlc from Alice\n> - Bob sends update_accept to Alice\n>\n> 2) Bob switches to WAIT_FOR_UPDATE_SIG state\n> - Bob receives update_signature from Alice\n> - Bob sends update_complete to Alice\n>\n> 3) Bob switches to NORMAL state\n\nYep, Bob goes NORMAL (send PKT_UPDATE_ACCEPT)\n        -> WAIT_FOR_UPDATE_SIG\n        -> NORMAL\n\nWhen Carol completes htlc, Bob sees CMD_SEND_HTLC_COMPLETE,\nand does:\n\n        NORMAL (send PKT_UPDATE_COMPLETE_HTLC)\n        -> STATE_WAIT_FOR_HTLC_ACCEPT (send PKT_UPDATE_SIGNATURE)\n        -> STATE_WAIT_FOR_UPDATE_COMPLETE\n        -> NORMAL\n\n> - (Bob sends update_add_htlc to Carol on another channel)\n> - (Bob receives update_complete_htlc from Carol on another channel)\n> - Bob sends update_complete_htlc to Alice\n>\n> 4) Bob switches to WAIT_FOR_HTLC_ACCEPT state\n> - Bob receives update_accept from Alice\n> - Bob sends update_signature to Alice\n>\n> 5) Bob switches to WAIT_FOR_UPDATE_COMPLETE state\n> - Bob receives update_complete from Alice\n>\n> 6) Bob switches to NORMAL state\n>\n> Phew, does that make sense ?\n\nYeah.  Let me generate a decent text flowchart for the normal cases...\n\nThanks!\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-21T05:32:32",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n> Yeah.  Let me generate a decent text flowchart for the normal cases...\n\nI've taken out some transitions for simplicity (eg. ERR_ANCHOR_LOST and\nERR_INFORMATION_LEAK, which shouldn't happen):\n\nNormal opening states:\n\nINIT_NOANCHOR:\n\tINPUT_NONE -> OPEN_WAIT_FOR_OPEN_NOANCHOR (=>PKT_OPEN)\nINIT_WITHANCHOR:\n\tINPUT_NONE -> OPEN_WAIT_FOR_OPEN_WITHANCHOR (=>PKT_OPEN)\nOPEN_WAIT_FOR_OPEN_NOANCHOR:\n\tPKT_OPEN -> OPEN_WAIT_FOR_ANCHOR\n\tCMD_CLOSE -> CLOSED\nOPEN_WAIT_FOR_OPEN_WITHANCHOR:\n\tPKT_OPEN -> OPEN_WAIT_FOR_COMMIT_SIG (=>PKT_OPEN_ANCHOR)\n\tCMD_CLOSE -> CLOSED\nOPEN_WAIT_FOR_ANCHOR:\n\tPKT_OPEN_ANCHOR -> OPEN_WAITING_THEIRANCHOR (=>PKT_OPEN_COMMIT_SIG)\n\tCMD_CLOSE -> CLOSED\nOPEN_WAIT_FOR_COMMIT_SIG:\n\tPKT_OPEN_COMMIT_SIG -> OPEN_WAITING_OURANCHOR\n\tCMD_CLOSE -> CLOSED\nOPEN_WAITING_OURANCHOR:\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tBITCOIN_ANCHOR_DEPTHOK -> OPEN_WAIT_FOR_COMPLETE_OURANCHOR (=>PKT_OPEN_COMPLETE)\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tCMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\nOPEN_WAITING_THEIRANCHOR:\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_DEPTHOK -> OPEN_WAIT_FOR_COMPLETE_THEIRANCHOR (=>PKT_OPEN_COMPLETE)\n\tBITCOIN_ANCHOR_TIMEOUT -> ERR_ANCHOR_TIMEOUT (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tCMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n\nOPEN_WAIT_FOR_COMPLETE_OURANCHOR:\n\tPKT_OPEN_COMPLETE -> NORMAL_HIGHPRIO\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tCMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n\nOPEN_WAIT_FOR_COMPLETE_THEIRANCHOR:\n\tPKT_OPEN_COMPLETE -> NORMAL_LOWPRIO\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tCMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n\nOperational state loop:\n======================\nI've folded high and low here, but we alternate.\n\nNORMAL_LOWPRIO:\nNORMAL_HIGHPRIO:\n\tPKT_UPDATE -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ADD_HTLC -> NORMAL_HIGHPRIO (=>PKT_UPDATE_DECLINE_HTLC)\n\tPKT_UPDATE_ADD_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_COMPLETE_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_TIMEDOUT_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ROUTEFAIL_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n\tCMD_SEND_UPDATE -> WAIT_FOR_UPDATE_ACCEPT_LOWPRIO (=>PKT_UPDATE)\n\tCMD_SEND_HTLC_UPDATE -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO (=>PKT_UPDATE_ADD_HTLC)\n\tCMD_SEND_HTLC_COMPLETE -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO (=>PKT_UPDATE_COMPLETE_HTLC)\n\tCMD_SEND_HTLC_TIMEDOUT -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO (=>PKT_UPDATE_TIMEDOUT_HTLC)\n\tCMD_SEND_HTLC_ROUTEFAIL -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO (=>PKT_UPDATE_ROUTEFAIL_HTLC)\n\tCMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n\nWAIT_FOR_HTLC_ACCEPT_LOWPRIO:\nWAIT_FOR_HTLC_ACCEPT_HIGHPRIO:\n\tPKT_UPDATE -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ADD_HTLC -> NORMAL_HIGHPRIO (=>PKT_UPDATE_DECLINE_HTLC)\n\tPKT_UPDATE_ADD_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ACCEPT -> WAIT_FOR_UPDATE_COMPLETE_LOWPRIO (=>PKT_UPDATE_SIGNATURE)\n\tPKT_UPDATE_DECLINE_HTLC -> NORMAL_HIGHPRIO\n\tPKT_UPDATE_COMPLETE_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_TIMEDOUT_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ROUTEFAIL_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\nWAIT_FOR_HTLC_ACCEPT_HIGHPRIO:\n\tPKT_UPDATE_ACCEPT -> WAIT_FOR_UPDATE_COMPLETE_HIGHPRIO (=>PKT_UPDATE_SIGNATURE)\n\tPKT_UPDATE_DECLINE_HTLC -> NORMAL_LOWPRIO\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n\nWAIT_FOR_UPDATE_ACCEPT_LOWPRIO:\nWAIT_FOR_UPDATE_ACCEPT_HIGHPRIO:\n\tPKT_UPDATE -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ADD_HTLC -> NORMAL_HIGHPRIO (=>PKT_UPDATE_DECLINE_HTLC)\n\tPKT_UPDATE_ADD_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ACCEPT -> WAIT_FOR_UPDATE_COMPLETE_LOWPRIO (=>PKT_UPDATE_SIGNATURE)\n\tPKT_UPDATE_COMPLETE_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_TIMEDOUT_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_UPDATE_ROUTEFAIL_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n\nWAIT_FOR_UPDATE_COMPLETE_LOWPRIO:\nWAIT_FOR_UPDATE_COMPLETE_HIGHPRIO:\n\tPKT_UPDATE_COMPLETE -> NORMAL_HIGHPRIO\n\tPKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n\nWAIT_FOR_UPDATE_SIG_LOWPRIO:\n\tPKT_UPDATE_SIGNATURE -> NORMAL_HIGHPRIO (=>PKT_UPDATE_COMPLETE)\n        ...\nWAIT_FOR_UPDATE_SIG_HIGHPRIO:\n\tPKT_UPDATE_SIGNATURE -> NORMAL_LOWPRIO (=>PKT_UPDATE_COMPLETE)\n\tPKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n\tCMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n\nNormal closing:\n==============\n\nWAIT_FOR_CLOSE_COMPLETE:\n\tPKT_CLOSE -> CLOSE_WAIT_CLOSE (=>PKT_CLOSE_ACK)\n\tPKT_CLOSE_COMPLETE -> CLOSE_WAIT_CLOSE (=>PKT_CLOSE_ACK)\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE\n\tBITCOIN_CLOSE_DONE -> CLOSED\n\tINPUT_CLOSE_COMPLETE_TIMEOUT -> CLOSE_WAIT_CLOSE_OURCOMMIT (=>PKT_ERROR)\nWAIT_FOR_CLOSE_ACK:\n\tPKT_CLOSE_ACK -> CLOSE_WAIT_CLOSE\n\tPKT_ERROR -> CLOSE_WAIT_CLOSE\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_CLOSE:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE\n\tBITCOIN_CLOSE_DONE -> CLOSED\n\nWeird close states\n==================\nEg. steal transction, unilateral close, combinations thereof:\n \nCLOSE_WAIT_STEAL:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM\n\tBITCOIN_STEAL_DONE -> CLOSED\nCLOSE_WAIT_SPENDTHEM:\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDTHEM:\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\nCLOSE_WAIT_STEAL_CLOSE:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE\n\tBITCOIN_STEAL_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_SPENDTHEM_CLOSE:\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDTHEM_CLOSE:\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_SPENDOURS\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_OURCOMMIT\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_OURCOMMIT\nCLOSE_WAIT_STEAL_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_STEAL_SPENDOURS\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT\n\tBITCOIN_STEAL_DONE -> CLOSED\nCLOSE_WAIT_SPENDTHEM_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_SPENDTHEM_SPENDOURS\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\nCLOSE_WAIT_CLOSE_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_CLOSE_SPENDOURS\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE_OURCOMMIT\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_STEAL_CLOSE_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_STEAL_CLOSE_SPENDOURS\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT\n\tBITCOIN_STEAL_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT:\n\tBITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_SPENDOURS:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_SPENDOURS\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDOURS\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDOURS:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\nCLOSE_WAIT_SPENDTHEM_SPENDOURS:\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS:\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\nCLOSE_WAIT_CLOSE_SPENDOURS:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE_SPENDOURS\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_STEAL_CLOSE_SPENDOURS:\n\tBITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS:\n\tBITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED\nCLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS:\n\tBITCOIN_SPEND_THEIRS_DONE -> CLOSED\n\tBITCOIN_SPEND_OURS_DONE -> CLOSED\n\tBITCOIN_STEAL_DONE -> CLOSED\n\tBITCOIN_CLOSE_DONE -> CLOSED"
            },
            {
                "author": "Pierre",
                "date": "2015-08-28T16:55:31",
                "message_text_only": "Thanks, this helps a lot !\n\nI have more questions after reviewing your new branch 'state', if you have\ntime for that ;-)\n\n1) In PKT_UPDATE_ADD_HTLC, why is the field amount an int32 and not an\nuint32 ? the value shouldn't be negative right ?\n\n2) For a given payee, is the (simplified) htlc flow always :\n\nA->B PKT_UPDATE_ADD_HTLC\nB->A PKT_UPDATE_COMPLETE_HTLC\nA->B PKT_UPDATE_ADD_HTLC\nB->A PKT_UPDATE_COMPLETE_HTLC ?\n\ncan we have two successive PKT_UPDATE_ADD_HTLC with the same H, the latter\nupdating the former ? and then a single completion ?\n\n3) Since an htlc is completed with a PKT_UPDATE_COMPLETE_HTLC, what is the\nuse case of PKT_UPDATE ?\n\n4) Why is there no PKT_UPDATE_DECLINE ?\n\n5) I understand the High/Low priorities are a way of resolving conflicts,\nbut I don't get how it works. Could you please explain the principle of it ?\n\n6) In a closing by mutual consent, who is supposed to publish the final\ntransaction ?\n\n7) How do we manage the fees ?\n\nThanks,\n\nPierre\n\n\n2015-08-21 7:32 GMT+02:00 Rusty Russell <rusty at rustcorp.com.au>:\n\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n> > Yeah.  Let me generate a decent text flowchart for the normal cases...\n>\n> I've taken out some transitions for simplicity (eg. ERR_ANCHOR_LOST and\n> ERR_INFORMATION_LEAK, which shouldn't happen):\n>\n> Normal opening states:\n>\n> INIT_NOANCHOR:\n>         INPUT_NONE -> OPEN_WAIT_FOR_OPEN_NOANCHOR (=>PKT_OPEN)\n> INIT_WITHANCHOR:\n>         INPUT_NONE -> OPEN_WAIT_FOR_OPEN_WITHANCHOR (=>PKT_OPEN)\n> OPEN_WAIT_FOR_OPEN_NOANCHOR:\n>         PKT_OPEN -> OPEN_WAIT_FOR_ANCHOR\n>         CMD_CLOSE -> CLOSED\n> OPEN_WAIT_FOR_OPEN_WITHANCHOR:\n>         PKT_OPEN -> OPEN_WAIT_FOR_COMMIT_SIG (=>PKT_OPEN_ANCHOR)\n>         CMD_CLOSE -> CLOSED\n> OPEN_WAIT_FOR_ANCHOR:\n>         PKT_OPEN_ANCHOR -> OPEN_WAITING_THEIRANCHOR (=>PKT_OPEN_COMMIT_SIG)\n>         CMD_CLOSE -> CLOSED\n> OPEN_WAIT_FOR_COMMIT_SIG:\n>         PKT_OPEN_COMMIT_SIG -> OPEN_WAITING_OURANCHOR\n>         CMD_CLOSE -> CLOSED\n> OPEN_WAITING_OURANCHOR:\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         BITCOIN_ANCHOR_DEPTHOK -> OPEN_WAIT_FOR_COMPLETE_OURANCHOR\n> (=>PKT_OPEN_COMPLETE)\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         CMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n> OPEN_WAITING_THEIRANCHOR:\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_DEPTHOK -> OPEN_WAIT_FOR_COMPLETE_THEIRANCHOR\n> (=>PKT_OPEN_COMPLETE)\n>         BITCOIN_ANCHOR_TIMEOUT -> ERR_ANCHOR_TIMEOUT (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         CMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n>\n> OPEN_WAIT_FOR_COMPLETE_OURANCHOR:\n>         PKT_OPEN_COMPLETE -> NORMAL_HIGHPRIO\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         CMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n>\n> OPEN_WAIT_FOR_COMPLETE_THEIRANCHOR:\n>         PKT_OPEN_COMPLETE -> NORMAL_LOWPRIO\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         CMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n>\n> Operational state loop:\n> ======================\n> I've folded high and low here, but we alternate.\n>\n> NORMAL_LOWPRIO:\n> NORMAL_HIGHPRIO:\n>         PKT_UPDATE -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ADD_HTLC -> NORMAL_HIGHPRIO (=>PKT_UPDATE_DECLINE_HTLC)\n>         PKT_UPDATE_ADD_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_COMPLETE_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_TIMEDOUT_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ROUTEFAIL_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n>         CMD_SEND_UPDATE -> WAIT_FOR_UPDATE_ACCEPT_LOWPRIO (=>PKT_UPDATE)\n>         CMD_SEND_HTLC_UPDATE -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO\n> (=>PKT_UPDATE_ADD_HTLC)\n>         CMD_SEND_HTLC_COMPLETE -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO\n> (=>PKT_UPDATE_COMPLETE_HTLC)\n>         CMD_SEND_HTLC_TIMEDOUT -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO\n> (=>PKT_UPDATE_TIMEDOUT_HTLC)\n>         CMD_SEND_HTLC_ROUTEFAIL -> WAIT_FOR_HTLC_ACCEPT_LOWPRIO\n> (=>PKT_UPDATE_ROUTEFAIL_HTLC)\n>         CMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n>\n> WAIT_FOR_HTLC_ACCEPT_LOWPRIO:\n> WAIT_FOR_HTLC_ACCEPT_HIGHPRIO:\n>         PKT_UPDATE -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ADD_HTLC -> NORMAL_HIGHPRIO (=>PKT_UPDATE_DECLINE_HTLC)\n>         PKT_UPDATE_ADD_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ACCEPT -> WAIT_FOR_UPDATE_COMPLETE_LOWPRIO\n> (=>PKT_UPDATE_SIGNATURE)\n>         PKT_UPDATE_DECLINE_HTLC -> NORMAL_HIGHPRIO\n>         PKT_UPDATE_COMPLETE_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_TIMEDOUT_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ROUTEFAIL_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n> WAIT_FOR_HTLC_ACCEPT_HIGHPRIO:\n>         PKT_UPDATE_ACCEPT -> WAIT_FOR_UPDATE_COMPLETE_HIGHPRIO\n> (=>PKT_UPDATE_SIGNATURE)\n>         PKT_UPDATE_DECLINE_HTLC -> NORMAL_LOWPRIO\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n>\n> WAIT_FOR_UPDATE_ACCEPT_LOWPRIO:\n> WAIT_FOR_UPDATE_ACCEPT_HIGHPRIO:\n>         PKT_UPDATE -> WAIT_FOR_UPDATE_SIG_LOWPRIO (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ADD_HTLC -> NORMAL_HIGHPRIO (=>PKT_UPDATE_DECLINE_HTLC)\n>         PKT_UPDATE_ADD_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ACCEPT -> WAIT_FOR_UPDATE_COMPLETE_LOWPRIO\n> (=>PKT_UPDATE_SIGNATURE)\n>         PKT_UPDATE_COMPLETE_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_TIMEDOUT_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_UPDATE_ROUTEFAIL_HTLC -> WAIT_FOR_UPDATE_SIG_LOWPRIO\n> (=>PKT_UPDATE_ACCEPT)\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n>\n> WAIT_FOR_UPDATE_COMPLETE_LOWPRIO:\n> WAIT_FOR_UPDATE_COMPLETE_HIGHPRIO:\n>         PKT_UPDATE_COMPLETE -> NORMAL_HIGHPRIO\n>         PKT_CLOSE -> WAIT_FOR_CLOSE_ACK (=>PKT_CLOSE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n>\n> WAIT_FOR_UPDATE_SIG_LOWPRIO:\n>         PKT_UPDATE_SIGNATURE -> NORMAL_HIGHPRIO (=>PKT_UPDATE_COMPLETE)\n>         ...\n> WAIT_FOR_UPDATE_SIG_HIGHPRIO:\n>         PKT_UPDATE_SIGNATURE -> NORMAL_LOWPRIO (=>PKT_UPDATE_COMPLETE)\n>         PKT_ERROR -> CLOSE_WAIT_OURCOMMIT\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM (=>PKT_ERROR)\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL (=>PKT_ERROR)\n>         CMD_CLOSE -> WAIT_FOR_CLOSE_COMPLETE (=>PKT_CLOSE)\n>\n> Normal closing:\n> ==============\n>\n> WAIT_FOR_CLOSE_COMPLETE:\n>         PKT_CLOSE -> CLOSE_WAIT_CLOSE (=>PKT_CLOSE_ACK)\n>         PKT_CLOSE_COMPLETE -> CLOSE_WAIT_CLOSE (=>PKT_CLOSE_ACK)\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE\n>         BITCOIN_CLOSE_DONE -> CLOSED\n>         INPUT_CLOSE_COMPLETE_TIMEOUT -> CLOSE_WAIT_CLOSE_OURCOMMIT\n> (=>PKT_ERROR)\n> WAIT_FOR_CLOSE_ACK:\n>         PKT_CLOSE_ACK -> CLOSE_WAIT_CLOSE\n>         PKT_ERROR -> CLOSE_WAIT_CLOSE\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_CLOSE:\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE\n>         BITCOIN_CLOSE_DONE -> CLOSED\n>\n> Weird close states\n> ==================\n> Eg. steal transction, unilateral close, combinations thereof:\n>\n> CLOSE_WAIT_STEAL:\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM\n>         BITCOIN_STEAL_DONE -> CLOSED\n> CLOSE_WAIT_SPENDTHEM:\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDTHEM:\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_CLOSE:\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE\n>         BITCOIN_STEAL_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_SPENDTHEM_CLOSE:\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE:\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_SPENDOURS\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_OURCOMMIT\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_OURCOMMIT\n> CLOSE_WAIT_STEAL_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_STEAL_SPENDOURS\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT\n>         BITCOIN_STEAL_DONE -> CLOSED\n> CLOSE_WAIT_SPENDTHEM_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED ->\n> CLOSE_WAIT_SPENDTHEM_SPENDOURS\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDTHEM_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED ->\n> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n> CLOSE_WAIT_CLOSE_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED -> CLOSE_WAIT_CLOSE_SPENDOURS\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE_OURCOMMIT\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_CLOSE_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED ->\n> CLOSE_WAIT_STEAL_CLOSE_SPENDOURS\n>         BITCOIN_ANCHOR_THEIRSPEND ->\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT\n>         BITCOIN_STEAL_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_SPENDTHEM_CLOSE_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED ->\n> CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS\n>         BITCOIN_ANCHOR_OTHERSPEND ->\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_OURCOMMIT:\n>         BITCOIN_ANCHOR_OURCOMMIT_DELAYPASSED ->\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_SPENDOURS:\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_SPENDOURS\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDOURS\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDOURS:\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n> CLOSE_WAIT_SPENDTHEM_SPENDOURS:\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDTHEM_SPENDOURS:\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n> CLOSE_WAIT_CLOSE_SPENDOURS:\n>         BITCOIN_ANCHOR_THEIRSPEND -> CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS\n>         BITCOIN_ANCHOR_OTHERSPEND -> CLOSE_WAIT_STEAL_CLOSE_SPENDOURS\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_CLOSE_SPENDOURS:\n>         BITCOIN_ANCHOR_THEIRSPEND ->\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_SPENDTHEM_CLOSE_SPENDOURS:\n>         BITCOIN_ANCHOR_OTHERSPEND ->\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n> CLOSE_WAIT_STEAL_SPENDTHEM_CLOSE_SPENDOURS:\n>         BITCOIN_SPEND_THEIRS_DONE -> CLOSED\n>         BITCOIN_SPEND_OURS_DONE -> CLOSED\n>         BITCOIN_STEAL_DONE -> CLOSED\n>         BITCOIN_CLOSE_DONE -> CLOSED\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150828/6e9bd480/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-31T00:34:03",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Thanks, this helps a lot !\n>\n> I have more questions after reviewing your new branch 'state', if you have\n> time for that ;-)\n>\n> 1) In PKT_UPDATE_ADD_HTLC, why is the field amount an int32 and not an\n> uint32 ? the value shouldn't be negative right ?\n\nIndeed!  Thanks, fixed (see below for patch).\n\n> 2) For a given payee, is the (simplified) htlc flow always :\n>\n> A->B PKT_UPDATE_ADD_HTLC\n> B->A PKT_UPDATE_COMPLETE_HTLC\n> A->B PKT_UPDATE_ADD_HTLC\n> B->A PKT_UPDATE_COMPLETE_HTLC ?\n>\n> can we have two successive PKT_UPDATE_ADD_HTLC with the same H, the latter\n> updating the former ? and then a single completion ?\n\nThat's not quite right.\n\nAdding an HTLC goes like so:\n\nA: PKT_UPDATE_ADD_HTLC\nB: PKT_UPDATE_ACCEPT (or PKT_UPDATE_DECLINE_HTLC, in which case end)\nA: PKT_UPDATE_SIGNATURE\nB: PKT_UPDATE_COMPLETE\n\nThere are three ways to remove it.\n\nIt has timed out, so A wants to cancel it:\nA: PKT_UPDATE_TIMEDOUT_HTLC \n\nOR, B finally gets a failure upstream, so wants to cancel it:\nB: PKT_UPDATE_ROUTEFAIL_HTLC\n\nOR, B gets the R value, and wants to compleete it:\nB: PKT_UPDATE_COMPLETE_HTLC\n\nAll these cases lead to the\nPKT_UPDATE_ACCEPT/PKT_UPDATE_SIGNATURE/PKT_UPDATE_COMPLETE sequence.\n\nI will rename PKT_UPDATE_COMPLETE_HTLC to PKT_UPDATE_FULFILL_HTLC which\navoids overloading \"COMPLETE\".\n\n> 3) Since an htlc is completed with a PKT_UPDATE_COMPLETE_HTLC, what is the\n> use case of PKT_UPDATE ?\n\nPKT_UPDATE is a non-htlc transfer.  It was useful for writing test\nutilities, but I've actually now taken it out of the state machine since\nit's not useful in practice.\n\nSo all updates are now HTLC updates..\n\n> 4) Why is there no PKT_UPDATE_DECLINE ?\n\nSee above.\n\n> 5) I understand the High/Low priorities are a way of resolving conflicts,\n> but I don't get how it works. Could you please explain the principle of it ?\n\nSure.  The protocol can only do one update at a time.  In the case where\nwe both propose an update, we need to decide which goes first.\n\nThus, each peer alternates between high and low priority states.  If\nyou're high priority, your update takes precedence.  Arbitrarily, the\nanchor funder starts in high priority, the other one in low priority.\n\n> 6) In a closing by mutual consent, who is supposed to publish the final\n> transaction ?\n\nBoth sides should publish (they should be identical anyway, but it\ndoesn't matter).\n\n> 7) How do we manage the fees ?\n\nThat's mainly unresolved.  A node will decline if not enough fees are\noffered, but how those are advertised (and how routes are advertised) is\nstill TBA.\n\nWe'll probably implement fixed fees and terrible routing to begin with.\n\nCheers,\nRusty.\n\nSubject: protocol: HTLC amounts can't be negative.\n\nReported-by: Pierre <pm+lists at acinq.fr>\nSigned-off-by: Rusty Russell <rusty at rustcorp.com.au>\n\ndiff --git a/lightning.pb-c.c b/lightning.pb-c.c\nindex b601697..3108aa5 100644\n--- a/lightning.pb-c.c\n+++ b/lightning.pb-c.c\n@@ -1711,7 +1711,7 @@ static const ProtobufCFieldDescriptor update_add_htlc__field_descriptors[4] =\n     \"amount\",\n     2,\n     PROTOBUF_C_LABEL_REQUIRED,\n-    PROTOBUF_C_TYPE_INT32,\n+    PROTOBUF_C_TYPE_UINT32,\n     0,   /* quantifier_offset */\n     offsetof(UpdateAddHtlc, amount),\n     NULL,\ndiff --git a/lightning.pb-c.h b/lightning.pb-c.h\nindex 05b0a58..77a6c7b 100644\n--- a/lightning.pb-c.h\n+++ b/lightning.pb-c.h\n@@ -278,7 +278,7 @@ struct  _UpdateAddHtlc\n   /*\n    * Amount for htlc\n    */\n-  int32_t amount;\n+  uint32_t amount;\n   /*\n    * Hash for HTLC R value.\n    */\ndiff --git a/lightning.proto b/lightning.proto\nindex 4388c5c..86ca52e 100644\n--- a/lightning.proto\n+++ b/lightning.proto\n@@ -113,7 +113,7 @@ message update_add_htlc {\n   // Hash for which I will supply preimage to revoke this commitment tx.\n   required sha256_hash revocation_hash = 1;\n   // Amount for htlc\n-  required int32 amount = 2;\n+  required uint32 amount = 2;\n   // Hash for HTLC R value.\n   required sha256_hash r_hash = 3;\n   // Time at which HTLC expires (absolute)"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-29T07:42:39",
                "message_text_only": "On Fri, Aug 21, 2015 at 03:02:32PM +0930, Rusty Russell wrote:\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n> > Yeah.  Let me generate a decent text flowchart for the normal cases...\n> I've taken out some transitions for simplicity (eg. ERR_ANCHOR_LOST and\n> ERR_INFORMATION_LEAK, which shouldn't happen):\n\nSome thoughs, fwiw.\n\nI think the two INIT states is odd. I guess I would have expected\nsomething more like:\n  INIT:\n    - (cmd_open_my_anchor) -> INIT_WITHANCHOR\n    - (pkt_propose_channel) -> INIT_NOANCHOR\n\nI think the \"state\" orientation of the dot output isn't great. ie rather\nthan laying it out like how it is in the code with a state then all the\ntransitions from that state:\n\n  NORMAL:\n    - UPDATE_HTLC -> X\n    - UPDATE_PKT -> Y\n    - COMPLETE_HTLC -> Z\n\nI'd rather see it laid out as the protocol steps:\n  UPDATE_HTLC\n    NORMAL -[UPDATE_HTLC]-> X -[ACCEPT]-> X2 ->...\n\n  UPDATE_PKT\n    NORMAL -[UPDATE_PKT]-> Y ->...\n\nie, have multiple graphs, each starting at INIT/NORMAL with a single\ncmd/pkt and ending at NORMAL'/CLOSED/ERROR. I'd probably prefer\nincluding the decision points as nodes too.\n\nA lot of the \"an error occurred!\" abort paths apply to a whole bunch of\nstates, it would be nice to combine them in the output... Hmm, I think\nthat's doable...\n\nI've had a go at doing this with code. C is hard, so I converted to\npython, and came up with:\n\n  http://azure.erisian.com.au/~aj/tmp/lightstate/statepy.svg\n\n(source bits in the lightstate/ directory)\n\nI was thinking it would be possible to update many HTLCs at once, so\nI was expecting a single PKT_UPDATE_CHANNEL rather than the ADD_HTLC,\nCOMPLETE_HTLC, TIMEOUT_HTLC, etc variants. From a protocol POV, I guess\nthat's something like:\n\n  UpdateChannel:\n     int  n_ops\n     op   ops[]\n     int  commitment_len;\n     byte commitment[]\n\nwhere an op would be ADD_HTLC, COMPLETE_HTLC, TIMEOUT_HTLC,\nROUTEFAIL_HTLC, etc. That's a bit more complicated in the protocol,\nbut I think it pays off in simplifying the state diagram and hence the\nsoftware? (I think it's also kindof necessary for some fee models, and\nwill be useful for batching updates when performance eventually matters)\n\nThat would look something like:\n\n  http://azure.erisian.com.au/~aj/tmp/lightstate/update.svg\n\nI think...\n\nIf you're going to have separate PKT_UPDATE_COMPLETE_HTLC, etc; then\nit might make sense to have some of them go to WAIT_FOR_UPDATE_ACCEPT\ninstead of WAIT_FOR_HTLC_ACCEPT so that declining is forbidden -- if you\nreveal R, or claim a timeout has been reached, then your counterparty\ndoesn't have the right to decline the update, and if they try, you want\nto close the channel anyway afaics.\n\nHmm, I find the PRIO stuff pretty klunky. It's only used to choose who\nwins in the event of simultaneous/overlapping channel updates, no? Why\nnot just have a constant tiebreak in that case, eg, where whoever has the\nlowest channel balance (or the lowest IP / key id), wins?\n\n  NORMAL\n    >pkt_update\n\n  WAIT_FOR_HTLC_ACCEPT\n    <pkt_update_accept\n    >pkt_update_signature -> WAIT_FOR_UPDATE_COMPLETE\n\n    <pkt_update_decline -> NORMAL\n\n    <pkt_update + <dec_win_tie\n    -> WAIT_FOR_HTLC_ACCEPT\n\n    <pkt_update + <dec_lose_tie + <dec_accept_update\n    >pkt_update_accept -> WAIT_FOR_UPDATE_SIG\n\n    <pkt_update + <dec_lose_tie + <dec_decline_update\n    >pkt_update_decline -> NORMAL\n\nOr alternatively, just have the high priority be given to whoever last\nwent from WAIT_FOR_UPDATE_SIG -> NORMAL (and low priority to whoever\nwent from WAIT_FOR_UPDATE_COMPLETE -> NORMAL). That way the priority\nwould still swap, and you could keep the priority embedded in the state,\nbut it would only be needed for NORMAL and WAIT_FOR_*_ACCEPT states;\nand not the UPDATE_COMPLETE and UPDATE_SIG states as well.\n\nAFAICS, you still have a potential deadlock atm if you think you're\nhigh priority but your counterparty also thinks they're high priority,\nor just missed your update packet. I think there might be a similar\ndeadlock if both systems think they're low priority. There should be a\n\"timeout waiting for message -> retry/close channel\", for most of the\nnon-NORMAL states shouldn't there?\n\nIf the INIT_NOANCHOR is meant to do to single-sided-anchor idea proposed\nin\n\n  https://bitcointalk.org/index.php?topic=1134319.msg11963141\n\nthen it would probably be good to have a PKT_REBALANCE_VIA_BLOCKCHAIN\noption; ie something like:\n\n 0. channel is unbalanced: A has many funds, B has no funds\n 1. B proposes rebalancing by $x.\n 2. A accepts, chooses R, reveals #(R).\n 3. B proposes HTLC from A to B of x funds, conditional on R.\n 4. B posts $x in funds on the blockchain, payable to:\n      [SIG_B & R | SIG_A & TIMEOUT]\n 5. B tells A the transaction id (and p2sh details etc).\n 6. A waits for this to be \"deep enough\"\n 7. A claims the blockchain transaction, revealing R.\n 8. B completes the HTLC, rebalancing the channel.\n\nI think that would look like:\n\nA:\n  NORMAL\n    <pkt_rebalance (x)\n    >pkt_update_channel (add htlc: A->B, x, R, T)\n\n    (or pkt_rebalance_decline -> NORMAL)\n\n  REBAL_WAIT_FOR_HTLC_ACCEPT (R,x)\n    <pkt_update_accept\n    >pkt_update_signature\n\n  REBAL_WAIT_FOR_UPDATE_COMPLETE (R,x)\n    <pkt_update_complete\n    >pkt_rebal_ok (#R,x)\n\n  NORMAL+REBAL_2 (R,x)\n    <pkt_rebal_underway (txn)\n\n  NORMAL+REBAL_3 (R,x,txn)\n    <bitcoin_depthok (txn)\n    >bitcoin_spend (txn,R,SIG_A -> ...)\n\n  NORMAL\n\nB:\n  NORMAL\n    <cmd_rebalance (x)\n    >pkt_rebalance (x)\n\n  NORMAL+REBAL_A (x)\n    <pkt_rebal_ok (#R,x)\n    >bitcoin_spend (... -> R+SIG_A|TIME+SIG_B)\n    >pkt_rebal_underway (txn)\n\n    (or <pkt_rebal_decline -> NORMAL)\n\n  NORMAL+REBAL_B (#R,x,txn)\n    <bitcoin_spent (txn)\n    <pkt_update_channel\n\n  NORMAL\n\nNot being able to tack on orthogonal state makes things a little clumsy\nhere...\n\nCheers,\naj"
            },
            {
                "author": "Pierre",
                "date": "2015-08-29T12:50:44",
                "message_text_only": "Hi Anthony,\n\nYour svg looks great, thanks for sharing !\n\nRegarding the init phase, you seem to be making the assumption that whoever\ninitiates a channel will be the one funding it. But that's not necessarily\nthe case if the requester is a merchant who will only receive payments\nright ?\n\nOf course we can make this initial funding as low as we want, then have the\nlightning node fund the channel...\n\nCheers\n\nPierre\n\n2015-08-29 9:42 GMT+02:00 Anthony Towns <aj at erisian.com.au>:\n\n> On Fri, Aug 21, 2015 at 03:02:32PM +0930, Rusty Russell wrote:\n> > Rusty Russell <rusty at rustcorp.com.au> writes:\n> > > Yeah.  Let me generate a decent text flowchart for the normal cases...\n> > I've taken out some transitions for simplicity (eg. ERR_ANCHOR_LOST and\n> > ERR_INFORMATION_LEAK, which shouldn't happen):\n>\n> Some thoughs, fwiw.\n>\n> I think the two INIT states is odd. I guess I would have expected\n> something more like:\n>   INIT:\n>     - (cmd_open_my_anchor) -> INIT_WITHANCHOR\n>     - (pkt_propose_channel) -> INIT_NOANCHOR\n>\n> I think the \"state\" orientation of the dot output isn't great. ie rather\n> than laying it out like how it is in the code with a state then all the\n> transitions from that state:\n>\n>   NORMAL:\n>     - UPDATE_HTLC -> X\n>     - UPDATE_PKT -> Y\n>     - COMPLETE_HTLC -> Z\n>\n> I'd rather see it laid out as the protocol steps:\n>   UPDATE_HTLC\n>     NORMAL -[UPDATE_HTLC]-> X -[ACCEPT]-> X2 ->...\n>\n>   UPDATE_PKT\n>     NORMAL -[UPDATE_PKT]-> Y ->...\n>\n> ie, have multiple graphs, each starting at INIT/NORMAL with a single\n> cmd/pkt and ending at NORMAL'/CLOSED/ERROR. I'd probably prefer\n> including the decision points as nodes too.\n>\n> A lot of the \"an error occurred!\" abort paths apply to a whole bunch of\n> states, it would be nice to combine them in the output... Hmm, I think\n> that's doable...\n>\n> I've had a go at doing this with code. C is hard, so I converted to\n> python, and came up with:\n>\n>   http://azure.erisian.com.au/~aj/tmp/lightstate/statepy.svg\n>\n> (source bits in the lightstate/ directory)\n>\n> I was thinking it would be possible to update many HTLCs at once, so\n> I was expecting a single PKT_UPDATE_CHANNEL rather than the ADD_HTLC,\n> COMPLETE_HTLC, TIMEOUT_HTLC, etc variants. From a protocol POV, I guess\n> that's something like:\n>\n>   UpdateChannel:\n>      int  n_ops\n>      op   ops[]\n>      int  commitment_len;\n>      byte commitment[]\n>\n> where an op would be ADD_HTLC, COMPLETE_HTLC, TIMEOUT_HTLC,\n> ROUTEFAIL_HTLC, etc. That's a bit more complicated in the protocol,\n> but I think it pays off in simplifying the state diagram and hence the\n> software? (I think it's also kindof necessary for some fee models, and\n> will be useful for batching updates when performance eventually matters)\n>\n> That would look something like:\n>\n>   http://azure.erisian.com.au/~aj/tmp/lightstate/update.svg\n>\n> I think...\n>\n> If you're going to have separate PKT_UPDATE_COMPLETE_HTLC, etc; then\n> it might make sense to have some of them go to WAIT_FOR_UPDATE_ACCEPT\n> instead of WAIT_FOR_HTLC_ACCEPT so that declining is forbidden -- if you\n> reveal R, or claim a timeout has been reached, then your counterparty\n> doesn't have the right to decline the update, and if they try, you want\n> to close the channel anyway afaics.\n>\n> Hmm, I find the PRIO stuff pretty klunky. It's only used to choose who\n> wins in the event of simultaneous/overlapping channel updates, no? Why\n> not just have a constant tiebreak in that case, eg, where whoever has the\n> lowest channel balance (or the lowest IP / key id), wins?\n>\n>   NORMAL\n>     >pkt_update\n>\n>   WAIT_FOR_HTLC_ACCEPT\n>     <pkt_update_accept\n>     >pkt_update_signature -> WAIT_FOR_UPDATE_COMPLETE\n>\n>     <pkt_update_decline -> NORMAL\n>\n>     <pkt_update + <dec_win_tie\n>     -> WAIT_FOR_HTLC_ACCEPT\n>\n>     <pkt_update + <dec_lose_tie + <dec_accept_update\n>     >pkt_update_accept -> WAIT_FOR_UPDATE_SIG\n>\n>     <pkt_update + <dec_lose_tie + <dec_decline_update\n>     >pkt_update_decline -> NORMAL\n>\n> Or alternatively, just have the high priority be given to whoever last\n> went from WAIT_FOR_UPDATE_SIG -> NORMAL (and low priority to whoever\n> went from WAIT_FOR_UPDATE_COMPLETE -> NORMAL). That way the priority\n> would still swap, and you could keep the priority embedded in the state,\n> but it would only be needed for NORMAL and WAIT_FOR_*_ACCEPT states;\n> and not the UPDATE_COMPLETE and UPDATE_SIG states as well.\n>\n> AFAICS, you still have a potential deadlock atm if you think you're\n> high priority but your counterparty also thinks they're high priority,\n> or just missed your update packet. I think there might be a similar\n> deadlock if both systems think they're low priority. There should be a\n> \"timeout waiting for message -> retry/close channel\", for most of the\n> non-NORMAL states shouldn't there?\n>\n> If the INIT_NOANCHOR is meant to do to single-sided-anchor idea proposed\n> in\n>\n>   https://bitcointalk.org/index.php?topic=1134319.msg11963141\n>\n> then it would probably be good to have a PKT_REBALANCE_VIA_BLOCKCHAIN\n> option; ie something like:\n>\n>  0. channel is unbalanced: A has many funds, B has no funds\n>  1. B proposes rebalancing by $x.\n>  2. A accepts, chooses R, reveals #(R).\n>  3. B proposes HTLC from A to B of x funds, conditional on R.\n>  4. B posts $x in funds on the blockchain, payable to:\n>       [SIG_B & R | SIG_A & TIMEOUT]\n>  5. B tells A the transaction id (and p2sh details etc).\n>  6. A waits for this to be \"deep enough\"\n>  7. A claims the blockchain transaction, revealing R.\n>  8. B completes the HTLC, rebalancing the channel.\n>\n> I think that would look like:\n>\n> A:\n>   NORMAL\n>     <pkt_rebalance (x)\n>     >pkt_update_channel (add htlc: A->B, x, R, T)\n>\n>     (or pkt_rebalance_decline -> NORMAL)\n>\n>   REBAL_WAIT_FOR_HTLC_ACCEPT (R,x)\n>     <pkt_update_accept\n>     >pkt_update_signature\n>\n>   REBAL_WAIT_FOR_UPDATE_COMPLETE (R,x)\n>     <pkt_update_complete\n>     >pkt_rebal_ok (#R,x)\n>\n>   NORMAL+REBAL_2 (R,x)\n>     <pkt_rebal_underway (txn)\n>\n>   NORMAL+REBAL_3 (R,x,txn)\n>     <bitcoin_depthok (txn)\n>     >bitcoin_spend (txn,R,SIG_A -> ...)\n>\n>   NORMAL\n>\n> B:\n>   NORMAL\n>     <cmd_rebalance (x)\n>     >pkt_rebalance (x)\n>\n>   NORMAL+REBAL_A (x)\n>     <pkt_rebal_ok (#R,x)\n>     >bitcoin_spend (... -> R+SIG_A|TIME+SIG_B)\n>     >pkt_rebal_underway (txn)\n>\n>     (or <pkt_rebal_decline -> NORMAL)\n>\n>   NORMAL+REBAL_B (#R,x,txn)\n>     <bitcoin_spent (txn)\n>     <pkt_update_channel\n>\n>   NORMAL\n>\n> Not being able to tack on orthogonal state makes things a little clumsy\n> here...\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150829/9f7f273a/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-30T00:51:54",
                "message_text_only": "On 29 August 2015 at 22:50, Pierre <pm+lists at acinq.fr> wrote:\n\n> Hi Anthony,\n> Your svg looks great, thanks for sharing !\n>\n\n\u200bYeah, I like it :)\n\n\n> Regarding the init phase, you seem to be making the assumption that\n> whoever initiates a channel will be the one funding it. But that's not\n> necessarily the case if the requester is a merchant who will only receive\n> payments right ?\n>\n\nYeah, kind-of. I figure that whoever is providing the anchor will want to\nmake a decision beforehand (rather than just have software do that\nautomatically when a particular packet comes in), and they'll indicate they\nwant to proceed by issuing a \"cmd_init_with_my_anchor\". Maybe there's some\nnegotiation before that (someone registers on your website, or whatever\neg), but I figure that's out-of-band.\n\nIf you're a merchant, I think it would either be:\n\n a) register with paypal, paypal anchors the channel\n b) merchant anchors the channel with random hub, merchant has all the\nfunds, suggests rebalancing via the blockchain with the hub, rebalancing\nprotocol happens\n c) merchant anchors the channel, merchant does a HTLC to:\n     - their account on an exchange\n     - their \"cold wallet\" lightning channel\n     - something else\n    moving all the funds to the other side of their channel\n\nand voila, they can receive funds.\n\nOf course we can make this initial funding as low as we want, then have the\n> lightning node fund the channel...\n>\n\n\u200bYou can't increase the capacity of a channel easily -- you need a new\nanchor transaction for that...\u200b\n\n\u200bCheers,\naj\u200b\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150830/8d5ea290/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-31T01:04:21",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Aug 21, 2015 at 03:02:32PM +0930, Rusty Russell wrote:\n>> Rusty Russell <rusty at rustcorp.com.au> writes:\n>> > Yeah.  Let me generate a decent text flowchart for the normal cases...\n>> I've taken out some transitions for simplicity (eg. ERR_ANCHOR_LOST and\n>> ERR_INFORMATION_LEAK, which shouldn't happen):\n>\n> Some thoughs, fwiw.\n>\n> I think the two INIT states is odd. I guess I would have expected\n> something more like:\n>   INIT:\n>     - (cmd_open_my_anchor) -> INIT_WITHANCHOR\n>     - (pkt_propose_channel) -> INIT_NOANCHOR\n>\n> I think the \"state\" orientation of the dot output isn't great. ie rather\n> than laying it out like how it is in the code with a state then all the\n> transitions from that state:\n>\n>   NORMAL:\n>     - UPDATE_HTLC -> X\n>     - UPDATE_PKT -> Y\n>     - COMPLETE_HTLC -> Z\n>\n> I'd rather see it laid out as the protocol steps:\n>   UPDATE_HTLC\n>     NORMAL -[UPDATE_HTLC]-> X -[ACCEPT]-> X2 ->...\n>\n>   UPDATE_PKT\n>     NORMAL -[UPDATE_PKT]-> Y ->...\n>\n> ie, have multiple graphs, each starting at INIT/NORMAL with a single\n> cmd/pkt and ending at NORMAL'/CLOSED/ERROR. I'd probably prefer\n> including the decision points as nodes too.\n\nYeah, I plan on eventually creating an RFC-style document which lays\nthis out.\n\nAt its core, it's fairly simple, and I'm starting to think that diagrams\nmore than a simple ASCII flowchart don't add anything.\n\n> A lot of the \"an error occurred!\" abort paths apply to a whole bunch of\n> states, it would be nice to combine them in the output... Hmm, I think\n> that's doable...\n>\n> I've had a go at doing this with code. C is hard, so I converted to\n> python, and came up with:\n>\n>   http://azure.erisian.com.au/~aj/tmp/lightstate/statepy.svg\n>\n> (source bits in the lightstate/ directory)\n> \n> \n> I was thinking it would be possible to update many HTLCs at once, so\n> I was expecting a single PKT_UPDATE_CHANNEL rather than the ADD_HTLC,\n> COMPLETE_HTLC, TIMEOUT_HTLC, etc variants. From a protocol POV, I guess\n> that's something like:\n>\n>   UpdateChannel:\n>      int  n_ops\n>      op   ops[]\n>      int  commitment_len;\n>      byte commitment[]\n>\n> where an op would be ADD_HTLC, COMPLETE_HTLC, TIMEOUT_HTLC,\n> ROUTEFAIL_HTLC, etc. That's a bit more complicated in the protocol,\n> but I think it pays off in simplifying the state diagram and hence the\n> software? (I think it's also kindof necessary for some fee models, and\n> will be useful for batching updates when performance eventually\n> matters)\n\nThis is the kind of optimization we may see later, but I really shy away\nfrom doing it now.  Your diagram looks simpler because you removed all\nthe rest of the handshaking.  Try this:\n\nA: ADD_HTLC --> B: DECLINE_HTLC\n  OR\nA: ADD_HTLC --> B: ACCEPT --> A: SIGNATURE --> B: COMPLETE\n\nAfter success:\n\nB: FULFILL_HTLC -> A: ACCEPT --> B: SIGNATURE --> A: COMPLETE\n  OR\nB: ROUTEFAIL_HTLC -> A: ACCEPT --> B: SIGNATURE --> A: COMPLETE\n  OR\nA: TIMEDOUT_HTLC -> B: ACCEPT --> A: SIGNATURE --> B: COMPLETE\n\nThis makes the constraints clearer, eg. you can't DECLINE_HTLC anything\nbut an ADD_HTLC.\n\n> Hmm, I find the PRIO stuff pretty klunky. It's only used to choose who\n> wins in the event of simultaneous/overlapping channel updates, no? Why\n> not just have a constant tiebreak in that case, eg, where whoever has the\n> lowest channel balance (or the lowest IP / key id), wins?\n\nThat could lead to livelock.\n\n> Or alternatively, just have the high priority be given to whoever last\n> went from WAIT_FOR_UPDATE_SIG -> NORMAL (and low priority to whoever\n> went from WAIT_FOR_UPDATE_COMPLETE -> NORMAL). That way the priority\n> would still swap\n\nWell, that would alternate at least.  But that seems more complex than\nbasing priority on the lower bit of the commitment number, which we have\nto remember anyway.\n\n> AFAICS, you still have a potential deadlock atm if you think you're\n> high priority but your counterparty also thinks they're high priority,\n> or just missed your update packet. I think there might be a similar\n> deadlock if both systems think they're low priority.\n\nThey can't get into that state.  And that's why it's spelled out in the\nstate machine, so I can exhaustively test (and have).\n\n> If the INIT_NOANCHOR is meant to do to single-sided-anchor idea proposed\n> in\n>\n>   https://bitcointalk.org/index.php?topic=1134319.msg11963141\n>\n> then it would probably be good to have a PKT_REBALANCE_VIA_BLOCKCHAIN\n> option; ie something like:\n>\n>  0. channel is unbalanced: A has many funds, B has no funds\n>  1. B proposes rebalancing by $x.\n>  2. A accepts, chooses R, reveals #(R).\n>  3. B proposes HTLC from A to B of x funds, conditional on R.\n>  4. B posts $x in funds on the blockchain, payable to:\n>       [SIG_B & R | SIG_A & TIMEOUT]\n>  5. B tells A the transaction id (and p2sh details etc).\n>  6. A waits for this to be \"deep enough\"\n>  7. A claims the blockchain transaction, revealing R.\n>  8. B completes the HTLC, rebalancing the channel.\n\nWe want A to be able to increase the channel too, so this doesn't quite\nwork.  I think we need to explicitly add a new anchor for that case.\n\nBut this idea is a subset of a more general \"swap to X\" HTLC, which\ncomes down to a routing problem, which is a layer up from this state\nmachine.\n\n> Not being able to tack on orthogonal state makes things a little clumsy\n> here...\n\nThe state machine is hard to work with, but the payoff is exhaustive\nproof that it's sane, and handles all possible cases.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-08-31T02:24:26",
                "message_text_only": "On 31 August 2015 at 11:04, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> > I was thinking it would be possible to update many HTLCs at once, so\n> > I was expecting a single PKT_UPDATE_CHANNEL rather than the ADD_HTLC,\n> > COMPLETE_HTLC, TIMEOUT_HTLC, etc variants. From a protocol POV, I guess\n> > that's something like:\n> This is the kind of optimization we may see later, but I really shy away\n> from doing it now.  Your diagram looks simpler because you removed all\n> the rest of the handshaking.  Try this:\n>\n\n\u200bI think the statepy.svg includes all the handshaking (including errors,\nbut I think excluding internal errors) apart from the nop state\ntransitions. Having a single PKT_UPDATE_CHANNEL would just combine those\ninto one subgraph / one edge.\n\nI'm a bit surprised that CMD_CLOSE isn't a valid option when proposing an\nupdate -- it's valid during WAIT_FOR_UPDATE_SIG but not\nWAIT_FOR_HTLC_ACCEPT/WAIT_FOR_UPDATE_COMPLETE. (Correspondingly, PKT_CLOSE\ndoesn't seem valid during WAIT_FOR_UPDATE_SIG)\n\nA: ADD_HTLC --> B: DECLINE_HTLC\n>   OR\n> A: ADD_HTLC --> B: ACCEPT --> A: SIGNATURE --> B: COMPLETE\n>\n> After success:\n>\n> B: FULFILL_HTLC -> A: ACCEPT --> B: SIGNATURE --> A: COMPLETE\n>   OR\n> B: ROUTEFAIL_HTLC -> A: ACCEPT --> B: SIGNATURE --> A: COMPLETE\n>   OR\n> A: TIMEDOUT_HTLC -> B: ACCEPT --> A: SIGNATURE --> B: COMPLETE\n>\n> This makes the constraints clearer, eg. you can't DECLINE_HTLC anything\n> but an ADD_HTLC.\n>\n\n\u200bYour states currently allow declining those though:\n\n        case STATE_NORMAL_LOWPRIO:\n        case STATE_NORMAL_HIGHPRIO:\n                } else if (input_is(input, CMD_SEND_HTLC_COMPLETE)) {\n                        /* We are to send an HTLC complete. */\n                        set_effect(effect, send,\n                                   pkt_htlc_complete(effect, sdata,\nidata->cmd));\n                        return prio(state, STATE_WAIT_FOR_HTLC_ACCEPT);\n\n        case STATE_WAIT_FOR_HTLC_ACCEPT_LOWPRIO:\n        case STATE_WAIT_FOR_HTLC_ACCEPT_HIGHPRIO:\n                /* HTLCs can also evoke a refusal. */\n                if (input_is(input, PKT_UPDATE_DECLINE_HTLC)) {\n                        fail_cmd(effect, CMD_SEND_HTLC_UPDATE, idata->pkt);\n                        /* Toggle between high and low priority states. */\n                        return toggle_prio(state, STATE_NORMAL);\n                }\n\nIf your counterparty proposes a broken HTLC update, I'm not sure there's\nharm in being allowed to decline it? They can choose to close the channel\nif they think you're unreasonable, retry the update if they found a\nmistake, or just forget it and not worry (if they were issuing a ROUTEFAIL,\nit's not /their/ funds that are on the line eg).\n\nI also wonder if\n\n  A: TIMEDOUT_HTLC -> B: DECLINE (err_time_sync_lost)\n\nmight be useful.\n\n> AFAICS, you still have a potential deadlock atm if you think you're\n> > high priority but your counterparty also thinks they're high priority,\n> > or just missed your update packet. I think there might be a similar\n> > deadlock if both systems think they're low priority.\n> They can't get into that state.\n\n\n\u200bSorry, I was assuming that one or both implementations were buggy. I meant\nto make that explicit.\u200b You're talking with strangers on the network, so\nyou can't assume their software is bug free, right?\n\nBTW, your states currently switch priority even when an update is declined,\nso the low bit of the current commitment id (which obviously isn't changed\non a declined update) doesn't actually give you the priority afaics.\n\nCheers,\naj\n\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150831/b67b1611/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-21T01:27:22",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hello all,\n>\n> First, bravo for the great work on lightning ! @Rusty I'm the guy who\n> recently made two dummy PR on your github project, thanks for merging them\n> ;-)\n>\n> I've just got one remark : from OPEN_WAITING state, you seem to be assuming\n> that the event BITCOIN_ANCHOR_DEPTHOK will always happen before receiving\n> the other party's PKT_OPEN_COMPLETE ; but that won't necessarily be the\n> case depending on each party's minDepth, right ?\n\nIt actually ignores (\"defers\") that packet until after the transition;\nI suppressed the loops in the simplified diagram, but the code is:\n\n\tcase STATE_OPEN_WAITING_OURANCHOR:\n\t\tif (input_is(input, BITCOIN_ANCHOR_DEPTHOK)) {\n\t\t\tset_effect(effect, send,\n\t\t\t\t   pkt_open_complete(effect, sdata));\n\t\t\treturn STATE_OPEN_WAIT_FOR_COMPLETE_OURANCHOR;\n\t\t} else if (input_is(input, BITCOIN_ANCHOR_UNSPENT)) {\n\t\t\tgoto anchor_unspent;\n\t\t} else if (input_is(input, PKT_OPEN_COMPLETE)) {\n\t\t\t/* Ignore until we've hit depth ourselves. */\n\t\t\tset_effect(effect, defer, input);\n\t\t\treturn state;\n                ...\n\n> Also, can you please confirm that the following is correct in an\n> Alice->Bob->Carol->Dave scenario if we look at the state of *Bob* ?\n\nBob has two states here; the states are per connection.\n\nSo there's Bob->Alice and Bob->Carol.\n\n> 1) Bob is in NORMAL state\n> - Bob receives update_add_htlc from Alice\n> - Bob sends update_accept to Alice\n>\n> 2) Bob switches to WAIT_FOR_UPDATE_SIG state\n> - Bob receives update_signature from Alice\n>\n> - (Bob sends update_add_htlc to Carol on another channel)\n> - (Bob receives update_complete_htlc on another channel)\n>\n> 3) Bob switches to NORMAL state\n\nSo far so good.  Now the HTLC is established, so I don't understand\nthese transitions:\n\n> - Bob sends update_accept to Alice\n>\n> 4) Bob switches to WAIT_FOR_UPDATE_SIG state\n> - Bob receives update_signature from Alice\n>\n> 5) Bob switches to NORMAL state\n\nCheers,\nRuysty."
            }
        ],
        "thread_summary": {
            "title": "A state machine.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Pierre"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 84352
        }
    },
    {
        "title": "[Lightning-dev] Negotiating & Committing Signatures",
        "thread_messages": [
            {
                "author": "Jeremy Rubin",
                "date": "2015-08-28T22:36:25",
                "message_text_only": "Negotiating & Committing Signatures\n============================\n\nIn this proposal, I suggest the addition of new types of signature schemes\nto Bitcoin, and running lightning over multi signature of the\nvariants to utilize the advantages of multiple signature schemes without\nthe drawbacks.\n\n\nSecure Construction of Signature Variants\n================================\n\nSuppose you have a signature scheme A and a signature scheme B.\n\nAssume we can categorize A as a \"better to commit to\" scheme (ie, it is\neasier to put on the blockchain) and B as a \"better to negotiate with\"\nscheme (ie, it is easier to renegotiate with). Assume these advantages and\ndisadvantages are somewhat disjoint, and we would like to leverage both.\n\nTherefore, we can operate lightning where each parties key is a 1 of 2\nmerkelized multisig (or H(H(PK_A)+H(PK_B)) ).\n\nNow, in this scheme, only either a signature with A or B would be needed\nfor the payment to be valid, and the space hit for the merkle proof is\nmarginal.\n\nWhat this enables a user to do is to use signature scheme B for the main\nset of negotiations, and when it is time to settle, request switching to A.\nIf the settlement is in the case where parties disagree and are not\ncooperating, the version signed with scheme B would still allow for\nsettlement. However, assuming this case is infrequent, B should rarely be\nneeded.\n\n\nSignature Schemes\n=================\n\nECDSA is the only signature scheme available in Bitcoin currently. However,\nthere exist a multitude of signature schemes with many unique properties.\n\nSecureRF (Derek Atkins, CTO is cc'd) has developed a novel signature\nalgorithm based on the Braid Group (it's a new paper -- not purely based on\nthe conjugacy problem) which promises to be significantly more efficient to\nverify. (I do not have the know-how to audit their claims and cryptosystem,\nso assuming it is correct my analysis follows...). The size of their\nkeys/signature is approximately an order of magnitude larger, but their\nverfication time is approximately 200x faster. Thus, were one to use this\nsignature scheme as \"B\", it would have the property of being better to\nnegotiate with but worse to settle on as it would contribute to blockchain\nbloat.\n\n\nThere may be other such schemes B that would be interesting to explore, but\nI have limited knowledge here.\n\n\nMotivation\n========\n\nSo why put effort into making the negotiation phase easier?\n\nBy lowering the requirements to verify a payment, embedded systems could be\nmade less expensive that can verify a lightning network payment. This\ncapability would mean that it would be easier to have a large collection of\ndevices which can receive and verify micropayments easily, eg, anywhere you\nmight have a coin slot.\n\nIt's unclear if this would provide great value over having the devices\noutsource verification, but is worth discussion as their may be other\nbenefits derived from a negotiation v.s. committing key.\n\nDrawbacks\n========\nSuch a scheme requires that new signature algorithms be added to Bitcoin;\nthis may be difficult to get implemented. However, if the benefits of\nhaving distinct negotiating v.s. committing keys has a tangible effect on\nthe usability & scalability of layer 2 systems such as lightning it may be\na worthwhile pursuit.\n\n\n\nHappy to hear your thoughts on the usefulness of such a scheme, and if it\nhas applications outside of lightning.\n\nCheers,\n\nJeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150828/d00b7587/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-08-31T02:54:55",
                "message_text_only": "Jeremy Rubin <jr at mit.edu> writes:\n> Negotiating & Committing Signatures\n> ============================\n>\n> In this proposal, I suggest the addition of new types of signature schemes\n> to Bitcoin, and running lightning over multi signature of the\n> variants to utilize the advantages of multiple signature schemes without\n> the drawbacks.\n\nHi Jeremy,\n\n        Such a hybrid would certainly be possible (though getting novel\ncrypto into bitcoin is a large task).\n\nYou refer to an \"order or magnitude\" increase in pubkey and signature\nsizes, but signatures of even 64k wouldn't make much logistical\ndifference to the LN.  Giant pubkeys might be a logistical issue, though\nusing the bitcoin trick of referring to them via their RIPEMD160 should\nwork there, too.\n\nCheers,\nRusty."
            },
            {
                "author": "Derek Atkins",
                "date": "2015-08-31T13:20:34",
                "message_text_only": "Hi Rusty,\n\nOn Mon, 2015-08-31 at 12:24 +0930, Rusty Russell wrote:\n> Jeremy Rubin <jr at mit.edu> writes:\n> > Negotiating & Committing Signatures\n> > ============================\n> >\n> > In this proposal, I suggest the addition of new types of signature schemes\n> > to Bitcoin, and running lightning over multi signature of the\n> > variants to utilize the advantages of multiple signature schemes without\n> > the drawbacks.\n> \n> Hi Jeremy,\n> \n>         Such a hybrid would certainly be possible (though getting novel\n> crypto into bitcoin is a large task).\n> \n> You refer to an \"order or magnitude\" increase in pubkey and signature\n> sizes, but signatures of even 64k wouldn't make much logistical\n> difference to the LN.  \n\nThe AEDSA signatures are around 6000 bits, give or take.  Due to the way\nthe algorithm works the signatures are not constant length (they have a\nlength distribution).  As a result we tend to talk about \"average\nlength\" of signatures.\n\n> Giant pubkeys might be a logistical issue, though\n> using the bitcoin trick of referring to them via their RIPEMD160 should\n> work there, too.\n\nThe AEDSA public keys are 344 bits long and are constant length.  I'm\nnot sure if it's worth the time to perform a RIPEMD160 over 344 bits to\nsave 50%?  But only you could answer that.\n\nYet even with these sizes we're seeing a tremendous verification\nperformance increase over ECDSA (on the order of 100-300x improvement)\nwith a smaller code footprint and reduced RAM usage, even on tiny, 8-bit\nplatforms like an 8051 or 16-bit platforms like an MSP430.\n\n> \n> Cheers,\n> Rusty.\n\n-derek\n\n-- \nDerek Atkins\nChief Technology Officer\nSecureRF Corporation\n\nOffice: 203.227.3151  x1343\nDirect: 617.623.3745\nMobile: 617.290.5355\nEmail: DAtkins at SecureRF.com\n\nThis email message may contain confidential, proprietary and / or\nlegally privileged information and intended only for the use of the\nintended recipient(s) and others specifically authorized. Any\ndisclosure, dissemination, copying, distribution or use of the\ninformation contained in this email message, including any attachments,\nto or by anyone other than the intended recipient is strictly\nprohibited.  If you received this in error, please immediately advise\nthe sender by reply email or at the telephone number above, and then\ndelete, shred, or otherwise dispose of this message."
            }
        ],
        "thread_summary": {
            "title": "Negotiating & Committing Signatures",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Derek Atkins",
                "Jeremy Rubin"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6790
        }
    }
]