[
    {
        "title": "[Lightning-dev] Pinging a route for capacity",
        "thread_messages": [
            {
                "author": "Jim Posen",
                "date": "2018-03-01T14:45:16",
                "message_text_only": "My understanding is that the best strategy for choosing a route to send\nfunds over is to determine all possible routes, rank them by estimated fees\nbased on channel announcements and number of hops, then try them\nsuccessively until one works.\n\nIt seems inefficient to me to actually do a full HTLC commitment handshake\non each hop just to find out that the last hop in the route didn't have\nsufficient remaining capacity in the first place. Depending on how many\npeople are using the network, I could also forsee situations where this\ncreates more payment failures because bandwidth is locked up in HTLCs that\nare about to fail anyway.\n\nOne idea that would likely help is the ability to send a ping over an onion\nroute asking \"does every hop have capacity to send X msat?\" Every hop would\nforward the onion request if the answer is yes, or immediately send the\nresponse back up the circuit if the answer is no. This should reveal no\nadditional information about the channel capacities that the sender\ncouldn't determine by sending a test payment to themself (assuming they\ncould find a loop). Additionally, the hops could respond with the latest\nfee rate in case channel updates are slow to propagate.\n\nThe main benefit is that this should make it quicker to send a successful\npayment because latency is lower than sending an actual payment and the\nsender could ping all possible routes in parallel, whereas they can't send\nmultiple payments in parallel. The main downside I can think of is that, by\nthe same token, it is faster and cheaper for someone to extract information\nabout channel capacities on the network with a binary search.\n\n-jimpo\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180301/55533bfa/attachment.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-03-01T15:13:43",
                "message_text_only": "Hey everyone,\n\ndisclaimer I am new here and have not a full understanding of the complete\nspecs yet - however since I decided to participate in lighting dev I will\njust be brave and try to add my ideas on the problem jimpo posed. So even\nin case by ideas are complete bs please just tell me in a friendly way and\nI know I need to read more code and specs in order to participate.\n\nReading about the described problem techniques like IP-Fragmentation (\nhttps://en.wikipedia.org/wiki/IP_fragmentation ) come to my mind. The\nsetting is a little bit different but in from my current understanding it\nshould still be applicable and also be the favorable solution in comparison\nto the proposed ping:\n\n1.) IP setting: In IP-Fragmentation one would obviously just split the\nIP-package in order to utilize a link layer protocol that doesn't have\nenough bandwidth for a bigger size package.\n2.) Lightning case: When the capacity of a channel during routing is not\nhigh enough - which means that the channel balance on that side is\nsomewhere between 0 and the size of the payment - one would have to to send\nthe second part of the fragmented package on a different route. This is\nobvious since the insufficient channel balance cannot come out of thin air\n(as in IP-Routing).\n\nMy first intuition was that this would become a problem for onion routing\nsince the router in question does not know the final destination but only\nknows the next hop which can't be utilized as the channel doesn't have\nenough funds. However I imagine one could just encapsulate the second part\nof the fragmented payment in a new onion routed package that goes on a\ndetour (using different payment channels) to the original \"next\" hop und\nprogresses from there as it was originally thought of.\n\nNot sure however how the impacts to the HTLC would be and if it would\nactually be possible to fragment a payment that is encapsulated within the\nonion routing.\n\nIf possible the advantage in comparison to your proposed ping method is\nthat fragmentation would be highly dynamic and still work if a channel runs\nout of funds while routing payment. In your ping scenario it could very\nwell happen that you do a ping for a designated rout, everything looks\ngreat, you send a payment but while it is on its way a channel on that way\ncould run dry.\n\nbest Rene\n\n\nOn Thu, Mar 1, 2018 at 3:45 PM, Jim Posen <jim.posen at gmail.com> wrote:\n\n> My understanding is that the best strategy for choosing a route to send\n> funds over is to determine all possible routes, rank them by estimated fees\n> based on channel announcements and number of hops, then try them\n> successively until one works.\n>\n> It seems inefficient to me to actually do a full HTLC commitment handshake\n> on each hop just to find out that the last hop in the route didn't have\n> sufficient remaining capacity in the first place. Depending on how many\n> people are using the network, I could also forsee situations where this\n> creates more payment failures because bandwidth is locked up in HTLCs that\n> are about to fail anyway.\n>\n> One idea that would likely help is the ability to send a ping over an\n> onion route asking \"does every hop have capacity to send X msat?\" Every hop\n> would forward the onion request if the answer is yes, or immediately send\n> the response back up the circuit if the answer is no. This should reveal no\n> additional information about the channel capacities that the sender\n> couldn't determine by sending a test payment to themself (assuming they\n> could find a loop). Additionally, the hops could respond with the latest\n> fee rate in case channel updates are slow to propagate.\n>\n> The main benefit is that this should make it quicker to send a successful\n> payment because latency is lower than sending an actual payment and the\n> sender could ping all possible routes in parallel, whereas they can't send\n> multiple payments in parallel. The main downside I can think of is that,\n> by the same token, it is faster and cheaper for someone to extract\n> information about channel capacities on the network with a binary search.\n>\n> -jimpo\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n\n\n-- \nwww.rene-pickhardt.de\n<http://www.beijing-china-blog.com/>\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180301/de74d39d/attachment.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-03-01T15:26:22",
                "message_text_only": "Hey everyone,\n\ndisclaimer I am new here and have not a full understanding of the complete\nspecs yet - however since I decided to participate in lighting dev I will\njust be brave and try to add my ideas on the problem jimpo posed. So even\nin case by ideas are complete bs please just tell me in a friendly way and\nI know I need to read more code and specs in order to participate.\n\nReading about the described problem techniques like IP-Fragmentation (\nhttps://en.wikipedia.org/wiki/IP_fragmentation ) come to my mind. The\nsetting is a little bit different but in from my current understanding it\nshould still be applicable and also be the favorable solution in comparison\nto the proposed ping:\n\n1.) IP setting: In IP-Fragmentation one would obviously just split the\nIP-package in order to utilize a link layer protocol that doesn't have\nenough bandwidth for a bigger size package.\n2.) Lightning case: When the capacity of a channel during routing is not\nhigh enough - which means that the channel balance on that side is\nsomewhere between 0 and the size of the payment - one would have to to send\nthe second part of the fragmented package on a different route. This is\nobvious since the insufficient channel balance cannot come out of thin air\n(as in IP-Routing).\n\nMy first intuition was that this would become a problem for onion routing\nsince the router in question does not know the final destination but only\nknows the next hop which can't be utilized as the channel doesn't have\nenough funds. However I imagine one could just encapsulate the second part\nof the fragmented payment in a new onion routed package that goes on a\ndetour (using different payment channels) to the original \"next\" hop und\nprogresses from there as it was originally thought of.\n\nNot sure however how the impacts to the HTLC would be and if it would\nactually be possible to fragment a payment that is encapsulated within the\nonion routing.\n\nIf possible the advantage in comparison to your proposed ping method is\nthat fragmentation would be highly dynamic and still work if a channel runs\nout of funds while routing payment. In your ping scenario it could very\nwell happen that you do a ping for a designated rout, everything looks\ngreat, you send a payment but while it is on its way a channel on that way\ncould run dry.\n\nbest Rene\n\n\nOn Thu, Mar 1, 2018 at 3:45 PM, Jim Posen <jim.posen at gmail.com> wrote:\n\n> My understanding is that the best strategy for choosing a route to send\n> funds over is to determine all possible routes, rank them by estimated fees\n> based on channel announcements and number of hops, then try them\n> successively until one works.\n>\n> It seems inefficient to me to actually do a full HTLC commitment handshake\n> on each hop just to find out that the last hop in the route didn't have\n> sufficient remaining capacity in the first place. Depending on how many\n> people are using the network, I could also forsee situations where this\n> creates more payment failures because bandwidth is locked up in HTLCs that\n> are about to fail anyway.\n>\n> One idea that would likely help is the ability to send a ping over an\n> onion route asking \"does every hop have capacity to send X msat?\" Every hop\n> would forward the onion request if the answer is yes, or immediately send\n> the response back up the circuit if the answer is no. This should reveal no\n> additional information about the channel capacities that the sender\n> couldn't determine by sending a test payment to themself (assuming they\n> could find a loop). Additionally, the hops could respond with the latest\n> fee rate in case channel updates are slow to propagate.\n>\n> The main benefit is that this should make it quicker to send a successful\n> payment because latency is lower than sending an actual payment and the\n> sender could ping all possible routes in parallel, whereas they can't send\n> multiple payments in parallel. The main downside I can think of is that,\n> by the same token, it is faster and cheaper for someone to extract\n> information about channel capacities on the network with a binary search.\n>\n> -jimpo\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n\n\n-- \nSkype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180301/ba0d1507/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-02T07:53:46",
                "message_text_only": "Good morning Rene,\n\nPlease consider the recent discussion about AMP, atomic multi-path. https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html\n\nNote that only the source (payer) can split the payment into multiple smaller payments; we cannot safely let intermediaries split the payment as the intermediaries may very well decide to send it to a ridiculously high-fee channel.  So the payer will make multiple payments that can only be merged at the destination, each sub-payment has a single route and itself cannot be split unless the payer decides to split.\n\n> Not sure however how the impacts to the HTLC would be and if it would actually be possible to fragment a payment that is encapsulated within the onion routing.\n\nThe timeouts in particular would be impossible to handle.  At any point the payment should reach the payee within some N blocks and each hop reduces that margin by a small amount (14 blocks for c-lightning if I remember correctly).  It is likely that there will not be enough time if it goes through a detour, unless the detour has equal or smaller reduction (delay) than the original hop with insufficient monetary capacity.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 1, 2018 11:26 PM, Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey everyone,\n>\n> disclaimer I am new here and have not a full understanding of the complete specs yet - however since I decided to participate in lighting dev I will just be brave and try to add my ideas on the problem jimpo posed. So even in case by ideas are complete bs please just tell me in a friendly way and I know I need to read more code and specs in order to participate.\n>\n> Reading about the described problem techniques like IP-Fragmentation ( https://en.wikipedia.org/wiki/IP_fragmentation ) come to my mind. The setting is a little bit different but in from my current understanding it should still be applicable and also be the favorable solution in comparison to the proposed ping:\n>\n> 1.) IP setting: In IP-Fragmentation one would obviously just split the IP-package in order to utilize a link layer protocol that doesn't have enough bandwidth for a bigger size package.\n> 2.) Lightning case: When the capacity of a channel during routing is not high enough - which means that the channel balance on that side is somewhere between 0 and the size of the payment - one would have to to send the second part of the fragmented package on a different route. This is obvious since the insufficient channel balance cannot come out of thin air (as in IP-Routing).\n>\n> My first intuition was that this would become a problem for onion routing since the router in question does not know the final destination but only knows the next hop which can't be utilized as the channel doesn't have enough funds. However I imagine one could just encapsulate the second part of the fragmented payment in a new onion routed package that goes on a detour (using different payment channels) to the original \"next\" hop und progresses from there as it was originally thought of.\n>\n> Not sure however how the impacts to the HTLC would be and if it would actually be possible to fragment a payment that is encapsulated within the onion routing.\n>\n> If possible the advantage in comparison to your proposed ping method is that fragmentation would be highly dynamic and still work if a channel runs out of funds while routing payment. In your ping scenario it could very well happen that you do a ping for a designated rout, everything looks great, you send a payment but while it is on its way a channel on that way could run dry.\n>\n> best Rene\n>\n> On Thu, Mar 1, 2018 at 3:45 PM, Jim Posen <jim.posen at gmail.com> wrote:\n>\n>> My understanding is that the best strategy for choosing a route to send funds over is to determine all possible routes, rank them by estimated fees based on channel announcements and number of hops, then try them successively until one works.\n>>\n>> It seems inefficient to me to actually do a full HTLC commitment handshake on each hop just to find out that the last hop in the route didn't have sufficient remaining capacity in the first place. Depending on how many people are using the network, I could also forsee situations where this creates more payment failures because bandwidth is locked up in HTLCs that are about to fail anyway.\n>>\n>> One idea that would likely help is the ability to send a ping over an onion route asking \"does every hop have capacity to send X msat?\" Every hop would forward the onion request if the answer is yes, or immediately send the response back up the circuit if the answer is no. This should reveal no additional information about the channel capacities that the sender couldn't determine by sending a test payment to themself (assuming they could find a loop). Additionally, the hops could respond with the latest fee rate in case channel updates are slow to propagate.\n>>\n>> The main benefit is that this should make it quicker to send a successful payment because latency is lower than sending an actual payment and the sender could ping all possible routes in parallel, whereas they can't send multiple payments in parallel. The main downside I can think of is that, by the same token, it is faster and cheaper for someone to extract information about channel capacities on the network with a binary search.\n>>\n>> -jimpo\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> --\n> Skype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180302/fed112ba/attachment-0001.html>"
            },
            {
                "author": "gb",
                "date": "2018-03-01T21:16:02",
                "message_text_only": ".... and any thoughts on protections against flood pinging?\n\nOn Thu, 2018-03-01 at 09:45 -0500, Jim Posen wrote:\n\n\n> The main benefit is that this should make it quicker to send a\n> successful payment because latency is lower than sending an actual\n> payment and the sender could ping all possible routes in parallel,\n> whereas they can't send multiple payments in parallel. The main\n> downside I can think of is that, by the same token, it is faster and\n> cheaper for someone to extract information about channel capacities on\n> the network with a binary search.\n> \n> \n> -jimpo\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Jim Posen",
                "date": "2018-03-02T14:42:09",
                "message_text_only": "Regarding ping flooding, if it is problematic, the best solution is\nprobably including a small proof-of-work with the ping, similar to BIP 154.\nHowever, the whole purpose of the ping in the first place is to be a\ncheaper way to collect routing information than attempting to send a\npayment, so I think adding a PoW starts to become counterproductive. Note\nthat the sender needs to expend a certain amount of computation just\ncreating the onion packet up front (on the order of a few ms, I believe),\nso perhaps that is sufficient.\n\nAlso, if someone wanted to DoS the network, there are much better ways than\nusing this proposed ping mechanism. For example, someone can send payments\nalong any circuit with a randomly generated payment hash (for which the\npreimage is unknown), and force a payment failure at the end of the route.\nThat is basically a way to ping that works now, but is more expensive for\neveryone.\n\nOn Thu, Mar 1, 2018 at 4:16 PM, gb <kiwigb at yahoo.com> wrote:\n\n> .... and any thoughts on protections against flood pinging?\n>\n> On Thu, 2018-03-01 at 09:45 -0500, Jim Posen wrote:\n>\n>\n> > The main benefit is that this should make it quicker to send a\n> > successful payment because latency is lower than sending an actual\n> > payment and the sender could ping all possible routes in parallel,\n> > whereas they can't send multiple payments in parallel. The main\n> > downside I can think of is that, by the same token, it is faster and\n> > cheaper for someone to extract information about channel capacities on\n> > the network with a binary search.\n> >\n> >\n> > -jimpo\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180302/e1a8e668/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-03-04T02:46:46",
                "message_text_only": "Jim Posen <jim.posen at gmail.com> writes:\n> My understanding is that the best strategy for choosing a route to send\n> funds over is to determine all possible routes, rank them by estimated fees\n> based on channel announcements and number of hops, then try them\n> successively until one works.\n>\n> It seems inefficient to me to actually do a full HTLC commitment handshake\n> on each hop just to find out that the last hop in the route didn't have\n> sufficient remaining capacity in the first place. Depending on how many\n> people are using the network, I could also forsee situations where this\n> creates more payment failures because bandwidth is locked up in HTLCs that\n> are about to fail anyway.\n\nIf failure is common this would be true, but I think it's too early to\ndesign for it.\n\nThis kind of signalling is what fees are for: when capacity gets low you\nincrease fees, and when it gets high, you reduce them.  But that may\nstill prove insufficient.\n\nTwo things come to mind:\n\n1. `temporary_channel_failure` returns a `channel_update`.  The\n   implication is that this has the disabled flag, but we should\n   probably make that true iff the request asks for < 2% of the channel\n   capacity or some \"minimal bar\".  If you can't even service this, you\n   should disable the channel.\n\n2. We can implement fast failure to reduce latency:\n   https://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming\n\nNote that there needs to be more analysis on reliable ways to mask the\nactive capacity of a channel: using a static random threshold still\nleaks information that *something* has happened, so it may need to be\nmore sophisticated.\n\nCheers,\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-04T22:18:56",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n> Jim Posen <jim.posen at gmail.com> writes:\n> If failure is common this would be true, but I think it's too early to\n> design for it.\n>\n> This kind of signalling is what fees are for: when capacity gets low you\n> increase fees, and when it gets high, you reduce them.  But that may\n> still prove insufficient.\n>\n> Two things come to mind:\n>\n> 1. `temporary_channel_failure` returns a `channel_update`.  The\n>    implication is that this has the disabled flag, but we should\n>    probably make that true iff the request asks for < 2% of the channel\n>    capacity or some \"minimal bar\".  If you can't even service this, you\n>    should disable the channel.\n>\n> 2. We can implement fast failure to reduce latency:\n>    https://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming\n>\n> Note that there needs to be more analysis on reliable ways to mask the\n> active capacity of a channel: using a static random threshold still\n> leaks information that *something* has happened, so it may need to be\n> more sophisticated.\n\nI have to agree with Rusty here, pinging a channel for capacity sounds a\nlot like premature optimization. In addition it could lead to a rather\nlarge privacy leak, both for the sender as well as the individual\nchannels.\n\nGiving any information about the current balance of a channel, could\nlead to tracing payments through the network. And users pinging channels\nbefore making a payment could result also in traced payments.\n\nThe feedback mechanism we have by adding channel_updates in the failure\nmessage should allow senders to learn about changes in the channels that\ncaused the failure, and it should be injected into the gossip so peers\nlearn about it as well. Once we have exhausted what we can do with the\nsimple gossip mechanism, only then should we be looking at other\nsolutions.\n\nCheers,\nChristian"
            }
        ],
        "thread_summary": {
            "title": "Pinging a route for capacity",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "gb",
                "Christian Decker",
                "Ren\u00e9 Pickhardt",
                "Rusty Russell",
                "Jim Posen",
                "ZmnSCPxj"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 23107
        }
    },
    {
        "title": "[Lightning-dev] refunds -- was Re:  BOLT 11, real time micro payments, and route redundancy",
        "thread_messages": [
            {
                "author": "Andy Schroder",
                "date": "2018-03-02T06:25:51",
                "message_text_only": "On 09/14/2017 11:49 PM, Rusty Russell wrote:\n>>>> I guess I'm confused how this is going to work safely. If you \n>>>> put a refund request in with your payment, isn't that revealing the \n>>>> public key of your node and then defeating the whole purpose of the \n>>>> onion routing of the payment in the first place (I'm, assuming the payee \n>>>>  node re-uses the same public key?)? It seems like rather than putting a\n>>>> >>> flag in BOLT 11 to instruct a payer to include a refund payment request,\n>>>> >>> shouldn't the payer just know to do that if they think they will need\n>>>> >>> to? Or maybe they won't always?\n>>> >> Nobody along the route (B and C in our example above) can see it.  And D\n>>> >> kind of has to, since it needs to send the refund.\n>> >\n>> > It seems to me like this is sort of a limitation in privacy with \n>> > lightening. With blockchain payments on my fuel pump, I could return a \n>> > refund back to the customer without always knowing who they are. With \n>> > lightning, it looks like the payer will reveal their identity to the \n>> > payee by offering a refund payment request. It's great that those along \n>> > the payment route don't know, but it's still bad to have the payer \n>> > revealed to the payee. Why does someone have to reveal their identity \n>> > just to get a refund?\n> Indeed, it's deeply suboptimal for privacy.\n>\n> There's a more complex scheme which is possible, using round-trip\n> payments (I think this was originally from Christian Decker?); I make a\n> payment via you and back to myself, it's just that I pay your node an\n> abnormally high \"fee\".  But unfortunately for security reasons each\n> encrypted hop contains the amount it expects to be sent, which doesn't\n> work if I don't know how much you're going to refund.\n>\n> Technically, you can put a really small amount in there (each node only\n> insists that the amount sent is >= this amount), but this just allows\n> one of those return nodes to untracably steal the extra refund amount.\n>\n> So, we really need to be able to include a (smaller) return onion to\n> fix this properly.  I've added that to:\n>\n>         https://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming#refunds\n>\n> Thanks!\n> Rusty.\n\n\n\nIf you are including a smaller return onion, you are including that with\nthe payment? That return onion would be created by the payer since they\nknow the routes from the payer to the payee? If so, how could this work\nif the route no longer has capacity (or goes down) by the time the payee\ndecides it's going to send the refund back to the payer (which could be\nminutes, hours, or days later)? Also, even if all routes are still up,\nthe payer may not necessarily know how much refund the payee will be\ngiving them, so they may not necessarily be able to even know what the\nbest route they should build an onion for?\n\n\n\n\n\nAndy Schroder"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-03-06T03:32:23",
                "message_text_only": "Andy Schroder <info at AndySchroder.com> writes:\n> On 09/14/2017 11:49 PM, Rusty Russell wrote:\n>> So, we really need to be able to include a (smaller) return onion to\n>> fix this properly.  I've added that to:\n>>\n>>         https://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming#refunds\n>>\n>> Thanks!\n>> Rusty.\n>\n> If you are including a smaller return onion, you are including that with\n> the payment? That return onion would be created by the payer since they\n> know the routes from the payer to the payee? If so, how could this work\n> if the route no longer has capacity (or goes down) by the time the payee\n> decides it's going to send the refund back to the payer (which could be\n> minutes, hours, or days later)? Also, even if all routes are still up,\n> the payer may not necessarily know how much refund the payee will be\n> giving them, so they may not necessarily be able to even know what the\n> best route they should build an onion for?\n\nYou're right.  While optimal routes aren't necessary, failures are\npossible and made worse by the inability to retry via a different route.\nI've noted this on the brainstorming phase.\n\nWe don't currently return a reply message on success, but we could.\nIt's best-effort of course (it won't appear if we drop to chain).  I\nwonder if we could use that somehow.\n\nThe general solution seems to require an ability to send payments to an\nanonymous destinations, which we don't have.\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "refunds -- was Re:  BOLT 11, real time micro payments, and route redundancy",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Andy Schroder"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4315
        }
    },
    {
        "title": "[Lightning-dev] Another Implementation",
        "thread_messages": [
            {
                "author": "\u6817\u5143\u61b2\u4e00",
                "date": "2018-03-03T12:52:03",
                "message_text_only": "I'm Kenichi Kurimoto from Japan.\n\nWe are the team who have been seeking an application and architecture that\ncombine cryptocurrency and IoT. (We are corporate team. Nayuta Inc.)\n\nWe are implementing another Node software according to Lightning Network\nSpecification(BOLT).\nhttps://github.com/nayutaco/ptarmigan\n\nThe software is developping phase, but basic feature of BOLT works on small\nclosed Testnet network with LND, c-lightning, and \u00e9clair.\nWe wrote how to use it on closed network. https://github.com/nayutaco/\nptarmigan/tree/development/docs\nWhen this node have valid path to starblocks, payment for starblocks can be\ndone.\nWe have not tested ip address broadcast mode.\n\nWe have respect for the efforts of the people who made RFC document, and we\nwould like to contribute further protocol development.\n\n-Kenichi Kurimoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180303/192c1215/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-03-06T03:42:46",
                "message_text_only": "\u6817\u5143\u61b2\u4e00 <kurimoto at nayuta.co> writes:\n> I'm Kenichi Kurimoto from Japan.\n\nGreetings Kenichi,\n\n        I've been wondering what you've been doing, since we've seen\nso many of your intelligent questions on the lightning-rfc github!\n\nWe have a Google Hangout every two weeks; you're welcome to join if you\nwant to discuss the specification progress but it is very early for\nJapan (4:00am!).\n\nhttps://docs.google.com/document/d/1oU4wxzGsYd0T084rTXJbedb7Gvdtj4ax638nMkYUmco/edit\n\nI look forward to your contributions!\n\nThankyou,\nRusty.\n\n> We are the team who have been seeking an application and architecture that\n> combine cryptocurrency and IoT. (We are corporate team. Nayuta Inc.)\n>\n> We are implementing another Node software according to Lightning Network\n> Specification(BOLT).\n> https://github.com/nayutaco/ptarmigan\n>\n> The software is developping phase, but basic feature of BOLT works on small\n> closed Testnet network with LND, c-lightning, and \u00e9clair.\n> We wrote how to use it on closed network. https://github.com/nayutaco/\n> ptarmigan/tree/development/docs\n> When this node have valid path to starblocks, payment for starblocks can be\n> done.\n> We have not tested ip address broadcast mode.\n>\n> We have respect for the efforts of the people who made RFC document, and we\n> would like to contribute further protocol development.\n>\n> -Kenichi Kurimoto\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Another Implementation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "\u6817\u5143\u61b2\u4e00"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2561
        }
    },
    {
        "title": "[Lightning-dev] Christian Deckers Duplex Micropayment Channels vs Lightning networks revocation key solution",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-03-03T23:30:23",
                "message_text_only": "Hey everyone,\n\nas mentioned before I am quite new to lightning dev. Should the questions\nI'll ask be too basic please drop me a kind note and I will be more quite\nor ask my questions on other places.\n\nToday I studied Chrstian Deckers nice work about duplex micropayment\nchannels (\nhttp://www.tik.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf\n<https://www.google.com/url?q=http://www.tik.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf&sa=D&source=hangouts&ust=1520200459037000&usg=AFQjCNG3ZwxZzV6e3VYlLpemzn0ZCUIv-A>\n )\n\nI am wondering what was the rational for the lightning spec (\nhttps://github.com/lightningnetwork/lightning-rfc ) to go with the\nrevocation key system instead of the solution by Christian Decker to the\nproblem? I understand that the revocation system was already in the\nwhitepaper and at the time of writing the whitepaper the work by Christian\nDecker wasn't out yet. But I guess this will not be the entire reason.\n\nTo me the key revocation system seems pretty complex to handle. In\nparticular as Rusty also mentioned on his article (c.f.\nhttps://medium.com/@rusty_lightning/lightning-watching-for-cheaters-93d365d0d02f\n ) that already in the white paper people knew that potentially a third\nparty observing service to detect a cheater is needed. This seems to me\nlike a big drawback.\n\nSo what have been strong arguments to go with the revocation system?\n\nOn a side note I would like to state my respect to you: The lightning\nnetwork (in combination with bitcoin) is really the most beautiful piece of\ntechnology I came across since I learnt about TCP/IP. Great work everybody\nfor creating such an amazing technology and bringing together all those\nbeautiful ideas. I am very confident that this technology will become\nhistory.\n\nbest Rene\n\n-- \nwww.rene-pickhardt.de\n<http://www.beijing-china-blog.com/>\n\nSkype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180304/4359a7b0/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-05T13:28:49",
                "message_text_only": "Good morning Rene,\n\nThe main issue I can think of offhand is the below issue for duplex channels:\n\nThe maximum lockup period for your funds in the worst case is proportional to the number of updates the channel can have.  Shorter worstcase lockup, fewer updates before the channel can only be closed.  There is a technique to make O(log n) lockup time for n update limit rather than O(n) (at the cost of using O(log n) transactions in sequence), but the basic \"more updates more worstcase lockup\"  exists.  With Poon-Dryja (revocation) channels, there is no limit in the number of updates possible on a channel, especially when you use the \"shachain\" concept by Rusty Russell (which reduces storage for a sequence of revocation keys to just 64 bytes or so, I have not studied it deeply): in effect, you get O(1) lockup time and O(1) transactions for n update limit under Poon-Dryja rather than O(log n) lockup time and O(log n) transactions for Decker-Wattenhofer.\n\nNote in particular that every payment actually requires two updates: one to get payer funds to an HTLC, and the other to get the HTLC funds to the payee (or to revert the HTLC funds to the payer in case of routing failure). This is needed to get proof-of-payment and in particular to ensure that the final payee on a long route really did get the funds.  So the cost incurred by Decker-Wattenhofer is higher by that factor, too.\n\nDecker-Wattenhofer does have the advantage that its construction can be extended to any number of participants per channel, while Poon-Dryja does not seem like it can be easily extended beyond two per channel.  Hence the Burchert-Decker-Wattenhofer channel factories, where a Decker-Wattenhofer multiparticipant channel construction terminates into multiple two-participant Poon-Dryja channels.  The Poon-Dryja channels can have any number of updates, and the Decker-Wattenhofer part only gets updated if all participants agree to redistribute their funds between terminating Poon-Dryja channels (which we expect to happen much more rarely than routing and sending/receiving funds, so that the O(log n) cost for maximum number of updates is less onerous for fund redistribution, while we still get to enjoy the potentially infinite number of possible channel updates for individual Poon-Dryja channels).\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 4, 2018 7:30 AM, Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey everyone,\n>\n> as mentioned before I am quite new to lightning dev. Should the questions I'll ask be too basic please drop me a kind note and I will be more quite or ask my questions on other places.\n>\n> Today I studied Chrstian Deckers nice work about duplex micropayment channels ( [http://www.tik.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf](https://www.google.com/url?q=http://www.tik.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf&sa=D&source=hangouts&ust=1520200459037000&usg=AFQjCNG3ZwxZzV6e3VYlLpemzn0ZCUIv-A) )\n>\n> I am wondering what was the rational for the lightning spec ( https://github.com/lightningnetwork/lightning-rfc ) to go with the revocation key system instead of the solution by Christian Decker to the problem? I understand that the revocation system was already in the whitepaper and at the time of writing the whitepaper the work by Christian Decker wasn't out yet. But I guess this will not be the entire reason.\n>\n> To me the key revocation system seems pretty complex to handle. In particular as Rusty also mentioned on his article (c.f. https://medium.com/@rusty_lightning/lightning-watching-for-cheaters-93d365d0d02f ) that already in the white paper people knew that potentially a third party observing service to detect a cheater is needed. This seems to me like a big drawback.\n>\n> So what have been strong arguments to go with the revocation system?\n>\n> On a side note I would like to state my respect to you: The lightning network (in combination with bitcoin) is really the most beautiful piece of technology I came across since I learnt about TCP/IP. Great work everybody for creating such an amazing technology and bringing together all those beautiful ideas. I am very confident that this technology will become history.\n>\n> best Rene\n>\n> --\n> [www.rene-pickhardt.de](http://www.rene-pickhardt.de/)http://www.beijing-china-blog.com/\n>\n> Skype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180305/21ef4a3a/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-05T13:50:10",
                "message_text_only": "Good morning Rene,\n\n>To me the key revocation system seems pretty complex to handle. In particular as Rusty also mentioned on his article (c.f. https://medium.com/@rusty_lightning/lightning-watching-for-cheaters-93d365d0d02f ) that already in the white paper people knew that potentially a third party observing service to detect a cheater is needed. This seems to me like a big drawback.\n\nI believe this is also necessary under Decker-Wattenhofer?  A potential thief trying to reuse old invalid state could make sure you will be offline for a few days, then broadcast (and hope it confirms) the kickoff transaction, wait for the old invalid state to be valid, and then broadcast the old invalid commitment transaction.  You have to be online after the kickoff transaction gets confirmed to ensure you can broadcast the latest commitment transaction, too, or if you plan to be offline for long, you also need some watchtower-like service under Decker-Wattenhofer.  And I believe that watchtowers under Poon-Dryja need only store the shachain and the funding txid, while watchtowers under Decker-Wattenhofer would have to store entire relative-timelocked transactions, leaking economic information at each update to a Decker-Wattenhofer watchtower, whereas Poon-Dryja watchtowers need to learn only about shachain updates, and can learn economic information only when channels get onchain (and honestly, when channels drop onchain everyone knows the economic information since the blockchain is publicly readable, so it is not a significant information at that point).\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180305/80250b5f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Christian Deckers Duplex Micropayment Channels vs Lightning networks revocation key solution",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8571
        }
    },
    {
        "title": "[Lightning-dev] Improving the initial gossip sync: DRAFT",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-03-06T03:26:00",
                "message_text_only": "https://github.com/lightningnetwork/lightning-rfc/pull/392\n\nI'll append to this as suggestions come in.  I'm trying to find some\ncycles to implement it too.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Improving the initial gossip sync: DRAFT",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 172
        }
    },
    {
        "title": "[Lightning-dev] Lightning Protocol Summit September 10/11 2018?",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-03-06T03:55:25",
                "message_text_only": "Hi all,\n\n        We had a kickoff summit for the Lightning Protocol in October\n2016 in Milan.  I think we're due for another one, so I'm proposing a\ndate and location which works for me: September 10th and 11th Adelaide,\nAustralia.\n\n        This would be a meeting for development, update and optimization\nof the Lightning network protocol, with the aim to figure out what would\nbe in the next version of the specification.\n\n        I would love to host you all; we're a wine growing region, we\nhave exotic animals, and spring is a great time to visit.\n\nCheers,\nRusty.\nPS.  I'm confident we can find travel funds for developers who would\n     otherwise be unable to attend."
            }
        ],
        "thread_summary": {
            "title": "Lightning Protocol Summit September 10/11 2018?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 673
        }
    },
    {
        "title": "[Lightning-dev] Fwd:  Post-Schnorr lightning txes",
        "thread_messages": [
            {
                "author": "Andrew Poelstra",
                "date": "2018-03-06T20:58:51",
                "message_text_only": "Hi Anthony,\n\n\nIf you have adaptor/Bellare-Neven signatures you can actually do state updates\nin a much simpler way. Suppose we have two parties, Alice and Bob.\n\nThe basic structure of a payment channel in state i is\n\n  Funding tx --> Commit_i --> Close_i\n\nwhere Commit_i is a transaction with one output with the following script\n\n   IF AB_i ELSE <csv> CSV AB'_i ENDIF CHECKSIG\n\nand Close_i is a transaction moving the coins to their final destination.\n\n(I'm using IF/ELSE, but for efficiency the CSV branch could be hidden behind\na Taproot.)\n\n\n\nTo create a new state i, A and B interact as follows.\n\n    0. Create tx_i, a 1-in-1-out tx which spends the funding tx output to\n       the Commit_i output.\n\n    1. Both sign a closing transaction tx'_i which spends this output to the\n       Close_i output. tx'_i will be valid <csv> blocks after the Commit\n       transaction is posted to the blockchain.\n\n    2. A and B interactively sign tx_i twice. In the final step of this\n       interaction, A gives s^1_{A,i} to B and B gives s^2_{B,i} to A.\n\n       Now A can generate s^2_{A,i} to complete a signature and post tx_i,\n       or B can generate s^1_{B,i} to the same effect.\n\nAfter creating a new state i, A and B revoke state i-1 as follows:\n\n    3. A sends an adaptor signature for s^2_{A,i-1} which reveals her half\n       of AB_i if she publishes that signature. Similarly B sends an\n       adaptor sig for s^1_{B,i-1} which reveals his half of AB_{i-1}.\n\n       Now if either party completes tx_i and to post the (i-1)th state\n       to the chain, the _other_ party will learn the secret key to AB_i\n       and can take the coins.\n\n\nThe partial signatures in step (2) can be adaptor signatures which link\nthis state update to other state updates in other channel, giving complete\npaths. In fact you can link arbitrary sets of channels to get multipaths,\nso AMP comes for free in this scheme.\n\nAs Anthony mentioned in his email, the payment receipt is now a discrete log\n(which can be reblinded so that participants in the hop who aren't the sender\nor recipient can't see it). This means that the sender can sign with this,\ngetting a transferrable proof of payment that also works with AMP.\n\n\n\nThe required state to store consists of these adaptor signatures, so it's\nlinear in the number of state updates in each channel. I believe outsourcing\nwill be quadratic :( but I haven't worked out those details. Though you can\nget a weak form of monitoring by giving the adaptor signatures to the monitor\nand having it contact the affected party with \"wake up! somebody published an\nold state and revealed the key x, please use it to take your coins\".\n\nI haven't worked out blind monitoring either, it seems like it should be\ndoable because everything here is discrete-log based which is inherently\nfriendly toward blinding.\n\n\n\n\n\nAndrew\n\n\nOn Tue, Mar 06, 2018 at 08:18:31PM +0000, Christian Decker wrote:\n> ---------- Forwarded message ---------\n> From: Anthony Towns <aj at erisian.com.au>\n> Date: Mon, Feb 19, 2018 at 11:59 PM\n> Subject: [Lightning-dev] Post-Schnorr lightning txes\n> To: <lightning-dev at lists.linuxfoundation.org>\n> \n> \n> Hi *,\n> \n> My understanding of lightning may be out of date, so please forgive\n> (or at least correct :) any errors on my behalf.\n> \n> I was thinking about whether Greg Maxwell's graftroot might solve the\n> channel monitoring problem (spoiler: not really) and ended up with maybe\n> an interesting take on Schnorr. I don't think I've seen any specific\n> writeup of what that might look like, so hopefully at least some of this\n> is novel!\n> \n> I'm assuming familiarity with current thinking on Schnorr sigs -- but all\n> you should need to know is the quick summary at footnote [0].\n> \n> So I think there's four main scenarios for closing a lightning channel:\n> \n>  - both parties are happy to close, do so cooperatively, and can\n>    sign a new unconditional transaction that they agree on. already fine.\n>    (should happen almost all of the time, call it 80%)\n> \n>  - communications failure: one side has to close, but the other side\n>    is happy to cooperate as far as they're able but can only do so via\n>    the blockchain and maybe with some delay (maybe 15% of the time)\n> \n>  - disappearance, uncooperative: one side effectively completely\n>    disappears so the other side has to fully close the channel on their\n>    own (5% of the time)\n> \n>  - misbehaviour: one side tries publishing an old channel state due to\n>    error or maliciousness, and the other collects the entire balance as\n>    penalty (0% of the time)\n> \n> With \"graftroot\" in mind, I was thinking that optimising for the last\n> case might be interesting -- despite expecting it to be vanishingly\n> rare. That would have to look something like:\n> \n>    (0) funding tx\n>    (1) ...which is spent by a misbehaving commitment tx\n>    (2) ...which is spent by a penalty tx\n> \n> You do need 3 txes for that case, but you really only need 1 output\n> for each: so (0) is 2-in-1-out, (1) is 1-in-1-out, (2) is 1-in-1-out;\n> which could all be relatively cheap. (And (2) could be batched with other\n> txes making it 1 input in a potentially large tx)\n> \n> For concreteness, I'm going to treat A as the one doing the penalising,\n> and B (Bad?) as the one that's misbehaving.\n> \n> If you treat each of those txes as a muSig Schnorr pay-to-pubkey, the\n> output addresses would be:\n> \n>    (0) funding tx pays to [A,B]\n>    (1) commitment tx pays to [A(i),Revocation(B,i)]\n>    (2) pays to A\n> \n> (where i is a commitment id / counter for the channel state)\n> \n> If B misbehaves by posting the commitment tx after revealing the\n> revocation secret, A can calculate A(i) and Revocation(B,i) and claim\n> all the funds immediately.\n> \n> As far as the other cases go:\n> \n>   - In a cooperative close, you don't publish any commitment txes, you\n>     just spend the funding to each party's preferred destinations\n>     directly; so this is already great.\n> \n>   - Otherwise, you need to be able to actually commit to how the funds\n>     get distributed.\n> \n> But committing to distributing funds is easy: just jointly sign\n> a transaction with [A(i),Revocation(B,i)]. Since B is the one we're\n> worrying about misbehaving, it needs to hold a transaction with the\n> appropriate outputs that is:\n> \n>   - timelocked to `to_self_delay` blocks/seconds in advance via nSequence\n>   - signed by A(i)\n> \n> That ensures A has `to_self_delay` blocks/seconds to penalise misehaviour,\n> and that when closing properly, B can complete the signature using the\n> current revocation secret.\n> \n> This means the \"appropriate outputs\" no longer need the OP_CSV step, which\n> should simplify the scripts a bit.\n> \n> Having B have a distribution transaction isn't enough -- B could vanish\n> between publishing the commitment transaction and the distribution\n> transaction, leaving A without access to any funds. So A needs a\n> corresponding distribution transaction. But because that transaction can\n> only be published if B signs and publishes the corresponding commitment\n> transaction, the fact that it's published indicates both A and B are\n> happy with the channel close -- so this is a semi-cooperative close and\n> no delay is needed. So A should hold a partially signed transaction with\n> the same outputs:\n> \n>   - without any timelock\n>   - signed by Revocation(B,i), waiting for signature by A(i)\n> \n> Thus, if B does a non-cooperative close, either:\n> \n>   - A proves misbehaviour and claims all the funds immediately\n>   - A agrees that the channel state is correct, signs and publishes\n>     the un-timelocked distribution transaction, then claims A's outputs;\n>     B can then immediately claim its outputs\n>   - A does nothing, and B waits for the `to_self_delay` period, signs\n>     and publishes its transaction, then claims B's outputs; A can eventually\n>     claim its own outputs\n> \n> In that case all of the transactions except the in-flight HTLCs just look\n> like simple pay-to-pubkey transactions.\n> \n> Further, other than the historical secrets no old information needs\n> to be retained: misbehaviour can be dealt with (and can only be dealt\n> with) by creating a new transaction signed by your own secrets and the\n> revocation information.\n> \n> None of that actually relies on Schnorr-multisig, I think -- it could\n> be done today with normal 2-of-2 multisig as far as I can see.\n> \n> \n> \n> I'm not 100% sure how this approach works compared to the current one\n> for the CSV/CLTV overlap problem. I think any case you could solve by\n> obtaining a HTLC-Timeout or HTLC-Success transaction currently, you could\n> solve in the above scenario by just updating the channel state to remove\n> the HTLC.\n> \n> \n> So I believe the above lets you completely forget info about old HTLCs,\n> while still enforcing correct behavior, and also makes enforcing correct\n> behaviour cheaper because it's just two extremely simple transactions\n> to post. If I haven't missed any corner cases, it also seems to simplify\n> the scripts a fair bit.\n> \n> Does this make sense? It seems to to me...\n> \n> \n> So for completeness, it would make sense to do HTLCs via Schnorr --\n> at least to make them reveal elliptic curve private keys, and ideally\n> to make them mostly indistinguishable from regular transactions as a\n> \"scriptless script\" [1] or \"discreet log contract\" [2]. (I think, at\n> least for HTLCs, these end up being the same?)\n> \n> The idea then is to have the HTLC payment hash be R=r*G, where r is the\n> secret/payment receipt.\n> \n> Supposing your current commitment has n HTLCs in-flight, some paying A\n> if the HTLC succeeds and \"r\" is revealed, others paying B. We'll focus\n> on one paying A.\n> \n> So you succeed by A completing a signature that reveals r to B,\n> and which simultaneously allows collection of the funds on chain. A\n> needs to be able to do this knowing nothing other than r (and their own\n> private keys). So agree to sign to muSig 2-of-2 multisig [A,B]. A and B\n> generate random values i and j respectively and reveal I=i*G and J=j*G,\n> and each calculates Q=I+J+R, and they generate partial signatures of a\n> transaction paying A:\n> \n>     I, i + H(X,Q,m)*H(L,A)*a\n>     J, j + H(X,Q,m)*H(L,B)*b\n> \n> where L = H(A,B) and X = H(L,A)*A + H(L,B)*B as usual. Once A knows r,\n> A can construct a full signature by adding R, r to the above values,\n> and B can then determine r by subtracting the above values from signature\n> A generated.\n> \n> To ensure B gets paid if the HTLC timesout, they should also sign a\n> timelocked transaction paying B directly, that B can hold onto until\n> the channel state gets updated.\n> \n> And once you're doing payment hashes via ECC, you can of course change\n> them at each hop to make it harder to correlate steps in a payment route.\n> \n> I think that when combined with the above method of handling CSV delays\n> and revocation, this covers all the needed cases with a straightforward\n> pay-to-pubkey(hash) output, no script info needed at all. It does mean\n> each HTLC needs a signature every time the channel state updates (B needs\n> to sign a tx allowing A to claim the output once A knows the secret,\n> A needs to sign a tx allowing B to claim the output on timeout).\n> \n> \n> For channel monitoring this is pretty good, I think. You need to\n> keep track of the revocation info and your secret keys -- but that's\n> essentially a constant amount of data.\n> \n> If you're happy to have the data grow by 64 bytes every time the channel\n> state updates, you can outsource channel monitoring: arrange a formula\n> for constructing a penalty tx based on the channel commitment tx --\n> eg, 95% of the balance goes to me, 4% goes to the monitor's address, 1%\n> goes to fees, there's a relative locktime of to_self_delay/3 to allow me\n> to directly claim 100% of the funds if I happen to be paying attention;\n> then do a partial signature with A(i), and then allow the monitoring\n> service to catch fraudulent transactions, work out the appropriate\n> revocation secret, and finish the signature.\n> \n> If your channel updates 100 times a second for an entire year, that's\n> 200GB of data, which seems pretty feasible. (You can't just regenerate\n> that data though, unless you keep each commitment tx) And it's pretty\n> easy to work out which bit of data you need to access: the funding\n> tx that's being spent tells you which channel, and the channel state\n> index is encoded in the locktime and sequence, so you should only need\n> small/logarithmic overhead even for frequently updated channels rather\n> than any serious indexes.\n> \n> I don't think you can do better than that without serious changes to\n> bitcoin: if you let the monitoring agency sign on its own, you'd need some\n> sort of covenant opcode to ensure it sends any money to you; and with\n> segwit outputs, there's no way to provide a signature for a transaction\n> without committing to exactly which transaction you're signing.\n> \n> I was hoping covenants and graftroot would be enough, but I don't\n> think they are. The idea would be that since the transaction spends to\n> A(i)+Rev(B,i), you'd sign an output script with A that uses covenant\n> opcodes to ensure the transaction only pays the appropriate monitoring\n> reward, and the monitor could then work out A(i)-A and Rev(B,i) and finish\n> the signature. But the signature by \"A\" would need to know A(i)+Rev(B,i)\n> when calculating the hash, and that's different for every commitment\n> transaction, so as far as I can see, it just doesn't work. You can't\n> drop the muSig-style construction because you need to be protect yourself\n> against potential malicious choice of the revocation secret [3].\n> \n> \n> Summary:\n> \n>  - Funding txes as 2-of-2 multisig is still great. Convert to\n>    Schnorr/muSig when available of course.\n> \n>  - Generate 6+8*n transactions everytime the channel state is updated,\n>    (n = number of HTLCs in-flight)\n> \n>    1. Channel state commitment tx, held by A, spends funding tx,\n>       payable to Schnorr muSig address [A(i),Rev(B,i)], signed by B\n>    2. Channel fund distribution tx, held by A (CSV), spends (1),\n>       signed by Rev(B,i)\n>    3. Channel fund distribution tx, held by B (no CSV), spends (1),\n>       signed by A(i)\n>    4. Channel state commitment tx, held by B, spends funding tx\n>       payable to Schnorr muSig address [B(i),Rev(A,i)], signed by A\n>    5. Channel fund distribution tx, held by B (CSV), spends (4),\n>       signed by Rev(A,i)\n>    6. Channel fund distribution tx, held by A (no CSV), spends (4),\n>       signed by B(i)\n> \n>    The fund distribution txs all pay the same collection of addresses:\n>      - channel balance for A directly to A's preferred address\n>      - channel balance for B directly to B's preferred address\n>      - HTLC balance to muSig address for [A,B] for each in-flight HTLC\n>        paying A on success\n>      - HTLC balance to muSig address for [B,A] for each in-flight HTLC\n>        paying B on success\n>      - (probably makes sense to bump the HTLC addresses by some random\n>        value to make it harder for third parties to tell which addresses\n>        were balances versus HTLCs)\n> \n>    Both (1) and (4) include obscured channel state ids as per current\n>    standard.\n> \n>    For each HTLC that pays X on timeout and Y on success:\n>      a. Timeout tx, held by X, signed by Y, spends from (2)\n>      b. Timeout tx, held by X, signed by Y, spends from (3)\n>      c. Timeout tx, held by X, signed by Y, spends from (5)\n>      d. Timeout tx, held by X, signed by Y, spends from (6)\n> \n>      e. Success tx, held by Y, signed by X, spends from (2)\n>      f. Success tx, held by Y, signed by X, spends from (3)\n>      g. Success tx, held by Y, signed by X, spends from (5)\n>      h. Success tx, held by Y, signed by X, spends from (6)\n> \n>      (these should all be able to be SIGHASH_SINGLE, ANYONECANPAY\n>       to allow some level of aggregation)\n> \n>  - Fund distribution tx outputs can all be pay2pubkey(hash): HTLCs work\n>    by pre-signed timelocked transactions and scriptless\n>    scripts/discreet-log contracts to reveal the secret; balances work\n>    directly; CSV and revocations are already handled by that point\n> \n>  - You can discard all old transaction info and HTLC parameters once\n>    they're not relevant to the current channel state\n> \n>  - Channel monitoring can be outsourced pretty efficiently -- as little as\n>    a signature per state could be made to works as far as I can see,\n>    which doesn't add up too fast.\n> \n>  - There's still no plausible way of doing constant space outsourced\n>    channel monitoring without some sort of SIGHASH_NOINPUT, at least\n>    that I can see\n> \n> Thoughts?\n> \n> [4]\n> \n> Cheers,\n> aj, very sad that this didn't turn out to be a potential use case for\n>     graftroot :(\n> \n> [0] In particular, I'm assuming that:\n> \n>     - Schnorr sigs in bitcoin will look something like:\n>         R, r + H(X,R,m)*x\n> \n>       (where m is the message being signed by private key x, r is a\n>       random per-sig nonce, R and X are public keys corresponding to r,x;\n>       H is the secure hash function)\n> \n>     - muSig is a secure way for untrusting parties to construct an n-of-n\n>       combined signature; for public keys A and B, it produces a combined\n>       public key:\n>         X = H(L,A)*A + H(L,B)*B\n>       with L = H(A,B)\n> \n>    See\n> https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html\n> \n> [1]\n> https://scalingbitcoin.org/stanford2017/Day2/Using-the-Chain-for-what-Chains-are-Good-For.pdf\n> \n> http://diyhpl.us/wiki/transcripts/scalingbitcoin/stanford-2017/using-the-chain-for-what-chains-are-good-for/\n> \n> [2] https://adiabat.github.io/dlc.pdf\n>     https://diyhpl.us/wiki/transcripts/discreet-log-contracts/\n> \n> [3] Well, maybe you could request a zero-knowledge proof to ensure a new\n>     revocation hash conforms to the standard for generating revocation\n>     secrets without revealing the secret, and have the public key be\n>     a(i)*G + r(B,i)*G without using the muSig construct, but that would\n>     probably be obnoxious to have to generate every time you update\n>     the channel state.\n> \n> [4] As an aside -- this could make it feasible and interesting to penalise\n>     disappearance as well as misbehaviour. If you add a transaction\n>     the B pre-signs, spending the commitment tx A holds, giving all the\n>     channel funds to A but only after a very large CSV timeout, perhaps\n>     `to_self_delay`*50, then the scenarios are:\n> \n>     If A is present:\n> \n>       - B publishes an old commitment: A immediately steals all the\n>         funds if active or outsourced misbehaviour monitoring. Whoops!\n> \n>       - B publishes the current commitment: A publishes its distribution\n>         transaction and collects its funds immediately, allowing B to\n>         do likewise\n> \n>     If A has disappeared:\n> \n>       - B publises the current commitment and waits a modest amount\n>         of time, publishes its distribution transaction claiming its\n>         rightful funds, and allowing A to collect its funds if it ever\n>         does reappear and still knows its secrets\n> \n>       - B publishes the current commitment, waits a fair while,\n>         A reappears and publishes its distribution transactions, both\n>         parties get their rightful funds\n> \n>       - B publishes the current commitment, waits an extended period\n>         of time, and claims the entire channel's funds. If B is\n>         particularly reputable, and A can prove its identity (but not\n>         recover all its secrets) maybe B even refunds A some/all of its\n>         rightful balance\n> \n>     Perhaps that provides too much of an incentive to try blocking\n>     someone from having access to the blockchain though.\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180306/ed21a545/attachment-0001.sig>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2018-03-06T21:06:25",
                "message_text_only": "On Tue, Mar 06, 2018 at 08:58:51PM +0000, Andrew Poelstra wrote:\n> After creating a new state i, A and B revoke state i-1 as follows:\n> \n>     3. A sends an adaptor signature for s^2_{A,i-1} which reveals her half\n>        of AB_i if she publishes that signature. Similarly B sends an\n>        adaptor sig for s^1_{B,i-1} which reveals his half of AB_{i-1}.\n> \n>        Now if either party completes tx_i and to post the (i-1)th state\n>        to the chain, the _other_ party will learn the secret key to AB_i\n>        and can take the coins.\n>\n\nOof I messed up this paragraph. _i should be _{i-1} everywhere. Here is a\ncorrect version: \n\n>     3. A sends an adaptor signature for s^2_{A,i-1} which reveals her half\n>        of AB_{i-1} if she publishes that signature. Similarly B sends an\n>        adaptor sig for s^1_{B,i-1} which reveals his half of AB_{i-1}.\n> \n>        Now if either party completes tx_{i-1} to post the (i-1)th state\n>        to the chain, the _other_ party will learn the secret key to AB_{i-1}\n>        and can take the coins.\n>\n\n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180306/829279c4/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Fwd:  Post-Schnorr lightning txes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Andrew Poelstra"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 22168
        }
    },
    {
        "title": "[Lightning-dev] A protocol for requesting invoices",
        "thread_messages": [
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-03-08T15:19:56",
                "message_text_only": "Hi,\n\nI was thinking of how to use Lightning for various types of payments,\nand I think it's currently fine for customer/(web)shop type\ninteractions, but it seems a bit inconvenient for other use cases, e.g.\nsalary payments or direct pay-out of cryptocurrency bought on an\nexchange. I came up with an idea that addresses some of these issues and\nmore (e.g. payee anonymity) by having a direct line of communication\nbetween payer and payee instead of BOLT11-style interaction. It's still\na bit half-baked, with many details not worked out yet, but you can read\nit here, and see if you like where this is going:\n\n\nhttps://github.com/bitonic-cjp/lightning-rfc/blob/payment-protocol/12-payment-protocol.md\n\n\nIn true permissionless fashion, I have been so bolD to register bolT #12\nfor my idea.\n\n\nPlease let me know what you think.\n\nkind regards,\n\nCJP"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-09T04:28:34",
                "message_text_only": "Good morning Corne,\n\nYou mention URLs in your draft.  This made me remember about the Web Payments Working Group of W3C, https://www.w3.org/Payments/WG/ , of which Decker, Christian of Blockstream is a member: https://www.w3.org/2000/09/dbwg/details?group=83744&public=1\n\nMy understanding is that Christian aims to make Bitcoin payments (and possibly Lightning invoice payments?) payable over Web payment protocols that W3C group is working on.\n\nPossibly the Web Payments Working Group may provide better perspective on various other payment use cases as well as their subtleties, which can help inform your considerations in your proposed BOLT12.\n\nRegards,\nZmnSCPxj\n\n\n\u200bSent with ProtonMail Secure Email.\u200b\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n\nOn March 8, 2018 11:19 PM, Corn\u00e9 Plooy via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n> \n> I was thinking of how to use Lightning for various types of payments,\n> \n> and I think it's currently fine for customer/(web)shop type\n> \n> interactions, but it seems a bit inconvenient for other use cases, e.g.\n> \n> salary payments or direct pay-out of cryptocurrency bought on an\n> \n> exchange. I came up with an idea that addresses some of these issues and\n> \n> more (e.g. payee anonymity) by having a direct line of communication\n> \n> between payer and payee instead of BOLT11-style interaction. It's still\n> \n> a bit half-baked, with many details not worked out yet, but you can read\n> \n> it here, and see if you like where this is going:\n> \n> https://github.com/bitonic-cjp/lightning-rfc/blob/payment-protocol/12-payment-protocol.md\n> \n> In true permissionless fashion, I have been so bolD to register bolT #12\n> \n> for my idea.\n> \n> Please let me know what you think.\n> \n> kind regards,\n> \n> CJP\n> \n> Lightning-dev mailing list\n> \n> Lightning-dev at lists.linuxfoundation.org\n> \n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-03-15T14:29:30",
                "message_text_only": "Hi\u00a0 ZmnSCPxj,\n\n\nThanks for the links. I've done a bit of reading, and this seems to be\nthe clearest explanation of what the Web Payments Working Group wants to\nachieve:\n\nhttps://www.w3.org/TR/webpayments-overview/\n\nBut maybe Christian can give better / more up-to-date info.\n\n\nFrom what I can see, their concept is still very much focused on\nnon-recurring purchases, and then especially on websites. In other\nwords: the typical web shop use case. The site linked above does however\ncontain the following text:\n\n\n\"A concern has been raised over the structure of a payment request,\nnotably that there are other forms of messages that may be initiated by\na payer. There is currently a proposal to modify payment request to a\nmore generalized \"payment instruction\" that would be capable of\nexpressing other messages like subscriptions, preauthorizations,\nrefunds, and other sorts of payment-related instructions.\"\n\n\nSo it seems they're thinking about it, but there is no consensus or\nstandardization yet. The important question: should we wait for this?\nHow long is this going to take? How bad would it be to first push\nforward some simple version of BOLT 12?\n\n\nCJP\n\n\nPS. Quote of the day:\n\n\"Some aspects of bitcoin are less useful, however. It is currently\nimpossible to set up recurring payments with the currency, making it\nimpractical for subscriptions that renew on a short term basis.\"\n\n\n\nOp 09-03-18 om 05:28 schreef ZmnSCPxj:\n> Good morning Corne,\n>\n> You mention URLs in your draft.  This made me remember about the Web Payments Working Group of W3C, https://www.w3.org/Payments/WG/ , of which Decker, Christian of Blockstream is a member: https://www.w3.org/2000/09/dbwg/details?group=83744&public=1\n>\n> My understanding is that Christian aims to make Bitcoin payments (and possibly Lightning invoice payments?) payable over Web payment protocols that W3C group is working on.\n>\n> Possibly the Web Payments Working Group may provide better perspective on various other payment use cases as well as their subtleties, which can help inform your considerations in your proposed BOLT12.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> \u200bSent with ProtonMail Secure Email.\u200b\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>\n> On March 8, 2018 11:19 PM, Corn\u00e9 Plooy via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi,\n>>\n>> I was thinking of how to use Lightning for various types of payments,\n>>\n>> and I think it's currently fine for customer/(web)shop type\n>>\n>> interactions, but it seems a bit inconvenient for other use cases, e.g.\n>>\n>> salary payments or direct pay-out of cryptocurrency bought on an\n>>\n>> exchange. I came up with an idea that addresses some of these issues and\n>>\n>> more (e.g. payee anonymity) by having a direct line of communication\n>>\n>> between payer and payee instead of BOLT11-style interaction. It's still\n>>\n>> a bit half-baked, with many details not worked out yet, but you can read\n>>\n>> it here, and see if you like where this is going:\n>>\n>> https://github.com/bitonic-cjp/lightning-rfc/blob/payment-protocol/12-payment-protocol.md\n>>\n>> In true permissionless fashion, I have been so bolD to register bolT #12\n>>\n>> for my idea.\n>>\n>> Please let me know what you think.\n>>\n>> kind regards,\n>>\n>> CJP\n>>\n>> Lightning-dev mailing list\n>>\n>> Lightning-dev at lists.linuxfoundation.org\n>>\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2018-03-20T13:11:16",
                "message_text_only": "On 9 March 2018 at 05:28, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Corne,\n>\n> You mention URLs in your draft.  This made me remember about the Web\n> Payments Working Group of W3C, https://www.w3.org/Payments/WG/ , of which\n> Decker, Christian of Blockstream is a member: https://www.w3.org/2000/09/\n> dbwg/details?group=83744&public=1\n>\n> My understanding is that Christian aims to make Bitcoin payments (and\n> possibly Lightning invoice payments?) payable over Web payment protocols\n> that W3C group is working on.\n>\n> Possibly the Web Payments Working Group may provide better perspective on\n> various other payment use cases as well as their subtleties, which can help\n> inform your considerations in your proposed BOLT12.\n>\n\nI'm interested in this effort too.\n\nThere's various levels of web payments incubation.  Working Group is for\nwide deployment in browsers.  Interest Group is for ideas that are aimed at\nstandards track.  Community group is aimed at new ideas and specs which can\nhave stable references, but may be more on the bleeding edge.\n\nI do quite a bit of work with the W3C, so am happy to look over things, as\nI'd like to include something similar in my apps.  I was thinking I'd have\nto make my own ontology, but if it's possible to reuse, that's even better!\n\n\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> \u200bSent with ProtonMail Secure Email.\u200b\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>\n> On March 8, 2018 11:19 PM, Corn\u00e9 Plooy via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> > Hi,\n> >\n> > I was thinking of how to use Lightning for various types of payments,\n> >\n> > and I think it's currently fine for customer/(web)shop type\n> >\n> > interactions, but it seems a bit inconvenient for other use cases, e.g.\n> >\n> > salary payments or direct pay-out of cryptocurrency bought on an\n> >\n> > exchange. I came up with an idea that addresses some of these issues and\n> >\n> > more (e.g. payee anonymity) by having a direct line of communication\n> >\n> > between payer and payee instead of BOLT11-style interaction. It's still\n> >\n> > a bit half-baked, with many details not worked out yet, but you can read\n> >\n> > it here, and see if you like where this is going:\n> >\n> > https://github.com/bitonic-cjp/lightning-rfc/blob/\n> payment-protocol/12-payment-protocol.md\n> >\n> > In true permissionless fashion, I have been so bolD to register bolT #12\n> >\n> > for my idea.\n> >\n> > Please let me know what you think.\n> >\n> > kind regards,\n> >\n> > CJP\n> >\n> > Lightning-dev mailing list\n> >\n> > Lightning-dev at lists.linuxfoundation.org\n> >\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180320/bf6c51a4/attachment-0001.html>"
            },
            {
                "author": "Andy Schroder",
                "date": "2018-03-10T05:16:14",
                "message_text_only": "Hello Corn\u00e9,\n\nI'm glad to see that someone getting this kind of idea started.\n\nI'm still new to some of these topics, but I have a few comments.\nHopefully I'm not wasting your time if they are too rudimentary!\n\n 1. You mention that the payee gives a URL where the payer can then\n    connect to to request invoices. You mention that this can be a tor\n    hidden service if the payee needs to remain private. You also\n    suggest that the payee can remain private by \"payee can send an\n    invoice to payer which has a partial onion route as destination\n    instead of a node ID\". I was reading about tor hidden services\n    (https://www.torproject.org/docs/onion-services.html.en), and they\n    require an introduction point, and a rendezvous point. Do we not\n    need this two step process for the payment route, because we already\n    have communication initiated over the anonymous communication\n    channel, and the beginning of the partial onion route is not\n    publicly available information, and can change with every invoice?\n 2. What happens if the capacity of the partial onion route is no longer\n    sufficient when the payer is ready to pay? Is there a way to provide\n    a few routes just in case? Or, in the case where no amount is\n    specified, how is the partial onion route possible if we don't even\n    know how much capacity may be needed?\n 3. You say the refund should invalidate the proof of payment of the\n    initial transaction. What about partial refunds? I think there are a\n    lot of applications where there would be a partial refund.\n 4. You say \"this BOLT specifies a protocol where payee gives a URL to\n    one or more potential payers\". How does the payer identify itself to\n    the payee so that the payee knows what goods or services that they\n    want an invoice for? Do they send this after making the connection,\n    or is it part of the URL?\n\n\n\n\nAndy Schroder\n\nOn 03/08/2018 10:19 AM, Corn\u00e9 Plooy via Lightning-dev wrote:\n> Hi,\n>\n> I was thinking of how to use Lightning for various types of payments,\n> and I think it's currently fine for customer/(web)shop type\n> interactions, but it seems a bit inconvenient for other use cases, e.g.\n> salary payments or direct pay-out of cryptocurrency bought on an\n> exchange. I came up with an idea that addresses some of these issues and\n> more (e.g. payee anonymity) by having a direct line of communication\n> between payer and payee instead of BOLT11-style interaction. It's still\n> a bit half-baked, with many details not worked out yet, but you can read\n> it here, and see if you like where this is going:\n>\n>\n> https://github.com/bitonic-cjp/lightning-rfc/blob/payment-protocol/12-payment-protocol.md\n>\n>\n> In true permissionless fashion, I have been so bolD to register bolT #12\n> for my idea.\n>\n>\n> Please let me know what you think.\n>\n> kind regards,\n>\n> CJP\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180310/b0f5979c/attachment.html>"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-03-15T15:48:32",
                "message_text_only": "Hi Andy,\n\n\n1. Don't confuse TOR onion routing (used for anonymous/pseudonymous\ncommunication) with Lightning onion routing (used for anonymous\npayments). TOR's design is outside the scope of the discussion; as far\nas I can see, TOR is only relevant because it exists, it works(*) and it\nis useful to us. The \"partial onion route\" is about Lightning's onion\nrouting. You could consider the start of the partial route as an\n\"introduction point\"; it is selected by the payee(**). I'm not sure if\nit is exactly equivalent to TOR's introduction points though.\n\n\n2. Good thinking. I guess that, since either payer *or* payee will\ndecide on the amount, there is no use case for omitting the amount in an\ninvoice in BOLT 12; unlike BOLT 11, it should not be optional here. So\nthat's not a problem for the partial onion route. Unknown capacity is an\nissue, and I guess it's worse than if the payer is completely free to\nchoose a route, because the payer is no longer completely free to choose\nalternative routes. Giving a batch of alternative routes is one concept\n(TBD: can they have the same payment hash?); giving new alternatives\ninteractively is another option. I think using the same \"introduction\npoint\" for all routes is best for privacy: otherwise the payer could\ndetermine the neighborhood of the payee.\n\n\n3. True. Right now I'm thinking in the opposite direction: simplifying\nBOLT 12 by removing the possibility of refunds. We can always add it\nback later (with a proper set of features for all kinds of refunds) as\nan optional feature.\n\n4. This depends on the use case. The URL contains an optional invoice\nID. A payee can request a payment for a specific, single transaction\n(for a single instance of delivery of goods/services) by handing over an\nURL, including an invoice ID, to a single payer. This provides similar\nfunctionality as BOLT 11, except that you now have a well-defined\nchannel for transmitting larger invoice descriptions and for using\npartial onion routes. A payee can also hand over an URL without invoice\nID; this can be used and re-used by one or more payers, whenever they\nwant to perform payments to this payee.\n\nThanks for the questions; I think I can improve my proposal based on\nyour feedback.\n\nWhat should I do with BOLT 12? Have it pulled in\nlightningnetwork/lightning-rfc; maybe in a separate branch? Or first\nwork it out in more detail? How does lightningnetwork/lightning-rfc\ndistinguish between drafts, finished agreed-on specs and things we\ndecided we don't want? Is there even a consensus forming mechanism?\n\nCJP\n\n\n(*) to some degree; there are limits to the privacy provided by TOR.\n\n(**) when extending the current BOLT 12 draft a bit, it might also\noptionally be selected by the payer.\n\n\n\nOp 10-03-18 om 06:16 schreef Andy Schroder:\n> Hello Corn\u00e9,\n>\n> I'm glad to see that someone getting this kind of idea started.\n>\n> I'm still new to some of these topics, but I have a few comments.\n> Hopefully I'm not wasting your time if they are too rudimentary!\n>\n>  1. You mention that the payee gives a URL where the payer can then\n>     connect to to request invoices. You mention that this can be a tor\n>     hidden service if the payee needs to remain private. You also\n>     suggest that the payee can remain private by \"payee can send an\n>     invoice to payer which has a partial onion route as destination\n>     instead of a node ID\". I was reading about tor hidden services\n>     (https://www.torproject.org/docs/onion-services.html.en), and they\n>     require an introduction point, and a rendezvous point. Do we not\n>     need this two step process for the payment route, because we\n>     already have communication initiated over the anonymous\n>     communication channel, and the beginning of the partial onion\n>     route is not publicly available information, and can change with\n>     every invoice?\n>  2. What happens if the capacity of the partial onion route is no\n>     longer sufficient when the payer is ready to pay? Is there a way\n>     to provide a few routes just in case? Or, in the case where no\n>     amount is specified, how is the partial onion route possible if we\n>     don't even know how much capacity may be needed?\n>  3. You say the refund should invalidate the proof of payment of the\n>     initial transaction. What about partial refunds? I think there are\n>     a lot of applications where there would be a partial refund.\n>  4. You say \"this BOLT specifies a protocol where payee gives a URL to\n>     one or more potential payers\". How does the payer identify itself\n>     to the payee so that the payee knows what goods or services that\n>     they want an invoice for? Do they send this after making the\n>     connection, or is it part of the URL?\n>\n>\n>\n>\n> Andy Schroder\n> On 03/08/2018 10:19 AM, Corn\u00e9 Plooy via Lightning-dev wrote:\n>> Hi,\n>>\n>> I was thinking of how to use Lightning for various types of payments,\n>> and I think it's currently fine for customer/(web)shop type\n>> interactions, but it seems a bit inconvenient for other use cases, e.g.\n>> salary payments or direct pay-out of cryptocurrency bought on an\n>> exchange. I came up with an idea that addresses some of these issues and\n>> more (e.g. payee anonymity) by having a direct line of communication\n>> between payer and payee instead of BOLT11-style interaction. It's still\n>> a bit half-baked, with many details not worked out yet, but you can read\n>> it here, and see if you like where this is going:\n>>\n>>\n>> https://github.com/bitonic-cjp/lightning-rfc/blob/payment-protocol/12-payment-protocol.md\n>>\n>>\n>> In true permissionless fashion, I have been so bolD to register bolT #12\n>> for my idea.\n>>\n>>\n>> Please let me know what you think.\n>>\n>> kind regards,\n>>\n>> CJP\n>>\n>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-16T00:31:28",
                "message_text_only": "Good morning Corne,\n\n>     routing. You could consider the start of the partial route as an\n>     \n>     \"introduction point\"; it is selected by the payee(**). I'm not sure if\n>     \n>     it is exactly equivalent to TOR's introduction points though.\n\nIt is almost equivalent I think.\n\n>     \n> 2.  Good thinking. I guess that, since either payer or payee will\n>     \n>     decide on the amount, there is no use case for omitting the amount in an\n>     \n>     invoice in BOLT 12; unlike BOLT 11, it should not be optional here. So\n>     \n>     that's not a problem for the partial onion route. Unknown capacity is an\n>     \n>     issue, and I guess it's worse than if the payer is completely free to\n>     \n>     choose a route, because the payer is no longer completely free to choose\n>     \n>     alternative routes. Giving a batch of alternative routes is one concept\n>     \n>     (TBD: can they have the same payment hash?);\n\nYes. When we retry failing routes, we reuse the payment hash until we succeed to pay, or, give up paying.  This is simply the same concept.\n\n> giving new alternatives\n>     \n>     interactively is another option. I think using the same \"introduction\n>     \n>     point\" for all routes is best for privacy: otherwise the payer could\n>     \n>     determine the neighborhood of the payee.\n\nI wonder.  How does the payer contact the payee in the first place, without having located the neighborhood of the payee?  If it is via some TOR hidden service, and the payee considers this enough protection, why cannot the same TOR hidden service be used as the address of the LN node of the payee (LN protocol spec allows this, current implementations not so much)?  Freenet or I2P, I suppose?\n\n>     \n> 3.  True. Right now I'm thinking in the opposite direction: simplifying\n>     \n>     BOLT 12 by removing the possibility of refunds. We can always add it\n>     \n>     back later (with a proper set of features for all kinds of refunds) as\n>     \n>     an optional feature.\n>     \n> 4.  This depends on the use case. The URL contains an optional invoice\n>     \n>     ID. A payee can request a payment for a specific, single transaction\n>     \n>     (for a single instance of delivery of goods/services) by handing over an\n>     \n>     URL, including an invoice ID, to a single payer. This provides similar\n>     \n>     functionality as BOLT 11, except that you now have a well-defined\n>     \n>     channel for transmitting larger invoice descriptions and for using\n>     \n>     partial onion routes. A payee can also hand over an URL without invoice\n>     \n>     ID; this can be used and re-used by one or more payers, whenever they\n>     \n>     want to perform payments to this payee.\n\nHow does the payer derive the payment hash? Or does the payer have to contact the payee again to get a fresh payment hash specifically for the payer?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andy Schroder",
                "date": "2018-03-16T04:11:31",
                "message_text_only": "Andy Schroder\n\nOn 03/15/2018 08:31 PM, ZmnSCPxj wrote:\n> Good morning Corne,\n>\n>>      routing. You could consider the start of the partial route as an\n>>      \n>>      \"introduction point\"; it is selected by the payee(**). I'm not sure if\n>>      \n>>      it is exactly equivalent to TOR's introduction points though.\n> It is almost equivalent I think.\n\n\nI've been thinking, and start of the payment route has properties of \nboth an introduction point and rendezvous point. The introduction point \nis chosen by the TOR hidden service, and in this case, the start point \nis chosen by the lightning payee (which is hidden if they are operating \nover TOR). The TOR rendezvous point is not known to the public (only the \nclient and the hidden service), and in this case, the start point of the \npayment route is also not known by the public (only the payer and the \npayee if they are operating over TOR to communicate).\n\n\n>\n>>      \n>> 2.  Good thinking. I guess that, since either payer or payee will\n>>      \n>>      decide on the amount, there is no use case for omitting the amount in an\n>>      \n>>      invoice in BOLT 12; unlike BOLT 11, it should not be optional here. So\n>>      \n>>      that's not a problem for the partial onion route. Unknown capacity is an\n>>      \n>>      issue, and I guess it's worse than if the payer is completely free to\n>>      \n>>      choose a route, because the payer is no longer completely free to choose\n>>      \n>>      alternative routes. Giving a batch of alternative routes is one concept\n>>      \n>>      (TBD: can they have the same payment hash?);\n> Yes. When we retry failing routes, we reuse the payment hash until we succeed to pay, or, give up paying.  This is simply the same concept.\n\nWhat about enforcing a maximum payment amount that can be refunded? Can \nthis help make the amount not a requirement? This way the payment amount \nwill still be open to the payer, but it will have a constraint.\n\n\n\n>\n>> giving new alternatives\n>>      \n>>      interactively is another option. I think using the same \"introduction\n>>      \n>>      point\" for all routes is best for privacy: otherwise the payer could\n>>      \n>>      determine the neighborhood of the payee.\n> I wonder.  How does the payer contact the payee in the first place, without having located the neighborhood of the payee?  If it is via some TOR hidden service, and the payee considers this enough protection, why cannot the same TOR hidden service be used as the address of the LN node of the payee (LN protocol spec allows this, current implementations not so much)?  Freenet or I2P, I suppose?\n\nYou're saying that a .onion address is really a public key, so their is \nno reason to include both a public key and a host name?\n\n>\n>>      \n>> 3.  True. Right now I'm thinking in the opposite direction: simplifying\n>>      \n>>      BOLT 12 by removing the possibility of refunds. We can always add it\n>>      \n>>      back later (with a proper set of features for all kinds of refunds) as\n>>      \n>>      an optional feature.\n\n\nI want my refund :-) !\n\nhttp://andyschroder.com/BitcoinVendingDevices/\n\nRusty already suggested that a return onion be supplied for refunds, but \nI'm not sure if he was talking about a partial onion, or a complete \nonion, because that discussion was for the case where the original \npayment was sent directly to a non-anonymous payee.\n\nI think in this case though, were a partial onion route is supplied for \nthe initial payment, the refund payment onion route would have to be a \npartial one.\n\nAll return onions still have the same problem of capacity though.\n\n\n\n\n>>      \n>> 4.  This depends on the use case. The URL contains an optional invoice\n>>      \n>>      ID. A payee can request a payment for a specific, single transaction\n>>      \n>>      (for a single instance of delivery of goods/services) by handing over an\n>>      \n>>      URL, including an invoice ID, to a single payer. This provides similar\n>>      \n>>      functionality as BOLT 11, except that you now have a well-defined\n>>      \n>>      channel for transmitting larger invoice descriptions and for using\n>>      \n>>      partial onion routes. A payee can also hand over an URL without invoice\n>>      \n>>      ID; this can be used and re-used by one or more payers, whenever they\n>>      \n>>      want to perform payments to this payee.\n> How does the payer derive the payment hash? Or does the payer have to contact the payee again to get a fresh payment hash specifically for the payer?\n>\n> Regards,\n> ZmnSCPxj\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-16T10:56:36",
                "message_text_only": "Good morning Andy,\n\n> > > giving new alternatives\n> > > \n> > >      interactively is another option. I think using the same \"introduction\n> > >      \n> > >      point\" for all routes is best for privacy: otherwise the payer could\n> > >      \n> > >      determine the neighborhood of the payee.\n> > >     \n> > \n> > I wonder. How does the payer contact the payee in the first place, without having located the neighborhood of the payee? If it is via some TOR hidden service, and the payee considers this enough protection, why cannot the same TOR hidden service be used as the address of the LN node of the payee (LN protocol spec allows this, current implementations not so much)? Freenet or I2P, I suppose?\n> \n> You're saying that a .onion address is really a public key, so their is\n> \n> no reason to include both a public key and a host name?\n\nIt is a public key hash, yes.  But what I refer to is that the payee-determined route section, which starts from an introduction point, protects the payee from being located by the payer, but how did the payer contact the payee in the first place anyway?  If it was by IP or non-.onion hostname, then the payee has been already located and there is no point in hiding from the payer.  If it was by .onion hostname, then the payee security is bounded by the security of TOR, so it is no more secure for the payee to simply run its LN node on the same .onion address (which LN spec supports) and provide the public key of its LN node.\n\nNote that onion routing on LN in general protects the payer and the payee from being known easily by intermediate hop nodes, and this is the sole intent of onion routing for now.  Presumably the payer knows how to contact the payee (else how would it form a connection to the payee in order to make an interactive request for invoice?).  Presumably if the payee is a merchant, it knows how to send its product to the payer (and thus would know details like the physical address of the payer).  And so on.  The payee-determined route that starts from the introduction point protects the payee from the payer, but does it indeed increase the security or is there some other way to locate the payee anyway?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-03-19T13:59:11",
                "message_text_only": "> It is a public key hash, yes.  But what I refer to is that the payee-determined route section, which starts from an introduction point, protects the payee from being located by the payer, but how did the payer contact the payee in the first place anyway?  If it was by IP or non-.onion hostname, then the payee has been already located and there is no point in hiding from the payer.  If it was by .onion hostname, then the payee security is bounded by the security of TOR, so it is no more secure for the payee to simply run its LN node on the same .onion address (which LN spec supports) and provide the public key of its LN node.\n>\n> Note that onion routing on LN in general protects the payer and the payee from being known easily by intermediate hop nodes, and this is the sole intent of onion routing for now.  Presumably the payer knows how to contact the payee (else how would it form a connection to the payee in order to make an interactive request for invoice?).  Presumably if the payee is a merchant, it knows how to send its product to the payer (and thus would know details like the physical address of the payer).  And so on.  The payee-determined route that starts from the introduction point protects the payee from the payer, but does it indeed increase the security or is there some other way to locate the payee anyway?\nIf that payee has a LN node that is 100% a TOR hidden service, and you\ndon't use a (partially) payee-determined route, the payee has to reveal\nits node ID to the payer. This is not the same as revealing the physical\nidentity of the payee, and having a hidden service may help to keep the\ntwo identities separated, but a LN node is a relatively long-lived\nentity. Over time, the risk increases that knowledge about the node ID\n(e.g. what kinds of transactions are linked to this ID) leaks out and\ngets combined, revealing things you don't want to be revealed.\n\nIt may, for instance, be that some of your incoming transactions are\ninherently linked to your physical identity (e.g. salary), and some\nother you don't want linked to yourself. If you have to reveal your node\nID to all payers, you risk those transactions being linked to you,\neither now or in the future. Running a node as a TOR hidden service is\nnot sufficient. However, if you manage to hide your node ID from payers,\nthis becomes much more difficult; you really gain some privacy.\n\nIn fact, using a TOR hidden service may not always be necessary. In some\ncases, you could alternatively set up payer/payee communication over a\nmore-or-less anonymous physical medium; maybe using a burner phone, WiFi\nwith a randomized MAC address, NFC, or some other kind of radio\ncommunication.\n\nThe alternative approach to partially payee-determined routes would be\nto run different nodes for different identities and to regularly shut\ndown nodes and set up new ones. This requires expensive on-chain actions\nthough (more expensive than setting up a new TOR hidden service), and I\ndon't think it's good for the rest of the network either if channels are\nregularly shut down. I prefer if people can have lots of privacy, even\nwhen running only a single node.\n\nYou could roughly say that TOR is necessary because your IP address can\noften be linked to you, and partially payee-determined routes are\nnecessary because your node ID can often be linked to you.\n\nCJP"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-19T14:27:00",
                "message_text_only": "Good morning Corne,\n\n> > It is a public key hash, yes. But what I refer to is that the payee-determined route section, which starts from an introduction point, protects the payee from being located by the payer, but how did the payer contact the payee in the first place anyway? If it was by IP or non-.onion hostname, then the payee has been already located and there is no point in hiding from the payer. If it was by .onion hostname, then the payee security is bounded by the security of TOR, so it is no more secure for the payee to simply run its LN node on the same .onion address (which LN spec supports) and provide the public key of its LN node.\n> > \n> > Note that onion routing on LN in general protects the payer and the payee from being known easily by intermediate hop nodes, and this is the sole intent of onion routing for now. Presumably the payer knows how to contact the payee (else how would it form a connection to the payee in order to make an interactive request for invoice?). Presumably if the payee is a merchant, it knows how to send its product to the payer (and thus would know details like the physical address of the payer). And so on. The payee-determined route that starts from the introduction point protects the payee from the payer, but does it indeed increase the security or is there some other way to locate the payee anyway?\n> \n> If that payee has a LN node that is 100% a TOR hidden service, and you\n> \n> don't use a (partially) payee-determined route, the payee has to reveal\n> \n> its node ID to the payer. This is not the same as revealing the physical\n> \n> identity of the payee, and having a hidden service may help to keep the\n> \n> two identities separated, but a LN node is a relatively long-lived\n> \n> entity.\n\nThe LN node is long-lived, but the TOR address it uses is not long-lived?  LN nodes need to communicate with counterparties, and if the connection breaks, you need to get in contact again, else the channel is unuseable.\n\nAdmittedly an LN node may change its TOR address by re-gossiping a new TOR address, though, so I suppose that is a possibility.  But that still links LN pubkeys with TOR addresses anyway.\n\nI suppose the use-case here is that the payee uses many TOR addresses with only one LN node.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-03-20T12:59:28",
                "message_text_only": "> I suppose the use-case here is that the payee uses many TOR addresses with only one LN node.\nYes. Use different TOR addresses for things you want to keep separated.\nAny TOR address you advertise for channel connections is so widely\nshared through gossiping that you can in practice consider such an\naddress to be the same identity as your peer ID. For the payer/payee\ncommunication (BOLT 12, and other interfaces such as a website) you\nshould *not* use the same TOR address if you want that activity to\nremain unlinked from your node ID. You could use another TOR address, or\nany other pseudonymous communication method.\n\nDepending on the transport layer you use (TOR or something else) you end\nup with a different type of URL. I think for now it's good enough to\nsupport TCP and TOR.\n\nAnother use case could be to use partial onion routes for payments in\nthe opposite direction. This is, for instance, to refund a payer who\nwishes to remain anonymous. The original payee has an URL (can be TOR\nhidden service, or even regular TCP), and the original payer connects to\nthis (using TOR or another anonymizing medium). The original payer can\nthen remain anonymous by sending an invoice for the refund that uses a\npartial onion route on LN. In this use case, the purpose is to keep the\noriginal payer anonymous (not reveal the node ID), not to keep the\noriginal payee anonymous.\n\nCJP"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-21T04:02:39",
                "message_text_only": "Good morning Corne,\n\n\n\n> > I suppose the use-case here is that the payee uses many TOR addresses with only one LN node.\n> \n> Yes. Use different TOR addresses for things you want to keep separated.\n> \n> Any TOR address you advertise for channel connections is so widely\n> \n> shared through gossiping that you can in practice consider such an\n> \n> address to be the same identity as your peer ID. For the payer/payee\n> \n> communication (BOLT 12, and other interfaces such as a website) you\n> \n> should not use the same TOR address if you want that activity to\n> \n> remain unlinked from your node ID. You could use another TOR address, or\n> \n> any other pseudonymous communication method.\n\nI understand.\n\nI want to bring up another possible privacy break.  Channels can be brought onchain anytime, and any HTLCs pending through that channel will also be brought onchain and will be visible.  This will also publish the `payment_hash`.  A payer observing the chain knows the `payment_hash` it was paying to, can see the HTLC getting claimed and exposing the `payment_hash`, and from the channel signatures knows which nodes were using that channel (if it was a public channel then it has signatures attesting who the nodes participating in it are, from node gossip!).  It can guess that it is likelier than usual that one of the nodes on that channel is the payee, and definitely knows that the channel was part of the payee-provided route.\n\n(using non-public channels helps here in that the payer would have to observe every possible HTLC claim, not just those that it knows are from the public channels on the network, and would be hoping that such an event occurred during its payment: so it would have to devote more bandwidth and processing power searching through all transactions for an HTLC claim that matches its `payment_hash`.  But I think there is no such thing as a truly private channel: each channel has two participants and two can keep a secret only if one of them is dead)\n\nThis is not such a big concern; this is expected to be a rare case and if your node accepts received HTLCs very quickly and has very good uptime it is unlikely to occur in practice.  In addition, once we switch to Scriptless Script (which requires Bellare-Neven signatures to be implemented in some form on the base Bitcoin blockchain layer) this privacy leak disappears (I think... or maybe greatly reduces at least), as even onchain the equivalent to a hashlock is indistinguishable from an ordinary Bellare-Neven m-of-n signature.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andy Schroder",
                "date": "2018-03-21T05:50:43",
                "message_text_only": "Andy Schroder\n\nOn 03/19/2018 09:59 AM, Corn\u00e9 Plooy wrote:\n>> It is a public key hash, yes.  But what I refer to is that the payee-determined route section, which starts from an introduction point, protects the payee from being located by the payer, but how did the payer contact the payee in the first place anyway?  If it was by IP or non-.onion hostname, then the payee has been already located and there is no point in hiding from the payer.  If it was by .onion hostname, then the payee security is bounded by the security of TOR, so it is no more secure for the payee to simply run its LN node on the same .onion address (which LN spec supports) and provide the public key of its LN node.\n>>\n>> Note that onion routing on LN in general protects the payer and the payee from being known easily by intermediate hop nodes, and this is the sole intent of onion routing for now.  Presumably the payer knows how to contact the payee (else how would it form a connection to the payee in order to make an interactive request for invoice?).  Presumably if the payee is a merchant, it knows how to send its product to the payer (and thus would know details like the physical address of the payer).  And so on.  The payee-determined route that starts from the introduction point protects the payee from the payer, but does it indeed increase the security or is there some other way to locate the payee anyway?\n> If that payee has a LN node that is 100% a TOR hidden service, and you\n> don't use a (partially) payee-determined route, the payee has to reveal\n> its node ID to the payer. This is not the same as revealing the physical\n> identity of the payee, and having a hidden service may help to keep the\n> two identities separated, but a LN node is a relatively long-lived\n> entity. Over time, the risk increases that knowledge about the node ID\n> (e.g. what kinds of transactions are linked to this ID) leaks out and\n> gets combined, revealing things you don't want to be revealed.\n>\n> It may, for instance, be that some of your incoming transactions are\n> inherently linked to your physical identity (e.g. salary), and some\n> other you don't want linked to yourself. If you have to reveal your node\n> ID to all payers, you risk those transactions being linked to you,\n> either now or in the future. Running a node as a TOR hidden service is\n> not sufficient. However, if you manage to hide your node ID from payers,\n> this becomes much more difficult; you really gain some privacy.\n>\n> In fact, using a TOR hidden service may not always be necessary. In some\n> cases, you could alternatively set up payer/payee communication over a\n> more-or-less anonymous physical medium; maybe using a burner phone, WiFi\n> with a randomized MAC address, NFC, or some other kind of radio\n> communication.\n\nRegarding NFC and radio communication, I think this would be important \nto bake into the original spec. I'm going to encourage bluetooth over \nwifi with a randomized MAC address. Bluetooth is likely a little better \nbecause you can make a lot of simultaneous bluetooth connections and \nthey don't require you to do any changes to your internet connection, \nwhich you still need in order to interact with the bitcoin and lightning \nnetworks. Bluetooth also makes it simpler for the payee as far as \nlimiting what the payee can use the connection for. I'm guessing you can \nrandomize the bluetooth MAC address.\n\nOne thing for example that makes BIP70 complicated in that regard is \nthat you need to be able to supply a few URLs in order to give the payer \nan option on how they may want to connect to fetch a payment request \n(locally via bluetooth, or over the internet using http). Some hacks \nwere made to BIP70 to make it work with bluetooth, but I'm not sure if \nthe design was the best.\n\n  * Demo using my fuel pump and Bitcoin Wallet\n      o http://andyschroder.com/BitcoinFluidDispenser/2.3/\n          + Watch the first video on this page.\n          + I don't think totally offline payments are possible with\n            lightning, so that part of the workflow isn't comparable.\n  * Details about how Bitcoin Wallet is designed and different ways to\n    communicate with the payee.\n      o https://github.com/AndySchroder/bips/blob/master/tbip-0075.mediawiki\n      o https://github.com/bitcoin-wallet/bitcoin-wallet/wiki/Payment-Requests\n      o Note, the bluetooth communication protocol used here still needs\n        to be encrypted. That extension was never developed.\n\nObviously we aren't going to use BIP70 here for lightning, but my point \nis that there are some lessons that can be learned from the work flow.\n\n\n\n\n>\n> The alternative approach to partially payee-determined routes would be\n> to run different nodes for different identities and to regularly shut\n> down nodes and set up new ones. This requires expensive on-chain actions\n> though (more expensive than setting up a new TOR hidden service), and I\n> don't think it's good for the rest of the network either if channels are\n> regularly shut down.\nDefinitely.\n\n\n>   I prefer if people can have lots of privacy, even\n> when running only a single node.\n>\n> You could roughly say that TOR is necessary because your IP address can\n> often be linked to you, and partially payee-determined routes are\n> necessary because your node ID can often be linked to you.\n>\n> CJP\n>\n>\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180321/2fb57639/attachment-0001.html>"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-03-19T12:06:03",
                "message_text_only": ">\n> What about enforcing a maximum payment amount that can be refunded?\n> Can this help make the amount not a requirement? This way the payment\n> amount will still be open to the payer, but it will have a constraint.\n\nI see no use case anymore for leaving out the amount in the invoice. For\nany type of transaction where the payer decides the amount, he can do so\nby specifying the amount in the invoice request.\n\n>>> \u00a0\u00a0\u00a0\u00a0 3.\u00a0 True. Right now I'm thinking in the opposite direction:\n>>> simplifying\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 BOLT 12 by removing the possibility of refunds. We can\n>>> always add it\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 back later (with a proper set of features for all kinds of\n>>> refunds) as\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 an optional feature.\n>\n>\n> I want my refund :-) !\nI did some further thinking on refunds. Generally speaking, they are a\nsolution for when Transactions Get Messy, right? You agreed to a\ntransaction, the Lightning payment happened, but now you want to change\nsomething. That 'something' can be, for instance, a full refund (e.g. if\ngoods cannot be delivered), a partial refund (e.g. if goods arrived\nlater than agreed, or with inferior quality), an extra payment by the\npayer (e.g. cheaper model out of stock, decided to buy the more\nexpensive one instead), or no payment at all (e.g. payer changes mind\nafter the payment, and wants the black/blue model instead of the\nwhite/gold one, which has the same price).\n\nThere is some similarity between a \"BOLT 12\" transaction that allows\nrefunds and other updates, and a microtransaction channel. Specifically,\nI think you want the new state to be signed by whoever may possibly have\na legitimate interest *against* the update, and you want the old state\nto be invalidated. In BOLT 12, to support this, a state should typically\ncontain the description field, a field that invalidates the previous\nstate, a field that specifies how this state can be invalidated, and\noptionally a payment hash(*), which indicates that this state update is\nvalid only in combination with the corresponding preimage. A transaction\nstarts in a \"null\" state (no obligations between participants), and ends\nspecifying certain obligations that have been fulfilled. TBD: maybe\nreturning to null state by signing off that all obligations have been\nfulfilled? E.g. payer signing off that ordered goods have been received.\nNote that this must be different from canceling the transaction, since\nyou want the payer to keep some kind of proof of ownership. Anyway, I\nthink returning to null state should not be required on BOLT12 protocol\nlevel: not everybody wants this. Some suppliers may want to require it\nthough.\n\nLooking at the protocol for this (generalized) refund usage, it seems\nclear that, often, you don't want to have to keep the communication line\nopen the entire time: it can take days, weeks or longer until the final\nsettlement of a transaction. You should be able to reconnect (typically\nin the same direction as the initial connect) and say \"hey, let's update\nthe state of the transaction to this-or-that\". So, on re-connecting, you\nalso need to be able to specify *which* transaction to update.\n\nThe format of the \"description\" field is unspecified for now; I think\nit's best to keep it that way. Machine-readable formats for this are a\nvery complex subject, better solved at a higher level protocol. For now,\nassume it to be human-readable; maybe add a MIME type field so that its\nformat is both unambiguous (technologically) and upgradeable.\n\nTBD: is there a use case for transactions between more than two parties?\nOr having smart contract (scriptless?) scripts? These would then\ntypically be evaluated by a settlement service provider (e.g. the legal\nsystem) instead of a block chain.\n\n> All return onions still have the same problem of capacity though.\nA partial onion is a very generic solution. If capacity is your greatest\nconcern as payee, you just supply a zero-hop partial onion. Minimum\nprivacy, but maximum ability of the payer to construct a route over\nchannels with sufficient capacity. The choice is yours.\n\n>>> \u00a0\u00a0\u00a0\u00a0 4.\u00a0 This depends on the use case. The URL contains an optional\n>>> invoice\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 ID. A payee can request a payment for a specific, single\n>>> transaction\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 (for a single instance of delivery of goods/services) by\n>>> handing over an\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 URL, including an invoice ID, to a single payer. This\n>>> provides similar\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 functionality as BOLT 11, except that you now have a\n>>> well-defined\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 channel for transmitting larger invoice descriptions and\n>>> for using\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 partial onion routes. A payee can also hand over an URL\n>>> without invoice\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 ID; this can be used and re-used by one or more payers,\n>>> whenever they\n>>> \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 want to perform payments to this payee.\n>> How does the payer derive the payment hash? Or does the payer have to\n>> contact the payee again to get a fresh payment hash specifically for\n>> the payer?\nContact the payee again. Or, more generally, one of them knows how to\ncontact the other to propose updates to the agreement; if the payee of\nthe update agrees, he will provide the payment hash.\n\nCJP\n\n(*) together with amount and timeout: these allow the payer to know\nunder what conditions the payee is likely to release the preimage."
            },
            {
                "author": "Andy Schroder",
                "date": "2018-03-21T05:45:44",
                "message_text_only": "Andy Schroder\n\nOn 03/19/2018 08:06 AM, Corn\u00e9 Plooy wrote:\n>> What about enforcing a maximum payment amount that can be refunded?\n>> Can this help make the amount not a requirement? This way the payment\n>> amount will still be open to the payer, but it will have a constraint.\n> I see no use case anymore for leaving out the amount in the invoice. For\n> any type of transaction where the payer decides the amount, he can do so\n> by specifying the amount in the invoice request.\n\nMaybe you are right.\n\n\n\n>\n>>>>  \u00a0\u00a0\u00a0\u00a0 3.\u00a0 True. Right now I'm thinking in the opposite direction:\n>>>> simplifying\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 BOLT 12 by removing the possibility of refunds. We can\n>>>> always add it\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 back later (with a proper set of features for all kinds of\n>>>> refunds) as\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 an optional feature.\n>>\n>> I want my refund :-) !\n> I did some further thinking on refunds. Generally speaking, they are a\n> solution for when Transactions Get Messy, right? You agreed to a\n> transaction, the Lightning payment happened, but now you want to change\n> something. That 'something' can be, for instance, a full refund (e.g. if\n> goods cannot be delivered), a partial refund (e.g. if goods arrived\n> later than agreed, or with inferior quality), an extra payment by the\n> payer (e.g. cheaper model out of stock, decided to buy the more\n> expensive one instead), or no payment at all (e.g. payer changes mind\n> after the payment, and wants the black/blue model instead of the\n> white/gold one, which has the same price).\n\nDid you take a look a the application in my link? It demonstrates paying \nfor fuel for an automobile with bitcoin using blockchain payments. There \nis first a payment and then the pump powers on. After the person \nfinishes dispensing fuel into their vehicle, it immediately places a \nrefund transaction using the refund address received using the BIP70 \npayment protocol. It even uses NFC and bluetooth instead of QR codes and \nhttp. Most automobile owners have to go through this payment process \nevery 5-15 days if they buy fuel with cash. It's not really a messy \ntransaction and their is no any way to know with much accuracy how much \nfuel they actually need since fuel level gauges in automobiles aren't \nvery inaccurate. And, you can always be filling up some cans of unknown \nsize to take back and refill your tractor, generator, boat, or whatever. \nThis is a situation where you shouldn't need to divulge your identity to \nmake a trivial purchase of a commodity.\n\nOther common examples include making a deposit for a hotel. Normally you \nneed to put something up far beyond the cost of the room rental in order \nto cover any damages you could make to the room. Same goes for renting \nanything really. There are many other little cases where you may need to \nplace a deposit greater than the cost of the good/service you are receiving.\n\n\n>\n> There is some similarity between a \"BOLT 12\" transaction that allows\n> refunds and other updates, and a microtransaction channel. Specifically,\n> I think you want the new state to be signed by whoever may possibly have\n> a legitimate interest *against* the update, and you want the old state\n> to be invalidated. In BOLT 12, to support this, a state should typically\n> contain the description field, a field that invalidates the previous\n> state, a field that specifies how this state can be invalidated, and\n> optionally a payment hash(*), which indicates that this state update is\n> valid only in combination with the corresponding preimage. A transaction\n> starts in a \"null\" state (no obligations between participants), and ends\n> specifying certain obligations that have been fulfilled. TBD: maybe\n> returning to null state by signing off that all obligations have been\n> fulfilled? E.g. payer signing off that ordered goods have been received.\n> Note that this must be different from canceling the transaction, since\n> you want the payer to keep some kind of proof of ownership. Anyway, I\n> think returning to null state should not be required on BOLT12 protocol\n> level: not everybody wants this. Some suppliers may want to require it\n> though.\n>\n> Looking at the protocol for this (generalized) refund usage, it seems\n> clear that, often, you don't want to have to keep the communication line\n> open the entire time: it can take days, weeks or longer until the final\n> settlement of a transaction. You should be able to reconnect (typically\n> in the same direction as the initial connect) and say \"hey, let's update\n> the state of the transaction to this-or-that\". So, on re-connecting, you\n> also need to be able to specify *which* transaction to update.\n\nMakes sense.\n\n>\n> The format of the \"description\" field is unspecified for now; I think\n> it's best to keep it that way. Machine-readable formats for this are a\n> very complex subject, better solved at a higher level protocol. For now,\n> assume it to be human-readable; maybe add a MIME type field so that its\n> format is both unambiguous (technologically) and upgradeable.\n>\n> TBD: is there a use case for transactions between more than two parties?\n> Or having smart contract (scriptless?) scripts? These would then\n> typically be evaluated by a settlement service provider (e.g. the legal\n> system) instead of a block chain.\n\nInteresting thought.\n\n\n\n>\n>> All return onions still have the same problem of capacity though.\n> A partial onion is a very generic solution. If capacity is your greatest\n> concern as payee, you just supply a zero-hop partial onion. Minimum\n> privacy, but maximum ability of the payer to construct a route over\n> channels with sufficient capacity. The choice is yours.\n>\n>>>>  \u00a0\u00a0\u00a0\u00a0 4.\u00a0 This depends on the use case. The URL contains an optional\n>>>> invoice\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 ID. A payee can request a payment for a specific, single\n>>>> transaction\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 (for a single instance of delivery of goods/services) by\n>>>> handing over an\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 URL, including an invoice ID, to a single payer. This\n>>>> provides similar\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 functionality as BOLT 11, except that you now have a\n>>>> well-defined\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 channel for transmitting larger invoice descriptions and\n>>>> for using\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 partial onion routes. A payee can also hand over an URL\n>>>> without invoice\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 ID; this can be used and re-used by one or more payers,\n>>>> whenever they\n>>>>  \u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0 want to perform payments to this payee.\n>>> How does the payer derive the payment hash? Or does the payer have to\n>>> contact the payee again to get a fresh payment hash specifically for\n>>> the payer?\n> Contact the payee again. Or, more generally, one of them knows how to\n> contact the other to propose updates to the agreement; if the payee of\n> the update agrees, he will provide the payment hash.\n>\n> CJP\n>\n> (*) together with amount and timeout: these allow the payer to know\n> under what conditions the payee is likely to release the preimage.\n>\n>\n>"
            }
        ],
        "thread_summary": {
            "title": "A protocol for requesting invoices",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Andy Schroder",
                "Corn\u00e9 Plooy",
                "Melvin Carvalho",
                "ZmnSCPxj"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 55277
        }
    },
    {
        "title": "[Lightning-dev] New form of 51% attack via lightning's revocation system possible?",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-03-13T13:30:21",
                "message_text_only": "Hey everyone,\n\ndisclaimer: as mentioned in my other mail (\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March/001065.html\n) I am currently studying the revocation system of duplex micropayment\nchannels in detail but I am also pretty new to the topic. So I hope the\nattack I am about to describe is not possible and it is just me overseeing\nsome detail or rather my lack of understanding.\nThat being said even after waiting one week upon discovery and double\nchecking the assumptions I made I am still positive that the revocation\nsystem in its current form allows for a new form of a 51% attack. This\nattack seems to be way more harmful than a successful 51% attack on the\nbitcoin network. Afaik within the bitcoin network I could 'only double\nspend' my own funds with a successful 51% attack. In the lightning case it\nseems that an attacker could steal an arbitrary amount of funds as long as\nthe attacker has enough payment channels with enough balance open.\n\nThe attack itself follows exactly the philosophy of lightning: \"If a tree\nfalls in the forest and no one is around to hear it. Does it make a sound?\"\nIn the context of the attack this would translate to: \"If a 51% attacker\nsecretly mines enough blocks after fraudulently spending old commitment\ntransactions and no one sees it during the the *to_self_delay*  period,\nhave the commitment transactions been spent? (How) Can they be revoked?\"\n\n\nAs for the technical details I quote from the spec of BOLT 3:\n\"*To allow an opportunity for penalty transactions, in case of a revoked\ncommitment transaction, all outputs that return funds to the owner of the\ncommitment transaction (a.k.a. the \"local node\") must be delayed for *\n*to_self_delay** blocks. This delay is done in a second-stage HTLC\ntransaction (HTLC-success for HTLCs accepted by the local node,\nHTLC-timeout for HTLCs offered by the local node)*\"\n\nAssume an attacker has 51% of the hash power she could open several\nlightning channels and in particular accept any incoming payment channel\n(the more balance is in her channels the more lucrative the 51% attack).\nSince the attacker already has a lot of hash power it is reasonable (but\nnot necessary) to assume that the attacker already has a lot of bitcoins\nand is well known to honest nodes in the network which makes it even more\nlikely to have many open channels.\n\nThe attacker keeps track of her (revocable) commitment transactions in\nwhich the balance is mostly on the attackers side. Once the attacker knows\nenough of these (old) commitment transactions the attack is being executed\nin the following way:\n0.) The max value of to_self_delay is evaluated. Let us assume it is 72\nblocks (or half a day).\n1.) The attacker secretly starts mining on her own but does not broadcasts\nany successfully mined block. Since the attacker has 51% of the hash power\nshe will most likely be faster than the network to mine the 72 blocks of\nthe safety period in which fraudulent commitment transactions could be\nrevoked.\n2.) The attacker spends all the fraudulent (old) commitment transactions in\nthe first block of her secrete mining endeavor.\n3.) Meanwhile the attacker starts spending her own funds of her payment\nchannels e.g on decentralized exchanges for any other (crypto)currency.\n4.) As soon as the attacker has mined enough blocks that the commitment\ntransactions cannot be revoked she broadcasts her secretly minded\nblockchain which will be accepted by the network as it is the longest\nchain. (In Particular she includes all the other bitcoin transactions that\nare also in the original public blockchain so that other people don't even\nrealize something suspicious has happened.)\n\nSince according to the spec channels should never be balanced worse than\n99% to 1% the attacker could steal up to 99% of all the bitcoins allocated\nin the sum of all payment channels the attacker was connected to. This\namount could obviously be way higher than just double spending her own\nfunds. This attack would be interesting in particular for the power nodes\ncreated by the Barabasi-Albert model of lnd's autopilot (c.f.:\nhttps://github.com/lightningnetwork/lnd/issues/677 ).\n\nI understand that with the growth of the bitcoin (mining) network a 51%\nattack becomes less and less likely. Also I am very happy to be proven\nfalse about the attack that I am describing.\n\nAnother sad thing about this attack is that I currently do not see any\n(reasonable) way of preventing this form of a 51% attack (other than\ncreating payment channels that don't offer the possibility of revocation)\nas it is abusing exactly the core idea of lightning to do something in\nsecret without broadcasting it.\n\nBest regards Rene\n\n---\n\nhttp://www.rene-pickhardt.de\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180313/bb92bcf7/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-13T14:55:10",
                "message_text_only": "Hi Ren\u00e9,\n\nvery good question. I think the simple answer is that this is exactly\nthe reason why not having a participant in the network that can 51%\nattack over a prolonged period is one of the base assumptions in\nLightning. These attacks are deadly to all blockchains, and we are\ncertainly no different in that regard.\n\nMore interesting is the assertion that this may indeed be more dangerous\nthan a classical 51% attack, in which an attacker can only doublespend\nfunds that she had control over at some point during the attack\n(duration being defined as the period she can build a hidden fork of). I\nthink the case for Lightning is not more dangerous since what they could\ndo is enforce an old state in which they had a higher balance than in\nthe final state, without incurring in a penalty. The key observation is\nthat in this old state they actually had to have the balance they are\nstealing on the channel. So this maps directly to the classical\nscenario in which an attacker simply doublespends funds they had control\nover during the attack, making the attack pretty much the same.\n\nAnother interesting observation is that with Lightning the state that\nthe attacker is enforcing may predate the attack, e.g., an attacker\ncould use a state that existed and was replaced before it started\ngenerating its fork. This is in contrast to the classical doublespend\nattack in which invalidated spends have to happen after the fork\nstarted, and the attacker just filters them from its fork.\n\nBut as I said before, if we can't count on there not being a 51%\nattacker, then things are pretty much broken anyway :-)\n\nCheers,\nChristian\n\nRen\u00e9 Pickhardt via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org> writes:\n> Hey everyone,\n>\n> disclaimer: as mentioned in my other mail (\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March/001065.html\n> ) I am currently studying the revocation system of duplex micropayment\n> channels in detail but I am also pretty new to the topic. So I hope the\n> attack I am about to describe is not possible and it is just me overseeing\n> some detail or rather my lack of understanding.\n> That being said even after waiting one week upon discovery and double\n> checking the assumptions I made I am still positive that the revocation\n> system in its current form allows for a new form of a 51% attack. This\n> attack seems to be way more harmful than a successful 51% attack on the\n> bitcoin network. Afaik within the bitcoin network I could 'only double\n> spend' my own funds with a successful 51% attack. In the lightning case it\n> seems that an attacker could steal an arbitrary amount of funds as long as\n> the attacker has enough payment channels with enough balance open.\n>\n> The attack itself follows exactly the philosophy of lightning: \"If a tree\n> falls in the forest and no one is around to hear it. Does it make a sound?\"\n> In the context of the attack this would translate to: \"If a 51% attacker\n> secretly mines enough blocks after fraudulently spending old commitment\n> transactions and no one sees it during the the *to_self_delay*  period,\n> have the commitment transactions been spent? (How) Can they be revoked?\"\n>\n>\n> As for the technical details I quote from the spec of BOLT 3:\n> \"*To allow an opportunity for penalty transactions, in case of a revoked\n> commitment transaction, all outputs that return funds to the owner of the\n> commitment transaction (a.k.a. the \"local node\") must be delayed for *\n> *to_self_delay** blocks. This delay is done in a second-stage HTLC\n> transaction (HTLC-success for HTLCs accepted by the local node,\n> HTLC-timeout for HTLCs offered by the local node)*\"\n>\n> Assume an attacker has 51% of the hash power she could open several\n> lightning channels and in particular accept any incoming payment channel\n> (the more balance is in her channels the more lucrative the 51% attack).\n> Since the attacker already has a lot of hash power it is reasonable (but\n> not necessary) to assume that the attacker already has a lot of bitcoins\n> and is well known to honest nodes in the network which makes it even more\n> likely to have many open channels.\n>\n> The attacker keeps track of her (revocable) commitment transactions in\n> which the balance is mostly on the attackers side. Once the attacker knows\n> enough of these (old) commitment transactions the attack is being executed\n> in the following way:\n> 0.) The max value of to_self_delay is evaluated. Let us assume it is 72\n> blocks (or half a day).\n> 1.) The attacker secretly starts mining on her own but does not broadcasts\n> any successfully mined block. Since the attacker has 51% of the hash power\n> she will most likely be faster than the network to mine the 72 blocks of\n> the safety period in which fraudulent commitment transactions could be\n> revoked.\n> 2.) The attacker spends all the fraudulent (old) commitment transactions in\n> the first block of her secrete mining endeavor.\n> 3.) Meanwhile the attacker starts spending her own funds of her payment\n> channels e.g on decentralized exchanges for any other (crypto)currency.\n> 4.) As soon as the attacker has mined enough blocks that the commitment\n> transactions cannot be revoked she broadcasts her secretly minded\n> blockchain which will be accepted by the network as it is the longest\n> chain. (In Particular she includes all the other bitcoin transactions that\n> are also in the original public blockchain so that other people don't even\n> realize something suspicious has happened.)\n>\n> Since according to the spec channels should never be balanced worse than\n> 99% to 1% the attacker could steal up to 99% of all the bitcoins allocated\n> in the sum of all payment channels the attacker was connected to. This\n> amount could obviously be way higher than just double spending her own\n> funds. This attack would be interesting in particular for the power nodes\n> created by the Barabasi-Albert model of lnd's autopilot (c.f.:\n> https://github.com/lightningnetwork/lnd/issues/677 ).\n>\n> I understand that with the growth of the bitcoin (mining) network a 51%\n> attack becomes less and less likely. Also I am very happy to be proven\n> false about the attack that I am describing.\n>\n> Another sad thing about this attack is that I currently do not see any\n> (reasonable) way of preventing this form of a 51% attack (other than\n> creating payment channels that don't offer the possibility of revocation)\n> as it is abusing exactly the core idea of lightning to do something in\n> secret without broadcasting it.\n>\n> Best regards Rene\n>\n> ---\n>\n> http://www.rene-pickhardt.de\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-03-13T17:07:48",
                "message_text_only": "Hey Christian,\n\nI agree with you on almost anything you said. however I disagree that in\nthe lightning case it produces just another double spending. I wish to to\nemphasize on my statement that the in the case with lightning such a 51%\nattack can steal way more BTC than double spending my own funds. The\nfollowing example is a little extrem and constructed but it should help to\nmake the point. Also for pure convenience reasons I neglected the fact that\nchannels should never be worse distributed than 99% to 1%:\n\nLet us assume I am the attacker currently owning 1000 BTC. Now 1000 nodes\ncalled n_0,...n_{999} open a payment channel with me (all funded by the\nother side with 999 BTC in each channel (and 1 BTC from me)) resulting in\nthe following channel balance sheet:\nc_0: me = 1 BTC and n_0 = 999 BTC\nc_1: me = 1 BTC and n_1 = 999 BTC\nc_2: me = 1 BTC and n_2 = 999 BTC\n...\nc_{999}: me = 1 BTC and n_{999} = 999 BTC\n\nNow node n_0 sends 1 BTC to each node n_1,...,n_{999} (using me for routing\nthe payment) so the channel balances read:\nc_0: me =   1000 BTC and n_0 =       0 BTC (save the corresponding\ncommitment transaction!)\nc_1: me =         0 BTC and n_1 = 1000 BTC\nc_2: me =         0 BTC and n_2 = 1000 BTC\n...\nc_{999}: me=      0 BTC and n_{999} = 1000 BTC\n\nnext n_1 sends 1000 BTC to n_0:\nc_0: me =         0 BTC and n_0 = 1000 BTC\nc_1: me =   1000 BTC and n_1 =        0 BTC  (save the corresponding\ncommitment transaction!)\nc_2: me =         0 BTC and n_2 = 1000 BTC\n...\nc_{999}: me=      0 BTC and n_{999} = 1000 BTC\n\nsimilarly  n_2 sends 1000 BTC to n_1:\nc_0: me =         0 BTC and n_0 = 1000 BTC\nc_1: me =         0 BTC and n_1 = 1000 BTC\nc_2: me =   1000 BTC and n_2 =        0 BTC  (save the corresponding\ncommitment transaction!)\n...\nc_{999}: me =     0 BTC nad n_{999} = 1000 BTC\n\nfollowing this scheme n_3 --[1000 BTC]--> n_2, n_4 --[1000 BTC]--> n_3,...\n\ndue to this (as mentioned highly constructed and artificial behavior) I\nwill have old commitment transactions in *each* and every channel (which\nspends 1000 BTC to me)\n\nWhen starting my secret mining endeavor I spend those commitment\ntransactions which gives in this particular case 1000 * 1000 BTC = 1M BTC\nto me.\n\nSo while I agree that a 51% is a problem for any blockchain technology I\nthink the consequences in the lightning scenario are way more problematic\nand makes such an attack also way more interesting for a dishonest\nfraudulent person / group. In particular I could run for a decade on stable\npayment channels storing old state and at some point realizing it would be\na really big opportunity secretly cashing in all those old transactions\nwhich can't be revoked.\n\nI guess one way of resolving this kind of limitless but rare possibility\nfor stealing could be to make sure no one can have more than 2 or three\ntimes the amount of BTC she owns in all the payment channels the person has\nopen. As funding transactions are publicly visible on the blockchain one\ncould at least use that measure to warn people before opening and funding\nanother payment channel with a node that is heavily underfunded. Also in\nthe sense of network topology such a measure would probably make sure that\nchannels are somewhat equally funded.\n\nbest Rene\n\n\n\n\n\nOn Tue, Mar 13, 2018 at 3:55 PM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> Hi Ren\u00e9,\n>\n> very good question. I think the simple answer is that this is exactly\n> the reason why not having a participant in the network that can 51%\n> attack over a prolonged period is one of the base assumptions in\n> Lightning. These attacks are deadly to all blockchains, and we are\n> certainly no different in that regard.\n>\n> More interesting is the assertion that this may indeed be more dangerous\n> than a classical 51% attack, in which an attacker can only doublespend\n> funds that she had control over at some point during the attack\n> (duration being defined as the period she can build a hidden fork of). I\n> think the case for Lightning is not more dangerous since what they could\n> do is enforce an old state in which they had a higher balance than in\n> the final state, without incurring in a penalty. The key observation is\n> that in this old state they actually had to have the balance they are\n> stealing on the channel. So this maps directly to the classical\n> scenario in which an attacker simply doublespends funds they had control\n> over during the attack, making the attack pretty much the same.\n>\n> Another interesting observation is that with Lightning the state that\n> the attacker is enforcing may predate the attack, e.g., an attacker\n> could use a state that existed and was replaced before it started\n> generating its fork. This is in contrast to the classical doublespend\n> attack in which invalidated spends have to happen after the fork\n> started, and the attacker just filters them from its fork.\n>\n> But as I said before, if we can't count on there not being a 51%\n> attacker, then things are pretty much broken anyway :-)\n>\n> Cheers,\n> Christian\n>\n> Ren\u00e9 Pickhardt via Lightning-dev\n> <lightning-dev at lists.linuxfoundation.org> writes:\n> > Hey everyone,\n> >\n> > disclaimer: as mentioned in my other mail (\n> > https://lists.linuxfoundation.org/pipermail/lightning-dev/\n> 2018-March/001065.html\n> > ) I am currently studying the revocation system of duplex micropayment\n> > channels in detail but I am also pretty new to the topic. So I hope the\n> > attack I am about to describe is not possible and it is just me\n> overseeing\n> > some detail or rather my lack of understanding.\n> > That being said even after waiting one week upon discovery and double\n> > checking the assumptions I made I am still positive that the revocation\n> > system in its current form allows for a new form of a 51% attack. This\n> > attack seems to be way more harmful than a successful 51% attack on the\n> > bitcoin network. Afaik within the bitcoin network I could 'only double\n> > spend' my own funds with a successful 51% attack. In the lightning case\n> it\n> > seems that an attacker could steal an arbitrary amount of funds as long\n> as\n> > the attacker has enough payment channels with enough balance open.\n> >\n> > The attack itself follows exactly the philosophy of lightning: \"If a tree\n> > falls in the forest and no one is around to hear it. Does it make a\n> sound?\"\n> > In the context of the attack this would translate to: \"If a 51% attacker\n> > secretly mines enough blocks after fraudulently spending old commitment\n> > transactions and no one sees it during the the *to_self_delay*  period,\n> > have the commitment transactions been spent? (How) Can they be revoked?\"\n> >\n> >\n> > As for the technical details I quote from the spec of BOLT 3:\n> > \"*To allow an opportunity for penalty transactions, in case of a revoked\n> > commitment transaction, all outputs that return funds to the owner of the\n> > commitment transaction (a.k.a. the \"local node\") must be delayed for *\n> > *to_self_delay** blocks. This delay is done in a second-stage HTLC\n> > transaction (HTLC-success for HTLCs accepted by the local node,\n> > HTLC-timeout for HTLCs offered by the local node)*\"\n> >\n> > Assume an attacker has 51% of the hash power she could open several\n> > lightning channels and in particular accept any incoming payment channel\n> > (the more balance is in her channels the more lucrative the 51% attack).\n> > Since the attacker already has a lot of hash power it is reasonable (but\n> > not necessary) to assume that the attacker already has a lot of bitcoins\n> > and is well known to honest nodes in the network which makes it even more\n> > likely to have many open channels.\n> >\n> > The attacker keeps track of her (revocable) commitment transactions in\n> > which the balance is mostly on the attackers side. Once the attacker\n> knows\n> > enough of these (old) commitment transactions the attack is being\n> executed\n> > in the following way:\n> > 0.) The max value of to_self_delay is evaluated. Let us assume it is 72\n> > blocks (or half a day).\n> > 1.) The attacker secretly starts mining on her own but does not\n> broadcasts\n> > any successfully mined block. Since the attacker has 51% of the hash\n> power\n> > she will most likely be faster than the network to mine the 72 blocks of\n> > the safety period in which fraudulent commitment transactions could be\n> > revoked.\n> > 2.) The attacker spends all the fraudulent (old) commitment transactions\n> in\n> > the first block of her secrete mining endeavor.\n> > 3.) Meanwhile the attacker starts spending her own funds of her payment\n> > channels e.g on decentralized exchanges for any other (crypto)currency.\n> > 4.) As soon as the attacker has mined enough blocks that the commitment\n> > transactions cannot be revoked she broadcasts her secretly minded\n> > blockchain which will be accepted by the network as it is the longest\n> > chain. (In Particular she includes all the other bitcoin transactions\n> that\n> > are also in the original public blockchain so that other people don't\n> even\n> > realize something suspicious has happened.)\n> >\n> > Since according to the spec channels should never be balanced worse than\n> > 99% to 1% the attacker could steal up to 99% of all the bitcoins\n> allocated\n> > in the sum of all payment channels the attacker was connected to. This\n> > amount could obviously be way higher than just double spending her own\n> > funds. This attack would be interesting in particular for the power nodes\n> > created by the Barabasi-Albert model of lnd's autopilot (c.f.:\n> > https://github.com/lightningnetwork/lnd/issues/677 ).\n> >\n> > I understand that with the growth of the bitcoin (mining) network a 51%\n> > attack becomes less and less likely. Also I am very happy to be proven\n> > false about the attack that I am describing.\n> >\n> > Another sad thing about this attack is that I currently do not see any\n> > (reasonable) way of preventing this form of a 51% attack (other than\n> > creating payment channels that don't offer the possibility of revocation)\n> > as it is abusing exactly the core idea of lightning to do something in\n> > secret without broadcasting it.\n> >\n> > Best regards Rene\n> >\n> > ---\n> >\n> > http://www.rene-pickhardt.de\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n\n-- \nwww.rene-pickhardt.de\n<http://www.beijing-china-blog.com/>\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180313/b1e24dd5/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-03-13T18:30:19",
                "message_text_only": "On Tue, Mar 13, 2018 at 06:07:48PM +0100, Ren\u00e9 Pickhardt via Lightning-dev wrote:\n> Hey Christian,\n> I agree with you on almost anything you said. however I disagree that in the\n> lightning case it produces just another double spending. I wish to to emphasize\n> on my statement that the in the case with lightning such a 51% attack can steal\n> way more BTC than double spending my own funds.\n\nI think you can get a simpler example:\n\n * I setup a channel, funding it with 10 BTC (ie, balance is 100% on my side)\n\n * Someone else sets up a channel with me, funding it with 5 BTC\n   (balance is 100% on their side)\n\n * I route 5 BTC to myself from the first channel through the second:\n    aj -> X -> ... -> victim -> aj\n * I save the state that says I own all 5BTC in the victim <-> aj channel\n\n * I route 5 BTC to myself from the second channel throught the first:\n    aj -> victim -> ... -> X -> aj\n * At this point I'm back to having 10 BTC (minus some small amont\n   of lightning fees) in the first channel\n\n * I use 51% hashing power to mine a secret chain that uses the saved\n   state to close the victim<->aj channel. Once that chain is long enough\n   that I can claim the funds I do so. Once I have claimed the funds on\n   my secret chain and the secret chain has more work than the public\n   chain, I publish it, causing a reorg.\n\n * At this point I still have 10 BTC in the original channel, and I have\n   the victim's 5 BTC.\n\nI can parallelise this attack as well: before doing any private mining or\nclosing the victim's channel, I can do the same thing with another victim,\nallowing me to collect old states worth many multiples of up to 10 BTC, and\nmine them at once, leaving with my original 10BTC minus fees, plus n*10BTC\nstolen from victims.\n\nThis becomes more threatening if you add in conspiracy theories about\nthere already being a miner with >51% hashpower, who has financial\ninterests in seeing lightning fail...\n\nThe main limitation is that it still only allows a 51% miner to steal\nfunds from channels they participate in, so creating channels with\nidentifiable entities with whom you have an existing relationship (as\nopposed to picking random anonymous nodes) is a defense against this\nattack. Also, if 51% of hashpower is mining in secret for an extended\nperiod, that may be detectable, which may allow countermeasures to\nbe taken?\n\nYou could also look at this the other way around: at the point when\nlightning is widely deployed, this attack vector seems like it gives an\nimmediate, personal, financial justification for large economic actors\nto ensure that hash rate is very decentralised.\n\n> In particular I could run for a decade on stable payment channels\n> storing old state and at some point realizing it would be a really big\n> opportunity secretly cashing in all those old transactions which can't be\n> revoked.\n\n(I'd find it surprising if many channels stayed open for a decade; if\nnothing else, I'd expect deflation over that time to cause people to\nwant to close channels)\n\nCheers,\naj"
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-13T19:23:10",
                "message_text_only": "Good example, even if rather hard to setup :-)\n\nWhat I meant with the attack being identical is that we can replay the\nentire attack on-chain, without needing Lightning in the first place,\ni.e., the attacker needed to own the funds he is going to steal at some\ntime, whether that is as part of a channel settlement that is repalced\nor an output that has been spent.\n\nYou are however right that Lightning with its multi-hop payments\nincreases the potential exposure of a node, increasing the attackers\npayoff in case of a successful attack.\n\nCheers,\nChristian\n\nRen\u00e9 Pickhardt <r.pickhardt at googlemail.com> writes:\n> Hey Christian,\n>\n> I agree with you on almost anything you said. however I disagree that in\n> the lightning case it produces just another double spending. I wish to to\n> emphasize on my statement that the in the case with lightning such a 51%\n> attack can steal way more BTC than double spending my own funds. The\n> following example is a little extrem and constructed but it should help to\n> make the point. Also for pure convenience reasons I neglected the fact that\n> channels should never be worse distributed than 99% to 1%:\n>\n> Let us assume I am the attacker currently owning 1000 BTC. Now 1000 nodes\n> called n_0,...n_{999} open a payment channel with me (all funded by the\n> other side with 999 BTC in each channel (and 1 BTC from me)) resulting in\n> the following channel balance sheet:\n> c_0: me = 1 BTC and n_0 = 999 BTC\n> c_1: me = 1 BTC and n_1 = 999 BTC\n> c_2: me = 1 BTC and n_2 = 999 BTC\n> ...\n> c_{999}: me = 1 BTC and n_{999} = 999 BTC\n>\n> Now node n_0 sends 1 BTC to each node n_1,...,n_{999} (using me for routing\n> the payment) so the channel balances read:\n> c_0: me =   1000 BTC and n_0 =       0 BTC (save the corresponding\n> commitment transaction!)\n> c_1: me =         0 BTC and n_1 = 1000 BTC\n> c_2: me =         0 BTC and n_2 = 1000 BTC\n> ...\n> c_{999}: me=      0 BTC and n_{999} = 1000 BTC\n>\n> next n_1 sends 1000 BTC to n_0:\n> c_0: me =         0 BTC and n_0 = 1000 BTC\n> c_1: me =   1000 BTC and n_1 =        0 BTC  (save the corresponding\n> commitment transaction!)\n> c_2: me =         0 BTC and n_2 = 1000 BTC\n> ...\n> c_{999}: me=      0 BTC and n_{999} = 1000 BTC\n>\n> similarly  n_2 sends 1000 BTC to n_1:\n> c_0: me =         0 BTC and n_0 = 1000 BTC\n> c_1: me =         0 BTC and n_1 = 1000 BTC\n> c_2: me =   1000 BTC and n_2 =        0 BTC  (save the corresponding\n> commitment transaction!)\n> ...\n> c_{999}: me =     0 BTC nad n_{999} = 1000 BTC\n>\n> following this scheme n_3 --[1000 BTC]--> n_2, n_4 --[1000 BTC]--> n_3,...\n>\n> due to this (as mentioned highly constructed and artificial behavior) I\n> will have old commitment transactions in *each* and every channel (which\n> spends 1000 BTC to me)\n>\n> When starting my secret mining endeavor I spend those commitment\n> transactions which gives in this particular case 1000 * 1000 BTC = 1M BTC\n> to me.\n>\n> So while I agree that a 51% is a problem for any blockchain technology I\n> think the consequences in the lightning scenario are way more problematic\n> and makes such an attack also way more interesting for a dishonest\n> fraudulent person / group. In particular I could run for a decade on stable\n> payment channels storing old state and at some point realizing it would be\n> a really big opportunity secretly cashing in all those old transactions\n> which can't be revoked.\n>\n> I guess one way of resolving this kind of limitless but rare possibility\n> for stealing could be to make sure no one can have more than 2 or three\n> times the amount of BTC she owns in all the payment channels the person has\n> open. As funding transactions are publicly visible on the blockchain one\n> could at least use that measure to warn people before opening and funding\n> another payment channel with a node that is heavily underfunded. Also in\n> the sense of network topology such a measure would probably make sure that\n> channels are somewhat equally funded.\n>\n> best Rene\n>\n>\n>\n>\n>\n> On Tue, Mar 13, 2018 at 3:55 PM, Christian Decker <\n> decker.christian at gmail.com> wrote:\n>\n>> Hi Ren\u00e9,\n>>\n>> very good question. I think the simple answer is that this is exactly\n>> the reason why not having a participant in the network that can 51%\n>> attack over a prolonged period is one of the base assumptions in\n>> Lightning. These attacks are deadly to all blockchains, and we are\n>> certainly no different in that regard.\n>>\n>> More interesting is the assertion that this may indeed be more dangerous\n>> than a classical 51% attack, in which an attacker can only doublespend\n>> funds that she had control over at some point during the attack\n>> (duration being defined as the period she can build a hidden fork of). I\n>> think the case for Lightning is not more dangerous since what they could\n>> do is enforce an old state in which they had a higher balance than in\n>> the final state, without incurring in a penalty. The key observation is\n>> that in this old state they actually had to have the balance they are\n>> stealing on the channel. So this maps directly to the classical\n>> scenario in which an attacker simply doublespends funds they had control\n>> over during the attack, making the attack pretty much the same.\n>>\n>> Another interesting observation is that with Lightning the state that\n>> the attacker is enforcing may predate the attack, e.g., an attacker\n>> could use a state that existed and was replaced before it started\n>> generating its fork. This is in contrast to the classical doublespend\n>> attack in which invalidated spends have to happen after the fork\n>> started, and the attacker just filters them from its fork.\n>>\n>> But as I said before, if we can't count on there not being a 51%\n>> attacker, then things are pretty much broken anyway :-)\n>>\n>> Cheers,\n>> Christian\n>>\n>> Ren\u00e9 Pickhardt via Lightning-dev\n>> <lightning-dev at lists.linuxfoundation.org> writes:\n>> > Hey everyone,\n>> >\n>> > disclaimer: as mentioned in my other mail (\n>> > https://lists.linuxfoundation.org/pipermail/lightning-dev/\n>> 2018-March/001065.html\n>> > ) I am currently studying the revocation system of duplex micropayment\n>> > channels in detail but I am also pretty new to the topic. So I hope the\n>> > attack I am about to describe is not possible and it is just me\n>> overseeing\n>> > some detail or rather my lack of understanding.\n>> > That being said even after waiting one week upon discovery and double\n>> > checking the assumptions I made I am still positive that the revocation\n>> > system in its current form allows for a new form of a 51% attack. This\n>> > attack seems to be way more harmful than a successful 51% attack on the\n>> > bitcoin network. Afaik within the bitcoin network I could 'only double\n>> > spend' my own funds with a successful 51% attack. In the lightning case\n>> it\n>> > seems that an attacker could steal an arbitrary amount of funds as long\n>> as\n>> > the attacker has enough payment channels with enough balance open.\n>> >\n>> > The attack itself follows exactly the philosophy of lightning: \"If a tree\n>> > falls in the forest and no one is around to hear it. Does it make a\n>> sound?\"\n>> > In the context of the attack this would translate to: \"If a 51% attacker\n>> > secretly mines enough blocks after fraudulently spending old commitment\n>> > transactions and no one sees it during the the *to_self_delay*  period,\n>> > have the commitment transactions been spent? (How) Can they be revoked?\"\n>> >\n>> >\n>> > As for the technical details I quote from the spec of BOLT 3:\n>> > \"*To allow an opportunity for penalty transactions, in case of a revoked\n>> > commitment transaction, all outputs that return funds to the owner of the\n>> > commitment transaction (a.k.a. the \"local node\") must be delayed for *\n>> > *to_self_delay** blocks. This delay is done in a second-stage HTLC\n>> > transaction (HTLC-success for HTLCs accepted by the local node,\n>> > HTLC-timeout for HTLCs offered by the local node)*\"\n>> >\n>> > Assume an attacker has 51% of the hash power she could open several\n>> > lightning channels and in particular accept any incoming payment channel\n>> > (the more balance is in her channels the more lucrative the 51% attack).\n>> > Since the attacker already has a lot of hash power it is reasonable (but\n>> > not necessary) to assume that the attacker already has a lot of bitcoins\n>> > and is well known to honest nodes in the network which makes it even more\n>> > likely to have many open channels.\n>> >\n>> > The attacker keeps track of her (revocable) commitment transactions in\n>> > which the balance is mostly on the attackers side. Once the attacker\n>> knows\n>> > enough of these (old) commitment transactions the attack is being\n>> executed\n>> > in the following way:\n>> > 0.) The max value of to_self_delay is evaluated. Let us assume it is 72\n>> > blocks (or half a day).\n>> > 1.) The attacker secretly starts mining on her own but does not\n>> broadcasts\n>> > any successfully mined block. Since the attacker has 51% of the hash\n>> power\n>> > she will most likely be faster than the network to mine the 72 blocks of\n>> > the safety period in which fraudulent commitment transactions could be\n>> > revoked.\n>> > 2.) The attacker spends all the fraudulent (old) commitment transactions\n>> in\n>> > the first block of her secrete mining endeavor.\n>> > 3.) Meanwhile the attacker starts spending her own funds of her payment\n>> > channels e.g on decentralized exchanges for any other (crypto)currency.\n>> > 4.) As soon as the attacker has mined enough blocks that the commitment\n>> > transactions cannot be revoked she broadcasts her secretly minded\n>> > blockchain which will be accepted by the network as it is the longest\n>> > chain. (In Particular she includes all the other bitcoin transactions\n>> that\n>> > are also in the original public blockchain so that other people don't\n>> even\n>> > realize something suspicious has happened.)\n>> >\n>> > Since according to the spec channels should never be balanced worse than\n>> > 99% to 1% the attacker could steal up to 99% of all the bitcoins\n>> allocated\n>> > in the sum of all payment channels the attacker was connected to. This\n>> > amount could obviously be way higher than just double spending her own\n>> > funds. This attack would be interesting in particular for the power nodes\n>> > created by the Barabasi-Albert model of lnd's autopilot (c.f.:\n>> > https://github.com/lightningnetwork/lnd/issues/677 ).\n>> >\n>> > I understand that with the growth of the bitcoin (mining) network a 51%\n>> > attack becomes less and less likely. Also I am very happy to be proven\n>> > false about the attack that I am describing.\n>> >\n>> > Another sad thing about this attack is that I currently do not see any\n>> > (reasonable) way of preventing this form of a 51% attack (other than\n>> > creating payment channels that don't offer the possibility of revocation)\n>> > as it is abusing exactly the core idea of lightning to do something in\n>> > secret without broadcasting it.\n>> >\n>> > Best regards Rene\n>> >\n>> > ---\n>> >\n>> > http://www.rene-pickhardt.de\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n>\n> -- \n> www.rene-pickhardt.de\n> <http://www.beijing-china-blog.com/>\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-14T03:46:11",
                "message_text_only": "Good morning Rene,\n\nThe attack is possible but requires the combination of the below:\n\n1.  A large 51% miner.\n2.  Many channels share-owned by the miner.\n3.  Large capacities in each channel share-owned by the miner.\n\nIndividual nodes can protect against these as below:\n\n1.  Contributing hashpower to a decentralized mining aggregator (e.g. P2Pool).\n2.1.  Disallow more than n channels with a single node, with small n (ideally 1 as c-lightning does).\n2.2.  Insist on a blocksize limit.\n3.  Limit capacities per channel (e.g. 167.77215mBTC max capacity).\n\nAgainst protection #2.1 the attacker can run many nodes, but each node at least consumes some resource that could have been used for e.g. hashing.\n\nAgainst protection #3 the attacker can do nothing; if one side refuses to make larger than 167.77215 mBTC, the channel cannot be established.\n\nThe blocksize limit is important since the number of channels that can be stolen in a single block is bounded by the blocksize.  In combination with channel capacity limit, this increases the number of blocks needed to secretly mine to complete the attack.\n\n* If we impose a limit of 167.77216mBTC per channel, we need 6 channels to steal 1BTC.\n* To steal 1M BTC we need 6 million channels, which cannot fit in a block.\n* About 2000 transactions can fit in a block so that is 2000 channels closed per block.\n* To close 6 million channels you need to secretly mine 3000 blocks, which is about 20 days.\n\nNote that this only *closes* the channels: you also need to claim the commitment transactions, which is another 3000 blocks (an additional 20 or so days).\n\nThus the block size limit and the channel capacity limit are vital protections against this attack.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 13, 2018 9:30 PM, Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey everyone,\n>\n> disclaimer: as mentioned in my other mail ( https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March/001065.html ) I am currently studying the revocation system of duplex micropayment channels in detail but I am also pretty new to the topic. So I hope the attack I am about to describe is not possible and it is just me overseeing some detail or rather my lack of understanding.\n> That being said even after waiting one week upon discovery and double checking the assumptions I made I am still positive that the revocation system in its current form allows for a new form of a 51% attack. This attack seems to be way more harmful than a successful 51% attack on the bitcoin network. Afaik within the bitcoin network I could 'only double spend' my own funds with a successful 51% attack. In the lightning case it seems that an attacker could steal an arbitrary amount of funds as long as the attacker has enough payment channels with enough balance open.\n>\n> The attack itself follows exactly the philosophy of lightning: \"If a tree falls in the forest and no one is around to hear it. Does it make a sound?\"\n> In the context of the attack this would translate to: \"If a 51% attacker secretly mines enough blocks after fraudulently spending old commitment transactions and no one sees it during the the to_self_delay  period, have the commitment transactions been spent? (How) Can they be revoked?\"\n>\n> As for the technical details I quote from the spec of BOLT 3:\n> \"To allow an opportunity for penalty transactions, in case of a revoked commitment transaction, all outputs that return funds to the owner of the commitment transaction (a.k.a. the \"local node\") must be delayed for to_self_delay blocks. This delay is done in a second-stage HTLC transaction (HTLC-success for HTLCs accepted by the local node, HTLC-timeout for HTLCs offered by the local node)\"\n>\n> Assume an attacker has 51% of the hash power she could open several lightning channels and in particular accept any incoming payment channel (the more balance is in her channels the more lucrative the 51% attack). Since the attacker already has a lot of hash power it is reasonable (but not necessary) to assume that the attacker already has a lot of bitcoins and is well known to honest nodes in the network which makes it even more likely to have many open channels.\n>\n> The attacker keeps track of her (revocable) commitment transactions in which the balance is mostly on the attackers side. Once the attacker knows enough of these (old) commitment transactions the attack is being executed in the following way:\n> 0.) The max value of to_self_delay is evaluated. Let us assume it is 72 blocks (or half a day).\n> 1.) The attacker secretly starts mining on her own but does not broadcasts any successfully mined block. Since the attacker has 51% of the hash power she will most likely be faster than the network to mine the 72 blocks of the safety period in which fraudulent commitment transactions could be revoked.\n> 2.) The attacker spends all the fraudulent (old) commitment transactions in the first block of her secrete mining endeavor.\n> 3.) Meanwhile the attacker starts spending her own funds of her payment channels e.g on decentralized exchanges for any other (crypto)currency.\n> 4.) As soon as the attacker has mined enough blocks that the commitment transactions cannot be revoked she broadcasts her secretly minded blockchain which will be accepted by the network as it is the longest chain. (In Particular she includes all the other bitcoin transactions that are also in the original public blockchain so that other people don't even realize something suspicious has happened.)\n>\n> Since according to the spec channels should never be balanced worse than 99% to 1% the attacker could steal up to 99% of all the bitcoins allocated in the sum of all payment channels the attacker was connected to. This amount could obviously be way higher than just double spending her own funds. This attack would be interesting in particular for the power nodes created by the Barabasi-Albert model of lnd's autopilot (c.f.: https://github.com/lightningnetwork/lnd/issues/677 ).\n>\n> I understand that with the growth of the bitcoin (mining) network a 51% attack becomes less and less likely. Also I am very happy to be proven false about the attack that I am describing.\n>\n> Another sad thing about this attack is that I currently do not see any (reasonable) way of preventing this form of a 51% attack (other than creating payment channels that don't offer the possibility of revocation) as it is abusing exactly the core idea of lightning to do something in secret without broadcasting it.\n>\n> Best regards Rene\n>\n> ---\n>\n> http://www.rene-pickhardt.de\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180313/be085197/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "New form of 51% attack via lightning's revocation system possible?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Ren\u00e9 Pickhardt",
                "ZmnSCPxj",
                "Christian Decker"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 43648
        }
    },
    {
        "title": "[Lightning-dev] DNS Seed query semantics clarification",
        "thread_messages": [
            {
                "author": "Thomas Steenholdt",
                "date": "2018-03-14T17:45:07",
                "message_text_only": "Hi there,\n\n\nI'm trying to understand the DNS seeds described by BOLT10, but seem to be missing something regarding the query semantics.\n\n\nThe BOLT states that the DNS seed must support a list of key-value pairs, but it's unclear to me how these pairs are used in a query. Are they encoded into the fqdn used in the query or something entirely different?\n\n\nAny pointers?\n\n\n/Thomas\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180314/2a67c791/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-16T12:37:17",
                "message_text_only": "Hi Thomas,\n\nindeed the spec is a bit vague on the flags. The intent is to use them\nas subdomains. For example if you want to query for only realm IPv4\nnodes then you'd use the following:\n\n  dig a2.seed.bitcoinstats.com\n\nwhile IPv4 or IPv6 nodes, but only nodes with realm 0, should be\nreturned to the following:\n\n  dig r0.a6.seed.bitcoinstats.com\n\nNotice however that I haven't implemented the query filtering itself\njust yet.\n\nCheers,\nChristian\n\nThomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> writes:\n> Hi there,\n>\n>\n> I'm trying to understand the DNS seeds described by BOLT10, but seem to be missing something regarding the query semantics.\n>\n>\n> The BOLT states that the DNS seed must support a list of key-value pairs, but it's unclear to me how these pairs are used in a query. Are they encoded into the fqdn used in the query or something entirely different?\n>\n>\n> Any pointers?\n>\n>\n> /Thomas"
            },
            {
                "author": "Thomas Steenholdt",
                "date": "2018-03-16T13:06:28",
                "message_text_only": "Hi Christian,\n\nThanks for the explanation - This was exactly the the piece of the puzzle I was missing. \ud83d\ude0a\n\nI'd be happy to help clarify this in the BOLT10 specification, if that makes any type of sense? I can make a pull request for review?\n\n/Thomas\n\n\n________________________________\nFrom: Christian Decker <decker.christian at gmail.com>\nSent: Friday, March 16, 2018 9:37:17 AM\nTo: Thomas Steenholdt\nCc: lightning-dev at lists.linuxfoundation.org\nSubject: Re: DNS Seed query semantics clarification\n\nHi Thomas,\n\nindeed the spec is a bit vague on the flags. The intent is to use them\nas subdomains. For example if you want to query for only realm IPv4\nnodes then you'd use the following:\n\n  dig a2.seed.bitcoinstats.com\n\nwhile IPv4 or IPv6 nodes, but only nodes with realm 0, should be\nreturned to the following:\n\n  dig r0.a6.seed.bitcoinstats.com\n\nNotice however that I haven't implemented the query filtering itself\njust yet.\n\nCheers,\nChristian\n\nThomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> writes:\n> Hi there,\n>\n>\n> I'm trying to understand the DNS seeds described by BOLT10, but seem to be missing something regarding the query semantics.\n>\n>\n> The BOLT states that the DNS seed must support a list of key-value pairs, but it's unclear to me how these pairs are used in a query. Are they encoded into the fqdn used in the query or something entirely different?\n>\n>\n> Any pointers?\n>\n>\n> /Thomas\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180316/e4a9d867/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-16T13:44:01",
                "message_text_only": "Thomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> writes:\n> Thanks for the explanation - This was exactly the the piece of the\n> puzzle I was missing. \ud83d\ude0a\n>\n> I'd be happy to help clarify this in the BOLT10 specification, if that\n> makes any type of sense? I can make a pull request for revie\n\nAbsolutely, improvements are always welcome :-)"
            },
            {
                "author": "Thomas Steenholdt",
                "date": "2018-03-20T11:26:58",
                "message_text_only": "Cool,\n\nSince we're trying to clarify some of the things that may not be entirely clear, there are a few other things it may be relevant to address or define at the same time:\n\n  1.  What's the intended direction of interpreting the conditions?\n  2.  What's the result of the conflict if a condition is specified multiple times?\n\nSo using the thought-up case of r0.a2.n5.a4.n10.seed.example.com:\n\n  1.  Should the DNS seed process the conditions from the seed root and \"up the tree\" or in the opposite direction?\n\nFor the sake of argument, I'm going to assume we want to take a (DNS-wise) logical approach, i.e. interpreting from the seed root and \"up the tree\", so in the order: n10, a4, n5, a2, r0.\n\n  1.  What happens to a2 when we meet a4? Should a4 replace any current a condition or simply be ignored (or in the case of a perhaps even merged through a bitwise or)? Same question for n5when we meet n10.\n\nPersonally I think it would make sense to always replace currently set conditions, when we hit new conditions with the same key. This would allow us to easily add a condition to a query programmatically, without having to interpret any conditions that may be set already. Prepending a current query string with a6. would then guarantee that an earlier condition does not limit my results to either IPv4 or IPv6 nodes. As long as the length of the query string does not exceed a total of 253 chars (standard DNS limitation, not counting the root .).\n\nAny thoughts on this?\n\n\n/Thomas\n\n________________________________\nFrom: Christian Decker <decker.christian at gmail.com>\nSent: Friday, March 16, 2018 10:44:01 AM\nTo: Thomas Steenholdt\nCc: lightning-dev at lists.linuxfoundation.org\nSubject: Re: DNS Seed query semantics clarification\n\nThomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> writes:\n> Thanks for the explanation - This was exactly the the piece of the\n> puzzle I was missing. \ud83d\ude0a\n>\n> I'd be happy to help clarify this in the BOLT10 specification, if that\n> makes any type of sense? I can make a pull request for revie\n\nAbsolutely, improvements are always welcome :-)\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180320/6629603d/attachment.html>"
            },
            {
                "author": "Thomas Steenholdt",
                "date": "2018-03-23T13:06:47",
                "message_text_only": "Hi guys,\n\n\nI have proposed an update to BOLT #10 in pull request #396, in an attempt to address these things.\n\n\nAny feedback is welcome.\n\n\n/Thomas\n\n________________________________\nFrom: lightning-dev-bounces at lists.linuxfoundation.org <lightning-dev-bounces at lists.linuxfoundation.org> on behalf of Thomas Steenholdt <TSteenholdt at cascadetechnologypartners.com>\nSent: Tuesday, March 20, 2018 8:26:58 AM\nTo: Christian Decker\nCc: lightning-dev at lists.linuxfoundation.org\nSubject: Re: [Lightning-dev] DNS Seed query semantics clarification\n\n\nCool,\n\nSince we're trying to clarify some of the things that may not be entirely clear, there are a few other things it may be relevant to address or define at the same time:\n\n  1.  What's the intended direction of interpreting the conditions?\n  2.  What's the result of the conflict if a condition is specified multiple times?\n\nSo using the thought-up case of r0.a2.n5.a4.n10.seed.example.com:\n\n  1.  Should the DNS seed process the conditions from the seed root and \"up the tree\" or in the opposite direction?\n\nFor the sake of argument, I'm going to assume we want to take a (DNS-wise) logical approach, i.e. interpreting from the seed root and \"up the tree\", so in the order: n10, a4, n5, a2, r0.\n\n  1.  What happens to a2 when we meet a4? Should a4 replace any current a condition or simply be ignored (or in the case of a perhaps even merged through a bitwise or)? Same question for n5when we meet n10.\n\nPersonally I think it would make sense to always replace currently set conditions, when we hit new conditions with the same key. This would allow us to easily add a condition to a query programmatically, without having to interpret any conditions that may be set already. Prepending a current query string with a6. would then guarantee that an earlier condition does not limit my results to either IPv4 or IPv6 nodes. As long as the length of the query string does not exceed a total of 253 chars (standard DNS limitation, not counting the root .).\n\nAny thoughts on this?\n\n\n/Thomas\n\n________________________________\nFrom: Christian Decker <decker.christian at gmail.com>\nSent: Friday, March 16, 2018 10:44:01 AM\nTo: Thomas Steenholdt\nCc: lightning-dev at lists.linuxfoundation.org\nSubject: Re: DNS Seed query semantics clarification\n\nThomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> writes:\n> Thanks for the explanation - This was exactly the the piece of the\n> puzzle I was missing. \ud83d\ude0a\n>\n> I'd be happy to help clarify this in the BOLT10 specification, if that\n> makes any type of sense? I can make a pull request for revie\n\nAbsolutely, improvements are always welcome :-)\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180323/7ef3b163/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "DNS Seed query semantics clarification",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Thomas Steenholdt"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 8554
        }
    },
    {
        "title": "[Lightning-dev] Cyclic Superhubs",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-16T01:53:28",
                "message_text_only": "Good morning list,\n\nFor your amusement.\n\nhttps://zmnscpxj.github.io/offchain/cyclicsuperhubs.html\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180315/5929bdc0/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Cyclic Superhubs",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 306
        }
    },
    {
        "title": "[Lightning-dev] Can I try Lightning without running a fully-fledged bitcoin block chain?",
        "thread_messages": [
            {
                "author": "Yubin Ruan",
                "date": "2018-03-17T09:02:39",
                "message_text_only": "I just don't have so much space for a storing the whole blockchain on my\nlaptop.\n\nYubin\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 473 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180317/e53c62ae/attachment-0001.sig>"
            },
            {
                "author": "Federico Tenga",
                "date": "2018-03-17T10:56:05",
                "message_text_only": "You can try pruning, you will still have to validate the whole chain so it\ntakes time, but you won't need to store all the blockchain on your disk.\n\nOn 17 March 2018 at 10:02, Yubin Ruan <ablacktshirt at gmail.com> wrote:\n\n> I just don't have so much space for a storing the whole blockchain on my\n> laptop.\n>\n> Yubin\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180317/870e7667/attachment.html>"
            },
            {
                "author": "Aleksej",
                "date": "2018-03-17T12:59:39",
                "message_text_only": "I don't see why running a pruning node wouldn't work.\nYou might want to try that.\n\nAleksej\n\nOn Sat, 2018-03-17 at 17:02 +0800, Yubin Ruan wrote:\n> I just don't have so much space for a storing the whole blockchain on\n> my\n> laptop.\n> \n> Yubin\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-18T04:57:04",
                "message_text_only": "Good morning Aleksej and Yubin,\n\nC-lightning is currently known to NOT work with a pruning bitcoind.\n\nlnd has a neutrino mode which is a SPV mode, but neutrino protocol to my knowledge is not in official bitcoind yet (but I have not checked, possibly I am wrong), so you will need to peer with neutrino-supporting bitcoin peer.\n\nRegards,\nZmnSCPxj\n\n\n\u200bSent with ProtonMail Secure Email.\u200b\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n\nOn March 17, 2018 8:59 PM, Aleksej <aleksej at spidermail.tk> wrote:\n\n> I don't see why running a pruning node wouldn't work.\n> \n> You might want to try that.\n> \n> Aleksej\n> \n> On Sat, 2018-03-17 at 17:02 +0800, Yubin Ruan wrote:\n> \n> > I just don't have so much space for a storing the whole blockchain on\n> > \n> > my\n> > \n> > laptop.\n> > \n> > Yubin\n> > \n> > Lightning-dev mailing list\n> > \n> > Lightning-dev at lists.linuxfoundation.org\n> > \n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n> Lightning-dev mailing list\n> \n> Lightning-dev at lists.linuxfoundation.org\n> \n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Segue",
                "date": "2018-03-27T03:26:53",
                "message_text_only": "Developers,\n\nOn THIS note and slightly off-topic but relevant, why can't chunks of \nblockchain peel off the backend periodically and be archived, say on \nminimum of 150 computers across 7 continents?\n\nIt seems crazy to continue adding on to an increasingly long chain to \ninfinity if the old chapters (i.e. more than, say, 2 years old) could be \nstored in an evenly distributed manner across the planet.\u00a0 The same 150 \ncomputers would not need to store every chapter either, just the index \nwould need to be widely distributed in order to reconnect with a chapter \nif needed.\n\nThen maybe it is no longer a limitation in the future for people like Yubin.\n\nSegue\n\n\nOn 3/26/18 6:12 PM, lightning-dev-request at lists.linuxfoundation.org wrote:\n> Message: 2\n> Date: Sat, 17 Mar 2018 11:56:05 +0100\n> From: Federico Tenga<federicotenga at gmail.com>\n> To: Yubin Ruan<ablacktshirt at gmail.com>\n> Cc:lightning-dev at lists.linuxfoundation.org\n> Subject: Re: [Lightning-dev] Can I try Lightning without running a\n> \tfully-fledged bitcoin block chain?\n> Message-ID:\n> \t<CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> You can try pruning, you will still have to validate the whole chain so it\n> takes time, but you won't need to store all the blockchain on your disk.\n>\n> On 17 March 2018 at 10:02, Yubin Ruan<ablacktshirt at gmail.com>  wrote:\n>\n>> I just don't have so much space for a storing the whole blockchain on my\n>> laptop.\n>>\n>> Yubin\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180326/89867f22/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-28T05:00:49",
                "message_text_only": "Good morning Segue,\n\nPlease consider creating an implementation of this idea for bitcoind and share it on bitcoin-dev.  Then please make a pull request on github.com/bitcoin/bitcoin for this.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 27, 2018 11:26 AM, Segue <012mistery at frankentrikes.com> wrote:\n\n> Developers,\n>\n> On THIS note and slightly off-topic but relevant, why can't chunks of blockchain peel off the backend periodically and be archived, say on minimum of 150 computers across 7 continents?\n>\n> It seems crazy to continue adding on to an increasingly long chain to infinity if the old chapters (i.e. more than, say, 2 years old) could be stored in an evenly distributed manner across the planet.  The same 150 computers would not need to store every chapter either, just the index would need to be widely distributed in order to reconnect with a chapter if needed.\n>\n> Then maybe it is no longer a limitation in the future for people like Yubin.\n>\n> Segue\n>\n> On 3/26/18 6:12 PM, lightning-dev-request at lists.linuxfoundation.org wrote:\n>\n>> Message: 2\n>> Date: Sat, 17 Mar 2018 11:56:05 +0100\n>> From: Federico Tenga\n>> [<federicotenga at gmail.com>](mailto:federicotenga at gmail.com)\n>> To: Yubin Ruan\n>> [<ablacktshirt at gmail.com>](mailto:ablacktshirt at gmail.com)\n>> Cc:\n>> lightning-dev at lists.linuxfoundation.org\n>> Subject: Re: [Lightning-dev] Can I try Lightning without running a\n>>\tfully-fledged bitcoin block chain?\n>> Message-ID:\n>> [<CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com>](mailto:CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com)\n>> Content-Type: text/plain; charset=\"utf-8\"\n>>\n>> You can try pruning, you will still have to validate the whole chain so it\n>> takes time, but you won't need to store all the blockchain on your disk.\n>>\n>> On 17 March 2018 at 10:02, Yubin Ruan\n>> [<ablacktshirt at gmail.com>](mailto:ablacktshirt at gmail.com)\n>> wrote:\n>>\n>>> I just don't have so much space for a storing the whole blockchain on my\n>>> laptop.\n>>>\n>>> Yubin\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>>\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180328/eb9af9ed/attachment-0001.html>"
            },
            {
                "author": "Mahesh Govind",
                "date": "2018-03-28T08:21:34",
                "message_text_only": "Could we use similar technique used in hyperledger to prune the chain .\nPruning based on consensus ?\n-mahesh\n\nOn Wed, Mar 28, 2018 at 10:30 AM, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Segue,\n>\n> Please consider creating an implementation of this idea for bitcoind and\n> share it on bitcoin-dev.  Then please make a pull request on\n> github.com/bitcoin/bitcoin for this.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On March 27, 2018 11:26 AM, Segue <012mistery at frankentrikes.com> wrote:\n>\n> Developers,\n>\n>\n> On THIS note and slightly off-topic but relevant, why can't chunks of\n> blockchain peel off the backend periodically and be archived, say on\n> minimum of 150 computers across 7 continents?\n>\n> It seems crazy to continue adding on to an increasingly long chain to\n> infinity if the old chapters (i.e. more than, say, 2 years old) could be\n> stored in an evenly distributed manner across the planet.  The same 150\n> computers would not need to store every chapter either, just the index\n> would need to be widely distributed in order to reconnect with a chapter if\n> needed.\n>\n> Then maybe it is no longer a limitation in the future for people like\n> Yubin.\n>\n> Segue\n>\n>\n>\n> On 3/26/18 6:12 PM, lightning-dev-request at lists.linuxfoundation.org wrote:\n>\n> Message: 2\n> Date: Sat, 17 Mar 2018 11:56:05 +0100\n> From: Federico Tenga <federicotenga at gmail.com> <federicotenga at gmail.com>\n> To: Yubin Ruan <ablacktshirt at gmail.com> <ablacktshirt at gmail.com>\n> Cc: lightning-dev at lists.linuxfoundation.org\n> Subject: Re: [Lightning-dev] Can I try Lightning without running a\n> \tfully-fledged bitcoin block chain?\n> Message-ID:\n> \t<CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com> <CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> You can try pruning, you will still have to validate the whole chain so it\n> takes time, but you won't need to store all the blockchain on your disk.\n>\n> On 17 March 2018 at 10:02, Yubin Ruan <ablacktshirt at gmail.com> <ablacktshirt at gmail.com> wrote:\n>\n>\n> I just don't have so much space for a storing the whole blockchain on my\n> laptop.\n>\n> Yubin\n>\n> _______________________________________________\n> Lightning-dev mailing listLightning-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180328/423ff422/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-30T14:06:27",
                "message_text_only": "Dear Mahesh,\n\nas interesting as the discussion of alternative blockchain storage it,\nit is probably off-topic for the Lightning mailing list. So I'd suggest\ntaking this discussion to either the bitcoin-dev or bitcoin-core-dev\nmailing lists.\n\nCheers,\nChristian\n\nMahesh Govind <mahesh at digiledge.com> writes:\n> Could we use similar technique used in hyperledger to prune the chain .\n> Pruning based on consensus ?\n> -mahesh\n>\n> On Wed, Mar 28, 2018 at 10:30 AM, ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Good morning Segue,\n>>\n>> Please consider creating an implementation of this idea for bitcoind and\n>> share it on bitcoin-dev.  Then please make a pull request on\n>> github.com/bitcoin/bitcoin for this.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>>\n>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On March 27, 2018 11:26 AM, Segue <012mistery at frankentrikes.com> wrote:\n>>\n>> Developers,\n>>\n>>\n>> On THIS note and slightly off-topic but relevant, why can't chunks of\n>> blockchain peel off the backend periodically and be archived, say on\n>> minimum of 150 computers across 7 continents?\n>>\n>> It seems crazy to continue adding on to an increasingly long chain to\n>> infinity if the old chapters (i.e. more than, say, 2 years old) could be\n>> stored in an evenly distributed manner across the planet.  The same 150\n>> computers would not need to store every chapter either, just the index\n>> would need to be widely distributed in order to reconnect with a chapter if\n>> needed.\n>>\n>> Then maybe it is no longer a limitation in the future for people like\n>> Yubin.\n>>\n>> Segue\n>>\n>>\n>>\n>> On 3/26/18 6:12 PM, lightning-dev-request at lists.linuxfoundation.org wrote:\n>>\n>> Message: 2\n>> Date: Sat, 17 Mar 2018 11:56:05 +0100\n>> From: Federico Tenga <federicotenga at gmail.com> <federicotenga at gmail.com>\n>> To: Yubin Ruan <ablacktshirt at gmail.com> <ablacktshirt at gmail.com>\n>> Cc: lightning-dev at lists.linuxfoundation.org\n>> Subject: Re: [Lightning-dev] Can I try Lightning without running a\n>> \tfully-fledged bitcoin block chain?\n>> Message-ID:\n>> \t<CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com> <CAP=-fx4APtKw-x08kQ_+y7bEh-EbGfPmSCGQDBrZn0Fh-NNjAQ at mail.gmail.com>\n>> Content-Type: text/plain; charset=\"utf-8\"\n>>\n>> You can try pruning, you will still have to validate the whole chain so it\n>> takes time, but you won't need to store all the blockchain on your disk.\n>>\n>> On 17 March 2018 at 10:02, Yubin Ruan <ablacktshirt at gmail.com> <ablacktshirt at gmail.com> wrote:\n>>\n>>\n>> I just don't have so much space for a storing the whole blockchain on my\n>> laptop.\n>>\n>> Yubin\n>>\n>> _______________________________________________\n>> Lightning-dev mailing listLightning-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Can I try Lightning without running a fully-fledged bitcoin block chain?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Aleksej",
                "Segue",
                "Federico Tenga",
                "Yubin Ruan",
                "Mahesh Govind",
                "ZmnSCPxj"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 13215
        }
    },
    {
        "title": "[Lightning-dev] High level fee mechanics",
        "thread_messages": [
            {
                "author": "Thomas Steenholdt",
                "date": "2018-03-18T22:24:07",
                "message_text_only": "Hi,\n\n\nI've been trying to figure out the mechanics of Lightning fees, especially in the case of routed payments. Unfortunately, I haven't had any success in finding a high level description on the topic.\n\n\nI'm hoping somebody is able to point me in the right direction?\n\n\nExample:\n\nA multi-hop routed payment where A needs to pay D through B and C. Established channels are A -> B -> C -> D.\n\n\nWhat I'm looking for is a high level explanation of how fees are established, announced and ultimately claimed in a payment like this. Some of the questions that come to mind are:\n\n\n- Does A know ahead of time the fees on B and C, or only when trying to set up the payment? And how?\n\n- How does A know the amount of fees that need to be added to the payment to cover all fees?\n\n- Is D aware of the full amount including fees or is that somehow hidden?\n\n- How are the fees actually claimed (who ends up paying whom)?\n\n\nThanks in advance.\n\n\n/Thomas\n\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180318/1b9879d6/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-18T23:48:57",
                "message_text_only": "Good morning Thomas,\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 19, 2018 6:24 AM, Thomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> wrote:\n\n> Hi,\n>\n> I've been trying to figure out the mechanics of Lightning fees, especially in the case of routed payments. Unfortunately, I haven't had any success in finding a high level description on the topic.\n>\n> I'm hoping somebody is able to point me in the right direction?\n\nBOLT spec https://github.com/lightningnetwork/lightning-rfc contains everything, but is very detailed and contains the topic in multiple places.\n\n> Example:\n>\n> A multi-hop routed payment where A needs to pay D through B and C. Established channels are A -> B -> C -> D.\n>\n> What I'm looking for is a high level explanation of how fees are established, announced and ultimately claimed in a payment like this. Some of the questions that come to mind are:\n>\n> - Does A know ahead of time the fees on B and C, or only when trying to set up the payment? And how?\n\nYes.  Node gossip, the `channel_update` message in BOLT#7.  This message, contains `fee_base_msat` and `fee_proportional_millionths`.  For each channel, there are two `channel_update` messages, one from each direction.  For example B<->C channel, B announces its fee for B->C transfers while C announnces its fee for C->B transfers.\n\nThe A may have obsolete information about fees (e.g. B or C change their fee but their `channel_update` has not propagated to A yet).  In this case, payment routing will fail, but the `channel_update` will also be sent as part of the error message returned by payment routing failure.\n\n> - How does A know the amount of fees that need to be added to the payment to cover all fees?\n\nIt computes it.  If D is to be given a payment with value `msatoshi` then it computes first the C->D fee, which is the C->D `fee_base_msat` +  (C->D `fee_proportion_millionts` * `msatoshi` / 1,000,000).  Add that to `msatoshi` and that is the payment that needs to reach C, so A computes the payment from B->C similarly, except the `msatoshi` is replaced with the payment that should reach C.  Then A knows how much it has to give to B.\n\n> - Is D aware of the full amount including fees or is that somehow hidden?\n\nNo.  D is only aware of how much C offers it.\n\n> - How are the fees actually claimed (who ends up paying whom)?\n\nA offer B a value that is higher than what A instruct B to forward to C.  The difference is the fee.  Since the highest value is at the source A, A is the one, who ends up paying the entire fee.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180318/f73857f7/attachment-0001.html>"
            },
            {
                "author": "Thomas Steenholdt",
                "date": "2018-03-19T11:30:35",
                "message_text_only": "Hi ZmnSCPxj,\n\n\nThank you so much - Exactly what I needed! \ud83d\ude0a\n\n\n/Thomas\n\n________________________________\nFrom: ZmnSCPxj <ZmnSCPxj at protonmail.com>\nSent: Sunday, March 18, 2018 8:48:57 PM\nTo: Thomas Steenholdt\nCc: lightning-dev at lists.linuxfoundation.org\nSubject: Re: [Lightning-dev] High level fee mechanics\n\nGood morning Thomas,\n\n\nSent with ProtonMail<https://protonmail.com> Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 19, 2018 6:24 AM, Thomas Steenholdt <TSteenholdt at cascadetechnologypartners.com> wrote:\n\n\nHi,\n\n\nI've been trying to figure out the mechanics of Lightning fees, especially in the case of routed payments. Unfortunately, I haven't had any success in finding a high level description on the topic.\n\n\n\nI'm hoping somebody is able to point me in the right direction?\n\nBOLT spec https://github.com/lightningnetwork/lightning-rfc contains everything, but is very detailed and contains the topic in multiple places.\n\n\n\nExample:\n\nA multi-hop routed payment where A needs to pay D through B and C. Established channels are A -> B -> C -> D.\n\n\n\nWhat I'm looking for is a high level explanation of how fees are established, announced and ultimately claimed in a payment like this. Some of the questions that come to mind are:\n\n\n- Does A know ahead of time the fees on B and C, or only when trying to set up the payment? And how?\n\nYes.  Node gossip, the `channel_update` message in BOLT#7.  This message, contains `fee_base_msat` and `fee_proportional_millionths`.  For each channel, there are two `channel_update` messages, one from each direction.  For example B<->C channel, B announces its fee for B->C transfers while C announnces its fee for C->B transfers.\n\nThe A may have obsolete information about fees (e.g. B or C change their fee but their `channel_update` has not propagated to A yet).  In this case, payment routing will fail, but the `channel_update` will also be sent as part of the error message returned by payment routing failure.\n\n\n- How does A know the amount of fees that need to be added to the payment to cover all fees?\n\nIt computes it.  If D is to be given a payment with value `msatoshi` then it computes first the C->D fee, which is the C->D `fee_base_msat` +  (C->D `fee_proportion_millionts` * `msatoshi` / 1,000,000).  Add that to `msatoshi` and that is the payment that needs to reach C, so A computes the payment from B->C similarly, except the `msatoshi` is replaced with the payment that should reach C.  Then A knows how much it has to give to B.\n\n\n- Is D aware of the full amount including fees or is that somehow hidden?\n\nNo.  D is only aware of how much C offers it.\n\n\n- How are the fees actually claimed (who ends up paying whom)?\n\nA offer B a value that is higher than what A instruct B to forward to C.  The difference is the fee.  Since the highest value is at the source A, A is the one, who ends up paying the entire fee.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180319/9d31d0d1/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "High level fee mechanics",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Thomas Steenholdt"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7030
        }
    },
    {
        "title": "[Lightning-dev] AMP via HD, BN+SS, and TR",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-19T00:25:13",
                "message_text_only": "Good morning list,\n\nI sketch here the idea, of making atomic multipath payment (AMP), with the properties:\n\n1.  Has a proof-of-payment.\n2.  Multipath decorrelation.\n\nNote: I am not a mathematician.  Thus, it is likely, that there is a mistake here, and we cannot make this work.\n\nFirst, we look at BIP32 hierarchically derived (HD) keys by Wuille.  Roughly, given a parent private key k_par, we can do derive k_i child keys for integer i by:\n\nk_i = H(i || k_par * G) + k_par\n\nwhere H(x) is a hash function and G is the generator point. (this it not quite how BIP32 does it, it uses HMAC, maybe that is safer for some reason that my non-mathematician self is unaware of...)\n\nThe parent public key K_par = k_par * G.  We can derive K_i public child keys for integer i by:\n\nK_i = H(i || K_par) * G + K_par\n\n(I think)\n\nNote that K_i = k_i * G still, as is usual for elliptic curve asymmetric cryptography:\n\nK_i = k_i * G = (H(i || k_par * G) + k_par) * G = H(i || k_par * G) * G + k_par * G = H(i || K_par) * G + K_par\n\nOf note is that if we know an i, a private child key k_i corresponding to that i, and the public parent key K_par, we can derive the private parent key k_par:\n\nk_i = H(i || K_par) + k_par\n\nk_par = k_i - H(i || K_par)\n\nNow all we need is to have a conditional payment, which can only be performed if the payee provides a private key which matches a public key, i.e. given x * G, the payee must provide x.\n\nFortunately Poelstra has done this work beforehand in the Scriptless Script (SS) concept, where the payee provides a T = t * G, and the Scriptless Script construction requires that the payee reveal the t in order to claim the payment.  I will not go into the math since there is a good chance I shall make a mistake; look up discussions by better mathematicians by me.  Scriptless Script requires Bellare-Neven (BN) signatures to work.\n\nNote that Scriptless Script handles only the equivalent of hashlocking.  We still need a timelock in case the payee refuses to reveal the proof-of-payment t.\n\nFortunately, Maxwell has provided a construction, taproot (TR).  This construction has two top-level branches: a Bellare-Neven n-of-n, or a Bitcoin Script.  We know that Scriptless Script can make an equivalent to a hashlock from a Bellare-Neven n-of-n.  The other branch of a taproot construction can now be a simple OP_CLTV+OP_CHECKSIG script, forming the timelock half of an HTLC.\n\nHow would a multipath payment work?  The invoice would contain the parent public key K_par.  From this, the payer derives as many K_i, as it needs to split the payment to.  It sets up conditional payments that require revelation of the private child key k_i for each K_i it derives.\n\nWhen the payee receives a partial payment, it is not incentivized to claim it immediately yet.  This is because revelation of even one child key k_i will, in combination with the parent public key K_par, reveal the parent private key k_par, which serves as proof-of-payment.  The payee will wait for the entire payment to reach it, and then claim all of them.  This reveals all the private child keys k_i, any one of which will let the payer extract the parent private key k_par that serves as proof-of-payment.\n\nEach path has a different k_i, thus providing multipath decorrelation.\n\n(Please check my math --- I am not a mathematician and it is possible I have made a mistake somewhere)\n\nRegards,\nZmnSCPXj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180318/ce9decae/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2018-03-19T14:57:57",
                "message_text_only": "Hi ZmnSCPxj,\n\n\nYep, I'm pretty sure this works the way you describe -- essentially replace\nthe hash challenges with adaptor signatures which are reblinded at each layer.\nBecause adaptor signatures can make arbitrary sets of signatures atomic (and\ndon't require any precommitments in the blockchain) it's easy to do multipath\nstuff this way. And using discrete logs as challenges makes reblinding and\ntransferrable proof-of-payment easy.\n\nIt's also true that you can use BIP32 hardened keys for the challenges. You\nmight as well use HMAC rather than a hash for the sake of standardness, but\nI don't think there's any particular reason to do this for key derivation.\n\nThen Taproot can hide the non-cooperative cases as you mention.\n\n\nI've been working on understanding Lightning and figuring out best way to\nuse the full power of scriptless scripts. I think we can do better than just\ndropping TR+SS into the existing architecture. (Some of AJ's recent emails\nto the list have been one-sided commentary on ideas I floated to him in\nperson recently, but I haven't had time to get everything straight enough\nin my mind to reply.)\n\nFor example, with adaptor signatures + Graftroot [1], one party can make their\ncommit-tx signature atomic with a delegation to a timelock script; the other\nparty does the same but for a different timelock script. Then maybe both parties\ncan share the same commit tx rather than doing the symmetric thing, which would\nsave space and simplify the protocol a bit. And more generally, this \"output\nhas different spend conditions depending on who publishes to the chain\" primitive\nseems like a really powerful thing, and AFAIK nobody has noticed this feature of\nGraftroot until very recently.\n\n\nCheers\n\nAndrew\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015700.html\n\n\nOn Sun, Mar 18, 2018 at 08:25:13PM -0400, ZmnSCPxj via Lightning-dev wrote:\n> Good morning list,\n> \n> I sketch here the idea, of making atomic multipath payment (AMP), with the properties:\n> \n> 1.  Has a proof-of-payment.\n> 2.  Multipath decorrelation.\n> \n> Note: I am not a mathematician.  Thus, it is likely, that there is a mistake here, and we cannot make this work.\n> \n> First, we look at BIP32 hierarchically derived (HD) keys by Wuille.  Roughly, given a parent private key k_par, we can do derive k_i child keys for integer i by:\n> \n> k_i = H(i || k_par * G) + k_par\n> \n> where H(x) is a hash function and G is the generator point. (this it not quite how BIP32 does it, it uses HMAC, maybe that is safer for some reason that my non-mathematician self is unaware of...)\n> \n> The parent public key K_par = k_par * G.  We can derive K_i public child keys for integer i by:\n> \n> K_i = H(i || K_par) * G + K_par\n> \n> (I think)\n> \n> Note that K_i = k_i * G still, as is usual for elliptic curve asymmetric cryptography:\n> \n> K_i = k_i * G = (H(i || k_par * G) + k_par) * G = H(i || k_par * G) * G + k_par * G = H(i || K_par) * G + K_par\n> \n> Of note is that if we know an i, a private child key k_i corresponding to that i, and the public parent key K_par, we can derive the private parent key k_par:\n> \n> k_i = H(i || K_par) + k_par\n> \n> k_par = k_i - H(i || K_par)\n> \n> Now all we need is to have a conditional payment, which can only be performed if the payee provides a private key which matches a public key, i.e. given x * G, the payee must provide x.\n> \n> Fortunately Poelstra has done this work beforehand in the Scriptless Script (SS) concept, where the payee provides a T = t * G, and the Scriptless Script construction requires that the payee reveal the t in order to claim the payment.  I will not go into the math since there is a good chance I shall make a mistake; look up discussions by better mathematicians by me.  Scriptless Script requires Bellare-Neven (BN) signatures to work.\n> \n> Note that Scriptless Script handles only the equivalent of hashlocking.  We still need a timelock in case the payee refuses to reveal the proof-of-payment t.\n> \n> Fortunately, Maxwell has provided a construction, taproot (TR).  This construction has two top-level branches: a Bellare-Neven n-of-n, or a Bitcoin Script.  We know that Scriptless Script can make an equivalent to a hashlock from a Bellare-Neven n-of-n.  The other branch of a taproot construction can now be a simple OP_CLTV+OP_CHECKSIG script, forming the timelock half of an HTLC.\n> \n> How would a multipath payment work?  The invoice would contain the parent public key K_par.  From this, the payer derives as many K_i, as it needs to split the payment to.  It sets up conditional payments that require revelation of the private child key k_i for each K_i it derives.\n> \n> When the payee receives a partial payment, it is not incentivized to claim it immediately yet.  This is because revelation of even one child key k_i will, in combination with the parent public key K_par, reveal the parent private key k_par, which serves as proof-of-payment.  The payee will wait for the entire payment to reach it, and then claim all of them.  This reveals all the private child keys k_i, any one of which will let the payer extract the parent private key k_par that serves as proof-of-payment.\n> \n> Each path has a different k_i, thus providing multipath decorrelation.\n> \n> (Please check my math --- I am not a mathematician and it is possible I have made a mistake somewhere)\n> \n> Regards,\n> ZmnSCPXj\n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180319/b2f89db2/attachment-0001.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-20T02:32:16",
                "message_text_only": "Good morning Andrew,\n\n> Hi ZmnSCPxj,\n> \n> Yep, I'm pretty sure this works the way you describe -- essentially replace\n> \n> the hash challenges with adaptor signatures which are reblinded at each layer.\n\n\nThank you very much your confirmation.\n\n> For example, with adaptor signatures + Graftroot \\[1\\], one party can make their\n> \n> commit-tx signature atomic with a delegation to a timelock script; the other\n> \n> party does the same but for a different timelock script. Then maybe both parties\n> \n> can share the same commit tx rather than doing the symmetric thing, which would\n> \n> save space and simplify the protocol a bit.\n\nPossibly not?  On each pair of symmetric commitments, an output that is timelocked on one commitment transaction is not timelocked on the other commitment transaction, and that output is signable by the same party.  E.g. in the simple case with a single output controlled by a single party A, A has a commitment transaction whose output is timelocked and unlockable by A, B has a commitment transaction whose output is only unlockable by A (and in particular not timelocked).  Each side still needs its own commitment transaction I think.\n\n(unless Graftroot is even more magical than how I understand it: my skills already strain trying to understand Scriptless Script and Taproot, so possibly I just do not understand Graftroot well enough)\n\nSymmetry in commitment transactions is not particularly space-heavy.  Well-behaved nodes will never bother storing old commitments and can delete those from disk, and you only need to store your own commitment --- the other commitment is the responsibility of the counterparty to store.\n\n> And more generally, this \"output\n> \n> has different spend conditions depending on who publishes to the chain\" primitive\n> \n> seems like a really powerful thing, and AFAIK nobody has noticed this feature of\n> \n> Graftroot until very recently.\n\nAh, this is indeed very interesting!\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-20T06:25:20",
                "message_text_only": "Good morning list,\n\nIt is possible to mean atomic in multiple meanings:\n\n1.  The payee is completely unable to claim any partial payments until all partial payments arrive at the payee.\n2.  The payee is not incentivized to claim partial payments until all partial payments arrive at the payee.\n\nMy proposal uses \"atomic\" in the sense of #2.  As soon as a single partial payment reveals a child key k_i, then with the know public parent key K_par it is possible to compute parent secret key k_par.\n\nThis is sufficient if k_par is valuable, for example if it is also the encryption key for valuable digital data such as some megabytes of a streamed movie, game downloadable content, ransomed files, etc. i.e. for ZKCP.  The payee is incentivized to claim payments only if all partial payments reach it, since once it claims any sub-payment, it will also release the valuable secret k_par.\n\nHowever, it is possible to upgrade from #2 to #1 by adding a secret from the payer to the payee that is sent \"in pieces\" for each sub-payment.\n\nWe add this payer secret p and modify our derivation as follows:\n\nK_i = H(i || p || K_par) * G + K_par\n\nk_i = H(i || p || k_par * G) + k_par\n\nk_par can be derived if we know any i, k_i, p, and K_par:\n\nk_par = k_i - H(i || p || K_par)\n\nWhen splitting a single payment into two payments, the payer generates a hiding random number x_1.\n\nWhen sending an onion payment, the onion payload contains pieces of the payer secret p.  For example, in the 2-subpayment case:\n\nsub-payment 1: p ^ x_1\nsub-payment 2: x_1\n\nThis can be extended to any number of subpayments n:\n\nsub-payment 1: p ^ x_1 ^ ... ^ x_n-1\nsub-payment 2: x_1\n...\nsub-payment n: x_n-1\n\nIn this case, the payee truly cannot claim any sub-payment unless all sub-payments have reached it.  When all sub-payments have reached it, it XORs all the pieces of the payer secret together to compute p.\n\nThe payee cannot derive k_i unless it knows i, p, and the secret k_par.  Once at least one sub-payment is claimed, then the payer can derive the secret k_par.\n\nSince offers on LN are HTLCs, there is a timelock involved.  As long as the payee does not claim too close to the timelock, it has time to claim all sub-payments, even if only claiming one sub-payment is enough for the payer to derive the (potentially valuable) secret k_par.\n\nThus this scheme achieves atomicity in the sense \"the payee cannot claim partial payments\", not just \"the payee is disincentivized to claim partial payments\".\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 19, 2018 8:25 AM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> I sketch here the idea, of making atomic multipath payment (AMP), with the properties:\n>\n> 1.  Has a proof-of-payment.\n> 2.  Multipath decorrelation.\n>\n> Note: I am not a mathematician.  Thus, it is likely, that there is a mistake here, and we cannot make this work.\n>\n> First, we look at BIP32 hierarchically derived (HD) keys by Wuille.  Roughly, given a parent private key k_par, we can do derive k_i child keys for integer i by:\n>\n> k_i = H(i || k_par * G) + k_par\n>\n> where H(x) is a hash function and G is the generator point. (this it not quite how BIP32 does it, it uses HMAC, maybe that is safer for some reason that my non-mathematician self is unaware of...)\n>\n> The parent public key K_par = k_par * G.  We can derive K_i public child keys for integer i by:\n>\n> K_i = H(i || K_par) * G + K_par\n>\n> (I think)\n>\n> Note that K_i = k_i * G still, as is usual for elliptic curve asymmetric cryptography:\n>\n> K_i = k_i * G = (H(i || k_par * G) + k_par) * G = H(i || k_par * G) * G + k_par * G = H(i || K_par) * G + K_par\n>\n> Of note is that if we know an i, a private child key k_i corresponding to that i, and the public parent key K_par, we can derive the private parent key k_par:\n>\n> k_i = H(i || K_par) + k_par\n>\n> k_par = k_i - H(i || K_par)\n>\n> Now all we need is to have a conditional payment, which can only be performed if the payee provides a private key which matches a public key, i.e. given x * G, the payee must provide x.\n>\n> Fortunately Poelstra has done this work beforehand in the Scriptless Script (SS) concept, where the payee provides a T = t * G, and the Scriptless Script construction requires that the payee reveal the t in order to claim the payment.  I will not go into the math since there is a good chance I shall make a mistake; look up discussions by better mathematicians by me.  Scriptless Script requires Bellare-Neven (BN) signatures to work.\n>\n> Note that Scriptless Script handles only the equivalent of hashlocking.  We still need a timelock in case the payee refuses to reveal the proof-of-payment t.\n>\n> Fortunately, Maxwell has provided a construction, taproot (TR).  This construction has two top-level branches: a Bellare-Neven n-of-n, or a Bitcoin Script.  We know that Scriptless Script can make an equivalent to a hashlock from a Bellare-Neven n-of-n.  The other branch of a taproot construction can now be a simple OP_CLTV+OP_CHECKSIG script, forming the timelock half of an HTLC.\n>\n> How would a multipath payment work?  The invoice would contain the parent public key K_par.  From this, the payer derives as many K_i, as it needs to split the payment to.  It sets up conditional payments that require revelation of the private child key k_i for each K_i it derives.\n>\n> When the payee receives a partial payment, it is not incentivized to claim it immediately yet.  This is because revelation of even one child key k_i will, in combination with the parent public key K_par, reveal the parent private key k_par, which serves as proof-of-payment.  The payee will wait for the entire payment to reach it, and then claim all of them.  This reveals all the private child keys k_i, any one of which will let the payer extract the parent private key k_par that serves as proof-of-payment.\n>\n> Each path has a different k_i, thus providing multipath decorrelation.\n>\n> (Please check my math --- I am not a mathematician and it is possible I have made a mistake somewhere)\n>\n> Regards,\n> ZmnSCPXj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180320/fb7f65dd/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "AMP via HD, BN+SS, and TR",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Andrew Poelstra",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 18047
        }
    },
    {
        "title": "[Lightning-dev] Towards a gridlike Lightning Network",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-20T03:19:02",
                "message_text_only": "Good morning list,\n\nAs my award-winning and supremely notable and talked-about-by-the-man-on-the-street article \"Cyclic Superhubs as Solution Towards Reasonable Lightning Network Topography\" points out, cycles are a good way to organize the LN in order to allow easier accessibility to the network for all participants of all kinds.\n\nAn issue here is the need for coordination in order to set up cyclic superhubs.  A node acting by itself cannot form cyclic superhubs.\n\nHowever, one can consider that coordination is needed only to identify peers with which one forms superhubs.  But we already have a system that identifies peers: the node gossip.\n\nSo let us assume: All nodes have similar-enough views of the publicly-visible peers on the node graph, as built by node gossip.\n\nI now present an algorithm, which given a set of nodes extracted from node gossip, returns a peer to try connecting and funding a channel to.\n\n--\n\nFirst, start with a 32-bit number i = 0.\n\nFor each node, get hash = H(i || pubkey), where H is some standard hash algorithm, and pubkey is the public key of the node.  Also get our_hash = H(i || our_pubkey)\n\nPerform successive filtering.  While the set is larger than 2 nodes, successively compare high bits.  If the highest bit of hash does not match the highest bit of our_hash, remove it from the set.  If the resulting set is still larger than 2, match the next bit.  When the set is now 2 or 1 node, back off by one bit and add back the most recently removed nodes.  This yields a set that is at least 3 or more nodes.\n\nSort the nodes according to hash.\n\nIdentify where our node is in the sorted list.  Then our candidate is the next node in the list, or if we are the last node, then the first node in the list.\n\nIf the candidate already has a channel with us, or has no address info and cannot be found by DNS seed or so on, or cannot be contacted, or refuses incoming channels or some other error, then increment i and try finding again.\n\n---\n\nEven if nodes have some divergence in their own local maps of the network, there is the chance that the difference will be filtered away and the nodes that are \"destined\" to form a superhub can still find each other in the same superhub.\n\nAssuming all nodes have the same routemap, then all nodes will form their own, non-overlapping superhubs for each i.  However if some nodes get to increment i, hopefully because it already has a channel with its destined candidate peer at one value of i, it can then potentially form superhubs with other nodes that have also reached higher i.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180319/e0e059cf/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-23T15:29:19",
                "message_text_only": "Good morning list,\n\nIgor Cota has started implementing my idea: https://github.com/icota/presto/commit/3311785e660d840f0ac8f2e333d0f0097aec980e\n\nThis forced me to actually start thinking more deeply about the algorithm I gave.\n\n1.  We should use a well-used hash algorithm, such as RIPEMD160(SHA256(x))\n2.  We should specify the size of `i` - 32-bits, 4 bytes - and indicate its endianness.  Let us use big-endian, as is typical for the rest of Lightning and for network order.\n3.  My original algorithm had a significant probability of diverging.  So I respecify the termination condition later.\n4.  Our own node should be part of the original working set.\n5.  In the decimation loop, start with the highest bit.  This is the 7-index bit (1 << 7) of the first byte in the 20-byte hash (we treat the hash as a big-endian 160-bit number).\n\nThe modified termination condition for the decimation loop is below:\n\n* If the working set is 7 nodes or more, decimate (i.e. match the next bit in the hashes and remove those that do not match our own hash in that bit.).\n* If the working set is 3 to 6 nodes, stop, that is now the members of the superhub and we then sort them by hash and decide our position in the superhub (who will channel to us and who we will channel to).\n* If the working set is 1 or 2 nodes, fail to form a superhub.  Increment `i` and restart.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 20, 2018 11:19 AM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> As my award-winning and supremely notable and talked-about-by-the-man-on-the-street article \"Cyclic Superhubs as Solution Towards Reasonable Lightning Network Topography\" points out, cycles are a good way to organize the LN in order to allow easier accessibility to the network for all participants of all kinds.\n>\n> An issue here is the need for coordination in order to set up cyclic superhubs.  A node acting by itself cannot form cyclic superhubs.\n>\n> However, one can consider that coordination is needed only to identify peers with which one forms superhubs.  But we already have a system that identifies peers: the node gossip.\n>\n> So let us assume: All nodes have similar-enough views of the publicly-visible peers on the node graph, as built by node gossip.\n>\n> I now present an algorithm, which given a set of nodes extracted from node gossip, returns a peer to try connecting and funding a channel to.\n>\n> --\n>\n> First, start with a 32-bit number i = 0.\n>\n> For each node, get hash = H(i || pubkey), where H is some standard hash algorithm, and pubkey is the public key of the node.  Also get our_hash = H(i || our_pubkey)\n>\n> Perform successive filtering.  While the set is larger than 2 nodes, successively compare high bits.  If the highest bit of hash does not match the highest bit of our_hash, remove it from the set.  If the resulting set is still larger than 2, match the next bit.  When the set is now 2 or 1 node, back off by one bit and add back the most recently removed nodes.  This yields a set that is at least 3 or more nodes.\n>\n> Sort the nodes according to hash.\n>\n> Identify where our node is in the sorted list.  Then our candidate is the next node in the list, or if we are the last node, then the first node in the list.\n>\n> If the candidate already has a channel with us, or has no address info and cannot be found by DNS seed or so on, or cannot be contacted, or refuses incoming channels or some other error, then increment i and try finding again.\n>\n> ---\n>\n> Even if nodes have some divergence in their own local maps of the network, there is the chance that the difference will be filtered away and the nodes that are \"destined\" to form a superhub can still find each other in the same superhub.\n>\n> Assuming all nodes have the same routemap, then all nodes will form their own, non-overlapping superhubs for each i.  However if some nodes get to increment i, hopefully because it already has a channel with its destined candidate peer at one value of i, it can then potentially form superhubs with other nodes that have also reached higher i.\n>\n> Regards,\n> ZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180323/6b759ddd/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-24T12:07:52",
                "message_text_only": "Good morning list,\n\nI have decided on a better termination condition for searching for a cyclic superhub.  I re-describe below the algorithm:\n\nStart with `i` = 0 and a set of known nodes, including our own node.\n\nIterate over `i`:\n\n- Compute hash = H(i || pubkey) for each node. H = RIPEMD160 . SHA256, serialize `i` as a big-endian 32-bit number.  Also compute our_hash = H(i || our_pubkey) for our self.  Put this in a working set.\n\n- Iterate over bits (start with the 7th bit (128) of the first byte):\n\n- - Split the working set into two sets, the matching set and the non-matching set, where the bit in the hash matches the bit in our_hash.\n\n- - If the non-matching set is empty, skip to the next bit.\n\n- - If the matching set is 1 or 2 members, or the non-matching set is 1 or 2 members, merge the two sets together into the working set and exit this loop: we have found a cyclic superhub.\n\n- - else set the working set to the matching set.\n\n- Sort the set according to the hash (treat the hash as a 160-bit big-endian number).\n\n- We should open a channel to the node after us in the sorted list; if we are the last, wrap around to the first node in the list.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 23, 2018 11:29 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning list,\n>\n> Igor Cota has started implementing my idea: https://github.com/icota/presto/commit/3311785e660d840f0ac8f2e333d0f0097aec980e\n>\n> This forced me to actually start thinking more deeply about the algorithm I gave.\n>\n> 1.  We should use a well-used hash algorithm, such as RIPEMD160(SHA256(x))\n> 2.  We should specify the size of `i` - 32-bits, 4 bytes - and indicate its endianness.  Let us use big-endian, as is typical for the rest of Lightning and for network order.\n> 3.  My original algorithm had a significant probability of diverging.  So I respecify the termination condition later.\n> 4.  Our own node should be part of the original working set.\n> 5.  In the decimation loop, start with the highest bit.  This is the 7-index bit (1 << 7) of the first byte in the 20-byte hash (we treat the hash as a big-endian 160-bit number).\n>\n> The modified termination condition for the decimation loop is below:\n>\n> * If the working set is 7 nodes or more, decimate (i.e. match the next bit in the hashes and remove those that do not match our own hash in that bit.).\n> * If the working set is 3 to 6 nodes, stop, that is now the members of the superhub and we then sort them by hash and decide our position in the superhub (who will channel to us and who we will channel to).\n> * If the working set is 1 or 2 nodes, fail to form a superhub.  Increment `i` and restart.\n>\n> Regards,\n> ZmnSCPxj\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On March 20, 2018 11:19 AM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Good morning list,\n>>\n>> As my award-winning and supremely notable and talked-about-by-the-man-on-the-street article \"Cyclic Superhubs as Solution Towards Reasonable Lightning Network Topography\" points out, cycles are a good way to organize the LN in order to allow easier accessibility to the network for all participants of all kinds.\n>>\n>> An issue here is the need for coordination in order to set up cyclic superhubs.  A node acting by itself cannot form cyclic superhubs.\n>>\n>> However, one can consider that coordination is needed only to identify peers with which one forms superhubs.  But we already have a system that identifies peers: the node gossip.\n>>\n>> So let us assume: All nodes have similar-enough views of the publicly-visible peers on the node graph, as built by node gossip.\n>>\n>> I now present an algorithm, which given a set of nodes extracted from node gossip, returns a peer to try connecting and funding a channel to.\n>>\n>> --\n>>\n>> First, start with a 32-bit number i = 0.\n>>\n>> For each node, get hash = H(i || pubkey), where H is some standard hash algorithm, and pubkey is the public key of the node.  Also get our_hash = H(i || our_pubkey)\n>>\n>> Perform successive filtering.  While the set is larger than 2 nodes, successively compare high bits.  If the highest bit of hash does not match the highest bit of our_hash, remove it from the set.  If the resulting set is still larger than 2, match the next bit.  When the set is now 2 or 1 node, back off by one bit and add back the most recently removed nodes.  This yields a set that is at least 3 or more nodes.\n>>\n>> Sort the nodes according to hash.\n>>\n>> Identify where our node is in the sorted list.  Then our candidate is the next node in the list, or if we are the last node, then the first node in the list.\n>>\n>> If the candidate already has a channel with us, or has no address info and cannot be found by DNS seed or so on, or cannot be contacted, or refuses incoming channels or some other error, then increment i and try finding again.\n>>\n>> ---\n>>\n>> Even if nodes have some divergence in their own local maps of the network, there is the chance that the difference will be filtered away and the nodes that are \"destined\" to form a superhub can still find each other in the same superhub.\n>>\n>> Assuming all nodes have the same routemap, then all nodes will form their own, non-overlapping superhubs for each i.  However if some nodes get to increment i, hopefully because it already has a channel with its destined candidate peer at one value of i, it can then potentially form superhubs with other nodes that have also reached higher i.\n>>\n>> Regards,\n>> ZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180324/41ad53bd/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Towards a gridlike Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12996
        }
    },
    {
        "title": "[Lightning-dev] Lightning network implementation with ethereum",
        "thread_messages": [
            {
                "author": "Mahesh Govind",
                "date": "2018-03-27T01:12:08",
                "message_text_only": "Dear Experts,\n\nCould you please let me know the implementation I could use with ethereum  .\n\nWith thanks and regards\nmahesh\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180327/0532763e/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-03-30T14:04:20",
                "message_text_only": "Dear Mahesh,\n\nthat's a very interesting question, to be best of my knowledge there is\nno working implementation for Ethereum and I don't think anybody is\nworking on one currently. There is the Raiden network attempt at porting\na Lightning-like network to Ethereum, but I'm not sure what the current\nstatus of that project is.\n\nA direct port is probably not possible due to the differences in the\nunderlying blockchain, but a Lightning-like network is definitely\npossible.\n\nCheers,\nChristian\n\nMahesh Govind <mahesh at digiledge.com> writes:\n> Dear Experts,\n>\n> Could you please let me know the implementation I could use with ethereum  .\n>\n> With thanks and regards\n> mahesh\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Lightning network implementation with ethereum",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Mahesh Govind"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1177
        }
    },
    {
        "title": "[Lightning-dev] Opening channels with neighbors for cost/connectivity benefit",
        "thread_messages": [
            {
                "author": "Karan Verma",
                "date": "2018-03-27T03:57:57",
                "message_text_only": "Hello,\nThe sender node doesn\u2019t always have a route to the receiving node accepting\nlightning payments and since opening new channels is costly - I was wondering if\nthere was a smarter way to open channels such that it increases the\nconnectedness of the sender node with other nodes in the network and also\npossibly save money\u00a0in the intended transaction.\nTo clarify, if Bob wants to send money to Alice but doesn\u2019t have a route to her.\nHe would need to open a\u00a0new channel with Alice and send the money. This is\ncostly for Bob if that was the only transaction he ever wanted to do with Alice.\nHowever, if Alice was connected to Charlie and Dave (Unidirectional: Charlie ->\nAlice & Dave -> Alice due to the amount being sent). He could instead connect\nwith Charlie/Dave or nodes connected with them which have a route to Alice\nthrough Charlie/Dave such that it minimizes the transaction cost to reaching\nAlice (some routes might have negative fee)\u00a0and maximizes the number of nodes\nBob can now reach through this channel. Lets say if Bob chose Charlie's\nneighbor, then he can now reach at-least three nodes - Charlie's neighbor,\nCharlie and Alice and end up paying less.\nEssentially we're sorting choice of the nodes to open a channel with by\ntransaction fee and connectedness it brings to the origin node. This would\nbenefit Bob in the long term and also maybe lightning network as a whole. I'm\nnew to lightning and would appreciate feedback on this idea. Thanks.\n-Karan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180327/cfb6b838/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-03-28T05:41:10",
                "message_text_only": "Good morning Karan,\n\nChannel direction cannot be determined publicly, as sharing that information would be equivalent to broadcasting how much you own on a channel to everyone, and updating everyone about each transaction made on that channel.  This hurts privacy.\n\nI believe lnd implements the Barabasi-Albert model which tries to look for hub nodes and preferentially attaches to those, but I worry that this would cause effective centralization of the network, which will hurt privacy and possibly network availability.\n\nSee also my recent pointless rants about cyclic superhubs.  These encourage a gridlike network with good alternative routes, but is not implemented by anyone at all yet, making it pointless to implement in the first place, since they would work only if everybody strongly prefers them.  It also does not handle very well when a good number of nodes are shut down regularly, or are buggy, and you would strongly want to have atomic multipath payments in order to be able to spread out your counterparty risk to more nodes.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn March 27, 2018 11:57 AM, Karan Verma <karanverma at alumni.stanford.edu> wrote:\n\n> Hello,\n>\n> The sender node doesn\u2019t always have a route to the receiving node accepting lightning payments and since opening new channels is costly - I was wondering if there was a smarter way to open channels such that it increases the connectedness of the sender node with other nodes in the network and also possibly save money in the intended transaction.\n>\n> To clarify, if Bob wants to send money to Alice but doesn\u2019t have a route to her. He would need to open a new channel with Alice and send the money. This is costly for Bob if that was the only transaction he ever wanted to do with Alice. However, if Alice was connected to Charlie and Dave (Unidirectional: Charlie -> Alice & Dave -> Alice due to the amount being sent). He could instead connect with Charlie/Dave or nodes connected with them which have a route to Alice through Charlie/Dave such that it minimizes the transaction cost to reaching Alice (some routes might have negative fee) and maximizes the number of nodes Bob can now reach through this channel. Lets say if Bob chose Charlie's neighbor, then he can now reach at-least three nodes - Charlie's neighbor, Charlie and Alice and end up paying less.\n>\n> Essentially we're sorting choice of the nodes to open a channel with by transaction fee and connectedness it brings to the origin node. This would benefit Bob in the long term and also maybe lightning network as a whole. I'm new to lightning and would appreciate feedback on this idea. Thanks.\n>\n> -Karan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180328/9f24d0ac/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Opening channels with neighbors for cost/connectivity benefit",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Karan Verma",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4571
        }
    },
    {
        "title": "[Lightning-dev] Fwd: Opening channels with neighbors for cost/connectivity benefit",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-03-28T08:57:20",
                "message_text_only": "Sorry I sent this mail by accident only to Karan.\n\n---------- Forwarded message ---------\nFrom: Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\nDate: Di., 27. M\u00e4rz 2018 11:10\nSubject: Re: [Lightning-dev] Opening channels with neighbors for\ncost/connectivity benefit\nTo: Karan Verma <karanverma at alumni.stanford.edu>\n\n\nDear karan,\n\nThere is a feature called autopilot in the lnd implementation that tries to\nachieve something similar to what you describe.\n\nHowever the problem is much harder than just using some plausible\nheuristic. I have an open issue on github discussing these problems:\nhttps://github.com/lightningnetwork/lnd/issues/677\n\n>From there I also linked a draft of a whitepaper that I am working on in\nwhich I plan to discuss ways of automatically create a well connected\nnetwork topology fitting the specific needs of the peers in the lightning\nnetwork.\n\nYour help and ideas would be appreciated. Also you could just implement\nyour idea in the lnd autopilot interface\n\nBest regards Rene Pickhardt\n\nKaran Verma <karanverma at alumni.stanford.edu> schrieb am Di., 27. M\u00e4rz 2018\n05:58:\n\n> Hello,\n>\n> The sender node doesn\u2019t always have a route to the receiving node\n> accepting lightning payments and since opening new channels is costly - I\n> was wondering if there was a smarter way to open channels such that it\n> increases the connectedness of the sender node with other nodes in the\n> network and also possibly save money in the intended transaction.\n>\n> To clarify, if Bob wants to send money to Alice but doesn\u2019t have a route\n> to her. He would need to open a new channel with Alice and send the money.\n> This is costly for Bob if that was the only transaction he ever wanted to\n> do with Alice. However, if Alice was connected to Charlie and Dave\n> (Unidirectional: Charlie -> Alice & Dave -> Alice due to the amount being\n> sent). He could instead connect with Charlie/Dave or nodes connected with\n> them which have a route to Alice through Charlie/Dave such that it\n> minimizes the transaction cost to reaching Alice (some routes might have\n> negative fee) and maximizes the number of nodes Bob can now reach through\n> this channel. Lets say if Bob chose Charlie's neighbor, then he can now\n> reach at-least three nodes - Charlie's neighbor, Charlie and Alice and end\n> up paying less.\n>\n> Essentially we're sorting choice of the nodes to open a channel with by\n> transaction fee and connectedness it brings to the origin node. This would\n> benefit Bob in the long term and also maybe lightning network as a whole.\n> I'm new to lightning and would appreciate feedback on this idea. Thanks.\n>\n> -Karan\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180328/9e7ab97e/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Opening channels with neighbors for cost/connectivity benefit",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3007
        }
    },
    {
        "title": "[Lightning-dev] An Idea to Improve Connectivity of the Graph",
        "thread_messages": [
            {
                "author": "Alejandro Ranchal Pedrosa",
                "date": "2018-03-29T15:10:37",
                "message_text_only": "Hello all,\n\nChristian Decker pointed the following out\n(source:https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000991.html):\n\n>I'd also like to point out that the way we do state invalidations in\n>Lightning is not really suited for multi-party negotiations beyond 2\n>parties. The number of potential reactions to a party cheating grows\n>exponentially in the number of parties in the contract, which is the\n>reason the Channel Factories paper relies on the Duplex Micropayment\n>Channel construction instead of the retaliation construction in LN.\n\nCan somebody ellaborate on this assumption?\n\nBest,\n\nAlejandro.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180329/3b672012/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "An Idea to Improve Connectivity of the Graph",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Alejandro Ranchal Pedrosa"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 817
        }
    }
]