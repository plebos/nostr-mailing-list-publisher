[
    {
        "title": "[Lightning-dev] Imposing minimum 253 sat/ksipa feerate?",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2018-06-06T01:06:13",
                "message_text_only": "> In this case, a 250 sat/kweight feerate is too low for Bitcoin to\nbroadcast,\n> and thus will be too low for timely processing (since it will *never* be\nput\n> in a block, the processing time will be infinite).\n\nIf by \"Bitcoin\" you mean Satoshi's client, then the latest instance will\nactually _dynamically_ regulate its min fee rate [1]. As a result, we can't\njust all agree to some static fee floor, as nodes on the network will\nregulate their min fee rate accordingly deepening on the size of their\nmempools. If a large fee spike occurs, then even a value of 253 may be too\nlow. As a result, setting a static fee floor is only a temporary measure,\nthat may cease to work at an unknown time (or even if nodes are configured\nto have very small mempools if they have low memory).\n\nThe best current candidate for managing these fee issues (without more\nliberal sighash flags) seems to be utilizing a permanent op_true output.\nAlthough this itself has its own issues...\n\n[1]:\nhttps://github.com/bitcoin/bitcoin/blob/0264836695a2c260fcc50f25a5e9962098a84647/src/txmempool.cpp#L983\n\n-- Laolu\n\n\nOn Tue, May 29, 2018 at 12:39 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning laolu,\n>\n> What's a ksipa? lnd uses vsize internally for all fee estimation. FWIW,\n> fees are extremely low on mainnet atm, we can thank the segwit capacity\n> increase for that.\n>\n>\n> This:\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#fee-calculation\n>\n> sipa is the arbitrary unit used for weight, although I suppose there is no\n> such thing anyway.\n>\n>\n> Why does cl unilaterally close in that case? Atm it's trivial for anyone\n> to propose a low ball fee rate and cause a synchronized channel closure.\n> The latest of such events resulted in over 250 channels being closed within\n> 2 blocks.\n>\n>\n> This:\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee\n>\n> > A receiving node:\n> > * if the `update_fee` is too low for timely processing, OR is\n> unreasonably large:\n> >   * SHOULD fail the channel.\n>\n> In this case, a 250 sat/kweight feerate is too low for Bitcoin to\n> broadcast, and thus will be too low for timely processing (since it will\n> *never* be put in a block, the processing time will be infinite).\n>\n> If we do not immediately close, I believe the attack I described here is\n> possible:\n> https://github.com/ElementsProject/lightning/issues/1443#issuecomment-385541379\n>\n> Although it is entirely possible that I made a mistake, and the attack I\n> gave is not possible.  So, I want also to ask, if I am too naive in this\n> attack and it is in fact not possible.\n>\n> (one wonders why the above \"SHOULD fail the channel\" is indicated in the\n> BOLT spec, if the attack above (or a similar attack) is not possible)\n>\n>\n> Force closing asymmetrically penalizes the broadcaster atm, causing cl to\n> waste on chain fees sweeping and also it must incur the time lock delay.\n>\n>\n> Yes.\n>\n> But I find it strange that lnd insists on a 250 sat/kweight, when, if we\n> use the BOLT-02 algorithm for fee calculation, such a feerate would be\n> rejected by bitcoind nodes for many transactions.  Does not lnd encounter\n> this issue?\n>\n> Regards,\n> ZmnSCPxj\n>\n> On Mon, May 28, 2018, 11:16 PM ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all, but most especially non-c-lightning developers,\n>>\n>> Some time ago, C-lightning imposed a minimum 253 sat/ksipa feerate:\n>> https://github.com/ElementsProject/lightning/pull/1251\n>>\n>> The reason is that the BOLT spec specifies a fee computation that is not\n>> identical to how bitcoind computes fees.\n>>\n>> Thus, the minimum 250 sat/ksipa feerate, if computed using the BOLT spec,\n>> will result in a fee which bitcoind will compute as less than the minimum\n>> 250 sat/ksipa it imposes (due to difference in how BOLT and bitcoind\n>> compute feerates).\n>>\n>> Now C-lightning will not accept an onchain feerate (from `update_fee`) of\n>> less than 253 sat/ksipa, precisely because of the above issue with the\n>> divergence in how BOLT and bitcoind compute fees: anything less than 253\n>> sat/ksipa, computed using the BOLT spec, will be rejected by bitcoind.\n>> This results in a few issues in C-lightning where we close unilaterally\n>> when the counterparty proposes a 250sat/ksipa feerate:\n>>\n>> * https://github.com/ElementsProject/lightning/issues/1351\n>> * https://github.com/ElementsProject/lightning/issues/1529\n>>\n>> (C-lightning has increased the ranges recently, but the 253sat/ksipa\n>> limit is a hard limit and will still cause C-lightning to unilaterally\n>> close if the counterparty gives an `update_fee` of <253)\n>>\n>> Recently, Eclair discovered this same issue (i.e. bitcoind will not\n>> broadcast a 250 sat/ksipa feerate tx when computed using the BOLT spec\n>> algorithm): https://github.com/ACINQ/eclair/issues/602\n>>\n>> Eclair appears to have also imposed the same solution as C-lightning:\n>> https://github.com/ACINQ/eclair/commit/8981d45dd52c52abe60d5c00411d638dd2124b6f\n>>\n>> ucoin (nayutaco/ptarmigan) also has 253 in a constant somewhere:\n>> https://github.com/nayutaco/ptarmigan/blob/6fe9db418ec962bf1d9282bb5271750b7c5764c2/ucoin/include/ln.h#L73\n>> https://github.com/nayutaco/ptarmigan/blob/315e49785aa3fa19d1291b4d40bfc6951f988cda/ucoind/monitoring.c#L147\n>>\n>> I am wondering whether lnd and lit have ever encountered issues with 250\n>> sat/ksipa transactions getting propagated on the Bitcoin-level network.  I\n>> cannot find \"253\" in either codebase, suggesting that this minimum is not\n>> imposed by lnd or lit.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180605/5d7d209f/attachment.html>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2018-06-15T11:39:59",
                "message_text_only": "Despite the dynamic stuff, IIUC a minimum of 1000 sat / kbyte is still enforced (in AcceptToMemoryPoolWorker), unless the user also sets -minrelaytxfee:\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L736\n\nMost lnd nodes probably use btcd either directly or through neutrino (which is not implemented for Bitcoin Core yet). So they wouldn\u2019t notice the issue immediately, or at all if those nodes are well connected.\n\nHowever, in order to get mined, your transaction likely needs to pass through at least one bitcoind node, so keeping at least the above minimum in mind seems wise.\n\n\nDefault minimums aside I agree with Laolu: the problem with dynamic minimum relay fees is that many nodes - including your own! - might never relay your transaction if the fee is on the low end of the permitted range. Even the default 300 MB mempool setting only fits ~150 blocks (1 day) worth of transactions. That creates a problem if you use fees based on e.g. having a full week to close a channel, you better make sure your node is well connected or somehow warns you otherwise.\n\nSjors\n\n\n> Op 6 jun. 2018, om 03:06 heeft Olaoluwa Osuntokun <laolu32 at gmail.com> het volgende geschreven:\n> \n> > In this case, a 250 sat/kweight feerate is too low for Bitcoin to broadcast,\n> > and thus will be too low for timely processing (since it will *never* be put\n> > in a block, the processing time will be infinite).\n> \n> If by \"Bitcoin\" you mean Satoshi's client, then the latest instance will\n> actually _dynamically_ regulate its min fee rate [1]. As a result, we can't\n> just all agree to some static fee floor, as nodes on the network will\n> regulate their min fee rate accordingly deepening on the size of their\n> mempools. If a large fee spike occurs, then even a value of 253 may be too\n> low. As a result, setting a static fee floor is only a temporary measure,\n> that may cease to work at an unknown time (or even if nodes are configured\n> to have very small mempools if they have low memory).\n> \n> The best current candidate for managing these fee issues (without more\n> liberal sighash flags) seems to be utilizing a permanent op_true output.\n> Although this itself has its own issues...\n> \n> [1]: https://github.com/bitcoin/bitcoin/blob/0264836695a2c260fcc50f25a5e9962098a84647/src/txmempool.cpp#L983\n> \n> -- Laolu\n> \n> \n> On Tue, May 29, 2018 at 12:39 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> Good morning laolu,\n> \n>> What's a ksipa? lnd uses vsize internally for all fee estimation. FWIW, fees are extremely low on mainnet atm, we can thank the segwit capacity increase for that. \n> \n> This: https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#fee-calculation\n> \n> sipa is the arbitrary unit used for weight, although I suppose there is no such thing anyway.\n> \n>> \n>> Why does cl unilaterally close in that case? Atm it's trivial for anyone to propose a low ball fee rate and cause a synchronized channel closure. The latest of such events resulted in over 250 channels being closed within 2 blocks. \n> \n> This: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee\n> \n> > A receiving node:\n> > * if the `update_fee` is too low for timely processing, OR is unreasonably large:\n> >   * SHOULD fail the channel.\n> \n> In this case, a 250 sat/kweight feerate is too low for Bitcoin to broadcast, and thus will be too low for timely processing (since it will *never* be put in a block, the processing time will be infinite).\n> \n> If we do not immediately close, I believe the attack I described here is possible: https://github.com/ElementsProject/lightning/issues/1443#issuecomment-385541379\n> \n> Although it is entirely possible that I made a mistake, and the attack I gave is not possible.  So, I want also to ask, if I am too naive in this attack and it is in fact not possible.\n> \n> (one wonders why the above \"SHOULD fail the channel\" is indicated in the BOLT spec, if the attack above (or a similar attack) is not possible)\n> \n>> \n>> Force closing asymmetrically penalizes the broadcaster atm, causing cl to waste on chain fees sweeping and also it must incur the time lock delay. \n> \n> Yes.\n> \n> But I find it strange that lnd insists on a 250 sat/kweight, when, if we use the BOLT-02 algorithm for fee calculation, such a feerate would be rejected by bitcoind nodes for many transactions.  Does not lnd encounter this issue?\n> \n> Regards,\n> ZmnSCPxj\n> \n>> On Mon, May 28, 2018, 11:16 PM ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>> Hi all, but most especially non-c-lightning developers,\n>> \n>> Some time ago, C-lightning imposed a minimum 253 sat/ksipa feerate: https://github.com/ElementsProject/lightning/pull/1251\n>> \n>> The reason is that the BOLT spec specifies a fee computation that is not identical to how bitcoind computes fees.\n>> \n>> Thus, the minimum 250 sat/ksipa feerate, if computed using the BOLT spec, will result in a fee which bitcoind will compute as less than the minimum 250 sat/ksipa it imposes (due to difference in how BOLT and bitcoind compute feerates).\n>> \n>> Now C-lightning will not accept an onchain feerate (from `update_fee`) of less than 253 sat/ksipa, precisely because of the above issue with the divergence in how BOLT and bitcoind compute fees: anything less than 253 sat/ksipa, computed using the BOLT spec, will be rejected by bitcoind.  This results in a few issues in C-lightning where we close unilaterally when the counterparty proposes a 250sat/ksipa feerate:\n>> \n>> * https://github.com/ElementsProject/lightning/issues/1351\n>> * https://github.com/ElementsProject/lightning/issues/1529\n>> \n>> (C-lightning has increased the ranges recently, but the 253sat/ksipa limit is a hard limit and will still cause C-lightning to unilaterally close if the counterparty gives an `update_fee` of <253)\n>> \n>> Recently, Eclair discovered this same issue (i.e. bitcoind will not broadcast a 250 sat/ksipa feerate tx when computed using the BOLT spec algorithm): https://github.com/ACINQ/eclair/issues/602\n>> \n>> Eclair appears to have also imposed the same solution as C-lightning: https://github.com/ACINQ/eclair/commit/8981d45dd52c52abe60d5c00411d638dd2124b6f\n>> \n>> ucoin (nayutaco/ptarmigan) also has 253 in a constant somewhere: https://github.com/nayutaco/ptarmigan/blob/6fe9db418ec962bf1d9282bb5271750b7c5764c2/ucoin/include/ln.h#L73 https://github.com/nayutaco/ptarmigan/blob/315e49785aa3fa19d1291b4d40bfc6951f988cda/ucoind/monitoring.c#L147\n>> \n>> I am wondering whether lnd and lit have ever encountered issues with 250 sat/ksipa transactions getting propagated on the Bitcoin-level network.  I cannot find \"253\" in either codebase, suggesting that this minimum is not imposed by lnd or lit.\n>> \n>> Regards,\n>> ZmnSCPxj\n>> \n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-18T09:22:07",
                "message_text_only": "Good morning Sjors, Laolu, and list,\n\nIndeed, I understand, this minimum of 1000 sat/kbyte (=250 sat/kweight), is imposed too, absolutely, regardless of dynamic blockchain conditions.\n\nMy logic, is, this is workaround for current conditions.\n\nIn current conditions, we often can get away with this minimum relay fee for fee rate.\n\nBut, we compute fee differently from bitcoind, which imposes this minimum relay fee.\n\nOf course, we should use better dynamic fee paying later. But, requires blockchain-level softfork I think (at minimum, 0-value OP_TRUE output that can be spent only in current block).  Also, requires that LN impl, keep some money onchain for fee payment.\n\nCurrently, many channel failure occur between lnd and c-lightning, because of this imposed 253sat/ksipa feerate in c-lightning.  If lnd support same absolute minimum, this channel failure is reduced.  And then we have time, to make better dynamic fee system.\n\nI think, SegWit blocksize increase, is sufficient to maintain low fees for some time until we can develop and deploy better dynamic fee system.\n\nAnd we see this behavior (channel failure between lnd and c-lightning due to lnd too low feerate) especially during low feerate time, because of SegWit blocksize increase.\n\nRegards,\nZmnSCPxj\n\n\n\n\u200bSent with ProtonMail Secure Email.\u200b\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n\nOn June 15, 2018 7:39 PM, Sjors Provoost <sjors at sprovoost.nl> wrote:\n\n> Despite the dynamic stuff, IIUC a minimum of 1000 sat / kbyte is still enforced (in AcceptToMemoryPoolWorker), unless the user also sets -minrelaytxfee:\n> \n> https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L736\n> \n> Most lnd nodes probably use btcd either directly or through neutrino (which is not implemented for Bitcoin Core yet). So they wouldn\u2019t notice the issue immediately, or at all if those nodes are well connected.\n> \n> However, in order to get mined, your transaction likely needs to pass through at least one bitcoind node, so keeping at least the above minimum in mind seems wise.\n> \n> Default minimums aside I agree with Laolu: the problem with dynamic minimum relay fees is that many nodes - including your own! - might never relay your transaction if the fee is on the low end of the permitted range. Even the default 300 MB mempool setting only fits ~150 blocks (1 day) worth of transactions. That creates a problem if you use fees based on e.g. having a full week to close a channel, you better make sure your node is well connected or somehow warns you otherwise.\n> \n> Sjors\n> \n> > Op 6 jun. 2018, om 03:06 heeft Olaoluwa Osuntokun laolu32 at gmail.com het volgende geschreven:\n> > \n> > > In this case, a 250 sat/kweight feerate is too low for Bitcoin to broadcast,\n> > > \n> > > and thus will be too low for timely processing (since it will never be put\n> > > \n> > > in a block, the processing time will be infinite).\n> > \n> > If by \"Bitcoin\" you mean Satoshi's client, then the latest instance will\n> > \n> > actually dynamically regulate its min fee rate 1. As a result, we can't\n> > \n> > just all agree to some static fee floor, as nodes on the network will\n> > \n> > regulate their min fee rate accordingly deepening on the size of their\n> > \n> > mempools. If a large fee spike occurs, then even a value of 253 may be too\n> > \n> > low. As a result, setting a static fee floor is only a temporary measure,\n> > \n> > that may cease to work at an unknown time (or even if nodes are configured\n> > \n> > to have very small mempools if they have low memory).\n> > \n> > The best current candidate for managing these fee issues (without more\n> > \n> > liberal sighash flags) seems to be utilizing a permanent op_true output.\n> > \n> > Although this itself has its own issues...\n> > \n> > -- Laolu\n> > \n> > On Tue, May 29, 2018 at 12:39 AM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> > \n> > Good morning laolu,\n> > \n> > > What's a ksipa? lnd uses vsize internally for all fee estimation. FWIW, fees are extremely low on mainnet atm, we can thank the segwit capacity increase for that.\n> > \n> > This: https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#fee-calculation\n> > \n> > sipa is the arbitrary unit used for weight, although I suppose there is no such thing anyway.\n> > \n> > > Why does cl unilaterally close in that case? Atm it's trivial for anyone to propose a low ball fee rate and cause a synchronized channel closure. The latest of such events resulted in over 250 channels being closed within 2 blocks.\n> > \n> > This: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee\n> > \n> > > A receiving node:\n> > > \n> > > -   if the `update_fee` is too low for timely processing, OR is unreasonably large:\n> > >     \n> > >     -   SHOULD fail the channel.\n> > \n> > In this case, a 250 sat/kweight feerate is too low for Bitcoin to broadcast, and thus will be too low for timely processing (since it will never be put in a block, the processing time will be infinite).\n> > \n> > If we do not immediately close, I believe the attack I described here is possible: https://github.com/ElementsProject/lightning/issues/1443#issuecomment-385541379\n> > \n> > Although it is entirely possible that I made a mistake, and the attack I gave is not possible. So, I want also to ask, if I am too naive in this attack and it is in fact not possible.\n> > \n> > (one wonders why the above \"SHOULD fail the channel\" is indicated in the BOLT spec, if the attack above (or a similar attack) is not possible)\n> > \n> > > Force closing asymmetrically penalizes the broadcaster atm, causing cl to waste on chain fees sweeping and also it must incur the time lock delay.\n> > \n> > Yes.\n> > \n> > But I find it strange that lnd insists on a 250 sat/kweight, when, if we use the BOLT-02 algorithm for fee calculation, such a feerate would be rejected by bitcoind nodes for many transactions. Does not lnd encounter this issue?\n> > \n> > Regards,\n> > \n> > ZmnSCPxj\n> > \n> > > On Mon, May 28, 2018, 11:16 PM ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org wrote:\n> > > \n> > > Hi all, but most especially non-c-lightning developers,\n> > > \n> > > Some time ago, C-lightning imposed a minimum 253 sat/ksipa feerate: https://github.com/ElementsProject/lightning/pull/1251\n> > > \n> > > The reason is that the BOLT spec specifies a fee computation that is not identical to how bitcoind computes fees.\n> > > \n> > > Thus, the minimum 250 sat/ksipa feerate, if computed using the BOLT spec, will result in a fee which bitcoind will compute as less than the minimum 250 sat/ksipa it imposes (due to difference in how BOLT and bitcoind compute feerates).\n> > > \n> > > Now C-lightning will not accept an onchain feerate (from `update_fee`) of less than 253 sat/ksipa, precisely because of the above issue with the divergence in how BOLT and bitcoind compute fees: anything less than 253 sat/ksipa, computed using the BOLT spec, will be rejected by bitcoind. This results in a few issues in C-lightning where we close unilaterally when the counterparty proposes a 250sat/ksipa feerate:\n> > > \n> > > -   https://github.com/ElementsProject/lightning/issues/1351\n> > > -   https://github.com/ElementsProject/lightning/issues/1529\n> > > \n> > > (C-lightning has increased the ranges recently, but the 253sat/ksipa limit is a hard limit and will still cause C-lightning to unilaterally close if the counterparty gives an `update_fee` of <253)\n> > > \n> > > Recently, Eclair discovered this same issue (i.e. bitcoind will not broadcast a 250 sat/ksipa feerate tx when computed using the BOLT spec algorithm): https://github.com/ACINQ/eclair/issues/602\n> > > \n> > > Eclair appears to have also imposed the same solution as C-lightning: https://github.com/ACINQ/eclair/commit/8981d45dd52c52abe60d5c00411d638dd2124b6f\n> > > \n> > > ucoin (nayutaco/ptarmigan) also has 253 in a constant somewhere: https://github.com/nayutaco/ptarmigan/blob/6fe9db418ec962bf1d9282bb5271750b7c5764c2/ucoin/include/ln.h#L73 https://github.com/nayutaco/ptarmigan/blob/315e49785aa3fa19d1291b4d40bfc6951f988cda/ucoind/monitoring.c#L147\n> > > \n> > > I am wondering whether lnd and lit have ever encountered issues with 250 sat/ksipa transactions getting propagated on the Bitcoin-level network. I cannot find \"253\" in either codebase, suggesting that this minimum is not imposed by lnd or lit.\n> > > \n> > > Regards,\n> > > \n> > > ZmnSCPxj\n> > > \n> > > Lightning-dev mailing list\n> > > \n> > > Lightning-dev at lists.linuxfoundation.org\n> > > \n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > \n> > Lightning-dev mailing list\n> > \n> > Lightning-dev at lists.linuxfoundation.org\n> > \n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Imposing minimum 253 sat/ksipa feerate?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Sjors Provoost",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 21976
        }
    },
    {
        "title": "[Lightning-dev] New idea on decentralized identity and truth (Re: Numerifides)",
        "thread_messages": [
            {
                "author": "Tyler H",
                "date": "2018-06-07T02:27:54",
                "message_text_only": "Greetings again, list.\n\nI have an idea that may be an excellent use-case for Lightning.  Where\nNumerifides was an attempt at decentralized identity rooted to the\nBlockchain, I thought of a new system that uses Lightning itself that seems\nsuperior, and perhaps gives Lightning even more utility than it currently\nhas.\n\nThe long and short of it is: I propose adding a feature (along with an RFC\nand a feature bit) to Lightning whereby any given node can be queried for a\nmapping (such as \"Give me the IP address for Google.com\" and the node can\nprovide any answer one chooses _along with fulfilling a Lightning payment\nrequest the client provides_.\n\nThe thinking here is nobody is willing to pay for mappings unless they're\nimportant, so mappings such as the pubkey associated with an unpopular\nusername will only get paid by the person who has the username, or not paid\nat all, and thus the result can safely be disregarded.  Longer paths or\nmore queries will cost the claimant more, plus it will cost for each query\nof the mapping.  Paying 1 satoshi (or less ;] ) per query for\ndecentralized, trusted hosting of your data mappings seems fair.\n\nThis is also aided by the fact that you cannot pay out on a channel without\nalready having a channel _with outbound liquidity_.  So someone cannot,\nsay, open a channel to a random node and spam queries as the directionality\nsimply won't allow it.\n\nLastly on the topic, the database could be shared among nodes for a price,\nwhere a Lightning node can offer to store data per hour and the person who\nwishes for redundancy can pay a Lightning invoice and provide the data.\nThis data wouldn't have to be encrypted or private, since the whole point\nis that it can be queried publicly.  You could even check if they're honest\nby querying them and seeing if they pay you Bitcoin back.\n\nI think if nothing else, this would be a good spare functionality used for\nrebalancing channels, if only to add some utility.\n\nLooking way far into the future, you could also submit queries like \"What's\nthe best place to get a burger in San Francisco\" and only the real die-hard\nfans (and companies with some Bitcoin to burn for \"advertising\") would be\nwilling to pay for their opinion to be heard.\n\nFeedback appreciated,\nTyler\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180606/4c09afbe/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-07T03:20:30",
                "message_text_only": "Good morning Tyler,\n\nIt seems this can be a layer on top of LN.\n\nThis is my understanding: the querier requests some mapping and sends also an invoice, the responder either fails, or returns the mapping and pays to the invoice.  So the responder pays to the querier.\n\nHowever it seems a little strange that I can get money by an action I initiate.\n\nFor example, if I know that Google wants to claim some mapping, I could drain them of their allocated \"advertising funds\" by querying them repeatedly.\n\nIn any case, non-distributed server-client protocols for storing database information I believe pay in reverse: the querier requests some query, the responder sends the encrypted data, an invoice with payment preimage, and a proof that the preimage is the (symmetric) encryption key to the encrypted data.  The querier pays the invoice and receives the preimage, which is the encryption key to the encrypted data.  The query may be a proof-of-storage so that a database client can have assurance that the server is indeed keeping its data alive.\n\nThe mapping idea you have is the opposite of the above common consideration.  I suppose this is a pay-for-advertising, which I believe is not yet commonly researched yet.\n\nI believe a proposed pay-for-advertising should have the below considerations:\n\n1.  As advertiser, I should get a proof that my advertisement did indeed reach some target audience, before I pay out.\n2.  An attacker could trivially invent some target audience that it pretends exists, but might not actually exist.  How do we prove that the target audience exists?\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n\n> Greetings again, list.\n>\n> I have an idea that may be an excellent use-case for Lightning.  Where Numerifides was an attempt at decentralized identity rooted to the Blockchain, I thought of a new system that uses Lightning itself that seems superior, and perhaps gives Lightning even more utility than it currently has.\n>\n> The long and short of it is: I propose adding a feature (along with an RFC and a feature bit) to Lightning whereby any given node can be queried for a mapping (such as \"Give me the IP address for Google.com\" and the node can provide any answer one chooses _along with fulfilling a Lightning payment request the client provides_.\n>\n> The thinking here is nobody is willing to pay for mappings unless they're important, so mappings such as the pubkey associated with an unpopular username will only get paid by the person who has the username, or not paid at all, and thus the result can safely be disregarded.  Longer paths or more queries will cost the claimant more, plus it will cost for each query of the mapping.  Paying 1 satoshi (or less ;] ) per query for decentralized, trusted hosting of your data mappings seems fair.\n>\n> This is also aided by the fact that you cannot pay out on a channel without already having a channel _with outbound liquidity_.  So someone cannot, say, open a channel to a random node and spam queries as the directionality simply won't allow it.\n>\n> Lastly on the topic, the database could be shared among nodes for a price, where a Lightning node can offer to store data per hour and the person who wishes for redundancy can pay a Lightning invoice and provide the data.  This data wouldn't have to be encrypted or private, since the whole point is that it can be queried publicly.  You could even check if they're honest by querying them and seeing if they pay you Bitcoin back.\n>\n> I think if nothing else, this would be a good spare functionality used for rebalancing channels, if only to add some utility.\n>\n> Looking way far into the future, you could also submit queries like \"What's the best place to get a burger in San Francisco\" and only the real die-hard fans (and companies with some Bitcoin to burn for \"advertising\") would be willing to pay for their opinion to be heard.\n>\n> Feedback appreciated,\n> Tyler\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180606/d824e5b5/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-07T03:36:26",
                "message_text_only": "Good morning again Tyler,\n\nBuilding off the \"server-client database\" idea, here is an alternate idea.\n\nWe have a special node type, an \"advertiser node\".  Aside from normal LN protocol, advertiser nodes also have the below interface:\n\n1.  A \"write\" interface that lets advertisers pay to set a mapping.\n2.  A \"read\" interface that lets audiences pay to get a mapping.  The payment here should be much smaller than the \"write\" interface.\n3.  A \"proof\" interface that lets anyone query how much the advertiser node owns in its channels.  It may be possible to set things up so that if the advertiser lies, it loses some of its funds (if not, this scheme is not workable).\n\nIf an advertiser node owns much funds, it probably earned that from many advertisers paying to set mappings, and audiences paying to get mappings.  So if the advertising node is inventing its audience, then it will have to lock some of its own funds and not spend it, sacrificing opportunity to invest it elsewhere.\n\nOf course, this is strongly centralizing and thus not recommended.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn June 7, 2018 11:20 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Tyler,\n>\n> It seems this can be a layer on top of LN.\n>\n> This is my understanding: the querier requests some mapping and sends also an invoice, the responder either fails, or returns the mapping and pays to the invoice.  So the responder pays to the querier.\n>\n> However it seems a little strange that I can get money by an action I initiate.\n>\n> For example, if I know that Google wants to claim some mapping, I could drain them of their allocated \"advertising funds\" by querying them repeatedly.\n>\n> In any case, non-distributed server-client protocols for storing database information I believe pay in reverse: the querier requests some query, the responder sends the encrypted data, an invoice with payment preimage, and a proof that the preimage is the (symmetric) encryption key to the encrypted data.  The querier pays the invoice and receives the preimage, which is the encryption key to the encrypted data.  The query may be a proof-of-storage so that a database client can have assurance that the server is indeed keeping its data alive.\n>\n> The mapping idea you have is the opposite of the above common consideration.  I suppose this is a pay-for-advertising, which I believe is not yet commonly researched yet.\n>\n> I believe a proposed pay-for-advertising should have the below considerations:\n>\n> 1.  As advertiser, I should get a proof that my advertisement did indeed reach some target audience, before I pay out.\n> 2.  An attacker could trivially invent some target audience that it pretends exists, but might not actually exist.  How do we prove that the target audience exists?\n>\n> Regards,\n> ZmnSCPxj\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n>\n>> Greetings again, list.\n>>\n>> I have an idea that may be an excellent use-case for Lightning.  Where Numerifides was an attempt at decentralized identity rooted to the Blockchain, I thought of a new system that uses Lightning itself that seems superior, and perhaps gives Lightning even more utility than it currently has.\n>>\n>> The long and short of it is: I propose adding a feature (along with an RFC and a feature bit) to Lightning whereby any given node can be queried for a mapping (such as \"Give me the IP address for Google.com\" and the node can provide any answer one chooses _along with fulfilling a Lightning payment request the client provides_.\n>>\n>> The thinking here is nobody is willing to pay for mappings unless they're important, so mappings such as the pubkey associated with an unpopular username will only get paid by the person who has the username, or not paid at all, and thus the result can safely be disregarded.  Longer paths or more queries will cost the claimant more, plus it will cost for each query of the mapping.  Paying 1 satoshi (or less ;] ) per query for decentralized, trusted hosting of your data mappings seems fair.\n>>\n>> This is also aided by the fact that you cannot pay out on a channel without already having a channel _with outbound liquidity_.  So someone cannot, say, open a channel to a random node and spam queries as the directionality simply won't allow it.\n>>\n>> Lastly on the topic, the database could be shared among nodes for a price, where a Lightning node can offer to store data per hour and the person who wishes for redundancy can pay a Lightning invoice and provide the data.  This data wouldn't have to be encrypted or private, since the whole point is that it can be queried publicly.  You could even check if they're honest by querying them and seeing if they pay you Bitcoin back.\n>>\n>> I think if nothing else, this would be a good spare functionality used for rebalancing channels, if only to add some utility.\n>>\n>> Looking way far into the future, you could also submit queries like \"What's the best place to get a burger in San Francisco\" and only the real die-hard fans (and companies with some Bitcoin to burn for \"advertising\") would be willing to pay for their opinion to be heard.\n>>\n>> Feedback appreciated,\n>> Tyler\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180606/3e12e2db/attachment-0001.html>"
            },
            {
                "author": "Tyler H",
                "date": "2018-06-07T04:01:41",
                "message_text_only": "ZmnSCPxj,\n\nRegarding proof of payment, a receiving node must have some inbound\nLightning capacity. Therefore, they must have spent funds on the LN\nalready. Attackers can't drain more than they've spent on their channels.\nNode pubkeys can also be used such that rapid subsequent requests above a\nthreshold from a given pubkey fail after the first success.\n\nThe read must be a payout, the point is that I get the mappings I care\nabout and Google (with more Bitcoin, processing power, or Lightning nodes)\ncan't come in and outbid me for them, or else I will just spam the fake\nmapping for a steady stream of satoshis ;)\n\nAlso, no one knows which node has the original mapping, only which nodes\nare hosting them, and what mappings are available.\n\nThe mappings themselves can be openly queried without payment. The payment\nis so a client knows that a specific mapping has \"put its money where its\nmouth is\" about it. Only mappings that actually pay out can be trusted.\n\nCompared to your alternate idea I believe this map of mappings, or the\n\"Atlas bit\" as it could be called is much more decentalized, honest and\nfair.\n\nTyler\n\nOn Wed, Jun 6, 2018, 23:36 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning again Tyler,\n>\n> Building off the \"server-client database\" idea, here is an alternate idea.\n>\n> We have a special node type, an \"advertiser node\".  Aside from normal LN\n> protocol, advertiser nodes also have the below interface:\n>\n> 1.  A \"write\" interface that lets advertisers pay to set a mapping.\n> 2.  A \"read\" interface that lets audiences pay to get a mapping.  The\n> payment here should be much smaller than the \"write\" interface.\n> 3.  A \"proof\" interface that lets anyone query how much the advertiser\n> node owns in its channels.  It may be possible to set things up so that if\n> the advertiser lies, it loses some of its funds (if not, this scheme is not\n> workable).\n>\n> If an advertiser node owns much funds, it probably earned that from many\n> advertisers paying to set mappings, and audiences paying to get mappings.\n> So if the advertising node is inventing its audience, then it will have to\n> lock some of its own funds and not spend it, sacrificing opportunity to\n> invest it elsewhere.\n>\n> Of course, this is strongly centralizing and thus not recommended.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On June 7, 2018 11:20 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Tyler,\n>\n> It seems this can be a layer on top of LN.\n>\n> This is my understanding: the querier requests some mapping and sends also\n> an invoice, the responder either fails, or returns the mapping and pays to\n> the invoice.  So the responder pays to the querier.\n>\n> However it seems a little strange that I can get money by an action I\n> initiate.\n>\n> For example, if I know that Google wants to claim some mapping, I could\n> drain them of their allocated \"advertising funds\" by querying them\n> repeatedly.\n>\n> In any case, non-distributed server-client protocols for storing database\n> information I believe pay in reverse: the querier requests some query, the\n> responder sends the encrypted data, an invoice with payment preimage, and a\n> proof that the preimage is the (symmetric) encryption key to the encrypted\n> data.  The querier pays the invoice and receives the preimage, which is the\n> encryption key to the encrypted data.  The query may be a proof-of-storage\n> so that a database client can have assurance that the server is indeed\n> keeping its data alive.\n>\n> The mapping idea you have is the opposite of the above common\n> consideration.  I suppose this is a pay-for-advertising, which I believe is\n> not yet commonly researched yet.\n>\n> I believe a proposed pay-for-advertising should have the below\n> considerations:\n>\n> 1.  As advertiser, I should get a proof that my advertisement did indeed\n> reach some target audience, before I pay out.\n> 2.  An attacker could trivially invent some target audience that it\n> pretends exists, but might not actually exist.  How do we prove that the\n> target audience exists?\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n>\n>\n> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n>\n> Greetings again, list.\n>\n> I have an idea that may be an excellent use-case for Lightning.  Where\n> Numerifides was an attempt at decentralized identity rooted to the\n> Blockchain, I thought of a new system that uses Lightning itself that seems\n> superior, and perhaps gives Lightning even more utility than it currently\n> has.\n>\n> The long and short of it is: I propose adding a feature (along with an RFC\n> and a feature bit) to Lightning whereby any given node can be queried for a\n> mapping (such as \"Give me the IP address for Google.com\" and the node can\n> provide any answer one chooses _along with fulfilling a Lightning payment\n> request the client provides_.\n>\n> The thinking here is nobody is willing to pay for mappings unless they're\n> important, so mappings such as the pubkey associated with an unpopular\n> username will only get paid by the person who has the username, or not paid\n> at all, and thus the result can safely be disregarded.  Longer paths or\n> more queries will cost the claimant more, plus it will cost for each query\n> of the mapping.  Paying 1 satoshi (or less ;] ) per query for\n> decentralized, trusted hosting of your data mappings seems fair.\n>\n> This is also aided by the fact that you cannot pay out on a channel\n> without already having a channel _with outbound liquidity_.  So someone\n> cannot, say, open a channel to a random node and spam queries as the\n> directionality simply won't allow it.\n>\n> Lastly on the topic, the database could be shared among nodes for a price,\n> where a Lightning node can offer to store data per hour and the person who\n> wishes for redundancy can pay a Lightning invoice and provide the data.\n> This data wouldn't have to be encrypted or private, since the whole point\n> is that it can be queried publicly.  You could even check if they're honest\n> by querying them and seeing if they pay you Bitcoin back.\n>\n> I think if nothing else, this would be a good spare functionality used for\n> rebalancing channels, if only to add some utility.\n>\n> Looking way far into the future, you could also submit queries like\n> \"What's the best place to get a burger in San Francisco\" and only the real\n> die-hard fans (and companies with some Bitcoin to burn for \"advertising\")\n> would be willing to pay for their opinion to be heard.\n>\n> Feedback appreciated,\n> Tyler\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180607/4c71b712/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-07T08:07:11",
                "message_text_only": "Good morning Tyler,\n\n> Regarding proof of payment, a receiving node must have some inbound Lightning capacity. Therefore, they must have spent funds on the LN already. Attackers can't drain more than they've spent on their channels. Node pubkeys can also be used such that rapid subsequent requests above a threshold from a given pubkey fail after the first success.\n>\n> The read must be a payout, the point is that I get the mappings I care about and Google (with more Bitcoin, processing power, or Lightning nodes) can't come in and outbid me for them, or else I will just spam the fake mapping for a steady stream of satoshis ;)\n>\n> Also, no one knows which node has the original mapping, only which nodes are hosting them, and what mappings are available.\n>\n> The mappings themselves can be openly queried without payment. The payment is so a client knows that a specific mapping has \"put its money where its mouth is\" about it. Only mappings that actually pay out can be trusted.\n\nBut in a trustless environment, \"only mappings that actually pay out can be trusted\" is equivalent to \"all reads require a payout\"...?\n\nIt would be easy for me to spin up a few hundred nodes, connect them into cyclic superhubs, somehow arrange an incoming channel per superhub (e.g. using an LN-to-chain bridge, or an exchange or similar service where I can send my Lightning money and then recover it in some other form), then make a few hundred queries of the mapping.  The mapping service cannot differentiate between valid queries and invalid ones that I claim exist but are not.  In short, you have no proof that the audience for the advertisement exists (i.e. there is no Sybil protection for readers of the mapping service).\n\nPresumably, in order to pay out, the mapping service needs to have *some* outgoing channel *somewhere*. I might not be able to directly convince the mapping service to make a direct channel to me, but I *could* convince *somebody* to make an incoming channel to me (which is something merchants would want to do, therefore such a service will arise (and likely already exists)). Using normal Lightning operations, there could be a viable path from the mapping service to a node on my cyclic superhub by which I could drain them (if such a path could not exist, then LN as a whole would have failed).  And if at least one node on a cyclic superhub has an incoming channel, then the entire cyclic superhub is payable from that channel.\n\nRegards,\nZmnSCPxj\n\n> Compared to your alternate idea I believe this map of mappings, or the \"Atlas bit\" as it could be called is much more decentalized, honest and fair.\n>\n> Tyler\n>\n> On Wed, Jun 6, 2018, 23:36 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning again Tyler,\n>>\n>> Building off the \"server-client database\" idea, here is an alternate idea.\n>>\n>> We have a special node type, an \"advertiser node\".  Aside from normal LN protocol, advertiser nodes also have the below interface:\n>>\n>> 1.  A \"write\" interface that lets advertisers pay to set a mapping.\n>> 2.  A \"read\" interface that lets audiences pay to get a mapping.  The payment here should be much smaller than the \"write\" interface.\n>> 3.  A \"proof\" interface that lets anyone query how much the advertiser node owns in its channels.  It may be possible to set things up so that if the advertiser lies, it loses some of its funds (if not, this scheme is not workable).\n>>\n>> If an advertiser node owns much funds, it probably earned that from many advertisers paying to set mappings, and audiences paying to get mappings.  So if the advertising node is inventing its audience, then it will have to lock some of its own funds and not spend it, sacrificing opportunity to invest it elsewhere.\n>>\n>> Of course, this is strongly centralizing and thus not recommended.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On June 7, 2018 11:20 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>\n>>> Good morning Tyler,\n>>>\n>>> It seems this can be a layer on top of LN.\n>>>\n>>> This is my understanding: the querier requests some mapping and sends also an invoice, the responder either fails, or returns the mapping and pays to the invoice.  So the responder pays to the querier.\n>>>\n>>> However it seems a little strange that I can get money by an action I initiate.\n>>>\n>>> For example, if I know that Google wants to claim some mapping, I could drain them of their allocated \"advertising funds\" by querying them repeatedly.\n>>>\n>>> In any case, non-distributed server-client protocols for storing database information I believe pay in reverse: the querier requests some query, the responder sends the encrypted data, an invoice with payment preimage, and a proof that the preimage is the (symmetric) encryption key to the encrypted data.  The querier pays the invoice and receives the preimage, which is the encryption key to the encrypted data.  The query may be a proof-of-storage so that a database client can have assurance that the server is indeed keeping its data alive.\n>>>\n>>> The mapping idea you have is the opposite of the above common consideration.  I suppose this is a pay-for-advertising, which I believe is not yet commonly researched yet.\n>>>\n>>> I believe a proposed pay-for-advertising should have the below considerations:\n>>>\n>>> 1.  As advertiser, I should get a proof that my advertisement did indeed reach some target audience, before I pay out.\n>>> 2.  An attacker could trivially invent some target audience that it pretends exists, but might not actually exist.  How do we prove that the target audience exists?\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>>>\n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n>>>\n>>>> Greetings again, list.\n>>>>\n>>>> I have an idea that may be an excellent use-case for Lightning.  Where Numerifides was an attempt at decentralized identity rooted to the Blockchain, I thought of a new system that uses Lightning itself that seems superior, and perhaps gives Lightning even more utility than it currently has.\n>>>>\n>>>> The long and short of it is: I propose adding a feature (along with an RFC and a feature bit) to Lightning whereby any given node can be queried for a mapping (such as \"Give me the IP address for Google.com\" and the node can provide any answer one chooses _along with fulfilling a Lightning payment request the client provides_.\n>>>>\n>>>> The thinking here is nobody is willing to pay for mappings unless they're important, so mappings such as the pubkey associated with an unpopular username will only get paid by the person who has the username, or not paid at all, and thus the result can safely be disregarded.  Longer paths or more queries will cost the claimant more, plus it will cost for each query of the mapping.  Paying 1 satoshi (or less ;] ) per query for decentralized, trusted hosting of your data mappings seems fair.\n>>>>\n>>>> This is also aided by the fact that you cannot pay out on a channel without already having a channel _with outbound liquidity_.  So someone cannot, say, open a channel to a random node and spam queries as the directionality simply won't allow it.\n>>>>\n>>>> Lastly on the topic, the database could be shared among nodes for a price, where a Lightning node can offer to store data per hour and the person who wishes for redundancy can pay a Lightning invoice and provide the data.  This data wouldn't have to be encrypted or private, since the whole point is that it can be queried publicly.  You could even check if they're honest by querying them and seeing if they pay you Bitcoin back.\n>>>>\n>>>> I think if nothing else, this would be a good spare functionality used for rebalancing channels, if only to add some utility.\n>>>>\n>>>> Looking way far into the future, you could also submit queries like \"What's the best place to get a burger in San Francisco\" and only the real die-hard fans (and companies with some Bitcoin to burn for \"advertising\") would be willing to pay for their opinion to be heard.\n>>>>\n>>>> Feedback appreciated,\n>>>> Tyler\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180607/d1333627/attachment-0001.html>"
            },
            {
                "author": "Tyler H",
                "date": "2018-06-07T08:45:36",
                "message_text_only": ">But in a trustless environment, \"only mappings that actually pay out can\nbe trusted\" is equivalent to \"all reads require a payout\"...?\n\nI'll rephrase to say \"can be trusted to be human meaningful\".  As you may\nrecall, the goal of Numerifides was to create _human meaningful_ but still\n_trusted_ name mappings. If you want to know the IP to Google.com, you (the\nhuman) want _the right one_.  If you get the wrong one, even if the node\npaid you for it, you can ban that node as untrustworthy and over time,\nyou'll have a set of trustworthy nodes.\n\nNew nodes will start out less trustworthy than old nodes that continue to\nhost mappings for the maximum number of people.  Though I'm not clear on\nthe specifics of eltoo penalty transactions, I think that you can actually\nuse this as a trust meter for which nodes have the most accurate mappings\nby combining proof of the routable channel, proof of a breach (either a\ncurrent-state Lightning breach where the revocation key is used OR an eltoo\nbreach where you can provide proof of the most recent state of a channel.\n\n>Presumably, in order to pay out, the mapping service needs to have *some*\noutgoing channel *somewhere*.\n\nYes, in a way this is a sort of way to know which Lightning nodes are\nhonest.  Perhaps this could be combined with eltoo as a way for Lightning\nto not even need Watchtowers.  Every node could be a watchtower, by\nannouncing to the network at large when a channel is breached, thus nodes\nwill likely want to close their channels with the less trustworthy nodes.\n\nIn a way, Lightning decentralizes payments to be usable.  Atlas, as I've\ncome to call it, centralizes trust over the entire Lightning Network.\n\nI appreciate the feedback, this is very helpful in refining this idea.\n\nThanks,\nTyler\n\nOn Thu, Jun 7, 2018 at 4:07 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Tyler,\n>\n> Regarding proof of payment, a receiving node must have some inbound\n> Lightning capacity. Therefore, they must have spent funds on the LN\n> already. Attackers can't drain more than they've spent on their channels.\n> Node pubkeys can also be used such that rapid subsequent requests above a\n> threshold from a given pubkey fail after the first success.\n>\n> The read must be a payout, the point is that I get the mappings I care\n> about and Google (with more Bitcoin, processing power, or Lightning nodes)\n> can't come in and outbid me for them, or else I will just spam the fake\n> mapping for a steady stream of satoshis ;)\n>\n> Also, no one knows which node has the original mapping, only which nodes\n> are hosting them, and what mappings are available.\n>\n> The mappings themselves can be openly queried without payment. The payment\n> is so a client knows that a specific mapping has \"put its money where its\n> mouth is\" about it. Only mappings that actually pay out can be trusted.\n>\n>\n> But in a trustless environment, \"only mappings that actually pay out can\n> be trusted\" is equivalent to \"all reads require a payout\"...?\n>\n> It would be easy for me to spin up a few hundred nodes, connect them into\n> cyclic superhubs, somehow arrange an incoming channel per superhub (e.g.\n> using an LN-to-chain bridge, or an exchange or similar service where I can\n> send my Lightning money and then recover it in some other form), then make\n> a few hundred queries of the mapping.  The mapping service cannot\n> differentiate between valid queries and invalid ones that I claim exist but\n> are not.  In short, you have no proof that the audience for the\n> advertisement exists (i.e. there is no Sybil protection for readers of the\n> mapping service).\n>\n> Presumably, in order to pay out, the mapping service needs to have *some*\n> outgoing channel *somewhere*. I might not be able to directly convince the\n> mapping service to make a direct channel to me, but I *could* convince\n> *somebody* to make an incoming channel to me (which is something merchants\n> would want to do, therefore such a service will arise (and likely already\n> exists)). Using normal Lightning operations, there could be a viable path\n> from the mapping service to a node on my cyclic superhub by which I could\n> drain them (if such a path could not exist, then LN as a whole would have\n> failed).  And if at least one node on a cyclic superhub has an incoming\n> channel, then the entire cyclic superhub is payable from that channel.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Compared to your alternate idea I believe this map of mappings, or the\n> \"Atlas bit\" as it could be called is much more decentalized, honest and\n> fair.\n>\n> Tyler\n>\n> On Wed, Jun 6, 2018, 23:36 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning again Tyler,\n>>\n>> Building off the \"server-client database\" idea, here is an alternate idea.\n>>\n>> We have a special node type, an \"advertiser node\".  Aside from normal LN\n>> protocol, advertiser nodes also have the below interface:\n>>\n>> 1.  A \"write\" interface that lets advertisers pay to set a mapping.\n>> 2.  A \"read\" interface that lets audiences pay to get a mapping.  The\n>> payment here should be much smaller than the \"write\" interface.\n>> 3.  A \"proof\" interface that lets anyone query how much the advertiser\n>> node owns in its channels.  It may be possible to set things up so that if\n>> the advertiser lies, it loses some of its funds (if not, this scheme is not\n>> workable).\n>>\n>> If an advertiser node owns much funds, it probably earned that from many\n>> advertisers paying to set mappings, and audiences paying to get mappings.\n>> So if the advertising node is inventing its audience, then it will have to\n>> lock some of its own funds and not spend it, sacrificing opportunity to\n>> invest it elsewhere.\n>>\n>> Of course, this is strongly centralizing and thus not recommended.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>>\n>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On June 7, 2018 11:20 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>\n>> Good morning Tyler,\n>>\n>> It seems this can be a layer on top of LN.\n>>\n>> This is my understanding: the querier requests some mapping and sends\n>> also an invoice, the responder either fails, or returns the mapping and\n>> pays to the invoice.  So the responder pays to the querier.\n>>\n>> However it seems a little strange that I can get money by an action I\n>> initiate.\n>>\n>> For example, if I know that Google wants to claim some mapping, I could\n>> drain them of their allocated \"advertising funds\" by querying them\n>> repeatedly.\n>>\n>> In any case, non-distributed server-client protocols for storing database\n>> information I believe pay in reverse: the querier requests some query, the\n>> responder sends the encrypted data, an invoice with payment preimage, and a\n>> proof that the preimage is the (symmetric) encryption key to the encrypted\n>> data.  The querier pays the invoice and receives the preimage, which is the\n>> encryption key to the encrypted data.  The query may be a proof-of-storage\n>> so that a database client can have assurance that the server is indeed\n>> keeping its data alive.\n>>\n>> The mapping idea you have is the opposite of the above common\n>> consideration.  I suppose this is a pay-for-advertising, which I believe is\n>> not yet commonly researched yet.\n>>\n>> I believe a proposed pay-for-advertising should have the below\n>> considerations:\n>>\n>> 1.  As advertiser, I should get a proof that my advertisement did indeed\n>> reach some target audience, before I pay out.\n>> 2.  An attacker could trivially invent some target audience that it\n>> pretends exists, but might not actually exist.  How do we prove that the\n>> target audience exists?\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>>\n>>\n>>\n>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>\n>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>> On June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n>>\n>> Greetings again, list.\n>>\n>> I have an idea that may be an excellent use-case for Lightning.  Where\n>> Numerifides was an attempt at decentralized identity rooted to the\n>> Blockchain, I thought of a new system that uses Lightning itself that seems\n>> superior, and perhaps gives Lightning even more utility than it currently\n>> has.\n>>\n>> The long and short of it is: I propose adding a feature (along with an\n>> RFC and a feature bit) to Lightning whereby any given node can be queried\n>> for a mapping (such as \"Give me the IP address for Google.com\" and the node\n>> can provide any answer one chooses _along with fulfilling a Lightning\n>> payment request the client provides_.\n>>\n>> The thinking here is nobody is willing to pay for mappings unless they're\n>> important, so mappings such as the pubkey associated with an unpopular\n>> username will only get paid by the person who has the username, or not paid\n>> at all, and thus the result can safely be disregarded.  Longer paths or\n>> more queries will cost the claimant more, plus it will cost for each query\n>> of the mapping.  Paying 1 satoshi (or less ;] ) per query for\n>> decentralized, trusted hosting of your data mappings seems fair.\n>>\n>> This is also aided by the fact that you cannot pay out on a channel\n>> without already having a channel _with outbound liquidity_.  So someone\n>> cannot, say, open a channel to a random node and spam queries as the\n>> directionality simply won't allow it.\n>>\n>> Lastly on the topic, the database could be shared among nodes for a\n>> price, where a Lightning node can offer to store data per hour and the\n>> person who wishes for redundancy can pay a Lightning invoice and provide\n>> the data.  This data wouldn't have to be encrypted or private, since the\n>> whole point is that it can be queried publicly.  You could even check if\n>> they're honest by querying them and seeing if they pay you Bitcoin back.\n>>\n>> I think if nothing else, this would be a good spare functionality used\n>> for rebalancing channels, if only to add some utility.\n>>\n>> Looking way far into the future, you could also submit queries like\n>> \"What's the best place to get a burger in San Francisco\" and only the real\n>> die-hard fans (and companies with some Bitcoin to burn for \"advertising\")\n>> would be willing to pay for their opinion to be heard.\n>>\n>> Feedback appreciated,\n>> Tyler\n>>\n>>\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180607/a209e3c3/attachment.html>"
            },
            {
                "author": "Tyler H",
                "date": "2018-06-10T22:29:19",
                "message_text_only": "All,\n\nI've opened https://github.com/lightningnetwork/lightning-rfc/pull/441 to\nget started on hashing out the features and behavior of Atlas.\n\nThanks,\nTyler\n\nOn Thu, Jun 7, 2018 at 4:45 AM Tyler H <tyzbit at gmail.com> wrote:\n\n> >But in a trustless environment, \"only mappings that actually pay out can\n> be trusted\" is equivalent to \"all reads require a payout\"...?\n>\n> I'll rephrase to say \"can be trusted to be human meaningful\".  As you may\n> recall, the goal of Numerifides was to create _human meaningful_ but still\n> _trusted_ name mappings. If you want to know the IP to Google.com, you (the\n> human) want _the right one_.  If you get the wrong one, even if the node\n> paid you for it, you can ban that node as untrustworthy and over time,\n> you'll have a set of trustworthy nodes.\n>\n> New nodes will start out less trustworthy than old nodes that continue to\n> host mappings for the maximum number of people.  Though I'm not clear on\n> the specifics of eltoo penalty transactions, I think that you can actually\n> use this as a trust meter for which nodes have the most accurate mappings\n> by combining proof of the routable channel, proof of a breach (either a\n> current-state Lightning breach where the revocation key is used OR an eltoo\n> breach where you can provide proof of the most recent state of a channel.\n>\n> >Presumably, in order to pay out, the mapping service needs to have *some*\n> outgoing channel *somewhere*.\n>\n> Yes, in a way this is a sort of way to know which Lightning nodes are\n> honest.  Perhaps this could be combined with eltoo as a way for Lightning\n> to not even need Watchtowers.  Every node could be a watchtower, by\n> announcing to the network at large when a channel is breached, thus nodes\n> will likely want to close their channels with the less trustworthy nodes.\n>\n> In a way, Lightning decentralizes payments to be usable.  Atlas, as I've\n> come to call it, centralizes trust over the entire Lightning Network.\n>\n> I appreciate the feedback, this is very helpful in refining this idea.\n>\n> Thanks,\n> Tyler\n>\n> On Thu, Jun 7, 2018 at 4:07 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Tyler,\n>>\n>> Regarding proof of payment, a receiving node must have some inbound\n>> Lightning capacity. Therefore, they must have spent funds on the LN\n>> already. Attackers can't drain more than they've spent on their channels.\n>> Node pubkeys can also be used such that rapid subsequent requests above a\n>> threshold from a given pubkey fail after the first success.\n>>\n>> The read must be a payout, the point is that I get the mappings I care\n>> about and Google (with more Bitcoin, processing power, or Lightning nodes)\n>> can't come in and outbid me for them, or else I will just spam the fake\n>> mapping for a steady stream of satoshis ;)\n>>\n>> Also, no one knows which node has the original mapping, only which nodes\n>> are hosting them, and what mappings are available.\n>>\n>> The mappings themselves can be openly queried without payment. The\n>> payment is so a client knows that a specific mapping has \"put its money\n>> where its mouth is\" about it. Only mappings that actually pay out can be\n>> trusted.\n>>\n>>\n>> But in a trustless environment, \"only mappings that actually pay out can\n>> be trusted\" is equivalent to \"all reads require a payout\"...?\n>>\n>> It would be easy for me to spin up a few hundred nodes, connect them into\n>> cyclic superhubs, somehow arrange an incoming channel per superhub (e.g.\n>> using an LN-to-chain bridge, or an exchange or similar service where I can\n>> send my Lightning money and then recover it in some other form), then make\n>> a few hundred queries of the mapping.  The mapping service cannot\n>> differentiate between valid queries and invalid ones that I claim exist but\n>> are not.  In short, you have no proof that the audience for the\n>> advertisement exists (i.e. there is no Sybil protection for readers of the\n>> mapping service).\n>>\n>> Presumably, in order to pay out, the mapping service needs to have *some*\n>> outgoing channel *somewhere*. I might not be able to directly convince the\n>> mapping service to make a direct channel to me, but I *could* convince\n>> *somebody* to make an incoming channel to me (which is something merchants\n>> would want to do, therefore such a service will arise (and likely already\n>> exists)). Using normal Lightning operations, there could be a viable path\n>> from the mapping service to a node on my cyclic superhub by which I could\n>> drain them (if such a path could not exist, then LN as a whole would have\n>> failed).  And if at least one node on a cyclic superhub has an incoming\n>> channel, then the entire cyclic superhub is payable from that channel.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>>\n>> Compared to your alternate idea I believe this map of mappings, or the\n>> \"Atlas bit\" as it could be called is much more decentalized, honest and\n>> fair.\n>>\n>> Tyler\n>>\n>> On Wed, Jun 6, 2018, 23:36 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>\n>>> Good morning again Tyler,\n>>>\n>>> Building off the \"server-client database\" idea, here is an alternate\n>>> idea.\n>>>\n>>> We have a special node type, an \"advertiser node\".  Aside from normal LN\n>>> protocol, advertiser nodes also have the below interface:\n>>>\n>>> 1.  A \"write\" interface that lets advertisers pay to set a mapping.\n>>> 2.  A \"read\" interface that lets audiences pay to get a mapping.  The\n>>> payment here should be much smaller than the \"write\" interface.\n>>> 3.  A \"proof\" interface that lets anyone query how much the advertiser\n>>> node owns in its channels.  It may be possible to set things up so that if\n>>> the advertiser lies, it loses some of its funds (if not, this scheme is not\n>>> workable).\n>>>\n>>> If an advertiser node owns much funds, it probably earned that from many\n>>> advertisers paying to set mappings, and audiences paying to get mappings.\n>>> So if the advertising node is inventing its audience, then it will have to\n>>> lock some of its own funds and not spend it, sacrificing opportunity to\n>>> invest it elsewhere.\n>>>\n>>> Of course, this is strongly centralizing and thus not recommended.\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>>>\n>>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>>\n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On June 7, 2018 11:20 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>>\n>>> Good morning Tyler,\n>>>\n>>> It seems this can be a layer on top of LN.\n>>>\n>>> This is my understanding: the querier requests some mapping and sends\n>>> also an invoice, the responder either fails, or returns the mapping and\n>>> pays to the invoice.  So the responder pays to the querier.\n>>>\n>>> However it seems a little strange that I can get money by an action I\n>>> initiate.\n>>>\n>>> For example, if I know that Google wants to claim some mapping, I could\n>>> drain them of their allocated \"advertising funds\" by querying them\n>>> repeatedly.\n>>>\n>>> In any case, non-distributed server-client protocols for storing\n>>> database information I believe pay in reverse: the querier requests some\n>>> query, the responder sends the encrypted data, an invoice with payment\n>>> preimage, and a proof that the preimage is the (symmetric) encryption key\n>>> to the encrypted data.  The querier pays the invoice and receives the\n>>> preimage, which is the encryption key to the encrypted data.  The query may\n>>> be a proof-of-storage so that a database client can have assurance that the\n>>> server is indeed keeping its data alive.\n>>>\n>>> The mapping idea you have is the opposite of the above common\n>>> consideration.  I suppose this is a pay-for-advertising, which I believe is\n>>> not yet commonly researched yet.\n>>>\n>>> I believe a proposed pay-for-advertising should have the below\n>>> considerations:\n>>>\n>>> 1.  As advertiser, I should get a proof that my advertisement did indeed\n>>> reach some target audience, before I pay out.\n>>> 2.  An attacker could trivially invent some target audience that it\n>>> pretends exists, but might not actually exist.  How do we prove that the\n>>> target audience exists?\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>>>\n>>>\n>>>\n>>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>>\n>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>> On June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n>>>\n>>> Greetings again, list.\n>>>\n>>> I have an idea that may be an excellent use-case for Lightning.  Where\n>>> Numerifides was an attempt at decentralized identity rooted to the\n>>> Blockchain, I thought of a new system that uses Lightning itself that seems\n>>> superior, and perhaps gives Lightning even more utility than it currently\n>>> has.\n>>>\n>>> The long and short of it is: I propose adding a feature (along with an\n>>> RFC and a feature bit) to Lightning whereby any given node can be queried\n>>> for a mapping (such as \"Give me the IP address for Google.com\" and the node\n>>> can provide any answer one chooses _along with fulfilling a Lightning\n>>> payment request the client provides_.\n>>>\n>>> The thinking here is nobody is willing to pay for mappings unless\n>>> they're important, so mappings such as the pubkey associated with an\n>>> unpopular username will only get paid by the person who has the username,\n>>> or not paid at all, and thus the result can safely be disregarded.  Longer\n>>> paths or more queries will cost the claimant more, plus it will cost for\n>>> each query of the mapping.  Paying 1 satoshi (or less ;] ) per query for\n>>> decentralized, trusted hosting of your data mappings seems fair.\n>>>\n>>> This is also aided by the fact that you cannot pay out on a channel\n>>> without already having a channel _with outbound liquidity_.  So someone\n>>> cannot, say, open a channel to a random node and spam queries as the\n>>> directionality simply won't allow it.\n>>>\n>>> Lastly on the topic, the database could be shared among nodes for a\n>>> price, where a Lightning node can offer to store data per hour and the\n>>> person who wishes for redundancy can pay a Lightning invoice and provide\n>>> the data.  This data wouldn't have to be encrypted or private, since the\n>>> whole point is that it can be queried publicly.  You could even check if\n>>> they're honest by querying them and seeing if they pay you Bitcoin back.\n>>>\n>>> I think if nothing else, this would be a good spare functionality used\n>>> for rebalancing channels, if only to add some utility.\n>>>\n>>> Looking way far into the future, you could also submit queries like\n>>> \"What's the best place to get a burger in San Francisco\" and only the real\n>>> die-hard fans (and companies with some Bitcoin to burn for \"advertising\")\n>>> would be willing to pay for their opinion to be heard.\n>>>\n>>> Feedback appreciated,\n>>> Tyler\n>>>\n>>>\n>>>\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180610/b256d24e/attachment-0001.html>"
            },
            {
                "author": "Tyler H",
                "date": "2018-06-10T22:32:33",
                "message_text_only": "All,\n\nSorry for the rapid double message, but I forgot to mention here that Atlas\ncan be used as a punishment mechanism for eltoo channels.\n\nThanks,\nTyler\n\nOn Sun, Jun 10, 2018 at 6:29 PM Tyler H <tyzbit at gmail.com> wrote:\n\n> All,\n>\n> I've opened https://github.com/lightningnetwork/lightning-rfc/pull/441 to\n> get started on hashing out the features and behavior of Atlas.\n>\n> Thanks,\n> Tyler\n>\n> On Thu, Jun 7, 2018 at 4:45 AM Tyler H <tyzbit at gmail.com> wrote:\n>\n>> >But in a trustless environment, \"only mappings that actually pay out can\n>> be trusted\" is equivalent to \"all reads require a payout\"...?\n>>\n>> I'll rephrase to say \"can be trusted to be human meaningful\".  As you may\n>> recall, the goal of Numerifides was to create _human meaningful_ but still\n>> _trusted_ name mappings. If you want to know the IP to Google.com, you (the\n>> human) want _the right one_.  If you get the wrong one, even if the node\n>> paid you for it, you can ban that node as untrustworthy and over time,\n>> you'll have a set of trustworthy nodes.\n>>\n>> New nodes will start out less trustworthy than old nodes that continue to\n>> host mappings for the maximum number of people.  Though I'm not clear on\n>> the specifics of eltoo penalty transactions, I think that you can actually\n>> use this as a trust meter for which nodes have the most accurate mappings\n>> by combining proof of the routable channel, proof of a breach (either a\n>> current-state Lightning breach where the revocation key is used OR an eltoo\n>> breach where you can provide proof of the most recent state of a channel.\n>>\n>> >Presumably, in order to pay out, the mapping service needs to have\n>> *some* outgoing channel *somewhere*.\n>>\n>> Yes, in a way this is a sort of way to know which Lightning nodes are\n>> honest.  Perhaps this could be combined with eltoo as a way for Lightning\n>> to not even need Watchtowers.  Every node could be a watchtower, by\n>> announcing to the network at large when a channel is breached, thus nodes\n>> will likely want to close their channels with the less trustworthy nodes.\n>>\n>> In a way, Lightning decentralizes payments to be usable.  Atlas, as I've\n>> come to call it, centralizes trust over the entire Lightning Network.\n>>\n>> I appreciate the feedback, this is very helpful in refining this idea.\n>>\n>> Thanks,\n>> Tyler\n>>\n>> On Thu, Jun 7, 2018 at 4:07 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>\n>>> Good morning Tyler,\n>>>\n>>> Regarding proof of payment, a receiving node must have some inbound\n>>> Lightning capacity. Therefore, they must have spent funds on the LN\n>>> already. Attackers can't drain more than they've spent on their channels.\n>>> Node pubkeys can also be used such that rapid subsequent requests above a\n>>> threshold from a given pubkey fail after the first success.\n>>>\n>>> The read must be a payout, the point is that I get the mappings I care\n>>> about and Google (with more Bitcoin, processing power, or Lightning nodes)\n>>> can't come in and outbid me for them, or else I will just spam the fake\n>>> mapping for a steady stream of satoshis ;)\n>>>\n>>> Also, no one knows which node has the original mapping, only which nodes\n>>> are hosting them, and what mappings are available.\n>>>\n>>> The mappings themselves can be openly queried without payment. The\n>>> payment is so a client knows that a specific mapping has \"put its money\n>>> where its mouth is\" about it. Only mappings that actually pay out can be\n>>> trusted.\n>>>\n>>>\n>>> But in a trustless environment, \"only mappings that actually pay out can\n>>> be trusted\" is equivalent to \"all reads require a payout\"...?\n>>>\n>>> It would be easy for me to spin up a few hundred nodes, connect them\n>>> into cyclic superhubs, somehow arrange an incoming channel per superhub\n>>> (e.g. using an LN-to-chain bridge, or an exchange or similar service where\n>>> I can send my Lightning money and then recover it in some other form), then\n>>> make a few hundred queries of the mapping.  The mapping service cannot\n>>> differentiate between valid queries and invalid ones that I claim exist but\n>>> are not.  In short, you have no proof that the audience for the\n>>> advertisement exists (i.e. there is no Sybil protection for readers of the\n>>> mapping service).\n>>>\n>>> Presumably, in order to pay out, the mapping service needs to have\n>>> *some* outgoing channel *somewhere*. I might not be able to directly\n>>> convince the mapping service to make a direct channel to me, but I *could*\n>>> convince *somebody* to make an incoming channel to me (which is something\n>>> merchants would want to do, therefore such a service will arise (and likely\n>>> already exists)). Using normal Lightning operations, there could be a\n>>> viable path from the mapping service to a node on my cyclic superhub by\n>>> which I could drain them (if such a path could not exist, then LN as a\n>>> whole would have failed).  And if at least one node on a cyclic superhub\n>>> has an incoming channel, then the entire cyclic superhub is payable from\n>>> that channel.\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>>>\n>>> Compared to your alternate idea I believe this map of mappings, or the\n>>> \"Atlas bit\" as it could be called is much more decentalized, honest and\n>>> fair.\n>>>\n>>> Tyler\n>>>\n>>> On Wed, Jun 6, 2018, 23:36 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>>\n>>>> Good morning again Tyler,\n>>>>\n>>>> Building off the \"server-client database\" idea, here is an alternate\n>>>> idea.\n>>>>\n>>>> We have a special node type, an \"advertiser node\".  Aside from normal\n>>>> LN protocol, advertiser nodes also have the below interface:\n>>>>\n>>>> 1.  A \"write\" interface that lets advertisers pay to set a mapping.\n>>>> 2.  A \"read\" interface that lets audiences pay to get a mapping.  The\n>>>> payment here should be much smaller than the \"write\" interface.\n>>>> 3.  A \"proof\" interface that lets anyone query how much the advertiser\n>>>> node owns in its channels.  It may be possible to set things up so that if\n>>>> the advertiser lies, it loses some of its funds (if not, this scheme is not\n>>>> workable).\n>>>>\n>>>> If an advertiser node owns much funds, it probably earned that from\n>>>> many advertisers paying to set mappings, and audiences paying to get\n>>>> mappings.  So if the advertising node is inventing its audience, then it\n>>>> will have to lock some of its own funds and not spend it, sacrificing\n>>>> opportunity to invest it elsewhere.\n>>>>\n>>>> Of course, this is strongly centralizing and thus not recommended.\n>>>>\n>>>> Regards,\n>>>> ZmnSCPxj\n>>>>\n>>>>\n>>>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>>>\n>>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>>> On June 7, 2018 11:20 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>>>\n>>>> Good morning Tyler,\n>>>>\n>>>> It seems this can be a layer on top of LN.\n>>>>\n>>>> This is my understanding: the querier requests some mapping and sends\n>>>> also an invoice, the responder either fails, or returns the mapping and\n>>>> pays to the invoice.  So the responder pays to the querier.\n>>>>\n>>>> However it seems a little strange that I can get money by an action I\n>>>> initiate.\n>>>>\n>>>> For example, if I know that Google wants to claim some mapping, I could\n>>>> drain them of their allocated \"advertising funds\" by querying them\n>>>> repeatedly.\n>>>>\n>>>> In any case, non-distributed server-client protocols for storing\n>>>> database information I believe pay in reverse: the querier requests some\n>>>> query, the responder sends the encrypted data, an invoice with payment\n>>>> preimage, and a proof that the preimage is the (symmetric) encryption key\n>>>> to the encrypted data.  The querier pays the invoice and receives the\n>>>> preimage, which is the encryption key to the encrypted data.  The query may\n>>>> be a proof-of-storage so that a database client can have assurance that the\n>>>> server is indeed keeping its data alive.\n>>>>\n>>>> The mapping idea you have is the opposite of the above common\n>>>> consideration.  I suppose this is a pay-for-advertising, which I believe is\n>>>> not yet commonly researched yet.\n>>>>\n>>>> I believe a proposed pay-for-advertising should have the below\n>>>> considerations:\n>>>>\n>>>> 1.  As advertiser, I should get a proof that my advertisement did\n>>>> indeed reach some target audience, before I pay out.\n>>>> 2.  An attacker could trivially invent some target audience that it\n>>>> pretends exists, but might not actually exist.  How do we prove that the\n>>>> target audience exists?\n>>>>\n>>>> Regards,\n>>>> ZmnSCPxj\n>>>>\n>>>>\n>>>>\n>>>>\n>>>> Sent with ProtonMail <https://protonmail.com> Secure Email.\n>>>>\n>>>> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>>>> On June 7, 2018 10:27 AM, Tyler H <tyzbit at gmail.com> wrote:\n>>>>\n>>>> Greetings again, list.\n>>>>\n>>>> I have an idea that may be an excellent use-case for Lightning.  Where\n>>>> Numerifides was an attempt at decentralized identity rooted to the\n>>>> Blockchain, I thought of a new system that uses Lightning itself that seems\n>>>> superior, and perhaps gives Lightning even more utility than it currently\n>>>> has.\n>>>>\n>>>> The long and short of it is: I propose adding a feature (along with an\n>>>> RFC and a feature bit) to Lightning whereby any given node can be queried\n>>>> for a mapping (such as \"Give me the IP address for Google.com\" and the node\n>>>> can provide any answer one chooses _along with fulfilling a Lightning\n>>>> payment request the client provides_.\n>>>>\n>>>> The thinking here is nobody is willing to pay for mappings unless\n>>>> they're important, so mappings such as the pubkey associated with an\n>>>> unpopular username will only get paid by the person who has the username,\n>>>> or not paid at all, and thus the result can safely be disregarded.  Longer\n>>>> paths or more queries will cost the claimant more, plus it will cost for\n>>>> each query of the mapping.  Paying 1 satoshi (or less ;] ) per query for\n>>>> decentralized, trusted hosting of your data mappings seems fair.\n>>>>\n>>>> This is also aided by the fact that you cannot pay out on a channel\n>>>> without already having a channel _with outbound liquidity_.  So someone\n>>>> cannot, say, open a channel to a random node and spam queries as the\n>>>> directionality simply won't allow it.\n>>>>\n>>>> Lastly on the topic, the database could be shared among nodes for a\n>>>> price, where a Lightning node can offer to store data per hour and the\n>>>> person who wishes for redundancy can pay a Lightning invoice and provide\n>>>> the data.  This data wouldn't have to be encrypted or private, since the\n>>>> whole point is that it can be queried publicly.  You could even check if\n>>>> they're honest by querying them and seeing if they pay you Bitcoin back.\n>>>>\n>>>> I think if nothing else, this would be a good spare functionality used\n>>>> for rebalancing channels, if only to add some utility.\n>>>>\n>>>> Looking way far into the future, you could also submit queries like\n>>>> \"What's the best place to get a burger in San Francisco\" and only the real\n>>>> die-hard fans (and companies with some Bitcoin to burn for \"advertising\")\n>>>> would be willing to pay for their opinion to be heard.\n>>>>\n>>>> Feedback appreciated,\n>>>> Tyler\n>>>>\n>>>>\n>>>>\n>>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180610/c3217319/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "New idea on decentralized identity and truth (Re: Numerifides)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Tyler H",
                "ZmnSCPxj"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 60192
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] eltoo: A Simplified update Mechanism for Lightning and Off-Chain Contracts",
        "thread_messages": [
            {
                "author": "David A. Harding",
                "date": "2018-06-19T11:56:18",
                "message_text_only": "Hi,\n\nI finished a re-read of y'alls excellent paper describing Eltoo, and\nthere was something that confused me:\n\n> If the update transaction represents the last agreed upon state it can\n> use relatively low fees being certain that it will not be replaced. \n\nI don't understand why this is \"certain\"?  State_2 can't replace State_3\non the block chain (ignoring reorgs) because S_2's nLockTime of n+2\ndoesn't satisify S_3's CLTV-enforced minimum state number/locktime of\nn+4.  But in the mempool this constraint doesn't hold: if S_3 is in the\nmempool, S_2 can simply pay more fees than S_3 for RBF replacement.\n\nA mempool replacement of S_3 with S_2 also invalidates the transaction\ncontaining S_3 until one of the participants rewrites it from binding to\nState_1's outpoint to binding to S_2's outpoint.\n\nUnless I'm misunderstanding, this could perhaps be clarified to make\nclear that, even in the case of a cooperative close, monitoring for old\nstates needs to continue until the final state has whatever number of\nconfirmations a participant deems sufficient to make it immutable.\n\nThanks,\n\n-Dave\n\nP.S.: The paper I re-read was the version (as of yesterday) at blockstream.com/eltoo.pdf\n\n    $ grep -a CreationDate eltoo.pdf \n    /CreationDate (D:20180502232831+02'00')\n    $ sha256sum eltoo.pdf \n    aa630d637e4e1aedd91249d52609ab75b2eef2da8e4146e74f30e63c96fb7c26  eltoo.pdf\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180619/1c533520/attachment.sig>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-06-19T14:46:32",
                "message_text_only": "\"David A. Harding\" <dave at dtrt.org> writes:\n> I finished a re-read of y'alls excellent paper describing Eltoo, and\n> there was something that confused me:\n>\n>> If the update transaction represents the last agreed upon state it can\n>> use relatively low fees being certain that it will not be replaced. \n>\n> I don't understand why this is \"certain\"?  State_2 can't replace State_3\n> on the block chain (ignoring reorgs) because S_2's nLockTime of n+2\n> doesn't satisify S_3's CLTV-enforced minimum state number/locktime of\n> n+4.  But in the mempool this constraint doesn't hold: if S_3 is in the\n> mempool, S_2 can simply pay more fees than S_3 for RBF replacement.\n\nThat is true, we can't prevent S_2 to make it into the blockchain, but\nwe can make sure it doesn't have any effect (aside from wasting some\nfees), by simply binding S_3 to it immediately afterwards. So if S_3 is\nthe last agreed upon state, we can bind it to the funding output or any\nintermediate ones, i.e., when an intermediate update makes it into the\nblockchain. Eventually S_3, bound to some prior update output and\nideally directly to the funding output, will make it into the blockchain\nat which point the game is over. Intermediate updates may have leaked\ninto the blockchain, but did not unlock the intermediate settlement path\nand the blockchain was paid with the fees attached to the intermediate\nupdates.\n\n> A mempool replacement of S_3 with S_2 also invalidates the transaction\n> containing S_3 until one of the participants rewrites it from binding to\n> State_1's outpoint to binding to S_2's outpoint.\n\nIt should be noted that anyone can perform the rewriting, and it's easy\nto do so, by just following the funding output and knowing the final\nupdate.\n\n> Unless I'm misunderstanding, this could perhaps be clarified to make\n> clear that, even in the case of a cooperative close, monitoring for old\n> states needs to continue until the final state has whatever number of\n> confirmations a participant deems sufficient to make it immutable.\n\nGood point, we did not mention that finality has to be ensured, and that\nin a case of a reorg that unconfirms the update we might have to perform\nadditional rewrites. This is similar to LN-penalty where we actually\nneed to make sure that the penalty transaction is final and doesn't get\nreorged out.\n\n\nCheers,\nChristian"
            },
            {
                "author": "David A. Harding",
                "date": "2018-06-19T18:02:51",
                "message_text_only": "On Tue, Jun 19, 2018 at 04:46:32PM +0200, Christian Decker wrote:\n> That is true, we can't prevent S_2 to make it into the blockchain, but\n> we can make sure it doesn't have any effect (aside from wasting some\n> fees), by simply binding S_3 to it immediately afterwards. \n\nRight, but I'm picking on the phrasing in the paper here, which seems to\nimply that once the final settlement transaction enters the mempool with\na reasonable fee, its confirmation---and the safe close of the\nchannel---is \"certain.\"  I don't think that's the case and I think the\nphrasing might be accidentally misleading to readers who don't have a\ngood grasp of mempool behavior.\n\n> It should be noted that anyone can perform the rewriting, and it's easy\n> to do so, by just following the funding output and knowing the final\n> update.\n\nAnyone can rewrite a SIGHASH_NOINPUT input's outpoint, but the actual\ntransaction containing the settlement is expected to have (at least) two\ninputs, with the second one originating the fees.  That second input's\nsignature is (I assume) using SIGHASH_ALL to commit to all outpoints in\nthe transaction, so it can't be arbitrarily rewritten by a third-party\nto apply to a different state outpoint---and so I think we're dependent\non a motivated person (e.g. one of the channel participants) performing\nthe rewrite so that the rewritten final settlement transaction pays\nfees.\n\nThanks,\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180619/7bde3561/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2018-06-20T15:31:50",
                "message_text_only": "On Tue, Jun 19, 2018 at 02:02:51PM -0400, David A. Harding wrote:\n> Anyone can rewrite a SIGHASH_NOINPUT input's outpoint, but the actual\n> transaction containing the settlement is expected to have (at least) two\n> inputs, with the second one originating the fees.  That second input's\n> signature is (I assume) using SIGHASH_ALL to commit to all outpoints in\n> the transaction, so it can't be arbitrarily rewritten by a third-party\n> to apply to a different state outpoint\n\nI realized that the fee-paying input could possibly be signed with\nSIGHASH_ALL|SIGHASH_ANYONECANPAY to allow anyone to arbitrarily\nrewrite the other input signed with SIGHASH_NOINPUT.  However, this\nreminded me of the well-known DoS against transactions signed with\nSIGHASH_ANYONECANPAY[1], which seems to apply generally against\nSIGHASH_NOINPUT as well and may allow theft from HTLCs.\n\n## DoS against Eltoo settlements\n\nAlice and Mallory have a channel with some state updates.  Alice tries\nto initiate a cooperate close, but Mallory stalls and instead broadcasts\nthe trigger transaction and the first state (state 0).  Notably, the\nfirst state is bundled into a very large vsize transaction with a low\nfeerate.  State 1 is added to another very large low-feerate\ntransaction, as are states 2 through 9. \n\nAlice could in theory RBF the state 0 transaction, but per BIP125 rule\n#3, she needs to pay an absolute fee greater than all the transactions\nbeing replaced (not just a higher feerate).  That could cost a lot.\nAlice could also create a transaction that binds the final state to the\nstate 9 transaction and attempt CPFP, but increasing the feerate for the\ntransaction ancestor group to a satisfactory degree would cost the same\namount as RBF.\n\nSo Alice is stuck waiting for states 0-9 to confirm before the final\nstate can be confirmed.  During recent periods of full mempools on\ndefault nodes, the waiting time for 10 nBTC/vbyte transactions has been\nmore than two weeks.\n\n## HTLC theft\n\nIf Mallory is able to introduce significant settlement delays, HTLC\nsecurity is compromised.  For example, imagine this route:\n\n    Mallory <-> Alice <-> Bob\n\nMallory orders a widget from Bob and pays via LN by sending 1 BTC to\nAlice hashlocked and timelocked, which Alice forwards to Bob also\nhashlocked and timelocked.  Mallory releases the preimage to Bob, who\nclaims the funds from Alice and ships the widget, giving Alice the\npreimage.\n\nAt this point, Mallory broadcasts the transactions described in the\npreceding section.\n\nIf the low feerate of states 0-9 prevent them from confirming before the\ntimeout, Mallory can create a transaction containing a dishonest final\nstate that executes the refund branch.  Like before, she can bury this\nin an ancestor transaction chain that would be cost prohibitive for Alice\nto RBF.\n\nConsidered independently, this is a very expensive attack for Mallory,\nand so perhaps impractical.  But Mallory can join forces with someone\nalready creating large low-feerate consolidation transactions.  Better\nyet, from Mallory's perspective, she can execute the attack against\nhundreds of channels at once (creating long chains of ancestor\ntransactions that are large in aggregate rather than individually\nlarge), using the aggregate size of all the victims' channels against\neach of the individual victims.\n\nThanks,\n\n-Dave\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-August/006438.html\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180620/7ecf165a/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-06-22T00:32:01",
                "message_text_only": "\"David A. Harding\" <dave at dtrt.org> writes:\n> On Tue, Jun 19, 2018 at 02:02:51PM -0400, David A. Harding wrote:\n>> Anyone can rewrite a SIGHASH_NOINPUT input's outpoint, but the actual\n>> transaction containing the settlement is expected to have (at least) two\n>> inputs, with the second one originating the fees.  That second input's\n>> signature is (I assume) using SIGHASH_ALL to commit to all outpoints in\n>> the transaction, so it can't be arbitrarily rewritten by a third-party\n>> to apply to a different state outpoint\n>\n> I realized that the fee-paying input could possibly be signed with\n> SIGHASH_ALL|SIGHASH_ANYONECANPAY to allow anyone to arbitrarily\n> rewrite the other input signed with SIGHASH_NOINPUT.  However, this\n> reminded me of the well-known DoS against transactions signed with\n> SIGHASH_ANYONECANPAY[1], which seems to apply generally against\n> SIGHASH_NOINPUT as well and may allow theft from HTLCs.\n\nYes, RBF Rule #3 again :( It makes RBF unusable in adversarial\nconditions, and it's not miner incentive-compatible.\n\nThe only mitigations I have been able to come up with are:\n\n1. Reduce the RBF grouping depth to 2, not 10.  This doesn't help\n   here though, since you can still have ~infinite fan-out of txs\n   (create 1000 outputs, spend each with a 400ksipa tx).\n\n2. Revert #3 to a simple \"greater feerate\" rule, but delay propagation\n   proportional to tx weight, say 60 seconds (fuzzed) for a 400 ksipa\n   tx.  That reduces your ability to spam the network (you can always\n   connect directly to nodes and waste their time and bandwidth, but you\n   can do that pretty much today).\n\nFrankly, I'd also like a similar mechanism to not reject low-fee txs\n(above 250 satoshi per ksipa) but simply not propagate them.  Drop them\nafter 60 seconds if there's no CPFP to increase their effective feerate.\nThat would allow us to use CPFP on lightning commitment txs today,\nwithout having to guess what fees will be sometime in the future.\n\nCheers,\nRusty.\n\n> ## DoS against Eltoo settlements\n>\n> Alice and Mallory have a channel with some state updates.  Alice tries\n> to initiate a cooperate close, but Mallory stalls and instead broadcasts\n> the trigger transaction and the first state (state 0).  Notably, the\n> first state is bundled into a very large vsize transaction with a low\n> feerate.  State 1 is added to another very large low-feerate\n> transaction, as are states 2 through 9. \n>\n> Alice could in theory RBF the state 0 transaction, but per BIP125 rule\n> #3, she needs to pay an absolute fee greater than all the transactions\n> being replaced (not just a higher feerate).  That could cost a lot.\n> Alice could also create a transaction that binds the final state to the\n> state 9 transaction and attempt CPFP, but increasing the feerate for the\n> transaction ancestor group to a satisfactory degree would cost the same\n> amount as RBF.\n>\n> So Alice is stuck waiting for states 0-9 to confirm before the final\n> state can be confirmed.  During recent periods of full mempools on\n> default nodes, the waiting time for 10 nBTC/vbyte transactions has been\n> more than two weeks.\n>\n> ## HTLC theft\n>\n> If Mallory is able to introduce significant settlement delays, HTLC\n> security is compromised.  For example, imagine this route:\n>\n>     Mallory <-> Alice <-> Bob\n>\n> Mallory orders a widget from Bob and pays via LN by sending 1 BTC to\n> Alice hashlocked and timelocked, which Alice forwards to Bob also\n> hashlocked and timelocked.  Mallory releases the preimage to Bob, who\n> claims the funds from Alice and ships the widget, giving Alice the\n> preimage.\n>\n> At this point, Mallory broadcasts the transactions described in the\n> preceding section.\n>\n> If the low feerate of states 0-9 prevent them from confirming before the\n> timeout, Mallory can create a transaction containing a dishonest final\n> state that executes the refund branch.  Like before, she can bury this\n> in an ancestor transaction chain that would be cost prohibitive for Alice\n> to RBF.\n>\n> Considered independently, this is a very expensive attack for Mallory,\n> and so perhaps impractical.  But Mallory can join forces with someone\n> already creating large low-feerate consolidation transactions.  Better\n> yet, from Mallory's perspective, she can execute the attack against\n> hundreds of channels at once (creating long chains of ancestor\n> transactions that are large in aggregate rather than individually\n> large), using the aggregate size of all the victims' channels against\n> each of the individual victims.\n>\n> Thanks,\n>\n> -Dave\n>\n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-August/006438.html\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "eltoo: A Simplified update Mechanism for Lightning and Off-Chain Contracts",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "Christian Decker"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 14177
        }
    },
    {
        "title": "[Lightning-dev] Mesh network problem",
        "thread_messages": [
            {
                "author": "Joseph Hoane",
                "date": "2018-06-20T18:15:19",
                "message_text_only": "I root for the Lightening Network\u2019s success, but it seems to have an inherent weakness. Since\u00a0routing tables are not part of the architecture\u00a0how can the sender chose the next recipient so as to effect\u00a0an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver\u2019s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\u00a0\nI don\u2019t think any solution to the mesh network routing problem has been found.\u00a0What am I missing here?\u00a0 Thanks.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180620/3d0d68dd/attachment.html>"
            },
            {
                "author": "Andy Schroder",
                "date": "2018-06-20T18:57:54",
                "message_text_only": "Who do you think controls the routing table for the internet? Is the internet not a mesh network?\n\n--\nAndy Schroder\n\nOn June 20, 2018 2:15:19 PM EDT, Joseph Hoane via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>I root for the Lightening Network\u2019s success, but it seems to have an\n>inherent weakness. Since\u00a0routing tables are not part of the\n>architecture\u00a0how can the sender chose the next recipient so as to\n>effect\u00a0an efficient path to the ultimate receiver? With no routing\n>table available the next receiver's connection to the remote ultimate\n>receiver or to the ultimate receiver\u2019s proximate connections is\n>unknown. Even a powerful bridge node will not know an efficient\n>subsequent path and could send the message on in exactly the most\n>inefficient direction. How does choosing an efficient next intermediate\n>receiver not remain a guess, a shot in the dark?\u00a0\n>I don\u2019t think any solution to the mesh network routing problem has been\n>found.\u00a0What am I missing here?\u00a0 Thanks.\n>\n>\n>\n>------------------------------------------------------------------------\n>\n>_______________________________________________\n>Lightning-dev mailing list\n>Lightning-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180620/9472e474/attachment.html>"
            },
            {
                "author": "Oleg Sadov",
                "date": "2018-06-22T19:59:09",
                "message_text_only": "May be it would be reasonable to think about using of SDN\ntechnologies, such as OpenFlow. This specification is supported by\nmany SW and HW NW switches. This allows you to create a NW\nconfiguration managed by the L7 OSI application layer with NW packet\nrouting and transparent transformation for the sender/receiver pair.\nWe use this technology for building of SDN-enabled Blockchain\nmodelling NW environments (for ex. NWs with Quantum Cryptography) for\nR&D projects of our students:\n\nhttp://balchemylab.gitlab.io/\n\n\u0441\u0440, 20 \u0438\u044e\u043d. 2018 \u0433. \u0432 22:07, Andy Schroder <info at andyschroder.com>:\n>\n> Who do you think controls the routing table for the internet? Is the internet not a mesh network?\n>\n> --\n> Andy Schroder\n>\n> On June 20, 2018 2:15:19 PM EDT, Joseph Hoane via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>>\n>> I root for the Lightening Network\u2019s success, but it seems to have an inherent weakness. Since routing tables are not part of the architecture how can the sender chose the next recipient so as to effect an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver\u2019s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\n>> I don\u2019t think any solution to the mesh network routing problem has been found. What am I missing here?  Thanks.\n>>\n>>\n>> ________________________________\n>>\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-23T02:06:15",
                "message_text_only": "Good morning Joseph,\n\n> I root for the Lightening Network\u2019s success, but it seems to have an inherent weakness. Since routing tables are not part of the architecture how can the sender chose the next recipient so as to effect an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver\u2019s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\n> \n> I don\u2019t think any solution to the mesh network routing problem has been found. What am I missing here? Thanks.\n\n\nThe current spec has each participant share their views of the entire graph with each other.  The payer uses its own local view of the entire network to create a route from payer to payee.  None of the intermediate nodes need to make any decisions or keep routing tables: the entire route has been found by the payer in the first place.  No guesswork is necessary: either you know of a route and can provide it entirely (so intermediate nodes never have to guess) or you know of no route and are unable to pay.\n\nThe existence of channels has a simple proof: every channel is backed by a 2-of-2 multisig UTXO.  When sharing views of network graph, each channel in the view includes a reference to the UTXO backing it.  To show that the channels are indeed Lightning channels, a signature matching the 2-of-2 multisig is required.  The proof-of-channel-existence is thus the reference to the UTXO, plus a signature signing that reference.  If a node receives a supposed channel from a peer, but the UTXO does not exist or is already spent, then the node ignores that channel and does not add it to its local network view..  It is thus not possible to fake a channel (to spam the network views of Lightning peers) without actually committing money into some UTXO, which deters spam.\n\nThe solution currently in use is simple and direct, at the cost that each node has to keep a view of the entire network.  The so-called \"Lightning Network scaling problem\" is largely a problem of these local network views becoming too large for low-end devices to keep; perhaps the Eclair developers should chime in at this point, since they target mobile devices and may be able to give a perspective on whether the network map is too large for mobile devices already.\n\n--\n\nThe mesh network routing problem in general can be solved by self-addressing packets (like IP (the Internet) uses).\n\nWhen a node receives a packet that is not addressed to it, it looks up the destination address in its routing table. If it does not exist in the routing table, then the node simply throws it to some other peer, which at least is progress.\n\nSimilarly, a \"payment packet\" can offer a forwarding fee and the payment.  When a node receives it, it could deduct some part of the fee for itself and attempt to forward it to one of its other peers.  The more accurately it can forward the payment, the more likely it can earn from the forwarding fees (if the payment fails to reach the destination then the node cannot earn fee).  Even a simple \"try all your peers\" approach would in aggregate result in a breadth-first search of the network graph, so if it is reachable then the payment will indeed get forwarded.  The drawback is that it reveals the destination of the payment, which is why Lightning went with onion routing.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Mesh network problem",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Oleg Sadov",
                "Joseph Hoane",
                "Andy Schroder",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7984
        }
    },
    {
        "title": "[Lightning-dev] Second Level Protocols - Lightning - Patents",
        "thread_messages": [
            {
                "author": "Praveen Baratam",
                "date": "2018-06-22T15:21:28",
                "message_text_only": "Hello everybody,\n\nI just heard from a friend that Second Level Protocols such as Lightening\nNetwork can be patented if the author/inventor chooses to!\n\nIs it possible? Am I missing something?\n\nBest,\n\nPraveen Baratam\n\nabout.me <http://about.me/praveen.baratam>\n\u1427\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180622/1607c88e/attachment.html>"
            },
            {
                "author": "Tim Blokdijk",
                "date": "2018-06-22T15:35:07",
                "message_text_only": "Probably not in the EU. Both 'mathematical methods' and 'programs for \ncomputers' are excluded from being patented.\n\n\nOp 22-06-18 om 17:21 schreef Praveen Baratam:\n> Hello everybody,\n>\n> I just heard from a friend that Second Level Protocols such as \n> Lightening Network can be patented if the author/inventor chooses to!\n>\n> Is it possible? Am I missing something?\n>\n> Best,\n>\n> Praveen Baratam\n>\n> about.me <http://about.me/praveen.baratam>\n> \u1427\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180622/e8c61140/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-29T02:55:29",
                "message_text_only": "Good morning Praveen,\n\nThe patent system, has intent, that the inventor will completely reveal the design of the invention, in exchange for a (time-bound) state monopoly on the construction and sale of the invention.  The intent, is that the inventor is compensated for the toil in creating the invention, while the revealed design may help future inventors to consider, an improved designed, after the granted monopoly has ended.\n\nThus, the patent system, has the concept, \"prior art\".\n\nIf the item being patented, is in the past (\"prior\") already known among practitioners (\"art\"), then there is no need for the state to \"pay for\" revealing the design by granting a monopoly.  Already, the design is revealed and known, so why should the state pay the inventor with a state-enforced monopoly?\n\nImportantly, any evidence, that the design of the invention is known, is prior art. This includes publications made by the inventor himself or herself.  It is prior art since the fact of publication indicates that other practitioners now know of the art of the new design.\n\nAnother consideration, is the \"grace period\".\n\nAn inventor may publish, the design of the invention, at some past point, and then file for a patent afterward.  However, the fact of the publication, even initiated by the inventor, is itself prior art, and is evidence that the invention is known (and that the state must, logically, not pay for it by enforcing a patent-backed monopoly).\n\nOf course, an inventor may publish an invention with intent to patent it later. Thus, the state allows, a grace period, after the inventor publishes the design, to patent the design. Importantly, this grace period is not of unlimited duration.  The de facto global state government, the USA, provides a grace period of 1 year only.\n\nFor reference, the Poon-Dryja whitepaper for Lightning was published in 2016, and the current year is now known to be 2018.\n\nAs the current Lightning design is designed publicly and continuously published in the lightning-rfc (thus a continuous evidence that the design of Lightning is already known), and is in any case based on the prior-art Poon-Dryja paper, and neither Poon nor Dryja have applied for patents of the Lightning design within a year of publication of the Poon-Dryja paper, then the state will not bother to grant a patent to the inventors of Lightning.\n\n(the above describes the ideal operation of patent systems. it should be noted, that agents operating patent systems are known to run on cognitive substrates that are highly amenable to external corrupting influences, and thus non-ideal operation may occur in practice.)\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn June 22, 2018 11:21 PM, Praveen Baratam <praveen.baratam at gmail.com> wrote:\n\n> Hello everybody,\n>\n> I just heard from a friend that Second Level Protocols such as Lightening Network can be patented if the author/inventor chooses to!\n>\n> Is it possible? Am I missing something?\n>\n> Best,\n>\n> Praveen Baratam\n>\n> [about.me](http://about.me/praveen.baratam)\n> \u1427\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180628/d37990cf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Second Level Protocols - Lightning - Patents",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Praveen Baratam",
                "Tim Blokdijk",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4572
        }
    },
    {
        "title": "[Lightning-dev] help",
        "thread_messages": [
            {
                "author": "flop py",
                "date": "2018-06-24T21:50:17",
                "message_text_only": ">Saturday, June 23, 2018 3:01 PM +03:00 from lightning-dev-request at lists.linuxfoundation.org:\n>\n>Send Lightning-dev mailing list submissions to\n>lightning-dev at lists.linuxfoundation.org\n>\n>To subscribe or unsubscribe via the World Wide Web, visit\n>https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>or, via email, send a message with subject or body 'help' to\n>lightning-dev-request at lists.linuxfoundation.org\n>\n>You can reach the person managing the list at\n>lightning-dev-owner at lists.linuxfoundation.org\n>\n>When replying, please edit your Subject line so it is more specific\n>than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n>Today's Topics:\n>\n>\u00a0\u00a0\u00a01. Second Level Protocols - Lightning - Patents (Praveen Baratam)\n>\u00a0\u00a0\u00a02. Re: Second Level Protocols - Lightning - Patents (Tim Blokdijk)\n>\u00a0\u00a0\u00a03. Re: Mesh network problem (Oleg Sadov)\n>\u00a0\u00a0\u00a04. Re: Mesh network problem (ZmnSCPxj)\n>\n>\n>----------------------------------------------------------------------\n>\n>Message: 1\n>Date: Fri, 22 Jun 2018 20:51:28 +0530\n>From: Praveen Baratam < praveen.baratam at gmail.com >\n>To: Lightning-dev < lightning-dev at lists.linuxfoundation.org >\n>Subject: [Lightning-dev] Second Level Protocols - Lightning - Patents\n>Message-ID:\n>< CAAQs3wsGuCyb6OEpvtAtuThtGnE74vQmOQ24O5VLYBG8Kk2GTw at mail.gmail.com >\n>Content-Type: text/plain; charset=\"utf-8\"\n>\n>\u00a0Hello everybody,\n>\n>I just heard from a friend that Second Level Protocols such as Lightening\n>Network can be patented if the author/inventor chooses to!\n>\n>Is it possible? Am I missing something?\n>\n>Best,\n>\n>Praveen Baratam\n>\n>about.me < http://about.me/praveen.baratam >\n>?\n>-------------- next part --------------\n>An HTML attachment was scrubbed...\n>URL: < http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180622/1607c88e/attachment-0001.html >\n>\n>------------------------------\n>\n>Message: 2\n>Date: Fri, 22 Jun 2018 17:35:07 +0200\n>From: Tim Blokdijk < tim at timblokdijk.nl >\n>To:  lightning-dev at lists.linuxfoundation.org\n>Subject: Re: [Lightning-dev] Second Level Protocols - Lightning -\n>Patents\n>Message-ID: < 07859b75-9c76-0e1d-e565-8e82402e7423 at timblokdijk.nl >\n>Content-Type: text/plain; charset=\"utf-8\"; Format=\"flowed\"\n>\n>Probably not in the EU. Both 'mathematical methods' and 'programs for \n>computers' are excluded from being patented.\n>\n>\n>Op 22-06-18 om 17:21 schreef Praveen Baratam:\n>> Hello everybody,\n>>\n>> I just heard from a friend that Second Level Protocols such as \n>> Lightening Network can be patented if the author/inventor chooses to!\n>>\n>> Is it possible? Am I missing something?\n>>\n>> Best,\n>>\n>> Praveen Baratam\n>>\n>> about.me < http://about.me/praveen.baratam >\n>> ?\n>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>>  Lightning-dev at lists.linuxfoundation.org\n>>  https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>-------------- next part --------------\n>An HTML attachment was scrubbed...\n>URL: < http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180622/e8c61140/attachment-0001.html >\n>\n>------------------------------\n>\n>Message: 3\n>Date: Fri, 22 Jun 2018 22:59:09 +0300\n>From: Oleg Sadov < oleg.sadov at gmail.com >\n>To:  Lightning-dev at lists.linuxfoundation.org\n>Subject: Re: [Lightning-dev] Mesh network problem\n>Message-ID:\n>< CAGpBVFvHrp3A=4heisxba7MsfG9FLdK-RiOQDf=DRsryLWEP8w at mail.gmail.com >\n>Content-Type: text/plain; charset=\"UTF-8\"\n>\n>May be it would be reasonable to think about using of SDN\n>technologies, such as OpenFlow. This specification is supported by\n>many SW and HW NW switches. This allows you to create a NW\n>configuration managed by the L7 OSI application layer with NW packet\n>routing and transparent transformation for the sender/receiver pair.\n>We use this technology for building of SDN-enabled Blockchain\n>modelling NW environments (for ex. NWs with Quantum Cryptography) for\n>R&D projects of our students:\n>\n>http://balchemylab.gitlab.io/\n>\n>??, 20 ???. 2018 ?. ? 22:07, Andy Schroder < info at andyschroder.com >:\n>>\n>> Who do you think controls the routing table for the internet? Is the internet not a mesh network?\n>>\n>> --\n>> Andy Schroder\n>>\n>> On June 20, 2018 2:15:19 PM EDT, Joseph Hoane via Lightning-dev < lightning-dev at lists.linuxfoundation.org > wrote:\n>>>\n>>> I root for the Lightening Network?s success, but it seems to have an inherent weakness. Since routing tables are not part of the architecture how can the sender chose the next recipient so as to effect an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver?s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\n>>> I don?t think any solution to the mesh network routing problem has been found. What am I missing here?  Thanks.\n>>>\n>>>\n>>> ________________________________\n>>>\n>>> Lightning-dev mailing list\n>>>  Lightning-dev at lists.linuxfoundation.org\n>>>  https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>>  Lightning-dev at lists.linuxfoundation.org\n>>  https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>------------------------------\n>\n>Message: 4\n>Date: Fri, 22 Jun 2018 22:06:15 -0400\n>From: ZmnSCPxj < ZmnSCPxj at protonmail.com >\n>To: \"lightning-dev\\\\@lists.linuxfoundation.org\"\n>< lightning-dev at lists.linuxfoundation.org >\n>Subject: Re: [Lightning-dev] Mesh network problem\n>Message-ID:\n>< m0W7J5znQ0u9rUzIE6skSPKX50sWp3kqjz_FEsT_gdhcAGQ_r-RtTcGf7w0Ogxr3opxoBTofgMxY_LOLDy0qPtf4z7gYzARjSXJrZcTUmkc=@protonmail.com >\n>\n>Content-Type: text/plain; charset=UTF-8\n>\n>Good morning Joseph,\n>\n>> I root for the Lightening Network?s success, but it seems to have an inherent weakness. Since routing tables are not part of the architecture how can the sender chose the next recipient so as to effect an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver?s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\n>> \n>> I don?t think any solution to the mesh network routing problem has been found. What am I missing here? Thanks.\n>\n>\n>The current spec has each participant share their views of the entire graph with each other.  The payer uses its own local view of the entire network to create a route from payer to payee.  None of the intermediate nodes need to make any decisions or keep routing tables: the entire route has been found by the payer in the first place.  No guesswork is necessary: either you know of a route and can provide it entirely (so intermediate nodes never have to guess) or you know of no route and are unable to pay.\n>\n>The existence of channels has a simple proof: every channel is backed by a 2-of-2 multisig UTXO.  When sharing views of network graph, each channel in the view includes a reference to the UTXO backing it.  To show that the channels are indeed Lightning channels, a signature matching the 2-of-2 multisig is required.  The proof-of-channel-existence is thus the reference to the UTXO, plus a signature signing that reference.  If a node receives a supposed channel from a peer, but the UTXO does not exist or is already spent, then the node ignores that channel and does not add it to its local network view..  It is thus not possible to fake a channel (to spam the network views of Lightning peers) without actually committing money into some UTXO, which deters spam.\n>\n>The solution currently in use is simple and direct, at the cost that each node has to keep a view of the entire network.  The so-called \"Lightning Network scaling problem\" is largely a problem of these local network views becoming too large for low-end devices to keep; perhaps the Eclair developers should chime in at this point, since they target mobile devices and may be able to give a perspective on whether the network map is too large for mobile devices already.\n>\n>--\n>\n>The mesh network routing problem in general can be solved by self-addressing packets (like IP (the Internet) uses).\n>\n>When a node receives a packet that is not addressed to it, it looks up the destination address in its routing table. If it does not exist in the routing table, then the node simply throws it to some other peer, which at least is progress.\n>\n>Similarly, a \"payment packet\" can offer a forwarding fee and the payment.  When a node receives it, it could deduct some part of the fee for itself and attempt to forward it to one of its other peers.  The more accurately it can forward the payment, the more likely it can earn from the forwarding fees (if the payment fails to reach the destination then the node cannot earn fee).  Even a simple \"try all your peers\" approach would in aggregate result in a breadth-first search of the network graph, so if it is reachable then the payment will indeed get forwarded.  The drawback is that it reveals the destination of the payment, which is why Lightning went with onion routing.\n>\n>Regards,\n>ZmnSCPxj\n>\n>\n>------------------------------\n>\n>_______________________________________________\n>Lightning-dev mailing list\n>Lightning-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>End of Lightning-dev Digest, Vol 34, Issue 13\n>*********************************************\n\n\nmailto:floppynet at mail.ru\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180625/111d370f/attachment-0001.html>"
            },
            {
                "author": "Oleg Sadov",
                "date": "2018-06-25T16:29:04",
                "message_text_only": "What's the Question?\n\u043f\u043d, 25 \u0438\u044e\u043d. 2018 \u0433. \u0432 1:41, flop py via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org>:\n>\n>\n>\n>\n> Saturday, June 23, 2018 3:01 PM +03:00 from lightning-dev-request at lists.linuxfoundation.org:\n>\n> Send Lightning-dev mailing list submissions to\n> lightning-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> or, via email, send a message with subject or body 'help' to\n> lightning-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n> lightning-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Second Level Protocols - Lightning - Patents (Praveen Baratam)\n>    2. Re: Second Level Protocols - Lightning - Patents (Tim Blokdijk)\n>    3. Re: Mesh network problem (Oleg Sadov)\n>    4. Re: Mesh network problem (ZmnSCPxj)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Fri, 22 Jun 2018 20:51:28 +0530\n> From: Praveen Baratam <praveen.baratam at gmail.com>\n> To: Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n> Subject: [Lightning-dev] Second Level Protocols - Lightning - Patents\n> Message-ID:\n> <CAAQs3wsGuCyb6OEpvtAtuThtGnE74vQmOQ24O5VLYBG8Kk2GTw at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n>  Hello everybody,\n>\n> I just heard from a friend that Second Level Protocols such as Lightening\n> Network can be patented if the author/inventor chooses to!\n>\n> Is it possible? Am I missing something?\n>\n> Best,\n>\n> Praveen Baratam\n>\n> about.me <http://about.me/praveen.baratam>\n> ?\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180622/1607c88e/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Fri, 22 Jun 2018 17:35:07 +0200\n> From: Tim Blokdijk <tim at timblokdijk.nl>\n> To: lightning-dev at lists.linuxfoundation.org\n> Subject: Re: [Lightning-dev] Second Level Protocols - Lightning -\n> Patents\n> Message-ID: <07859b75-9c76-0e1d-e565-8e82402e7423 at timblokdijk.nl>\n> Content-Type: text/plain; charset=\"utf-8\"; Format=\"flowed\"\n>\n> Probably not in the EU. Both 'mathematical methods' and 'programs for\n> computers' are excluded from being patented.\n>\n>\n> Op 22-06-18 om 17:21 schreef Praveen Baratam:\n> > Hello everybody,\n> >\n> > I just heard from a friend that Second Level Protocols such as\n> > Lightening Network can be patented if the author/inventor chooses to!\n> >\n> > Is it possible? Am I missing something?\n> >\n> > Best,\n> >\n> > Praveen Baratam\n> >\n> > about.me <http://about.me/praveen.baratam>\n> > ?\n> >\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180622/e8c61140/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Fri, 22 Jun 2018 22:59:09 +0300\n> From: Oleg Sadov <oleg.sadov at gmail.com>\n> To: Lightning-dev at lists.linuxfoundation.org\n> Subject: Re: [Lightning-dev] Mesh network problem\n> Message-ID:\n> <CAGpBVFvHrp3A=4heisxba7MsfG9FLdK-RiOQDf=DRsryLWEP8w at mail.gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> May be it would be reasonable to think about using of SDN\n> technologies, such as OpenFlow. This specification is supported by\n> many SW and HW NW switches. This allows you to create a NW\n> configuration managed by the L7 OSI application layer with NW packet\n> routing and transparent transformation for the sender/receiver pair.\n> We use this technology for building of SDN-enabled Blockchain\n> modelling NW environments (for ex. NWs with Quantum Cryptography) for\n> R&D projects of our students:\n>\n> http://balchemylab.gitlab.io/\n>\n> ??, 20 ???. 2018 ?. ? 22:07, Andy Schroder <info at andyschroder.com>:\n> >\n> > Who do you think controls the routing table for the internet? Is the internet not a mesh network?\n> >\n> > --\n> > Andy Schroder\n> >\n> > On June 20, 2018 2:15:19 PM EDT, Joseph Hoane via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >> I root for the Lightening Network?s success, but it seems to have an inherent weakness. Since routing tables are not part of the architecture how can the sender chose the next recipient so as to effect an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver?s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\n> >> I don?t think any solution to the mesh network routing problem has been found. What am I missing here? Thanks.\n> >>\n> >>\n> >> ________________________________\n> >>\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> ------------------------------\n>\n> Message: 4\n> Date: Fri, 22 Jun 2018 22:06:15 -0400\n> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> To: \"lightning-dev\\\\@lists.linuxfoundation.org\"\n> <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] Mesh network problem\n> Message-ID:\n> <m0W7J5znQ0u9rUzIE6skSPKX50sWp3kqjz_FEsT_gdhcAGQ_r-RtTcGf7w0Ogxr3opxoBTofgMxY_LOLDy0qPtf4z7gYzARjSXJrZcTUmkc=@protonmail.com>\n>\n> Content-Type: text/plain; charset=UTF-8\n>\n> Good morning Joseph,\n>\n> > I root for the Lightening Network?s success, but it seems to have an inherent weakness. Since routing tables are not part of the architecture how can the sender chose the next recipient so as to effect an efficient path to the ultimate receiver? With no routing table available the next receiver's connection to the remote ultimate receiver or to the ultimate receiver?s proximate connections is unknown. Even a powerful bridge node will not know an efficient subsequent path and could send the message on in exactly the most inefficient direction. How does choosing an efficient next intermediate receiver not remain a guess, a shot in the dark?\n> >\n> > I don?t think any solution to the mesh network routing problem has been found. What am I missing here? Thanks.\n>\n>\n> The current spec has each participant share their views of the entire graph with each other. The payer uses its own local view of the entire network to create a route from payer to payee. None of the intermediate nodes need to make any decisions or keep routing tables: the entire route has been found by the payer in the first place. No guesswork is necessary: either you know of a route and can provide it entirely (so intermediate nodes never have to guess) or you know of no route and are unable to pay.\n>\n> The existence of channels has a simple proof: every channel is backed by a 2-of-2 multisig UTXO. When sharing views of network graph, each channel in the view includes a reference to the UTXO backing it. To show that the channels are indeed Lightning channels, a signature matching the 2-of-2 multisig is required. The proof-of-channel-existence is thus the reference to the UTXO, plus a signature signing that reference. If a node receives a supposed channel from a peer, but the UTXO does not exist or is already spent, then the node ignores that channel and does not add it to its local network view.. It is thus not possible to fake a channel (to spam the network views of Lightning peers) without actually committing money into some UTXO, which deters spam.\n>\n> The solution currently in use is simple and direct, at the cost that each node has to keep a view of the entire network. The so-called \"Lightning Network scaling problem\" is largely a problem of these local network views becoming too large for low-end devices to keep; perhaps the Eclair developers should chime in at this point, since they target mobile devices and may be able to give a perspective on whether the network map is too large for mobile devices already.\n>\n> --\n>\n> The mesh network routing problem in general can be solved by self-addressing packets (like IP (the Internet) uses).\n>\n> When a node receives a packet that is not addressed to it, it looks up the destination address in its routing table. If it does not exist in the routing table, then the node simply throws it to some other peer, which at least is progress.\n>\n> Similarly, a \"payment packet\" can offer a forwarding fee and the payment. When a node receives it, it could deduct some part of the fee for itself and attempt to forward it to one of its other peers. The more accurately it can forward the payment, the more likely it can earn from the forwarding fees (if the payment fails to reach the destination then the node cannot earn fee). Even a simple \"try all your peers\" approach would in aggregate result in a breadth-first search of the network graph, so if it is reachable then the payment will indeed get forwarded. The drawback is that it reveals the destination of the payment, which is why Lightning went with onion routing.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> ------------------------------\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> End of Lightning-dev Digest, Vol 34, Issue 13\n> *********************************************\n>\n>\n>\n> mailto:floppynet at mail.ru\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "help",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Oleg Sadov",
                "flop py"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 20454
        }
    },
    {
        "title": "[Lightning-dev] Including a Protocol for splicing to BOLT",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-06-25T10:10:26",
                "message_text_only": "Hey everyone,\n\nI found a mail from 6 month ago on this list ( c.f.:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2017-December/000865.html\n)\nin which it was stated that there was a plan to include a splicing protocol\nas BOLT 1.1 (On a side node I wonder weather it would make more sense to\ninclude splicing to BOLT 3?) I checked out the git repo and issues and\ndon't see that anyone is currently working on that topic and that it hasn't\nbeen included yet. Am I correct?\nIf noone works on this at the moment and the spec is still needed I might\ntake the initiative on that one over the next weeks. If someone is working\non this I would kindly offer my support.\n\nThe background for my question: Last weekend I have been attending the 2nd\nlightninghackday in Berlin and we had quite some intensive discussions\nabout the autopilot feature and splicing. (c.f. a summary can be found on\nmy blog:\nhttps://www.rene-pickhardt.de/improve-the-autopilot-of-bitcoins-lightning-network-summary-of-the-bar-camp-session-at-the-2nd-lightninghackday-in-berlin\n)\n\nThey people from lightning labs told me that they are currently started\nworking on splicing but even though it seems technically straight forward\nthe protocols should also be formalized. Previously I planned working on\nimproving the intelligence of the autopilot feature of the lightning\nnetwork however on the weekend I got convinced that splicing should be much\nhigher priority and the process should be specified in the lightning rfc.\n\nAlso it would be nice if someone would be willing to help out improving the\nquality of the spec that I would create since it will be my first time\nadding work to such a formal rfc.\n\nbest Rene\n\n\n-- \nwww.rene-pickhardt.de\n<http://www.beijing-china-blog.com/>\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180625/d400f365/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2018-06-25T19:35:41",
                "message_text_only": "Hi Ren\u00e9,\n\nSpeaking at a high level, the main differ between modifying autopilot\nstrategies (channel bootstrapping, and maintenance) vs something like\nsplicing, is that the former is purely policy while the latter is actually a\nprotocol modifications. With respect to difficulty, the first option (in lnd\nat least) requires a dev to work solely on a high level (implementing a\nseries of \"pure\" interfaces), on the other hand something like splicing\nrequires a bit more low-level knowledge of Bitcoin, the protocol, and also\nspecific details of an implementation (funding channels, signing, sync,\netc).\n\nSplicing is likely something to be included (along with many other things on\nour various wish lists) within BOLT 1.1, which will start to be \"officially\"\ndrafted late fall of this year. However of course it's possible for\nimplementations to start to draft up working versions, reserving a temporary\nfeature bit.\n\n> They people from lightning labs told me that they are currently started\n> working on splicing\n\nYep, I have a branch locally that has started a full async version of\nsplicing. Mostly started to see if any implementation level details would be\na surprise, compared to how we think it all should work in our heads.\n\n> but even though it seems technically straight forward t\n\nWell the full async implementation may be a bit involved, depending on the\narchitecture of the implementation (see the second point below).\n\nIn the abstract, I'd say a splicing proposal should include the following:\n\n  * a generic message for both splice in/out\n    * this allows both sides to schedule/queue up possible changes,\n      opportunistically piggy-backing then on top of the other sides\n      initiation\n    * most of the channel params can also be re-negotiated as this point,\n      another upside is this effectively allows garbage collecting old\n      revocation state\n  * fully async splice in/out\n     * async is ideal as we don't need to block channel operation for\n       confirmations, this greatly improves the UX of the process\n     * async splice in should use a technique similar to what Conner has\n       suggested in the past [0], otherwise it would need to block :(\n  * a sort of pre-announcement gossip messages\n     * purpose of this is to signal to other nodes \"hey this channel is\n       about to change outpoints, but you can keep routing through it\"\n     * otherwise, if this doesn't exist, then nodes would interpret the\n       action as a close then open of a channel, rather than a re-allocation\n\nJumping down to a lower level detail, the inclusion of a sort of \"scheduler\"\nfor splicing can also allow implementations to greatly batch all their\noperations. One example is using a splicing session initiated by the remote\nparty to open channels, send regular on-chain payments, CPFP pending\nsweeps/commitments, etc.\n\n[0]:\nhttps://github.com/lightningnetwork/lightning-rfc/issues/280#issuecomment-388269599\n\n-- Laolu\n\n\nOn Mon, Jun 25, 2018 at 3:10 AM Ren\u00e9 Pickhardt via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey everyone,\n>\n> I found a mail from 6 month ago on this list ( c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2017-December/000865.html )\n> in which it was stated that there was a plan to include a splicing protocol\n> as BOLT 1.1 (On a side node I wonder weather it would make more sense to\n> include splicing to BOLT 3?) I checked out the git repo and issues and\n> don't see that anyone is currently working on that topic and that it hasn't\n> been included yet. Am I correct?\n> If noone works on this at the moment and the spec is still needed I might\n> take the initiative on that one over the next weeks. If someone is working\n> on this I would kindly offer my support.\n>\n> The background for my question: Last weekend I have been attending the 2nd\n> lightninghackday in Berlin and we had quite some intensive discussions\n> about the autopilot feature and splicing. (c.f. a summary can be found on\n> my blog:\n> https://www.rene-pickhardt.de/improve-the-autopilot-of-bitcoins-lightning-network-summary-of-the-bar-camp-session-at-the-2nd-lightninghackday-in-berlin\n> )\n>\n> They people from lightning labs told me that they are currently started\n> working on splicing but even though it seems technically straight forward\n> the protocols should also be formalized. Previously I planned working on\n> improving the intelligence of the autopilot feature of the lightning\n> network however on the weekend I got convinced that splicing should be much\n> higher priority and the process should be specified in the lightning rfc.\n>\n> Also it would be nice if someone would be willing to help out improving\n> the quality of the spec that I would create since it will be my first time\n> adding work to such a formal rfc.\n>\n> best Rene\n>\n>\n> --\n> www.rene-pickhardt.de\n> <http://www.beijing-china-blog.com/>\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618 <+49%20176%2057623618>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180625/cb863f25/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-06-26T07:26:09",
                "message_text_only": "Good morning Laolu,\n\n>> but even though it seems technically straight forward t\n>\n> Well the full async implementation may be a bit involved, depending on the\n> architecture of the implementation (see the second point below).\n>\n> In the abstract, I'd say a splicing proposal should include the following:\n>\n>   * a generic message for both splice in/out\n>     * this allows both sides to schedule/queue up possible changes,\n>       opportunistically piggy-backing then on top of the other sides\n>       initiation\n>     * most of the channel params can also be re-negotiated as this point,\n>       another upside is this effectively allows garbage collecting old\n>       revocation state\n>   * fully async splice in/out\n>      * async is ideal as we don't need to block channel operation for\n>        confirmations, this greatly improves the UX of the process\n>      * async splice in should use a technique similar to what Conner has\n>        suggested in the past [0], otherwise it would need to block :(\n\nIt increases complexity. I suppose it would be OK to limit splice-in so that if a splice-in has not been buried deeply in the chain yet, you cannot splice-in even more, to limit the number of parallel updates you need to keep track of to only 2.\n\n>   * a sort of pre-announcement gossip messages\n>      * purpose of this is to signal to other nodes \"hey this channel is\n>        about to change outpoints, but you can keep routing through it\"\n>      * otherwise, if this doesn't exist, then nodes would interpret the\n>        action as a close then open of a channel, rather than a re-allocation\n\nAt first it seems benign to me -- after all, the channel is simply \"reopened\" and what does it matter whether other nodes know if the new channel is the same as the old channel? -- but then there will be a time of a few blocks where other nodes consider the channel closed but the replacement channel is not yet deep enough onchain to be reannounced.  So I suppose it enables routing across the channel during those few blocks.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180626/2a4b4ee6/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Including a Protocol for splicing to BOLT",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9572
        }
    },
    {
        "title": "[Lightning-dev] SPSP: Simple Protocol for Spontaneous Payments",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2018-06-27T19:56:11",
                "message_text_only": "Hi,\n\nCurrently, in Lightning, you need to get an invoice from the receiver\nto be able to send a payment. But what if you want to do a payment\nspontaneously, e.g. as a gift? I just realized this use case can be met\nin quite a simple way.\n\nYou simply route the payment to the receiver's Lightning node (so you\ndo need to know the node ID). The routing message to the receiver's\nnode is of a special form, and includes the preimage. It might also\ncontain some (small!) other data: maybe the hash of a signed\ndescription?\n\nAnyway, if the receiver's node recognizes this routing message format,\nit can then use the preimage to finish the transaction. It may also\ncancel the transaction instead, if the node owner doesn't want to\nreceive unsolicited money.\n\nThe fun thing is, none of the intermediate nodes can use the preimage\nto steal funds, since the routing data is encrypted.\n\nI do realize that spontaneous payments can also be done with a \"payment\nto self\" that just happens to give a very large fee to a particular\nintermediate node. The new protocol has the advantages that it doesn't\nneed the second half of the route (back to self), it is clear to the\nreceiving node that this is in fact intended as a payment, and you may\nbe able to include a small message.\n\nCJP"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2018-06-27T20:30:44",
                "message_text_only": "Yep, check out this issue for an outline for an implementation within lnd:\nhttps://github.com/lightningnetwork/lnd/issues/132\n\nThis is also documented in the \"brain storm\" wiki on the RFC repo:\nhttps://github.com/lightningnetwork/lightning-rfc/wiki/Brainstorming#passing-a-transfer-secret-in-the-onion\n\n\n-- Laolu\n\nOn Wed, Jun 27, 2018 at 12:57 PM CJP <cjp at ultimatestunts.nl> wrote:\n\n> Hi,\n>\n> Currently, in Lightning, you need to get an invoice from the receiver\n> to be able to send a payment. But what if you want to do a payment\n> spontaneously, e.g. as a gift? I just realized this use case can be met\n> in quite a simple way.\n>\n> You simply route the payment to the receiver's Lightning node (so you\n> do need to know the node ID). The routing message to the receiver's\n> node is of a special form, and includes the preimage. It might also\n> contain some (small!) other data: maybe the hash of a signed\n> description?\n>\n> Anyway, if the receiver's node recognizes this routing message format,\n> it can then use the preimage to finish the transaction. It may also\n> cancel the transaction instead, if the node owner doesn't want to\n> receive unsolicited money.\n>\n> The fun thing is, none of the intermediate nodes can use the preimage\n> to steal funds, since the routing data is encrypted.\n>\n> I do realize that spontaneous payments can also be done with a \"payment\n> to self\" that just happens to give a very large fee to a particular\n> intermediate node. The new protocol has the advantages that it doesn't\n> need the second half of the route (back to self), it is clear to the\n> receiving node that this is in fact intended as a payment, and you may\n> be able to include a small message.\n>\n> CJP\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180627/eb5215a3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "SPSP: Simple Protocol for Spontaneous Payments",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun",
                "CJP"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3352
        }
    }
]