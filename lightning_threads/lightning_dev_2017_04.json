[
    {
        "title": "[Lightning-dev] RFC new BOLT proposal for creating and closing channels using cold storage",
        "thread_messages": [
            {
                "author": "Jonathan Underwood",
                "date": "2017-04-07T03:48:07",
                "message_text_only": "Hello all,\n\nI have written up a very primitive BOLT for consideration.\n\nhttps://gist.github.com/junderw/f6d0c023d7cefc1107a9c58d6d58aa5e\n\nIf you would please let me know what you think of it, and especially ways\nwe could possibly mitigate (or at least give the channel owners a fighting\nchance) the scenario where a single attacker compromises both sides of the\nchannel, I would appreciate it.\n\nThank you,\nJonathan\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: http://openpgpjs.org\n\nxsBNBFTSV/kBB/9FyhUaxI/2bfJ0pBp+y6YAim4LyOXeFDdtZL2C04T2eWBB\n+n2HXD3r9CIifdqefnc0VCKwPe2hpbGXKNVy33tnp3m76CPVwKvIooE/gCcI\nLJUIKwbdj1ydsuUiErOhuRaral+iDhEaWuZmSZc1SiBANcufQvTru6o3Ne1M\nhozenpFHdyUXL4zIgifglEKRRsQiqxpF8vyIo/A7u5bDZQPq1HAc9vL13Oe0\n5ZhgXDMp0sgTfHVond6gNSJxWb7PqDLunY+kvINawqePEADkAJlvcZbXpc07\nRuX8+/FSRI0LPmZin6w0DuvzRAYAE/f1/OcqabWTIXbcmG3F32OmPS4PABEB\nAAHNMUpvbmF0aGFuIFVuZGVyd29vZCA8anVuZGVyd29vZEBiaXRjb2luYmFu\nay5jby5qcD7CwHIEEAEIACYFAlTSV/0GCwkIBwMCCRCpJzta0+R7RQQVCAIK\nAxYCAQIbAwIeAQAAQXgH/jZh+WLLxx4Sznw5o53nROMn+WChasZ1cOoFzfAX\nRpFC5UZTXyTS1fMsA1vMA21B88FX/+UCxvCB3EHN6MrUIinc8SFh/oZX/041\ndwfFOFaN2LsWJ5xF9pZpRdz4e+Bzbfyhe7MC/7d7KsfwyiEWgPbH8N869SWd\nQqu8WIH9hIDyyWU4rNx9Un440lZJhN79Z58vaw1q3FRq8qy+hKkMU7vi6PYq\n/D4WPrztfguqHe3vmtmlWaC8WGvy+AG7KEzinkc7VeIXdFtuLV70t3L9GyAV\nNPM+RVxi/nDhQ2FW9tYA0jJ0VYpRltkrMHTvlnP+VRqb/qbvss0ghaD3C7bi\nzCnOwE0EVNJX/QEH/2LRn75y2UIPVVd9Og6gT6Hfwh6CK2PcmjRzmGtY0ZU1\nwu/07CpAk3SP+5jm/o9FSVU46tE7d/VPw1gxj2vLryzsE8ticnUYtOVGzCgF\nmZgzcj+E8HNGLo5BiNaVqFVc1sf/bf3bGytVFWRsPoJmNgLTvwtJOZNXtOD/\n3IAAdiFRifeKDvElMlNhNNYOFncr+O16pnyesmQpg95nVbvww4t8QUjy5c2p\ng+9W1ZLzlEY2GC8bsvhrQsikycyV/pRqzDJo3D+DPLlEB4xASmHnJh6vw0Og\nVieAt1CcWyzPZQRcEBUQ9TVemvoQ+CBeVEAlivXXHyGu4OPV9miV66G2WTkA\nEQEAAcLAXwQYAQgAEwUCVNJYAgkQqSc7WtPke0UCGwwAAAsUB/sGC6hlR5t1\nzTJkJlSJb2Rg4iX1BXHpf/8DKFCrZ5UjsLkeAIJQxpSLtCKPFArPHLGLUowq\nHtpCFRg30pCRSKdzlTTM4ossrnHjQj3AFyedodPeoYbWSUNgHiM7pY9m5uNL\nI1Xg1K5AuAtrsD66vAtha5vL/ZIEmMkGl4mwC1dj4ueSCvfGP+xG5iGKiq8f\nP+PDscI99YtbeaLknXjTEYZMkqCYOsEstWx6YLu13Ee8rwrk2TkeavUiybD+\nPnaP3kISoaMPew3LNvnfc6ZJ/UxcEwmGf3UchSYRp3g/lMWcyFF624sszOQY\nULPn8N650ejg39n11SmCwk7aHoyYxfjs\n=RpF5\n-----END PGP PUBLIC KEY BLOCK-----\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170407/13d67ac2/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-04-12T20:03:14",
                "message_text_only": "Hi Jonathan,\n\n        The issue of hotwallet security is a real one: great to see you\nthinking deeply about it!  The ideal case would be that all keys are\noffline, but of course we need the funding secret key and payment\nbasepoint secret for channel updates.\n\nNote that before and after the channel, security is fairly easy: mutual\nclose can pay straight to a cold wallet address, and open waits for\nseveral blocks anyway, so you can have the secret key offline until that\npoint and wait for someone to press a button to release it.\n\nOnce open, the following avenues are open to a malicious party who has\nkey access:\n\n1. With cooperation of the peer, simply create a transaction which spends\n   the funding tx.\n\n2. If you can control the compromised node, you don't need cooperation\n   of the peer: create an HTLC sending maximum amount out to some other\n   place.\n\nSo we can mildly increase security with additional requirement where we\ntell the other node \"don't allow me to spend more then X without a\nsigned message from this other key\".  That's mildly better than nothing.\n\nIn addition, a future Trezor firmware could also hold the channel\nsecrets and various enforce rules, too.  We've nominally got an HSM\ndaemon for this in our new implementation, but we don't use it for this\nso far: more research needed!\n\nThanks!\nRusty.\n        \nJonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n> Hello all,\n>\n> I have written up a very primitive BOLT for consideration.\n>\n> https://gist.github.com/junderw/f6d0c023d7cefc1107a9c58d6d58aa5e\n>\n> If you would please let me know what you think of it, and especially ways\n> we could possibly mitigate (or at least give the channel owners a fighting\n> chance) the scenario where a single attacker compromises both sides of the\n> channel, I would appreciate it.\n>\n> Thank you,\n> Jonathan\n>\n> -- \n> -----------------\n> Jonathan Underwood\n> \u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n> -----------------\n>\n> \u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n>\n> -----BEGIN PGP PUBLIC KEY BLOCK-----\n> Comment: http://openpgpjs.org\n>\n> xsBNBFTSV/kBB/9FyhUaxI/2bfJ0pBp+y6YAim4LyOXeFDdtZL2C04T2eWBB\n> +n2HXD3r9CIifdqefnc0VCKwPe2hpbGXKNVy33tnp3m76CPVwKvIooE/gCcI\n> LJUIKwbdj1ydsuUiErOhuRaral+iDhEaWuZmSZc1SiBANcufQvTru6o3Ne1M\n> hozenpFHdyUXL4zIgifglEKRRsQiqxpF8vyIo/A7u5bDZQPq1HAc9vL13Oe0\n> 5ZhgXDMp0sgTfHVond6gNSJxWb7PqDLunY+kvINawqePEADkAJlvcZbXpc07\n> RuX8+/FSRI0LPmZin6w0DuvzRAYAE/f1/OcqabWTIXbcmG3F32OmPS4PABEB\n> AAHNMUpvbmF0aGFuIFVuZGVyd29vZCA8anVuZGVyd29vZEBiaXRjb2luYmFu\n> ay5jby5qcD7CwHIEEAEIACYFAlTSV/0GCwkIBwMCCRCpJzta0+R7RQQVCAIK\n> AxYCAQIbAwIeAQAAQXgH/jZh+WLLxx4Sznw5o53nROMn+WChasZ1cOoFzfAX\n> RpFC5UZTXyTS1fMsA1vMA21B88FX/+UCxvCB3EHN6MrUIinc8SFh/oZX/041\n> dwfFOFaN2LsWJ5xF9pZpRdz4e+Bzbfyhe7MC/7d7KsfwyiEWgPbH8N869SWd\n> Qqu8WIH9hIDyyWU4rNx9Un440lZJhN79Z58vaw1q3FRq8qy+hKkMU7vi6PYq\n> /D4WPrztfguqHe3vmtmlWaC8WGvy+AG7KEzinkc7VeIXdFtuLV70t3L9GyAV\n> NPM+RVxi/nDhQ2FW9tYA0jJ0VYpRltkrMHTvlnP+VRqb/qbvss0ghaD3C7bi\n> zCnOwE0EVNJX/QEH/2LRn75y2UIPVVd9Og6gT6Hfwh6CK2PcmjRzmGtY0ZU1\n> wu/07CpAk3SP+5jm/o9FSVU46tE7d/VPw1gxj2vLryzsE8ticnUYtOVGzCgF\n> mZgzcj+E8HNGLo5BiNaVqFVc1sf/bf3bGytVFWRsPoJmNgLTvwtJOZNXtOD/\n> 3IAAdiFRifeKDvElMlNhNNYOFncr+O16pnyesmQpg95nVbvww4t8QUjy5c2p\n> g+9W1ZLzlEY2GC8bsvhrQsikycyV/pRqzDJo3D+DPLlEB4xASmHnJh6vw0Og\n> VieAt1CcWyzPZQRcEBUQ9TVemvoQ+CBeVEAlivXXHyGu4OPV9miV66G2WTkA\n> EQEAAcLAXwQYAQgAEwUCVNJYAgkQqSc7WtPke0UCGwwAAAsUB/sGC6hlR5t1\n> zTJkJlSJb2Rg4iX1BXHpf/8DKFCrZ5UjsLkeAIJQxpSLtCKPFArPHLGLUowq\n> HtpCFRg30pCRSKdzlTTM4ossrnHjQj3AFyedodPeoYbWSUNgHiM7pY9m5uNL\n> I1Xg1K5AuAtrsD66vAtha5vL/ZIEmMkGl4mwC1dj4ueSCvfGP+xG5iGKiq8f\n> P+PDscI99YtbeaLknXjTEYZMkqCYOsEstWx6YLu13Ee8rwrk2TkeavUiybD+\n> PnaP3kISoaMPew3LNvnfc6ZJ/UxcEwmGf3UchSYRp3g/lMWcyFF624sszOQY\n> ULPn8N650ejg39n11SmCwk7aHoyYxfjs\n> =RpF5\n> -----END PGP PUBLIC KEY BLOCK-----\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "RFC new BOLT proposal for creating and closing channels using cold storage",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Jonathan Underwood"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6395
        }
    },
    {
        "title": "[Lightning-dev] Transaction revocation within transaction malleability via anyone-can-revoke hashlocks",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-04-26T19:16:47",
                "message_text_only": "One primitive that is necessary for bidirectional channels is revocable transactions. Briefly, in the absence of transaction malleability, in order to generate a revocable output, the output is encumbered such that either the receiver can receive the output after some time (via CSV opcode), or the output may be signed by both the sender and receiver. If the receiver wants to provide a proof of revocation, the receiver constructs a revocation transaction spending the output and sending it to the sender. The receiver signs that transaction and gives it to the sender. If the receiver subsequently attempts to realize the revoked output by broadcasting its transaction on the public blockchain, the sender may revoke it by sending the revocation transaction.\n\nHowever, in the presence of malleability, a fraudluent receiver may simply malleate the transaction producing the output. The output will then be referred to via a different txid, invalidating the existing revocation transaction.\n\nAnother issue with this style of revocable transactions is that it is still possible for the receiver to defraud the sender via a two-prong attack: the sender DDOS'es or otherwise prevents the sender from successfully sending the revocation transaction, and transmits the revoked transaction on the network. If the receover is capable of keeping the sender off-network until the CSV expires, the receiver may defraud the sender. It would be desirable if a separate bounty hunter may be hired in order to prevent fraud, so that the fraudulent receiver needs to keep many more agents away from the Bitcoin network.\n\nFortunately, a single solution fixes both issues.\n\nWhen constructing a revocable output, the receiver first generates a secure truely random number, the revocation key. The revocation lock is the hash of the revocation key (i.e. hashlock). The revocable output may be spent in any of the following conditions:\n\n1. After CSV +2 days, by the receiver.\n\n2. By the sender, if the sender can show the revocation key.\n\n3. After CSV +1 days, by anyone who can show the revocation key (anyone can revoke).\n\nTo revoke the revocable output, the receiver of the revocable output publishes the revocation key to the sender and to any interested participants in the Lightning Network.\n\nIf the output has not been revoked, the receiver has never published the revocation key and simply needs to wait 2 days to spend.\n\nIf the output has been revoked, and the receiver attempts to realize the revoked output on the Bitcoin network, if the sender is online, it can construct a revocation transaction by itself by signing the transaction and showing the published revocation key.\n\nIn addition, if the sender is unavailable or disconnected, after 1 day, anyone who has heard and kept the revocation key may claim the receiver's coins. Thus, the receiver, in order to use a revoked output, needs to prevent everyone to whom the revocation key has been sent from the Bitcoin network during the 1 day between the CSV+1 and CSV+2 periods.\n\nI would like to know if my consideration is correct or if I have missed or incorrectly analyzed some aspect of transaction revocation.\n\nI hope for your discussion.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170426/01bcd88f/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-04-27T01:19:18",
                "message_text_only": "Hi ZmnSCPxj!\n\n        Your suggestion for a \"burn window\" is interesting, but it still\nallows the attacker to burn your coins.  The attacker also has a chance\nto steal the coins themselves; quite a good chance if they are a miner.\n\nThe current draft uses a revocation key, which only the sender knows;\nthis part is actually malleation-proof:\n\n        The revocationkey is a blinded key: the remote node provides the\n        base, and the local node provides the blinding factor which it\n        later reveals, so the remote node can use the secret\n        revocationkey for a penalty transaction.\n\nThe DoS problem is a difficult one, but in practice it's very hard to\ncut someone off the bitcoin network for very long; they can always send\nout a transaction via various web interfaces on their phone if they have\nto.  But even the DoS problem is prevented by Tadge's watchers, though\nthey *are* subject to malleation.\n\nThere was a suggestion in the original Lightning paper to add a\nTX_NOINPUT sighash flag, which would allow watchers to operate even in\nthe case where malleation occurred.  But as that would be a soft fork\ntoo, we're better off waiting for SegWit...\n\nThanks for your input!\nRusty.\n\nZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n> One primitive that is necessary for bidirectional channels is revocable transactions. Briefly, in the absence of transaction malleability, in order to generate a revocable output, the output is encumbered such that either the receiver can receive the output after some time (via CSV opcode), or the output may be signed by both the sender and receiver. If the receiver wants to provide a proof of revocation, the receiver constructs a revocation transaction spending the output and sending it to the sender. The receiver signs that transaction and gives it to the sender. If the receiver subsequently attempts to realize the revoked output by broadcasting its transaction on the public blockchain, the sender may revoke it by sending the revocation transaction.\n>\n> However, in the presence of malleability, a fraudluent receiver may simply malleate the transaction producing the output. The output will then be referred to via a different txid, invalidating the existing revocation transaction.\n>\n> Another issue with this style of revocable transactions is that it is still possible for the receiver to defraud the sender via a two-prong attack: the sender DDOS'es or otherwise prevents the sender from successfully sending the revocation transaction, and transmits the revoked transaction on the network. If the receover is capable of keeping the sender off-network until the CSV expires, the receiver may defraud the sender. It would be desirable if a separate bounty hunter may be hired in order to prevent fraud, so that the fraudulent receiver needs to keep many more agents away from the Bitcoin network.\n>\n> Fortunately, a single solution fixes both issues.\n>\n> When constructing a revocable output, the receiver first generates a secure truely random number, the revocation key. The revocation lock is the hash of the revocation key (i.e. hashlock). The revocable output may be spent in any of the following conditions:\n>\n> 1. After CSV +2 days, by the receiver.\n>\n> 2. By the sender, if the sender can show the revocation key.\n>\n> 3. After CSV +1 days, by anyone who can show the revocation key (anyone can revoke).\n>\n> To revoke the revocable output, the receiver of the revocable output publishes the revocation key to the sender and to any interested participants in the Lightning Network.\n>\n> If the output has not been revoked, the receiver has never published the revocation key and simply needs to wait 2 days to spend.\n>\n> If the output has been revoked, and the receiver attempts to realize the revoked output on the Bitcoin network, if the sender is online, it can construct a revocation transaction by itself by signing the transaction and showing the published revocation key.\n>\n> In addition, if the sender is unavailable or disconnected, after 1 day, anyone who has heard and kept the revocation key may claim the receiver's coins. Thus, the receiver, in order to use a revoked output, needs to prevent everyone to whom the revocation key has been sent from the Bitcoin network during the 1 day between the CSV+1 and CSV+2 periods.\n>\n> I would like to know if my consideration is correct or if I have missed or incorrectly analyzed some aspect of transaction revocation.\n>\n> I hope for your discussion.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-04-27T13:28:57",
                "message_text_only": "Hi ZmnSCPxj!\n\nGood morning Rusty, thank you for your reply.\n\nI want to know about whether Lightning can be implemented even without SegWit, given only the current features that could be activated as of today 2017-04.\n\nYour suggestion for a \"burn window\" is interesting, but it still\nallows the attacker to burn your coins. The attacker also has a chance\nto steal the coins themselves; quite a good chance if they are a miner.\n\nYes, although you can build a revocation transaction to claim all of your counterparty's funding.in case of fraud.\n\nAs you mentioned, also normal \"watchers\" cannot work if the revoked commitment transaction is malleated. However with my burn window, anyone can be a watcher, but they claim the entirety of the fraudulent counterparty's funds, rather than a watching bonus.\n\nThe current draft uses a revocation key, which only the sender knows;\nthis part is actually malleation-proof:\n\nThe revocationkey is a blinded key: the remote node provides the\nbase, and the local node provides the blinding factor which it\nlater reveals, so the remote node can use the secret\nrevocationkey for a penalty transaction.\n\nI'm sorry. I read only the whitepaper and could not find the above text in the whitepaper, so maybe my knowledge is obsolete. My last knowledge is that the proof of revocation is a revocation transaction constructed specifically for the old commitment transaction. But, it means malleation of commitment transaction will disable the revocation transaction.\n\nI searched your quoted text and I could find about the lightningnetwork/lightning-rfc repository on github. It seems, this is the \"draft\" you refer to?\n\nNow I'm reading more about this set of documents. I started at BOLT#3 (which contains your quoted text). From what little I could understand, it seems, the conditions for a revocable Bob output are one of: (Bob's private key AND CSV+1) OR (Alice's private key and revocationkey). Thus, the data of the revocationkey is sufficient for Alice to enforce revocation. Is my understanding correct?\n\nThe DoS problem is a difficult one, but in practice it's very hard to\ncut someone off the bitcoin network for very long; they can always send\nout a transaction via various web interfaces on their phone if they have\nto. But even the DoS problem is prevented by Tadge's watchers, though\nthey *are* subject to malleation.\n\nMy concern is that there are countries with difficulty to get Internet, and maybe censorship and so on. If a Lightning Network user is disconnected because of such geopolitical concerns, perhaps the counterparty may attempt to defraud him or her. So I would very much like to have watchers, even if they cannot be trusted to give the money to the poor victim of geopolitical concerns, in order to prevent taking advantage of other's inadvertent disconnection.\n\nThere was a suggestion in the original Lightning paper to add a\nTX_NOINPUT sighash flag, which would allow watchers to operate even in\nthe case where malleation occurred. But as that would be a soft fork\ntoo, we're better off waiting for SegWit...\nI understand.\n\nFrom what I can gather so far, it seems, the issue of transaction revocation even with transaction malleability appears to be solved. Although, I want to know, is my idea (which support selfish untrustworthy watchers) better than what Lightning now has? Or has different tradeoffs? It seems to me, at first glance, if the revocation key in my idea is not publicized but sent only to the counterparty, it is effectively equivalent to the current technique. But the receiving counterparty has the option of publishing this revocation key in order to allow anyone to enforce and get free money, even with malleability.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170427/d11e8d44/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Transaction revocation within transaction malleability via anyone-can-revoke hashlocks",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12018
        }
    },
    {
        "title": "[Lightning-dev] [RFC] Lightning payment format",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2017-04-29T00:57:32",
                "message_text_only": "Hi all!\n\n        I threw together this draft format for requesting lightning\npayments, and an (incomplete) implementation:\n\n- https://github.com/rustyrussell/lightning-payencode\n\nThe representation size ranges from ~181 characters upwards: we could\nsqueeze at least 5 of those out if we cared.  Bech32 only guarantees to\ndetect 3 errors at these lengths (beyond 1024 it's only 1), but the\nsignature is the final error detection.\n\nYou'll notice one optimization for the common case: we use the 8-byte\nchanid (stealing 1 bit) to compactly refer to the destination.  This is\nshorter than a full 33-byte pubkey, and relies on the fact that the\nnetwork topology is well-known.  We use these same style of IDs in\nthe channel announcement messages already.\n\nI look forward to both the bikeshed comments, and more substantive\nfeedback :)\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Lightning payment format",
            "categories": [
                "Lightning-dev",
                "RFC"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 845
        }
    },
    {
        "title": "[Lightning-dev] [PATCH] Add spellcheck tool (requires `aspell`), also spellcheck.",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-04-29T03:19:07",
                "message_text_only": "This patch should apply to http://github.com/lightningnetwork/lightning-rfc\n\nNonidealities:\n\nAspell triggers spelling errors on the hexadecimal strings in\nthe test vectors. I don't have enough aspell-fu to figure\nout how to make Aspell ignore these.\n\nThere are 2 possible pluralizations of `HTLC`: `HTLCs` and\n`HTLC's`. I'd prefer the latter, but for now I support both.\nWe should standardize pluralization; we can edit the\n`.aspell.en.pws` file to remove the pluralization we won't\nchoose.\n---\n.aspell.en.prepl | 5 +\n.aspell.en.pws | 260 ++++++++++++++++++++++++++++++++++++++++++++++++++++\n01-messaging.md | 6 +-\n02-peer-protocol.md | 4 +-\n03-transactions.md | 4 +-\n04-onion-routing.md | 20 ++--\n05-onchain.md | 6 +-\n08-transport.md | 8 +-\ntools/spellcheck.sh | 45 +++++++++\n9 files changed, 334 insertions(+), 24 deletions(-)\ncreate mode 100644 .aspell.en.prepl\ncreate mode 100644 .aspell.en.pws\ncreate mode 100755 tools/spellcheck.sh\n\ndiff --git a/.aspell.en.prepl b/.aspell.en.prepl\nnew file mode 100644\nindex 0000000..7011550\n--- /dev/null\n+++ b/.aspell.en.prepl\n@@ -0,0 +1,5 @@\n+personal_repl-1.1 en 0\n+paramaters parameters\n+primage preimage\n+referece reference\n+continguous contiguous\ndiff --git a/.aspell.en.pws b/.aspell.en.pws\nnew file mode 100644\nindex 0000000..27a37de\n--- /dev/null\n+++ b/.aspell.en.pws\n@@ -0,0 +1,260 @@\n+personal_ws-1.1 en 259\n+secp\n+sig\n+unguessable\n+libsecp\n+TCP\n+DER\n+micropayments\n+nhops\n+retransmitted\n+dev\n+inflight\n+tradeoff\n+mixHeader\n+uint\n+hopsData\n+bitfield\n+B'th\n+decrypting\n+rhokey\n+rhoKey\n+buf\n+millisatoshis\n+yToX\n+funder's\n+IRATEMONK\n+wpkh\n+nextHmac\n+basepoint\n+streamKey\n+localkey\n+paymentPath\n+SPV\n+HopData\n+CSV\n+xFFFFFFFFFF\n+plaintext\n+EQUALVERIFY\n+AEAD\n+secretkey\n+TripleDH\n+addr\n+CHECKMULTISIG\n+decryptWithAD\n+routable\n+epk\n+scriptpubkey\n+mukey\n+muKey\n+sharedSecretSize\n+DUP\n+sharedSecrets\n+firewalled\n+xFFFFFFFFFFFF\n+revocationsecretkey\n+cryptographic\n+generateSharedSecret\n+instantiations\n+deterministically\n+deduplication\n+FIPS\n+responder\n+UTF\n+blockchain\n+nSequence\n+decrypt\n+flen\n+incrementing\n+feerate\n+affine\n+CHECKSEQUENCEVERIFY\n+nonces\n+iff\n+serializeCompressed\n+prepended\n+roasbeef\n+multisig\n+nodepk\n+remotesig\n+hopBlindingFactors\n+ECDH\n+addrlen\n+assocData\n+blockheight\n+ActOne\n+ammag\n+computeBlindingFactor\n+wsh\n+multiScalarMult\n+onionpacket\n+OnionPacket\n+ikm\n+fillerSize\n+txinput\n+init\n+reconnection\n+milli\n+revocationsig\n+irc\n+unroutable\n+NOTIF\n+txindex\n+generateHeaderPadding\n+IPv\n+ipv\n+satoshi\n+delayedsig\n+hopDataSize\n+I'th\n+segwit\n+htlc\n+ChaCha\n+len\n+ciphertext\n+endian\n+C'mon\n+NewOnionPacket\n+keypair\n+preimage\n+MiTM\n+mempool\n+cltv\n+localfeatures\n+iteratively\n+PrivateKey\n+br\n+millisatoshi\n+trustless\n+ee\n+eg\n+hopSize\n+retransmit\n+deobfuscating\n+onchain\n+BADONION\n+rightShift\n+protocolName\n+hopEphemeralPubKeys\n+txid\n+Fn\n+PublicKey\n+liveness\n+ie\n+shakin\n+txin\n+globalfeatures\n+calcMac\n+privkey\n+overpayment\n+hopSharedSecrets\n+TimeLocked\n+timelocked\n+lc\n+btcec\n+localsig\n+responder's\n+ripemd\n+md\n+ENDIF\n+blockchains\n+provisorial\n+cleartext\n+streamBytes\n+WISTFULTOLL\n+locktime\n+xFFF\n+localprivkey\n+deserialized\n+pubkey\n+PubKey\n+ok\n+Retransmissions\n+numHops\n+failuremsg\n+byteslen\n+shortid\n+se\n+rk\n+micropayment\n+rn\n+testbit\n+unparsable\n+sk\n+RoutingInfo\n+funder\n+Counterintuitively\n+basepoints\n+decrypts\n+sn\n+generateFiller\n+unrevoked\n+bytelen\n+ss\n+that'd\n+retransmitting\n+ack\n+deobfuscated\n+gflen\n+satoshis\n+instantiation\n+HeaderMAC\n+blindGroupElement\n+tx\n+pubkeys\n+CHECKLOCKTIMEVERIFY\n+generateCipherStream\n+XK\n+lflen\n+deobfuscates\n+generateKey\n+alice\n+revocationprivkey\n+PKH\n+remotekey\n+HKDF\n+ooo\n+repo\n+num\n+numStreamBytes\n+txout\n+HTLCs\n+htlcs\n+HTLC's\n+retransmission\n+decrypted\n+sessionKey\n+sessionkey\n+PRIVMSG\n+routingInfoSize\n+hostname\n+rgb\n+ciphertexts\n+CHECKSIG\n+pre\n+numMaxHops\n+HMACs\n+hmac\n+BIP\n+hmacSize\n+ratelimit\n+Poy\n+talkin\n+Freenode\n+revocationkey\n+ctlv\n+msat\n+func\n+unencrypted\n+coinbase\n+priv\n+sha\n+TODO\n+ChaChaPoly\n+delayedkey\n+Diffie\n+IETF\n+xFFFFFFFFFFF\n+FIXME\n+whitespace\n+EphemeralKey\ndiff --git a/01-messaging.md b/01-messaging.md\nindex b260a41..96f503c 100644\n--- a/01-messaging.md\n+++ b/01-messaging.md\n@@ -4,7 +4,7 @@\nThis protocol assumes an underlying authenticated and ordered transport mechanism that takes care of framing individual messages.\n[BOLT #8](08-transport.md) specifies the canonical transport layer used in Lightning, though it can be replaced by any transport that fulfills the above guarantees.\n\n-The default TCP port is 9735. This corresponds to hexadecimal `0x2607`, the unicode code point for LIGHTNING.<sup>[1](#reference-1)</sup>\n+The default TCP port is 9735. This corresponds to hexadecimal `0x2607`, the Unicode code point for LIGHTNING.<sup>[1](#reference-1)</sup>\n\nAll data fields are big-endian unless otherwise specified.\n\n@@ -143,7 +143,7 @@ or if `channel-id` is zero, it MUST fail all channels and MUST close the connect\n`len` to the remainder of the packet if it is larger.\n\nA receiving node SHOULD only print out `data` verbatim if the string is composed solely of printable ASCII characters.\n-For referece, the printable character set includes byte values 32 through 127 inclusive.\n+For reference, the printable character set includes byte values 32 through 127 inclusive.\n\n#### Rationale\n\n@@ -161,7 +161,7 @@ it leak information, thus the optional data field.\n\nIn order to allow for the existence of very long-lived TCP connections, at\ntimes it may be required that both ends keep alive the TCP connection at the\n-application level. Such messages also allow obsfusation of traffic patterns.\n+application level. Such messages also allow obfuscation of traffic patterns.\n\n1. type: 18 (`ping`)\n2. data:\ndiff --git a/02-peer-protocol.md b/02-peer-protocol.md\nindex 810ecce..5a403be 100644\n--- a/02-peer-protocol.md\n+++ b/02-peer-protocol.md\n@@ -173,7 +173,7 @@ The *channel reserve* is specified by the peer's `channel-reserve-satoshis`; 1%\n\nThe sender can unconditionally give initial funds to the receiver using a non-zero `push-msat`, and this is one case where the normal reserve mechanism doesn't apply. However, like any other on-chain transaction, this payment is not certain until the funding transaction has been confirmed sufficiently (may be double-spent) and may require a separate method to prove payment via on-chain confirmation.\n\n-The `feerate-per-kw` is generally only a concern to the sender (who pays the fees), but that is also the feerate paid by HTLC transactions; thus unresonably large fee rates can also penalize the reciepient.\n+The `feerate-per-kw` is generally only a concern to the sender (who pays the fees), but that is also the feerate paid by HTLC transactions; thus unreasonably large fee rates can also penalize the recipient.\n\n#### Future\n\n@@ -882,7 +882,7 @@ retransmit any channel messages which may not have been.\n\nThis is fairly straightforward in the case of channel establishment\nand close where messages have an explicit order, but in normal\n-operation acknowlegements of updates are delayed until the\n+operation acknowledgements of updates are delayed until the\n`commitment_signed` / `revoke_and_ack` exchange, so we cannot assume\nthe updates have been received. This also means that the receiving\nnode only needs to store updates upon receipt of `commitment_signed`.\ndiff --git a/03-transactions.md b/03-transactions.md\nindex d2afc03..cdca943 100644\n--- a/03-transactions.md\n+++ b/03-transactions.md\n@@ -358,11 +358,11 @@ Each commitment transaction uses a unique set of keys; `localkey` and `remotekey\nKeys change because of the desire for trustless outsourcing of\nwatching for revoked transactions; a _watcher_ should not be able to\ndetermine what the contents of commitment transaction is, even if\n-given the transaction ID to watch for and can make a resonable guess\n+given the transaction ID to watch for and can make a reasonable guess\nas to what HTLCs and balances might be included. Nonetheless, to\navoid storage for every commitment transaction, it can be given the\n`per-commitment-secret` values (which can be stored compactly) and the\n-`revocation-basepoint` and `delayed-payment-basepoint` to regnerate\n+`revocation-basepoint` and `delayed-payment-basepoint` to regenerate\nthe scripts required for the penalty transaction: it need only be\ngiven (and store) the signatures for each penalty input.\n\ndiff --git a/04-onion-routing.md b/04-onion-routing.md\nindex 48166de..bd0ddd5 100644\n--- a/04-onion-routing.md\n+++ b/04-onion-routing.md\n@@ -77,7 +77,7 @@ The packet consists of 4 parts:\nas they forward the message.\n- A 32-byte `HMAC` used to verify the packet's integrity.\n\n-The overall structure of the packet is depicted below. The network format of the packet consists of the individual parts being serialized into one continguous byte-stream and then transferred to the recipient of the packet. Due to the fixed size of the packet it does not need to be prefixed by its length when transferred over a connection.\n+The overall structure of the packet is depicted below. The network format of the packet consists of the individual parts being serialized into one contiguous byte-stream and then transferred to the recipient of the packet. Due to the fixed size of the packet it does not need to be prefixed by its length when transferred over a connection.\n\n~~~~\n+------------------+-----------------------+------------------------+-----------------+\n@@ -130,11 +130,11 @@ Field Description:\nprocessing an incoming Sphinx packet along with the HTLC message it's\nencapsulated within, if the following inequality doesn't hold, then the\nHTLC should be rejected as it indicates a prior node in the path has\n- deviated from the specified paramters:\n+ deviated from the specified parameters:\n\nincoming_htlc_amt - fee >= amt_to_forward\n\n- Where `fee` is calculated according to the receving node's advertised fee\n+ Where `fee` is calculated according to the receiving node's advertised fee\nschema as described in [BOLT 7](https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#htlc-fees), or 0 if this node is the\nfinal hop.\n\n@@ -144,7 +144,7 @@ Field Description:\ncltv-expiry - cltv-expiry-delta = outgoing_cltv_value\n\nInclusion of this field allows a node to both authenticate the information\n- specified by the original sender and the paramaters of the HTLC forwarded,\n+ specified by the original sender and the parameters of the HTLC forwarded,\nand ensure the original sender is using the current `cltv-expiry-delta` value.\nIf there is no next hop, `cltv-expiry-delta` is zero.\nIf the values don't correspond, then the HTLC should be failed+rejected as\n@@ -322,7 +322,7 @@ The sessionkey is a 32 byte EC private key.\nThe shared secret creation receives a public key and a 32 byte secret as input and returns a 32 byte secret as output.\n\nIn the packet generation phase the secret is the `sessionkey` and the public key is the node's public key, blinded with all previous blinding factors.\n-In the pocessing phase the secret is the node's private key and the public key is the ephemeral public key from the packet, which has been incrementally blinded by the predecessors.\n+In the processing phase the secret is the node's private key and the public key is the ephemeral public key from the packet, which has been incrementally blinded by the predecessors.\n\nThe public key is multiplied by the secret, using to the `secp256k1` curve.\nThe DER compressed representation of the multiplication result is serialized and hashed using `SHA256`.\n@@ -713,27 +713,27 @@ We use the same parameters (node ids, shared secrets ,...) as above\npayload = 00022002007e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\num_key = 4da7f2923edce6c2d85987d1d9fa6d88023e6c3a9c3d20f07d3b10b61a78d646\nraw_error_packet = 807890139cc04c1fdea98b22ebda0a831d1beebe00022002007e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n- # forwaring error packet\n+ # forwarding error packet\nshared_secret = b5756b9b542727dbafc6765a49488b023a725d631af688fc031217e90770c328\nammag_key = 2f36bb8822e1f0d04c27b7d8bb7d7dd586e032a3218b8d414afbba6f169a4d68\nstream = e9c975b07c9a374ba64fd9be3aae955e917d34d1fa33f2e90f53bbf4394713c6a8c9b16ab5f12fd45edd73c1b0c8b33002df376801ff58aaa94000bf8a86f92620f343baef38a580102395ae3abf9128d1047a0736ff9b83d456740ebbb4aeb3aa9737f18fb4afb4aa074fb26c4d702f42968888550a3bded8c05247e045b866baef0499f079fdaeef6538f31d44deafffdfd3afa2fb4ca9\nerror packet for node 4: 69b1e5a3e05a7b5478e6529cd1749fdd8c66da6ffa31d2eb0f2dbbf4394713c6a8c9b16ab5f12fd45edd73c1b0c8b33002df376801ff58aaa94000bf8a86f92620f343baef38a580102395ae3abf9128d1047a0736ff9b83d456740ebbb4aeb3aa9737f18fb4afb4aa074fb26c4d702f42968888550a3bded8c05247e045b866baef0499f079fdaeef6538f31d44deafffdfd3afa2fb4ca9\n- # forwaring error packet\n+ # forwarding error packet\nshared_secret = 21e13c2d7cfe7e18836df50872466117a295783ab8aab0e7ecc8c725503ad02d\nammag_key = cd9ac0e09064f039fa43a31dea05f5fe5f6443d40a98be4071af4a9d704be5ad\nstream = 617ca1e4624bc3f04fece3aa5a2b615110f421ec62408d16c48ea6c1b7c33fe7084a2bd9d4652fc5068e5052bf6d0acae2176018a3d8c75f37842712913900263cff92f39f3c18aa1f4b20a93e70fc429af7b2b1967ca81a761d40582daf0eb49cef66e3d6fbca0218d3022d32e994b41c884a27c28685ef1eb14603ea80a204b2f2f474b6ad5e71c6389843e3611ebeafc62390b717ca53\nerror packet for node 3: 08cd44478211b8a4370ab1368b5ffe8c9c92fb8398715ffdcba31d358e842c21a0839ab361940011585323930fa5b9fae0c85770a2279ff59ec427ad1bbff9001c0cd1497004bd2a0f68b50704cf6d6a4bf3c8b6a0833399a24b3456961ba00736785112594f65b6b2d44d9f5ea4e49b5e1ec2af978cbe31c67114440ac51a62081df0ed46d4a3df295da0b0fe25c0115019f03f15ec86fa\n- # forwaring error packet\n+ # forwarding error packet\nshared_secret = 3a6b412548762f0dbccce5c7ae7bb8147d1caf9b5471c34120b30bc9c04891cc\nammag_key = 1bf08df8628d452141d56adfd1b25c1530d7921c23cecfc749ac03a9b694b0d3\nstream = 6149f48b5a7e8f3d6f5d870b7a698e204cf64452aab4484ff1dee671fe63fd4b5f1b78ee2047dfa61e3d576b149bedaf83058f85f06a3172a3223ad6c4732d96b32955da7d2feb4140e58d86fc0f2eb5d9d1878e6f8a7f65ab9212030e8e915573ebbd7f35e1a430890be7e67c3fb4bbf2def662fa625421e7b411c29ebe81ec67b77355596b05cc155755664e59c16e21410aabe53e8040\n# error packet for node 2: 6984b0ccd86f37995857363df13670acd064bfd132c517b23a7dfb4470e7d16aff98e25d41d3dfb7466e74f81b3e545563cdd8f5524dae873de61d7bdfccd496af2584930d2b566b4f8d3881f8c043df92224f38cf094cfc09d92655989531524593ec6d6caec1863bdfaa79229b5020acc034cd6deeea1021c50586947b9b8e6faa83b81fbfa6133c0af5d6b07c017f7158fa94f0d206ba\n- # forwaring error packet\n+ # forwarding error packet\nshared_secret = a6519e98832a0b179f62123b3567c106db99ee37bef036e783263602f3488fae\nammag_key = 59ee5867c5c151daa31e36ee42530f429c433836286e63744f2020b980302564\nstream = 0f10c86f05968dd91188b998ee45dcddfbf89fe9a99aa6375c42ed5520a257e048456fe417c15219ce39d921555956ae2ff795177c63c819233f3bcb9b8b28e5ac6e33a3f9b87ca62dff43f4cc4a2755830a3b7e98c326b278e2bd31f4a9973ee99121c62873f5bfb2d159d3d48c5851e3b341f9f6634f51939188c3b9ff45feeb11160bb39ce3332168b8e744a92107db575ace7866e4b8\n# error packet for node 1: 669478a3ddf9ba4049df8fa51f73ac712b9c20389b5fb185663f16115045868ab7dd8db956128dae8857add94e6702fb4c3a4de22e2e669e1ed926b04447fc73034bb730f4932acd62727b75348a648a1128744657ca6a4e713b9b646c3ca66cac02cdab44dd3439890ef3aaf61708714f7375349b8da541b2548d452d84de7084bb95b3ac2345201d624d31f4d52078aa0fa05a88b4e202\n- # forwaring error packet\n+ # forwarding error packet\nshared_secret = 53eb63ea8a3fec3b3cd433b85cd62a4b145e1dda09391b348c4e1cd36a03ea66\nammag_key = 3761ba4d3e726d8abb16cba5950ee976b84937b61b7ad09e741724d7dee12eb5\nstream = 3699fd352a948a05f604763c0bca2968d5eaca2b0118602e52e59121f050936c8dd90c24df7dc8cf8f1665e39a6c75e9e2c0900ea245c9ed3b0008148e0ae18bbfaea0c711d67eade980c6f5452e91a06b070bbde68b5494a92575c114660fb53cf04bf686e67ffa4a0f5ae41a59a39a8515cb686db553d25e71e7a97cc2febcac55df2711b6209c502b2f8827b13d3ad2f491c45a0cafe7\ndiff --git a/05-onchain.md b/05-onchain.md\nindex 179efcd..3b05a27 100644\n--- a/05-onchain.md\n+++ b/05-onchain.md\n@@ -2,7 +2,7 @@\n\n## Abstract\n\n-Lightning allows for two parties (A and B) to make transactions off-chain, by both holding a cross-signed *commitment transaction*, which describes the current state of the channel (basically the current balance). This *commitment transaction* is updated everytime a new payment is made, and is spendable at all times.\n+Lightning allows for two parties (A and B) to make transactions off-chain, by both holding a cross-signed *commitment transaction*, which describes the current state of the channel (basically the current balance). This *commitment transaction* is updated every time a new payment is made, and is spendable at all times.\n\nThere are three ways a channel can end:\n\n@@ -118,7 +118,7 @@ When node A sees its own *commitment transaction*:\noutput is spent (as recommended), the output is *resolved* by the spending\ntransaction, otherwise it is considered *resolved* by the *commitment transaction* itself.\n2. _B's main output_: No action required, this output is considered *resolved*\n- by the *commitment transaction* utself.\n+ by the *commitment transaction* itself.\n3. _A's offered HTLCs_: See \"On-chain HTLC Output Handling: Our Offers\" below.\n4. _B's offered HTLCs_: See \"On-chain HTLC Output Handling: Their Offers\" below.\n\n@@ -183,7 +183,7 @@ as described in \"On-chain HTLC Transaction Handling\".\nIf the commitment transaction is theirs, the only way to spend the\nHTLC output using a payment preimage is for them to use the\nHTLC-success transaction. If the commitment transaction is ours, they\n-could create any transaction using the primage.\n+could create any transaction using the preimage.\n\nThe payment preimage either serves to prove payment (if this node\ndiff --git a/08-transport.md b/08-transport.md\nindex 34ac81e..a1430fe 100644\n--- a/08-transport.md\n+++ b/08-transport.md\n@@ -86,7 +86,7 @@ chosen as the hash function, `secp256k1` as the elliptic curve, and finally\n`ChaChaPoly-1305` as the `AEAD` construction. The composition of `ChaCha20`\nand `Poly1305` used MUST conform to `RFC 7539`<sup>[1](#reference-1)</sup>. With this laid out, the\nofficial Noise protocol name for our variant is:\n-`Noise_XK_secp256k1_ChaChaPoly_SHA256`. The ascii string representation of\n+`Noise_XK_secp256k1_ChaChaPoly_SHA256`. The ASCII string representation of\nthis value is hashed into a digest used to initialize the starting handshake\nstate. If the protocol names of two endpoints differ, then the handshake\nprocess fails immediately.\n@@ -126,7 +126,7 @@ The following functions will also be referenced:\n\n* `ECDH(rk, k)`: Performs an Elliptic-Curve Diffie-Hellman operation using\n`rk` which is a `secp256k1` public key and `k` which is a valid private key\n- within the finite field as defined by the curve paramters.\n+ within the finite field as defined by the curve parameters.\n* The returned value is the SHA256 of the DER compressed format of the\ngenerated point.\n\n@@ -166,13 +166,13 @@ state as follows:\n\n1. `h = SHA-256(protocolName)`\n* where `protocolName = \"Noise_XK_secp256k1_ChaChaPoly_SHA256\"` encoded as\n- an ascii string.\n+ an ASCII string.\n\n2. `ck = h`\n\n3. `h = SHA-256(h || prologue)`\n- * where `prologue` is the ascii string: `lightning`.\n+ * where `prologue` is the ASCII string: `lightning`.\n\nAs a concluding step, both sides mix the responder's public key into the\ndiff --git a/tools/spellcheck.sh b/tools/spellcheck.sh\nnew file mode 100755\nindex 0000000..63dbaba\n--- /dev/null\n+++ b/tools/spellcheck.sh\n@@ -0,0 +1,45 @@\n+#!/bin/sh\n+# spellcheck.sh\n+# by ZmnSCPxj\n+# Simple script to spellcheck files.\n+#\n+# ZmnSCPxj puts this script into the public domain.\n+\n+# Check if dirname works.\n+if (test_dir=`dirname -- /` && test \"X\"$test_dir = \"X/\")\n+then\n+ my_dirname=dirname\n+else\n+ my_dirname=false\n+fi\n+\n+# Find the path to this script.\n+# We assume sed works on most systems, since it's very old.\n+my_dir=`$my_dirname -- \"$0\" ||\n+echo X\"$0\" |\n+ sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n+ s//\\1/\n+ q\n+ }\n+ /^X\\(\\/\\/\\)[^/].*/{\n+ s//\\1/\n+ q\n+ }\n+ /^X\\(\\/\\/\\)$/{\n+ s//\\1/\n+ q\n+ }\n+ /^X\\(\\/\\).*/{\n+ s//\\1/\n+ q\n+ }\n+ s/.*/./; q'`\n+\n+# This script should be in the tools/ directory of the\n+# repository.\n+homedir=\"$my_dir\"/..\n+\n+for f\n+do\n+ aspell --home-dir ${homedir} -c $f\n+done\n--\n2.11.0\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170428/94d20675/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Add spellcheck tool (requires `aspell`), also spellcheck.",
            "categories": [
                "Lightning-dev",
                "PATCH"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 20716
        }
    },
    {
        "title": "[Lightning-dev] Funding Transactions within transaction malleability",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-04-29T15:17:30",
                "message_text_only": "Good morning all,\n\nBelow is a collection of how to make funding transactions for micropayment\nchannels even if SegWit is never activated.\n\nEven with transaction malleability, revocation is possible by the use of\nrevocation keys, and thus, bidirectional micropayment channels are possible.\n\nHowever, the creation of micropayment channels is significantly more\ndifficult without a malleability fix and segregated signatures.\n\nIn the below, Alice wants to provide 1.0 BTC to the channel while Bob\nonly wants to provide 0.25 BTC. Both agree to give 0.01 BTC, each, as\ntransaction fees. The total input is thus 1.27 BTC.\n\n== Timelocked ==\n\nThe funding transaction has two outputs:\n\n1. 1.0 BTC to (Alice && CSV + 1 week) || (Alice && Bob)\n2. 0.25 BTC to (Bob && CSV + 1 week) || (Alice && Bob)\n\nCommitment transactions have two inputs, which are both of the outputs\nof the funding transaction.\n\nChannel construction begins with the funding transaction being broadcast\nover the Bitcoin network. Both sides wait for the transaction, or a\nmalleated version thereof, to be confirmed on a block. Once both sides\nhave confirmed, they may generate commitment transactions referring to\nthe confirmed funding transaction and sign each other's commitment\ntransactions.\n\nBecause of the timeout, the side which has received more money than it\noriginally put into the channel must close the channel before the\ntimeout. This puts a strict upper limit to the duration of the channel.\n\nDrawback: The timeout serves two masters. On the one hand, if channel\nopening must be aborted due to noncooperation between both sides, the\nmoney is locked up for the timeout duration; if one side needs the\nmoney transmitted quickly and does not have enough money to fund a\ndifferent channel, the other side may force an abort and hostage the\nfunds until the timeout. On the other hand, the timeout limits the\nlifetime of the channel, and it's best if the channel has a long\nlifetime if the channel can be succesfully opened.\n\nChannel Lifetime: Limited.\n\nAbort: Funds are tied up for the channel lifetime if opening is\naborted.\n\nCost: Low; only one transaction is needed to open.\n\nHostage: Possible if one side needs to transfer the money quickly\nand cannot afford to have its funds tied up in case of an abort.\n\n== Child Pays For Parent ==\n\nThe funding transaction has two outputs:\n\n1. 1.25 BTC to (Alice && Bob)\n2. 0.02 BTC to (Alice && Bob)\n\nSince the funding transaction spends all 1.27 BTC of input, there is\nno transaction fee, so miners are not incentivized to mine the funding\ntransaction, or any malleated version thereof. Thus, if both sides\nare cooperating, they may safely broadcast this transaction on the\nBitcoin network without worry of counterparty hostaging of funds.\n\nAfter the funding transaction has been created and signed by both\nsides, they can create commitment transactions referring to the\nunmalleated funding transaction. Once both commitment transactions\nare signed by the counterparty, the two sides create a new, Child\nPays For Parent transaction which inputs the funding transaction's\noutput containing the decided miner's fee and having a 0 output\nto an arbitrary address. The CPFP transaction is then broadcast to\nthe Bitcoin network, and the two sides wait until the funding\ntransaction is confirmed (which requires that the CPFP transaction\nalso be confirmed in the same block). After confirmation, the\nchannel may be used.\n\nIn case of an abort, both sides may spend an input of the funding\ntransaction immediately (and should do so for safety).\n\nMalleated versions of the funding transaction would not be mined,\nas they have 0 transaction fees.\n\nDrawback: Hostaging is possible with the cooperation of a miner;\nit might not even require a malicious miner. Some miners have a\nservice that lets users pay the miner to include a transaction\nwith low transaction fees onto the miner's block. A fraudulent\ncounterparty may create a malleated version of the funding\ntransaction, then provide it to a miner transaction-speedup\nservice with a fee. Once in a block, the other counterparty's\nmoney is held hostage indefinitely.\n\nDrawback: Miners might not support CPFP correctly for various\nreasons. This may slow down the funding transaction getting\nconfirmed until a miner supporting CPFP gets around to the\nfunding transaction and its CPFP.\n\nChannel Lifetime: Unlimited.\n\nAbort: Funds in the channel are unencumbered (and in fact\nshould be moved to another address for safety) if opening is\naborted.\n\nCost: Medium; two transactions, but both with relatively\nsimple scripts.\n\nHostage: Possible with miner cooperation.\n\n== Hashlocked Escrow ==\n\nThe funding transaction needs to be very complicated. In\naddition, each side needs to place in escrow the value of\nthe counterparty's fund; thus, it forces symmetry. For\nexample, even if Bob wants to commit only 0.25 BTC while\nAlice commits 1.0 BTC, Bob must still temporarily commit\n1.25 BTC, then withdraw 1.0 BTC afterwards.\n\nPrior to building the funding transaction, both Alice and\nBob individually create escrow release keys. These are\nsimply short pieces of data. The output script contains\nthe hash of those data.\n\nThe funding transaction takes 1.26 BTC from Alice and\n1.26 BTC from Bob. It has four outputs:\n\n1. 1.0 BTC to (Alice && Bob) || (Bob && AliceEscrowKey)\n2. 0.25 BTC to (Alice && Bob) || (Alice && BobEscrowKey)\n3. 1.0 BTC to (Bob && CSV + 2 hours) || (Alice && AliceEscrowKey)\n4. 0.25 BTC to (Alice && CSV + 2 hours) || (Bob && BobEscrowKey)\n\nCommitment transactions take the first two outputs. Channel\nopening completes by creating an Escrow Recovery Transaction\nthat inputs the #3 and #4 outputs above, and distributes them\nto the correct counterparty in the correct amounts (1.0 to\nBob, 0.25 to Alice).\n\nFirst, each side generates Escrow Release Keys as mentioned,\nthen provides the hash of those keys to each other and\nconstructing, signing, and broadcasting the funding\ntransaction.\n\nWhen the funding transaction is confirmed, each side creates\ncommitment transactions and signs its counterparty's. Finally,\nbefore 1 hour (half the timeout) both of them must create the\nEscrow Recovery Transaction and have both sides acquire a fully\nsigned copy.\n\nTo abort, either of output 3 or 4 must be spent, which also\nimplicitly releases the corresponding output 1 or 2 to the\nother party.\n\nDrawback: If the Bitcoin network is backlogged, race\nconditions may occur that allow either counterparty to steal\ncoins outright from the other counterparty in an abort.\nIf Alice wants to abort, she makes a transaction recovering\noutput 3 of the funding transaction. This publicizes\nAliceEscrowKey. If that transaction is stuck unconfirmed\nuntil the 2-hour timeout passes, Bob can make transactions\nspending outputs 1, 3, and 4, and may boost up the miner fees\nor use a miner's speedup service to speed up the transaction\nspending output 3. Both of Alice and Bob now enter a heated\ntransaction battle, with both of them attempting to claim\noutputs 3 and 4 in addition to their \"safe\" money in output 2\n(for Alice) and output 1 (for Bob).\n\nDrawback: You need to escrow money equal to your counterparty's\nfunding commitment. If the reason you would prefer to have a\nlow funding commitment on your end is due to lack of funds,\nyour counterparty is forced to lower his or her funding\ncommitment to equal yours. But if your counterparty is likely\nto send you money than you will send him or her, this is\ninefficient, as both of you are forced to close the channel\nwhen it saturates.\n\nChannel Lifetime: Unlimited.\n\nAbort: Part of the fund put into the channel is unencumbered,\nwhile the other part is tied up for 2 hours if opening is aborted.\n\nCost: High; funding transaction is complicated, and another\ntransaction is needed to complete the opening.\n\nHostage: Not possible to my knowledge.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170429/48472c8d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Funding Transactions within transaction malleability",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8031
        }
    }
]