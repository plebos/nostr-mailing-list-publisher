[{"title": "[Lightning-dev] Onion messages for probing scheme", "thread_messages": [{"author": "Antoine Riard", "date": "2023-03-01T18:02:04", "message_text_only": "Hi Val,\n\nThanks for the proposal here. About using OM for payment probing, I think\nthere could be an alternative of the routing hops themselves announcing\ntheir liquidity balances with an extension or new set of gossip messages.\n\nGossips messages could commit to a liquidity balance and duration\n(e.g +1000 blocks from tip), rather relying on sender-side probing, which\nmight be less and less accurate with higher rate of network liquidity\ncongestion. Additionally, a routing hop could commit to \"private\" gossip\nsent back to HTLC senders during HTLC successful settlement. Those\n\"private\" gossip might announce \"differentiated services\" of channel\nliquidity levels. I believe this can be guaranteed transparently from the\nrest of the network thanks to parallel channels.\n\nAny deviation from the gossip message could be penalized by sender's\nscoring algorithms as the liquidity SLA parameters have been announced\nexplicitly by the routing hops. This is just an intuition on how public\nchannel liquidity discovery could be worked out, and I don't know which of\nthe alternatives would be more efficient in terms of\nbandwidth/convergence delays.\n\nBest,\nAntoine\n\nLe lun. 27 f\u00e9vr. 2023 \u00e0 21:32, vwallace via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hi list!\n>\n> I wanted to bring up the idea of using onion messages for payment probing,\n> which was briefly touched\n> on at the 2022 LN summit. Tadge Dryja has also brought up a similar idea.\n>\n> I recommend reading the gist instead since it has the relevant diagrams\n> in-line:\n> https://gist.github.com/valentinewallace/ebe1741f0438c2360eda0f80f0e075c9\n> but the scheme is also\n> posted below for convenience.\n>\n> ## Introduction\n>\n> For context, in today\u2019s lightning, payment reliability tends to heavily\n> depend on having sufficient\n> payment volume to determine current liquidity balances of channels, which\n> is how most big nodes can\n> tell whether a given channel has enough liquidity to forward a given\n> amount. If a node is using HTLC\n> probing to achieve this payment volume, they use a regular\n> `update_add_htlc` message with a bogus\n> payment hash, where the error returned informs the sender of whether the\n> payment reached the final\n> recipient. Note that there is a tradeoff between always routing through\n> nodes that are known to\n> rebalance their channels vs leaning on probing smaller nodes and \u201crisking\u201d\n> payments through them\n> based on what\u2019s learned.\n>\n> Today\u2019s HTLC payment probing can work well, but risks channel liquidity\n> being locked up if a peer\n> along the route goes offline. On the upside, for just-in-time probes, it\n> works to loosely \u201creserve\u201d\n> the channel liquidity along the route for the actual payment.\n>\n> Onion messages (OMs) present a convenient way to probe without risking\n> locked liquidity along the\n> route.\n>\n> ## Design Rationale\n>\n> A naive approach could be to send onion message probes directly to\n> individual nodes along the\n> desired route, including those to which you don\u2019t have a direct channel.\n> However, this scheme is\n> problematic because it would enable monitoring the payment flows of\n> arbitrary nodes across the\n> network without having to have a channel path to them. This would be a\n> significant degradation of\n> privacy because, for comparison, in HTLC probing it is quite difficult to\n> probe the balances of\n> far-off nodes. And if you can\u2019t probe a node using HTLCs, you can\u2019t send\n> over it anyway, so there\u2019s\n> not a lot of benefit (and significant privacy downside).\n>\n> Therefore, it is probably best to design a scheme that probes along\n> channel paths, like HTLC\n> probing. This adds more complexity to the case where an intermediate node\n> cannot forward the desired\n> amount due to the stateless nature of OMs, discussed further down.\n>\n> ## Scheme\n>\n> Let\u2019s go through the happy path, where Alice is probing Alice > Bob >\n> Carol > Dave for a 100k msat\n> payment.\n>\n> She\u2019ll construct an onion message for Bob, the first hop, as such:\n> https://imgur.com/BZg8yt8\n>\n> Bob receives this OM, sees that he\u2019s able to forward 110k msats to his\n> next-hop Carol, and forwards\n> Carol\u2019s onion packet to her. Carol sees she can forward 105k msats to\n> Dave, and forwards his onion\n> packet. Finally, Dave receives his onion packet, sees he can receive 100k\n> msats from Carol, and uses\n> the provided reply path to send a simple probe success onion message back\n> to Alice:\n>\n> ```\n> onion_message_probe_result {\n>     data_tlv {\n>         type: 4242,\n>         probe_id: [u8; 32],\n>         can_forward_desired_amt: true,\n>     }\n>    .. regular OM TLVs\n> }\n> ```\n>\n> Note that Dave will use this same onion message if he can\u2019t receive; he\u2019ll\n> just set\n> `can_forward_desired_amt` to false.\n>\n> As an example of the sad path for an intermediate node, if Carol can\u2019t\n> forward 105k msats to Dave,\n> she\u2019ll fail the probe back to Bob by sending this onion message:\n> https://imgur.com/a/hqlzw4I\n>\n> This step justifies why we need to encode a failure onion for each\n> intermediate hop of a probe. If\n> we hadn\u2019t done that, and Carol responded to Bob with an empty \u201cfailed\u201d\n> message, Bob would have no\n> idea which peer to fail the probe back to, because OMs are stateless.\n> Instead, Bob unwraps his error\n> onion and sees that he needs to fail back to Alice with her provided error\n> onion. Alice receives the\n> failure onion and can see that Carol was not able to forward the desired\n> amount corresponding to the\n> probe id, thus completing the probe.\n>\n> ## Outro\n>\n> While there is nothing stopping nodes from lying about their ability to\n> forward, they may be\n> negatively scored if they do so. Further, adopting a protocol like this\n> could help routing nodes\n> attract more forwarding traffic, which is a nice incentive.\n>\n> I view this feature as a low priority enhancement, given there are a lot\n> more pressing issues in LN,\n> but open to feedback. Mostly, I thought it could be useful to spark ideas\n> and highlight the\n> flexibility of OMs.\n>\n> Cheers,\n> Val\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230301/756791ad/attachment.html>", "summary": "The use of onion messages (OMs) for payment probing in Lightning Network could be an alternative to HTLC probing. Routing hops could announce their liquidity balances with a new set of gossip messages, committing to a liquidity balance and duration, which could be guaranteed transparently from the rest of the network thanks to parallel channels. Any deviation from the gossip message could be penalized by sender's scoring algorithms."}, {"author": "Aymeric Vitte", "date": "2023-03-06T16:39:42", "message_text_only": "The question is not really related to onion messages but why is\nLightning not using a DHT system for gossip?\n\n\nLe 01/03/2023 \u00e0 19:02, Antoine Riard a \u00e9crit :\n> Hi Val,\n>\n> Thanks for the proposal here. About using OM for payment probing, I\n> think there could be an alternative of the routing hops themselves\n> announcing their liquidity balances with an extension or new set of\n> gossip messages.\n>\n> Gossips messages could commit to a liquidity balance and duration\n> (e.g +1000 blocks from tip), rather relying on sender-side probing,\n> which might be less and less accurate with higher rate of network\n> liquidity congestion. Additionally, a routing hop could commit to\n> \"private\" gossip sent back to HTLC senders during HTLC successful\n> settlement. Those \"private\" gossip might announce \"differentiated\n> services\" of channel liquidity levels. I believe this can be\n> guaranteed transparently from the rest of the network thanks to\n> parallel channels.\n>\n> Any deviation from the gossip message could be penalized by sender's\n> scoring algorithms as the liquidity SLA parameters have been announced\n> explicitly by the routing hops. This is just an intuition on how\n> public channel liquidity discovery could be worked out, and I don't\n> know which of the alternatives would be more efficient in terms of\n> bandwidth/convergence delays.\n>\n> Best,\n> Antoine\n>\n> Le lun. 27 f\u00e9vr. 2023 \u00e0 21:32, vwallace via Lightning-dev\n> <lightning-dev at lists.linuxfoundation.org\n> <mailto:lightning-dev at lists.linuxfoundation.org>> a \u00e9crit :\n>\n>     Hi list!\n>\n>     I wanted to bring up the idea of using onion messages for payment\n>     probing, which was briefly touched\n>     on at the 2022 LN summit. Tadge Dryja has also brought up a\n>     similar idea.\n>\n>     I recommend reading the gist instead since it has the relevant\n>     diagrams in-line:\n>     https://gist.github.com/valentinewallace/ebe1741f0438c2360eda0f80f0e075c9\n>     but the scheme is also\n>     posted below for convenience.\n>\n>     ## Introduction\n>\n>     For context, in today\u2019s lightning, payment reliability tends to\n>     heavily depend on having sufficient\n>     payment volume to determine current liquidity balances of\n>     channels, which is how most big nodes can\n>     tell whether a given channel has enough liquidity to forward a\n>     given amount. If a node is using HTLC\n>     probing to achieve this payment volume, they use a regular\n>     `update_add_htlc` message with a bogus\n>     payment hash, where the error returned informs the sender of\n>     whether the payment reached the final\n>     recipient. Note that there is a tradeoff between always routing\n>     through nodes that are known to\n>     rebalance their channels vs leaning on probing smaller nodes and\n>     \u201crisking\u201d payments through them\n>     based on what\u2019s learned.\n>\n>     Today\u2019s HTLC payment probing can work well, but risks channel\n>     liquidity being locked up if a peer\n>     along the route goes offline. On the upside, for just-in-time\n>     probes, it works to loosely \u201creserve\u201d\n>     the channel liquidity along the route for the actual payment.\n>\n>     Onion messages (OMs) present a convenient way to probe without\n>     risking locked liquidity along the\n>     route.\n>\n>     ## Design Rationale\n>\n>     A naive approach could be to send onion message probes directly to\n>     individual nodes along the\n>     desired route, including those to which you don\u2019t have a direct\n>     channel. However, this scheme is\n>     problematic because it would enable monitoring the payment flows\n>     of arbitrary nodes across the\n>     network without having to have a channel path to them. This would\n>     be a significant degradation of\n>     privacy because, for comparison, in HTLC probing it is quite\n>     difficult to probe the balances of\n>     far-off nodes. And if you can\u2019t probe a node using HTLCs, you\n>     can\u2019t send over it anyway, so there\u2019s\n>     not a lot of benefit (and significant privacy downside).\n>\n>     Therefore, it is probably best to design a scheme that probes\n>     along channel paths, like HTLC\n>     probing. This adds more complexity to the case where an\n>     intermediate node cannot forward the desired\n>     amount due to the stateless nature of OMs, discussed further down.\n>\n>     ## Scheme\n>\n>     Let\u2019s go through the happy path, where Alice is probing Alice >\n>     Bob > Carol > Dave for a 100k msat\n>     payment.\n>\n>     She\u2019ll construct an onion message for Bob, the first hop, as such:\n>     https://imgur.com/BZg8yt8\n>\n>     Bob receives this OM, sees that he\u2019s able to forward 110k msats to\n>     his next-hop Carol, and forwards\n>     Carol\u2019s onion packet to her. Carol sees she can forward 105k msats\n>     to Dave, and forwards his onion\n>     packet. Finally, Dave receives his onion packet, sees he can\n>     receive 100k msats from Carol, and uses\n>     the provided reply path to send a simple probe success onion\n>     message back to Alice:\n>\n>     ```\n>     onion_message_probe_result {\n>         data_tlv {\n>             type: 4242,\n>             probe_id: [u8; 32],\n>             can_forward_desired_amt: true,\n>         }\n>        .. regular OM TLVs\n>     }\n>     ```\n>\n>     Note that Dave will use this same onion message if he can\u2019t\n>     receive; he\u2019ll just set\n>     `can_forward_desired_amt` to false.\n>\n>     As an example of the sad path for an intermediate node, if Carol\n>     can\u2019t forward 105k msats to Dave,\n>     she\u2019ll fail the probe back to Bob by sending this onion message:\n>     https://imgur.com/a/hqlzw4I\n>\n>     This step justifies why we need to encode a failure onion for each\n>     intermediate hop of a probe. If\n>     we hadn\u2019t done that, and Carol responded to Bob with an empty\n>     \u201cfailed\u201d message, Bob would have no\n>     idea which peer to fail the probe back to, because OMs are\n>     stateless. Instead, Bob unwraps his error\n>     onion and sees that he needs to fail back to Alice with her\n>     provided error onion. Alice receives the\n>     failure onion and can see that Carol was not able to forward the\n>     desired amount corresponding to the\n>     probe id, thus completing the probe.\n>\n>     ## Outro\n>\n>     While there is nothing stopping nodes from lying about their\n>     ability to forward, they may be\n>     negatively scored if they do so. Further, adopting a protocol like\n>     this could help routing nodes\n>     attract more forwarding traffic, which is a nice incentive.\n>\n>     I view this feature as a low priority enhancement, given there are\n>     a lot more pressing issues in LN,\n>     but open to feedback. Mostly, I thought it could be useful to\n>     spark ideas and highlight the\n>     flexibility of OMs.\n>\n>     Cheers,\n>     Val\n>     _______________________________________________\n>     Lightning-dev mailing list\n>     Lightning-dev at lists.linuxfoundation.org\n>     <mailto:Lightning-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230306/a0b1de03/attachment-0001.html>", "summary": "A Lightning developer suggests using gossip messages to announce liquidity balances and differentiated services of channel liquidity levels instead of relying on sender-side probing."}], "thread_summary": {"title": "Onion messages for probing scheme", "categories": ["Lightning-dev"], "authors": ["Aymeric Vitte", "Antoine Riard"], "messages_count": 2, "total_messages_chars_count": 14517, "convo_summary": "Antoine Riard suggests using onion messages (OMs) for payment probing in Lightning Network as an alternative to HTLC probing. Aymeric Vitte agrees and suggests using gossip messages to announce liquidity balances and differentiated services of channel liquidity levels instead of relying on sender-side probing."}}, {"title": "[Lightning-dev] Local Reputation to Mitigate Slow Jamming", "thread_messages": [{"author": "Thomas HUET", "date": "2023-03-02T13:14:24", "message_text_only": "Hello,\n\nI think the local reputation is more important than upfront fees and should\nbe worked on first because 1) the most likely attack against the network\ntoday is the slow jamming attack against which upfront fees are not very\neffective (an attacker would only consider fast jamming if the network is\nalready resilient to slow jamming) and 2) I think that local reputation may\nprotect well enough against all types of jamming so that we don't even need\nupfront fees to protect against fast jamming.\nRegarding the formula itself, I would treat all scores as continuous values\nbetween 0 and 1 instead of binary classes. My proposed formula is detailed\nhere:\nhttps://docs.google.com/document/d/1hEt1EzyPFJ3gOY7PAvtm_XotTnlQO2r7LSF8Jx34qgc/edit?usp=sharing\nHowever my proposal is compatible with Clara's one in that the only thing\nthat needs to be communicated to the peers is how confident we are that the\npayment will succeed and all the rest is done locally and everyone can use\ntheir own formula. I would just prefer this confidence value to be more\nthan one bit but my formula would work with anything, even zero bits. The\nadvantage of using more bits is that we can be more precise in which HTLCs\nwe reject and reduce the number of innocent casualties.\n\nThomas\n\nLe jeu. 16 f\u00e9vr. 2023 \u00e0 22:29, Clara Shikhelman <clara.shikhelman at gmail.com>\na \u00e9crit :\n\n> Hi List,\n>\n> We\u2019re writing to seek early feedback on a draft for a neighbour reputation\n> setting recommendation as a jamming mitigation. The main idea is that\n> allowing full access to liquidity and slots in a channel can result in\n> jamming. To prevent this, we allow full access only to neighbours that\n> forward HTLC that resolve quickly and generate more profit than the damage\n> they can potentially create.\n>\n> The full suggested jamming mitigation solution includes upfront fees\n> together with reputation, see [1] for details.\n>\n> In the previous episodes:\n>\n> As presented here [1], we suggest a two part jamming mitigation strategy.\n> Reputation-based forwarding is aimed to solve \u201cslow jamming\u201d, where the\n> jamming transaction takes a long time to resolve.\n>\n> The main idea is that each node gives a binary reputation to its\n> neighbour. Each channel has a quota of liquidity and slots (say 50% of the\n> channel size and 50% of the slots in the channel) dedicated to transactions\n> coming from neighbours with reputation 0, or for transactions coming from\n> neighbours with reputation 1 that were not endorsed by the neighbour.\n>\n> For example, when Alice asks Bob to forward to Charlie then:\n>\n> If (Alice has reputation 1 with Bob) and (Alice endorses transaction):\n>\n> Forward and endorse\n>\n> Else:\n>\n> If (amount < available liquidity quota) and (available slots in quota>0):\n>\n> Forward HTLC without endorsing\n>\n> Reduce available liquidity and slots\n>\n> Else:\n>\n> Reject\n>\n> Reputation:\n>\n> The question we discuss here is how does Alice gain \u201cgood\u201d reputation\n> (i.e., a score of 1). Alice starts at 0, and she gains and keeps her good\n> reputation of 1 by continuously paying more fees to Bob than the damage she\n> can inflict.\n>\n> The 3 main parameters for reputation that each node operator picks are S,L\n> and M. Our recommendations are as follows:\n>\n>    -\n>\n>    S should be chosen as the maximum time an HTLC can be unresolved in\n>    any of Bob\u2019s channels.\n>    -\n>\n>    M is the revenue generated by Bob\u2019s node in the time S, representing\n>    the damage Alice could inflict.\n>    -\n>\n>    L is the time in which Alice should generate M revenue for Bob for her\n>    to have a good reputation of 1. We suggest L=10S.\n>\n>\n> Alice has reputation 1 if, in the last L seconds, she has forwarded\n> payments that generated M satoshi in fees.\n>\n> As an example:\n>\n>    -\n>\n>    Bob has a maximum CLTV delta of 2 weeks [2]\n>    -\n>\n>    Over the last 2 weeks, he has earned 0.5 BTC in routing fees\n>    -\n>\n>    Alice will be considered to have good reputation if she has forwarded\n>    0.5 BTC of routing revenue to Bob over the last 20 weeks\n>\n>\n> Formally:\n>\n> Let t be the current time, and let S and L be constants.\n>\n> M is calculated to be the revenue of Bob in time [t-S,t]. The revenue of\n> Bob is the sum of fees from transactions forwarded by any neighbour besides\n> Alice + any payments received by Bob. Note that Bob can choose to also take\n> into account utility gained from sending payments or anything of value to\n> the node operator.\n>\n> Alice has reputation 1 if in the time [t-L,t] she has forwarded HTLCs\n> that paid M in normalized fees.\n>\n> We normalize fees by resolution time to reward payments that resolve\n> quickly and discount slow resolving payments. Here we assume 10 seconds is\n> the \u201cnormal\u201d resolution time, this number can be bikesheded, and we round\n> up to avoid penalizing transactions resolved quicker than the \u201cnormal\u201d.\n>\n> The fee from a single transaction is normalized by the time it took for\n> the HTLC to resolve, counted in slots of 10 seconds. That is:\n>\n> Normalized_fee = (fee)/[ceiling(time_to_resolve/10s)]\n>\n>\n>\n> Some notes\n>\n>    1.\n>\n>    The reputation management happens locally, that is, the only protocol\n>    change needed is the ability to signal endorsement as a TLV in\n>    UpdateAddHTLC. The various parameters can be selected for various risk\n>    preferences.\n>    2.\n>\n>    We currently suggest a binary reputation for simplicity. Having\n>    several buckets could be interesting to study, yet we don\u2019t think that the\n>    complexity and the possible privacy issues are worth the potential benefits.\n>    3.\n>\n>    For most use cases, having reputation 0 is more than enough. If we\n>    send and receive transactions at a low rate, we usually don\u2019t need the full\n>    liquidity and slots available in a channel. Reputation mostly comes into\n>    play only when a channel is under attack, and then not all transaction are\n>    allowed to go through.\n>    4.\n>\n>    Following this thread [3]: it is important to note that we are only\n>    giving reputation to our direct neighbours. An advantage of this is that we\n>    have repeated interactions with them. In practice, this is also the only\n>    clean data we have to use when deciding whether to forward an HTLC or not.\n>\n>\n> Best,\n>\n> Carla and Clara\n>\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n> [2]\n> https://github.com/lightningnetwork/lnd/blob/de94a4ea5e81799330a72dfde111817b38565d99/htlcswitch/link.go#L51\n> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003842.html\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230302/47bf0566/attachment-0001.html>", "summary": "A proposed jamming mitigation strategy suggests prioritizing local reputation over upfront fees to protect against slow jamming attacks. A continuous value formula is proposed."}, {"author": "Clara Shikhelman", "date": "2023-03-02T18:56:32", "message_text_only": "Hi Thomas,\n\nI really like the idea of taking into consideration the failures. In our\nproposal, a failure won't benefit your reputation, as the neighbour is\ntrying to reach a fee threshold, but taking it into account instead of\nignoring it could be helpful against an adversary trying to manipulate\nparameters.\n\nCould you elaborate a bit about \"*c, the confidence given by the previous\nnode.*\" It looks from the formula (that has *1/c* component) that the lower\nthe confidence, the higher the reputation, and I am not sure that this is\nthe goal. Some numerical examples could help clarify the dynamics you are\naiming for.\n\nDo you have some estimation of what kind of protection or compensation this\nmethod offers?\n\nBest,\nClara\n\nOn Thu, Mar 2, 2023 at 8:14\u202fAM Thomas HUET <thomas.huet at acinq.fr> wrote:\n\n> Hello,\n>\n> I think the local reputation is more important than upfront fees and\n> should be worked on first because 1) the most likely attack against the\n> network today is the slow jamming attack against which upfront fees are not\n> very effective (an attacker would only consider fast jamming if the network\n> is already resilient to slow jamming) and 2) I think that local reputation\n> may protect well enough against all types of jamming so that we don't even\n> need upfront fees to protect against fast jamming.\n> Regarding the formula itself, I would treat all scores as continuous\n> values between 0 and 1 instead of binary classes. My proposed formula is\n> detailed here:\n>\n> https://docs.google.com/document/d/1hEt1EzyPFJ3gOY7PAvtm_XotTnlQO2r7LSF8Jx34qgc/edit?usp=sharing\n> However my proposal is compatible with Clara's one in that the only thing\n> that needs to be communicated to the peers is how confident we are that the\n> payment will succeed and all the rest is done locally and everyone can use\n> their own formula. I would just prefer this confidence value to be more\n> than one bit but my formula would work with anything, even zero bits. The\n> advantage of using more bits is that we can be more precise in which HTLCs\n> we reject and reduce the number of innocent casualties.\n>\n> Thomas\n>\n> Le jeu. 16 f\u00e9vr. 2023 \u00e0 22:29, Clara Shikhelman <\n> clara.shikhelman at gmail.com> a \u00e9crit :\n>\n>> Hi List,\n>>\n>> We\u2019re writing to seek early feedback on a draft for a neighbour\n>> reputation setting recommendation as a jamming mitigation. The main idea is\n>> that allowing full access to liquidity and slots in a channel can result in\n>> jamming. To prevent this, we allow full access only to neighbours that\n>> forward HTLC that resolve quickly and generate more profit than the damage\n>> they can potentially create.\n>>\n>> The full suggested jamming mitigation solution includes upfront fees\n>> together with reputation, see [1] for details.\n>>\n>> In the previous episodes:\n>>\n>> As presented here [1], we suggest a two part jamming mitigation strategy.\n>> Reputation-based forwarding is aimed to solve \u201cslow jamming\u201d, where the\n>> jamming transaction takes a long time to resolve.\n>>\n>> The main idea is that each node gives a binary reputation to its\n>> neighbour. Each channel has a quota of liquidity and slots (say 50% of the\n>> channel size and 50% of the slots in the channel) dedicated to transactions\n>> coming from neighbours with reputation 0, or for transactions coming from\n>> neighbours with reputation 1 that were not endorsed by the neighbour.\n>>\n>> For example, when Alice asks Bob to forward to Charlie then:\n>>\n>> If (Alice has reputation 1 with Bob) and (Alice endorses transaction):\n>>\n>> Forward and endorse\n>>\n>> Else:\n>>\n>> If (amount < available liquidity quota) and (available slots in quota>0):\n>>\n>> Forward HTLC without endorsing\n>>\n>> Reduce available liquidity and slots\n>>\n>> Else:\n>>\n>> Reject\n>>\n>> Reputation:\n>>\n>> The question we discuss here is how does Alice gain \u201cgood\u201d reputation\n>> (i.e., a score of 1). Alice starts at 0, and she gains and keeps her good\n>> reputation of 1 by continuously paying more fees to Bob than the damage she\n>> can inflict.\n>>\n>> The 3 main parameters for reputation that each node operator picks are S,L\n>> and M. Our recommendations are as follows:\n>>\n>>    -\n>>\n>>    S should be chosen as the maximum time an HTLC can be unresolved in\n>>    any of Bob\u2019s channels.\n>>    -\n>>\n>>    M is the revenue generated by Bob\u2019s node in the time S, representing\n>>    the damage Alice could inflict.\n>>    -\n>>\n>>    L is the time in which Alice should generate M revenue for Bob for\n>>    her to have a good reputation of 1. We suggest L=10S.\n>>\n>>\n>> Alice has reputation 1 if, in the last L seconds, she has forwarded\n>> payments that generated M satoshi in fees.\n>>\n>> As an example:\n>>\n>>    -\n>>\n>>    Bob has a maximum CLTV delta of 2 weeks [2]\n>>    -\n>>\n>>    Over the last 2 weeks, he has earned 0.5 BTC in routing fees\n>>    -\n>>\n>>    Alice will be considered to have good reputation if she has forwarded\n>>    0.5 BTC of routing revenue to Bob over the last 20 weeks\n>>\n>>\n>> Formally:\n>>\n>> Let t be the current time, and let S and L be constants.\n>>\n>> M is calculated to be the revenue of Bob in time [t-S,t]. The revenue of\n>> Bob is the sum of fees from transactions forwarded by any neighbour besides\n>> Alice + any payments received by Bob. Note that Bob can choose to also take\n>> into account utility gained from sending payments or anything of value\n>> to the node operator.\n>>\n>> Alice has reputation 1 if in the time [t-L,t] she has forwarded HTLCs\n>> that paid M in normalized fees.\n>>\n>> We normalize fees by resolution time to reward payments that resolve\n>> quickly and discount slow resolving payments. Here we assume 10 seconds is\n>> the \u201cnormal\u201d resolution time, this number can be bikesheded, and we round\n>> up to avoid penalizing transactions resolved quicker than the \u201cnormal\u201d.\n>>\n>> The fee from a single transaction is normalized by the time it took for\n>> the HTLC to resolve, counted in slots of 10 seconds. That is:\n>>\n>> Normalized_fee = (fee)/[ceiling(time_to_resolve/10s)]\n>>\n>>\n>>\n>> Some notes\n>>\n>>    1.\n>>\n>>    The reputation management happens locally, that is, the only protocol\n>>    change needed is the ability to signal endorsement as a TLV in\n>>    UpdateAddHTLC. The various parameters can be selected for various\n>>    risk preferences.\n>>    2.\n>>\n>>    We currently suggest a binary reputation for simplicity. Having\n>>    several buckets could be interesting to study, yet we don\u2019t think that the\n>>    complexity and the possible privacy issues are worth the potential benefits.\n>>    3.\n>>\n>>    For most use cases, having reputation 0 is more than enough. If we\n>>    send and receive transactions at a low rate, we usually don\u2019t need the full\n>>    liquidity and slots available in a channel. Reputation mostly comes into\n>>    play only when a channel is under attack, and then not all transaction are\n>>    allowed to go through.\n>>    4.\n>>\n>>    Following this thread [3]: it is important to note that we are only\n>>    giving reputation to our direct neighbours. An advantage of this is that we\n>>    have repeated interactions with them. In practice, this is also the only\n>>    clean data we have to use when deciding whether to forward an HTLC or not.\n>>\n>>\n>> Best,\n>>\n>> Carla and Clara\n>>\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n>> [2]\n>> https://github.com/lightningnetwork/lnd/blob/de94a4ea5e81799330a72dfde111817b38565d99/htlcswitch/link.go#L51\n>> [3]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003842.html\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230302/a33c0a42/attachment-0001.html>", "summary": "Thomas suggests that local reputation is more important than upfront fees in preventing slow jamming attacks. He proposes a formula for continuous reputation scores and suggests using more than one bit for confidence values."}, {"author": "Thomas HUET", "date": "2023-03-02T19:28:52", "message_text_only": "To give a very simple example, imagine a node that sends the same\nconfidence c for all HTLCs. We want c to be equal to the probability p that\nits HTLCs succeed.\n- If c = p then all is well and we give a reputation of 1 to the node.\n- If c > p then this node is overconfident or is lying to have its HTLCs\nrelayed, in both cases we should lower its reputation to account for that.\n- If c < p then yes it gives it a higher reputation but the reputation is\ncapped at 1 anyway, so by underestimating the confidence the node doesn't\ngain anything.\nIdeally we want all honest nodes to have a reputation of 1. It doesn't mean\nthat all their HTLCs succeed, it just means that they provide reliable\nestimates of the success probability of the HTLCs.\n\nLe jeu. 2 mars 2023 \u00e0 19:57, Clara Shikhelman <clara.shikhelman at gmail.com>\na \u00e9crit :\n\n> Hi Thomas,\n>\n> I really like the idea of taking into consideration the failures. In our\n> proposal, a failure won't benefit your reputation, as the neighbour is\n> trying to reach a fee threshold, but taking it into account instead of\n> ignoring it could be helpful against an adversary trying to manipulate\n> parameters.\n>\n> Could you elaborate a bit about \"*c, the confidence given by the previous\n> node.*\" It looks from the formula (that has *1/c* component) that the\n> lower the confidence, the higher the reputation, and I am not sure that\n> this is the goal. Some numerical examples could help clarify the dynamics\n> you are aiming for.\n>\n> Do you have some estimation of what kind of protection or compensation\n> this method offers?\n>\n> Best,\n> Clara\n>\n> On Thu, Mar 2, 2023 at 8:14\u202fAM Thomas HUET <thomas.huet at acinq.fr> wrote:\n>\n>> Hello,\n>>\n>> I think the local reputation is more important than upfront fees and\n>> should be worked on first because 1) the most likely attack against the\n>> network today is the slow jamming attack against which upfront fees are not\n>> very effective (an attacker would only consider fast jamming if the network\n>> is already resilient to slow jamming) and 2) I think that local reputation\n>> may protect well enough against all types of jamming so that we don't even\n>> need upfront fees to protect against fast jamming.\n>> Regarding the formula itself, I would treat all scores as continuous\n>> values between 0 and 1 instead of binary classes. My proposed formula is\n>> detailed here:\n>>\n>> https://docs.google.com/document/d/1hEt1EzyPFJ3gOY7PAvtm_XotTnlQO2r7LSF8Jx34qgc/edit?usp=sharing\n>> However my proposal is compatible with Clara's one in that the only thing\n>> that needs to be communicated to the peers is how confident we are that the\n>> payment will succeed and all the rest is done locally and everyone can use\n>> their own formula. I would just prefer this confidence value to be more\n>> than one bit but my formula would work with anything, even zero bits. The\n>> advantage of using more bits is that we can be more precise in which HTLCs\n>> we reject and reduce the number of innocent casualties.\n>>\n>> Thomas\n>>\n>> Le jeu. 16 f\u00e9vr. 2023 \u00e0 22:29, Clara Shikhelman <\n>> clara.shikhelman at gmail.com> a \u00e9crit :\n>>\n>>> Hi List,\n>>>\n>>> We\u2019re writing to seek early feedback on a draft for a neighbour\n>>> reputation setting recommendation as a jamming mitigation. The main idea is\n>>> that allowing full access to liquidity and slots in a channel can result in\n>>> jamming. To prevent this, we allow full access only to neighbours that\n>>> forward HTLC that resolve quickly and generate more profit than the damage\n>>> they can potentially create.\n>>>\n>>> The full suggested jamming mitigation solution includes upfront fees\n>>> together with reputation, see [1] for details.\n>>>\n>>> In the previous episodes:\n>>>\n>>> As presented here [1], we suggest a two part jamming mitigation\n>>> strategy. Reputation-based forwarding is aimed to solve \u201cslow jamming\u201d,\n>>> where the jamming transaction takes a long time to resolve.\n>>>\n>>> The main idea is that each node gives a binary reputation to its\n>>> neighbour. Each channel has a quota of liquidity and slots (say 50% of the\n>>> channel size and 50% of the slots in the channel) dedicated to transactions\n>>> coming from neighbours with reputation 0, or for transactions coming from\n>>> neighbours with reputation 1 that were not endorsed by the neighbour.\n>>>\n>>> For example, when Alice asks Bob to forward to Charlie then:\n>>>\n>>> If (Alice has reputation 1 with Bob) and (Alice endorses transaction):\n>>>\n>>> Forward and endorse\n>>>\n>>> Else:\n>>>\n>>> If (amount < available liquidity quota) and (available slots in\n>>> quota>0):\n>>>\n>>> Forward HTLC without endorsing\n>>>\n>>> Reduce available liquidity and slots\n>>>\n>>> Else:\n>>>\n>>> Reject\n>>>\n>>> Reputation:\n>>>\n>>> The question we discuss here is how does Alice gain \u201cgood\u201d reputation\n>>> (i.e., a score of 1). Alice starts at 0, and she gains and keeps her good\n>>> reputation of 1 by continuously paying more fees to Bob than the damage she\n>>> can inflict.\n>>>\n>>> The 3 main parameters for reputation that each node operator picks are S,L\n>>> and M. Our recommendations are as follows:\n>>>\n>>>    -\n>>>\n>>>    S should be chosen as the maximum time an HTLC can be unresolved in\n>>>    any of Bob\u2019s channels.\n>>>    -\n>>>\n>>>    M is the revenue generated by Bob\u2019s node in the time S, representing\n>>>    the damage Alice could inflict.\n>>>    -\n>>>\n>>>    L is the time in which Alice should generate M revenue for Bob for\n>>>    her to have a good reputation of 1. We suggest L=10S.\n>>>\n>>>\n>>> Alice has reputation 1 if, in the last L seconds, she has forwarded\n>>> payments that generated M satoshi in fees.\n>>>\n>>> As an example:\n>>>\n>>>    -\n>>>\n>>>    Bob has a maximum CLTV delta of 2 weeks [2]\n>>>    -\n>>>\n>>>    Over the last 2 weeks, he has earned 0.5 BTC in routing fees\n>>>    -\n>>>\n>>>    Alice will be considered to have good reputation if she has\n>>>    forwarded 0.5 BTC of routing revenue to Bob over the last 20 weeks\n>>>\n>>>\n>>> Formally:\n>>>\n>>> Let t be the current time, and let S and L be constants.\n>>>\n>>> M is calculated to be the revenue of Bob in time [t-S,t]. The revenue\n>>> of Bob is the sum of fees from transactions forwarded by any neighbour\n>>> besides Alice + any payments received by Bob. Note that Bob can choose to\n>>> also take into account utility gained from sending payments or anything\n>>> of value to the node operator.\n>>>\n>>> Alice has reputation 1 if in the time [t-L,t] she has forwarded HTLCs\n>>> that paid M in normalized fees.\n>>>\n>>> We normalize fees by resolution time to reward payments that resolve\n>>> quickly and discount slow resolving payments. Here we assume 10 seconds is\n>>> the \u201cnormal\u201d resolution time, this number can be bikesheded, and we round\n>>> up to avoid penalizing transactions resolved quicker than the \u201cnormal\u201d.\n>>>\n>>> The fee from a single transaction is normalized by the time it took for\n>>> the HTLC to resolve, counted in slots of 10 seconds. That is:\n>>>\n>>> Normalized_fee = (fee)/[ceiling(time_to_resolve/10s)]\n>>>\n>>>\n>>>\n>>> Some notes\n>>>\n>>>    1.\n>>>\n>>>    The reputation management happens locally, that is, the only\n>>>    protocol change needed is the ability to signal endorsement as a TLV\n>>>    in UpdateAddHTLC. The various parameters can be selected for various\n>>>    risk preferences.\n>>>    2.\n>>>\n>>>    We currently suggest a binary reputation for simplicity. Having\n>>>    several buckets could be interesting to study, yet we don\u2019t think that the\n>>>    complexity and the possible privacy issues are worth the potential benefits.\n>>>    3.\n>>>\n>>>    For most use cases, having reputation 0 is more than enough. If we\n>>>    send and receive transactions at a low rate, we usually don\u2019t need the full\n>>>    liquidity and slots available in a channel. Reputation mostly comes into\n>>>    play only when a channel is under attack, and then not all transaction are\n>>>    allowed to go through.\n>>>    4.\n>>>\n>>>    Following this thread [3]: it is important to note that we are only\n>>>    giving reputation to our direct neighbours. An advantage of this is that we\n>>>    have repeated interactions with them. In practice, this is also the only\n>>>    clean data we have to use when deciding whether to forward an HTLC or not.\n>>>\n>>>\n>>> Best,\n>>>\n>>> Carla and Clara\n>>>\n>>>\n>>> [1]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n>>> [2]\n>>> https://github.com/lightningnetwork/lnd/blob/de94a4ea5e81799330a72dfde111817b38565d99/htlcswitch/link.go#L51\n>>> [3]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003842.html\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230302/f66062bc/attachment-0001.html>", "summary": "A proposed formula for local reputation in Lightning Network considers the confidence given by the previous node, with honest nodes having a reputation of 1."}, {"author": "Clara Shikhelman", "date": "2023-03-03T16:14:12", "message_text_only": "Hi Thomas,\n\nThanks for the example.\n\n- If c < p then yes it gives it a higher reputation but the reputation is\n> capped at 1 anyway, so by underestimating the confidence the node doesn't\n> gain anything.\n>\nIs there anything to gain from giving high confidence? By doing this, you\nrisk lowering your reputation, and it's not clear what you gain.\nCould it be that the best selfish strategy is to report confidence 0 (that\nmaps to reputation 1) all the time?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230303/ca1a5168/attachment.html>", "summary": "The writer questions the benefits of reporting high confidence in a node's reputation, suggesting that a strategy of always reporting confidence 0 may be best."}, {"author": "Thomas HUET", "date": "2023-03-03T16:50:46", "message_text_only": "By giving a high confidence to HTLCs you increase the chance that they are\nrelayed which should be your goal. Having a high reputation is not a goal\nin itself, it's just a way to make your HTLCs more likely to be relayed. If\nyou always report confidence 0, then yes you will have a reputation of 1\nbut your HTLCs will still be rejected at the first sign of congestion.\n\nLe ven. 3 mars 2023 \u00e0 17:14, Clara Shikhelman <clara.shikhelman at gmail.com>\na \u00e9crit :\n\n> Hi Thomas,\n>\n> Thanks for the example.\n>\n> - If c < p then yes it gives it a higher reputation but the reputation is\n>> capped at 1 anyway, so by underestimating the confidence the node doesn't\n>> gain anything.\n>>\n> Is there anything to gain from giving high confidence? By doing this, you\n> risk lowering your reputation, and it's not clear what you gain.\n> Could it be that the best selfish strategy is to report confidence 0 (that\n> maps to reputation 1) all the time?\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230303/bc05d231/attachment.html>", "summary": "Giving high confidence to HTLCs increases the chance of relaying, while having a high reputation is just a means to that end. Reporting confidence 0 may lead to a reputation of 1, but HTLCs may still be rejected during congestion."}, {"author": "Clara Shikhelman", "date": "2023-03-03T18:45:17", "message_text_only": "Could you explain the benefits of continuous solutions over binary? This is\nsomething we should definitely understand before going in a more\ncomplicated direction.\n\nAlso, I'm still not sure that the rational behaviour is to report *c*\ntruthfully.\n\n\n\nOn Fri, Mar 3, 2023 at 11:51\u202fAM Thomas HUET <thomas.huet at acinq.fr> wrote:\n\n> By giving a high confidence to HTLCs you increase the chance that they are\n> relayed which should be your goal. Having a high reputation is not a goal\n> in itself, it's just a way to make your HTLCs more likely to be relayed. If\n> you always report confidence 0, then yes you will have a reputation of 1\n> but your HTLCs will still be rejected at the first sign of congestion.\n>\n> Le ven. 3 mars 2023 \u00e0 17:14, Clara Shikhelman <clara.shikhelman at gmail.com>\n> a \u00e9crit :\n>\n>> Hi Thomas,\n>>\n>> Thanks for the example.\n>>\n>> - If c < p then yes it gives it a higher reputation but the reputation is\n>>> capped at 1 anyway, so by underestimating the confidence the node doesn't\n>>> gain anything.\n>>>\n>> Is there anything to gain from giving high confidence? By doing this, you\n>> risk lowering your reputation, and it's not clear what you gain.\n>> Could it be that the best selfish strategy is to report confidence 0\n>> (that maps to reputation 1) all the time?\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230303/e91b930a/attachment.html>", "summary": "The benefits of continuous solutions over binary should be understood before taking a more complicated direction. Reporting truthfully may not always be rational."}, {"author": "Thomas HUET", "date": "2023-03-03T19:21:57", "message_text_only": "The benefit is that you can be more precise when blocking. With a binary\nsolution a single attacker can easily fill your quota of low-confidence\nHTLCs and then all low-reputation nodes are blocked. But not all of them\nare attackers, some of them just don't send you enough traffic to get a\nhigh reputation for instance and you're going to block them too. With a\ncontinuous solution you can differentiate between an active attacker and\nsomeone who just sends to nodes with poor connectivity and only block the\nfirst.\n\nFor reporting c truthfully, if you report it too high you will be penalized\nby having your reputation lowered, if you report it too low you will\npenalize your HTLCs and still get the same reputation as if you had\nreported it truthfully.\n\nLe ven. 3 mars 2023 \u00e0 19:45, Clara Shikhelman <clara.shikhelman at gmail.com>\na \u00e9crit :\n\n> Could you explain the benefits of continuous solutions over binary? This\n> is something we should definitely understand before going in a more\n> complicated direction.\n>\n> Also, I'm still not sure that the rational behaviour is to report *c*\n> truthfully.\n>\n>\n>\n> On Fri, Mar 3, 2023 at 11:51\u202fAM Thomas HUET <thomas.huet at acinq.fr> wrote:\n>\n>> By giving a high confidence to HTLCs you increase the chance that they\n>> are relayed which should be your goal. Having a high reputation is not a\n>> goal in itself, it's just a way to make your HTLCs more likely to be\n>> relayed. If you always report confidence 0, then yes you will have a\n>> reputation of 1 but your HTLCs will still be rejected at the first sign of\n>> congestion.\n>>\n>> Le ven. 3 mars 2023 \u00e0 17:14, Clara Shikhelman <clara.shikhelman at gmail.com>\n>> a \u00e9crit :\n>>\n>>> Hi Thomas,\n>>>\n>>> Thanks for the example.\n>>>\n>>> - If c < p then yes it gives it a higher reputation but the reputation\n>>>> is capped at 1 anyway, so by underestimating the confidence the node\n>>>> doesn't gain anything.\n>>>>\n>>> Is there anything to gain from giving high confidence? By doing this,\n>>> you risk lowering your reputation, and it's not clear what you gain.\n>>> Could it be that the best selfish strategy is to report confidence 0\n>>> (that maps to reputation 1) all the time?\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230303/d15bb113/attachment-0001.html>", "summary": "Continuous solutions allow for more precise blocking of attackers and low-reputation nodes. Reporting c truthfully is important to maintain reputation."}, {"author": "Clara Shikhelman", "date": "2023-03-03T19:48:52", "message_text_only": "> With a binary solution a single attacker can easily fill your quota of\n> low-confidence HTLCs and then all low-reputation nodes are blocked. But not\n> all of them are attackers, some of them just don't send you enough traffic\n> to get a high reputation for instance and you're going to block them too.\n> With a continuous solution you can differentiate between an active attacker\n> and someone who just sends to nodes with poor connectivity and only block\n> the first.\n>\n\nIf it's very cheap to behave like a neighbour with poor connectivity, why\nwouldn't the attacker mimic this, and then block?\nDifferentiating between a potential attacker and just a low-traffic\nneighbour is very difficult. I think that instead of \"low/high reputation\"\na better way to think about it is \"unknown/endorsed\", and just consider\nwhich neighbour needs access to all resources and which one doesn't.\n\nThe idea of different bins was brought up a few times and might help a bit,\nbut I am not sure at all that it is worth the complication.\n\nFor reporting c truthfully, if you report it too high you will be penalized\n> by having your reputation lowered, if you report it too low you will\n> penalize your HTLCs and still get the same reputation as if you had\n> reported it truthfully.\n>\n\nIt might be that there is a strong motivation to underestimate than\noverestimate. That is \u2013 the punishment for underestimating by X is\nsignificantly smaller than for overestimating by X (or vice versa). The\nformula you choose can affect this significantly.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230303/4c8fa6ae/attachment.html>", "summary": "A continuous solution can differentiate between an active attacker and a low-traffic neighbor, unlike a binary solution that blocks all low-reputation nodes. Reporting c truthfully is crucial to avoid reputation penalties."}, {"author": "Vincenzo Palazzo", "date": "2023-03-04T12:40:23", "message_text_only": "Hi all,\n\nSorry if I jump in the middle of the party!\n\n> Could you explain the benefits of continuous solutions over binary? This is\n> something we should definitely understand before going in a more\n> complicated direction.\nI completly agree! Why we will not propose an practical definition of the local\nreputation and we ran some experimentation of how the local metrics is \nevaluated in a real environment with a real LN node?\n\nBy now we should have the tools to conduct this analysis.\n\nCheers!\n\nVincent.", "summary": "The benefits of continuous solutions over binary need to be understood before moving forward. Proposing a practical definition of local reputation and conducting experiments is suggested."}, {"author": "Antoine Riard", "date": "2023-03-06T17:29:12", "message_text_only": "Hi all,\n\nMy understanding of the local reputation channel is the following, when Bob\nreceives a HTLC forwarding request from Alice to Caroll:\n- if Alice has reputation of 1 and Alice endorses the transaction, Bob\nforwards and endorses the HTLC to Caroll\n- else if the HTLC amount is under the available outbound liquidity quota\nassigned to Alice and available outbound slots assigned to Alice, Bob\nforwards the HTLC to Caroll and reduce available outbound liquidity/slots\nassigned to Alice\n- else the HTLC is rejected\n\nThis is unclear on which criterias the endorsement decision is made (e.g\nCLTV expiry delta, odds of settlement, ongoing congestion of outbound\nchannels ?). Additionally, this is unclear how the available\nliquidity/slots on a given outbound channel are initially distributed\nbetween all the inbound channels (e.g proportional to the capacity) and how\nthey're balanced once the inbound channels start to accumulate reputation.\n\nI don't know if this local reputation scheme precises how reputation is\nslashed in case of HTLC failure, and if any \"grace\" amount/rate is granted\nto the inbound channel counterparty, e.g Alice.\n\nIndependently of those considerations, I think this local reputation scheme\nmight suffer from exploitable reputation asymmetries by a jamming adversary.\nLet's say you have the topology:\n\nAlice - Bob - Caroll - Dave\n\nAlice accumulated a reputation of 1 towards Bob and same for Bob towards\nCaroll. As `fee_base_msat` Bob picked up 1000 msat and Caroll picked up\n2000 msat. If Alice forwards a HTLC to Bob and it is endorsed by him before\nrelay to Caroll, Alice can now inflict a 50 sat damage to Caroll, while\nonly encumbering the lower-priced reputational cost towards Bob.\n\nThis concern could hold in case of asymmetries arising from the dynamic\nadjustment of routing fees during an evaluated period of time. E.g both Bob\nand Caroll requires routing fees of 1000 msat. Alice builds up a reputation\nof 1 towards Bob during this period N. At period N+1, Caroll bumps her\nrouting fees to 2000 msat. From now on, Alice can exploit this asymmetry.\n\nWhile I think this deficiency could be fixed by ensuring a proportionality\nof the reputation acquisition cost between the inbound channels and the\ncost requested by a counterparty on an outbound channel, I believe this\nwould come with the downside that any update in reputation cost should be\nrecursively applied to the downstream links (i.e Bob on Alice channel,\nAlice on neighbouring inbound channels, etc).\n\nApart of this reputation asymmetry concern, I think the local reputation\nscheme could suffer from spontaneous jamming by \"honest\" long-term held\npackets (e.g CLTV delta=2 weeks), where even if Alice is not scored to 1 by\nBob, she always settles her long-term held packets. However, those packets\nare yielding less routing fees to Bob than let's say 14 HTLC packets of\nCLTV delta = 1 day.\n\nFinally, the dynamic reduction of the available outbound liquidity/slots in\nthe occurrence of reputation=0 counterparty's HTLC being only known at the\nlink-level could break the expectations of the HTLC senders scoring\nalgorithms. E.g, being connected to Alice might have probed through another\npath the available liquidity on the link Bob-Caroll. This Eve's probe is\nfalsified by any reduction done by Caroll towards Bob, and therefore Eve's\npayment reliability is likely to be downgraded.\n\nBest,\nAntoine\n\nLe jeu. 16 f\u00e9vr. 2023 \u00e0 21:29, Clara Shikhelman <clara.shikhelman at gmail.com>\na \u00e9crit :\n\n> Hi List,\n>\n> We\u2019re writing to seek early feedback on a draft for a neighbour reputation\n> setting recommendation as a jamming mitigation. The main idea is that\n> allowing full access to liquidity and slots in a channel can result in\n> jamming. To prevent this, we allow full access only to neighbours that\n> forward HTLC that resolve quickly and generate more profit than the damage\n> they can potentially create.\n>\n> The full suggested jamming mitigation solution includes upfront fees\n> together with reputation, see [1] for details.\n>\n> In the previous episodes:\n>\n> As presented here [1], we suggest a two part jamming mitigation strategy.\n> Reputation-based forwarding is aimed to solve \u201cslow jamming\u201d, where the\n> jamming transaction takes a long time to resolve.\n>\n> The main idea is that each node gives a binary reputation to its\n> neighbour. Each channel has a quota of liquidity and slots (say 50% of the\n> channel size and 50% of the slots in the channel) dedicated to transactions\n> coming from neighbours with reputation 0, or for transactions coming from\n> neighbours with reputation 1 that were not endorsed by the neighbour.\n>\n> For example, when Alice asks Bob to forward to Charlie then:\n>\n> If (Alice has reputation 1 with Bob) and (Alice endorses transaction):\n>\n> Forward and endorse\n>\n> Else:\n>\n> If (amount < available liquidity quota) and (available slots in quota>0):\n>\n> Forward HTLC without endorsing\n>\n> Reduce available liquidity and slots\n>\n> Else:\n>\n> Reject\n>\n> Reputation:\n>\n> The question we discuss here is how does Alice gain \u201cgood\u201d reputation\n> (i.e., a score of 1). Alice starts at 0, and she gains and keeps her good\n> reputation of 1 by continuously paying more fees to Bob than the damage she\n> can inflict.\n>\n> The 3 main parameters for reputation that each node operator picks are S,L\n> and M. Our recommendations are as follows:\n>\n>    -\n>\n>    S should be chosen as the maximum time an HTLC can be unresolved in\n>    any of Bob\u2019s channels.\n>    -\n>\n>    M is the revenue generated by Bob\u2019s node in the time S, representing\n>    the damage Alice could inflict.\n>    -\n>\n>    L is the time in which Alice should generate M revenue for Bob for her\n>    to have a good reputation of 1. We suggest L=10S.\n>\n>\n> Alice has reputation 1 if, in the last L seconds, she has forwarded\n> payments that generated M satoshi in fees.\n>\n> As an example:\n>\n>    -\n>\n>    Bob has a maximum CLTV delta of 2 weeks [2]\n>    -\n>\n>    Over the last 2 weeks, he has earned 0.5 BTC in routing fees\n>    -\n>\n>    Alice will be considered to have good reputation if she has forwarded\n>    0.5 BTC of routing revenue to Bob over the last 20 weeks\n>\n>\n> Formally:\n>\n> Let t be the current time, and let S and L be constants.\n>\n> M is calculated to be the revenue of Bob in time [t-S,t]. The revenue of\n> Bob is the sum of fees from transactions forwarded by any neighbour besides\n> Alice + any payments received by Bob. Note that Bob can choose to also take\n> into account utility gained from sending payments or anything of value to\n> the node operator.\n>\n> Alice has reputation 1 if in the time [t-L,t] she has forwarded HTLCs\n> that paid M in normalized fees.\n>\n> We normalize fees by resolution time to reward payments that resolve\n> quickly and discount slow resolving payments. Here we assume 10 seconds is\n> the \u201cnormal\u201d resolution time, this number can be bikesheded, and we round\n> up to avoid penalizing transactions resolved quicker than the \u201cnormal\u201d.\n>\n> The fee from a single transaction is normalized by the time it took for\n> the HTLC to resolve, counted in slots of 10 seconds. That is:\n>\n> Normalized_fee = (fee)/[ceiling(time_to_resolve/10s)]\n>\n>\n>\n> Some notes\n>\n>    1.\n>\n>    The reputation management happens locally, that is, the only protocol\n>    change needed is the ability to signal endorsement as a TLV in\n>    UpdateAddHTLC. The various parameters can be selected for various risk\n>    preferences.\n>    2.\n>\n>    We currently suggest a binary reputation for simplicity. Having\n>    several buckets could be interesting to study, yet we don\u2019t think that the\n>    complexity and the possible privacy issues are worth the potential benefits.\n>    3.\n>\n>    For most use cases, having reputation 0 is more than enough. If we\n>    send and receive transactions at a low rate, we usually don\u2019t need the full\n>    liquidity and slots available in a channel. Reputation mostly comes into\n>    play only when a channel is under attack, and then not all transaction are\n>    allowed to go through.\n>    4.\n>\n>    Following this thread [3]: it is important to note that we are only\n>    giving reputation to our direct neighbours. An advantage of this is that we\n>    have repeated interactions with them. In practice, this is also the only\n>    clean data we have to use when deciding whether to forward an HTLC or not.\n>\n>\n> Best,\n>\n> Carla and Clara\n>\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n> [2]\n> https://github.com/lightningnetwork/lnd/blob/de94a4ea5e81799330a72dfde111817b38565d99/htlcswitch/link.go#L51\n> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003842.html\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230306/d19448db/attachment-0001.html>", "summary": "The local reputation channel involves forwarding requests from one party to another based on reputation and available outbound liquidity/slots. However, there are concerns about endorsement decision criteria, reputation slashing in case of HTLC failure, and exploitable reputation asymmetries."}, {"author": "Clara Shikhelman", "date": "2023-03-06T18:53:59", "message_text_only": "Hi,\n\nThis is unclear on which criterias the endorsement decision is made\n>\n\nA node endorses an HTLC if and only if it came from a neighbour that has\nreputation 1 that endorsed it.\n\n\n> Additionally, this is unclear how the available liquidity/slots on a given\n> outbound channel are initially distributed between all the inbound channels\n> (e.g proportional to the capacity) and how they're balanced once the\n> inbound channels start to accumulate reputation.\n>\n\nThe quotas are for any incoming HTLC that is either from a neighbour with\nreputation 0, or is not endorsed. For each channel, the quotas\nare independent of other channels and independent of the neighbour that\nforwarded the HTLC.\n\n\n\n> I don't know if this local reputation scheme precises how reputation is\n> slashed in case of HTLC failure, and if any \"grace\" amount/rate is granted\n> to the inbound channel counterparty, e.g Alice.\n>\n> Independently of those considerations, I think this local reputation\n> scheme might suffer from exploitable reputation asymmetries by a jamming\n> adversary.\n> Let's say you have the topology:\n>\n> Alice - Bob - Caroll - Dave\n>\n> Alice accumulated a reputation of 1 towards Bob and same for Bob towards\n> Caroll. As `fee_base_msat` Bob picked up 1000 msat and Caroll picked up\n> 2000 msat. If Alice forwards a HTLC to Bob and it is endorsed by him\n> before relay to Caroll, Alice can now inflict a 50 sat damage to Caroll,\n> while only encumbering the lower-priced reputational cost towards Bob.\n>\n> This concern could hold in case of asymmetries arising from the dynamic\n> adjustment of routing fees during an evaluated period of time. E.g both Bob\n> and Caroll requires routing fees of 1000 msat. Alice builds up a reputation\n> of 1 towards Bob during this period N. At period N+1, Caroll bumps her\n> routing fees to 2000 msat. From now on, Alice can exploit this asymmetry.\n>\n\nIn general, if Bob is a low flow node (resulting in it having a low\nthreshold for reputation), he cannot have a high reputation with Carroll as\nhe will never forward enough. Taking into account the differences in fees\nis interesting, but should be checked further.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230306/88a444fc/attachment.html>", "summary": "The criteria for endorsement decisions and the distribution of liquidity/slots on outbound channels are unclear in the local reputation scheme. There may also be exploitable reputation asymmetries."}], "thread_summary": {"title": "Local Reputation to Mitigate Slow Jamming", "categories": ["Lightning-dev"], "authors": ["Thomas HUET", "Antoine Riard", "Clara Shikhelman", "Vincenzo Palazzo"], "messages_count": 11, "total_messages_chars_count": 43094, "convo_summary": "Thomas Huet proposes prioritizing local reputation over upfront fees to prevent slow jamming attacks in Lightning Network. He suggests a formula for continuous reputation scores and using more than one bit for confidence values. Clara Shikhelman questions the benefits of reporting high confidence and suggests reporting confidence 0. Vincenzo Palazzo suggests understanding the benefits of continuous solutions before moving forward. Antoine Riard raises concerns about endorsement decision criteria and exploitable reputation asymmetries in the local reputation channel."}}, {"title": "[Lightning-dev] [Proposal] Payment Route Reservation", "thread_messages": [{"author": "g0b1el", "date": "2023-03-02T13:35:38", "message_text_only": "There are two more improvements I missed in my first mail.\n\nThe first one is that all the nodes on the route get the same amount to reserve. So there is no need to put the amount inside the onion. This way node can fail reservation faster if there is no reservation balance left without opening the onion. Also, the onion gets smaller, and now it holds just the next hop information. This might simplify rendezvous routing(needs to explore this further).\n\nAnd the second improvement is that we don't need HTLC onion in the second step. Route hops already contain all the information to create HTLC. So all that's left to do is for the sender to sign the commitment and to revoke the state with a first node in the route. Thus increase in payment latency would be just one more call between the route nodes.\n\nBest Regards,\ng0b1el\n\n> If ASCII graphics are not rendering correctly, you can read the proposal on the mailing list archive, where for some reason are rendered correctly - https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003867.html", "summary": "Improvements to Lightning Network routing include all nodes on the route receiving the same amount to reserve, simplifying rendezvous routing, and eliminating the need for an HTLC onion in the second step."}], "thread_summary": {"title": "Payment Route Reservation", "categories": ["Lightning-dev", "Proposal"], "authors": ["g0b1el"], "messages_count": 1, "total_messages_chars_count": 1064}}, {"title": "[Lightning-dev] Jamming Mitigation Call Today", "thread_messages": [{"author": "Clara Shikhelman", "date": "2023-03-06T15:03:51", "message_text_only": "Hi List,\n\nA reminder that we've got another jamming call coming up today at 19:00 UTC.\n\nMonday 06 Mar\n19:00 UTC\nhttps://meet.jit.si/UnjammingLN\n\nFeel free to add additional agenda items here:\nhttps://github.com/ClaraShk/LNJamming/issues/\n<https://github.com/ClaraShk/LNJamming/issues/5>5\n\nSee you soon!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230306/12138099/attachment.html>", "summary": "A reminder for the upcoming jamming call at 19:00 UTC on March 6th, with the option to add agenda items on GitHub."}], "thread_summary": {"title": "Jamming Mitigation Call Today", "categories": ["Lightning-dev"], "authors": ["Clara Shikhelman"], "messages_count": 1, "total_messages_chars_count": 487}}, {"title": "[Lightning-dev] Jamming Mitigation Call Summary - 03/06", "thread_messages": [{"author": "Carla Kirk-Cohen", "date": "2023-03-14T19:09:02", "message_text_only": "Hi list,\n\nWriting with a summary from our latest jamming mitigations call.\nFull transcript is available at [1].\n\nDetails for the next call:\n* Tuesday 21 March @ 17:00 UTC - *please note change of day/time*\n* https://meet.jit.si/UnjammingLN\n* Agenda: https://github.com/ClaraShk/LNJamming/issues/9\n\n## Housekeeping\nThe participants discussed the possibility of adding a rotating chair\nfor meetings, as suggested on the agenda issue [2]. There was no strong\npreference to introduce the structure of a chair, and none of the\nattendees volunteered to take on the role for the next meeting, so the\na decision was taken to leave the meetings structured around a communally\nsourced agenda.\n\n## Circuit Breaker Update\nThe circuit breaker UI is being redesigned for a more user friendly\nexperience, and to make it more mobile-friendly.\n\n## Local Reputation\nThe majority of the meeting's discussion was centered around approaches\nto local reputation tracking, as there have been multiple proposals\nsuggested on the mailing list.\n\n### Specification\nThere was some general discussion around taking a simpler approach to\nreputation before trying to propose more ambitious algorithms for\ntracking whether a peer has \"good\" reputation. This suggestion aims\nfor a more pragmatic approach to the long-unsolved quagmire of jamming\nmitigation proposals, and a way to make solutions more easily\nobservable to end users.\n\nThe reputation schemes that have been discussed so far depend on the\naddition of an \"endorsement\" fields to update_add_htlcs to help peers\nalong around communicate whether they believe a HTLC is unlikely to be\npart of a jamming attack. The possibility of starting without an\n\"endorsement\" field was floated, though many participants believed that\nit was an important part of informing forwarding decisions. Instead,\nthe possibility of simplifying the local reputation metric that is\nused to decide whether a peer's behavior is considered \"good\" was\nraised as a simplifying alternative.\n\n### Upfront Fees\nThe question was posed whether we will need to introduce upfront fees\nif we have an effective local reputation mechanism that can identify\nbad behavior. Opinions varied. It was noted that the original\nmotivation for local reputation paired with upfront fees was to address\nattackers that target their attack to sit just beneath a \"good\"\nthreshold. General consensus seemed to be that we should focus on\nreputation first, with the goal of measuring how effectively we can\naddress spamming before endeavoring to add upfront fees to the protocol.\n\n### Understanding of Attacks\nDiscussion also touched on the shifting landscape for the types of\nattacks we are trying to mitigate - at present, a mitigation is\nproposed and then we think about custom attacks for that exact solution.\nInstead, it was suggested that we collect a set of different attack\nstrategies that we wish to defend against, then compare different\nsolutions effectiveness. The first, instinctual definition for an attack\nbeing successfully defeated is that it is unable to disrupt honest\ntraffic.\n\nWe agreed to use an issue on the repo that is used to administer these\nmeetings to track various forms of attacks [3].\n\n### Simulation and Testing\nWe spent some time discussing the availability of data and possibility\nof using simulations to compare various approaches. A few approaches to\nempirically examining the problem were discussed:\n* \"Shadow\" deployment of a reputation metric, just logging outcomes, to\n  see how it would work on nodes today.\n* Data gathering on a collection of nodes in the network to feed into\n  a more realistic simulation.\n* Simulation of various payment flows using the real network graph.\n\nOne drawback that was noted is that we can't use real data to simulate\nattacks, since the network is not under attack in the steady state, and\nthe challenge of realistically representing this type of traffic.\n\nAs always, thanks to all who attended!\nCarla + Clara\n\n[1] https://github.com/ClaraShk/LNJamming/pull/8\n[2] https://github.com/ClaraShk/LNJamming/issues/5\n[3] https://github.com/ClaraShk/LNJamming/issues/7\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230314/1ab60721/attachment.html>", "summary": "A summary of a jamming mitigations call discussing local reputation tracking and the redesign of the circuit breaker UI. Next call on March 21."}], "thread_summary": {"title": "Jamming Mitigation Call Summary - 03/06", "categories": ["Lightning-dev"], "authors": ["Carla Kirk-Cohen"], "messages_count": 1, "total_messages_chars_count": 4288}}, {"title": "[Lightning-dev] Resizing Lightning Channels Off-Chain With Hierarchical Channels", "thread_messages": [{"author": "jlspc", "date": "2023-03-18T00:41:00", "message_text_only": "TL;DR\n=====\n\n* Dynamic management of Lightning channel capacity is required to support efficient Lightning Network (LN) payments\n  - On-chain resizing introduces delays, adds costs and limits scalability\n  - Fast and cheap resizing may be required to support watchtower-free LN payments for casual users\n  - Channel factories allow off-chain channel resizing, but only by exchanging capacity within a single factory\n* Hierarchical channels allow flexible, off-chain resizing of channels\n  - They don't require an exchange of capacity within a limited pool of users\n  - They also support watchtower-free casual users without stranding any channel capacity\n* Hierarchical channels do for channel capacity what the LN does for bitcoin\n* No change to the underlying Bitcoin protocol is required\n\nOverview\n========\n\nThe ability to move Lightning channel capacity to where it's most needed is central to the efficient operation of the LN.\nIn fact, it's been stated that the \"main (probably only) job of\" a dedicated Lightning user \"is to efficiently allocate their liquidity\" [10].\n\nThe use of on-chain transactions to resize channels limits the LN's scalability and increases its fees.\nIn addition, resizing channels on-chain can introduce substantial delays.\nIn fact, delays of multiple months are possible in the case of a casual user who operates in a watchtower-free manner [3], thus stranding capital and potentially preventing such users from operating in a watchtower-free manner in the current environment [10].\n\nExisting proposals for resizing channels off-chain consist of creating a channel factory [1] or CoinPool [7] and exchanging capacity between channels within the same factory or pool.\nHowever, only a very small fraction of the LN's channels can be expected to be in a single factory or pool [8], so the ability to match channels that have insufficient capacity with channels that have excess capacity is highly constrained.\n\nThis post uses hierarchical Lightning channels to solve two problems.\n\nFirst, as long as Lightning channels are created within hierarchical channels, it's possible to resize them flexibly, nearly instantly and off-chain.\nThus, hierarchical channels do for channel capacity what Lightning does for bitcoin.\nIn fact, this is more than just an analogy, as the channel capacity is actually transferred over the LN.\n\nSecond, hierarchical channels can be created by a casual user and a pair of dedicated users such that the casual user can send and receive bitcoin in a watchtower-free manner, while the dedicated users can use all of their channel capacity to route payments even while the casual user is inactive.\nAs a result, casual users can operate in a watchtower-free manner without stranding any capital.\n\nThe remainder of this post describes hierarchical channels and how to use them.\nA more complete description, including figures, is available in a paper [6].\n\nHierarchical Channels\n=====================\n\nA *party* is a group of one or more users.\nA *hierarchical channel* is a 2-party channel that has two main outputs, one per party, plus zero or more HTLC outputs.\nEach output from a hierarchical channel that pays to a multi-user party funds another (potentially hierarchical) channel.\nAs a result, each output in a hierarchical channel (including an HTLC output once it has been resolved) can be viewed as the root of an off-chain tree of outputs where the leaves are owned by single users.\n\nIn order to update a hierarchical channel, funds are offered by one party to the other party in an HTLC.\nOne user within the party offering the HTLC is designated as the *payer* and one user within the party offered the HTLC is designated as the *payee*.\nAll of the funds for the HTLC are provided by the payer, and if the HTLC succeeds, the bulk of the funds go to the payee (but users within the offered party other than the payee can also get routing fees).\nBefore the channel state is updated to include a new HTLC output, all of the users in the channel sign new transactions that spend the new channel state's main outputs, its existing HTLC outputs, and the new HTLC output.\nThe users then sign transactions that implement the new channel state (including the new HTLC output) and revoke the previous channel state.\nOnce the HTLC is resolved, the channel state is updated to include the HTLC's funds in the offered party's main output (if the HTLC succeeded) or in the offering party's main output (if the HTLC failed).\n\nBecause the two parties within a hierarchical channel can use an HTLC to exchange bitcoin, they can link their HTLC to HTLCs in other (potentially hierarchical) channels, thus making payments over the LN.\nIn particular, each party in a (potentially hierarchical) channel appears as a node in the LN channel graph and each (potentially hierarchical) channel appears as a pair of unidirectional edges linking the channel's two parties.\nAs in the current LN, a payment consists of a path where the node that's offered an HTLC in one hop offers an HTLC in the next hop (and the user that is the payee in one hop is the payer in the next hop).\n\nResizing Routing Channels Off-Chain\n===================================\n\nDedicated users who provide routing services to others can use hierarchical channels to resize their Lightning channels off-chain.\nFor example, consider dedicated users A, B, C and D who create a hierarchical channel with parties AB and CD.\nThis hierarchical channel's main outputs fund the (non-hierarchical) channels owned by AB and by CD.\nAlso, assume that party CD has a separate hierarchical channel with (single-user) party E.\n\nIf AB wants to reduce the capacity of their (non-hierarchical) channel, they can create a payment through the LN from party AB (with user A being the payer) to party (and user) A consisting of the path AB -> CD -> E -> F -> G -> A.\nBecause this payment is from party AB within the hierarchical channel owned by parties AB and CD, this payment reduces the value of the main output that pays to AB from this hierarchical channel.\nFurthermore, because the (non-hierarchical) channel owned by A and B is funded by the main output that pays to AB from that hierarchical channel, this payment reduces the size of the channel owned by A and B.\nFinally, because this payment is paid by A (as the payer within the offering party AB at the payment's first hop) and pays to A (as the payment's destination), user A neither gains nor loses funds (except for paying routing fees to users C, D, E, F and G).\n\nFurthermore, as in any LN payment, each routing node that gains funds in one hop loses an identical (minus fees) amount of funds in the next hop, so their overall balance is unchanged (except for a slight increase due to fees).\nThere's nothing new about this for routing nodes E, F and G, as they act as they do in the current LN.\nHowever, it's worth looking in more detail at routing node CD, as the existence of multi-user nodes in the LN is new with hierarchical channels.\n\nLike any routing node, CD gains funds in the hierarchical channel with AB and loses an identical (minus fees) amount of funds in the hierarchical channel with E.\nNote that C and D also appear as nodes within the LN channel graph, the channel between C and D that's funded by the hierarchical channel with AB appears as a pair of unidirectional edges between C and D, and the channel between C and D that's funded by the hierarchical channel with E appears as a pair of unidirectional edges between C and D.\nThus, the sum of the capacities of the two channels between C and D is unchanged, except for a slight increase due to fees.\n\nThe effects of this payment from AB to A on a portion of the LN channel graph are shown below.\nEach party appears as a box and each channel appears as a pair of directed edges between a pair of parties.\nThe channel's capacity is shown between the pair of directed edges, and each party's balance appears either above or below the pair of edges.\n\n                                                                  200\n     PHYSICAL CHANNELS                                       +--+ ->  +--+\n  BEFORE AB -> A PAYMENT                                     |C | 500 |D |\n  OF 100 UNITS PLUS FEES                                     |  |  <- |  |\n                                                             |  | 300 |  |\n                                                             |  |     |  |\n     800      800      400      200      500      500        |  | 700 |  |\n+--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+   |  | ->  |  |\n|AB|1300 |CD|1000 |E |1000 |F | 400 |G | 700 |A | 800 |B |   |  | 800 |  |\n+--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+   +--+  <- +--+\n     500      200      600      200      200      300             100\n\n                                                                  308\n     PHYSICAL CHANNELS                                       +--+ ->  +--+\n   AFTER AB -> A PAYMENT                                     |C | 609 |D |\n  OF 100 UNITS PLUS FEES                                     |  |  <- |  |\n                                                             |  | 301 |  |\n                                                             |  |     |  |\n     691      694      296       98      400      391        |  | 594 |  |\n+--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+   |  | ->  |  |\n|AB|1300 |CD|1000 |E |1000 |F | 400 |G | 700 |A | 691 |B |   |  | 694 |  |\n+--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+   +--+  <- +--+\n     609      306      704      302      300      300             100\n\nLogical vs. Physical Channels\n=============================\n\nBecause there are two separate channels between C and D (one funded by the hierarchical channel with AB and the other funded by the hierarchical channel with E), it's natural to express these channels as two separate pairs of edges between C and D (as is shown above).\nHowever, a better viewpoint is obtained by logically merging the two physical channels between C and D into a single logical channel containing the sum of the capacities of the two physical channels.\nIn fact, a large payment can be routed between C and D by using parallel HTLCs in the two physical channels connecting them.\nIn addition, when logical (rather than physical) channels are advertised to LN peers, the resulting channel capacities are much more stable, as they don't change (other than increasing due to fees) when the parties owning the channel are used to route a payment.\n\nFor example, in the payment shown above the capacity of the channel between A and B is decreased by the amount of the payment from AB to A (plus fees), and the capacity of all other logical channels (including the one between C and D) is unchanged (other than increases due to fees).\n\n     LOGICAL CHANNELS\n  BEFORE AB -> A PAYMENT\n  OF 100 UNITS PLUS FEES\n\n     800      800      400      200      500      500             900\n+--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+   +--+ ->  +--+\n|AB|1300 |CD|1000 |E |1000 |F | 400 |G | 700 |A | 800 |B |   |C |1300 |D |\n+--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+   +--+  <- +--+\n     500      200      600      200      200      300             400\n\n     LOGICAL CHANNELS\n   AFTER AB -> A PAYMENT\n  OF 100 UNITS PLUS FEES\n\n     691      694      296       98      400      391             902\n+--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+ ->  +--+   +--+ ->  +--+\n|AB|1300 |CD|1000 |E |1000 |F | 400 |G | 700 |A | 691 |B |   |C |1303 |D |\n+--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+  <- +--+   +--+  <- +--+\n     609      306      704      302      300      300             401\n\nOf course, the example given above could be reversed (by making a payment from A to AB) in order to increase the capacity of the channel between A and B off-chain.\n\nSupporting Casual Users Without Stranding Capacity\n==================================================\n\nHierarchical channels can also be used to support watchtower-free casual users without stranding any channel capacity.\nConsider a watchtower-free casual user A who creates a hierarchical channel with dedicated users B and C, where A is one party and BC is the other party in the channel.\nAssume A wants to make a payment to G, and that party BC has a separate hierarchical channel with user D, D has a channel with E, E has a channel with F, and F has a channel with G.\nIn this case, A can create a payment through the LN consisting of the path A -> BC -> D -> E -> F -> G.\n\nOf course, this example could be reversed in order to make a payment from G to casual user A.\n\nThe key observation is that whenever A is neither sending nor receiving a payment, dedicated users B and C can utilize all of the capacity in the channel between them to route LN payments.\nAlso, note that as long as B and C advertise their two physical channels (namely the one funded by the hierarchical channel shared with A and the one funded by the hierarchical channel shared with D) as a single logical channel, the capacity of the logical channel is unchanged (other than in increase due to fees) when B and C route payments to and from A.\n\nProtocols For Hierarchical Channels\n===================================\n\nSeveral issues have to be addressed in order to create a protocol for hierarchical channels.\n\nFirst, each main output (or resolved HTLC output) from a hierarchical channel must be able to pay to a tree of transactions that distribute the output's funds to individual users at the leaves.\nThis can be achieved by requiring the users in the hierarchical channel to exchange signatures for the tree of transactions that spend each output of a given Commitment transaction prior to signing that Commitment transaction.\n\nSecond, a Lightning channel is currently announced with a channel_announcement message that references the on-chain UTXO funding the channel and the channel's capacity is static.\nThese channel_announcement messages won't work for hierarchical channels that are funded by off-chain UTXOs and have dynamic capacities.\nRussell's proposal [9] for channel_update_v2 messages is well-suited to hierarchical channels as it merges the concepts of channel announcements and channel updates and it includes the channel's capacity, thus supporting dynamic capacities.\nIn addition, it supports channels that are funded off-chain by allowing on-chain UTXOs to be cited when announcing channels with capacities that are at most a fixed multiple of the on-chain UTXOs' value.\n\nThird, hierarchical channels need to support more than two users per channel.\nThe current Lightning channel protocol only works for 2-user channels, as it penalizes a user that puts an old Commitment transaction on-chain by allowing the other user to obtain all of the channel's funds.\nSuch an approach doesn't work if there are more than two users in the channel, where at least two are dishonest.\nIn such a case, a dishonest user could put an old Commitment transaction on-chain and another dishonest user could \"punish\" that user by claiming all of the channel funds, including those from the honest users.\nEven if the dishonest users can't guarantee that they'll take the channel's funds, the expected value obtained by dishonest behavior could exceed the expected value from honest behavior.\n\nIn contrast, channel factory protocols are designed to allow more than two users to update factory states off-chain, where each factory state consists of a division of the factory's funds among the factory's users.\nTherefore, if we define the hierarchical channel's state as consisting of its two main outputs, plus any HTLC outputs, a channel factory protocol can be used to update the channel's state off-chain.\nIn particular, the Invalidation Tree protocol [2], the Tunable-Penalty Factory protocol [5] or the Single-Commitment Factory protocol [5] can be used.\nOf these, the Tunable-Penalty Factory protocol appears most attractive, as it requires only O(1) time and O(1) on-chain bytes for a unilateral close.\n\nFinally, in addition to maintaining the channel's current set of outputs, each HTLC output must be resolved according to the terms of its associated HTLC.\nA simple approach, based on the current Lightning protocol, is to allow the HTLC output to be spent by either:\n* an HTLC-success transaction put on-chain by the payee and providing the HTLC's required preimage, or\n* an HTLC-timeout transaction put on-chain by any user within the offering party after the HTLC's expiry.\n\nThis approach works, but it has two serious performance problems:\n1) resolving an HTLC on-chain requires closing the hierarchical channel, and\n2) the latency required for putting the HTLC output on-chain can significantly delay the HTLC's expiry.\n\nFortunately, both of these performance challenges are solved by using separate control transactions to resolve the HTCLs, as is done in the FFO and FFO-WF channel protocols [4].\nSpecifically, the FFO protocol can be extended to resolve HTLCs in hierarchical channels owned by more than two dedicated users, and the FFO-WF protocol can be extended to resolve HTLCs in hierarchical channels with more than two users, exactly one of whom is a casual user.\nThe details are given in the paper [6].\n\nConclusions\n===========\n\nSending bitcoin between users can be performed on-chain.\nHowever, allocating bitcoin to a Lightning channel allows it to be sent off-chain nearly instantly, with much lower fees, and in a far more scalable manner.\n\nSimilarly, Lightning channel capacity can be moved to where it's needed on-chain.\nHowever, allocating Lighting channel capacity within a hierarchical channel allows the channel to be resized off-chain nearly instantly, with much lower fees, and in a far more scalable manner.\n\nIn addition, hierarchical channels can be used to support watchtower-free casual users without stranding any Lightning channel capacity.\nAs a result, providing watchtower-freedom to casual users appears to be cost-effective.\n\nGiven that these results can be achieved without making changes to the underlying Bitcoin protocol, it's hoped that hierarchical channels will eventually be adopted in BOLTs and implemented in order to improve the scalability, efficiency, and usability of the Lightning network.\n\nRegards,\nJohn\n\n[1] Burchert, Decker and Wattenhofer, http://dx.doi.org/10.1098/rsos.180089\n[2] Decker and Wattenhofer, https://tik-old.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf\n[3] Law, https://github.com/JohnLaw2/ln-watchtower-free\n[4] Law, https://github.com/JohnLaw2/ln-factory-optimized\n[5] Law, https://github.com/JohnLaw2/ln-efficient-factories\n[6] Law, https://github.com/JohnLaw2/ln-hierarchical-channels\n[7] Naumenko and Riard, https://coinpool.dev/\n[8] Riard, https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020370.html\n[9] Russell, https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-February/003470.html\n[10] Teinturier, https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-October/003712.html\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230318/2dfda9d8/attachment-0001.html>", "summary": "Hierarchical channels allow for flexible, off-chain resizing of Lightning channels, solving issues with on-chain resizing and channel factories. No changes to Bitcoin protocol needed."}, {"author": "David A. Harding", "date": "2023-03-24T03:19:57", "message_text_only": "Hi John,\n\nThank you for another innovative application of your tunable penalties.\nI see two key benefits being described by your paper[1]:\n\n- **Offchain channel resizes:** in state 0, Alice and Bob share control\n   over an offchain UTXO valued at x satoshis; in state 1, the value of\n   the offchain UTXO is y satoshis.\n\n- **Liquidity multiplexing:** Alice, Bob, Carol, and Dan each rightfully\n   own some portion of a UTXO.  Alice and Bob expect to always be\n   available; Carol and Dan may sometimes be unavailable.  The proposal\n   allows Carol and Dan to spend/receive in combination with Alice and\n   Bob, but also ensures Alice and Bob can spend back and forth the\n   entirety their portions of the UTXO even if Carol, Dan, or both of\n   them are unavailable.\n\nFor the Offchain Channel Resizes, I don't see how your proposal\nfunctionally differs from a classic channel factory.  In section 3, you\nshow the set {A, B, C, D} with the subset {A,B} where A reduces its\nbalance in {A,B} by transfering it to {C,D} via an HTLC to another of \nits\nnodes (A').\n\nYour description uses hierarchical channels (which may have >2\nparticipants per channel).  In a classic pair-producing channel factory,\neach channel only has two participants, e.g. the factory {A, B, C, D}\nproduces the channels,\n\n   {A,B}\n   {A,C}\n   {A,D}\n   {B,C}\n   {B,D}\n   {C,D}\n\nHowever, the same thing is possible, A as part of {A,B} can pay through\n{B,C} out of the factory to A'.  After the HTLCs are settled, the\noffchain channel setup transactions inside the factory can be\nregenerated with the cooperation of all {A, B, C, D}.\n\nAm I missing something, or is this first key benefit something that was\nalready possible (in theory) with pair-producing channel factories?\n\nFor the Liquidity Multiplexing, this does feel like a significant\nadvance.  In a pair-producing channel factory, any funds A has in {A, C}\nor {A, D} can't be spent when C or D are unavailable.  In your proposal,\n{A, B} form one half of {{A,B},C} and {{A,B},D}, allowing {A,B} to\nredistribute their portion of the funds when C and D are unavailable.\nThat's not an advantage of multiparty channels that I've seen described\nbefore, and not something I've been able to think how to functionally\nreproduce with pair-producing channel factories.\n\nGiven that it took me a while to understand the Liquidity Multiplexing,\nI wanted to double check to see if I had missed something about the\nOffchain Channel Resizes?\n\nThanks again,\n\n-Dave\n\n[1] https://github.com/JohnLaw2/ln-hierarchical-channels", "summary": "The proposed tunable penalties for offchain channel resizes and liquidity multiplexing in hierarchical channels are discussed, with the latter being a significant advance."}], "thread_summary": {"title": "Resizing Lightning Channels Off-Chain With Hierarchical Channels", "categories": ["Lightning-dev"], "authors": ["jlspc", "David A. Harding"], "messages_count": 2, "total_messages_chars_count": 21834, "convo_summary": "Hierarchical channels offer a solution to on-chain resizing and channel factories, allowing for flexible off-chain resizing. Tunable penalties for off-chain channel resizes and liquidity multiplexing are proposed, with the latter being a significant advancement. No changes to the Bitcoin protocol are needed."}}, {"title": "[Lightning-dev] On a legal communication received March 14th 2023 on one of my Bitcoin dev endpoint", "thread_messages": [{"author": "Antoine Riard", "date": "2023-03-21T07:24:58", "message_text_only": "Hi all,\n\nLast Tuesday 14th March, I did receive a letter from the law firm so-called\nJackson Lewis saying they represent Chaincode Labs about the subject of\n\"improper communications\". Being a long-time Bitcoin developer and knowing\nwell of Chaincode Labs, I've been and I'm still very confused about this\nletter's authenticity.\n\nThe letter is available here under MIT license:\nhttps://github.com/ariard/chaincode-improper-communications\n\nThe sentences inside are quite unclear to me, especially not being an\nEnglish native. They say that I have to halt \"all improper and\ninappropriate communications with certain Chaincode employees\". In the\npast, I did find bugs and other issues in Bitcoin Core Github PRs of some\nChaincode folks, so I don't know if saying the code might be broken under\n\"inappropriate communications\". They add \"You agreed to do so\" without\npresenting old-school paperwork signatures or cryptographic ones or OTS\nproofs of archived content, so it's a bit hard to know what to answer on.\nBeyond that, they say I would have sent \"unsolicited emails\" to Chaincode\nemployees in February 2023. For sure, I've sent mails on the usual mailing\nlists to which a lot of folks are contributing to. And some of those mails\nwere pointing to bitcoin technical shortcomings that might piss off people,\nas always.\n\nThen, they say my \"conduct was improper '' without pointing to a precise\nFOSS code of conduct. The thing is we don't have a code of conduct in\nBitcoin Core as there are a lot of legal uncertainties (from the recent\ninquiry of Chaincode Labs itself iirc). The restraint on communications\ntells nothing if it's scoping the confidential report of security flaws to\nselected parties (among them potentially Chaincode folks), in order to\nmitigate upcoming jeopardy of Bitcoin funds. Finally, the \"any and all\nlegal actions\" doesn't say if those actions can target open-source\ncommunities and projects I might be involved with (like we're seeing Tari\nLabs doing \"legal actions\" against LL and therefore impacting the wider\nnon-LL Taro community).\n\nThere are 2 more troubling issues. One, the title of the letter \"Chaincode\nLabs - Cease & Desist Letter to Antione Riard\". I really received it like\nthis and checked the typo multiple times. I think my name is Antoine Riard,\nI've to verify but I think so. So I don't know if the letter is legally\nvalid. Second, the lawyer issuing the letter sounds to be one specialist in\nlabor law, not really cryptocurrencies and FOSS software.\n\nIn the lack of sound legal advice on my side, I would say the default would\nbe to reach out to the Bitcoin Legal Defense Fund, which from my\nunderstanding sounds to have a mission to provide guidance to developers\nreceiving legal intimidations in the pursuit of their open-source\nactivities. The thing is the Bitcoin Legal Defense Fund is run by Chaincode\nLabs among others, so I wouldn't know if I could ask them for advice on an\nissue at first sight involving them. Sounds a weird catch 22.\n\nBy advance my apologies to Chaincode Labs if I'm sharing a forgery or\nnon-authenticated document assigned to their organization. I believe in the\ncases involving Tulip Trading Lawsuit there has been doubt on the quality\nof the document produced, so a fool sending forgeries to developers to\nthrow confusion among the community is not to exclude. In anycase, I\nbelieve it's better to seek community feedback on what to do about this\nletter (and as such ccing all the lists!).\n\nCheers,\nAntoine\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230321/664f3420/attachment.html>", "summary": "Bitcoin developer Antoine Riard received a cease and desist letter from law firm Jackson Lewis, claiming improper communications with Chaincode Labs employees. Riard is confused about the letter's authenticity and unclear on the allegations, and is considering seeking advice from the Bitcoin Legal Defense Fund, which is run by Chaincode Labs."}], "thread_summary": {"title": "On a legal communication received March 14th 2023 on one of my Bitcoin dev endpoint", "categories": ["Lightning-dev"], "authors": ["Antoine Riard"], "messages_count": 1, "total_messages_chars_count": 3663}}, {"title": "[Lightning-dev] [MODERATION] List Moderation Enabled", "thread_messages": [{"author": "Rusty Russell", "date": "2023-03-22T02:01:32", "message_text_only": "Hi all,\n\n        All posts will be reviewed by a moderator, and I will not be\napproving posts which are not directly concerned with Lightning\ndevelopment.[1]\n\nI'll review this decision sometime next week.[2]\n\nSorry for the inevitable latency!\nRusty.\n\n[1] Except this one.\n[2] Yeah, and I guess that one too?", "summary": "Posts not related to Lightning development will not be approved by the moderator. The decision will be reviewed next week."}], "thread_summary": {"title": "List Moderation Enabled", "categories": ["Lightning-dev", "MODERATION"], "authors": ["Rusty Russell"], "messages_count": 1, "total_messages_chars_count": 307}}, {"title": "[Lightning-dev] JSON RPC Interface BLIP", "thread_messages": [{"author": "michael at mikuhl.me", "date": "2023-03-24T03:14:54", "message_text_only": "Hi List,\n\nI am creating an app to manage your Bitcoin Lightning Node, but I am struggling to find a good solution to connect to the plethora of back ends that are available now. Especially via web, where I am encountering CORS errors, which would require the user to specifically configure their node to use the app, creating a not so great user experience.\n\nNodes may also be behind various firewalls, making them notoriously difficult to connect to remotely. Lightning Labs has made their solution called Lightning Node Connect, which uses a secure proxy WebSocket to talk to the node. But I fear Lightning Node Connect is far too tailored for use with LND, and gRPC. Also, I found myself having a hard time grasping the numerous different protocols, and handshakes it uses, as I needed to write an implementation in a language that it is not already available. Thus, the idea of getting other node back ends, like CLN, and Eclair to implement it, is a tough ask.\n\nWhat if there was a BLIP that described a JSON RPC interface over a WebSocket, that node back ends can implement allowing any front end to be able to be used with any back end. It would include all basic features of lightning, like opening a channel, closing a channel, sending a payment, etc. Technically, even custodial solutions like Wallet of Satoshi, could implement this interface. This allows the freedom to use any interface you desire, similar to how you can use any email client, with any email server.\n\nAdditionally, it would be great to have also a proxy version of the JSON RPC interface, allowing two sides to connect and subscribe to each other, and the proxy server pass encrypted messages it cant read along to the other side, allowing you to use your node behind complicated firewalls, like Tor.\n\nList, what do you think of something like this?\nThanks, Michael.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230324/60474ac2/attachment.html>", "summary": "The author is struggling to find a good solution to connect to Bitcoin Lightning Node back ends, and proposes a BLIP that describes a JSON RPC interface over a WebSocket to allow any front end to be used with any back end."}], "thread_summary": {"title": "JSON RPC Interface BLIP", "categories": ["Lightning-dev"], "authors": ["michael at mikuhl.me"], "messages_count": 1, "total_messages_chars_count": 2031}}, {"title": "[Lightning-dev] On watchtowers and accumulators", "thread_messages": [{"author": "Sergi Delgado Segura", "date": "2023-03-24T08:52:17", "message_text_only": "Hi all,\n\nSome time ago I was discussing with ZmnSCPxj about how to handle data\ndeletion for accountable watchtowers such that the tower doesn't have to\nstore raw proof of deletion for every single deleted item. The gist is\npretty simple, if I send you data and you hand me proof of reception of\nsuch data, if I ask you to delete the data, now you need to keep proof of\ndeletion, otherwise, I could claim you are not storing the data we agreed\non initially.\n\nThis, unsurprisingly, has led to using accumulators (as ZmnSCPxj originally\nsuggested) to reduce the data storage requirements (especially on the user\nside) while being able to prove additions/deletions.\n\nAfter chatting with Salvatore Ingala and Calvin Kim about it, I've come to\na point where I think this may be solvable in a rather elegant way, so I\nhave written a draft of what this may look like wrt watchtowers going,\nbriefly, from what towers are (and what we mean by accountable) to how\naccumulators may help with this issue.\n\nIf you're curious about either or both, please give it a look :D\n\nhttps://gist.github.com/sr-gi/f91f007fc8d871ea96ead9b27feec3d5\n--\nSergi.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230324/dfb16909/attachment.html>", "summary": "Sergi has written a draft on how to handle data deletion for accountable watchtowers using accumulators to reduce data storage requirements."}], "thread_summary": {"title": "On watchtowers and accumulators", "categories": ["Lightning-dev"], "authors": ["Sergi Delgado Segura"], "messages_count": 1, "total_messages_chars_count": 1316}}, {"title": "[Lightning-dev] Payment correlation attacks", "thread_messages": [{"author": "g0b1el", "date": "2023-03-25T13:09:07", "message_text_only": "Using payment correlation attacks adversary can try to link the sender and receiver of payment by observing traffic from the potential sender to the potential receiver. Such observations can be made by the adversary nodes if they are present on the payment path or if the adversary is able to monitor the network traffic of the potential sender and receiver. In some circumstances, the adversary can detect not only his presence on the payment path, but also if the monitored nodes are the sender and receiver.\n\n\u00a0 \u00a0___ \u00a0 \u00a0____ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ____ \u00a0 \u00a0___\n\u00a0 | \u00a0 | \u00a0| \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a0| \u00a0| \u00a0 |\n--| S |->| A1 |--> ......... -->| A2 |->| R |--\n\u00a0 |___| \u00a0|____| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 |____| \u00a0|___|\n\nS - potential sender\nR - potential receiver\nA1, A2 - adversary surveillance node\n\nFor big well-distributed networks, these forms of attacks are very costly and can be economically applied only on a small set of nodes. However, if a network is centralized, with the majority of traffic passing through a small number of big nodes, an adversary's job is much easier. An adversary can monitor traffic on those nodes, or in the case of a state-funded surveillance adversary, an adversary can acquire a court order to get complete access to big nodes routing information.\n\nThe adversary job can be simplified if:\n- A1 and A2 are the same nodes. The sender and receiver are connected through a single node, the adversary node.\n- A2 and R are the same nodes. The receiver is some form of custodial wallet, directly controlled or in collusion with the adversary. The adversary is going to be aware of all income transactions. The only thing left is to find out who the sender is.\n- S and A1 are the same nodes. If the sender is some form of custodial wallet, directly controlled or in collusion with the adversary, the sender has no privacy, so correlation attacks are unnecessary.\n- S->A1 is an unpublished channel. An adversary can identify S as the sender for all payments originating from S and passing through A1.\n- A2->R is an unpublished channel. An adversary can identify R as the receiver for all payments destined for R and passing through A2.\n\n\nThe most notable LN payment correlations in order of severity are:\n\n\u00a0* Hash correlation\n\u00a0* Amount correlation\n\u00a0* CLTV correlation\n\u00a0* Timing correlation\n\nHash correlation\n================\n\nHash correlation is the most straightforward to detect for surveillance nodes. If adversary nodes A1 and A2 observe a payment with the same hash, they can confidently conclude that they are on the payment path. However, the adversary cannot yet determine with enough certainty whether S is the sender and R the receiver. Yet, when combined with other correlation attacks or network topology examination, the adversary can establish such a conclusion with enough probability.\nFortunately, payment hash correlation is soon expected to be fixed with point time lock contracts (PTLCs)[1]. Each payment hop will use a unique lock contract point, so there will be no information that can correlate different payments.\n\n\nAmount correlation\n==================\n\nPayment amount correlation is only slightly better than hash correlation in terms of privacy because the receiver amount on each hop is mixed with the fees of all the downstream nodes. Fees on LN are just a tiny fraction of the amount, so for the attacker fees are not an issue, especially in combination with timing correlation attacks.\n\nSingle-path payments are the most vulnerable to amount correlation attacks. Besides the fact that nodes A1 and A2 will see a payment with roughly the same amount, node A2 depending on the payment amount, can conclude that R is a receiver. For instance, if the receiver is a shop that sells some product for X satoshis, and if the attacker sees a payment of around X satoshis, he can be sure that this payment goes to that shop node.\n\nMulti-path payments have better privacy because the amount is now split into multiple parts. The attacker can not easily find out what product the sender is buying. But there is still a potential correlation factor, depending on how we split the payment amount.\nIf we split the payment into equal parts, the attacker still can find out if a partial payment is multiple of the price of some of the shop products. Also, those sub-payment paths will be easily distinguishable by the amount, just like in the case of single-path payment.\n\nSo, what can be done to de-correlate sub-path payment amounts?\n\nRather than splitting the payment amount into equal parts, we split it into predefined values. For instance: 10k, 20k, 50k, 100k, 200k, 500k, 1000k, ... satoshis. Just like physical cash. By doing so, every individual payment is part of a much larger anonymity set consisting of all the payments at that moment. Using this approach, we can split a payment into as many paths as needed until we get to the exact number of satoshis. Splitting the payment amount into enough sub-paths to get an exact amount might be an overhead if current satoshi value, fees, and latencies are taken into account. Depending on user privacy preference, the wallet can create a payment path with exact change or overpay to the closest predefined value.\n\nFor instance, if there is a payment of 459,645 satoshis.\n\nUsers not that interested in privacy can split:\n200k + 200k + 50k + 9,645.\nWhile privacy-oriented users would overpay slightly:\n200k + 200k + 50k + 10k.\n\nNow sub-payments of privacy-oriented users are mixed with all other privacy-oriented and non-privacy-oriented users. Thus, the anonymity set is increased subsectional, especially if LN is processing a huge amount of transactions per second.\n\nThe drawback in splitting payment amounts into predefined values is that we might create more redundant payment[2] routes to match the reliability of sub-payments split into equal parts. When we split into equal parts, every redundant payment path can be used to replace any other failed paths. But in the case of predefined values, redundant sub-payment can replace only the sub-path with the same payment amount.\n\nCLTV correlation\n================\n\nCLTV correlation is not as serious as hash or amount correlation because it doesn't explicitly connect payment routes through adversary nodes. CLTV value does give a sense of closeness to either sender or receiver. However, if hop CLTV delta values used are exactly as the one nodes gossiped, then an attacker can potentially determine the payment path as well. This is especially true when CLTV deltas are used in combination with timing correlation, allowing the attacker to calculate all cltv path combinations between A1 and A2 and deduce if they are on the payment path.\nWith payment route reservation [2], CLTV delta gets shuffled thanks to the payment route split. If there is no route split node can return a random CLTV value around some predefined value. Thus for the attacker's job to correlate payment with payment route reservation, using only CLTV gets much harder.\n\n\nTiming correlation\n==================\n\nEvery low-latency network is susceptible to timing correlation attacks. The adversary observes the network traffic between the potential sender and receiver, and the time of the transactions is used to make correlations. This type of attack can be carried out even without LN node if the adversary can monitor the surveilled node's network traffic. Low-traffic networks are more vulnerable to timing attacks than high-traffic networks. As the number of LN users and payments continues to grow, the potential payment set will increase, making it increasingly difficult to correlate payments using only timing analysis.\n\nTo mitigate timing correlation attacks, a possible solution is to introduce a small random delay for privacy-oriented payments. This approach can make the attacker's job somewhat harder.\n\n\nWhat the attacker would most likely do is use a combination of amount, cltv, and timing correlation attacks. Each correlation attack will give some probability, and cumulative probability might reveal the payment route and, in the worst case, the sender and receiver. Therefore, it is crucial to minimize the probability of success for each attack to ensure the highest possible payment privacy.\n\n\n[1] https://bitcoinops.org/en/topics/ptlc/\n[2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003867.html\n\nBest Regards,\ng0b1el", "summary": "Payment correlation attacks can link senders and receivers by observing traffic, but are costly for well-distributed networks. Centralized networks are more vulnerable. Hash correlation is the most straightforward attack, but can be fixed with point time lock contracts."}, {"author": "Lloyd Fournier", "date": "2023-03-29T00:19:03", "message_text_only": "Hi g0b1e,\n\nI wanted to add to this excellent summary that there is a trade off here.\nThe harder you make payment correlation the easier you make channel\njamming. If payments can not be correlated at all it's possible to make\npayment paths that cycle through the same nodes many times over. This\nallows an adversary to lock up e.g. 10x the channel capacity on a target\nchannel than the coins they commit to the attack.\n\nSee: https://bitcoinproblems.org/problems/ptlc-cycle-jamming.html\n\nCheers,\n\nLL\n\nOn Mon, 27 Mar 2023 at 10:26, g0b1el via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Using payment correlation attacks adversary can try to link the sender and\n> receiver of payment by observing traffic from the potential sender to the\n> potential receiver. Such observations can be made by the adversary nodes if\n> they are present on the payment path or if the adversary is able to monitor\n> the network traffic of the potential sender and receiver. In some\n> circumstances, the adversary can detect not only his presence on the\n> payment path, but also if the monitored nodes are the sender and receiver.\n>\n>    ___    ____                   ____    ___\n>   |   |  |    |                 |    |  |   |\n> --| S |->| A1 |--> ......... -->| A2 |->| R |--\n>   |___|  |____|                 |____|  |___|\n>\n> S - potential sender\n> R - potential receiver\n> A1, A2 - adversary surveillance node\n>\n> For big well-distributed networks, these forms of attacks are very costly\n> and can be economically applied only on a small set of nodes. However, if a\n> network is centralized, with the majority of traffic passing through a\n> small number of big nodes, an adversary's job is much easier. An adversary\n> can monitor traffic on those nodes, or in the case of a state-funded\n> surveillance adversary, an adversary can acquire a court order to get\n> complete access to big nodes routing information.\n>\n> The adversary job can be simplified if:\n> - A1 and A2 are the same nodes. The sender and receiver are connected\n> through a single node, the adversary node.\n> - A2 and R are the same nodes. The receiver is some form of custodial\n> wallet, directly controlled or in collusion with the adversary. The\n> adversary is going to be aware of all income transactions. The only thing\n> left is to find out who the sender is.\n> - S and A1 are the same nodes. If the sender is some form of custodial\n> wallet, directly controlled or in collusion with the adversary, the sender\n> has no privacy, so correlation attacks are unnecessary.\n> - S->A1 is an unpublished channel. An adversary can identify S as the\n> sender for all payments originating from S and passing through A1.\n> - A2->R is an unpublished channel. An adversary can identify R as the\n> receiver for all payments destined for R and passing through A2.\n>\n>\n> The most notable LN payment correlations in order of severity are:\n>\n>  * Hash correlation\n>  * Amount correlation\n>  * CLTV correlation\n>  * Timing correlation\n>\n> Hash correlation\n> ================\n>\n> Hash correlation is the most straightforward to detect for surveillance\n> nodes. If adversary nodes A1 and A2 observe a payment with the same hash,\n> they can confidently conclude that they are on the payment path. However,\n> the adversary cannot yet determine with enough certainty whether S is the\n> sender and R the receiver. Yet, when combined with other correlation\n> attacks or network topology examination, the adversary can establish such a\n> conclusion with enough probability.\n> Fortunately, payment hash correlation is soon expected to be fixed with\n> point time lock contracts (PTLCs)[1]. Each payment hop will use a unique\n> lock contract point, so there will be no information that can correlate\n> different payments.\n>\n>\n> Amount correlation\n> ==================\n>\n> Payment amount correlation is only slightly better than hash correlation\n> in terms of privacy because the receiver amount on each hop is mixed with\n> the fees of all the downstream nodes. Fees on LN are just a tiny fraction\n> of the amount, so for the attacker fees are not an issue, especially in\n> combination with timing correlation attacks.\n>\n> Single-path payments are the most vulnerable to amount correlation\n> attacks. Besides the fact that nodes A1 and A2 will see a payment with\n> roughly the same amount, node A2 depending on the payment amount, can\n> conclude that R is a receiver. For instance, if the receiver is a shop that\n> sells some product for X satoshis, and if the attacker sees a payment of\n> around X satoshis, he can be sure that this payment goes to that shop node.\n>\n> Multi-path payments have better privacy because the amount is now split\n> into multiple parts. The attacker can not easily find out what product the\n> sender is buying. But there is still a potential correlation factor,\n> depending on how we split the payment amount.\n> If we split the payment into equal parts, the attacker still can find out\n> if a partial payment is multiple of the price of some of the shop products.\n> Also, those sub-payment paths will be easily distinguishable by the amount,\n> just like in the case of single-path payment.\n>\n> So, what can be done to de-correlate sub-path payment amounts?\n>\n> Rather than splitting the payment amount into equal parts, we split it\n> into predefined values. For instance: 10k, 20k, 50k, 100k, 200k, 500k,\n> 1000k, ... satoshis. Just like physical cash. By doing so, every individual\n> payment is part of a much larger anonymity set consisting of all the\n> payments at that moment. Using this approach, we can split a payment into\n> as many paths as needed until we get to the exact number of satoshis.\n> Splitting the payment amount into enough sub-paths to get an exact amount\n> might be an overhead if current satoshi value, fees, and latencies are\n> taken into account. Depending on user privacy preference, the wallet can\n> create a payment path with exact change or overpay to the closest\n> predefined value.\n>\n> For instance, if there is a payment of 459,645 satoshis.\n>\n> Users not that interested in privacy can split:\n> 200k + 200k + 50k + 9,645.\n> While privacy-oriented users would overpay slightly:\n> 200k + 200k + 50k + 10k.\n>\n> Now sub-payments of privacy-oriented users are mixed with all other\n> privacy-oriented and non-privacy-oriented users. Thus, the anonymity set is\n> increased subsectional, especially if LN is processing a huge amount of\n> transactions per second.\n>\n> The drawback in splitting payment amounts into predefined values is that\n> we might create more redundant payment[2] routes to match the reliability\n> of sub-payments split into equal parts. When we split into equal parts,\n> every redundant payment path can be used to replace any other failed paths.\n> But in the case of predefined values, redundant sub-payment can replace\n> only the sub-path with the same payment amount.\n>\n> CLTV correlation\n> ================\n>\n> CLTV correlation is not as serious as hash or amount correlation because\n> it doesn't explicitly connect payment routes through adversary nodes. CLTV\n> value does give a sense of closeness to either sender or receiver. However,\n> if hop CLTV delta values used are exactly as the one nodes gossiped, then\n> an attacker can potentially determine the payment path as well. This is\n> especially true when CLTV deltas are used in combination with timing\n> correlation, allowing the attacker to calculate all cltv path combinations\n> between A1 and A2 and deduce if they are on the payment path.\n> With payment route reservation [2], CLTV delta gets shuffled thanks to the\n> payment route split. If there is no route split node can return a random\n> CLTV value around some predefined value. Thus for the attacker's job to\n> correlate payment with payment route reservation, using only CLTV gets much\n> harder.\n>\n>\n> Timing correlation\n> ==================\n>\n> Every low-latency network is susceptible to timing correlation attacks.\n> The adversary observes the network traffic between the potential sender and\n> receiver, and the time of the transactions is used to make correlations.\n> This type of attack can be carried out even without LN node if the\n> adversary can monitor the surveilled node's network traffic. Low-traffic\n> networks are more vulnerable to timing attacks than high-traffic networks.\n> As the number of LN users and payments continues to grow, the potential\n> payment set will increase, making it increasingly difficult to correlate\n> payments using only timing analysis.\n>\n> To mitigate timing correlation attacks, a possible solution is to\n> introduce a small random delay for privacy-oriented payments. This approach\n> can make the attacker's job somewhat harder.\n>\n>\n> What the attacker would most likely do is use a combination of amount,\n> cltv, and timing correlation attacks. Each correlation attack will give\n> some probability, and cumulative probability might reveal the payment route\n> and, in the worst case, the sender and receiver. Therefore, it is crucial\n> to minimize the probability of success for each attack to ensure the\n> highest possible payment privacy.\n>\n>\n> [1] https://bitcoinops.org/en/topics/ptlc/\n> [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-February/003867.html\n>\n> Best Regards,\n> g0b1el\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230329/5e48a435/attachment-0001.html>", "summary": "Payment correlation attacks can link the sender and receiver of a payment by observing traffic, making channel jamming easier, and allowing an adversary to lock up more than the committed coins."}], "thread_summary": {"title": "Payment correlation attacks", "categories": ["Lightning-dev"], "authors": ["g0b1el", "Lloyd Fournier"], "messages_count": 2, "total_messages_chars_count": 18062, "convo_summary": "Payment correlation attacks can link senders and receivers by observing traffic, making channel jamming easier and allowing an adversary to lock up more than the committed coins. Centralized networks are more vulnerable, but well-distributed networks can be costly. Hash correlation is the most straightforward attack, but can be fixed with point time lock contracts."}}, {"title": "[Lightning-dev] [Splicing] On the topic of commit_sigs + revoke_and_ack", "thread_messages": [{"author": "niftynei", "date": "2023-03-30T22:08:22", "message_text_only": "This feels sort of dumb but I wrote it up and thought maybe others would\nfind it enlightening.\n\nThere's been a question of whether or not we should re-send all of the\ncommitment-sigs after a new splice has been negotiated. The current CLN\ndraft of splicing sends all of them, should we only send the one?\n\nAfter writing this out, it seems fairly obvious to me that the correct way\nforward is to only send a commitment sig for the newly negotiated splice;\nall of the commitment sigs should be re-sent only when the underlying\ncommitment tx changes (eg. htlc added/removed).\n\nLonger analysis below.\n\nAs an interesting 'historical aside', in the original splicing draft\nproposal, all commitment sigs were sent in a single message; we've since\nsplit them out into more messages, which now nicely allows for only sending\nthe new commitment_signed message when appropriate.\n\n~nifty\n\nh/t to @ddustin and @t-bast for surfacing this.\n\n\n# Should we re-send commit_sigs + revoke_and_ack for newly negotiated\nsplices?\n\n## Background\n\nWhen a splice tx is successfully negotiated, we need to send a\ncommitment-sig to the peer to be able to send the new funding tx.\n\nAfter `tx_complete`, we need to exchange the `commitment_sig` for the newly\ncreated splice tx.\n\n\n## Purpose of `commitment_signed`\n\nThe purpose of the `commitment_signed` message is to send the peer your\ncommitment sig for the currently proposed commitment.\n\n\n## Purpose of `revoke_and_ack`\n\nThe purpose of `revoke_and_ack` is two-fold:\n\n- Send a revocation point for the previous commitment transaction, REVOKING\nthe previous commitment\n- ACK that the commitment sig has been received for the next commitment\n\n\n\n## Current Protocol\n\nCurrently we send the following:\n- a `commitment_sig` message for the just negotiated splice tx\n- resends all prior negotiated splice `commit_sigs` (if RBF) and the\nnon-splice commit-sig.\n\nAfter receiving all the `commit_sig` messages, we do the 'normal' thing\nwhere we then exchange a single `revoke_and_ack`.\n\nNotably, the Current Protocol is identical for both new commitment signed\nworkflows and a new splice negotiation.\n\nWhich is to say, we re-use the same protocol for any new commitment\nsignatures that are required.\n\n### Benefits to this Approach\n\n- Single action to be taken after either a new commitment is negotiated or\na splice.\n- Less complexity in implementation + less testing footprint\n\n### Drawbracks to this Approach\n\n- Redundant messages are sent (peer already has all prior commitment sigs\nin the splice case)\n- More signing required for successful splice\n\n## Alternative Proposal\n\nInstead of sending all of the commit-sigs and a revoke_and_ack, we'd send a\nsingle `commitment_sig`.\n\n### Benefits of this Approach\n\n- Less data sent over the wire. Only new information is transmitted\n- Less signatures need to be (re)-generated.\n\n### Drawbacks to this Approach\n\n- We need a way to communicate that the `commitment_sig` has been received.\n(`tx_signatures` should fill this role.)\n- It's a slightly different way of doing commitments.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230330/e3b76db5/attachment-0001.html>", "summary": "The author questions whether all commitment-sigs should be re-sent after a new splice is negotiated, suggesting only the new one should be sent."}], "thread_summary": {"title": "On the topic of commit_sigs + revoke_and_ack", "categories": ["Lightning-dev", "Splicing"], "authors": ["niftynei"], "messages_count": 1, "total_messages_chars_count": 3228}}, {"title": "[Lightning-dev] Proposed changes to the splicing specification", "thread_messages": [{"author": "Bastien TEINTURIER", "date": "2023-03-31T09:04:24", "message_text_only": "Good morning list,\n\nAs some of you may know, we've been hard at work experimenting with\nsplicing [1]. Splicing is a complex feature with a large design space.\nIt was interesting to iterate on two separate implementations (eclair\nand cln) and discover the pain points, edge cases and things that could\nbe improved in the protocol specification.\n\nAfter a few months trying out different approaches, we'd like to share\nchanges that we believe make the splicing protocol simpler and more\nrobust.\n\nWe call \"active commitments\" the set of valid commitment transactions to\nwhich updates must be applied. While one (or more) splices are ongoing,\nthere is more than one active commitment. When signing updates, we send\none `commitment_signed` message per active commitment. We send those\nmessages in the order in which the corresponding funding transactions\nhave been created, which lets the receiver implicitly match every\n`commitment_signed` to their respective funding transaction.\n\nOnce we've negotiated a new splice and reached the signing steps of the\ninteractive-tx protocol, we send a single `commitment_signed` for that\nnew commitment. We don't revoke the previous commitment(s), as this adds\nan unnecessary step. Conceptually, we're simply adding a new commitment\nto our active commitments set.\n\nA sample flow will look like this:\n\n   Alice                           Bob\n     |             stfu             |\n     |----------------------------->|\n     |             stfu             |\n     |<-----------------------------|\n     |          splice_init         |\n     |----------------------------->|\n     |          splice_ack          |\n     |<-----------------------------|\n     |                              |\n     |       <interactive-tx>       |\n     |<---------------------------->|\n     |                              |\n     |         tx_complete          |\n     |----------------------------->|\n     |         tx_complete          |\n     |<-----------------------------|\n     |         commit_sig           | Sign the new commitment.\n     |----------------------------->|\n     |         commit_sig           | Sign the new commitment.\n     |<-----------------------------|\n     |        tx_signatures         |\n     |----------------------------->|\n     |        tx_signatures         |\n     |<-----------------------------|\n     |                              |\n     |       update_add_htlc        | Alice and Bob use the channel while\nthe splice transaction is unconfirmed.\n     |----------------------------->|\n     |       update_add_htlc        |\n     |----------------------------->|\n     |         commit_sig           | Sign the old commitment.\n     |----------------------------->|\n     |         commit_sig           | Sign the new commitment.\n     |----------------------------->|\n     |       revoke_and_ack         |\n     |<-----------------------------|\n     |         commit_sig           | Sign the old commitment.\n     |<-----------------------------|\n     |         commit_sig           | Sign the new commitment.\n     |<-----------------------------|\n     |       revoke_and_ack         |\n     |----------------------------->|\n     |                              |\n     |        splice_locked         | The splice transaction confirms.\n     |----------------------------->|\n     |        splice_locked         |\n     |<-----------------------------|\n     |                              |\n     |       update_add_htlc        | Alice and Bob can use the channel and\nforget the old commitment.\n     |----------------------------->|\n     |         commit_sig           | Sign the new commitment.\n     |----------------------------->|\n     |       revoke_and_ack         |\n     |<-----------------------------|\n     |         commit_sig           | Sign the new commitment.\n     |<-----------------------------|\n     |       revoke_and_ack         |\n     |----------------------------->|\n     |                              |\n\nYou can find many more details and sample flows in [2].\n\nWe require nodes to store data about the funding transaction as soon as\nthey send their `commitment_signed` message. This lets us handle every\ndisconnection scenario safely, allowing us to either resume the signing\nsteps on reconnection or forget the funding attempt. This is important\nbecause if peers disagree on the set of active commitments, this will\nlead to a force-close. In order to achieve that, we only need to add\nthe `next_funding_txid` to the `channel_reestablish` message, and fill\nit when we're missing signatures from our peer. Again, you can find more\ndetails and sample flows in [2].\n\nFinally, after trying various approaches, we believe that the funding\namounts that peer exchange in `splice_init` and `splice_ack` should be\nrelative amounts based on each peer's current channel balance.\n\nIf Alice sends `funding_amount = 200_000 sats`, it means she will be\nadding 200 000 sats to the channel's capacity (splice-in).\n\nIf she sends `funding_amount = -50_000 sats`, it means she will be\nremoving 50 000 sats from the channel's capacity (splice-out).\n\nThis makes it easier to compute the new channel balances (otherwise we\nhave to deal with millisatoshi to satoshi truncation) and better matches\nthe UX that node operators are expecting, which means there is less need\nto glue code between the RPC exposed to the node operator and the actual\nunderlying protocol.\n\nWe've also discovered that implementing 0-conf splicing is tricky: you\nneed to be very careful about scenarios where your peer force-closes\nusing an *inactive* commitment that ends up double-spending what you\nthink is the only *active* commitment but is unconfirmed. We'd be happy\nto discuss that in more details with other implementers to reduce the\nrisk of introducing new vulnerabilities when shipping that feature.\n\nCheers,\nBastien\n\n[1] https://github.com/lightning/bolts/pull/863\n[2] https://gist.github.com/t-bast/1ac31f4e27734a10c5b9847d06db8d86\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230331/9188b5fb/attachment.html>", "summary": "The Lightning Network team has shared changes to simplify and improve the splicing protocol, including the use of \"active commitments\" and sending one `commitment_signed` message per active commitment."}], "thread_summary": {"title": "Proposed changes to the splicing specification", "categories": ["Lightning-dev"], "authors": ["Bastien TEINTURIER"], "messages_count": 1, "total_messages_chars_count": 6124}}]