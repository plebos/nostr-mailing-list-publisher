[
    {
        "title": "[Lightning-dev] Better privacy with SNARKs",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-11-17T21:14:36",
                "message_text_only": "Hi all,\n\nAn obvious privacy limitation with lightning is that even with onion\nrouting, differents hops can be associated as being part of the same\ntransaction due to sharing a common R value. So if you see a HTLC from\nAlice to Bob, paying $5 to Bob on receipt of R where SHA(R)=12345..;\nand you see another HTLC from Carol to Dave, paying $4.95 to Bob on\nreceipt of R under the same condition, SHA(R)=12345..., then you know\nit's part of the same transaction.\n\nIf you could change R at each step in the route, this would go away,\nimproving payment anonymity and making it harder to attack the system in\ngeneral.\n\nThat's hard, because as a forwarding node, if you receive a HTLC payable\non R1, then to send a HTLC payable on R2, you need to be able to\ncalculate R1 from R2 or you'll be out of pocket. But you also can't be\nable to calculate R1 *without* R2, or you could just rip off whoever's\nmaking the payment. And, of course you have to know SHA(R2) to forward the\npayment at all. And if you only know SHA(R1) and SHA(R2) it's hard to\nsay anything at all about R1 and R2 because cryptographic hash functions\nare designed to make any structural relationships go away.\n\nBUT! I think the magic of SNARKs [0] lets you do this!\n\nWith a SNARK, you can \"prove\" that you have some secrets (ie, R1 and R2)\nthat satisfy some programmable condition (ie, SHA(R1)=H1 and SHA(R2)=H2\nand R1=R2 XOR X), based on public inputs (H1, H2 and X), without revealing\nthose secrets.\n\nI think that's pretty safe, because if you receive an HTLC asking for a\npreimage for H1, along with instructions in the onion saying ask Bob for\na preimage for H2, and here's X and a proof, then either:\n\n - your forwarded HTLC will fail, and everything's fine\n\n - you'll receive R2, calculate R1=R2 XOR X and see SHA(R1)=H1 as\n   expected, and everything's fine\n\n - you'll receive R2, calculate R1=R2 XOR X and see SHA(R1) != H1,\n   which is only possible if the cryptography behind SNARKs are broken\n\n - you'll receive RX, such that H2=SHA(RX) but RX being too\n   long or too short. If SNARKs aren't broken, this means that you know\n   R2alt and someone else knows R2 that are different but hash to the\n   same value, meaning SHA has been broken.\n\nIt seems like there are research-level tools out there that actually\nmake this practical to try out. I've had a go at implementing this using\nsnarkfront [1]. Using it looks like:\n\n1) initial setup of proof/verification keys\n\n $ ./test_lightning -m keygen > keygen.txt  # global setup\n\n2) generate a proof, using a 32 byte secret, and XOR key (64 hex digits)\n\n $ SECRET=\"the quick brown fox jumps lazily\"\n $ XOR=$(echo \"she sells sea shells\" | sha256sum | head -c64)\n $ cat keygen.txt |\n     ./test_lightning -m proof -s \"$SECRET\" -x \"$XOR\" > proof.txt\n   m: proof.\n   f: .\n   b: .\n   x: 5677d356ccd6ff29b296a697791d109a1703557ecbbcf52b4f38d4b680858912.\n   F: 74686520717569636b2062726f776e20666f78206a756d7073206c617a696c79\n   B: 221fb676bda3964ad9b6c4e5166a7eba716c2d5ea1c9985b3c18b8d7faece56b\n   #F: ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85\n   #B: 166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245\n   generate proof\n   (6) ..................................................\n   (5) ..................................................\n   (4) ..................................................\n   (3) ..................................................\n   (2) ..................................................\n   (1) ..................................................\n\n3) Verify the proof:\n\n $ F=ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85\n $ B=166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245\n $ cat keygen.txt proof.txt |\n     ./test_lightning -m verify -h \"$F\" -b \"$B\" -x \"$XOR\"\n   m: verify.\n   f: ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85.\n   b: 166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245.\n   x: 5677d356ccd6ff29b296a697791d109a1703557ecbbcf52b4f38d4b680858912.\n   verify proof (6) (5) (4) (3) (2) (1) \n   proof is verified\n\n4) Verify it doesn't report a valid proof with different inputs:\n\n  $ cat keygen.txt proof.txt |\n     ./test_lightning -m verify -h \"$B\" -b \"$F\" -x \"$XOR\"\n   m: verify.\n   f: 166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245.\n   b: ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85.\n   x: 5677d356ccd6ff29b296a697791d109a1703557ecbbcf52b4f38d4b680858912.\n   verify proof (6) (5) (4) (3) (2)\n   proof is rejected\n\nSome results:\n\n * the proof/verification key data take up about 100MB -- in theory\n   one set of this data can be used by everyone; the only catch is\n   that everyone has to trust that nobody has kept the original random\n   numbers used to generate it.\n\n * proof/verification key data takes about a minute to generate,\n   and about 650MB of RAM.\n\n * the proof data itself (which would need to be sent to the node that's\n   going to switch R's) is just 864 bytes; so it'd use up about 5 hops\n   worth of onion routing at 192B per hop -- in a 4096 byte packet eg,\n   you could have four hops, changing R each time; or you could have 9\n   hops, changing R only three times.\n\n * generating the proof data for a given R1,X pair takes about 10\n   seconds, and 260MB of RAM\n\n * verifying the proof is quick-ish -- it takes 0.5s on my laptop,\n   and uses about 150MB of RAM.\n\nFor comparison, that last point makes a SNARK verification 500+ times\nmore expensive than an ECDH operation. If I got my maths right, you\ncan translate 3c for a linode CPU-hour into 2.5 satoshi for a linode\nCPU-second (at $338/BTC), so you're probably looking at a minimum fee\nof a few satoshi per SNARK verification, but that's still pretty okay\nfor transactions of 500 satoshi or more, ie anything more than about a\nfifth of a US cent.\n\nThe 10s proof generation time is probably more of a limitation -- though\nyou could generate them in advance easily enough and just store them until\nyou need to use them, which would avoid lag being a problem at least. But\neven then it's still essentially adding up to 30c of additional costs to\nyour transaction (ie 10s cpu time valued at up to 3c/s), which probably\nisn't worthwhile for transactions smaller than a dollar or two.\n\nA drawback is that you'd either (a) have to do all this on the merchant's\nside (not just sending SHA(R) to whoever wants to pay you, but sending\nSHA(R1), SHA(R2), SHA(R3), SHA(R4), X12, X23, X34, and three proofs,\nwhich would be pretty painful; or (b) you'd have to generate all the\nR secrets as a consumer, and you wouldn't get to use the fact that you\nknow R as evidence that you paid the merchant.\n\nAnyway, it's obviously not ready for prime time today: SNARKs are still\npretty new as a concept; I'm definitely not familiar enough with SNARK\ntheory to be sure I'm not misusing the concept somehow; snarkfront may not\nhave implemented the theory fully correctly; and I might not have captured\neverything I needed to in order for my \"proof\" to actually say what I\nwant it to. So not a great idea to use this to protect real money today.\n\nBut still, this seems like it's not all /that/ far from being practical,\nand if the crypto's not fundamentally broken, seems like it goes a long\nway to filling in the biggest privacy hole in lightning today [3]...\n\nCode is at https://github.com/ajtowns/snarkfront/ or more directly at:\nhttps://github.com/ajtowns/snarkfront/blob/lightning-sha/test_lightning.cpp\n\nCheers,\naj\n\n[0] https://tahoe-lafs.org/trac/tahoe-lafs/wiki/SNARKs\n\n[1] https://github.com/jancarlsson/snarkfront\n\n[2] This would also improve privacy/anonymity for other applications of\n    HTLCs, such as atomic swaps across chains:\n\n     1 bitcoin, payable on R1 + Alice's sig or timeout + Bob's sig\n     100 litecoin, payable on R2 + Robert's sig or timeout + Ally's sig\n\n    Alice and Bob communicate privately, agreeing to trade 1 BTC for 100\n    litecoin and revealing their aliases Robert and Ally; Alice generates\n    R1, R2, and reveals SHA(R1), SHA(R2), R1^R2 and the SNARK proof and\n    publishes the litecoin payment. Bob verifies the proof, and publishes\n    the bitcoin payment. Alice claims the bitcoin payment, revealing R1;\n    Bob calculates R2 and claims the litecoin payment. The swap can take\n    place trustlessly because Bob knows the only way Alice can claim his\n    bitcoin is by revealing enough info so he can claim the corresponding\n    litecoin. But there isn't any on-chain information linking the two\n    transactions, because R1 and R2 are independent (and could even be\n    using different hash functions as well as different preimages).\n    After the funds have been claimed, the private communication is\n    also completely deniable, since anyone could generate R1^R2 and a\n    corresponding SNARK proof just using the info on the blockchain."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-11-19T13:16:57",
                "message_text_only": "Interesting, thanks for the write-up Anthony!\n\nIndeed, if we can somehow prove that R1 = R2 XOR X without revealing\nR1 or R2, we can switch R in between the routing an arbitrary amount\nof time. This would solve the last obvious privacy attack vector that\nwe have currently.\n\nI feel like the way ZKPs are constructed, one has to be absolutely\ncertain everything is perfectly implemented to actually work out the\nway we want it.\n\n> A drawback is that you'd either (a) have to do all this on the merchant's\n> side (not just sending SHA(R) to whoever wants to pay you, but sending\n> SHA(R1), SHA(R2), SHA(R3), SHA(R4), X12, X23, X34, and three proofs,\n> which would be pretty painful; or (b) you'd have to generate all the\n> R secrets as a consumer, and you wouldn't get to use the fact that you\n> know R as evidence that you paid the merchant.\n\nI don't think (a) would be too much of a problem. I am playing around\nwith the idea of having a messaging system over the same route as the\nactual payment. The data that needs to be communicated over regular\nchannels (QR, ...) would be limited to a rendezvous node and the\nencrypted route from that node to the receiver. The sender can contact\nthe receiver over that route and include the encrypted route back for\nfurther communications.\n\nI also think that - given how young SNARKs still are - efficiency will\nfurther be improved. Especially generation and verification of the\nproof, such that it is no longer a major cost factor.\n\n---------------\n\nAfter a night of sleep and some reassurance with sipa, I thought about\nsomething similar but with EC keys, that will allow us to do the same,\nbut without SNARKS.\n\nIf we would switch from preimage-hash verification to\nprivatekey-publickey, we can use the arithmetic operations inherited\nfrom the elliptic curve field.\n\nAssume two keypairs, K1(Q, q) and K2(R, r). Further we have a scalar\np, such that\n\nr = p * q\n\nand\n\nR = r * G = ( p * q ) * G = p * ( q * G ) = p * Q.\n\nYou can therefore give someone Q, R and p and he is able to verify\nthat above conditions indeed holds true. For a sufficiently large p it\nis not possible to derive that relationship within reasonable time\nwithout p. If he ever gets to know q, he is able to directly compute r\nas well.\n\nSo instead of making a payment towards a hash, we make a payment\ntowards a public key. If we ever get to know the private key, the\npayment is deemed settled.\n\nThis will allow for following construction:\n\n(1) Bob calculates a key pair he wants to receive a payment on\n(2) Bob will give the public key Q to Alice\n(3) Alice calculates a route, consisting of 10 hops\n(4) Alice chooses x random large numbers N_x and calculates x public\nkeys, such that\n\nQ_y = Q * N_x * N_x-1 * ... * N_y.\n\n(5) Alice constructs an onion object and includes Q_y together with N_y\n\nEach hop is able to translate the public key towards the corresponding\nkey for the next relay node, only Alice, with the knowledge of the set\nN is able to relate the payment though.\n\nThere is one caveat. We are currently unable to enforce a payment with\na priv/pub key pair. We would need a new operator\nOP_CHECKPRIVPUBKEYPAIR or similar that pops two items from the stack\n\n<Private Key> <Public Key>\n\nand replaces them with true/false. It could also be constructed in a\nsoftfork-manner, where the stack is not touched and it only fails in\ncase the key pair is not correct.\n\nRevealing the private key has the same effect as revealing a preimage.\n\nCheers\nMats"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-20T01:35:46",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> After a night of sleep and some reassurance with sipa, I thought about\n> something similar but with EC keys, that will allow us to do the same,\n> but without SNARKS.\n\nNice job!  I've been saying there might be a way using keypairs, but I'm\njust not this clever :)\n\nEven then, it took me several reads to make sure I understood your post\n:)\n\n> If we would switch from preimage-hash verification to\n> privatekey-publickey, we can use the arithmetic operations inherited\n> from the elliptic curve field.\n>\n> Assume two keypairs, K1(Q, q) and K2(R, r). Further we have a scalar\n> p, such that\n>\n> r = p * q\n\nYes, the two private keys are related by p...\n\n> and\n>\n> R = r * G = ( p * q ) * G = p * ( q * G ) = p * Q.\n\n...And if the two public keys are related by p, we know it's true.  Thus\nwe know revealing their privkey will give us our privkey.\n\n> There is one caveat. We are currently unable to enforce a payment with\n> a priv/pub key pair. We would need a new operator\n> OP_CHECKPRIVPUBKEYPAIR or similar that pops two items from the stack\n\nOr we could do an OP_FFMUL to do multiply over a finite field and check\nthe result, too:\n\n        <G> OP_FFMUL <PUBKEY> OP_EQUAL\n\nWith the segregated witness proposal, introducing new opcodes is easy,\nso maybe someone would find a reason to prefer open-coding it like this?\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-20T07:44:15",
                "message_text_only": "On Thu, Nov 19, 2015 at 01:16:57PM +0000, Mats Jerratsch wrote:\n> Interesting, thanks for the write-up Anthony!\n\nGlad I went ahead and implemented it as a snark before posting the idea\nor you would have spoiled all the fun I had playing with snarkfront!\n\n> I feel like the way ZKPs are constructed, one has to be absolutely\n> certain everything is perfectly implemented to actually work out the\n> way we want it.\n\nYeah. I think you could have a \"stop-loss\" condition, where any node that\ngets cheated (ie, they have a proof that R2 gives them and R1 for H1,H2,X;\nbut they have an R2 that doesn't give them R1) can just publish all that\nevidence, and everyone can immediately stop trusting snarks and so only\na small amount of money can actually be stolen from the system. But, yeah.\n\n> ---------------\n> After a night of sleep and some reassurance with sipa, I thought about\n> something similar but with EC keys, that will allow us to do the same,\n> but without SNARKS.\n\nSo this is genius! And I swear I would have thought of it myself if\nI could just get past my mental block on adding opcodes to bitcoin.\nHonest, guv!\n\n> Assume two keypairs, K1(Q, q) and K2(R, r). Further we have a scalar\n> p, such that\n> r = p * q\n> and\n> R = r * G = ( p * q ) * G = p * ( q * G ) = p * Q.\n> You can therefore give someone Q, R and p and he is able to verify\n> that above conditions indeed holds true. For a sufficiently large p it\n> is not possible to derive that relationship within reasonable time\n> without p. If he ever gets to know q, he is able to directly compute r\n> as well.\n\nEven better, given K1(Q,q) (q the public key provided by the merchant,\nQ the merchant's secret, used to claim the payment and serving as a\nreceipt), you (as the consumer) can construct r2, .., rN by generating\nrandom bits, and then generate\n\n  q1 = q\n  q2 = r2*q1\n  q3 = r3*q2\n  ...\n  qN = rN*q[N-1]\n\nand route your HTLC payable to qN at the first hop, q[N-1] at the second\nall the way to q1 when it gets to the merchant. The merchant reveals\nQ=Q1, and nodes calculate:\n\n  Q2 = r2*Q1\n  Q3 = r3*Q2\n  ...\n  QN = rN*Q[N-1]\n\nto collect their payments. So the extra burden for keeping the payment\nprivate falls entirely on the consumer, rather than the merchant. (Okay,\nyou had this point in your mail already essentially)\n\nHmm, I'm not sure if you can divide QN by (r2*..*rN) to get back to Q1,\nbut I think you can (the lowercase q's are the points on the elliptic\ncurve where division is hard, but the capital Q's are just numbers\nin Z_n where n is the order of G on the curve, I think?). If you can,\nyou even get the original receipt/proof of payment!\n\nOh, _and_ you don't even having to reveal q1/Q to any intermediate hops\n-- you could just pay to q[N-1] on the final hop and provide rN in the\nonion message on the final hop. If you do that, nobody but the merchant\nand the end consumer can calculate the proof of payment.\n\n_And_ I think you could just use SHA(ECDH_SEC || 3) as the r values at\neach stage rather than needing any additional entropy, or having to add\nany significant data to the onion packets.\n\n> There is one caveat. We are currently unable to enforce a payment with\n> a priv/pub key pair. We would need a new operator\n> OP_CHECKPRIVPUBKEYPAIR or similar that pops two items from the stack\n> <Private Key> <Public Key>\n> and replaces them with true/false.\n\nThere are a few \"generic\" crypto ops that might be useful to have; two\nthat come to mind are:\n\n  <point> <multiplicand> <resultpoint> OP_CHECK_SECP256K1_MUL_VERIFY\n    (enough for this, maybe lets you do ECDH on the blockchain,\n     and allows you to commit to revealing a key on the blockchain)\n\n  <signature> <pubkey> <message> OP_CHECK_INLINE_SIGNATURE_VERIFY\n    (this would let you do atomic cross-chain swaps without knowing in\n     advance who you're swapping with)\n\nMaybe it'd make sense to combine them into a soft-forkable OP_CRYPTO_OP\nthat pulls the crypto operation id from the stack, then if the operation\nis known, pulls the operands, and fails the script if the operands\ndon't add up. If the operation is unknown, mark it as non-standard but\nacceptable for future soft-forkability...\n\nOn Fri, Nov 20, 2015 at 12:05:46PM +1030, Rusty Russell wrote:\n> With the segregated witness proposal, introducing new opcodes is easy,\n> so maybe someone would find a reason to prefer open-coding it like this?\n\nI don't follow how segregated witness makes new opcodes any easier?\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-22T02:13:27",
                "message_text_only": "On Fri, Nov 20, 2015 at 05:44:15PM +1000, Anthony Towns wrote:\n> Hmm, I'm not sure if you can divide QN by (r2*..*rN) to get back to Q1,\n> but I think you can [...] If you can,\n> you even get the original receipt/proof of payment!\n\nYep, this works!\n\n> _And_ I think you could just use SHA(ECDH_SEC || 3) as the r values at\n> each stage rather than needing any additional entropy, or having to add\n> any significant data to the onion packets.\n\nThis doesn't quite, though: if a txn routes from Alice through Bob to\nCarol, with Alice/Bob's secret being p,P and Bob/Carol's being q,Q,\nwith p = q*r and P = Q*r; Alice has to pass on both p and q; p as part\nof the HTLC contract, and q inside the onion payload because calculating\nq=p/r is infeasible unless elliptic curve crypto is broken.\n\nSo add an extra 32B of payload to each onion hop if calculating r from\nthe ECDH secret is fine, or 64B of payload if it's not.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-24T03:30:19",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Nov 20, 2015 at 12:05:46PM +1030, Rusty Russell wrote:\n>> With the segregated witness proposal, introducing new opcodes is easy,\n>> so maybe someone would find a reason to prefer open-coding it like this?\n>\n> I don't follow how segregated witness makes new opcodes any easier?\n\nI didn't either, and that's because it's slightly orthogonal.\n\nThe proposal I heard is that the first byte of SW script is a version\nbyte, and if you don't understand that version, the script succeeds.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-24T05:45:43",
                "message_text_only": "On 24 November 2015 1:30:19 pm AEST, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>Anthony Towns <aj at erisian.com.au> writes:\n>> On Fri, Nov 20, 2015 at 12:05:46PM +1030, Rusty Russell wrote:\n>>> With the segregated witness proposal, introducing new opcodes is\n>easy,\n>>> so maybe someone would find a reason to prefer open-coding it like\n>this?\n>>\n>> I don't follow how segregated witness makes new opcodes any easier?\n>\n>I didn't either, and that's because it's slightly orthogonal.\n>\n>The proposal I heard is that the first byte of SW script is a version\n>byte, and if you don't understand that version, the script succeeds.\n\nAh, I see - it doesn't make OP_CHECK*VERIFY any easier then, but adding ops that actually change the contents of the stack becomes a soft fork instead of a hard fork. Pretty neat. Don't think that's needed here though.\n\nCheers,\naj\n\n\n-- \nSent from my phone."
            },
            {
                "author": "Andrew Miller",
                "date": "2015-11-24T13:31:37",
                "message_text_only": "Even though it seems like SNARKs aren't strictly necessary for this\napplication, it's awesome you tried that out!\n\nSo, there are a couple of things that seem off to me about those\nperformance estimates. I don't know snarklib/snarkfront well so I'm not\nsure what would cause this.\nBut checking a single snark proof should take around 10 milliseconds rather\nthan 500 milliseconds. And it should only require like a kilobyte of memory\nto verify, definitely not 150 MB.\nAlso when you say that the verification/proving key is 100MB, those are two\nvery different keys! The verification key should be extremely small, in the\nkilobyte range.\n\nWhen I have some time (hopefully later this week) I'll try to reproduce\nthis experiment using libsnark and write back in this thread. Some students\nat UMD also have a tool for composing circuits that is (arguably) more\nuser-friendly and complements libsnark, I'm really hoping they release\nthose open source soon!\n\nOn Tue, Nov 24, 2015 at 12:45 AM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On 24 November 2015 1:30:19 pm AEST, Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n> >Anthony Towns <aj at erisian.com.au> writes:\n> >> On Fri, Nov 20, 2015 at 12:05:46PM +1030, Rusty Russell wrote:\n> >>> With the segregated witness proposal, introducing new opcodes is\n> >easy,\n> >>> so maybe someone would find a reason to prefer open-coding it like\n> >this?\n> >>\n> >> I don't follow how segregated witness makes new opcodes any easier?\n> >\n> >I didn't either, and that's because it's slightly orthogonal.\n> >\n> >The proposal I heard is that the first byte of SW script is a version\n> >byte, and if you don't understand that version, the script succeeds.\n>\n> Ah, I see - it doesn't make OP_CHECK*VERIFY any easier then, but adding\n> ops that actually change the contents of the stack becomes a soft fork\n> instead of a hard fork. Pretty neat. Don't think that's needed here though.\n>\n> Cheers,\n> aj\n>\n>\n> --\n> Sent from my phone.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151124/35b6db51/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-26T11:15:16",
                "message_text_only": "On Fri, Nov 20, 2015 at 05:44:15PM +1000, Anthony Towns wrote:\n> > After a night of sleep and some reassurance with sipa, I thought about\n> > something similar but with EC keys, that will allow us to do the same,\n> > but without SNARKS.\n> So this is genius! And I swear I would have thought of it myself if\n> I could just get past my mental block on adding opcodes to bitcoin.\n> Honest, guv!\n\nAnd wow, it looks like you can do it without adding opcodes to bitcoin.\n\nTwo approaches to forcing someone to reveal the private key corresponding\nto secp256k1 public key P. Number one, which Greg Maxwell came up with:\n\n  OP_SIZE 57 OP_LESSTHANOREQUAL OP_VERIFY <P> OP_CHECKSIGVERIFY\n\nTo satisfy this script, you have to generate a signature with P, that\nproduces <r> and <s> parameters for the signature that have a combined\ntotal of 15 leading zero bytes (or more). There is a known <r> value with\n11 leading zero bytes though: g^(1/2), so you need to brute force about\n2**32=4B <s> parameters to get a valid signature, and that's just modifing\nthe transaction, hashing it, and doing modular arithmetic ops.  It might\nmean paying for a few seconds use of dedicated mining hardware though.\n\nUsing that <r> value reveals the secret key p: p = (2s - h)/r (mod O(g)).\n\nIf you want to cheat, you can brute force a secret key N with\ncorresponding public key r with as many leading zero bytes as possible.\nGreg Maxwell thinks grinding r values at a rate 0.08 microseconds per\ntry is practical, so that's ~10e6/second. Doing that on 2000 8-core\nmachines for abut a week gets you an r-value with 7 leading 0-bytes.\nGetting 8 leading 0-bytes might take 20k machines and four months.\n\nWith 7 leading zeroes in r, you still need 8 leading zeroes in s, which\nwould require about 213,000 GH/s worth of mining hardware running for 24\nhours to achieve. With 8 leading zeroes in r, you'd only need 7 leading\nzeroes in s, which you could get in 1 hour with 20GH/s of mining hardware.\n\n\n\nThe alternative approach, which andytoshi and I came up with\nindependently is a lot more complicated:\n\n  revealP( Q, R, sigA, sigB, sigC ) {\n    check_multisig_verify(2, P, R, 2, sigA, sigB); code_separtor();\n    check_multisig_verify(2, Q, R, 2, sigA, sigC); code_separtor();\n    check_multisig_verify(2, P, Q, 2, sigC, sigB);\n  }\n\nIf sigA, sigB and sigC all share the same r and SIGHASH settings, coming\nup with secret keys Q' and R' is straightforward (Q'=P'-(h2-h1)/r,\nR'=P'-(h2-h3)/r, where h1, h2 and h3 are the transaction hashes for\nthe various steps), and you have two valid sigs by key P with the same\nr value, letting you calculate P'. If you don't use the same r value,\nor use different sighash types between the signatures, coming up with\nvalid keys and sigs seems to require doing discrete logs on the elliptic\ncurve, so should be intractable. (In particular, I don't think throwing\nlots of hashpower at the problem helps at all)\n\nBut if you have to drop the transaction to the blockchain, it's six\nsigops, which combined with the two other signatures an HTLC needs to\nbe usable (one for A on timeout, one for B on success), means a total\nof 8 sigops per output, which is about equivalent to 400B per output\ngiven the relationship between the bytes-per-block and sigops-per-block\nlimits. Yikes. Translating from pseudocode into script is a little\nhard too.\n\n\n> > Assume two keypairs, K1(Q, q) and K2(R, r). Further we have a scalar\n> > p, such that\n> > r = p * q\n> > and\n> > R = r * G = ( p * q ) * G = p * ( q * G ) = p * Q.\n\nGreg Maxwell also pointed out you can also do this faster while still\nbeing secure; assuming Q was the public key from the incoming HTLC, and P\nis the public key you'll use for the outgoing HTLC, and r is your secret:\n\n p = q + r\n P = (q+r)*G = q*G + r*G = Q + r*G\n\nGiven Q is already known, calculating P just requires multiplying the\nbase point and an addition, which is quicker than multiplying an arbitrary\npoint. And once you find out p, calculating q=p-r is obviously easy.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-27T03:55:09",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Nov 20, 2015 at 05:44:15PM +1000, Anthony Towns wrote:\n>> > After a night of sleep and some reassurance with sipa, I thought about\n>> > something similar but with EC keys, that will allow us to do the same,\n>> > but without SNARKS.\n>> So this is genius! And I swear I would have thought of it myself if\n>> I could just get past my mental block on adding opcodes to bitcoin.\n>> Honest, guv!\n>\n> And wow, it looks like you can do it without adding opcodes to bitcoin.\n>\n> Two approaches to forcing someone to reveal the private key corresponding\n> to secp256k1 public key P. Number one, which Greg Maxwell came up with:\n>\n>   OP_SIZE 57 OP_LESSTHANOREQUAL OP_VERIFY <P> OP_CHECKSIGVERIFY\n>\n> To satisfy this script, you have to generate a signature with P, that\n> produces <r> and <s> parameters for the signature that have a combined\n> total of 15 leading zero bytes (or more). There is a known <r> value with\n> 11 leading zero bytes though: g^(1/2), so you need to brute force about\n> 2**32=4B <s> parameters to get a valid signature, and that's just modifing\n> the transaction, hashing it, and doing modular arithmetic ops.  It might\n> mean paying for a few seconds use of dedicated mining hardware though.\n>\n> Using that <r> value reveals the secret key p: p = (2s - h)/r (mod O(g)).\n>\n> If you want to cheat, you can brute force a secret key N with\n> corresponding public key r with as many leading zero bytes as possible.\n> Greg Maxwell thinks grinding r values at a rate 0.08 microseconds per\n> try is practical, so that's ~10e6/second. Doing that on 2000 8-core\n> machines for abut a week gets you an r-value with 7 leading 0-bytes.\n> Getting 8 leading 0-bytes might take 20k machines and four months.\n>\n> With 7 leading zeroes in r, you still need 8 leading zeroes in s, which\n> would require about 213,000 GH/s worth of mining hardware running for 24\n> hours to achieve. With 8 leading zeroes in r, you'd only need 7 leading\n> zeroes in s, which you could get in 1 hour with 20GH/s of mining hardware.\n\nYes, this is very clever.  But since it's slow, insecure or both, I\ndon't think we should go for it.\n\n> The alternative approach, which andytoshi and I came up with\n> independently is a lot more complicated:\n>\n>   revealP( Q, R, sigA, sigB, sigC ) {\n>     check_multisig_verify(2, P, R, 2, sigA, sigB); code_separtor();\n>     check_multisig_verify(2, Q, R, 2, sigA, sigC); code_separtor();\n>     check_multisig_verify(2, P, Q, 2, sigC, sigB);\n>   }\n>\n> If sigA, sigB and sigC all share the same r and SIGHASH settings,\n\nI don't think this works?  We can't provide the signatures in the\nscriptPubkey, since that requires them signing themselves.  We can't\nhave them provide it in the scriptSig, since theres no \"do these have\nthe same r value\" operator in script.  All those ops got disabled :(\n\n>> > Assume two keypairs, K1(Q, q) and K2(R, r). Further we have a scalar\n>> > p, such that\n>> > r = p * q\n>> > and\n>> > R = r * G = ( p * q ) * G = p * ( q * G ) = p * Q.\n>\n> Greg Maxwell also pointed out you can also do this faster while still\n> being secure; assuming Q was the public key from the incoming HTLC, and P\n> is the public key you'll use for the outgoing HTLC, and r is your secret:\n>\n>  p = q + r\n>  P = (q+r)*G = q*G + r*G = Q + r*G\n>\n> Given Q is already known, calculating P just requires multiplying the\n> base point and an addition, which is quicker than multiplying an arbitrary\n> point. And once you find out p, calculating q=p-r is obviously easy.\n\nYes, this is a nice optimization.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T04:42:19",
                "message_text_only": "On Fri, Nov 27, 2015 at 02:25:09PM +1030, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> > The alternative approach, which andytoshi and I came up with\n> > independently is a lot more complicated:\n> >   revealP( Q, R, sigA, sigB, sigC ) {\n> >     check_multisig_verify(2, P, R, 2, sigA, sigB); code_separtor();\n> >     check_multisig_verify(2, Q, R, 2, sigA, sigC); code_separtor();\n> >     check_multisig_verify(2, P, Q, 2, sigC, sigB);\n> >   }\n> > If sigA, sigB and sigC all share the same r and SIGHASH settings,\n> I don't think this works?  We can't provide the signatures in the\n> scriptPubkey, since that requires them signing themselves.  \n\nThe scriptPubkey has the pubkey P, and a whole mess of stack operations\nto implement the function above; the scriptSig just has Q, R and the\nthree signatures.\n\n> We can't\n> have them provide it in the scriptSig, since theres no \"do these have\n> the same r value\" operator in script.\n\nThere's six sig ops, but only three different signatures. Getting the\nvarious combinations to have the same signature forces the same r value\nbetween each of the signatures, without needing a separate op to check\nit explicitly.\n\nIt's mathematically possible to come up with Q, R, sigA, sigB, sigC where\nsigA.r, sigB.r and sigC.r are all different; but it requires being able\nto come up with a transaction with a particular hash, or calculating the\ndiscrete log of a weird value to do so, so should be safely intractable.\n\nCheers,\naj"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-11-27T14:44:19",
                "message_text_only": "I love how people come up with sneaky solutions to force the other\nparty to reveal the private key somehow. But given that we might have\ndozens of HTLCs in a commit transactions or also payments that pay to\ntwo (or more) payment keys (is this the new term for it now?) we\nshould maybe strive for a more clean solution.\n\nI have summarized most of the information of this discussion and\n'handed in' a BIP request to the bitcoin-dev mailing list. If the use\ncase is good enough (and I think it is) and there are little draw\nbacks (can't think of any security-relevant one), there should not be\ntoo much resistance.\n\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-November/011827.html\n\nCheers,\nMats\n\n2015-11-27 5:42 GMT+01:00 Anthony Towns <aj at erisian.com.au>:\n> On Fri, Nov 27, 2015 at 02:25:09PM +1030, Rusty Russell wrote:\n>> Anthony Towns <aj at erisian.com.au> writes:\n>> > The alternative approach, which andytoshi and I came up with\n>> > independently is a lot more complicated:\n>> >   revealP( Q, R, sigA, sigB, sigC ) {\n>> >     check_multisig_verify(2, P, R, 2, sigA, sigB); code_separtor();\n>> >     check_multisig_verify(2, Q, R, 2, sigA, sigC); code_separtor();\n>> >     check_multisig_verify(2, P, Q, 2, sigC, sigB);\n>> >   }\n>> > If sigA, sigB and sigC all share the same r and SIGHASH settings,\n>> I don't think this works?  We can't provide the signatures in the\n>> scriptPubkey, since that requires them signing themselves.\n>\n> The scriptPubkey has the pubkey P, and a whole mess of stack operations\n> to implement the function above; the scriptSig just has Q, R and the\n> three signatures.\n>\n>> We can't\n>> have them provide it in the scriptSig, since theres no \"do these have\n>> the same r value\" operator in script.\n>\n> There's six sig ops, but only three different signatures. Getting the\n> various combinations to have the same signature forces the same r value\n> between each of the signatures, without needing a separate op to check\n> it explicitly.\n>\n> It's mathematically possible to come up with Q, R, sigA, sigB, sigC where\n> sigA.r, sigB.r and sigC.r are all different; but it requires being able\n> to come up with a transaction with a particular hash, or calculating the\n> discrete log of a weird value to do so, so should be safely intractable.\n>\n> Cheers,\n> aj\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-30T00:07:59",
                "message_text_only": "On Thu, Nov 26, 2015 at 09:15:16PM +1000, Anthony Towns wrote:\n>   revealP( Q, R, sigA, sigB, sigC ) {\n>     check_multisig_verify(2, P, R, 2, sigA, sigB); code_separtor();\n>     check_multisig_verify(2, Q, R, 2, sigA, sigC); code_separtor();\n>     check_multisig_verify(2, P, Q, 2, sigC, sigB);\n>   }\n> Translating from pseudocode into script is a little hard too.\n\nI think:\n\n  2 5 ROLL 5 ROLL 2 <P> 5 ROLL\n  2 8 ROLL 6 PICK 2 5 PICK 11 ROLL\n  2 5 PICK 11 PICK 2 10 PICK 5 PICK\n  C_MSIG_V CODESEP C_MSIG_V CODESEP C_MSIG_V\n\nmight work (signing by providing sig_a, sig_b, sig_c, q_pub,\nr_pub). That's 34B of operators and 31B for P, for the redeem script,\nand 3*59B for signatures made using using N=g/2, 2*31B for Q and R,\nand 5B to push them on the stack, for a total of 65B redeem script and\n244B scriptsig. (There's no need to use N=g/2 in this scheme, but since\nyou're intending to reveal P/Q/R, there's no reason not to and it saves\na few bytes, so...)\n\nThat compares to: \"SHA256 <H> EQUALVERIFY\" giving a 35B redeem script,\nand a 33B scriptsig; so the privacy gain would be at a cost of an extra\n236B per HTLC per channel, when cleared on the blockchain.\n\nAt 40 satoshis per byte, the extra cost per HTLC is 9440 satoshi, which\nis about 3c per HTLC by my count.\n\nI think a minimal HTLC looks something like:\n\n IF_DUP IF 1SUB\n   IF SHA256 <revoke> EQUALVERIFY ELSE <reveal R> ENDIF <a_pub>\n ELSE\n   <t> CLTV <d> CSV <b_pub>\n ENDIF\n CHECKSIG\n\nfor the payer's commitment, spendable with:\n\n  <sigA> <revoke secret> 2\n  <sigA> <htlc preimage> 1\n  <sigB> 0\n\nThat's 19 opcodes, 2*33B pubkeys, 1*32B revoke hash, and however many bytes\nto reveal R. So another 117B, plus another 67B for the signature and\nbranch code. To spend an HTLC, you also need the other bits for a txin,\nwhich is 42 bytes:\n\n  42+117+67+35     = 261B  (sha256, refunding HTLC)\n  42+117+67+65     = 291B  (ecc, refunding HTLC)\n\n  42+117+67+35+33  = 294B  (sha256, claiming HTLC)\n  42+117+67+65+244 = 531B  (ecc, claiming HTLC)\n\nSo it's really only an overhead of ~80% when claiming, and ~11% when\nrefunding? So at $350/BTC, 40 satoshi per byte, that's 7.4c for an ECC\nclaim versus 4.1c for a SHA256 claim.\n\nI think you'd want to account for that as \"cost of closing a channel is\n4c (or 7c) times the number of simultaneous incoming HTLCs I'll accept,\nplus 4c times the number of simultaneous outgoing HTLCs I'll do\".\n\n(Trying to make sure every HTLC pays you at least 4c in fees isn't\nworkable if you want to support really small microtransactions, obviously)\n\nThat said, it still seems like you might be better off just forgetting\na 2c HTLC as far as the commitment tx goes, if it's going to cost you 4c\nto collect it. Account for it while the channel's open, sure, and update\nbalances when it goes through, but actually committing to it looks like\nit might be a net negative... (If you've got some subscription with a\nminer such that you don't pay per byte for your transactions, that would\nchange things too, I guess)\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Better privacy with SNARKs",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "Andrew Miller",
                "Mats Jerratsch"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 37375
        }
    },
    {
        "title": "[Lightning-dev] Lightning, the death of BIP62, and Segregated Witness",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-11-19T02:53:00",
                "message_text_only": "Hi all!\n\n        As you know, I designed a lightning variant which used only\nnon-experimental, in-planning BIPs[1].  One assumption was BIP62: in\nparticular, that anchor malleability wouldn't be an issue.  This was\nflawed; BIP62 will never be deployed.\n\n        There are several options from here:\n\n1) Ignore it.  Malleated txs are non-standard.\n2) Add a timeout to the anchor.  Limits the lifetime of the channel, and\n   still means if it does happen you have to wait for the timeout.\n3) Propose a reduced BIP62 which (say) only protects P2PKH, for a\n   specific transaction version.\n4) Take a leap of faith and assume Segregated Witness fixes all\n   malleability.\n\nI was debating between #1 and #3 for a while, but eventually settled on\n#4.  Here's why:\n\n1) While still pre-BIP, Pieter Wuille is working on a prototype now\n   (Luke Jr came up with a sanish way of softforking it in).\n2) Other parts of the lightning code (in particular, watching bitcoin\n   transactions) become significantly simpler if malleability is\n   ignored.\n3) It's the right thing for Bitcoin; all smart contract systems want\n   this.\n\nThis result is NOP for lightning in the short term; assuming SW is the\nsame as pretending malleability doesn't exist.  But if we need to add\nmalleability support later, it's going to be painful, since handling it\ncorrectly in all the places it's missing will be hard.\n\nCheers,\nRusty.\nPS.  Remember, every project has 3 major disasters.  Just wait until you\n     see the next two!\n\n[1] https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf"
            },
            {
                "author": "CJP",
                "date": "2015-11-19T08:13:08",
                "message_text_only": "Wow, that was unexpected.\n\nIs there a place where I can see the discussion that concluded in\nwithdrawing BIP62? The only thing I found with a quick search was this:\n\nhttps://github.com/bitcoin/bips/commit/916142e742b4256686c26b15a0bf943aea3f5ef9\n\nAll of BIP62's (including the only-new-transactions) are currently\nenforced\nas standardness rules, but it seems hard to push it further. Every new\ntype\nof complex transaction may require new extra rules, and some important\ntypes\nof malleability cannot be addressed by it (for example, a single\nparticipant\nin a multisig spend creating a new signature with a different nonce).\nIt seems wiser to pursue normalized txid or segregated witness-based\nsolutions, which do solve this problem more fundamentally.\n\nThe reasoning seems to assume that \"normalized txid or segregated\nwitness-based solutions\" will become available in the future. Aren't\nthese features harder to introduce (hard fork)? Is there a backup plan\nfor when these somehow don't get implemented? That could be e.g.\nun-withdrawing BIP62. If miners / pool operators see value in reducing\ntx malleability, I don't see how the core developers could stop such a\nmovement.\n\nBIP62 may not solve all cases (and is, in that sense, inferior to more\nfundamental solutions), but from what I can see, it was already good\nenough for certain types of smart contract constructions. I think the\nAmiko Pay \"HTLC emulation\" design would be secure against malleability\nunder the conditions that\n* BIP62 is in effect\n* Every channel is only funded by one of the two sides (so e.g. the \"New\nsignatures by the sender\" case can't be abused)\n\nCJP\n\n\nRusty Russell schreef op do 19-11-2015 om 13:23 [+1030]:\n> Hi all!\n> \n>         As you know, I designed a lightning variant which used only\n> non-experimental, in-planning BIPs[1].  One assumption was BIP62: in\n> particular, that anchor malleability wouldn't be an issue.  This was\n> flawed; BIP62 will never be deployed.\n> \n>         There are several options from here:\n> \n> 1) Ignore it.  Malleated txs are non-standard.\n> 2) Add a timeout to the anchor.  Limits the lifetime of the channel, and\n>    still means if it does happen you have to wait for the timeout.\n> 3) Propose a reduced BIP62 which (say) only protects P2PKH, for a\n>    specific transaction version.\n> 4) Take a leap of faith and assume Segregated Witness fixes all\n>    malleability.\n> \n> I was debating between #1 and #3 for a while, but eventually settled on\n> #4.  Here's why:\n> \n> 1) While still pre-BIP, Pieter Wuille is working on a prototype now\n>    (Luke Jr came up with a sanish way of softforking it in).\n> 2) Other parts of the lightning code (in particular, watching bitcoin\n>    transactions) become significantly simpler if malleability is\n>    ignored.\n> 3) It's the right thing for Bitcoin; all smart contract systems want\n>    this.\n> \n> This result is NOP for lightning in the short term; assuming SW is the\n> same as pretending malleability doesn't exist.  But if we need to add\n> malleability support later, it's going to be painful, since handling it\n> correctly in all the places it's missing will be hard.\n> \n> Cheers,\n> Rusty.\n> PS.  Remember, every project has 3 major disasters.  Just wait until you\n>      see the next two!\n> \n> [1] https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Pierre",
                "date": "2015-11-19T12:29:42",
                "message_text_only": "Hi guys,\n\nDo you know of any available resources on \"segregated witness\" ? I\ncouldn't find any.\n\nCheers,\n\nPierre"
            },
            {
                "author": "sickpig at gmail.com",
                "date": "2015-11-19T12:33:47",
                "message_text_only": "Hi Pierre\n\nyou could start here\n\nhttps://github.com/ElementsProject/elementsproject.github.io#segregated-witness\nhttps://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\nhttps://github.com/ElementsProject/elements\n\n\n\n\nOn Thu, Nov 19, 2015 at 1:29 PM, Pierre <pm+lists at acinq.fr> wrote:\n\n> Hi guys,\n>\n> Do you know of any available resources on \"segregated witness\" ? I\n> couldn't find any.\n>\n> Cheers,\n>\n> Pierre\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/ca14f084/attachment.html>"
            },
            {
                "author": "Glenn Tarbox, PhD",
                "date": "2015-11-19T15:28:16",
                "message_text_only": "On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com <sickpig at gmail.com>\nwrote:\n\n> Hi Pierre\n>\n> you could start here\n>\n>\n> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n> https://github.com/ElementsProject/elements\n\n\nThere was a brief blip on Reddit:\n\nhttps://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n\nIts weird how little information there is on Segregated Witness.  I'm\nguessing its a simple concept and those working on it (sipa / gmaxwell)\nhaven't felt the need to write it up.\n\nThat it \"apparently\" can be done with a soft fork similar to P2SH is good\nnews... I guess...\n\n\n-- \nGlenn H. Tarbox, PhD\n =]|[=\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/8b88dfe3/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2015-11-19T15:31:50",
                "message_text_only": "The hardfork variant is quite simple, if I understood it correctly. You\njust stick the signatures in another parallel merkle tree. So if you don't\nwant to validate signatures, just don't download them, and validate\neverything else. TXIDs don't use the signature at all. Nothing to malleate,\nAFAIK. Not sure what the softfork plan is, but it will be a talk at Scaling\nBitcoin HK.\n\nOn Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD <glenn at tarbox.org>\nwrote:\n\n>\n> On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com <sickpig at gmail.com>\n> wrote:\n>\n>> Hi Pierre\n>>\n>> you could start here\n>>\n>>\n>> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>>\n>> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>> https://github.com/ElementsProject/elements\n>\n>\n> There was a brief blip on Reddit:\n>\n>\n> https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>\n> Its weird how little information there is on Segregated Witness.  I'm\n> guessing its a simple concept and those working on it (sipa / gmaxwell)\n> haven't felt the need to write it up.\n>\n> That it \"apparently\" can be done with a soft fork similar to P2SH is good\n> news... I guess...\n>\n>\n> --\n> Glenn H. Tarbox, PhD\n>  =]|[=\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/630dbc4e/attachment-0001.html>"
            },
            {
                "author": "Pierre",
                "date": "2015-11-19T16:04:47",
                "message_text_only": "> it will be a talk at Scaling Bitcoin HK.\n\nThat's great news! Looking forward to it"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2015-11-19T17:56:15",
                "message_text_only": "The basic idea of the soft-fork plan is very simple --- have the\nscriptPubKey be just the 20-byte hash of the redeem script. The scriptSig\nof the spending input is empty. The actual scriptSig, with the redeem\nscript and signatures, is contained in a separate Merkle tree committed to\nelsewhere in the block (e.g. in the last output of the coinbase, or the\nlast output of the last transaction).\n\nOn Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> The hardfork variant is quite simple, if I understood it correctly. You\n> just stick the signatures in another parallel merkle tree. So if you don't\n> want to validate signatures, just don't download them, and validate\n> everything else. TXIDs don't use the signature at all. Nothing to malleate,\n> AFAIK. Not sure what the softfork plan is, but it will be a talk at Scaling\n> Bitcoin HK.\n>\n> On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD <glenn at tarbox.org>\n> wrote:\n>\n>>\n>> On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com <sickpig at gmail.com>\n>> wrote:\n>>\n>>> Hi Pierre\n>>>\n>>> you could start here\n>>>\n>>>\n>>> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>>>\n>>> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>>> https://github.com/ElementsProject/elements\n>>\n>>\n>> There was a brief blip on Reddit:\n>>\n>>\n>> https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>>\n>> Its weird how little information there is on Segregated Witness.  I'm\n>> guessing its a simple concept and those working on it (sipa / gmaxwell)\n>> haven't felt the need to write it up.\n>>\n>> That it \"apparently\" can be done with a soft fork similar to P2SH is good\n>> news... I guess...\n>>\n>>\n>> --\n>> Glenn H. Tarbox, PhD\n>>  =]|[=\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/e557c246/attachment.html>"
            },
            {
                "author": "Tadge Dryja",
                "date": "2015-11-19T19:12:24",
                "message_text_only": "I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses many\nvectors for txid malleability, but maybe there are more.  And more\nimportantly, it addresses 3rd party malleability.  It's not helpful in the\ncontext of lightning channel creation because ECDSA sigs are inherently\nmalleable.  You can always re-sign the same message with a different\nk-value and get a different signature.\n\nThe functionality that's needed is to be able to reliably spend from\nunconfirmed transactions.  Segregated witness can accomplish that, but it\nquite a large hard-fork change.  sighash_noinput can also accomplish that:\nas input txids are not signed, if they change, the spending transaction can\nbe modified while leaving counterparty signatures intact.\n\nI'm hoping to start a new \"testnet-L\" similar to testnet3, with this\nsighash type so that we can test malleability mitigation out.\n\n(Oh also, hi mailing list, sorry I have not posted till now!  But I will\nstart posting!)\n\n-Tadge\n\nOn Thu, Nov 19, 2015 at 9:56 AM, Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n> The basic idea of the soft-fork plan is very simple --- have the\n> scriptPubKey be just the 20-byte hash of the redeem script. The scriptSig\n> of the spending input is empty. The actual scriptSig, with the redeem\n> script and signatures, is contained in a separate Merkle tree committed to\n> elsewhere in the block (e.g. in the last output of the coinbase, or the\n> last output of the last transaction).\n>\n> On Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders <gsanders87 at gmail.com>\n> wrote:\n>\n>> The hardfork variant is quite simple, if I understood it correctly. You\n>> just stick the signatures in another parallel merkle tree. So if you don't\n>> want to validate signatures, just don't download them, and validate\n>> everything else. TXIDs don't use the signature at all. Nothing to malleate,\n>> AFAIK. Not sure what the softfork plan is, but it will be a talk at Scaling\n>> Bitcoin HK.\n>>\n>> On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD <glenn at tarbox.org>\n>> wrote:\n>>\n>>>\n>>> On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com <sickpig at gmail.com>\n>>> wrote:\n>>>\n>>>> Hi Pierre\n>>>>\n>>>> you could start here\n>>>>\n>>>>\n>>>> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>>>>\n>>>> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>>>> https://github.com/ElementsProject/elements\n>>>\n>>>\n>>> There was a brief blip on Reddit:\n>>>\n>>>\n>>> https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>>>\n>>> Its weird how little information there is on Segregated Witness.  I'm\n>>> guessing its a simple concept and those working on it (sipa / gmaxwell)\n>>> haven't felt the need to write it up.\n>>>\n>>> That it \"apparently\" can be done with a soft fork similar to P2SH is\n>>> good news... I guess...\n>>>\n>>>\n>>> --\n>>> Glenn H. Tarbox, PhD\n>>>  =]|[=\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/fd7ed0ed/attachment.html>"
            },
            {
                "author": "zaki at manian.org",
                "date": "2015-11-19T19:15:00",
                "message_text_only": "sighhash_noinput is the miner chooses which which utxo is consumed assuming\nthere are multiple candidates variant of the idea?\n\n\nOn Thu, Nov 19, 2015 at 11:12 AM, Tadge Dryja <tadge at lightning.network>\nwrote:\n\n> I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses many\n> vectors for txid malleability, but maybe there are more.  And more\n> importantly, it addresses 3rd party malleability.  It's not helpful in the\n> context of lightning channel creation because ECDSA sigs are inherently\n> malleable.  You can always re-sign the same message with a different\n> k-value and get a different signature.\n>\n> The functionality that's needed is to be able to reliably spend from\n> unconfirmed transactions.  Segregated witness can accomplish that, but it\n> quite a large hard-fork change.  sighash_noinput can also accomplish that:\n> as input txids are not signed, if they change, the spending transaction can\n> be modified while leaving counterparty signatures intact.\n>\n> I'm hoping to start a new \"testnet-L\" similar to testnet3, with this\n> sighash type so that we can test malleability mitigation out.\n>\n> (Oh also, hi mailing list, sorry I have not posted till now!  But I will\n> start posting!)\n>\n> -Tadge\n>\n> On Thu, Nov 19, 2015 at 9:56 AM, Mark Friedenbach <mark at friedenbach.org>\n> wrote:\n>\n>> The basic idea of the soft-fork plan is very simple --- have the\n>> scriptPubKey be just the 20-byte hash of the redeem script. The scriptSig\n>> of the spending input is empty. The actual scriptSig, with the redeem\n>> script and signatures, is contained in a separate Merkle tree committed to\n>> elsewhere in the block (e.g. in the last output of the coinbase, or the\n>> last output of the last transaction).\n>>\n>> On Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders <gsanders87 at gmail.com>\n>> wrote:\n>>\n>>> The hardfork variant is quite simple, if I understood it correctly. You\n>>> just stick the signatures in another parallel merkle tree. So if you don't\n>>> want to validate signatures, just don't download them, and validate\n>>> everything else. TXIDs don't use the signature at all. Nothing to malleate,\n>>> AFAIK. Not sure what the softfork plan is, but it will be a talk at Scaling\n>>> Bitcoin HK.\n>>>\n>>> On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD <glenn at tarbox.org>\n>>> wrote:\n>>>\n>>>>\n>>>> On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com <sickpig at gmail.com>\n>>>> wrote:\n>>>>\n>>>>> Hi Pierre\n>>>>>\n>>>>> you could start here\n>>>>>\n>>>>>\n>>>>> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>>>>>\n>>>>> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>>>>> https://github.com/ElementsProject/elements\n>>>>\n>>>>\n>>>> There was a brief blip on Reddit:\n>>>>\n>>>>\n>>>> https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>>>>\n>>>> Its weird how little information there is on Segregated Witness.  I'm\n>>>> guessing its a simple concept and those working on it (sipa / gmaxwell)\n>>>> haven't felt the need to write it up.\n>>>>\n>>>> That it \"apparently\" can be done with a soft fork similar to P2SH is\n>>>> good news... I guess...\n>>>>\n>>>>\n>>>> --\n>>>> Glenn H. Tarbox, PhD\n>>>>  =]|[=\n>>>>\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>>>\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/10a65b2f/attachment-0001.html>"
            },
            {
                "author": "Tadge Dryja",
                "date": "2015-11-19T19:21:12",
                "message_text_only": "With sighash_noinput, signers don't include their input's txid and index.\nAn even more powerful version would not even sign the pubkeyscript of the\ninput, which would allow some cool constructions.\n\nIn the case that there are multiple utxo outpoints which would be satisfied\nby a single signature, miners can decide.  It can be dangerous for this\nreason if you re-use pubkeys.  So don't!  Especially in a multisig setting,\nit seems unlikely to be a problem.\n\n-Tadge\n\nOn Thu, Nov 19, 2015 at 11:15 AM, zaki at manian.org <zaki at manian.org> wrote:\n\n> sighhash_noinput is the miner chooses which which utxo is consumed\n> assuming there are multiple candidates variant of the idea?\n>\n>\n>\n> On Thu, Nov 19, 2015 at 11:12 AM, Tadge Dryja <tadge at lightning.network>\n> wrote:\n>\n>> I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses many\n>> vectors for txid malleability, but maybe there are more.  And more\n>> importantly, it addresses 3rd party malleability.  It's not helpful in the\n>> context of lightning channel creation because ECDSA sigs are inherently\n>> malleable.  You can always re-sign the same message with a different\n>> k-value and get a different signature.\n>>\n>> The functionality that's needed is to be able to reliably spend from\n>> unconfirmed transactions.  Segregated witness can accomplish that, but it\n>> quite a large hard-fork change.  sighash_noinput can also accomplish that:\n>> as input txids are not signed, if they change, the spending transaction can\n>> be modified while leaving counterparty signatures intact.\n>>\n>> I'm hoping to start a new \"testnet-L\" similar to testnet3, with this\n>> sighash type so that we can test malleability mitigation out.\n>>\n>> (Oh also, hi mailing list, sorry I have not posted till now!  But I will\n>> start posting!)\n>>\n>> -Tadge\n>>\n>> On Thu, Nov 19, 2015 at 9:56 AM, Mark Friedenbach <mark at friedenbach.org>\n>> wrote:\n>>\n>>> The basic idea of the soft-fork plan is very simple --- have the\n>>> scriptPubKey be just the 20-byte hash of the redeem script. The scriptSig\n>>> of the spending input is empty. The actual scriptSig, with the redeem\n>>> script and signatures, is contained in a separate Merkle tree committed to\n>>> elsewhere in the block (e.g. in the last output of the coinbase, or the\n>>> last output of the last transaction).\n>>>\n>>> On Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders <gsanders87 at gmail.com>\n>>> wrote:\n>>>\n>>>> The hardfork variant is quite simple, if I understood it correctly. You\n>>>> just stick the signatures in another parallel merkle tree. So if you don't\n>>>> want to validate signatures, just don't download them, and validate\n>>>> everything else. TXIDs don't use the signature at all. Nothing to malleate,\n>>>> AFAIK. Not sure what the softfork plan is, but it will be a talk at Scaling\n>>>> Bitcoin HK.\n>>>>\n>>>> On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD <glenn at tarbox.org>\n>>>> wrote:\n>>>>\n>>>>>\n>>>>> On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com <sickpig at gmail.com>\n>>>>> wrote:\n>>>>>\n>>>>>> Hi Pierre\n>>>>>>\n>>>>>> you could start here\n>>>>>>\n>>>>>>\n>>>>>> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>>>>>>\n>>>>>> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>>>>>> https://github.com/ElementsProject/elements\n>>>>>\n>>>>>\n>>>>> There was a brief blip on Reddit:\n>>>>>\n>>>>>\n>>>>> https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>>>>>\n>>>>> Its weird how little information there is on Segregated Witness.  I'm\n>>>>> guessing its a simple concept and those working on it (sipa / gmaxwell)\n>>>>> haven't felt the need to write it up.\n>>>>>\n>>>>> That it \"apparently\" can be done with a soft fork similar to P2SH is\n>>>>> good news... I guess...\n>>>>>\n>>>>>\n>>>>> --\n>>>>> Glenn H. Tarbox, PhD\n>>>>>  =]|[=\n>>>>>\n>>>>> _______________________________________________\n>>>>> Lightning-dev mailing list\n>>>>> Lightning-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>>\n>>>>>\n>>>>\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>>>\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/e7a516bf/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2015-11-19T19:38:46",
                "message_text_only": "Nope, Luke came up with a way to do it in a soft-fork.\n\nOn 11/19/15 19:12, Tadge Dryja wrote:\n> I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses\n> many vectors for txid malleability, but maybe there are more.  And more\n> importantly, it addresses 3rd party malleability.  It's not helpful in\n> the context of lightning channel creation because ECDSA sigs are\n> inherently malleable.  You can always re-sign the same message with a\n> different k-value and get a different signature.\n>\n> The functionality that's needed is to be able to reliably spend from\n> unconfirmed transactions.  Segregated witness can accomplish that, but\n> it quite a large hard-fork change.  sighash_noinput can also accomplish\n> that: as input txids are not signed, if they change, the spending\n> transaction can be modified while leaving counterparty signatures intact.\n>\n> I'm hoping to start a new \"testnet-L\" similar to testnet3, with this\n> sighash type so that we can test malleability mitigation out.\n>\n> (Oh also, hi mailing list, sorry I have not posted till now!  But I will\n> start posting!)\n>\n> -Tadge\n>\n> On Thu, Nov 19, 2015 at 9:56 AM, Mark Friedenbach <mark at friedenbach.org\n> <mailto:mark at friedenbach.org>> wrote:\n>\n>     The basic idea of the soft-fork plan is very simple --- have the\n>     scriptPubKey be just the 20-byte hash of the redeem script. The\n>     scriptSig of the spending input is empty. The actual scriptSig, with\n>     the redeem script and signatures, is contained in a separate Merkle\n>     tree committed to elsewhere in the block (e.g. in the last output of\n>     the coinbase, or the last output of the last transaction).\n>\n>     On Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders <gsanders87 at gmail.com\n>     <mailto:gsanders87 at gmail.com>> wrote:\n>\n>         The hardfork variant is quite simple, if I understood it\n>         correctly. You just stick the signatures in another parallel\n>         merkle tree. So if you don't want to validate signatures, just\n>         don't download them, and validate everything else. TXIDs don't\n>         use the signature at all. Nothing to malleate, AFAIK. Not sure\n>         what the softfork plan is, but it will be a talk at Scaling\n>         Bitcoin HK.\n>\n>         On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD\n>         <glenn at tarbox.org <mailto:glenn at tarbox.org>> wrote:\n>\n>\n>             On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com\n>             <mailto:sickpig at gmail.com> <sickpig at gmail.com\n>             <mailto:sickpig at gmail.com>> wrote:\n>\n>                 Hi Pierre\n>\n>                 you could start here\n>\n>                 https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>                 https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>                 https://github.com/ElementsProject/elements\n>\n>\n>             There was a brief blip on Reddit:\n>\n>             https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>\n>             Its weird how little information there is on Segregated\n>             Witness.  I'm guessing its a simple concept and those\n>             working on it (sipa / gmaxwell) haven't felt the need to\n>             write it up.\n>\n>             That it \"apparently\" can be done with a soft fork similar to\n>             P2SH is good news... I guess...\n>\n>\n>             --\n>             Glenn H. Tarbox, PhD\n>               =]|[=\n>\n>             _______________________________________________\n>             Lightning-dev mailing list\n>             Lightning-dev at lists.linuxfoundation.org\n>             <mailto:Lightning-dev at lists.linuxfoundation.org>\n>             https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>         _______________________________________________\n>         Lightning-dev mailing list\n>         Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>     _______________________________________________\n>     Lightning-dev mailing list\n>     Lightning-dev at lists.linuxfoundation.org\n>     <mailto:Lightning-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Tadge Dryja",
                "date": "2015-11-19T19:40:12",
                "message_text_only": "Cool, I had not seen that, I'll take a look.  I'm all for anything that\nallows reliable spends from unconfirmed txs.  If SW can get in easier,\nsounds good.\n\n-Tadge\n\nOn Thu, Nov 19, 2015 at 11:38 AM, Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> Nope, Luke came up with a way to do it in a soft-fork.\n>\n> On 11/19/15 19:12, Tadge Dryja wrote:\n>\n>> I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses\n>> many vectors for txid malleability, but maybe there are more.  And more\n>> importantly, it addresses 3rd party malleability.  It's not helpful in\n>> the context of lightning channel creation because ECDSA sigs are\n>> inherently malleable.  You can always re-sign the same message with a\n>> different k-value and get a different signature.\n>>\n>> The functionality that's needed is to be able to reliably spend from\n>> unconfirmed transactions.  Segregated witness can accomplish that, but\n>> it quite a large hard-fork change.  sighash_noinput can also accomplish\n>> that: as input txids are not signed, if they change, the spending\n>> transaction can be modified while leaving counterparty signatures intact.\n>>\n>> I'm hoping to start a new \"testnet-L\" similar to testnet3, with this\n>> sighash type so that we can test malleability mitigation out.\n>>\n>> (Oh also, hi mailing list, sorry I have not posted till now!  But I will\n>> start posting!)\n>>\n>> -Tadge\n>>\n>> On Thu, Nov 19, 2015 at 9:56 AM, Mark Friedenbach <mark at friedenbach.org\n>> <mailto:mark at friedenbach.org>> wrote:\n>>\n>>     The basic idea of the soft-fork plan is very simple --- have the\n>>     scriptPubKey be just the 20-byte hash of the redeem script. The\n>>     scriptSig of the spending input is empty. The actual scriptSig, with\n>>     the redeem script and signatures, is contained in a separate Merkle\n>>     tree committed to elsewhere in the block (e.g. in the last output of\n>>     the coinbase, or the last output of the last transaction).\n>>\n>>     On Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders <gsanders87 at gmail.com\n>>     <mailto:gsanders87 at gmail.com>> wrote:\n>>\n>>         The hardfork variant is quite simple, if I understood it\n>>         correctly. You just stick the signatures in another parallel\n>>         merkle tree. So if you don't want to validate signatures, just\n>>         don't download them, and validate everything else. TXIDs don't\n>>         use the signature at all. Nothing to malleate, AFAIK. Not sure\n>>         what the softfork plan is, but it will be a talk at Scaling\n>>         Bitcoin HK.\n>>\n>>         On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD\n>>         <glenn at tarbox.org <mailto:glenn at tarbox.org>> wrote:\n>>\n>>\n>>             On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com\n>>             <mailto:sickpig at gmail.com> <sickpig at gmail.com\n>>             <mailto:sickpig at gmail.com>> wrote:\n>>\n>>                 Hi Pierre\n>>\n>>                 you could start here\n>>\n>>\n>> https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>>\n>> https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>>                 https://github.com/ElementsProject/elements\n>>\n>>\n>>             There was a brief blip on Reddit:\n>>\n>>\n>> https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>>\n>>             Its weird how little information there is on Segregated\n>>             Witness.  I'm guessing its a simple concept and those\n>>             working on it (sipa / gmaxwell) haven't felt the need to\n>>             write it up.\n>>\n>>             That it \"apparently\" can be done with a soft fork similar to\n>>             P2SH is good news... I guess...\n>>\n>>\n>>             --\n>>             Glenn H. Tarbox, PhD\n>>               =]|[=\n>>\n>>             _______________________________________________\n>>             Lightning-dev mailing list\n>>             Lightning-dev at lists.linuxfoundation.org\n>>             <mailto:Lightning-dev at lists.linuxfoundation.org>\n>>\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>>         _______________________________________________\n>>         Lightning-dev mailing list\n>>         Lightning-dev at lists.linuxfoundation.org\n>>         <mailto:Lightning-dev at lists.linuxfoundation.org>\n>>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>>     _______________________________________________\n>>     Lightning-dev mailing list\n>>     Lightning-dev at lists.linuxfoundation.org\n>>     <mailto:Lightning-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/c3686d88/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2015-11-19T19:48:04",
                "message_text_only": "Its still a huge code change that hasnt been significantly discussed \npublicly, so I think opinions on what to do have yet to solidify, but \n(at the risk of putting words in other people's mouths) I think a part \nof retracting BIP62 is because Pieter wants to push this forward.\n\nOn 11/19/15 19:40, Tadge Dryja wrote:\n> Cool, I had not seen that, I'll take a look.  I'm all for anything that\n> allows reliable spends from unconfirmed txs.  If SW can get in easier,\n> sounds good.\n>\n> -Tadge\n>\n> On Thu, Nov 19, 2015 at 11:38 AM, Matt Corallo <lf-lists at mattcorallo.com\n> <mailto:lf-lists at mattcorallo.com>> wrote:\n>\n>     Nope, Luke came up with a way to do it in a soft-fork.\n>\n>     On 11/19/15 19:12, Tadge Dryja wrote:\n>\n>         I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses\n>         many vectors for txid malleability, but maybe there are more.\n>         And more\n>         importantly, it addresses 3rd party malleability.  It's not\n>         helpful in\n>         the context of lightning channel creation because ECDSA sigs are\n>         inherently malleable.  You can always re-sign the same message\n>         with a\n>         different k-value and get a different signature.\n>\n>         The functionality that's needed is to be able to reliably spend from\n>         unconfirmed transactions.  Segregated witness can accomplish\n>         that, but\n>         it quite a large hard-fork change.  sighash_noinput can also\n>         accomplish\n>         that: as input txids are not signed, if they change, the spending\n>         transaction can be modified while leaving counterparty\n>         signatures intact.\n>\n>         I'm hoping to start a new \"testnet-L\" similar to testnet3, with this\n>         sighash type so that we can test malleability mitigation out.\n>\n>         (Oh also, hi mailing list, sorry I have not posted till now!\n>         But I will\n>         start posting!)\n>\n>         -Tadge\n>\n>         On Thu, Nov 19, 2015 at 9:56 AM, Mark Friedenbach\n>         <mark at friedenbach.org <mailto:mark at friedenbach.org>\n>         <mailto:mark at friedenbach.org <mailto:mark at friedenbach.org>>> wrote:\n>\n>              The basic idea of the soft-fork plan is very simple ---\n>         have the\n>              scriptPubKey be just the 20-byte hash of the redeem script. The\n>              scriptSig of the spending input is empty. The actual\n>         scriptSig, with\n>              the redeem script and signatures, is contained in a\n>         separate Merkle\n>              tree committed to elsewhere in the block (e.g. in the last\n>         output of\n>              the coinbase, or the last output of the last transaction).\n>\n>              On Thu, Nov 19, 2015 at 7:31 AM, Greg Sanders\n>         <gsanders87 at gmail.com <mailto:gsanders87 at gmail.com>\n>              <mailto:gsanders87 at gmail.com\n>         <mailto:gsanders87 at gmail.com>>> wrote:\n>\n>                  The hardfork variant is quite simple, if I understood it\n>                  correctly. You just stick the signatures in another\n>         parallel\n>                  merkle tree. So if you don't want to validate\n>         signatures, just\n>                  don't download them, and validate everything else.\n>         TXIDs don't\n>                  use the signature at all. Nothing to malleate, AFAIK.\n>         Not sure\n>                  what the softfork plan is, but it will be a talk at Scaling\n>                  Bitcoin HK.\n>\n>                  On Thu, Nov 19, 2015 at 10:28 AM, Glenn Tarbox, PhD\n>                  <glenn at tarbox.org <mailto:glenn at tarbox.org>\n>         <mailto:glenn at tarbox.org <mailto:glenn at tarbox.org>>> wrote:\n>\n>\n>                      On Thu, Nov 19, 2015 at 4:33 AM, sickpig at gmail.com\n>         <mailto:sickpig at gmail.com>\n>                      <mailto:sickpig at gmail.com\n>         <mailto:sickpig at gmail.com>> <sickpig at gmail.com\n>         <mailto:sickpig at gmail.com>\n>                      <mailto:sickpig at gmail.com\n>         <mailto:sickpig at gmail.com>>> wrote:\n>\n>                          Hi Pierre\n>\n>                          you could start here\n>\n>         https://github.com/ElementsProject/elementsproject.github.io#segregated-witness\n>         https://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n>         https://github.com/ElementsProject/elements\n>\n>\n>                      There was a brief blip on Reddit:\n>\n>         https://www.reddit.com/r/Bitcoin/comments/3ngtx5/could_the_segregated_witness_part_of_the/cwnthlh\n>\n>                      Its weird how little information there is on Segregated\n>                      Witness.  I'm guessing its a simple concept and those\n>                      working on it (sipa / gmaxwell) haven't felt the\n>         need to\n>                      write it up.\n>\n>                      That it \"apparently\" can be done with a soft fork\n>         similar to\n>                      P2SH is good news... I guess...\n>\n>\n>                      --\n>                      Glenn H. Tarbox, PhD\n>                        =]|[=\n>\n>                      _______________________________________________\n>                      Lightning-dev mailing list\n>         Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>\n>                      <mailto:Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>>\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>                  _______________________________________________\n>                  Lightning-dev mailing list\n>         Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>\n>                  <mailto:Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>>\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>              _______________________________________________\n>              Lightning-dev mailing list\n>         Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>\n>              <mailto:Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>>\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>\n>         _______________________________________________\n>         Lightning-dev mailing list\n>         Lightning-dev at lists.linuxfoundation.org\n>         <mailto:Lightning-dev at lists.linuxfoundation.org>\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-20T00:45:51",
                "message_text_only": "Tadge Dryja <tadge at lightning.network> writes:\n> I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses many\n> vectors for txid malleability, but maybe there are more.  And more\n> importantly, it addresses 3rd party malleability.  It's not helpful in the\n> context of lightning channel creation because ECDSA sigs are inherently\n> malleable.  You can always re-sign the same message with a different\n> k-value and get a different signature.\n\nYeah, that's why the deployable lightning model used single-sided\nfunding (the escape tx model also works).\n\n> The functionality that's needed is to be able to reliably spend from\n> unconfirmed transactions.  Segregated witness can accomplish that, but it\n> quite a large hard-fork change.\n\nThe excitement is because the proposal is to soft-forked it in.  Seems\nlike it might work, but I'll have to see how ugly it is.\n\n> sighash_noinput can also accomplish that:\n> as input txids are not signed, if they change, the spending transaction can\n> be modified while leaving counterparty signatures intact.\n\nI was trying to a new OP_CHECKSIG2, because I'm fairly sure we're going\nto take years to winnow down the set of features.  I expect it will\nlogjam on \"new sig flags\" \"schnorr!\" \"scriptable signature parts\" etc...\n\n> I'm hoping to start a new \"testnet-L\" similar to testnet3, with this\n> sighash type so that we can test malleability mitigation out.\n>\n> (Oh also, hi mailing list, sorry I have not posted till now!  But I will\n> start posting!)\n\nWelcome :)\n\nCheers,\nRusty."
            },
            {
                "author": "Peter Todd",
                "date": "2015-11-22T20:24:54",
                "message_text_only": "On Thu, Nov 19, 2015 at 11:12:24AM -0800, Tadge Dryja wrote:\n> I've joked that BIP62 is the \"whack-a-mole\" BIP in that it addresses many\n> vectors for txid malleability, but maybe there are more.  And more\n> importantly, it addresses 3rd party malleability.  It's not helpful in the\n> context of lightning channel creation because ECDSA sigs are inherently\n> malleable.  You can always re-sign the same message with a different\n> k-value and get a different signature.\n> \n> The functionality that's needed is to be able to reliably spend from\n> unconfirmed transactions.  Segregated witness can accomplish that, but it\n> quite a large hard-fork change.  sighash_noinput can also accomplish that:\n\nIt's definitely not a hard-fork change.\n\nIn fact, I'll point out that in general it's actually pretty hard to\ncome up with features that absolutely must be implemented as hard fork\nchanges.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000001a06d85a46abce495fd793f89fe342e6da18b235ade373f\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151122/1959b3ec/attachment.sig>"
            },
            {
                "author": "Douglas Roark",
                "date": "2015-11-19T19:31:09",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 2015/11/19 04:29, Pierre wrote:\n> Do you know of any available resources on \"segregated witness\" ? I \n> couldn't find any.\n\nOn top of what others have posted, it looks like Pieter has posted\ncode for a hard fork version over at alpha\n(https://github.com/ElementsProject/elements/commit/663e9bd32965008a43a0\n8d1d26ea09cbb14e83aa).\nI doubt it's everything you need but I think this will give you an\nidea of the nuts & bolts for the hard fork version. I'm not aware of\nany public soft fork code.\n\nDoug\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJWTiN9AAoJEEOBHRomYjkkGREP/0QAsyOpQ1IWu+qYBOXaoXXg\nmDqwqV5Ci3xrOr2EgCA5ZWLhFMP9Ljk+F0zzUGj0dgf6HSXn238nddzqyCntBYyz\nwtquSEKHkY8iAJcHB71QiIZAgZb2QDqGAGPRKY8OXXhajoaL/MDwKQpMdBxor640\nRNpYlipRET9+Hu9JY9a8zALt4qq0QHxEtHTV+tGA+wN7Ax9Ylsj8zNr8LwXTaPJE\ncywHDtXiqw6ZZrh46ii/0K6oruQMjzGqplPMZT02ZfJDY1/oKAQRqtzRFy0plxOr\nFCUQmAta91E13g2B2F4oY/bBXzwVfdiXyIZGfcq+3dYpha5eA6uIeO2aiOmBiNuq\navr7A6rCQV1PeDV4GllS2JNMP6q3OaoyvbN35vzXA+DxWqFDRF/rcVZoIoDLzHmK\nJ1U7L//UXxnzUSZzFUpZl3G5hE4N7A7TwA22L91fTdwIH2JXw9LTVt1Z1O2goAAn\n9bzwJ759u1rjzH0159fRCbH8EsuwoWFtyLqlUHXrozg2O/w3D824CLO5TXa3F+HV\nhnJogG5Lyj3ntMn2ZvwUdpyVGW48L0s5Pwb4FyusGT/vdjEb+tPuaiTqNgFrkhst\ntxzSGIbfAsuPozzI5Sfopf4dHsjXsPUi/bUGHhlwdxPvQkhCw/ZKzjAXx8wDiPxi\nrE/aCy0vOfeJiJ9NLVkM\n=tAD8\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Bryan Bishop",
                "date": "2015-11-19T20:07:44",
                "message_text_only": "On Thu, Nov 19, 2015 at 6:29 AM, Pierre <pm+lists at acinq.fr> wrote:\n\n> Do you know of any available resources on \"segregated witness\" ? I\n> couldn't find any.\n>\n\nhttp://gnusha.org/bitcoin-wizards/2015-11-19.log\nhttp://gnusha.org/bitcoin-wizards/2015-11-08.log\n\nhttp://diyhpl.us/wiki/transcripts/gmaxwell-sidechains-elements/\nhttps://github.com/ElementsProject/elementsproject.github.io#segregated-witness\nhttps://people.xiph.org/~greg/blockstream.gmaxwell.elements.talk.060815.pdf\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151119/b6e1f03e/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning, the death of BIP62, and Segregated Witness",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "sickpig at gmail.com",
                "Matt Corallo",
                "Peter Todd",
                "Greg Sanders",
                "Pierre",
                "zaki at manian.org",
                "Tadge Dryja",
                "Douglas Roark",
                "CJP",
                "Rusty Russell",
                "Mark Friedenbach",
                "Glenn Tarbox, PhD",
                "Bryan Bishop"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 45495
        }
    },
    {
        "title": "[Lightning-dev] crowdfunding with SIGHASH_ANYONE_CAN_PAY",
        "thread_messages": [
            {
                "author": "Ryan Grant",
                "date": "2015-11-23T20:12:55",
                "message_text_only": "Alice intends to pledge to Bob's crowdfunded project, and will\ncreate a one-input, one-output, anyone-can-pay transaction, valid\nfor one month.  Bob publicized his address, anchored to an open\nchannel on the Lightning Network.  Alice has already received\nBob's hashed preimage R.  They plan to use an intermediary node\nrun by Hubab.\n\n/ the problem /\n\nAlice needs some special Lightning protocol option to indicate\nthat only the final hop should be rewritten and signed as\nanyone-can-pay.\n\nAll other anyone-can-pay donors need to pay to the same output.\nHowever, Lightning does not normally reuse public keys for fresh\nCommitment Transactions.\n\nBob's Lightning software needs to leave all anyone-can-pay\nfragments alone until they are valid together.\n\nCrowdsourcing initiatives usually deal in larger amounts of money\nthan the initiators can raise beforehand, which would preclude\nmatching the amount in an initial Funding Transaction.\n\n/ routed option /\n\nAlice sends Hubab a normal channel transaction, using the HTLC,\nto cover the cost plus fees.  Alice can then send Hubab special\ninstructions on how to create a SIGHASH_ANYONE_CAN_PAY for Bob,\nusing the HTLC.  Hubab does so.\n\nBob can receive transactions of arbitrary complexity.  Once Bob\nreceives the pledge transaction from Alice, it should not be\nrevoked, as in normal bidirectional use of Lightning channels.\nIt should lie out-of-band until the anyone-can-pay output is\nclaimed.  Bob does not update any related Commitment\nTransactions, until the anyone-can-pay is fulfilled.\n\nHubab will be able to spend her normal channel transaction when\nBob reaches his goal.  Bob's crowdfunding software will\nconcatenate scriptPubKeys of the pledges delivered by Hubab, with\ntheir HTLCs, to claim the anyone-can-pay output, releasing R.\n\n/ other issues /\n\nCrowdfunding events could lock up money for a long time, since\nexecution is not handed over to the network when the HTLC\ncommitment is initiated.  Lightning Network nodes will price\ntheir fees accordingly.  When fee discovery comes about, it\nshould be aware of the different transaction types.\n\nPledges have longer lives than payments, and it's not an error to\nchange one's mind about them.  The protocol needs an\nupdate_revoke_pledge_htlc, to revoke accepted pledges that have\nnot yet expired or caused other errors.\n\nHubab may need to route further, to Carol.  Hubab needs to be\naware of more in the route than her handoff address, such as\nwhether the next destination is final.\n\nHubab (or Carol), when signing the SIGHASH_ANYONE_CAN_PAY\ntransaction, needs to select an input matching the exact amount.\n\nDid I get this right?\n\nIs there a simpler way to do crowdfunding with the Lightning\nNetwork?"
            },
            {
                "author": "Ryan Grant",
                "date": "2015-11-23T22:44:05",
                "message_text_only": "This was an interesting thought experiment for me, but upon reflection\nthere's no point in trying to do this in Lightning.\n\nEveryone considering a pledge can sign their part of the transaction,\nfor free, if they hold any coins on the Bitcoin blockchain. Only the\ninitiator needs to pay any transaction fee."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-24T23:04:31",
                "message_text_only": "Ryan Grant <bitcoin-dev at rgrant.org> writes:\n> This was an interesting thought experiment for me, but upon reflection\n> there's no point in trying to do this in Lightning.\n>\n> Everyone considering a pledge can sign their part of the transaction,\n> for free, if they hold any coins on the Bitcoin blockchain. Only the\n> initiator needs to pay any transaction fee.\n\nSure, but maybe you've got lightning funds already?\n\nLet's continue your analysis.  We already know the protocol can be\nextended to pay to anything (what I have been calling \"Atomic swap to\nX\").\n\nThe general problem with swapping onto the blockchain is that it needs\nto be able to time out, since the basic deal is of form \"I will pay you\n$5 iff you give me R in the next 24 hours\".  That can't be done natively\nin script, but it can be done as follows:\n\nFirst create a tx with a small output with scriptPubkey of form \"pay to\nme, or after <timeout> pay to anyone\".  Use that as one input to your\ncrowdfunding tx.\n\nAfter the timeout, anyone can double-spend and thus invalidate the\ncrowdfunding tx (make the amount cover a the expected txfee, and it's\nfree money).\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "crowdfunding with SIGHASH_ANYONE_CAN_PAY",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Ryan Grant"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4153
        }
    },
    {
        "title": "[Lightning-dev] How to exchange of Revocation preimage atomically ?",
        "thread_messages": [
            {
                "author": "Nicolas Dorier",
                "date": "2015-11-24T02:36:20",
                "message_text_only": "I am still learrning about Lightning Network, slowly but surely.\nAs I was reviewing bip 112 (\nhttps://github.com/btcdrak/bips/blob/bip112sync/bip-0112.mediawiki) I\nnoticed that HLTC seems to have a potential attack.\n\nWhen both parties want to revoke a commitment, they need to send one to\nanother the revocation preimage.\nHowever, if not done atomically, Alice intentionally not send her\nrevocation after receiving Bob's thus preventing Bob to withdraw his funds.\n\nAm I missing something ?\n\nThe only way I see of fixing as is, is to require a third party expecting\nhe does not collude, but this defeat the whole purpose.\n\nNicolas,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151124/9ee4f363/attachment.html>"
            },
            {
                "author": "Tadge Dryja",
                "date": "2015-11-24T03:14:16",
                "message_text_only": "If I understand your question, it's that the both Alice and Bob must revoke\ntheir previous transaction states and share their revocations, but someone\nhas to go first.\n\nI don't think there's a good way to make this atomic (fair exchange schemes\nbased on hash functions instead of signatures *sounds* sortof impossible,\nbut who knows).  But in practice there's not really an attack, in that\nevery update of a channel state has an initiator.\n\nAll the payments are \"push\" payments; if Alice wants to allocate more to\nBob, she initiates, and if Bob wants to allocate more to Alice, he\ninitiates.  With revocations, the user initiating the channel state change\ngoes first.\n\nIn the case where Alice is sending more coin to Bob:\n\nAlice signs new state, sends half signed tx to Bob.\nBob signs new state, sends half signed tx to Alice.\nAlice revokes old state by sending preimage to Bob.\nBob revokes old state by sending preimage to Alice.\nDone.\n\nIf Bob fails to perform the last step, the payment can be considered to not\nhave gone through.  But Bob doesn't have much motivation to fail there.  He\ncan leave the channel in an indeterminate state by failing to revoke with\nAlice, but that indeterminate state is worse for him than a fully\ndetermined state where he has more money.\n\nTLDR It's not atomic so payer goes first.\n\nHope this helps!  If not, let me know, say a bit more about what you think\nthe attack would be.\n\n-Tadge\n\nOn Mon, Nov 23, 2015 at 6:36 PM, Nicolas Dorier <nicolas.dorier at gmail.com>\nwrote:\n\n> I am still learrning about Lightning Network, slowly but surely.\n> As I was reviewing bip 112 (\n> https://github.com/btcdrak/bips/blob/bip112sync/bip-0112.mediawiki) I\n> noticed that HLTC seems to have a potential attack.\n>\n> When both parties want to revoke a commitment, they need to send one to\n> another the revocation preimage.\n> However, if not done atomically, Alice intentionally not send her\n> revocation after receiving Bob's thus preventing Bob to withdraw his funds.\n>\n> Am I missing something ?\n>\n> The only way I see of fixing as is, is to require a third party expecting\n> he does not collude, but this defeat the whole purpose.\n>\n> Nicolas,\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151123/fc57500a/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-24T03:55:04",
                "message_text_only": "Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n> I am still learrning about Lightning Network, slowly but surely.\n> As I was reviewing bip 112 (\n> https://github.com/btcdrak/bips/blob/bip112sync/bip-0112.mediawiki) I\n> noticed that HLTC seems to have a potential attack.\n>\n> When both parties want to revoke a commitment, they need to send one to\n> another the revocation preimage.\n> However, if not done atomically, Alice intentionally not send her\n> revocation after receiving Bob's thus preventing Bob to withdraw his funds.\n>\n> Am I missing something ?\n\nThe order is:\n\n1. Exchange new commit tx signatures.\n2. Exchange revocation of old commit tx.\n\nIf Alice doesn't do #2, Bob still has the new commit tx he can drop on\nthe blockchain.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "How to exchange of Revocation preimage atomically ?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Nicolas Dorier",
                "Tadge Dryja"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4123
        }
    },
    {
        "title": "[Lightning-dev] Return to the Layered Commit Transactions?",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-11-24T17:47:36",
                "message_text_only": "While working on the payment layer and messing around with timeouts /\ntimeframes for CSV and CLTV, I noticed a few things...\n\n(1)\nIt is indeed not possible for HTLCs to have a long revocation time and\na short refund time. And it makes sense the way we designed the\nscripts and the commit transaction. As it's a single output, we either\ncan prevent the other side from doing ANYTHING for the revocation\ntimeout T1, or the other party is able to claim the complete output\nwithout any encumbering... In long chains of multiple hops, I might\nneed R to settle the payment normally, while you still wait out the\nrevocation timeout before you can reveal R...\n\nI described that some time ago, but was unsure if I was right\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-September/000182.html\n\n(2)\nAs revocation-time and refund time are equal, we have some problematic\nrace conditions, where both parties can technically claim the payment,\ndepending on propagation time of the transaction. Further, if you\nclaim the payment that I was actually entitled to per refund, I may be\nout of luck getting my money back on the next hop...\n\n(3)\nAs the absolute CLTV timeout has to increase with each hop, it can\ngive us insight about our position within the route, even with onion\nrouting. It is possible to have the sender add some delay, but this\njust increases the (already long) total refund time.\n\nI played with the numbers back and forth, but I don't really see any\nway out of this problem. Anything below one day might be dangerous\nalready for DDoS attacks, with 20 hops we might end up with 30-40 days\nfor a refund though...\n\nIf we go back to the original design, we are able to separate\n'claiming-a-payment-using-R' and 'revoke-an-output' into two layers\nand such, we can enforce revealing R within a separate timeframe than\nthe revocation timeframe. To do this, we need either SIGHASH_NOINPUT\nor SW, as we can't construct the transaction on top of the 'reveal-R'\ntransaction without knowing R currently. Short refund timeouts would\nalso mitigate the problems of (3)\n\nI would really love to stick with the current design, as not having to\nkeep another set of signatures makes everything easier ...\n\nCheers\nMats"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-25T00:02:54",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> While working on the payment layer and messing around with timeouts /\n> timeframes for CSV and CLTV, I noticed a few things...\n>\n> (1)\n> It is indeed not possible for HTLCs to have a long revocation time and\n> a short refund time. And it makes sense the way we designed the\n> scripts and the commit transaction. As it's a single output, we either\n> can prevent the other side from doing ANYTHING for the revocation\n> timeout T1, or the other party is able to claim the complete output\n> without any encumbering... In long chains of multiple hops, I might\n> need R to settle the payment normally, while you still wait out the\n> revocation timeout before you can reveal R...\n\nRight.\n\nThis isn't immediately obvious, so let's unpack this a bit:\n\nBecause any to-self output needs to have an additional relative\nrevocation delay, A's HTLC output would look like:\n\n        For A if HTLC times out + revocation relative timeout, OR\n        For B with HTLC R value, OR\n        For B with revocation hash.\n\nA needs to handle the case where B spends after the HTLC timeout, but\nbefore the revocation relative timeout, so its inter-hop HTLC timeout\ndelta has to be > revocation timeout.\n\n(Aside: can we reduce the HTLC timeout there so that it takes into account\nthe relative timeout?  I'd have to think harder about all the other\nscripts, too, but it seems reasonable on the surface?).\n\n> (2)\n> As revocation-time and refund time are equal, we have some problematic\n> race conditions, where both parties can technically claim the payment,\n> depending on propagation time of the transaction. Further, if you\n> claim the payment that I was actually entitled to per refund, I may be\n> out of luck getting my money back on the next hop...\n\nYeah, don't do this.\n\n> (3)\n> As the absolute CLTV timeout has to increase with each hop, it can\n> give us insight about our position within the route, even with onion\n> routing. It is possible to have the sender add some delay, but this\n> just increases the (already long) total refund time.\n\nThis was my plan.\n\n> I played with the numbers back and forth, but I don't really see any\n> way out of this problem. Anything below one day might be dangerous\n> already for DDoS attacks, with 20 hops we might end up with 30-40 days\n> for a refund though...\n\nIt's not about DoS, really.  The revocation time has to be long enough\nso you're certain to spot someone cheating.  And we've established that\nthe HTLC inter-hop-delta should be >> revocation time.\n\nIf your node is online and robust, 3 hours should be sufficient for\nrevocation time (remember, you can jack up fees if you need to).  12\nhours will give you plenty of time to take your claim transactions and\ninject them into the bitcoin network via carrier pidgeon or whatever you\nneed to get around any DDoS.\n\nStill, let's assume everyone uses 1 day for revocation time, and 2 days\nfor HTLC timeout delta, and we have 20 hops.\n\nThe original HTLC (NODE 0 -> NODE 1) times out in 40 days.  The last\nHTLC (NODE 19 -> NODE 20) times out in 2 days, and that one falls to the\nblockchain.  NODE 19 takes 3 days to get a refund.  Then it can\nimmediately close the incoming HTLC from NODE18 (why wait for a timeout?\nIt no longer has outstanding liabilities or any reason to believe it\nwill get the R value), etc.\n\nSo, worst case is 3 days unless there are multiple hop failures?\n\n> If we go back to the original design, we are able to separate\n> 'claiming-a-payment-using-R' and 'revoke-an-output' into two layers\n> and such, we can enforce revealing R within a separate timeframe than\n> the revocation timeframe. To do this, we need either SIGHASH_NOINPUT\n> or SW, as we can't construct the transaction on top of the 'reveal-R'\n> transaction without knowing R currently. Short refund timeouts would\n> also mitigate the problems of (3)\n>\n> I would really love to stick with the current design, as not having to\n> keep another set of signatures makes everything easier ...\n\nAgreed.  \n\nWhat do you think about reducing the OP_CHECKLOCKTIMEVERIFY argument if\nit's followed by the revocation delay?\n\nThanks!\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-25T09:07:54",
                "message_text_only": "On Wed, Nov 25, 2015 at 10:32:54AM +1030, Rusty Russell wrote:\n>         For A if HTLC times out + revocation relative timeout, OR\n> (Aside: can we reduce the HTLC timeout there so that it takes into account\n> the relative timeout?  I'd have to think harder about all the other\n> scripts, too, but it seems reasonable on the surface?).\n\nDefinitions:\n d -- the OP_CSV delay\n T -- top OP_CLTV timeout\n C -- the commitment tx is signed by B and given to A at time C\n P -- the commitment tx is published at time P\n S -- the commitment tx is spent at time S\n X -- the timeout at which a refund can be forced\n\nConstraints enforced by bitcoin:\n\n  P >= C\n  S >= T\n  S >= P+d\n\nWhen A is paying the HTLC, and wants to claim a refund by unilaterally\nclosing the channel, We want to enforce S >= P+d and S >= X.\n\nIf C+d >= X, then P+d >= C+d >= X, and we can just use OP_CSV <d>.\n\nIf C+d < X, then if the commitment is published immediately, P+d < X,\nand we still need OP_CSV <d> && OP_CLTV <T=X>.\n\nHowever if the commitment gets updated while the HTLC remains open, C\nwill increase over time while d and X remain constant, so eventually the\nOP_CLTV could be dropped. But I don't see how that does any good?\n\n_But_ if you're updating a commitment and C+d >= X, then it seems like\nyour counterparty should already have given up on trying to redeem it,\nnot keep it open? If so, you're probably being cheated and should have\nclosed the channel already.\n\nAlice forwards to Bob who forward to Carol creates two HTLCs:\n\n  (Bob, x, R, T)\n  (Carol, x-f, R, T-t)\n\nWhat we want is to be able to say that \"assuming Bob can close the HTLC\nwith Carol by T-t+k, Alice can close the channel by time T+k\", I think...\n\n * At time T-t+k, Alice says \"Bob, you haven't given me R. Do you give\n   up?\". If Bob has closed his channel with Carol and is cooperative,\n   he reveals R (if Carol did) and is happy, or gives up and Alice times\n   out the HTLC slightly early. (If Bob doesn't answer at this point,\n   he's violating protocol, and we don't care if he loses money)\n\n * Otherwise, Alice declares Bob uncooperative, and closes the channel,\n   with an output spending to:\n\n      (Alice & OP_CLTV T & OP_CSV d) | (Bob & (R | Revoke_A))\n\n * This enters the blockchain at time T-t+k+x (where x is some delay due\n   to the time it takes to find a block, and whether the fee Alice's\n   commitment pays is competitive or not)\n\n * Alice can spend this HTLC at time max(T, T-t+k+x+d), which we'd like to\n   no later than T. So T-t+k+x+d <= T, which just means d <= t-k-x\n   If t >> d (ie, inter-hop-delta is much greater than revocation delay),\n   that's satisfied.\n\n * Depending on the fee Alice pays etc, her transaction then gets\n   n confirmations by time T+y, or else Bob manages a double spend,\n   revealing R. If we chose k such that y <= k here, we're done: if Bob\n   tried at doublespend, then at time T+k Alice knows R, or Alice is\n   confident she got her refund.\n\n * Induction lets us note that Bob can apply the same argument and\n   ensure that he complies with protocol, giving us the original\n   assumption.\n\n * For concreteness, then, assuming you pay fees that get your block\n   accepted withing the next F blocks or so, k=y=10*(n+F) minutes,\n   x=10*F minutes, and t >= d+10*(n+2F).\n\n   So normally your HTLC will expire at T-t+k = T-d-10*F and the channel\n   will stay open; otherwise you'll close the channel and not know the\n   answer for sure until T+k = T+10*(n+F).\n\n   For n=4, F=4, t >= d+2 hours, so normal expiry is no later than\n   T-d-40m, and uncooperative expiry is at T+1h20, so d+2h later.\n\n> > (3)\n> > As the absolute CLTV timeout has to increase with each hop, it can\n\n(decrease with each hop; at least if you start counting at whoever's\npaying)\n\n> It's not about DoS, really.  The revocation time has to be long enough\n> so you're certain to spot someone cheating.  And we've established that\n> the HTLC inter-hop-delta should be >> revocation time.\n> \n> If your node is online and robust, 3 hours should be sufficient for\n> revocation time (remember, you can jack up fees if you need to). \n\nSo if d=3h, then t>=5h above assuming 4 confirmations is enough to give\nyou confidence you won't be reorged and doublespent, and you pay enough\nfees to get into one of the next 4 blocks.\n\n> 12\n> hours will give you plenty of time to take your claim transactions and\n> inject them into the bitcoin network via carrier pidgeon or whatever you\n> need to get around any DDoS.\n\nd=3h and t=12h gives (n+2F)=54, so say n=24, F=15; meaning pay enough\nfees to get in in the next 15 blocks, and accept spends after 24\nconfirmations.\n\n> Still, let's assume everyone uses 1 day for revocation time, and 2 days\n> for HTLC timeout delta, and we have 20 hops.\n>\n> The original HTLC (NODE 0 -> NODE 1) times out in 40 days.  The last\n> HTLC (NODE 19 -> NODE 20) times out in 2 days, and that one falls to the\n> blockchain.  NODE 19 takes 3 days to get a refund.\n\nBy my protocol above, node 19 would demand an answer from node 20\nat time T-t+k, but T=2 days, and t=2 days, so that's just time 0+k.\nd<=t-k-x, so k<=t-d-x; ie, k<=1 day - x, and x=10*F minutes. So node 19\ndemands an answer from node 20 after, say, k=21 hours (F=18 blocks). Node\n20 doesn't reply, so 19 closes the channel and posts the commitment\nto the blockchain, paying enough fee to be visible after 18 blocks,\nwhich happens to be 3h later, ie 1 day total time.  After another day,\nboth OP_CLTV and OP_CSV pass, so node 19 tries spending it, with enough\nfee to get in after 18 blocks, or 3h, so that's at about T=51h.\n\nMeanwhile node 18 is wondering what's going on, and follows the same\nprotocol. At time T'-t+k demanding an answer from node 19. T'=4 days,\nt=2 days, and k=21h, so T'-t+k = 69h. So node 19 has 18 hours to be\nconfident its refund transaction isn't going to be reorged, or to see an\nattempt at a doublespend by node 20 revealing R. Either way, node 19 can\nrespond to node 18's request and keep the channel open. Node 18 can\npre-emptively pass on R or close 17's HTLC at that point and so on.\n\nSo by my count, node 19 has a refund within 2 days 21 hours.\n\n> So, worst case is 3 days unless there are multiple hop failures?\n\nA single hop failure at node 3 immediately after the transaction gets\npassed on would be worse. Setup:\n\n node 1/node 2 = 38 days\n node 2/node 3 = 36 days\n node 3/node 4 = 34 days\n ...\n node 19/node 20 = 2 days\n\nt+1 second:\n\n node 1/node 2 = 38 days\n node 2/node 3 = 36 days\n node 3/node 4 = 34 days\n [everyone else resolved]\n\nNode 4 asks node 3 \"wtf??\". doesn't get an answer, closes the channel,\npublishing the commitment to the blockchain.\n\nAfter a day, node 4 can reclaim uncommitted funds, and reveal R to claim\nthe HTLC funds. node 3 is out of pocket.\n\nWithin the next 33 days, node 3 wakes up, sees R and finishes the\ntransaction. Node 2, in particular, has funds held up for the 34 days\nnode 3 was down.\n\n> What do you think about reducing the OP_CHECKLOCKTIMEVERIFY argument if\n> it's followed by the revocation delay?\n\nThe revocation delay happens simultaneously, so I don't think this can\nbe made to work usefully.\n\nDon't think it's needed either though, so long as channels have parameters\n\"t\" and \"k\" as well as \"d\" to drop to the blockchain well before T\nactually comes around.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-27T03:42:55",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n>  Definitions:\n>   d -- the OP_CSV delay\n>   T -- top OP_CLTV timeout\n>   C -- the commitment tx is signed by B and given to A at time C\n>   P -- the commitment tx is published at time P\n>   S -- the commitment tx is spent at time S\n>   X -- the timeout at which a refund can be forced\n...\n>    For n=4, F=4, t >= d+2 hours, so normal expiry is no later than\n>    T-d-40m, and uncooperative expiry is at T+1h20, so d+2h later.\n\nIs the 2 hours here due to timer tolerance?  If so, BIP 113 may allow us\nto squeeze that a little in practice, depending on one's risk tolerance.\n\n>> So, worst case is 3 days unless there are multiple hop failures?\n>\n> A single hop failure at node 3 immediately after the transaction gets\n> passed on would be worse. Setup:\n\nIndeed.\n\n>> What do you think about reducing the OP_CHECKLOCKTIMEVERIFY argument if\n>> it's followed by the revocation delay?\n>\n> The revocation delay happens simultaneously, so I don't think this can\n> be made to work usefully.\n\nGood point, it was a thinko.\n\n> Don't think it's needed either though, so long as channels have parameters\n> \"t\" and \"k\" as well as \"d\" to drop to the blockchain well before T\n> actually comes around.\n\nI'll be honest, I got lost somewhere in the alphabet reading your post.\n\nHowever, you might be able to help me with a related question: I\nproposed previously that if you didn't get fast resolution on an HTLC\nyou'd require proof that a commit tx was published, or you'd close the\nchannel yourself to create such a proof to hand back.\n\nHow would this work, timeout-wise?  We don't know how many hops are\nahead of us.  If the rule is \"wait 1 minute, if you don't get a\nresponse, close the channel\" then everyone in the chain will close the\nchannel at once.  If the timeout is in the HTLC offer, then it makes the\nmessage more traceable.\n\nI can't see any obvious solution, can you?\n\nThanks,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T05:14:46",
                "message_text_only": "On Fri, Nov 27, 2015 at 02:12:55PM +1030, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> >  Definitions:\n> >   d -- the OP_CSV delay\n> >   T -- top OP_CLTV timeout\n> >   C -- the commitment tx is signed by B and given to A at time C\n> >   P -- the commitment tx is published at time P\n> >   S -- the commitment tx is spent at time S\n> >   X -- the timeout at which a refund can be forced\n> ...\n> >    For n=4, F=4, t >= d+2 hours, so normal expiry is no later than\n> >    T-d-40m, and uncooperative expiry is at T+1h20, so d+2h later.\n> Is the 2 hours here due to timer tolerance?  \n\nNope, it's just plugging in n and F into \"t >= d+10*(n+2F)\".\n\n> > Don't think it's needed either though, so long as channels have parameters\n> > \"t\" and \"k\" as well as \"d\" to drop to the blockchain well before T\n> > actually comes around.\n> I'll be honest, I got lost somewhere in the alphabet reading your post.\n\nYeah; I'm surprised I didn't while writing it.\n\nBut while chatting with matsjj afterwards, I think I came up with a\nbeter explanation:\n\n  T = the timeout in the HTLC\n  d = the CSV delay in the HTLC\n  n = how long it takes for you to be confident someone else can't\n      doublespend an input to your transaction (ie, 10 minutes * however\n      many confirmations you want to see)\n  f = how long it takes your transactions to get the first confirmation,\n      given how much fee you pay\n\n(To translate to t and k, t=d+f and k=f+n))\n\nAt time T-d-f, if the HTLC hasn't been resolved off-chain, you want to\npublish your commitment transaction. It'll hit the chain at time T-d.\n\nAt time T both the CTLV and CSV clauses are satisfied, so you can spend\nit. You should attempt to do so immediately. Your tx will be confirmed\nat time T+f. At time T+f+n, you'll be satisfied your tx is safe.\n\nT-d-f = T-t = when you decide to close the channel and hit the blockchain\nT+f+n = T+k = when you're 100% sure the HTLC is done with\n\n> However, you might be able to help me with a related question: I\n> proposed previously that if you didn't get fast resolution on an HTLC\n> you'd require proof that a commit tx was published, or you'd close the\n> channel yourself to create such a proof to hand back.\n> \n> How would this work, timeout-wise?  We don't know how many hops are\n> ahead of us.  If the rule is \"wait 1 minute, if you don't get a\n> response, close the channel\" then everyone in the chain will close the\n> channel at once.  If the timeout is in the HTLC offer, then it makes the\n> message more traceable.\n> \n> I can't see any obvious solution, can you?\n\nI still hope the \"fine people for keeping the channel open\" idea (I\nthink CJP proposed it?) is possible, but I haven't tried working out if\nyou can make the details work when you have to drop to the blockchain,\nand have multiple HTLCs in flight.\n\nIf you made the rule be something like \"if the HTLC was setup at time\nO with timeout T, wait until O+(T-O)/120 and close the channel\" you\nwouldn't have privacy problems though.\n\nYou'll still have the problem that if you're near the end of the chain\nyou might get left holding the bag though (ie, still having to pay the\ntx amount forward (despite closing that channel), but not being able\nto collect it from the other end (because you cancelled the HTLC you\nforwarded, in order to keep the channel open)).\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T21:27:42",
                "message_text_only": "On Fri, Nov 27, 2015 at 03:14:46PM +1000, Anthony Towns wrote:\n> On Fri, Nov 27, 2015 at 02:12:55PM +1030, Rusty Russell wrote:\n> > Anthony Towns <aj at erisian.com.au> writes:\n>   T = the timeout in the HTLC\n>   d = the CSV delay in the HTLC\n>   n = how long it takes for you to be confident someone else can't\n>       doublespend an input to your transaction (ie, 10 minutes * however\n>       many confirmations you want to see)\n>   f = how long it takes your transactions to get the first confirmation,\n>       given how much fee you pay\n\n> At time T-d-f, if the HTLC hasn't been resolved off-chain, you want to\n> publish your commitment transaction. It'll hit the chain at time T-d.\n\n> At time T both the CTLV and CSV clauses are satisfied, so you can spend\n> it. You should attempt to do so immediately. Your tx will be confirmed\n> at time T+f. At time T+f+n, you'll be satisfied your tx is safe.\n\n> T-d-f = T-t = when you decide to close the channel and hit the blockchain\n> T+f+n = T+k = when you're 100% sure the HTLC is done with\n\nSo in addition: if Bob is forwarding an HTLC from Alice to Carol, then,\nassuming:\n\n  Bob knows Alice's f, call it f_a;\n  Bob knows the CSV delay on his channel with Alice, call it d_a;\n  Bob knows the CSV delay on his channel with Carol, call it d_c;\n  Bob knows his own f and n;\n  Bob knows the timeout on the incoming HTLC, T_a\n\n  Bob wants to work out the timeout to set on the outgoing HTLC, T_b.\n\nIn order to keep the channel with Alice open, he needs to resolve the\noutgoing HTLC by time T_a-d_a-f_a. And the time he's sure his outgoing\nHTLC is done is T_b+f+n, so:\n\n  T_b+f+n <= T_a-d_a-f_a\n\n  T_b <= T_a - d_a - f_a - f - n\n\nAlso, Bob wants T_b-d-f > now, or there's no point forwarding the HTLC since\nhe'd have to close the channel immediately, so:\n\n  now + d + f < T_b <= T_a - d_a - f_a - f - n\n\ngives you constraints on the forwarded timeout based on, I think, fairly\nmeaningful parameters.\n\n(You might want to add further constraints on the timeout based on fees,\nof course -- the above is what you need to avoid being left holding\nthe bag)\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-30T01:25:54",
                "message_text_only": "On Sat, Nov 28, 2015 at 07:27:42AM +1000, Anthony Towns wrote:\n> (You might want to add further constraints on the timeout based on fees,\n> of course -- the above is what you need to avoid being left holding\n> the bag)\n\nYou might also want to batch the timeouts, so if you have 1000 concurrent\nHTLCs on a channel at any point in time [0] and expect 10% of them\nto timeout, you'd be better off expiring them in five batches of 20,\nrather than individually.\n\nThat way you can spend them all to a single output, saving you both\n19*34 bytes in that transaction, but also something like 19*130 bytes\nwhen you want to actually spend the outputs. (With 40 satoshi/byte fees @\n$350/BTC, that's an overall saving of 2c or more per batched HTLC)\n\nCheers,\naj\n\n[0] I think the 100kB standardness limit on transactions means you can\n    have at most about 3000 concurrent committed HTLCs on a channel,\n    assuming your anchor is a single multisig transaction, and your\n    outputs are all P2SH."
            }
        ],
        "thread_summary": {
            "title": "Return to the Layered Commit Transactions?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Mats Jerratsch"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 21967
        }
    },
    {
        "title": "[Lightning-dev] Committing to dust",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T02:38:07",
                "message_text_only": "Hey,\n\nSuppose you have a lightning channel, with balances of exactly 2 BTC\non your side, and 1 BTC on the other (and 1mBTC for fees). You send a\nmicropayment of 42 satoshi across the channel, resulting in an updated\ncommitment that looks like:\n\n  in:\n    anchor (3.001 BTC): [yoursig theirsig redeemscript]\n\n  out:\n    1 BTC: [pay2pubkey(theirs)]\n    1.99999958 BTC: [pay2pubkey(yours)]\n    0.00000042 BTC: [pay2scripthash(htlc to them with R or you after\n                     timeout)]\n\nBut the third output will hit the IsDust() test (less than 546 satoshi\nfor a min relay fee of 0.01 mBTC) and the entire transaction will be\nrejected, so the channel can't be closed at all!\n\nThis is a similar problem to sub 1-satoshi payments, but it's different\nin that while you can't represent them as an HTLC output, you can\nrepresent them as soon as they complete -- ie:\n\n  out:\n    1.00000042 BTC: [pay2pubkey(theirs)]\n    1.99999958 BTC: [pay2pubkey(yours)]\n\nis completely legitimate (whereas an output of 1.0 + 0.042e-8 BTC\nwouldn't be).\n\nI assume treating them much the same way is the only real option --\naccount for them exactly in the lightning state, but just approximate the\nresults in the actual commitments. So long as you're closing channels\ninfrequently, losing a few hundred satoshi here and there won't matter\nmuch.\n\nThe important thing is that adding dust to your commitment might mean you\ncan't access _any_ of your funds if your channel counterparty goes AWOL.\nEven though the amount mightn't matter, you can't just treat it like\nany other case in the code.\n\nAnother option might be to weaken the dust protection in the network --\neg if you made the dust output be\n\n    0.00000042 BTC: [(them && (R || revoke))\n                     || (you && d CSV && t CLTV)\n                     || (3 months CSV)]\n\nthen anyone could clear the dust after 3 months if it weren't otherwise\nclaimed; maybe having some dust for a finite time is okay. But it'd also\nmean paying to an actual (non-standard) script, rather than a scripthash,\nwhich would be annoying in its own way... And, really, adding that output\nto the txn would probably cost more in additional fees that it's going\nto pay you in any case.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-11-27T03:58:25",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> Hey,\n>\n> Suppose you have a lightning channel, with balances of exactly 2 BTC\n> on your side, and 1 BTC on the other (and 1mBTC for fees). You send a\n> micropayment of 42 satoshi across the channel, resulting in an updated\n> commitment that looks like:\n>\n>   in:\n>     anchor (3.001 BTC): [yoursig theirsig redeemscript]\n>\n>   out:\n>     1 BTC: [pay2pubkey(theirs)]\n>     1.99999958 BTC: [pay2pubkey(yours)]\n>     0.00000042 BTC: [pay2scripthash(htlc to them with R or you after\n>                      timeout)]\n>\n> But the third output will hit the IsDust() test (less than 546 satoshi\n> for a min relay fee of 0.01 mBTC) and the entire transaction will be\n> rejected, so the channel can't be closed at all!\n>\n> This is a similar problem to sub 1-satoshi payments, but it's different\n> in that while you can't represent them as an HTLC output, you can\n> represent them as soon as they complete -- ie:\n>\n>   out:\n>     1.00000042 BTC: [pay2pubkey(theirs)]\n>     1.99999958 BTC: [pay2pubkey(yours)]\n>\n> is completely legitimate (whereas an output of 1.0 + 0.042e-8 BTC\n> wouldn't be).\n>\n> I assume treating them much the same way is the only real option --\n> account for them exactly in the lightning state, but just approximate the\n> results in the actual commitments. So long as you're closing channels\n> infrequently, losing a few hundred satoshi here and there won't matter\n> much.\n\nYes, unfortunately we'll have to have a rule to avoid producing those\noutputs.\n\nI've opened https://github.com/ElementsProject/lightning/issues/14\nso we make sure we track this.\n\n> Another option might be to weaken the dust protection in the network --\n> eg if you made the dust output be\n>\n>     0.00000042 BTC: [(them && (R || revoke))\n>                      || (you && d CSV && t CLTV)\n>                      || (3 months CSV)]\n>\n> then anyone could clear the dust after 3 months if it weren't otherwise\n> claimed; maybe having some dust for a finite time is okay. But it'd also\n> mean paying to an actual (non-standard) script, rather than a scripthash,\n> which would be annoying in its own way... And, really, adding that output\n> to the txn would probably cost more in additional fees that it's going\n> to pay you in any case.\n\nAgreed, we'll just cull those outputs and let them go to fees.\n\nCheers,\nRusty."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-11-27T06:14:54",
                "message_text_only": "Another way to deal with it is to add two HTLCs to the commit, basically\n\n'I pay you 1.00000001 BTC and you pay me 1 BTC, so effectively I paid\nyou 1 satoshi'.\n\nIn reality we would of course use smaller 'transport-values'. Both of\nthese payments would pay to the same R value, so they would be atomic.\nOne issue with this is that it increases the fees by a lot, as the\nlocked up capital increases by quite a lot. It might also not\ntranslate that well over many hops, when fees are different in each\ndirection. We might want to have some special protocol for these\npayments?\n\nBy the way, as far as I know the dust value got increased to 5430? So\neven more of a problem for us now... (wow, that's already 2ct, don't\nthink we can just disallow these, given that we promised the holy\ngrail of micro payments ;) )\n\nI also don't think just adding these to the change amount is\nsustainable. That's a thing I realized some time ago, as soon as there\nis some loop hole somewhere, there will be one guy who will move\nheaven and earth to make a profit off of it.\n\nCheers\nMats\n\n2015-11-27 4:58 GMT+01:00 Rusty Russell <rusty at rustcorp.com.au>:\n> Anthony Towns <aj at erisian.com.au> writes:\n>> Hey,\n>>\n>> Suppose you have a lightning channel, with balances of exactly 2 BTC\n>> on your side, and 1 BTC on the other (and 1mBTC for fees). You send a\n>> micropayment of 42 satoshi across the channel, resulting in an updated\n>> commitment that looks like:\n>>\n>>   in:\n>>     anchor (3.001 BTC): [yoursig theirsig redeemscript]\n>>\n>>   out:\n>>     1 BTC: [pay2pubkey(theirs)]\n>>     1.99999958 BTC: [pay2pubkey(yours)]\n>>     0.00000042 BTC: [pay2scripthash(htlc to them with R or you after\n>>                      timeout)]\n>>\n>> But the third output will hit the IsDust() test (less than 546 satoshi\n>> for a min relay fee of 0.01 mBTC) and the entire transaction will be\n>> rejected, so the channel can't be closed at all!\n>>\n>> This is a similar problem to sub 1-satoshi payments, but it's different\n>> in that while you can't represent them as an HTLC output, you can\n>> represent them as soon as they complete -- ie:\n>>\n>>   out:\n>>     1.00000042 BTC: [pay2pubkey(theirs)]\n>>     1.99999958 BTC: [pay2pubkey(yours)]\n>>\n>> is completely legitimate (whereas an output of 1.0 + 0.042e-8 BTC\n>> wouldn't be).\n>>\n>> I assume treating them much the same way is the only real option --\n>> account for them exactly in the lightning state, but just approximate the\n>> results in the actual commitments. So long as you're closing channels\n>> infrequently, losing a few hundred satoshi here and there won't matter\n>> much.\n>\n> Yes, unfortunately we'll have to have a rule to avoid producing those\n> outputs.\n>\n> I've opened https://github.com/ElementsProject/lightning/issues/14\n> so we make sure we track this.\n>\n>> Another option might be to weaken the dust protection in the network --\n>> eg if you made the dust output be\n>>\n>>     0.00000042 BTC: [(them && (R || revoke))\n>>                      || (you && d CSV && t CLTV)\n>>                      || (3 months CSV)]\n>>\n>> then anyone could clear the dust after 3 months if it weren't otherwise\n>> claimed; maybe having some dust for a finite time is okay. But it'd also\n>> mean paying to an actual (non-standard) script, rather than a scripthash,\n>> which would be annoying in its own way... And, really, adding that output\n>> to the txn would probably cost more in additional fees that it's going\n>> to pay you in any case.\n>\n> Agreed, we'll just cull those outputs and let them go to fees.\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T08:52:02",
                "message_text_only": "On Fri, Nov 27, 2015 at 07:14:54AM +0100, Mats Jerratsch wrote:\n> Another way to deal with it is to add two HTLCs to the commit, basically\n> 'I pay you 1.00000001 BTC and you pay me 1 BTC, so effectively I paid\n> you 1 satoshi'.\n\nTrue! Doubles the cost of the HTLC if it gets published to the\nblockchain though...\n\n> One issue with this is that it increases the fees by a lot, as the\n> locked up capital increases by quite a lot. It might also not\n> translate that well over many hops, when fees are different in each\n> direction.\n\nI don't think number of hops matters; it only affects each channel\ndirectly (so hop1 pays a+b one way, and b the other way; hop2 pays\na-f+c one way, c the other way; etc), a as the transaction amount,\nf as b's fee, b and c arbitrary channel parameters for a/b and b/c\nchannels respectively.\n\nYou only have to lock up a little more than the dust amount, so call that\n1c per HTLC, assume a locktime of 20 days, and a time cost of bitcoin\nof 20% pa, then that's an extra cost of 0.01 of a cent per transaction.\nIf you're aiming for a 1% per-hop fee, you can still handle transactions\nworth about a cent with that approach. If you've got a time cost of\nbitcoin at about 5% pa and a lock time of 10 days, you can do a 2c\ntransaction with a per-hop fee of about 0.1%.\n\n> We might want to have some special protocol for these\n> payments?\n\nI don't think that helps?\n\n> By the way, as far as I know the dust value got increased to 5430? So\n> even more of a problem for us now... (wow, that's already 2ct, don't\n> think we can just disallow these, given that we promised the holy\n> grail of micro payments ;) )\n\nI don't think so? minrelayfee got increased to .05 mBTC, but that's for\n1000 bytes while the dust threshold is for 546 bytes, so that's 2730\nsatoshi (a little under 1c at $351 USD/BTC).\n\nAccording to Visa, anything less than $20 is a micropayment though, so\nthere's still plenty of leeway ;)\n\nhttp://www.techworld.com.au/article/351015/visa_payclick_takes_paypal_micropayments/\n\n> I also don't think just adding these to the change amount is\n> sustainable. That's a thing I realized some time ago, as soon as there\n> is some loop hole somewhere, there will be one guy who will move\n> heaven and earth to make a profit off of it.\n\nYeah, and with onion routing and so on, I could be that guy!!\n\nIf you anonymously setup two channels with another node, and route a whole\nbunch of dust payments to yourself, ie me1 -> them -> me2, then:\n\n - if the HTLCs are in both txns, you can't do anything\n\n - if the second channel's commitment unconditionally pays you for a\n   bunch of transactions, close the channel, and never reveal any of\n   the secrets.  you eventually get all your money back in me1, and made\n   a profit in me2.\n\n - if the first channel's commitment doesn't debit you for a bunch\n   of transactions, reveal the corresponding secrets in the second\n   channel, updating its commitment, but refuse to follow protocol to\n   update the transactions in the first channel, closing it, but keeping\n   your money.\n\n - if txns in the second channel are credited to fees, but have HTLCs\n   in the first channel; close the second channel, and the txns timeout,\n   refunding your money, but costing the other node the sum of those\n   HTLCs.\n\nYay, more problems!\n\nMaybe you could tweak the dual HTLC approach to make attacks unattractive:\n\n  42 satoshi from A -> B\n\n  10042 satoshi for (B && R || A && 20days CLTV)\n  10000 satoshi for (A && R && 15 days CLTV || B && 20days CLTV)\n\nIf it resolves on channel, fine; but if it hits the blockchain, A has to\nwait 15 days even if R gets revealed to get her 3.5c back.\n\nNot actually sure if that does any real good though...\n\nCheers,\naj\n\n> 2015-11-27 4:58 GMT+01:00 Rusty Russell <rusty at rustcorp.com.au>:\n> > Anthony Towns <aj at erisian.com.au> writes:\n> >> Hey,\n> >>\n> >> Suppose you have a lightning channel, with balances of exactly 2 BTC\n> >> on your side, and 1 BTC on the other (and 1mBTC for fees). You send a\n> >> micropayment of 42 satoshi across the channel, resulting in an updated\n> >> commitment that looks like:\n> >>\n> >>   in:\n> >>     anchor (3.001 BTC): [yoursig theirsig redeemscript]\n> >>\n> >>   out:\n> >>     1 BTC: [pay2pubkey(theirs)]\n> >>     1.99999958 BTC: [pay2pubkey(yours)]\n> >>     0.00000042 BTC: [pay2scripthash(htlc to them with R or you after\n> >>                      timeout)]\n> >>\n> >> But the third output will hit the IsDust() test (less than 546 satoshi\n> >> for a min relay fee of 0.01 mBTC) and the entire transaction will be\n> >> rejected, so the channel can't be closed at all!\n> >>\n> >> This is a similar problem to sub 1-satoshi payments, but it's different\n> >> in that while you can't represent them as an HTLC output, you can\n> >> represent them as soon as they complete -- ie:\n> >>\n> >>   out:\n> >>     1.00000042 BTC: [pay2pubkey(theirs)]\n> >>     1.99999958 BTC: [pay2pubkey(yours)]\n> >>\n> >> is completely legitimate (whereas an output of 1.0 + 0.042e-8 BTC\n> >> wouldn't be).\n> >>\n> >> I assume treating them much the same way is the only real option --\n> >> account for them exactly in the lightning state, but just approximate the\n> >> results in the actual commitments. So long as you're closing channels\n> >> infrequently, losing a few hundred satoshi here and there won't matter\n> >> much.\n> >\n> > Yes, unfortunately we'll have to have a rule to avoid producing those\n> > outputs.\n> >\n> > I've opened https://github.com/ElementsProject/lightning/issues/14\n> > so we make sure we track this.\n> >\n> >> Another option might be to weaken the dust protection in the network --\n> >> eg if you made the dust output be\n> >>\n> >>     0.00000042 BTC: [(them && (R || revoke))\n> >>                      || (you && d CSV && t CLTV)\n> >>                      || (3 months CSV)]\n> >>\n> >> then anyone could clear the dust after 3 months if it weren't otherwise\n> >> claimed; maybe having some dust for a finite time is okay. But it'd also\n> >> mean paying to an actual (non-standard) script, rather than a scripthash,\n> >> which would be annoying in its own way... And, really, adding that output\n> >> to the txn would probably cost more in additional fees that it's going\n> >> to pay you in any case.\n> >\n> > Agreed, we'll just cull those outputs and let them go to fees."
            },
            {
                "author": "Nicolas Dorier",
                "date": "2015-11-27T07:13:08",
                "message_text_only": "As I documented on https://github.com/ElementsProject/lightning/issues/14 the\nproblem is not easily solved because the dust amount is not constant. It\ndepends on minTxRelayFee which itself depends on the mempool state of each\nnode.\n\nA way to decouple mintxrelayfee from dust is needed. I proposed to tie the\ndust definition to transaction's fee. But had problem during implementation\nbecause of some circular dependency.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151127/660ad76e/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2015-11-27T09:46:05",
                "message_text_only": "On Nov 27, 2015 8:13 AM, \"Nicolas Dorier\" <nicolas.dorier at gmail.com> wrote:\n>\n> As I documented on https://github.com/ElementsProject/lightning/issues/14 the\nproblem is not easily solved because the dust amount is not constant. It\ndepends on minTxRelayFee which itself depends on the mempool state of each\nnode.\n\nI don think this is the case, IsDust depends on the minTxRelayFee global\nfrom main, but it's not dynamic like the one used in the mempool.\nIf the global minTxRelayFee has been made dynamic without me noticing, it\nshould be easy to separate a dynamic and static one though.\n\n> A way to decouple mintxrelayfee from dust is needed. I proposed to tie\nthe dust definition to transaction's fee. But had problem during\nimplementation because of some circular dependency.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151127/44d1e3c3/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Committing to dust",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Jorge Tim\u00f3n",
                "Nicolas Dorier",
                "Rusty Russell",
                "Mats Jerratsch"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 16358
        }
    },
    {
        "title": "[Lightning-dev] Payment channel without timeout protected from malleability",
        "thread_messages": [
            {
                "author": "Nicolas Dorier",
                "date": "2015-11-27T07:37:04",
                "message_text_only": "By adapting an idea from gmaxwell (\nhttps://bitcointalk.org/index.php?topic=303088.0) it is possible to open a\nchannel without suffering from malleability attack.\n\nThe process for A to open channel with B is the following:\n\n* A asks B pubkey\n* A create the first commitment transaction\n* A extract the hash that B needs to sign to be able to broadcast the\ncommitment\n* A asks B to sign the hash, but do not disclose the commitment\n* A broadcast the anchor\n* After confirmation, A announce the anchor to B.\n\nB can't identify A's anchor before announcement because he does not know\nthe P2SH of the multisig.\n\nAm I missing something ?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151127/f2d6361b/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T09:09:46",
                "message_text_only": "On Fri, Nov 27, 2015 at 04:37:04PM +0900, Nicolas Dorier wrote:\n> By adapting an idea from gmaxwell (\n> https://bitcointalk.org/index.php?topic=303088.0) it is possible to open a\n> channel without suffering from malleability attack.\n> The process for A to open channel with B is the following:\n> * A asks B pubkey\n> * A create the first commitment transaction\n> * A extract the hash that B needs to sign to be able to broadcast the\n> commitment\n> * A asks B to sign the hash, but do not disclose the commitment\n> * A broadcast the anchor\n> * After confirmation, A announce the anchor to B.\n\nA also passes the original unsigned commitment to B, who verifies that\nit's in the right format (ie, can be revoked), and hashes to the hash\nthat he signed.\n\n> B can't identify A's anchor before announcement because he does not know\n> the P2SH of the multisig.\n> Am I missing something ?\n\nSomeone other than B (ie a third party) could malleate the anchor between\nbroadcast and confirmation just for their own amusement.\n\nB can't reuse pubkeys between different channels with this protocol\neither, but that's good practice anyway.\n\n>From the same forum post, using child-pays-for-parent seems plausible.\nDoing:\n\n  txA: spend 6 BTC to\n     5 BTC to A&B\n     1 BTC to A\n\n  txB: spend 1 BTC from txA:1 to\n     0.999 BTC to A\n\nshould be pretty safe: either someone malleates txA and mines it for\n0 fee; or they mine both txA+txB for 0.001 BTC fee, and txA can't be\nmalleated. But CPFP doesn't work yet, and segregated witness seems like\nit'll happen sooner anyway?\n\nCheers,\naj"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2015-11-27T16:18:21",
                "message_text_only": "> A also passes the original unsigned commitment to B, who verifies that\n> it's in the right format (ie, can be revoked), and hashes to the hash\n> that he signed.\n\nNo, if A pass the unsigned commitment to B then B can malleate the anchor.\n(because B would know the txid of the anchor at broadcast time)\nB does not have to verify it is in right format, because he does not have\nanything to loose by signing a random hash.\nB can verify he signed the hash of the first commitment after A announce\nhis already confirmed anchor.\n\n> Someone other than B (ie a third party) could malleate the anchor between\n> broadcast and confirmation just for their own amusement.\n\nYes, actually the only malleability vector which B can use to his advantage\nis HighS, not all BIP62 vectors.\nKnowing miners will most likely run at least 0.11.2 (if CLTV is acceepted)\nHighS should be more likely rejected.\n\n> B can't reuse pubkeys between different channels with this protocol\n> either, but that's good practice anyway.\n\nRight, neither A should. If A reuse a key, then B can guess the redeem\nhash, then would identify the transaction to malleate at broadcast time,\nbefore A's announcement.\n\nI'd prefer seggregated witness to fix the problem cleanly, but I think that\nopening the channel as I said is a good enough workaround until it happen.\nThe only attack B can try is malleate all transaction to HighS.\nWhen CLTV will pass, there is not lot of probability of such attack to\nsucceed, because bitcoind should block HighS.\n\n> 'without timeout' is only possible with OP_CSV - not naturally\nwith what we have currently. ;)\n\nThe anchor does not have to use OP_CSV at all. But yes, for commitment, I'm\nassuming OP_CSV passed.\n\n> To be able to build a valid payment channel on top of the anchor,\nB has to be sure that A cannot get her money back at any point in the\nfuture. Given just a hash that B should sign, B has no clue what is\nthe output of the transaction he just signed.\n\nActually B do not care about it. Remember I am separating \"A's anchor\nbroadcast\" from \"A's announcement of anchor to B\".\nWhen A announce the anchor, then B can check if he really signed the first\ncommitment or something else, but he can't malleate anything since the\nanchor is already confirmed.\nB does not have anything to loose by signing unknown hash. (if he use a non\nreusable key)\n\nAgain, yes, a network-wide HighS attack would be the only way to malleate\nthe anchor.\nIf CLTV fork pass, then it is fair to consider that the odd of such attack\nsucceeding is very low. HighS should be blocked from 0.11.1 if I remember\nwell.\n\n\nOn Fri, Nov 27, 2015 at 6:09 PM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Fri, Nov 27, 2015 at 04:37:04PM +0900, Nicolas Dorier wrote:\n> > By adapting an idea from gmaxwell (\n> > https://bitcointalk.org/index.php?topic=303088.0) it is possible to\n> open a\n> > channel without suffering from malleability attack.\n> > The process for A to open channel with B is the following:\n> > * A asks B pubkey\n> > * A create the first commitment transaction\n> > * A extract the hash that B needs to sign to be able to broadcast the\n> > commitment\n> > * A asks B to sign the hash, but do not disclose the commitment\n> > * A broadcast the anchor\n> > * After confirmation, A announce the anchor to B.\n>\n> A also passes the original unsigned commitment to B, who verifies that\n> it's in the right format (ie, can be revoked), and hashes to the hash\n> that he signed.\n>\n> > B can't identify A's anchor before announcement because he does not know\n> > the P2SH of the multisig.\n> > Am I missing something ?\n>\n> Someone other than B (ie a third party) could malleate the anchor between\n> broadcast and confirmation just for their own amusement.\n>\n> B can't reuse pubkeys between different channels with this protocol\n> either, but that's good practice anyway.\n>\n> From the same forum post, using child-pays-for-parent seems plausible.\n> Doing:\n>\n>   txA: spend 6 BTC to\n>      5 BTC to A&B\n>      1 BTC to A\n>\n>   txB: spend 1 BTC from txA:1 to\n>      0.999 BTC to A\n>\n> should be pretty safe: either someone malleates txA and mines it for\n> 0 fee; or they mine both txA+txB for 0.001 BTC fee, and txA can't be\n> malleated. But CPFP doesn't work yet, and segregated witness seems like\n> it'll happen sooner anyway?\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151128/454bf694/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-11-27T20:11:13",
                "message_text_only": "On Sat, Nov 28, 2015 at 01:18:21AM +0900, Nicolas Dorier wrote:\n> > A also passes the original unsigned commitment to B, who verifies that\n> > it's in the right format (ie, can be revoked), and hashes to the hash\n> > that he signed.\n> No, if A pass the unsigned commitment to B then B can malleate the anchor.\n\nSorry, I meant the above needs to happen after the anchor's confirmed\nin the blockchain (and A's told B about the anchor).\n\n> > B can't reuse pubkeys between different channels with this protocol\n> > either, but that's good practice anyway.\n> Right, neither A should. If A reuse a key, then B can guess the redeem\n> hash, then would identify the transaction to malleate at broadcast time,\n> before A's announcement.\n\nB will be providing a signature for a tx that:\n\n - has the anchor as input\n - has a single refund output payable to\n     (A && OP_CSV) | (B && OP_HASH <revoke> OP_EQUALVERIFY)\n\nBut B won't be able to guess what the <revoke> hash is, so won't be\nable to correlate with potential anchor transactions at all, afaics,\neven if pubkeys <A> and <B> are both known to B?\n\n> I'd prefer seggregated witness to fix the problem cleanly, but I think that\n> opening the channel as I said is a good enough workaround until it happen.\n\nYeah, it's 99% of the way there; I just worry about random vandalism,\npersonally.\n\nCheers,\naj"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2015-11-27T21:46:34",
                "message_text_only": "> But B won't be able to guess what the <revoke> hash is, so won't be\n> able to correlate with potential anchor transactions at all, afaics,\n> even if pubkeys <A> and <B> are both known to B?\n\nDid not thought about that, yes you are right.\n\n> Yeah, it's 99% of the way there; I just worry about random vandalism,\n> personally.\n\nYes, I was worrying about B pro actively malleating everything.\nBut since A controls broadcast time, he can choose to delay the broadcast\nwhen a vast malleability attack happens.\n\n\nOn Sat, Nov 28, 2015 at 5:11 AM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Sat, Nov 28, 2015 at 01:18:21AM +0900, Nicolas Dorier wrote:\n> > > A also passes the original unsigned commitment to B, who verifies that\n> > > it's in the right format (ie, can be revoked), and hashes to the hash\n> > > that he signed.\n> > No, if A pass the unsigned commitment to B then B can malleate the\n> anchor.\n>\n> Sorry, I meant the above needs to happen after the anchor's confirmed\n> in the blockchain (and A's told B about the anchor).\n>\n> > > B can't reuse pubkeys between different channels with this protocol\n> > > either, but that's good practice anyway.\n> > Right, neither A should. If A reuse a key, then B can guess the redeem\n> > hash, then would identify the transaction to malleate at broadcast time,\n> > before A's announcement.\n>\n> B will be providing a signature for a tx that:\n>\n>  - has the anchor as input\n>  - has a single refund output payable to\n>      (A && OP_CSV) | (B && OP_HASH <revoke> OP_EQUALVERIFY)\n>\n> But B won't be able to guess what the <revoke> hash is, so won't be\n> able to correlate with potential anchor transactions at all, afaics,\n> even if pubkeys <A> and <B> are both known to B?\n>\n> > I'd prefer seggregated witness to fix the problem cleanly, but I think\n> that\n> > opening the channel as I said is a good enough workaround until it\n> happen.\n>\n> Yeah, it's 99% of the way there; I just worry about random vandalism,\n> personally.\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151128/ea994660/attachment-0001.html>"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-11-27T09:10:13",
                "message_text_only": "Hm interesting.\n\nCouple of remarks:\n\n(1) 'without timeout' is only possible with OP_CSV - not naturally\nwith what we have currently. ;)\n\n(2) To be able to build a valid payment channel on top of the anchor,\nB has to be sure that A cannot get her money back at any point in the\nfuture. Given just a hash that B should sign, B has no clue what is\nthe output of the transaction he just signed. But I guess we can solve\nthis by B demanding the transaction he signed before proceeding to\naccept any payments. B can then reassure himself that this transaction\nindeed resolves to the hash he signed and that it is revocable by B\nwith any following commitments. Beside the pubkey we also need some\nrevocation hash provided by B for creating the commitment transaction.\n\n(3) While this is a fair setup already, it does only protect us\nagainst targeted attacks against a specific transaction. An attacker\ncould still mine a block with all P2SH transactions (probably not even\nthat many) changed. If you have a large amount of hashing power, you\ncan open up channels with hundreds of parties and then start attacking\nthe network. It can be mitigated by waiting some time before\nbroadcasting his anchor, but even then it remains some hack, and\ntheres some chance someone will lose money doing that.\n\n2015-11-27 8:37 GMT+01:00 Nicolas Dorier <nicolas.dorier at gmail.com>:\n> By adapting an idea from gmaxwell\n> (https://bitcointalk.org/index.php?topic=303088.0) it is possible to open a\n> channel without suffering from malleability attack.\n>\n> The process for A to open channel with B is the following:\n>\n> * A asks B pubkey\n> * A create the first commitment transaction\n> * A extract the hash that B needs to sign to be able to broadcast the\n> commitment\n> * A asks B to sign the hash, but do not disclose the commitment\n> * A broadcast the anchor\n> * After confirmation, A announce the anchor to B.\n>\n> B can't identify A's anchor before announcement because he does not know the\n> P2SH of the multisig.\n>\n> Am I missing something ?\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Payment channel without timeout protected from malleability",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Nicolas Dorier",
                "Mats Jerratsch"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 12614
        }
    }
]