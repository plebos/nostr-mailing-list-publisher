[
    {
        "title": "[Lightning-dev] Transaction revocation within transaction malleability via anyone-can-revoke hashlocks",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2017-05-01T04:33:07",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> Hi ZmnSCPxj!\n>\n> Good morning Rusty, thank you for your reply.\n> From what I can gather so far, it seems, the issue of transaction revocation even with transaction malleability appears to be solved. Although, I want to know, is my idea (which support selfish untrustworthy watchers) better than what Lightning now has? Or has different tradeoffs? It seems to me, at first glance, if the revocation key in my idea is not publicized but sent only to the counterparty, it is effectively equivalent to the current technique. But the receiving counterparty has the option of publishing this revocation key in order to allow anyone to enforce and get free money, even with malleability.\n\nThat's true, actually.  You can certainly have trusted watchers know\nyour revocation keys (and they have a very compact form, so the storage\nis ~log2(num-transactions).\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-02T14:25:41",
                "message_text_only": "Good morning Rusty,\n\n>ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n>> From what I can gather so far, it seems, the issue of transaction revocation even with transaction malleability appears to be solved. Although, I want to know, is my idea (which support selfish untrustworthy watchers) better than what Lightning now has? Or has different tradeoffs? It seems to me, at first glance, if the revocation key in my idea is not publicized but sent only to the counterparty, it is effectively equivalent to the current technique. But the receiving counterparty has the option of publishing this revocation key in order to allow anyone to enforce and get free money, even with malleability.\n>\n>That's true, actually.\n\nDo you think it's a good idea to publish revocation keys, and have the condition (Alice && revokekey) || (CSV + 1 && revokekey) || (CSV + 2 && Bob)? That way, you can revoke immediately if iyu are online, or anyone (including Bob) can poach it if you let the CSV+1 lapse (the hope is, Bob's probability of poaching via this method is low, so, it will disincentivize Bob). If you don't want anyone to poach the money via anyone-can-revoke, you can keep the revocation key to yourself, but you must ensure you can get online before the CSV+2 period arrives.\n\n>You can certainly have trusted watchers know\n>your revocation keys (and they have a very compact form, so the storage\n>is ~log2(num-transactions).\n\nMaybe, you mean, counterparty's revocation key? (sorry, I want to confirm my understanding of low level of Lightning Network)\n\nOr is there some advantage to give your own revocation key to another trusted person?\n\n(I'm considering, \"your revocation key\" is the revocation key that invalidates the output that goes to you, or is my understanding wrong?)\n\nRegards,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170502/efecb159/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-05T02:36:31",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> Good morning Rusty,\n>\n>>ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n>>> From what I can gather so far, it seems, the issue of transaction revocation even with transaction malleability appears to be solved. Although, I want to know, is my idea (which support selfish untrustworthy watchers) better than what Lightning now has? Or has different tradeoffs? It seems to me, at first glance, if the revocation key in my idea is not publicized but sent only to the counterparty, it is effectively equivalent to the current technique. But the receiving counterparty has the option of publishing this revocation key in order to allow anyone to enforce and get free money, even with malleability.\n>>\n>>That's true, actually.\n>\n> Do you think it's a good idea to publish revocation keys, and have the condition (Alice && revokekey) || (CSV + 1 && revokekey) || (CSV + 2 && Bob)? That way, you can revoke immediately if iyu are online, or anyone (including Bob) can poach it if you let the CSV+1 lapse (the hope is, Bob's probability of poaching via this method is low, so, it will disincentivize Bob). If you don't want anyone to poach the money via anyone-can-revoke, you can keep the revocation key to yourself, but you must ensure you can get online before the CSV+2 period arrives.\n\nI think it's a good idea to use segwit, and not rely on these kind of\ngames...\n\n>>You can certainly have trusted watchers know\n>>your revocation keys (and they have a very compact form, so the storage\n>>is ~log2(num-transactions).\n>\n> Maybe, you mean, counterparty's revocation key? (sorry, I want to confirm my understanding of low level of Lightning Network)\n\nAh, terminology?  I meant A could share the key which allows A to spend\nB's old commitment transactions.\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-05T05:00:17",
                "message_text_only": "Good morning Rusty,\n\n>> Do you think it's a good idea to publish revocation keys, and have the condition (Alice && revokekey) || (CSV + 1 && revokekey) || (CSV + 2 && Bob)? That way, you can revoke immediately if iyu are online, or anyone (including Bob) can poach it if you let the CSV+1 lapse (the hope is, Bob's probability of poaching via this method is low, so, it will disincentivize Bob). If you don't want anyone to poach the money via anyone-can-revoke, you can keep the revocation key to yourself, but you must ensure you can get online before the CSV+2 period arrives.\n\n>I think it's a good idea to use segwit, and not rely on these kind of\n>games...\n\nI understand.\n\n>>>You can certainly have trusted watchers know\n>>>your revocation keys (and they have a very compact form, so the storage\n>>>is ~log2(num-transactions).\n>>\n>> Maybe, you mean, counterparty's revocation key? (sorry, I want to confirm my understanding of low level of Lightning Network)\n>\n>Ah, terminology? I meant A could share the key which allows A to spend\n>B's old commitment transactions.\n\nThank you very much your explanation!\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170505/3c563142/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Transaction revocation within transaction malleability via anyone-can-revoke hashlocks",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 6004
        }
    },
    {
        "title": "[Lightning-dev] [RFC] Lightning payment format",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2017-05-01T18:03:08",
                "message_text_only": "Hi Rusty,\n\nI was thinking of proposing something similar recently, but looks like you\nbeat me to it!\n\nI really like the flexibility of the tag format. Over the past few months, I\nthought of quite a bit of things application developers can do by utilizing\na tag-based payment request format in conjunction with either: the spare\nbytes of the onion payload or an abuse of the encrypted back errors (in\ncombo with some onion payload bytes).\n\nOn the topic of bech32: I'm all for piggybacking on existing emerging\nstandards in the space, but I'm not convinced we really gain anything by\nusing it outside of the initial prefix. The human-readable amount within the\nprefix is nice for UX as you can eyeball exactly how much one is about to\npay/receive. However, these payment requests can get rather long, so I don't\nenvision any user typing them out by hand or reading them to someone over\nthe phone.  As a result, I don't think we have much use for bech32 character\nwhich has been optimized for manual-entry.  Additionally, as this proposal\nincludes a signature that covers the entire payreq, what's the use of the\nadded checksum? Detecting 3 characters out of 1024+ is rather\ninsignificant.\n\nOn the topic of signatures: as is proposed now, a user isn't able to verify\nthe validity of the signature (and thereby authenticity of the payreq and\nintegrity of the contents) without first having a (direction || chanID) ->\npubKey mapping. In my opinion, the payreqs are already so long that\noptimizing for size is a bit of a waste. By replacing the chanID with the\ncompressed serialized public key, users will be able to immediately verify\nthe signature without the use of an external mapping.\n\nI think this is a good step in the right direction. However, it utilizes an\nencoding whose rationale make sense for the Bitcoin address use-case, but in\nmy opinion, doesn't carry over those compelling traits to the LN payreq\nuse-case.\n\n-- Laolu\n\n\nOn Fri, Apr 28, 2017 at 5:57 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Hi all!\n>\n>         I threw together this draft format for requesting lightning\n> payments, and an (incomplete) implementation:\n>\n> - https://github.com/rustyrussell/lightning-payencode\n>\n> The representation size ranges from ~181 characters upwards: we could\n> squeeze at least 5 of those out if we cared.  Bech32 only guarantees to\n> detect 3 errors at these lengths (beyond 1024 it's only 1), but the\n> signature is the final error detection.\n>\n> You'll notice one optimization for the common case: we use the 8-byte\n> chanid (stealing 1 bit) to compactly refer to the destination.  This is\n> shorter than a full 33-byte pubkey, and relies on the fact that the\n> network topology is well-known.  We use these same style of IDs in\n> the channel announcement messages already.\n>\n> I look forward to both the bikeshed comments, and more substantive\n> feedback :)\n>\n> Thanks!\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170501/98cf78f1/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-02T00:40:17",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> Hi Rusty,\n>\n> I was thinking of proposing something similar recently, but looks like you\n> beat me to it!\n>\n> I really like the flexibility of the tag format. Over the past few months, I\n> thought of quite a bit of things application developers can do by utilizing\n> a tag-based payment request format in conjunction with either: the spare\n> bytes of the onion payload or an abuse of the encrypted back errors (in\n> combo with some onion payload bytes).\n\nYes, I thought about this too, but I'm reluctant to assign those onion\nbytes as they're a limited resource.  Easy to add later, though.\n\n> On the topic of bech32: I'm all for piggybacking on existing emerging\n> standards in the space, but I'm not convinced we really gain anything by\n> using it outside of the initial prefix. The human-readable amount within the\n> prefix is nice for UX as you can eyeball exactly how much one is about to\n> pay/receive. However, these payment requests can get rather long, so I don't\n> envision any user typing them out by hand or reading them to someone over\n> the phone.  As a result, I don't think we have much use for bech32 character\n> which has been optimized for manual-entry.  Additionally, as this proposal\n> includes a signature that covers the entire payreq, what's the use of the\n> added checksum? Detecting 3 characters out of 1024+ is rather\n> insignificant.\n\nI kind of agree, but I think the code reuse outweighs other arguments,\nsince codebases are going to have bech32 anyway.\n\nThe minimal theoretical size we can do is 20 (payment hash160) + 64\n(signature).  We'd have to change the protocol to use hash160 instead of\nsha256 (we already do this onchain).  But even that is 135 characters,\nwhich is not going to be entered by hand, so I don't think it's worth\nit.\n\n> On the topic of signatures: as is proposed now, a user isn't able to verify\n> the validity of the signature (and thereby authenticity of the payreq and\n> integrity of the contents) without first having a (direction || chanID) ->\n> pubKey mapping. In my opinion, the payreqs are already so long that\n> optimizing for size is a bit of a waste. By replacing the chanID with the\n> compressed serialized public key, users will be able to immediately verify\n> the signature without the use of an external mapping.\n\nAs you pointed out offline, we can do key recovery from the signature[1],\nso the information is there already in fact :)  The chanid is really a\ncourtesy, from this POV.\n\n> I think this is a good step in the right direction. However, it utilizes an\n> encoding whose rationale make sense for the Bitcoin address use-case, but in\n> my opinion, doesn't carry over those compelling traits to the LN payreq\n> use-case.\n\nThanks!\nRusty.\n[1]  You also pointed out that we can use the same technique to remove\n     node-id and bitcoin-key from the channel announcement.  Which would\n     be awesome magic..."
            },
            {
                "author": "Pierre",
                "date": "2017-05-02T16:11:29",
                "message_text_only": ">> On the topic of signatures: as is proposed now, a user isn't able to verify\n>> the validity of the signature (and thereby authenticity of the payreq and\n>> integrity of the contents) without first having a (direction || chanID) ->\n>> pubKey mapping. In my opinion, the payreqs are already so long that\n>> optimizing for size is a bit of a waste. By replacing the chanID with the\n>> compressed serialized public key, users will be able to immediately verify\n>> the signature without the use of an external mapping.\n\nAs much as I pushed for using the short chanID in the onion, I too am\na reluctant to use\nit here. In addition to laolu's arguments, I would say:\n- making the assumption that the network is well-known doesn't take\ninto account the fact\nthat announcements take time to propagate through the network\n(typically a few minutes with\nstaggered broadcast every minute); ok it doesn't change often, but now\nwe will need to worry\nabout not using our most recently created/closed channels as reference.\n- we already know that we won't always be able to have a full view of\nthe network in\nthe future, so I feel like we should rely on it as less as possible\n- since payment requests are sent out-of-band, optimizing their size\nis maybe not as\nimportant as messages exchanged on the p2p network?\n\n>As you pointed out offline, we can do key recovery from the signature[1],\n>so the information is there already in fact :)  The chanid is really a\n>courtesy, from this POV.\n\nThat is really amazing! Why not completely ditch the chanid then? ;-)\n\nCheers,\n\nPierre\n\n2017-05-02 2:40 GMT+02:00 Rusty Russell <rusty at rustcorp.com.au>:\n> Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n>> Hi Rusty,\n>>\n>> I was thinking of proposing something similar recently, but looks like you\n>> beat me to it!\n>>\n>> I really like the flexibility of the tag format. Over the past few months, I\n>> thought of quite a bit of things application developers can do by utilizing\n>> a tag-based payment request format in conjunction with either: the spare\n>> bytes of the onion payload or an abuse of the encrypted back errors (in\n>> combo with some onion payload bytes).\n>\n> Yes, I thought about this too, but I'm reluctant to assign those onion\n> bytes as they're a limited resource.  Easy to add later, though.\n>\n>> On the topic of bech32: I'm all for piggybacking on existing emerging\n>> standards in the space, but I'm not convinced we really gain anything by\n>> using it outside of the initial prefix. The human-readable amount within the\n>> prefix is nice for UX as you can eyeball exactly how much one is about to\n>> pay/receive. However, these payment requests can get rather long, so I don't\n>> envision any user typing them out by hand or reading them to someone over\n>> the phone.  As a result, I don't think we have much use for bech32 character\n>> which has been optimized for manual-entry.  Additionally, as this proposal\n>> includes a signature that covers the entire payreq, what's the use of the\n>> added checksum? Detecting 3 characters out of 1024+ is rather\n>> insignificant.\n>\n> I kind of agree, but I think the code reuse outweighs other arguments,\n> since codebases are going to have bech32 anyway.\n>\n> The minimal theoretical size we can do is 20 (payment hash160) + 64\n> (signature).  We'd have to change the protocol to use hash160 instead of\n> sha256 (we already do this onchain).  But even that is 135 characters,\n> which is not going to be entered by hand, so I don't think it's worth\n> it.\n>\n>> On the topic of signatures: as is proposed now, a user isn't able to verify\n>> the validity of the signature (and thereby authenticity of the payreq and\n>> integrity of the contents) without first having a (direction || chanID) ->\n>> pubKey mapping. In my opinion, the payreqs are already so long that\n>> optimizing for size is a bit of a waste. By replacing the chanID with the\n>> compressed serialized public key, users will be able to immediately verify\n>> the signature without the use of an external mapping.\n>\n> As you pointed out offline, we can do key recovery from the signature[1],\n> so the information is there already in fact :)  The chanid is really a\n> courtesy, from this POV.\n>\n>> I think this is a good step in the right direction. However, it utilizes an\n>> encoding whose rationale make sense for the Bitcoin address use-case, but in\n>> my opinion, doesn't carry over those compelling traits to the LN payreq\n>> use-case.\n>\n> Thanks!\n> Rusty.\n> [1]  You also pointed out that we can use the same technique to remove\n>      node-id and bitcoin-key from the channel announcement.  Which would\n>      be awesome magic...\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2017-05-03T15:37:14",
                "message_text_only": "Hi Rusty,\n\nPayment requests should also include a timestamp and an expiry date (they\ncould be optional tagged items but I think it makes more sense to make them\nmandatory)\n\u200b\nThanks!\nFabrice\u200b\n\n\nOn 2 May 2017 at 18:11, Pierre <pm+lists at acinq.fr> wrote:\n\n> >> On the topic of signatures: as is proposed now, a user isn't able to\n> verify\n> >> the validity of the signature (and thereby authenticity of the payreq\n> and\n> >> integrity of the contents) without first having a (direction || chanID)\n> ->\n> >> pubKey mapping. In my opinion, the payreqs are already so long that\n> >> optimizing for size is a bit of a waste. By replacing the chanID with\n> the\n> >> compressed serialized public key, users will be able to immediately\n> verify\n> >> the signature without the use of an external mapping.\n>\n> As much as I pushed for using the short chanID in the onion, I too am\n> a reluctant to use\n> it here. In addition to laolu's arguments, I would say:\n> - making the assumption that the network is well-known doesn't take\n> into account the fact\n> that announcements take time to propagate through the network\n> (typically a few minutes with\n> staggered broadcast every minute); ok it doesn't change often, but now\n> we will need to worry\n> about not using our most recently created/closed channels as reference.\n> - we already know that we won't always be able to have a full view of\n> the network in\n> the future, so I feel like we should rely on it as less as possible\n> - since payment requests are sent out-of-band, optimizing their size\n> is maybe not as\n> important as messages exchanged on the p2p network?\n>\n> >As you pointed out offline, we can do key recovery from the signature[1],\n> >so the information is there already in fact :)  The chanid is really a\n> >courtesy, from this POV.\n>\n> That is really amazing! Why not completely ditch the chanid then? ;-)\n>\n> Cheers,\n>\n> Pierre\n>\n> 2017-05-02 2:40 GMT+02:00 Rusty Russell <rusty at rustcorp.com.au>:\n> > Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> >> Hi Rusty,\n> >>\n> >> I was thinking of proposing something similar recently, but looks like\n> you\n> >> beat me to it!\n> >>\n> >> I really like the flexibility of the tag format. Over the past few\n> months, I\n> >> thought of quite a bit of things application developers can do by\n> utilizing\n> >> a tag-based payment request format in conjunction with either: the spare\n> >> bytes of the onion payload or an abuse of the encrypted back errors (in\n> >> combo with some onion payload bytes).\n> >\n> > Yes, I thought about this too, but I'm reluctant to assign those onion\n> > bytes as they're a limited resource.  Easy to add later, though.\n> >\n> >> On the topic of bech32: I'm all for piggybacking on existing emerging\n> >> standards in the space, but I'm not convinced we really gain anything by\n> >> using it outside of the initial prefix. The human-readable amount\n> within the\n> >> prefix is nice for UX as you can eyeball exactly how much one is about\n> to\n> >> pay/receive. However, these payment requests can get rather long, so I\n> don't\n> >> envision any user typing them out by hand or reading them to someone\n> over\n> >> the phone.  As a result, I don't think we have much use for bech32\n> character\n> >> which has been optimized for manual-entry.  Additionally, as this\n> proposal\n> >> includes a signature that covers the entire payreq, what's the use of\n> the\n> >> added checksum? Detecting 3 characters out of 1024+ is rather\n> >> insignificant.\n> >\n> > I kind of agree, but I think the code reuse outweighs other arguments,\n> > since codebases are going to have bech32 anyway.\n> >\n> > The minimal theoretical size we can do is 20 (payment hash160) + 64\n> > (signature).  We'd have to change the protocol to use hash160 instead of\n> > sha256 (we already do this onchain).  But even that is 135 characters,\n> > which is not going to be entered by hand, so I don't think it's worth\n> > it.\n> >\n> >> On the topic of signatures: as is proposed now, a user isn't able to\n> verify\n> >> the validity of the signature (and thereby authenticity of the payreq\n> and\n> >> integrity of the contents) without first having a (direction || chanID)\n> ->\n> >> pubKey mapping. In my opinion, the payreqs are already so long that\n> >> optimizing for size is a bit of a waste. By replacing the chanID with\n> the\n> >> compressed serialized public key, users will be able to immediately\n> verify\n> >> the signature without the use of an external mapping.\n> >\n> > As you pointed out offline, we can do key recovery from the signature[1],\n> > so the information is there already in fact :)  The chanid is really a\n> > courtesy, from this POV.\n> >\n> >> I think this is a good step in the right direction. However, it\n> utilizes an\n> >> encoding whose rationale make sense for the Bitcoin address use-case,\n> but in\n> >> my opinion, doesn't carry over those compelling traits to the LN payreq\n> >> use-case.\n> >\n> > Thanks!\n> > Rusty.\n> > [1]  You also pointed out that we can use the same technique to remove\n> >      node-id and bitcoin-key from the channel announcement.  Which would\n> >      be awesome magic...\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170503/3885b9e8/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-04T04:39:50",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> Hi Rusty,\n>\n> Payment requests should also include a timestamp and an expiry date (they\n> could be optional tagged items but I think it makes more sense to make them\n> mandatory)\n\nExcellent point.  Provability definitely requires a timestamp, but the\nduration could be optional.\n\nHere's the patch I just pushed:\n\nSubject: Add timestamp and (optional) expiry.\n\nWe take advantage of the variable length encoding for the expiry timestamp,\nand 32 bits for the offer time (wake me in 2106 to update the spec).\n\nI chose a reasonable default expiry of 1 hour; the intention is that\nthe software should warn if this expiry approaches.\n\nSuggested-by: Fabrice Drouin <fabrice.drouin at acinq.fr>\nSigned-off-by: Rusty Russell <rusty at rustcorp.com.au>\n\ndiff --git a/README.md b/README.md\nindex 3039333..6da4150 100644\n--- a/README.md\n+++ b/README.md\n@@ -11,6 +11,7 @@ Human readable part:\n \n And data part:\n 1. Version: 0 (5 bits)\n+1. UTC timestamp in seconds-since-Unix-epoch (32 bits)\n 1. Payment hash (256 bits)\n 1. Zero or more tagged parts.\n 1. Signature (bitcoin-style, of SHA256(SHA256(), plus recovery byte) of above. (520 bits)\n@@ -25,6 +26,7 @@ Currently defined tagged parts are:\n 1. h: description of purpose of payment (SHA256).  This is used to commit\n    to an associated description which is too long to fit, such as may\n    be contained in a web page.\n+1. x: expiry time in seconds. Default is 3600 (1 hour) if not specified.\n 1. f: fallback onchain-address.  20 bytes == p2pkh.  21 bytes == p2wpkh, 33 bytes == p2wsh.\n 1. r: extra routing information.  This should be appended to the route\n       to allow routing to non-public nodes; there may be more\ndiff --git a/examples.sh b/examples.sh\nindex 78c2be8..f526223 100755\n--- a/examples.sh\n+++ b/examples.sh\n@@ -11,8 +11,8 @@ echo \"# Please send 10 satoshi using rhash $RHASH to me @$PUBKEY\"\n ./lightning-address.py encode 10000 $RHASH $PRIVKEY\n echo\n \n-echo \"# Please send \\$3 for a cup of coffee to the same peer\"\n-./lightning-address.py encode --description='1 cup coffee' $((3 * 100000000000 / $CONVERSION_RATE)) $RHASH $PRIVKEY\n+echo \"# Please send \\$3 for a cup of coffee to the same peer, within 1 minute\"\n+./lightning-address.py encode --description='1 cup coffee' $((3 * 100000000000 / $CONVERSION_RATE)) --expires=60 $RHASH $PRIVKEY\n echo\n \n echo \"# Now send \\$24 for an entire list of things (hashed)\"\ndiff --git a/lightning-address.py b/lightning-address.py\nindex c43d020..7b72314 100755\n--- a/lightning-address.py\n+++ b/lightning-address.py\n@@ -3,6 +3,7 @@ import argparse\n import hashlib\n import re\n import sys\n+import time\n # Try 'pip3 install secp256k1'\n import secp256k1\n \n@@ -138,9 +139,24 @@ def u32list(val):\n     assert val < (1 << 32)\n     return bytearray([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff])\n \n+# Represent big-endian number with as many bytes as it takes.\n+def varlist(val):\n+    b = bytearray()\n+    while val != 0:\n+        b.append(val & 0xFF)\n+        val = val // 256\n+    b.reverse()\n+    return b\n+\n def from_u32list(l):\n     return (l[0] << 24) + (l[1] << 16) + (l[2] << 8) + l[3]\n \n+def from_varlist(l):\n+    total = 0\n+    for v in l:\n+        total = total * 256 + v\n+    return total\n+\n def tagged(char, l):\n     bits=convertbits(l, 8, 5)\n     assert len(bits) < (1 << 10)\n@@ -169,9 +185,12 @@ def lnencode(options):\n     \n     hrp = 'ln' + options.currency + amount\n     \n-    # version + paymenthash\n-    data = [0] + convertbits(bytearray.fromhex(options.paymenthash), 8, 5)\n+    # version + timestamp + paymenthash\n+    now = int(time.time())\n+    assert len(u32list(now) + bytearray.fromhex(options.paymenthash)) == 4 + 32\n+    data = [0] + convertbits(u32list(now) + bytearray.fromhex(options.paymenthash), 8, 5)\n     \n+\n     for r in options.route:\n         pubkey,channel,fee,cltv = r.split('/')\n         route = bytearray.fromhex(pubkey) + bytearray.fromhex(channel) + u32list(int(fee)) + u32list(int(cltv))\n@@ -183,7 +202,10 @@ def lnencode(options):\n     \n     if options.description:\n         data = data + tagged('d', [ord(c) for c in options.description])\n-    \n+\n+    if options.expires:\n+        data = data + tagged('x', varlist(options.expires))\n+        \n     if options.description_hashed:\n         data = data + tagged('h', hashlib.sha256(options.description_hashed.encode('utf-8')).digest())\n \n@@ -239,14 +261,16 @@ def lndecode(options):\n     if options.rate:\n         print(\"(Conversion: {})\".format(amount / 10**11 * float(options.rate)))\n \n-    # 32 bytes turns into 52 bytes when base32 encoded.\n-    if len(data) < 52:\n-        sys.exit(\"Not long enough to contain payment hash\")\n+    # 4 + 32 bytes turns into 58 bytes when base32 encoded.\n+    if len(data) < 58:\n+        sys.exit(\"Not long enough to contain timestamp and payment hash\")\n \n-    decoded = convertbits(data[:52], 5, 8, False)\n-    data = data[52:]\n-    assert len(decoded) == 32\n-    print(\"Payment hash: {}\".format(bytearray(decoded).hex()))\n+    decoded = convertbits(data[:58], 5, 8, False)\n+    data = data[58:]\n+    assert len(decoded) == 4 + 32\n+    tstamp = from_u32list(decoded[0:4])\n+    print(\"Timestamp: {} ({})\".format(tstamp, time.ctime(tstamp)))\n+    print(\"Payment hash: {}\".format(bytearray(decoded[4:]).hex()))\n \n     while len(data) > 0:\n         tag,tagdata,data = pull_tagged(data)\n@@ -265,6 +289,8 @@ def lndecode(options):\n             print(\"Description: {}\".format(''.join(chr(c) for c in tagdata)))\n         elif tag == 'h':\n             print(\"Description hash: {}\".format(bytearray(tagdata).hex()))\n+        elif tag == 'x':\n+            print(\"Expiry (seconds): {}\".format(from_varlist(tagdata)))\n         else:\n             print(\"UNKNOWN TAG {}: {}\".format(tag, bytearray(tagdata).hex()))\n \n@@ -286,6 +312,8 @@ parser_enc.add_argument('--description',\n                         help='What is being purchased')\n parser_enc.add_argument('--description-hashed',\n                         help='What is being purchased (for hashing)')\n+parser_enc.add_argument('--expires', type=int,\n+                        help='Seconds before offer expires')\n parser_enc.add_argument('amount', type=int, help='Amount in millisatoshi')\n parser_enc.add_argument('paymenthash', help='Payment hash (in hex)')\n parser_enc.add_argument('privkey', help='Private key (in hex)')"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-04T04:42:51",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n>>> On the topic of signatures: as is proposed now, a user isn't able to verify\n>>> the validity of the signature (and thereby authenticity of the payreq and\n>>> integrity of the contents) without first having a (direction || chanID) ->\n>>> pubKey mapping. In my opinion, the payreqs are already so long that\n>>> optimizing for size is a bit of a waste. By replacing the chanID with the\n>>> compressed serialized public key, users will be able to immediately verify\n>>> the signature without the use of an external mapping.\n>\n> As much as I pushed for using the short chanID in the onion, I too am\n> a reluctant to use\n> it here. In addition to laolu's arguments, I would say:\n> - making the assumption that the network is well-known doesn't take\n> into account the fact\n> that announcements take time to propagate through the network\n> (typically a few minutes with\n> staggered broadcast every minute); ok it doesn't change often, but now\n> we will need to worry\n> about not using our most recently created/closed channels as reference.\n> - we already know that we won't always be able to have a full view of\n> the network in\n> the future, so I feel like we should rely on it as less as possible\n> - since payment requests are sent out-of-band, optimizing their size\n> is maybe not as\n> important as messages exchanged on the p2p network?\n>\n>>As you pointed out offline, we can do key recovery from the signature[1],\n>>so the information is there already in fact :)  The chanid is really a\n>>courtesy, from this POV.\n>\n> That is really amazing! Why not completely ditch the chanid then? ;-)\n\nOK, I have done this.  I added another byte which you need to figure out\nwhich key to recover as there may be multiples.\n\nI will add a dependency on the python libsecp256k1 so I can update the\ntool.\n\nNote: we will lose this ability when we switch to Schnorr, apparently.\nBut then we'll have more data on actual usage by which to decide on\ntradeoffs.\n\nI've pushed this change.  Here's the patch:\n\nSubject: Drop channel ID in favor of key recovery.\n\nAs suggested by roasbeef (Olaoluwa Osuntokun).  We add a byte to the\nsignature, even though we only need 1 or 2 bits for recovery ID.\n\nThe signature is actually over human readable part and data in 5-bit\nbytes, for simplicity of implementation (all current bech32 encoders\nwork this way).\n\nSigned-off-by: Rusty Russell <rusty at rustcorp.com.au>\n\ndiff --git a/README.md b/README.md\nindex b6ac088..3039333 100644\n--- a/README.md\n+++ b/README.md\n@@ -12,9 +12,8 @@ Human readable part:\n And data part:\n 1. Version: 0 (5 bits)\n 1. Payment hash (256 bits)\n-1. Dest channel id (high bit == which end) (64 bits)\n 1. Zero or more tagged parts.\n-1. Signature (bitcoin-style, of SHA256(SHA256()) of above. (256 bits)\n+1. Signature (bitcoin-style, of SHA256(SHA256(), plus recovery byte) of above. (520 bits)\n \n Tagged parts are of format:\n 1. type (5 bits)\ndiff --git a/examples.sh b/examples.sh\nindex 3da33ab..78c2be8 100755\n--- a/examples.sh\n+++ b/examples.sh\n@@ -2,28 +2,27 @@\n \n # Dummy placeholder values\n RHASH=0001020304050607080900010203040506070809000102030405060708090102\n-CHANID=1122334455667788\n CONVERSION_RATE=1200\n # Random keypair for testing.\n PRIVKEY=e126f68f7eafcc8b74f54d269fe206be715000f94dac067d1c04a8ca3b2db734\n PUBKEY=03e7156ae33b0a208d0744199163177e909e80176e55d97a2f221ede0f934dd9ad\n \n-echo '# Please send 10 satoshi using rhash $RHASH to node at channel $CHANID (numerically-lesser end of those peers).'\n-./lightning-address.py encode 10000 $RHASH $CHANID $PRIVKEY\n+echo \"# Please send 10 satoshi using rhash $RHASH to me @$PUBKEY\"\n+./lightning-address.py encode 10000 $RHASH $PRIVKEY\n echo\n \n-echo '# Please send $3 for a cup of coffee to the same peer'\n-./lightning-address.py encode --description='1 cup coffee' $((3 * 100000000000 / $CONVERSION_RATE)) $RHASH $CHANID $PRIVKEY\n+echo \"# Please send \\$3 for a cup of coffee to the same peer\"\n+./lightning-address.py encode --description='1 cup coffee' $((3 * 100000000000 / $CONVERSION_RATE)) $RHASH $PRIVKEY\n echo\n \n-echo '# Now send $24 for an entire list of things (hashed)'\n-./lightning-address.py encode --description-hashed='One piece of chocolate cake, one icecream cone, one pickle, one slice of swiss cheese, one slice of salami, one lollypop, one piece of cherry pie, one sausage, one cupcake, and one slice of watermelon' $((24 * 100000000000 / $CONVERSION_RATE)) $RHASH $CHANID $PRIVKEY\n+echo \"# Now send \\$24 for an entire list of things (hashed)\"\n+./lightning-address.py encode --description-hashed='One piece of chocolate cake, one icecream cone, one pickle, one slice of swiss cheese, one slice of salami, one lollypop, one piece of cherry pie, one sausage, one cupcake, and one slice of watermelon' $((24 * 100000000000 / $CONVERSION_RATE)) $RHASH $PRIVKEY\n echo\n \n # NOTE: Does not implement real fallback format yet!\n echo '# The same, with a fallback address mk2QpYatsKicvFVuTAQLBryyccRXMUaGHP'\n-./lightning-address.py encode --fallback=mk2QpYatsKicvFVuTAQLBryyccRXMUaGHP --description-hashed='One piece of chocolate cake, one icecream cone, one pickle, one slice of swiss cheese, one slice of salami, one lollypop, one piece of cherry pie, one sausage, one cupcake, and one slice of watermelon' $((24 * 100000000000 / $CONVERSION_RATE)) $RHASH $CHANID $PRIVKEY\n+./lightning-address.py encode --fallback=mk2QpYatsKicvFVuTAQLBryyccRXMUaGHP --description-hashed='One piece of chocolate cake, one icecream cone, one pickle, one slice of swiss cheese, one slice of salami, one lollypop, one piece of cherry pie, one sausage, one cupcake, and one slice of watermelon' $((24 * 100000000000 / $CONVERSION_RATE)) $RHASH $PRIVKEY\n echo\n \n echo '# The same, with extra routing info to get to node 029e03a901b85534ff1e92c43c74431f7ce72046060fcf7a95c37e148f78c77255'\n-./lightning-address.py encode --route=029e03a901b85534ff1e92c43c74431f7ce72046060fcf7a95c37e148f78c77255/0102030405060708/20/3 --fallback=mk2QpYatsKicvFVuTAQLBryyccRXMUaGHP --description-hashed='One piece of chocolate cake, one icecream cone, one pickle, one slice of swiss cheese, one slice of salami, one lollypop, one piece of cherry pie, one sausage, one cupcake, and one slice of watermelon' $((24 * 100000000000 / $CONVERSION_RATE)) $RHASH $CHANID $PRIVKEY\n+./lightning-address.py encode --route=029e03a901b85534ff1e92c43c74431f7ce72046060fcf7a95c37e148f78c77255/0102030405060708/20/3 --fallback=mk2QpYatsKicvFVuTAQLBryyccRXMUaGHP --description-hashed='One piece of chocolate cake, one icecream cone, one pickle, one slice of swiss cheese, one slice of salami, one lollypop, one piece of cherry pie, one sausage, one cupcake, and one slice of watermelon' $((24 * 100000000000 / $CONVERSION_RATE)) $RHASH $PRIVKEY\ndiff --git a/lightning-address.py b/lightning-address.py\nindex 1a3f670..c43d020 100755\n--- a/lightning-address.py\n+++ b/lightning-address.py\n@@ -169,8 +169,8 @@ def lnencode(options):\n     \n     hrp = 'ln' + options.currency + amount\n     \n-    # version + paymenthash + channelid\n-    data = [0] + convertbits(bytearray.fromhex(options.paymenthash) + bytearray.fromhex(options.channelid), 8, 5)\n+    # version + paymenthash\n+    data = [0] + convertbits(bytearray.fromhex(options.paymenthash), 8, 5)\n     \n     for r in options.route:\n         pubkey,channel,fee,cltv = r.split('/')\n@@ -189,9 +189,10 @@ def lnencode(options):\n \n     # We actually sign the hrp, then the array of 5-bit values as bytes.\n     privkey = secp256k1.PrivateKey(bytes(bytearray.fromhex(options.privkey)))\n-    sig = privkey.ecdsa_serialize_compact(privkey.ecdsa_sign(\n-        bytearray([ord(c) for c in hrp] + data)))\n-    data = data + convertbits(sig, 8, 5)\n+    sig = privkey.ecdsa_sign_recoverable(bytearray([ord(c) for c in hrp] + data))\n+    # This doesn't actually serialize, but returns a pair of values :(\n+    sig,recid = privkey.ecdsa_recoverable_serialize(sig)\n+    data = data + convertbits(bytes(sig) + bytes([recid]), 8, 5)\n \n     print(bech32_encode(hrp, data))\n \n@@ -205,27 +206,19 @@ def lndecode(options):\n \n     if data[0] != 0:\n         sys.exit(\"Unknown version {}\".format(data[0]))\n+    data = data[1:]\n \n-    # Final signature takes 103 bytes (64 bytes base32 encoded)\n+    # Final signature takes 104 bytes (65 bytes base32 encoded)\n     if len(data) < 103:\n         sys.exit(\"Too short to contain signature\")\n-    sigdecoded = convertbits(data[-103:], 5, 8, False)\n-    data = data[:-103]\n-\n-    if options.pubkey:\n-        pubkey = secp256k1.PublicKey()\n-        pubkey.deserialize(bytes(bytearray.fromhex(options.pubkey)))\n-        sig = pubkey.ecdsa_deserialize_compact(sigdecoded)\n-        if not pubkey.ecdsa_verify(bytearray([ord(c) for c in hrp] + data), sig):\n-            sys.exit(\"Bad signature\")\n-        print(\"Signature: OK\")\n-    else:\n-        print(\"Signature: Unknown\")\n-\n-    # Preserve original data for signature check.\n-    origdata = data\n-    data = data[1:]\n+    sigdecoded = convertbits(data[-104:], 5, 8, False)\n+    data = data[:-104]\n \n+    pubkey = secp256k1.PublicKey(flags=secp256k1.ALL_FLAGS)\n+    sig = pubkey.ecdsa_recoverable_deserialize(sigdecoded[0:64], sigdecoded[64])\n+    pubkey.public_key = pubkey.ecdsa_recover(bytearray([ord(c) for c in hrp] + data), sig)\n+    print(\"Signed with public key: {}\".format(bytearray(pubkey.serialize()).hex()))\n+    \n     m = re.search(\"\\d+\", hrp)\n     if not m:\n         sys.exit(\"Does not contain amount\")\n@@ -246,15 +239,14 @@ def lndecode(options):\n     if options.rate:\n         print(\"(Conversion: {})\".format(amount / 10**11 * float(options.rate)))\n \n-    # (32 + 8) bytes turns into 64 bytes when base32 encoded.\n-    if len(data) < 64:\n-        sys.exit(\"Not long enough ton contain payment hash and channel id\")\n+    # 32 bytes turns into 52 bytes when base32 encoded.\n+    if len(data) < 52:\n+        sys.exit(\"Not long enough to contain payment hash\")\n \n-    decoded = convertbits(data[:64], 5, 8, False)\n-    data = data[64:]\n-    assert len(decoded) == 32 + 8\n-    print(\"Payment hash: {}\".format(bytearray(decoded[0:32]).hex()))\n-    print(\"Channel id: {}\".format(bytearray(decoded[32:40]).hex()))\n+    decoded = convertbits(data[:52], 5, 8, False)\n+    data = data[52:]\n+    assert len(decoded) == 32\n+    print(\"Payment hash: {}\".format(bytearray(decoded).hex()))\n \n     while len(data) > 0:\n         tag,tagdata,data = pull_tagged(data)\n@@ -297,7 +288,6 @@ parser_enc.add_argument('--description-hashed',\n                         help='What is being purchased (for hashing)')\n parser_enc.add_argument('amount', type=int, help='Amount in millisatoshi')\n parser_enc.add_argument('paymenthash', help='Payment hash (in hex)')\n-parser_enc.add_argument('channelid', help='Channel id (in hex)')\n parser_enc.add_argument('privkey', help='Private key (in hex)')\n parser_enc.set_defaults(func=lnencode)"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-06T04:08:47",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> However, it utilizes an\n> encoding whose rationale make sense for the Bitcoin address use-case, but in\n> my opinion, doesn't carry over those compelling traits to the LN payreq\n> use-case.\n\nI agree, but it's nice for QR codes too, and denser than hex.  And now\nwe're using your key recovery idea, having a checksum is not\n*completely* pointless.\n\nI've implemented and pushed fallback addresses in the example\nencoder/decoder, and tweaked the format slightly: the first 5-bit value\nis the witness version, or 17 for p2pkh, 18 for p2sh.  It's now\ncomplete.\n\nIn some places the encoding is a little awkward (trying to get on 5 bit\nboundaries), ideas welcome.\n\n<Feedback please!\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-08T11:25:29",
                "message_text_only": "I mentioned some things off-list before but let me add them here for completeness.\n\nMy biggest concern was the use of `short_channel_id` as an alias for\nthe endpoint, it just felt wrong having to perform that lookup to get\na space saving. This is all the more strange since the remainder of\nthe spec is very generous with space, allowing arbitrary (up to 1024\nbyte) string descriptions and similar. So good job at removing it,\neven if it was only as a fallback or hint.\n\nI also don't like the amount shorthands (k/m/g/...), that's purely a\nUI/UX concern and since these invoices are not user-readable I don't\nsee the point. Even if they were user-readable, we'd be forcing people\nto do the conversion BTC -> SAT on their own, since we would not\nsupport amount in bitcoin units (BTC, mBTC, ...). I'd say either get\nrid of the shorthands or add the BTC shorthands as well.\n\nOther than that, I really like the proposal, it's clean and\nextensible, and it supports testnet ;-) I also like using bech32 as a\nserialization format, if people also support the DNS bootstrapping and\nnode lookup they can simply reuse that dependency, and it is a bit\nshorter than hex. We might consider also supporting a different, human\nreadable, encoding though (without changing the signature\nserialization). And finally we could directly derive a URI scheme from\nthe bech32 encoded string by replacing the '1' with a ':', but we can\nspin that discussion off in another thread ^^\n\nCheers,\nChristian\n\nOn Sat, May 06, 2017 at 01:38:47PM +0930, Rusty Russell wrote:\n> Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> > However, it utilizes an\n> > encoding whose rationale make sense for the Bitcoin address use-case, but in\n> > my opinion, doesn't carry over those compelling traits to the LN payreq\n> > use-case.\n> \n> I agree, but it's nice for QR codes too, and denser than hex.  And now\n> we're using your key recovery idea, having a checksum is not\n> *completely* pointless.\n> \n> I've implemented and pushed fallback addresses in the example\n> encoder/decoder, and tweaked the format slightly: the first 5-bit value\n> is the witness version, or 17 for p2pkh, 18 for p2sh.  It's now\n> complete.\n> \n> In some places the encoding is a little awkward (trying to get on 5 bit\n> boundaries), ideas welcome.\n> \n> <Feedback please!\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-09T01:37:28",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n> I also don't like the amount shorthands (k/m/g/...), that's purely a\n> UI/UX concern and since these invoices are not user-readable I don't\n> see the point. Even if they were user-readable, we'd be forcing people\n> to do the conversion BTC -> SAT on their own, since we would not\n> support amount in bitcoin units (BTC, mBTC, ...). I'd say either get\n> rid of the shorthands or add the BTC shorthands as well.\n\nHey, invoices are totally human readable, for some humans :)\n\nBut a good point.  So let's use BTC with m (milli), u (micro), n (nano)\nand p (pico).  In theory we could allow . in that part, but I think it's\ntoo distracting.\n\nAt $1600/BTC:\n\n        0.01c = 62500p\n        1c = 6250n\n        $1 = 625u\n        $1000 = 625m\n\n> Other than that, I really like the proposal, it's clean and\n> extensible, and it supports testnet ;-) I also like using bech32 as a\n> serialization format, if people also support the DNS bootstrapping and\n> node lookup they can simply reuse that dependency, and it is a bit\n> shorter than hex. We might consider also supporting a different, human\n> readable, encoding though (without changing the signature\n> serialization). And finally we could directly derive a URI scheme from\n> the bech32 encoded string by replacing the '1' with a ':', but we can\n> spin that discussion off in another thread ^^\n\nOK, if people like this change, I think we can move start turning this\ninto BOLT 10?\n\nThanks!\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-09T08:22:41",
                "message_text_only": "On Tue, May 09, 2017 at 11:07:28AM +0930, Rusty Russell wrote:\n> Hey, invoices are totally human readable, for some humans :)\n> \nI know Pieter can decode bech32 on the fly :-)\n\n> But a good point.  So let's use BTC with m (milli), u (micro), n (nano)\n> and p (pico).  In theory we could allow . in that part, but I think it's\n> too distracting.\n> \n> At $1600/BTC:\n> \n>         0.01c = 62500p\n>         1c = 6250n\n>         $1 = 625u\n>         $1000 = 625m\n\nPerfect, even though your price is already outdated, and it currently\nis $1700/BTC. I mention the conversion confusion because I often run\ninto that problem myself (and keep typing 0s until the client\ncomplains).\n\n> > Other than that, I really like the proposal, it's clean and\n> > extensible, and it supports testnet ;-) I also like using bech32 as a\n> > serialization format, if people also support the DNS bootstrapping and\n> > node lookup they can simply reuse that dependency, and it is a bit\n> > shorter than hex. We might consider also supporting a different, human\n> > readable, encoding though (without changing the signature\n> > serialization). And finally we could directly derive a URI scheme from\n> > the bech32 encoded string by replacing the '1' with a ':', but we can\n> > spin that discussion off in another thread ^^\n> \n> OK, if people like this change, I think we can move start turning this\n> into BOLT 10?\n\nOops, I think I did what Luke hates, and sort of self assigned a\nproposal number... I can of course assign the DNS bootstrap BOLT\nanother number.\n\nCheers,\nChristian"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-10T01:52:26",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n> On Tue, May 09, 2017 at 11:07:28AM +0930, Rusty Russell wrote:\n>> Hey, invoices are totally human readable, for some humans :)\n>> \n> I know Pieter can decode bech32 on the fly :-)\n\nWell, Pieter can pronounce them too apparently:\n\n        http://pieterwuillefacts.com/?43\n\n>> But a good point.  So let's use BTC with m (milli), u (micro), n (nano)\n>> and p (pico).  In theory we could allow . in that part, but I think it's\n>> too distracting.\n>> \n>> At $1600/BTC:\n>> \n>>         0.01c = 62500p\n>>         1c = 6250n\n>>         $1 = 625u\n>>         $1000 = 625m\n>\n> Perfect, even though your price is already outdated, and it currently\n> is $1700/BTC. I mention the conversion confusion because I often run\n> into that problem myself (and keep typing 0s until the client\n> complains).\n\nI considered using the m/u/n modifier as the decimal point, eg:\n\n         0.0001c = 0n62\n         0.01c = 62n5\n         1c = 6u25\n         $1 = 625u \n         $1000 = 625m\n\nUnfortunately, it's horrible to write the code to encode/decode (I just\nspend an hour on it and I'm not happy with the result).\n\n>> OK, if people like this change, I think we can move start turning this\n>> into BOLT 10?\n>\n> Oops, I think I did what Luke hates, and sort of self assigned a\n> proposal number... I can of course assign the DNS bootstrap BOLT\n> another number.\n\nHuh?  I just did exactly the same thing!  So I'll take BOLT 11.\n\nCheers,\nRusty."
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2017-05-28T18:42:32",
                "message_text_only": "Rusty wrote:\n> Yes, I thought about this too, but I'm reluctant to assign those onion\n> bytes as they're a limited resource.  Easy to add later, though.\n\nIf y'all recall, the initial version of the Sphinx derived onion format\nincluded an end-to-end payload. In the first revision, removed this\npayload as at the time it was very large (1KB iirc), an at the time, we\ndidn't see nay clear use case for such a payload (and also due to MTU\nconstraints?). In my opinion, we should re-introduce this payload so we\naren't put into a corner where we need to shave bytes off of the per-hop\npayload in order to accommodate application level schemes/apps.\n\nRe-introducing the e2e payload would allow us to define a strict\nseparation of layers: h2h payload is reserved for _forwarding_ critical\ninformation, while the e2e payload is reserved for _applications_ to place\nrelevant data which is also onion encrypted + authenticated. IMO, the e2e\npayload doesn't need to be any where as large at it was previously (which\ndoubled the size of the onion packet). I'd proposed re-introducing it with\na size of somewhere around 200 bytes. With this, I could send you\nsomething to tweet once the payment has been extended :p.\n\nFabrice wrote:\n> Payment requests should also include a timestamp and an expiry date (they\n> could be optional tagged items but I think it makes more sense to make\n> them mandatory)\n\nAgreed that that would make for a really useful tag. I had a user which\nwas making a store on lnd request such a feature as his use-case depended\non users only having a particular time window to make the payment. This\ncould of course be enforced server side, but allow senders to enforce it\nat the origin of the payment saves them from extending an HTLC all\ntogether. Also in the world of pre-paying for HTLC's, you'd only want to\nextend an HTLC is you had a high degree of certainty that it'll be\nclaimed, otherwise you've just wasted your precious mSAT :(.\n\nRusty wrote:\n> Note: we will lose this ability when we switch to Schnorr, apparently.\n\nAFAIK, this isn't the case. With Schnorr signatures (that include the\nentire point, instead of the hash), we actually won't need to include a\nrecovery ID at all.\n\nRusty wrote:\n> OK, if people like this change, I think we can move start turning this\n> into BOLT 10?\n\nLet's do it (BOLT 11)! As were all getting pretty close to the stage of\ncross-implementation interoperability tests, having a shared payment\nrequest format will be super useful.\n\nChristian wrote:\n> Perfect, even though your price is already outdated, and it currently\n> is $1700/BTC\n\nPerfect, even through your price is already outdated, and it currently is\n$2200/BTC :p.\n\n-- Laolu\n\n\nOn Tue, May 9, 2017 at 10:18 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Christian Decker <decker.christian at gmail.com> writes:\n> > On Tue, May 09, 2017 at 11:07:28AM +0930, Rusty Russell wrote:\n> >> Hey, invoices are totally human readable, for some humans :)\n> >>\n> > I know Pieter can decode bech32 on the fly :-)\n>\n> Well, Pieter can pronounce them too apparently:\n>\n>         http://pieterwuillefacts.com/?43\n>\n> >> But a good point.  So let's use BTC with m (milli), u (micro), n (nano)\n> >> and p (pico).  In theory we could allow . in that part, but I think it's\n> >> too distracting.\n> >>\n> >> At $1600/BTC:\n> >>\n> >>         0.01c = 62500p\n> >>         1c = 6250n\n> >>         $1 = 625u\n> >>         $1000 = 625m\n> >\n> > Perfect, even though your price is already outdated, and it currently\n> > is $1700/BTC. I mention the conversion confusion because I often run\n> > into that problem myself (and keep typing 0s until the client\n> > complains).\n>\n> I considered using the m/u/n modifier as the decimal point, eg:\n>\n>          0.0001c = 0n62\n>          0.01c = 62n5\n>          1c = 6u25\n>          $1 = 625u\n>          $1000 = 625m\n>\n> Unfortunately, it's horrible to write the code to encode/decode (I just\n> spend an hour on it and I'm not happy with the result).\n>\n> >> OK, if people like this change, I think we can move start turning this\n> >> into BOLT 10?\n> >\n> > Oops, I think I did what Luke hates, and sort of self assigned a\n> > proposal number... I can of course assign the DNS bootstrap BOLT\n> > another number.\n>\n> Huh?  I just did exactly the same thing!  So I'll take BOLT 11.\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170528/7dcd0cac/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-29T10:48:51",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> Rusty wrote:\n>> Yes, I thought about this too, but I'm reluctant to assign those onion\n>> bytes as they're a limited resource.  Easy to add later, though.\n>\n> If y'all recall, the initial version of the Sphinx derived onion format\n> included an end-to-end payload. In the first revision, removed this\n> payload as at the time it was very large (1KB iirc), an at the time, we\n> didn't see nay clear use case for such a payload (and also due to MTU\n> constraints?). In my opinion, we should re-introduce this payload so we\n> aren't put into a corner where we need to shave bytes off of the per-hop\n> payload in order to accommodate application level schemes/apps.\n\nUnfortunately people want this for mid-points, too, to do weird crazy\nshit.  But it's trivial for us to extend to a \"multi-cell\" format in\nfuture, so I'm tempted by the default of \"no change\"?\n\n> Fabrice wrote:\n>> Payment requests should also include a timestamp and an expiry date (they\n>> could be optional tagged items but I think it makes more sense to make\n>> them mandatory)\n>\n> Agreed that that would make for a really useful tag. I had a user which\n> was making a store on lnd request such a feature as his use-case depended\n> on users only having a particular time window to make the payment. This\n> could of course be enforced server side, but allow senders to enforce it\n> at the origin of the payment saves them from extending an HTLC all\n> together.\n\nAgreed.  Latest version has a UTC timestamp, and expiry time (defaults\nto 1 hour if not specified).  As you say, must be server-enforced too,\nbut it's nice to make it clear to the user (and it's signed in case of\ndispute).\n\n> Rusty wrote:\n>> Note: we will lose this ability when we switch to Schnorr, apparently.\n>\n> AFAIK, this isn't the case. With Schnorr signatures (that include the\n> entire point, instead of the hash), we actually won't need to include a\n> recovery ID at all.\n\nQuoting a private conversation with Pieter Wuille, when I asked him\nabout it:\n\n        You can't.\n\n        At least, if you follow modern practices (which make the signature hash\n        commit to the public key), you can't do pubkey recovery.\n\n        It *is* possible (and safe, I think) to commit to the pubkeyhash\n        rather than the pubkey directly, in which case you can verify a\n        (signature, pubkeyhash, msg) triplet.\n\n        I think you can use a 128-bit pubkey hash, actually.\n\n> Rusty wrote:\n>> OK, if people like this change, I think we can move start turning this\n>> into BOLT 10?\n>\n> Let's do it (BOLT 11)! As were all getting pretty close to the stage of\n> cross-implementation interoperability tests, having a shared payment\n> request format will be super useful.\n\nOK, I'll start typing...\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Lightning payment format",
            "categories": [
                "Lightning-dev",
                "RFC"
            ],
            "authors": [
                "Fabrice Drouin",
                "Pierre",
                "Rusty Russell",
                "Olaoluwa Osuntokun",
                "Christian Decker"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 49168
        }
    },
    {
        "title": "[Lightning-dev] [PATCH] Add spellcheck tool (requires `aspell`), also spellcheck.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2017-05-03T03:39:26",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n> This patch should apply to http://github.com/lightningnetwork/lightning-rfc\n\nHi,\n\n        This patch was line-wrapped, whitespace-mangled, and does not apply.\nHowever, I unmangled it and worked through all the spelling errors (I\nchose HTLCs over the alternatives), and added a Travis check against\nintroducing new ones.\n\nYou can see the final result here:\n        https://github.com/lightningnetwork/lightning-rfc/pull/153\n\nThanks!\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-04T14:26:07",
                "message_text_only": "Good morning,\n\n>ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n>writes:\n>> This patch should apply to http://github.com/lightningnetwork/lightning-rfc\n>\n>Hi,\n>\n>This patch was line-wrapped, whitespace-mangled, and does not apply.\n>However, I unmangled it and worked through all the spelling errors (I\n>chose HTLCs over the alternatives), and added a Travis check against\n>introducing new ones.\n>\n>You can see the final result here:\n>https://github.com/lightningnetwork/lightning-rfc/pull/153\n\nSo sorry for the trouble. Next time I'll attach the patch instead.\n\nThank you for fixung the patch and improving it.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170504/e69251be/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Add spellcheck tool (requires `aspell`), also spellcheck.",
            "categories": [
                "Lightning-dev",
                "PATCH"
            ],
            "authors": [
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1358
        }
    },
    {
        "title": "[Lightning-dev] Channel top-up",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-03T16:51:46",
                "message_text_only": "Good morning people,\n\nI want to propose, the addition of a new operation (and related messages) to the Lightning Network protocol.\n\nSuppose Alice and Bob have a micropayment channel. Now, because Bob provides an excellent service, Alice's side of the micropayment channel is eventually depleted. If Alice needs to spend more for Bob's services, she can either look for another route on a channel she has with someone else, or open a new channel to Bob and close the existing channel.\n\nI would like to propose a \"top-up\" operation which transmits Bitcoins to Bob on-chain in exchange for crediting that amount to Alice's side in the micropayment channel.\n\nEffectively, this is equivalent, in spirit, to Alice paying Bob to pay Alice. Although no money effectively is transferred by the operation, it moves the state of the channel between Alice and Bob.\n\nIntuitively, for a casual user of LN, it should be possible to \"top up\" the channel, so that Alice can continuously pay for Bob's excellent service. The concept of topping up already exists outside of LN, and new users might reasonably ask about such a feature. Given that funds in a channel are locked up in that channel until closed, I think that most LN software would separate the amount spendable via Lightning from the amount spendable via normal Bitcoin transactions. A user of the software might want to increase his or her Lightning-spendable funds as they get depleted. While the software can abstract this away and simply create channels to random other nodes, I think the proposed \"top-up\" operations may reduce load on both Lightning and Bitcoin layers.\n\nThe procedure is below:\n\n1. Alice generates a random number preimage.\n\n2. Alice proposes a top-up operation to Bob.\n\n3. Bob responds with a newly-generated public key hash as payment target.\n\n4. Alice generates a recovery public key hash and creates an HTLC transaction containing the top-up amount from her funds, signs it, and broadcasts it to the Bitoin network. The HTLC will pay to Alice's recovery PKH after a CLTV + 2 day timeout, or pay to Bob's payment target with the random number preimage.\n\n5. When the transaction confirms on the Bitcoin blockchain, Alice provides the transaction ID to Bob as well as the hash of the random number preimage. (This is needed to prevent Alice from double-spending the money that should go to Bob).\n\n6. Bob sends a (standard) update_add_htlc to Alice, referring to their channel, with a CLTV +1 day timeout. They recreate commitment transactions as normal response to update_add_htlc message..\n\n7. Alice sends a (standard) update_fulfill_htlc, providing the random number preimage.\n\n8. Bob confirms that the preimage hashes to the random number preimage, and if so fulfills the update_fulfill_htlc. They recreate commitment transactions as normal response to update_fulfill_htlc. After this point, Alice may now spend via Lightning for Bob's services.\n\n9. Bob creates a transaction from the on-chain HTLC transaction to another address he controls.\n\n--\n\nI believe, the top-up operation reduces Lightning and Bitcoin layer overheads slightly.\n\nOn Lightning, since the channel is never closed and a new one is never created, new routing gossip does not need to be propagated.\n\nOn Bitcoin, we should remember that channels require a minimum amount of money for one counterparty in that channel. Basically, even though Alice's side in the channel is depleted, she still has a tiny amount of money on that channel assigned to her. When closing the channel, it becomes a tiny UTXO. With a top-up operation instead, the UTXO is a relatively medium top-up amount.\n\nNote however that the two transactions created on-chain by top-up are slightly larger than the cooperative commitment transaction of a close and a funding transaction of an open. This is because a lightning channel is funded by a 2-of-2 multisig account, whose script is smaller than an HTLC's script.\n\nFinally, this may be used to hide a self-mix. If Alice maintains several channels to several people, and she knows that her current addresses are traceable to her, she can make up HTLC's paying to herself,via new PKH addresses that she may deny having, then pretending that those are top-up operations with her channel counterparties.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170503/87de06e8/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-04T10:39:30",
                "message_text_only": "Hi ZmnSCPxj,\n\nthanks for proposing this, it looks quite interesting, and the top-up\nproblem is definitely worth looking into. However, I think there are a\nfew problems with your proposal: it is rather complicated and needs to\ntrack funds in the channel as well as \"side-stashed\" funds, also the\nHTLCs in the channel cannot possibly make use of the topped up funds\nsince they are not spending them, they'd need to be aggregated first.\n\nAt the Scaling Bitcoin workshop I proposed a mechanism that I called\nsplice-in/-out that would also solve the top-up problem, but I never\ngot around to write it up, mea culpa. Splicing is just a clever way of\nclosing a channel and reopening a new one right from the settlement,\nand the new one does not need to be confirmed before we can perform\nfurther updates.\n\nSplice-in\n---------\nSo let's say that Alice would like to top-up here channel with\nBob. She will take some of her funds and create a new 2-of-2 output\nwith requiring both Alice and Bob's signature, this is preparing funds\nto be added to the channel. We let the transaction creating that\n2-of-2 output confirm. Once that output is securely confirmed Alice\nasks Bob to splice-in, so they collaboratively close the channel by\nspending the funding TX output and the prepared top-up output into a\nnew 2-of-2 output. On that final 2-of-2 output we will create the new\nchannel, i.e., the settlement transaction is automatically the funding\ntransaction of the new channel.\n\nAlice and Bob can use the existing channel right up to the splice-in\noperation, Alice may just be pre-allocating some funds in\nparallel. During the splice-in we need to stop forwarding HTLCs for a\nfew seconds, so we can settle cleanly. Directly after the splice-in\nthe channel is functional again, no need to let the settlement/funding\ntransaction confirm. That is because the funds in the channel never\ntouched an unconfirmed singlesig output, hence they can never be\ndoublespent without the collaboration of the counterparty.\n\nSplice-out\n----------\nThe opposite problem of moving funds out of a channel can also be\naddressed with this trick. So we can actually perform on-chain\ntransactions directly from funds that are locked into a channel\n(that's why I don't think \"locked in\" is the right word to describe\nthis situation). So let's assume Alice would like to perform an\non-chain payment using some funds (x satoshi) that are currently\nassigned to a channel with Bob. She creates a settlement transactions\nthat spend x satoshi to the desired destination/address, and the\nremainder is paid back to a 2-of-2 output owned by Alice and Bob. They\nwill then build the new version of the channel on top of this new\n2-of-2 output and be able to continue performing transfers right\naway. Again, this works because the funds that remain in the channel\nnever touch a singlesig, so there is no need to confirm it first.\n\nWe might even go a step further and not need to drain the HTLCs from a\nchannel before performing a splice operation, assuming we can get the\nsetup procedure to include all HTLCs that were present before the\nsplice operation.\n\n\nI'd love feedback and comparisons of both proposals :-)\n\nCheers,\nChristian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-04T15:30:34",
                "message_text_only": "Good morning Christian,\n\n>thanks for proposing this, it looks quite interesting, and the top-up\n>problem is definitely worth looking into.\n\nThank you very much your kindness.\n\n>However, I think there are a\n>few problems with your proposal: it is rather complicated and needs to\n>track funds in the channel as well as \"side-stashed\" funds,\n\nI'm not sure why it's complicated apparently.\n\nActually, this reuses the same mechanism as onion routing. The only difference is that the first \"hop\" of the route is performed via an on-chain transaction.\n\nOnce the usual onion-routing mechanims has settled with update_fulfill_htlc, the channel state settles to a new topped-up state. The \"side funds\" are definitely in the possession of Bob, and do not affect the channel state and are not considered in the channel state.\n\nHere is concrete example.\n\n1. First, the channel has state: Alice=0.0, Bob=1.0\n\n2. Alice requests a top-up to Bob. She makes an HTLC(3days, topupsecret) on-chain (written, signed, confirmed) worth 0.25, which Bob can redeem once Alice provides the secret.\n\n3. Bob changes the channel state using update_add_htlc, so the channel now has state: Alice=0.0, Alice+HTLC(1day, topupsecret)=0.25, Bob=0.75.\n\n4. Alice changes the channel state using update_fulfill_htlc, so the channel now has state: Alice=0.25, Bob=0.75. Bob now knows the secret to the HTLC that Alice prepared on-chain.\n\n5. Bob performs an on-chain transaction to recover the 0.25Btc from the on-chain HTLC by Alice.\n\nThere is no need to keep track of side funds once the HTLC update_fullfill_htlc command is sent by Alice. At this point, Bob has access to the money.\n\nThe limitation here is that the total channel funds limits the amount that Alice can top-up the channel.\n\n>also the\n>HTLCs in the channel cannot possibly make use of the topped up funds\n>since they are not spending them, they'd need to be aggregated first.\n\nSorry, maybe my explanation isn't clear.\n\nAlice's side is depleted, but Bob's side isn't depleted. So Bob can offer an on-channel HTLC to Alice using Bob's funds on the channel.\n\n>At the Scaling Bitcoin workshop I proposed a mechanism that I called\n>splice-in/-out that would also solve the top-up problem, but I never\n>got around to write it up, mea culpa. Splicing is just a clever way of\n>closing a channel and reopening a new one right from the settlement,\n>and the new one does not need to be confirmed before we can perform\n>further updates.\n\nI'd considered something similar at first, but realized that some risks were involved.\n\n>Splice-in\n>---------\n>So let's say that Alice would like to top-up here channel with\n>Bob. She will take some of her funds and create a new 2-of-2 output\n>with requiring both Alice and Bob's signature, this is preparing funds\n>to be added to the channel. We let the transaction creating that\n>2-of-2 output confirm. Once that output is securely confirmed Alice\n>asks Bob to splice-in,\n\nBob then creates the following message: \"Heya Alice! I see you made a 0.25 btc output requiring a 2-of-2 multisig. One of the signatures on that multisig happens to be my signature. Because of this unauthorized requirement of my signature, I want you to make another transaction spending that transaction, sending 0.13 btc to 18X5NsJrrqgjprXucYTTshjHm3ETYgqk8z. You can transfer 0.12btc minus transaction fees to someone else if you like. Please sign that transaction and send it to me. Love, kisses, hope that helps, Bob.\" Bob then cryptographically signs the message and sends it off-channel to Alice. Bob then refuses to cooperate with the rest of the splice-in protocol.\n\n>so they collaboratively close the channel by\n>spending the funding TX output and the prepared top-up output into a\n>new 2-of-2 output. On that final 2-of-2 output we will create the new\n>channel, i.e., the settlement transaction is automatically the funding\n>transaction of the new channel.\n>\n>Alice and Bob can use the existing channel right up to the splice-in\n>operation, Alice may just be pre-allocating some funds in\n>parallel. During the splice-in we need to stop forwarding HTLCs for a\n>few seconds, so we can settle cleanly. Directly after the splice-in\n>the channel is functional again, no need to let the settlement/funding\n>transaction confirm. That is because the funds in the channel never\n>touched an unconfirmed singlesig output, hence they can never be\n>doublespent without the collaboration of the counterparty.\n\n^^ counterparty hostage risk, Bob didn't follow it ^^\n\n>Splice-out\n>----------\n>The opposite problem of moving funds out of a channel can also be\n>addressed with this trick. So we can actually perform on-chain\nt>ransactions directly from funds that are locked into a channel\n>(that's why I don't think \"locked in\" is the right word to describe\n>this situation). So let's assume Alice would like to perform an\n>on-chain payment using some funds (x satoshi) that are currently\n>assigned to a channel with Bob. She creates a settlement transactions\n>that spend x satoshi to the desired destination/address, and the\n>remainder is paid back to a 2-of-2 output owned by Alice and Bob. They\n>will then build the new version of the channel on top of this new\n>2-of-2 output and be able to continue performing transfers right\n>away. Again, this works because the funds that remain in the channel\n>never touch a singlesig, so there is no need to confirm it first.\n\nI see. This seems feasible. The order needs to be specified exactly, though. In this case, to splice out\n\n1. Alice generates a new funding transaction, inputting only the previous funding transaction. It outputs a 2-of-2 multisig Alice+Bob, and another output P2PKH of Alice's selection.\n\n2. Alice sends the splice-out funding transaction to Bob, who checks that the P2PKH of Alice plus the tx fee of the splice-out funding transaction is less than Alice's money on the channel.\n\n3. Alice and Bob create and sign new commitment transactions based on the splice-out funding transaction, checking that the balances are correct, with Alice's balances spliced out correctly.\n\n4. Alice and Bob sign the splice-out funding transaction, and broadcast the tx without waiting for confirmation.\n\n5. Alice and Bob exchange revocation keys for their previous commitment transactions (which were based on the previous funding transaction).\n\nIn the above, it's safe to abort at any time, with the money remaining in the channel.\n\nNote however a potential hostage situation: Alice wants to move money out of the channel expeditiously without closing the channel. Bob may refuse to cooperate on a splice-out. Thus, this is the same risk as Alice requesting to close the channel and Bob not cooperating, forcing Alice to use her commitment transaction, which has a time delay.\n\nThus, it's not safe to think of the channel's fund as anything but locked in, since uncooperation means the channel's funds are returned to you after a timeout.\n\n>We might even go a step further and not need to drain the HTLCs from a\n>channel before performing a splice operation, assuming we can get the\n>setup procedure to include all HTLCs that were present before the\n>splice operation.\n\nSorry, the interaction of CSV (in commitment transaction timeouts) and CLTV (in HTLC's) still escapes me.\n\n>I'd love feedback and comparisons of both proposals :-)\n\nAs for my top-up proposal, I realized also, that it's actually an onion route where part of the hop is done on-chain rather than on-Lightning.\n\nThus, while the top-up procedure is expected to be used by Alice to top up her channel funds, it's actually the first hop of an onion route. The onion route just happens to route from off-LN Alice, to on-LN Bob, to on-LN Alice.\n\nThis may be used by someone off-LN to pay into an LN node without committing funds to open a channel, for example for a one-off transaction to a Lightning node. That someone may use onion routing to ensure that it becomes untraceable on LN. Alternatively, a non-Lightning user can claim he or she did an off-LN onion route, but actually just sent the funds to himself/herself to throw off trackers.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170504/4c5ace41/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-04T17:53:29",
                "message_text_only": "Hi ZmnSCPxj,\n\nthanks for the clarification, I think I understand the proposal a bit\nbetter now.\n\n> I'm not sure why it's complicated apparently.\n> \n> Actually, this reuses the same mechanism as onion routing. The only\n> difference is that the first \"hop\" of the route is performed via an\n> on-chain transaction.\n> \n> Once the usual onion-routing mechanims has settled with\n> update_fulfill_htlc, the channel state settles to a new topped-up\n> state. The \"side funds\" are definitely in the possession of Bob, and\n> do not affect the channel state and are not considered in the\n> channel state.\n\nI see, so you're not actually modifying the total amount in the\nchannel, Alice is just buying back some capacity on the channel using\nan on-chain transaction.\n\n> >At the Scaling Bitcoin workshop I proposed a mechanism that I called\n> >splice-in/-out that would also solve the top-up problem, but I never\n> >got around to write it up, mea culpa. Splicing is just a clever way of\n> >closing a channel and reopening a new one right from the settlement,\n> >and the new one does not need to be confirmed before we can perform\n> >further updates.\n> \n> I'd considered something similar at first, but realized that some\n> risks were involved.\n\nI don't think we are incurring in any exceptional risks, and we are\nactually reusing the same machinery we already have for the initial\nestablishment of the channel.\n\n> >Splice-in\n> >---------\n> >So let's say that Alice would like to top-up here channel with\n> >Bob. She will take some of her funds and create a new 2-of-2 output\n> >with requiring both Alice and Bob's signature, this is preparing funds\n> >to be added to the channel. We let the transaction creating that\n> >2-of-2 output confirm. Once that output is securely confirmed Alice\n> >asks Bob to splice-in,\n> \n> Bob then creates the following message: \"Heya Alice! I see you made\n> a 0.25 btc output requiring a 2-of-2 multisig. One of the signatures\n> on that multisig happens to be my signature. Because of this\n> unauthorized requirement of my signature, I want you to make another\n> transaction spending that transaction, sending 0.13 btc to\n> 18X5NsJrrqgjprXucYTTshjHm3ETYgqk8z. You can transfer 0.12btc minus\n> transaction fees to someone else if you like. Please sign that\n> transaction and send it to me. Love, kisses, hope that helps, Bob.\"\n> Bob then cryptographically signs the message and sends it\n> off-channel to Alice. Bob then refuses to cooperate with the rest of\n> the splice-in protocol.\n\nThis is not different from how we are establishing channels\ninitially. Alice would only ever lock in the funds with a guarantee\nthat she can retrieve the funds if Bob decides not to cooperate. We\ncan implement this with locktimes or CSV, and disarm that mechanism\nlater using a re-anchor. So the script is (A+B || A+timeout) if the\nsplice goes well we re-anchor, and the righthand side of the || is\ndisarmed.\n\n> >so they collaboratively close the channel by\n> >spending the funding TX output and the prepared top-up output into a\n> >new 2-of-2 output. On that final 2-of-2 output we will create the new\n> >channel, i.e., the settlement transaction is automatically the funding\n> >transaction of the new channel.\n> >\n> >Alice and Bob can use the existing channel right up to the splice-in\n> >operation, Alice may just be pre-allocating some funds in\n> >parallel. During the splice-in we need to stop forwarding HTLCs for a\n> >few seconds, so we can settle cleanly. Directly after the splice-in\n> >the channel is functional again, no need to let the settlement/funding\n> >transaction confirm. That is because the funds in the channel never\n> >touched an unconfirmed singlesig output, hence they can never be\n> >doublespent without the collaboration of the counterparty.\n> \n> ^^ counterparty hostage risk, Bob didn't follow it ^^\n\nCounterparty hostage risk disarmed ^^\n\n> >Splice-out\n> >----------\n> \n> In the above, it's safe to abort at any time, with the money\n> remaining in the channel.\n> \n> Note however a potential hostage situation: Alice wants to move\n> money out of the channel expeditiously without closing the\n> channel. Bob may refuse to cooperate on a splice-out. Thus, this is\n> the same risk as Alice requesting to close the channel and Bob not\n> cooperating, forcing Alice to use her commitment transaction, which\n> has a time delay.\n> \n> Thus, it's not safe to think of the channel's fund as anything but\n> locked in, since uncooperation means the channel's funds are\n> returned to you after a timeout.\n\nRight, there remains that risk, but hopefully that wouldn't happen too\noften ;-)\n\n> >We might even go a step further and not need to drain the HTLCs from a\n> >channel before performing a splice operation, assuming we can get the\n> >setup procedure to include all HTLCs that were present before the\n> >splice operation.\n> \n> Sorry, the interaction of CSV (in commitment transaction timeouts)\n> and CLTV (in HTLC's) still escapes me.\n\nIf we are able to recreate the same HTLCs on the re-anchored channel\nin a safe way then we can avoid draining them off of the channel\nbefore splicing. Even if we don't do that we may simply hold back on\nadding new HTLCs, drain, re-anchor and then add the held back HTLCs\nonce the splice is completed. And finally this could allow us to\nperform a partial drop to the chain, splicing out just the HTLCs which\nare about to expire and maintaining the rest of the channel intact.\n\n> >I'd love feedback and comparisons of both proposals :-)\n> \n> As for my top-up proposal, I realized also, that it's actually an\n> onion route where part of the hop is done on-chain rather than\n> on-Lightning.\n> \n> Thus, while the top-up procedure is expected to be used by Alice to\n> top up her channel funds, it's actually the first hop of an onion\n> route. The onion route just happens to route from off-LN Alice, to\n> on-LN Bob, to on-LN Alice.\n> \n> This may be used by someone off-LN to pay into an LN node without\n> committing funds to open a channel, for example for a one-off\n> transaction to a Lightning node. That someone may use onion routing\n> to ensure that it becomes untraceable on LN. Alternatively, a\n> non-Lightning user can claim he or she did an off-LN onion route,\n> but actually just sent the funds to himself/herself to throw off\n> trackers.\n\nThat's very clever, I like the combination of on-chain and off-chain\npayments. I still like my splicing approach better (yes, I'm pretty\nbiased in this case ^^) but being able to combine on-chain and\noff-chain is a great feature, let's see how far we can push it.\n\nCheers,\nChristian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-04T22:00:36",
                "message_text_only": "Good morning,\n\n>> Once the usual onion-routing mechanims has settled with\n>> update_fulfill_htlc, the channel state settles to a new topped-up\n>> state. The \"side funds\" are definitely in the possession of Bob, and\n>> do not affect the channel state and are not considered in the\n>> channel state.\n>\n>I see, so you're not actually modifying the total amount in the\n>channel, Alice is just buying back some capacity on the channel using\n>an on-chain transaction.\n\nThat's correct. Of course, proper splice-in and splice-out operations would allow channel maximum capacity to be controlled by the counterparties, based on their financial situation and growing/shrinking trust in their counterparty.\n\n>> >Splice-in\n>> >---------\n>> >So let's say that Alice would like to top-up here channel with\n>> >Bob. She will take some of her funds and create a new 2-of-2 output\n>> >with requiring both Alice and Bob's signature, this is preparing funds\n>> >to be added to the channel. We let the transaction creating that\n>> >2-of-2 output confirm. Once that output is securely confirmed Alice\n>> >asks Bob to splice-in,\n>>\n>> Bob then creates the following message: \"Heya Alice! I see you made\n>> a 0.25 btc output requiring a 2-of-2 multisig. One of the signatures\n>> on that multisig happens to be my signature. Because of this\n>> unauthorized requirement of my signature, I want you to make another\n>> transaction spending that transaction, sending 0.13 btc to\n>> 18X5NsJrrqgjprXucYTTshjHm3ETYgqk8z. You can transfer 0.12btc minus\n>> transaction fees to someone else if you like. Please sign that\n>> transaction and send it to me. Love, kisses, hope that helps, Bob.\"\n>> Bob then cryptographically signs the message and sends it\n>> off-channel to Alice. Bob then refuses to cooperate with the rest of\n>> the splice-in protocol.\n>\n>This is not different from how we are establishing channels\n>initially. Alice would only ever lock in the funds with a guarantee\n>that she can retrieve the funds if Bob decides not to cooperate. We\n>can implement this with locktimes or CSV, and disarm that mechanism\n>later using a re-anchor. So the script is (A+B || A+timeout) if the\n>splice goes well we re-anchor, and the righthand side of the || is\n>disarmed.\n\nAh, I see. However, we need to ensure the new funding transaction can be confirmed before the pre-splice-in transaction times out. This is especially true if we continue to use the channel, based on the new funding transaction, in an asynchronous (i.e. operating the channel before the splice-in funding transaction is confirmed) manner. So the timeout needs to be rather longish, to ensure that the splice-in funding transaction can get on-chain before the pre-splice-in transaction times out.\n\nNeedless to say, asynchronous splice-in would require malleability fix, and in the back of my mind I'm forming a contingency plan if Bitcoin really can't deploy a malleability fix in two years (or half a year when I'm feeling particularly excited about LN). At least the off-to-on-LN routing (using an on-chain HTLC to \"buy back\" some capacity on your side of a channel) could work without malleability fix.\n\n>> ^^ counterparty hostage risk, Bob didn't follow it ^^\n>\n>Counterparty hostage risk disarmed ^^\n\nYes ^^\n\nAbout synchrony/asynchrony; perhaps it's possible to also offer a synchronous splice-in. For example, Alice knows she will route a larger-than-normal payment to Bob in the future, but will not be sending micropayments now. Then perhaps the counterparties can use a splice-in funding transaction directly spending from Alice's inputs (rather than from a pre-splice-in that Alice prepares to reassure Bob she won't suddenly invalidate an unconfirmed splice-in funding transaction). This is slightly less costly, but channel operations would have to be suspended while the splice-in funding transaction is confirmed. This reduces on-chain load.\n\nAlthough I suppose to the rest of the network, the unusable channel waiting for a synchronous splice-in would be no different from closing a channel, then opening a new one in its place, so maybe not.\n\n>> >Splice-out\n>> >----------\n>>\n>> In the above, it's safe to abort at any time, with the money\n>> remaining in the channel.\n>>\n>> Note however a potential hostage situation: Alice wants to move\n>> money out of the channel expeditiously without closing the\n>> channel. Bob may refuse to cooperate on a splice-out. Thus, this is\n>> the same risk as Alice requesting to close the channel and Bob not\n>> cooperating, forcing Alice to use her commitment transaction, which\n>> has a time delay.\n>>\n>> Thus, it's not safe to think of the channel's fund as anything but\n>> locked in, since uncooperation means the channel's funds are\n>> returned to you after a timeout.\n>\n>Right, there remains that risk, but hopefully that wouldn't happen too\n>often ;-)\n\nYes, but if there is hostility against LN (as I suspect), it may happen too often T.T\n\nPersonally, I think, it's safer to tell our users that indeed, channel funds are locked in, rather than some attacker running a bad LN node suddenly causing a behavior that honest but naive users did not expect.\n\n>> Sorry, the interaction of CSV (in commitment transaction timeouts)\n>> and CLTV (in HTLC's) still escapes me.\n>\n>If we are able to recreate the same HTLCs on the re-anchored channel\n>in a safe way then we can avoid draining them off of the channel\n>before splicing. Even if we don't do that we may simply hold back on\n>adding new HTLCs, drain, re-anchor and then add the held back HTLCs\n>once the splice is completed. And finally this could allow us to\n>perform a partial drop to the chain, splicing out just the HTLCs which\n>are about to expire and maintaining the rest of the channel intact.\n\nI'll have to defer to you on this one. While I can understand the revocable transactions and the HTLC's in isolation, I haven't understood well yet the ramifications of their interactions.\n\n>> As for my top-up proposal, I realized also, that it's actually an\n>> onion route where part of the hop is done on-chain rather than\n>> on-Lightning.\n>>\n>> Thus, while the top-up procedure is expected to be used by Alice to\n>> top up her channel funds, it's actually the first hop of an onion\n>> route. The onion route just happens to route from off-LN Alice, to\n>> on-LN Bob, to on-LN Alice.\n>>\n>> This may be used by someone off-LN to pay into an LN node without\n>> committing funds to open a channel, for example for a one-off\n>> transaction to a Lightning node. That someone may use onion routing\n>> to ensure that it becomes untraceable on LN. Alternatively, a\n>> non-Lightning user can claim he or she did an off-LN onion route,\n>> but actually just sent the funds to himself/herself to throw off\n>> trackers.\n>\n>That's very clever, I like the combination of on-chain and off-chain\n>payments. I still like my splicing approach better (yes, I'm pretty\n>biased in this case ^^) but being able to combine on-chain and\n>off-chain is a great feature, let's see how far we can push it.\n\nSuppose Alice is planning a new business that receives Bitcoin. She sets up an LN node. However, because her LN node is new, it doesn't have channels yet. To expedite payments to her when business is launched, she wants her LN node to have channels. But if she initiates channels herself to nodes already on the network, those channels will be set up to send from her business node to the network, when she wants them to be set up to receive. Of course she could leave her node without channels and have her first customers set up a channel directly to her, but that slows down her customers, who must wait for the channels to open before they can spend money on Alice's excellent service.\n\nInstead, in preparation for business launch day, Alice opens a channel to well-connected node Bob. At first, the channel's state is Alice=1.0, Bob=0.0, because Alice initiated the channel, so Alice can't actually use it to receive funds. She sends an invitation-to-top-up to Bob, inviting him to top up the channel by 0.5 btc, and if Bob compiles and does indeed top-up, then the channel's state becomes Alice=0.5, Bob=0.5, so it can now be used by Alice to receive from customers. Alice does this a few more times with various other existing LN nodes, so that on business launch, she can receive money from her first customers immediately.\n\nOf course, if we had a symmetrical rather than a one-sided open, a symmetrical open would be more efficient on the underlying Bitcoin network overall.\n\nTop-up can be used to revive not only exhausted channels, but exhausted routes. Suppose there is one known route from Alice to Carol: Alice->Bob->Carol. Because of Carol's excellent service, Bob->Carol's channel is exhausted. Alice can then use an on-chain HTLC to revive the Alice->Bob->Carol route, by making a top-up operation: Alice ->(onchain)-> Carol -> Bob -> Alice.\n\nOf course, in this case Alice is better off just making a channel directly to Carol, if she is willing to make an on-chain transaction anyway.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170504/612cd6fb/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-05T10:00:40",
                "message_text_only": "Good morning again,\n\n>That's very clever, I like the combination of on-chain and off-chain\n>payments. I still like my splicing approach better (yes, I'm pretty\n>biased in this case ^^) but being able to combine on-chain and\n>off-chain is a great feature, let's see how far we can push it.\n\nPotentially, another application for onion routes with on-chain and off-chain hops is for exchanges.\n\nSuppose I initially have 1000 BTC but only 0 LTC. Since I can afford it, most of my 1000 BTC is in an LN node, slowly gaining more money from routing fees.\n\nBut, with 0 LTC, I can't initiate connections on the LTC side of the network. I can pay to Litecoin users, but I would have to make some out-of-band request for a Litecoin-side LN node to connect a Litecoin channel to me.\n\nOne way for me to gain LTC would be to route from my BTC LN node, to a BTC/LTC exchange node, and request the final hop to go to an LTC address I control via an on-chain HTLC transaction.\n\nAfter that, I can initiate LTC connections to LTC LN nodes directly myself, without going through an exchange each time, or alternatively hodl my LTC.\n\nThis would allow anyone to be a cross-currency exchange, without having problems about chicken-and-egg problems like \"how do I receive LTC via Lightning if I don't have LTC to initiate a channel on the LTC side\". Of course, in reality, cross-currency exchanges already exist, so maybe this is not a problem in practice.\n\n--\n\nNow, we can argue that we can add an \"invitation to connect to me\" to make a channel that is set up to send money to me. This helps also the new-business-node case (where Alice is setting up a business and wants to initiate receive channels, rather than the default send channels).\n\nBut what is the reason why channel opens, in current 1.0 spec, require the initiator to be the one, and the only one, to put up funding for the channel?\n\nMy understanding (it's not explicitly stated in the paper, or in the rfc specs I've read) is that the initiator pays for the fees in setting up the channel.\n\nIf we have an \"invitation to connect to me\" request, and people comply with the request, the fees come from their funding of the channels. If I spam the network with this request, then I will waste everyone's time making those channels, locking up their funds, and wasting their transaction fees. If I then don't open up a channel to anyone else and I don't do some service for which I get paid, then the channels set up to me are wasted in routing gossip, since no route can pass through me, as there is no way to move money out of my node.\n\nInstead, we can keep the \"initiator pays for full funding of channel open\" and not have an \"invitation to connect to me\" request. Then I can initiate a channel with a well-connected counterparty (paid for by me), request a route through the new channel, to my counterparty, and ending with an on-chain hop back to an address I control. This effectively reverses the direction of the channel, and because I have money in the channel, my counterparty can add the tx fees for the on-chain hop to the routing fees he would charge for this onion route, paid for from my initially sending-direction channel.\n\nSo I think, basically, that allowing onion routes to start and end on-chain is an elegant way to modify channel states to what we want, while ensuring that everyone is reasonably protected from bad actors on the LN.\n\nOf course, there is some risk. If I make a request to make a route to a node, and have that route end up to, say,1.0 BTC to an on-chain public key I control, and that node accepts, I know that node has at least 1.0 BTC in spare funds, and I might use this information to assess if I want to hack that node's operator's computer.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170505/3d36fae9/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-09T09:56:20",
                "message_text_only": "On Fri, May 05, 2017 at 06:00:40AM -0400, ZmnSCPxj wrote:\n> Potentially, another application for onion routes with on-chain and\n> off-chain hops is for exchanges.\n> \n> Suppose I initially have 1000 BTC but only 0 LTC. Since I can afford\n> it, most of my 1000 BTC is in an LN node, slowly gaining more money\n> from routing fees.\n> \n> But, with 0 LTC, I can't initiate connections on the LTC side of the\n> network. I can pay to Litecoin users, but I would have to make some\n> out-of-band request for a Litecoin-side LN node to connect a\n> Litecoin channel to me.\n> \n> One way for me to gain LTC would be to route from my BTC LN node, to\n> a BTC/LTC exchange node, and request the final hop to go to an LTC\n> address I control via an on-chain HTLC transaction.\n> \n> After that, I can initiate LTC connections to LTC LN nodes directly\n> myself, without going through an exchange each time, or\n> alternatively hodl my LTC.\n> \n> This would allow anyone to be a cross-currency exchange, without\n> having problems about chicken-and-egg problems like \"how do I\n> receive LTC via Lightning if I don't have LTC to initiate a channel\n> on the LTC side\". Of course, in reality, cross-currency exchanges\n> already exist, so maybe this is not a problem in practice.\n\nYes, there is a possibility for doing atomic cross chain swaps using\nLightning nodes, and routing in a circle back to ourself, starting\nwith the outgoing currency and ending in the desired currency. The\nfact that we can directly perform the first hop on-chain, as you\npointed out, is a great way of having other nodes connect to us and\ndoing an initial balancing of the capacity, e.g., initially they'd own\n100% of the channel, but with the conditional on-chain transfer they'd\nsend us some.\n\n> Now, we can argue that we can add an \"invitation to connect to me\"\n> to make a channel that is set up to send money to me. This helps\n> also the new-business-node case (where Alice is setting up a\n> business and wants to initiate receive channels, rather than the\n> default send channels).\n> \n> But what is the reason why channel opens, in current 1.0 spec,\n> require the initiator to be the one, and the only one, to put up\n> funding for the channel?\n\nIt's just simpler, since it requires very little coordination, having\nmulti-party funded channels is definitely on the roadmap, but with\nyour insight above we can already balance the channels right from the\nget go.\n\n> My understanding (it's not explicitly stated in the paper, or in the\n> rfc specs I've read) is that the initiator pays for the fees in\n> setting up the channel.\n> \n> If we have an \"invitation to connect to me\" request, and people\n> comply with the request, the fees come from their funding of the\n> channels. If I spam the network with this request, then I will waste\n> everyone's time making those channels, locking up their funds, and\n> wasting their transaction fees. If I then don't open up a channel to\n> anyone else and I don't do some service for which I get paid, then\n> the channels set up to me are wasted in routing gossip, since no\n> route can pass through me, as there is no way to move money out of\n> my node.\n> \n> Instead, we can keep the \"initiator pays for full funding of channel\n> open\" and not have an \"invitation to connect to me\" request. Then I\n> can initiate a channel with a well-connected counterparty (paid for\n> by me), request a route through the new channel, to my counterparty,\n> and ending with an on-chain hop back to an address I control. This\n> effectively reverses the direction of the channel, and because I\n> have money in the channel, my counterparty can add the tx fees for\n> the on-chain hop to the routing fees he would charge for this onion\n> route, paid for from my initially sending-direction channel.\n> \n> So I think, basically, that allowing onion routes to start and end\n> on-chain is an elegant way to modify channel states to what we want,\n> while ensuring that everyone is reasonably protected from bad actors\n> on the LN.\n> \n> Of course, there is some risk. If I make a request to make a route\n> to a node, and have that route end up to, say,1.0 BTC to an on-chain\n> public key I control, and that node accepts, I know that node has at\n> least 1.0 BTC in spare funds, and I might use this information to\n> assess if I want to hack that node's operator's computer.\n\nWell, at the latest when the channel is being funded you'd see that\ninformation anyway. Also he could fund only part of the amount you\nprovided and instead give you a partial refund if it can't afford to\nopen a channel with the capacity you requested (though we may have to\ntweak the script of the on-chain tx to ensure the refund has\nprecedence).\n\nAs mentioned above, the ability to treat on-chain payments like any\nother lightning channel transfer is very nice. It allows us to treat\nthe on-chain payments identically to off-chain payments (with the\ncaveat of confirmation times), so we can extend all our Lightning\nschemes with on-chain hops :-)\n\nCheers,\nChristian"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-05T02:42:16",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n> Good morning people,\n>\n> I want to propose, the addition of a new operation (and related messages) to the Lightning Network protocol.\n\nHi,\n\n        Yes, we call this re-anchoring.  The same method can be used for\nadding or removing funds from the channel, by mutual cooperation.  It\nhas the additional merit that (once deeply confirmed) you can forget\nrevocation information for any older commitment transactions.\n\nIt was omitted from the 1.0 spec because we have more than enough in\nthere already.\n\nBut your solution seems overly complex?  A or B can simply propose a new\nfunding transaction which spends the current one, both sides exchange\nall the output signatures for a new commitment transaction which uses\nthat, then exchange signatures for the new funding transaction.\n\nEven if the new funding tx isn't confirmed yet, they can continue to use\nthe channel as normal.\n\n(FWIW, Christian Decker was the one who pointed out how elegant this\nis).\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-05T04:58:11",
                "message_text_only": "Good morning Rusty,\n\n>ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n>writes:\n>> Good morning people,\n>>\n>> I want to propose, the addition of a new operation (and related messages) to the Lightning Network protocol.\n>\n>Hi,\n>\n>Yes, we call this re-anchoring. The same method can be used for\n>adding or removing funds from the channel, by mutual cooperation. It\n>has the additional merit that (once deeply confirmed) you can forget\n>revocation information for any older commitment transactions.\n>\n>It was omitted from the 1.0 spec because we have more than enough in\n>there already.\n\nI understand.\n\n>But your solution seems overly complex? A or B can simply propose a new\n>funding transaction which spends the current one, both sides exchange\n>all the output signatures for a new commitment transaction which uses\n>that, then exchange signatures for the new funding transaction.\n\nI'm sorry my poor understanding of complexity.\n\nMy thought, was that this simply allows an onion-route payment to be started on-chain. Then normal onion-route messages (update_fulfill_htlc etc) can be used.\n\nBasically, my idea, if onion route code already exists, we just modify this a little by allowing an onion-route to start on-chain rather than on-Lightning. The onion route can still remain terminated into a Lightning node. So we need new message to allow onion route to be initiated on-chain/off-LN, but the rest of the onion-route uses the same, already-tested code.\n\nOriginally, I thought similarly to the splice-in/splice-out/reanchoring scheme. But I thought it would be more complex to add new message types to consider reanchoring.\n\n>Even if the new funding tx isn't confirmed yet, they can continue to use\n>the channel as normal.\n>\n>(FWIW, Christian Decker was the one who pointed out how elegant this\n>is).\n\nIf the funding tx will only output (i.e. only reduce money on the channel), it's OK.\n\nIf the funding tx will input (increase money on the channel), then we need to confirm a pre-splice-in transaction. Then the reanchoring tx can be made safely \"floating\", although since the pre-splice-in tx has a timelock, we should still anchor the reanchoring tx before the pre-splice-in transaction's timelock ends.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170505/0fc2860e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Channel top-up",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Christian Decker",
                "ZmnSCPxj"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 44161
        }
    },
    {
        "title": "[Lightning-dev] Minor editorial fixes to lightning-rfc",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-07T01:04:49",
                "message_text_only": "Good morning.\n\nAttached please find minor editorial patches to lighting-rfc.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170506/4622d409/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0001-02-peer-protocol.md-Minor-typo-update_htlc_add-verb-.patch\nType: text/x-patch\nSize: 858 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170506/4622d409/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0002-07-routing-gossip.md-Move-some-text-about-ipv6-and-p.patch\nType: text/x-patch\nSize: 2259 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170506/4622d409/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0003-07-routing-gossip.md-channel_update-Update-text-abou.patch\nType: text/x-patch\nSize: 1057 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170506/4622d409/attachment-0002.bin>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-07T03:00:21",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n> Good morning.\n>\n> Attached please find minor editorial patches to lighting-rfc.\n\nHi!\n\n        Thanks.  We generally prefer minor fixes as github pull requests\nto avoid spamming the list, though if you don't github I'm happy to take\nthem personally and apply them, as I've done in this case:\n\n        https://github.com/lightningnetwork/lightning-rfc/pull/161\n\nThe list is generally better used for discussing large change proposals,\nthough even they are better if they start with a github patch :)\n\nThanks!\nRusty.\n\n\n\n>\n> Regards,\n> ZmnSCPxj\n> From d107d6b60988e0d9f61cd400322021d87a22d8d8 Mon Sep 17 00:00:00 2001\n> From: \"ZmnSCPxj\" <ZmnSCPxj at protonmail.com>\n> Date: Sun, 7 May 2017 00:40:22 +0000\n> Subject: [PATCH 1/3] 02-peer-protocol.md: Minor typo: `update_htlc_add`, verb\n>  should come first\n>\n> ---\n>  02-peer-protocol.md | 2 +-\n>  1 file changed, 1 insertion(+), 1 deletion(-)\n>\n> diff --git a/02-peer-protocol.md b/02-peer-protocol.md\n> index 5751eb7..0c69724 100644\n> --- a/02-peer-protocol.md\n> +++ b/02-peer-protocol.md\n> @@ -482,7 +482,7 @@ the blockchain.\n>  \n>  #### Requirements\n>  \n> -A node MUST NOT offer an HTLC (`update_htlc_add`) in response to an incoming HTLC until \n> +A node MUST NOT offer an HTLC (`update_add_htlc`) in response to an incoming HTLC until \n>  the incoming HTLC has been irrevocably committed.\n>  \n>  A node MUST NOT fail an incoming HTLC (`update_fail_htlc`) for which it has committed \n> -- \n> 2.11.0\n>\n> From 288a34e6f650f4420a6f9e1614de3f5e873daf12 Mon Sep 17 00:00:00 2001\n> From: \"ZmnSCPxj\" <ZmnSCPxj at protonmail.com>\n> Date: Sun, 7 May 2017 00:49:42 +0000\n> Subject: [PATCH 2/3] 07-routing-gossip.md: Move some text about `ipv6` and\n>  `port` from `channel_update` to `node_announcement`.\n>\n>   `channel_update` does not make sense as it does not have fields\n>     with either addresses or ports.\n>   Moved it to `node_announcement` on the assumption that the text\n>     was just inserted in the wrong place, since `node_announcement`\n>     is described before `channel_update` and does have addresses\n>     and ports.\n> ---\n>  07-routing-gossip.md | 6 ++++--\n>  1 file changed, 4 insertions(+), 2 deletions(-)\n>\n> diff --git a/07-routing-gossip.md b/07-routing-gossip.md\n> index cc19da1..19898c7 100644\n> --- a/07-routing-gossip.md\n> +++ b/07-routing-gossip.md\n> @@ -231,6 +231,9 @@ does not match the types defined above.  The receiving node SHOULD\n>  fail the connection if `addrlen` is insufficient to hold the address\n>  descriptors of the known types.\n>  \n> +The receiving node SHOULD ignore `ipv6-addr` or `ipv4-addr`\n> +if `port` is zero.\n> +\n>  The receiving node SHOULD ignore the message if `node-id` is not\n>  previously known from a `channel_announcement` message, or if\n>  `timestamp` is not greater than the last-received\n> @@ -300,8 +303,7 @@ The creating node MUST set `timestamp` to greater than zero, and MUST set it to\n>  It MUST set `cltv-expiry-delta` to the number of blocks it will subtract from an incoming HTLCs `cltv-expiry`.  It MUST set `htlc-minimum-msat` to the minimum HTLC value it will accept, in millisatoshi.  It MUST set `fee-base-msat` to the base fee it will charge for any HTLC, in millisatoshi, and `fee-proportional-millionths` to the amount it will charge per millionth of a satoshi.\n>  \n>  The receiving node MUST ignore `flags` other than the least significant bit.\n> -The receiving node SHOULD ignore `ipv6`\n> -if `port` is zero.  It SHOULD ignore the message if `short-channel-id` does\n> +It SHOULD ignore the message if `short-channel-id` does\n>  not correspond to a previously\n>  known, unspent channel from `channel_announcement`, otherwise the node-id\n>  is taken from the `channel_announcement` `node-id-1` if least-significant bit of flags is 0 or `node-id-2` otherwise.\n> -- \n> 2.11.0\n>\n> From aca87a4e2598c0b4f785f109907d6a79b06989f5 Mon Sep 17 00:00:00 2001\n> From: \"ZmnSCPxj\" <ZmnSCPxj at protonmail.com>\n> Date: Sun, 7 May 2017 00:54:29 +0000\n> Subject: [PATCH 3/3] 07-routing-gossip.md: `channel_update`: Update text about\n>  end indication.\n>\n>    The channel end is now indicated via a single bit\n>      in `flags`, not an entire byte.\n> ---\n>  07-routing-gossip.md | 3 ++-\n>  1 file changed, 2 insertions(+), 1 deletion(-)\n>\n> diff --git a/07-routing-gossip.md b/07-routing-gossip.md\n> index 19898c7..97eeb32 100644\n> --- a/07-routing-gossip.md\n> +++ b/07-routing-gossip.md\n> @@ -264,7 +264,8 @@ padding within `addresses` if they require certain alignment.\n>  \n>  After a channel has been initially announced, each side independently\n>  announces its fees and minimum expiry for HTLCs.  It uses the 8-byte\n> -channel shortid which matches the `channel_announcement` and one byte\n> +channel shortid which matches the `channel_announcement` and one bit\n> +in the `flags` field\n>  to indicate which end this is.  It can do this multiple times, if\n>  it wants to change fees.\n>  \n> -- \n> 2.11.0\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-08T03:17:28",
                "message_text_only": "Good morning!\n\n>Thanks. We generally prefer minor fixes as github pull requests\n>to avoid spamming the list, though if you don't github I'm happy to take\n>them personally and apply them, as I've done in this case:\n>\n>https://github.com/lightningnetwork/lightning-rfc/pull/161\n\nI'm sorry for the trouble. I have github but have not yet set it up properly yet.\n\nThank you very much your information.\n\n>The list is generally better used for discussing large change proposals,\n>though even they are better if they start with a github patch :)\n\nI understand.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170507/8f012728/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Minor editorial fixes to lightning-rfc",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7168
        }
    },
    {
        "title": "[Lightning-dev] Spontaneous transfers",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2017-05-08T11:47:24",
                "message_text_only": "Hi all,\n\nfollowing the current discussion about invoice based transfers, I've\nbeen contacted by some users that would like us to consider other\nuse-cases as well. They'd like not to have to go through the\ninvoice-transfer-release cycle that invoices support, e.g., donations\nwithough prior contact between the recipient and the sender.\n\nThe recurring requirements for these transfers are that a) the\nrecipient gets the payment preimage so that she can trigger the\nclearing of the HTLC, and b) that there is a mechanism that signals to\nthe recipient who the sender is, without out of band communication.\n\nSo assuming Alice is the sender and Bob is the recipient I cam up with\nthe following possible solutions:\n\n - We can stuff that information into the routing info. We have the\n   flexibility of adding a new realm in there, and the last hop does\n   not contain much useful information currently. So we'd define a new\n   \"realm\" that basically let's the per-hop payload be interpreted as\n   the sender information, and we can put R and Alice's ID in there.\n\n - Another option is that Alice can create a circular route, from\n   Alice sending `X+fees` to Bob and then `fees` back to herself,\n   i.e., masquerading the payment as an oversized fee that is\n   deposited at Bob. This way Alice can trigger the payment herself,\n   but we can't communicate the sender's identity to Bob. We may even\n   be able to build the game in such a way that the payout of the\n   winning amount is the second half of the route, if Alice wins at\n   all.\n\nI think the first option is probably the easiest and cleanest, and the\nsecond one is more of a novelty, but it'd allow the creation of a\ngambling service that does not know the identity of its players :-)\n\nAre there other solutions that we can offer with the existing\nprotocol, or are there changes we could add for a v1.1 that would\nbetter accomodate these use-cases?\n\nCheers,\nChristian\n\nP.S.: I'm seeing quite a few of these ideas being repeated, because we\nhaven't documented these brainstorming ideas anywhere, shall we use\nthe lightning-rfc wiki on Github to catch them, so we can reference\nthem and maybe formulate them as BOLTs later?"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-09T01:22:42",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n> Hi all,\n>\n> following the current discussion about invoice based transfers, I've\n> been contacted by some users that would like us to consider other\n> use-cases as well. They'd like not to have to go through the\n> invoice-transfer-release cycle that invoices support, e.g., donations\n> withough prior contact between the recipient and the sender.\n\nThanks for bringing this up!\n\n> The recurring requirements for these transfers are that a) the\n> recipient gets the payment preimage so that she can trigger the\n> clearing of the HTLC, and b) hthat there is a mechanism that signals to\n> the recipient who the sender is, without out of band communication.\n>\n> So assuming Alice is the sender and Bob is the recipient I cam up with\n> the following possible solutions:\n>\n>  - We can stuff that information into the routing info. We have the\n>    flexibility of adding a new realm in there, and the last hop does\n>    not contain much useful information currently. So we'd define a new\n>    \"realm\" that basically let's the per-hop payload be interpreted as\n>    the sender information, and we can put R and Alice's ID in there.\n\nAnti-probing requires the amount and cltv fields.  We can use the 16\nbytes in the onion to communicate a 128-bit R value, however, which\nsuffices AFAICT.\n\n(If we ever want to support larger amounts we'll need a new onion\nversion but we can probably avoid enlarging it: steal two bytes from\n`outgoing_cltv_value` and have a new max of 720k bitcoins).\n\n>  - Another option is that Alice can create a circular route, from\n>    Alice sending `X+fees` to Bob and then `fees` back to herself,\n>    i.e., masquerading the payment as an oversized fee that is\n>    deposited at Bob. This way Alice can trigger the payment herself,\n>    but we can't communicate the sender's identity to Bob. We may even\n>    be able to build the game in such a way that the payout of the\n>    winning amount is the second half of the route, if Alice wins at\n>    all.\n>\n> I think the first option is probably the easiest and cleanest, and the\n> second one is more of a novelty, but it'd allow the creation of a\n> gambling service that does not know the identity of its players :-)\n\nDamn, I thought of doing exactly this trick to implement LightningDice\nservice just yesterday!  As usual, you're one step ahead :)\n\nYou also want to be able to prove to a third party if the server cheats,\nso the server revealing the payment preimage should be enough to show\nthat you lost.  I can't think of a way of doing that with preimages.\n\nBut ignoring that, we can pack a full payment hash into a pair of\nper_hop, so the LightningDice(TM) service run a pair of neighboring\nnodes:\n\n1. LD provides a payment hash as usual.\n2. You pick a payment preimage for your winnings.\n3. Construct route through the two LD nodes and back to you, except\n   1. the payment hash is encoded into the two padding fields for the LD nodes.\n   2. the onion switches to commit to your own payment hash for the return\n\nThen if you lose (using your payment hash XOR preimage), LD takes the\nmoney and you can see you lost by receiving the preimage.  If you win,\nit simply continues forwarding the onion with the new payment hash and\n(increased) amount.\n\nThe cool thing about this is that you can pay someone probabalistically\nvia the LD server (as long as you trust them not to collude on payment\nhashes).\n\n> Are there other solutions that we can offer with the existing\n> protocol, or are there changes we coiruld add for a v1.1 that would\n> better accomodate these use-cases?\n>\n> Cheers,\n> Christian\n>\n> P.S.: I'm seeing quite a few of these ideas being repeated, because we\n> haven't documented these brainstorming ideas anywhere, shall we use\n> the lightning-rfc wiki on Github to catch them, so we can reference\n> them and maybe formulate them as BOLTs later?\n\nYes, I think we all have mental lists.  This seems like something work\nhaving a wiki on github for?\n\nCheers,\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-09T10:19:24",
                "message_text_only": "On Tue, May 09, 2017 at 10:52:42AM +0930, Rusty Russell wrote:\n> Anti-probing requires the amount and cltv fields.  We can use the 16\n> bytes in the onion to communicate a 128-bit R value, however, which\n> suffices AFAICT.\n> \n> (If we ever want to support larger amounts we'll need a new onion\n> version but we can probably avoid enlarging it: steal two bytes from\n> `outgoing_cltv_value` and have a new max of 720k bitcoins).\n\nRight, we can't use those fields, and 16 bytes is not sufficient to\nidentify the sender. But we could probably use it for a prefix lookup\nin our routing table and then derive the payment preimage from\nthat. If this is the last hop the `channel_id` is also empty, and we\ncan use that as well. By defining a new realm we can also reorder the\nfields to have 24 contiguous bytes.\n\n> Damn, I thought of doing exactly this trick to implement LightningDice\n> service just yesterday!  As usual, you're one step ahead :)\n> \n> You also want to be able to prove to a third party if the server cheats,\n> so the server revealing the payment preimage should be enough to show\n> that you lost.  I can't think of a way of doing that with preimages.\n> \n> But ignoring that, we can pack a full payment hash into a pair of\n> per_hop, so the LightningDice(TM) service run a pair of neighboring\n> nodes:\n> \n> 1. LD provides a payment hash as usual.\n> 2. You pick a payment preimage for your winnings.\n> 3. Construct route through the two LD nodes and back to you, except\n>    1. the payment hash is encoded into the two padding fields for the LD nodes.\n>    2. the onion switches to commit to your own payment hash for the return\n> \n> Then if you lose (using your payment hash XOR preimage), LD takes the\n> money and you can see you lost by receiving the preimage.  If you win,\n> it simply continues forwarding the onion with the new payment hash and\n> (increased) amount.\n> \n> The cool thing about this is that you can pay someone probabalistically\n> via the LD server (as long as you trust them not to collude on payment\n> hashes).\n\nAh I see, I had a bit of trouble seeing how we could create a route\nthat commits to the 2 possible outcomes, since the HMAC commits to the\n`amt_to_forward`, so there'd be no way of forwarding either wins or\nlosses. You're saying that the route simply stops at LD if we lose.\n\nThe XORing is quite interesting though I can't really see how it'd\nwork yet. LD would commit to a secret by sending you the hash, you\nconstruct a route using that hash and your own pick (payment hash for\nthe second half) on the first half and then send the winnings back to\nme using my own pick? How are you combining the LD hash and your own\nhash to make it provably fair and giving LD the ability to pull the\npayment in say 50% of the cases?\n\nCheers,\nChristian"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-10T03:57:41",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n> On Tue, May 09, 2017 at 10:52:42AM +0930, Rusty Russell wrote:\n>> Anti-probing requires the amount and cltv fields.  We can use the 16\n>> bytes in the onion to communicate a 128-bit R value, however, which\n>> suffices AFAICT.\n>> \n>> (If we ever want to support larger amounts we'll need a new onion\n>> version but we can probably avoid enlarging it: steal two bytes from\n>> `outgoing_cltv_value` and have a new max of 720k bitcoins).\n>\n> Right, we can't use those fields, and 16 bytes is not sufficient to\n> identify the sender. But we could probably use it for a prefix lookup\n> in our routing table and then derive the payment preimage from\n> that. If this is the last hop the `channel_id` is also empty, and we\n> can use that as well. By defining a new realm we can also reorder the\n> fields to have 24 contiguous bytes.\n\nHmm, good point.  I was wrong about stealing 2 bytes from\noutgoing_cltv_value, BTW: it needs to be a block height :(\n\n>> 1. LD provides a payment hash as usual.\n>> 2. You pick a payment preimage for your winnings.\n>> 3. Construct route through the two LD nodes and back to you, except\n>>    1. the payment hash is encoded into the two padding fields for the LD nodes.\n>>    2. the onion switches to commit to your own payment hash for the return\n>> \n>> Then if you lose (using your payment hash XOR preimage), LD takes the\n>> money and you can see you lost by receiving the preimage.  If you win,\n>> it simply continues forwarding the onion with the new payment hash and\n>> (increased) amount.\n>> \n>> The cool thing about this is that you can pay someone probabalistically\n>> via the LD server (as long as you trust them not to collude on payment\n>> hashes).\n>\n> Ah I see, I had a bit of trouble seeing how we could create a route\n> that commits to the 2 possible outcomes, since the HMAC commits to the\n> `amt_to_forward`, so there'd be no way of forwarding either wins or\n> losses. You're saying that the route simply stops at LD if we lose.\n\nYes.  LD knows the preimage, so can take the funds (if it wins).  The\nrest of the onion commits to the *new* rhash and amount, so if it loses\nLD launches a new HTLC using the rest of the onion.\n\n> The XORing is quite interesting though I can't really see how it'd\n> work yet. LD would commit to a secret by sending you the hash, you\n> construct a route using that hash and your own pick (payment hash for\n> the second half) on the first half and then send the winnings back to\n> me using my own pick? How are you combining the LD hash and your own\n> hash to make it provably fair and giving LD the ability to pull the\n> payment in say 50% of the cases?\n\nWell, you can tell if it cheats, since it provides the preimage, you\nknow you should have won.  You can't prove it to a third party, however.\n\nXOR rules might look like:\n\n        bottom 7 bits = 0000000 -> LD wins (house edge)\n        otherwise bottom bit = 1 : LD wins\n        otherwise bottom bit = 0 : player wins\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-09T09:01:02",
                "message_text_only": "Good morning Christian,\n\n>- Another option is that Alice can create a circular route, from\n>Alice sending `X+fees` to Bob and then `fees` back to herself,\n>i.e., masquerading the payment as an oversized fee that is\n>deposited at Bob. This way Alice can trigger the payment herself,\n>but we can't communicate the sender's identity to Bob. We may even\n>be able to build the game in such a way that the payout of the\n>winning amount is the second half of the route, if Alice wins at\n>all.\n>\n>I think the first option is probably the easiest and cleanest, and the\n>second one is more of a novelty, but it'd allow the creation of a\n>gambling service that does not know the identity of its players :-)\n\nI think this is a clever way of doing anonymous donations to controversial charities. Not even the receiver can leak information on who the donators are.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170509/71cfe70f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Spontaneous transfers",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "ZmnSCPxj",
                "Christian Decker"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 13024
        }
    },
    {
        "title": "[Lightning-dev] lightning-rfc wiki (was: Spontaneous transfers)",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-09T09:05:19",
                "message_text_only": "Good morning all,\n\n>P.S.: I'm seeing quite a few of these ideas being repeated, because we\n>haven't documented these brainstorming ideas anywhere, shall we use\n>the lightning-rfc wiki on Github to catch them, so we can reference\n>them and maybe formulate them as BOLTs later?\n\nI agree on this idea. There is also much wrong judgment of Lightning elsewhere, since people are exposed to old Lightning paper and old Lightning presentations. While lightning-rfc contains the on-going latest spec, in many ways it is very low-level and technical.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170509/8ec775b7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "lightning-rfc wiki (was: Spontaneous transfers)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 745
        }
    },
    {
        "title": "[Lightning-dev] Deterministic generation of H",
        "thread_messages": [
            {
                "author": "Neil Fincham",
                "date": "2017-05-18T22:23:20",
                "message_text_only": "Hi List,\n\nI have a question and if it has been discussed before please just point me\nto it and tell me to f off :) .  Also, if I am grossly misunderstanding\nthings please feel free to correct me.\n\nIs there a way to deterministic generate H?\n\nFurther explanation:\n\n* With bitcoin addresses we have BIP32 that allows us to generate a Master\nPrivate Key, transform it to a Master Public Key and then use that Master\nPublic Key to generate a series of addresses.\n\nWe can generate addresses without the use of the private keys.\n\n* With LN we generate a random value S and hash it into H and distribute\nthat and then finally distribute S in order to close the channel.\n\nSO, my question:\n\nIs there a way to deterministic generate H like you can generate addresses\nwith a Master Public Key without revealing S to the generator and still\nbeing safe to use S to close the channel?  (Hopefully I am not just\nconfused and talking bullshit here)\n\n\nJohn\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170519/95ca0670/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-20T06:51:49",
                "message_text_only": "Neil Fincham <easy2confuse at gmail.com> writes:\n> Hi List,\n>\n> I have a question and if it has been discussed before please just point me\n> to it and tell me to f off :) .  Also, if I am grossly misunderstanding\n> things please feel free to correct me.\n>\n> Is there a way to deterministic generate H?\n\nYes, but not using the method we currently use.\n\n> Further explanation:\n>\n> * With bitcoin addresses we have BIP32 that allows us to generate a Master\n> Private Key, transform it to a Master Public Key and then use that Master\n> Public Key to generate a series of addresses.\n>\n> We can generate addresses without the use of the private keys.\n>\n> * With LN we generate a random value S and hash it into H and distribute\n> that and then finally distribute S in order to close the channel.\n\nThat's not quite right.  We use the terms \"payment hash\" for H and\n\"payment preimage\" for S, BTW.  You use the preimage to fulfill the HTLC\n(which is different from closing a channel).\n\n> SO, my question:\n>\n> Is there a way to deterministic generate H like you can generate addresses\n> with a Master Public Key without revealing S to the generator and still\n> being safe to use S to close the channel?  (Hopefully I am not just\n> confused and talking bullshit here)\n\nYou still need the payment preimage to close out the HTLC, but you could\ncertainly send out payment requests in such a scheme without access\nto the preimages.\n\n... but you can't do this with SHA256.  If we use a pubkey for the\n\"payment hash\" and a privkey for the \"payment preimage\" we could exactly\nuse BIP32.\n\n(There's an even more mindblowing scheme using Schnorr where the\nsignature *itself* serves as a kind of preimage, which we'll also need\nto assess.  I think that would allow a similar partition scheme to\nwhat you describe, but I'm not sure).\n\nHope that helps!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Deterministic generation of H",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Neil Fincham"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2959
        }
    },
    {
        "title": "[Lightning-dev] Generalizing proportional routing fees to exchange rates",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-20T00:03:20",
                "message_text_only": "Good morning list,\n\nI would like to propose a modification to lightning protocol, regarding the use of proportional routing fees.\n\nConsider Alice with a channel to Bob, who has a channel to Carol, and Alice must pay Carol 1.0BTC.\n\nBob advertises that he wants a 0.1% proportional fee, translating to 1,000/1,000,000 proportional routing fee.\n\n(I ignore the fixed fee for now)\n\nThis means, Alice must send 1.001 BTC to Bob, who then sends 1.0 BTC to Carol.\n\nThis translates to Bob actually having approximately 0.999001 BTC-to-BTC exchange rate.\n\nSince part of Lightning Network's roadmap is to eventually have cross-chain nodes, I would like to propose that, in lieu of advertising proportional routing fees, nodes advertise a BTC-to-BTC exchange rate. Then, we can generalize this exchange rate to cross-chain case.\n\nA node needs to advertise multiple exchange rates for various coins. Currently, Lightning designates supported coins by hashes of their genesis blocks (32-byte `chain_hash`). An exchange rate denominated in ratio of 1/1,000,000 can be encoded in 4 bytes. Thus to advertise exchange rates a node provides 64 bytes to identify the coins being referred to, and 4 bytes for the actual exchange rate. For cross-chain exchange rates, a node needs to advertise both directions (e.g. LTC-to-BTC and BTC-to-LTC).\n\nPossibly one way to advertise would be to advertise a BTC-to-LTC exchange rate plus a rate offset. For example, Bob might operate as a cross-chain exchange for LTC and BTC, and advertise a BTC-to-LTC rate of 4,000,000/1,000,000 (4 output LTC's for 1 input BTC), as well as a rate offset of 1,000/1,000,000.\n\nIf Alice sends LTC to Bob to be converted to 1.0BTC for Carol, she has to compute the Bob's exchange rate as (4,000,000+1,000)/1,000,000, then compute from the 1.0BTC for Carol to 1.0 * (4,001,000/1,000,000) as 4.001LTC to Bob.\n\nIf Carol sends BTC to Bob to be converted to 1.0LTC for Alice, she has to compute the Bob's exchange rate as (4,000,000-1,000)/1,000,000, then compute from the 1.0LTC for Alice to 1.0 / (3,999,000/1,000,000) as 0.25006252BTC to Bob.\n\nHas this been considered and rejected before?\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170519/63319cc9/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-23T05:04:01",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n> Good morning list,\n>\n> I would like to propose a modification to lightning protocol,\n> regarding the use of proportional routing fees.\n\nThere needs to be more information across networks than just the\nexchange rate.  For example, you need to know the block numbers for CLTV\ntimeouts on both sides, and you need to know the topology of the\nnetwork on both sides.  Those are problems we can push to the edges\nof the network, and nobody else should notice.\n\nMoreover, there are two general problems with random currencies on\nlightning.  Firstly, it's not clear why you'd want them once bitcoin has\nlightning: why use a highway to nowhere (unless you have invested money\nin nowhere, of course).  Secondly, we've made several assumptions that\nit's not free to create channels, which punts many DoS problems to the\nunderlying blockchain.  If you can create free channels, this protection\nvanishes.\n\nFinally, we're trying to close down spec changes, so we're reluctant to\nadd features to 1.0 if we can avoid it.\n\nThanks!\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-23T22:41:33",
                "message_text_only": "Good morning Rusty,\n\nThank you for your many explanations, I appreciate it.\n\n>>\n>> I would like to propose a modification to lightning protocol,\n>> regarding the use of proportional routing fees.\n>\n>There needs to be more information across networks than just the\n>exchange rate. For example, you need to know the block numbers for CLTV\n>timeouts on both sides, and you need to know the topology of the\n>network on both sides. Those are problems we can push to the edges\n>of the network, and nobody else should notice.\n\nDo you mean, there will be some special LN variant or service specifically for cross-chain operation (i.e. \"edge of the network\")?\n\n>Moreover, there are two general problems with random currencies on\n>lightning. Firstly, it's not clear why you'd want them once bitcoin has\n>lightning: why use a highway to nowhere (unless you have invested money\n>in nowhere, of course).\n\nI suppose that would be a good reason to want altcoin on LN....\n\n>Secondly, we've made several assumptions that\n>it's not free to create channels, which punts many DoS problems to the\n>underlying blockchain. If you can create free channels, this protection\n>vanishes.\n\nBy \"free\", do you refer to the fact, that most altcoins have low or practically 0 transaction fees?\n\n>Finally, we're trying to close down spec changes, so we're reluctant to\n>add features to 1.0 if we can avoid it.\n\nI understand.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170523/3714c25e/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-05-24T10:43:19",
                "message_text_only": "On Tue, May 23, 2017 at 06:41:33PM -0400, ZmnSCPxj via Lightning-dev wrote:\n> >There needs to be more information across networks than just the\n> >exchange rate. For example, you need to know the block numbers for CLTV\n> >timeouts on both sides, and you need to know the topology of the\n> >network on both sides. Those are problems we can push to the edges\n> >of the network, and nobody else should notice.\n> \n> Do you mean, there will be some special LN variant or service\n> specifically for cross-chain operation (i.e. \"edge of the network\")?\n\nThe edge of the network in this case refers to either the node\nperforming the exchange, i.e., straddling both blockchains by having\nchannels in both, and the endpoint creating the route, i.e., the\nsender of the transfer. These are the only ones who need to concern\nthemselves with the problems that come from this being a cross-chain\ntransfer. There may be some added noise for other nodes when it comes\nto being able to prove things along routes, e.g., \"here's proof that\nthe next hop is misbehaving\" if we don't understand the proof since it\nis in a blockchain we don't know. But since the node straddling the\nchains is already providing the exchange service it can simply\nincrease its margin to compensate for these cases.\n\nIt is far more efficient then to have them communicate out of band by\ncreating an order book on top of the base network and do order\nmatching in there, rather than attempting to fit this added complexity\ninto LN itself.\n\n> >Moreover, there are two general problems with random currencies on\n> >lightning. Firstly, it's not clear why you'd want them once bitcoin has\n> >lightning: why use a highway to nowhere (unless you have invested money\n> >in nowhere, of course).\n> \n> I suppose that would be a good reason to want altcoin on LN....\n\nWhile I understand the interest in LN as a decentralized and trustless\nexchange, I think our primary goal is to create a payment network, and\naccomodating the cross-chain needs brings in a lot of complexity into\nan already complex system, with the need to translate all parameters\ninto Bitcoin equivalent terms (CLTV, amount, off-chain fees, on-chain\nfees, ...). So I'm also rather hesitant to consider them now, while we\nhaven't gotten the base network off the ground in the simple one chain\nscenario. Like Rusty I'd like to punt this to a future version of the\nprotocol.\n\n> >Secondly, we've made several assumptions that\n> >it's not free to create channels, which punts many DoS problems to the\n> >underlying blockchain. If you can create free channels, this protection\n> >vanishes.\n> \n> By \"free\", do you refer to the fact, that most altcoins have low or\n> practically 0 transaction fees?\n\nYes, many of the DoS deterrents require Bitcoin-like on-chain fees to\nwork at all. As I mentioned above we might push the risk onto the\nnodes straddling the chains, but how attractive would their service be\nif they need to charge high fees to absorb that risk?\n\n\nI'd like to apologize for braking so much with the ideas you have come\nup, I just wanted to make it clear that we are currently focusing on\nslowing down the evolution of the 1.0 spec, so that we can finalize\nour implementations and start integration testing. It should not\ndissuade you from bringing them up, and I'd encourage discussion on\nthe ML, as long as it is understood that it likely won't be part of\nthe the 1.0 spec ;-)\n\nCheers,\nChristian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-24T23:54:42",
                "message_text_only": ">> >There needs to be more information across networks than just the\n>> >exchange rate. For example, you need to know the block numbers for CLTV\n>> >timeouts on both sides, and you need to know the topology of the\n>> >network on both sides. Those are problems we can push to the edges\n>> >of the network, and nobody else should notice.\n>>\n>> Do you mean, there will be some special LN variant or service\n>> specifically for cross-chain operation (i.e. \"edge of the network\")?\n>\n>The edge of the network in this case refers to either the node\n>performing the exchange, i.e., straddling both blockchains by having\n>channels in both, and the endpoint creating the route, i.e., the\n>sender of the transfer. These are the only ones who need to concern\n>themselves with the problems that come from this being a cross-chain\n>transfer. There may be some added noise for other nodes when it comes\n>to being able to prove things along routes, e.g., \"here's proof that\n>the next hop is misbehaving\" if we don't understand the proof since it\n>is in a blockchain we don't know. But since the node straddling the\n>chains is already providing the exchange service it can simply\n>increase its margin to compensate for these cases.\n\nAh, so my understanding, this is some variant of LN or a layer on top of LN which basically has some extensions, and that this will be for some future development.\n\n>It is far more efficient then to have them communicate out of band by\n>creating an order book on top of the base network and do order\n>matching in there, rather than attempting to fit this added complexity\n>into LN itself.\n\nI understand.\n\n>> >Moreover, there are two general problems with random currencies on\n>> >lightning. Firstly, it's not clear why you'd want them once bitcoin has\n>> >lightning: why use a highway to nowhere (unless you have invested money\n>> >in nowhere, of course).\n>>\n>> I suppose that would be a good reason to want altcoin on LN....\n>\n>While I understand the interest in LN as a decentralized and trustless\n>exchange, I think our primary goal is to create a payment network, and\n>accomodating the cross-chain needs brings in a lot of complexity into\n>an already complex system, with the need to translate all parameters\n>into Bitcoin equivalent terms (CLTV, amount, off-chain fees, on-chain\n>fees, ...). So I'm also rather hesitant to consider them now, while we\n>haven't gotten the base network off the ground in the simple one chain\n>scenario. Like Rusty I'd like to punt this to a future version of the\n>protocol.\n\nI understand.\n\n>> >Secondly, we've made several assumptions that\n>> >it's not free to create channels, which punts many DoS problems to the\n>> >underlying blockchain. If you can create free channels, this protection\n>> >vanishes.\n>>\n>> By \"free\", do you refer to the fact, that most altcoins have low or\n>> practically 0 transaction fees?\n>\n>Yes, many of the DoS deterrents require Bitcoin-like on-chain fees to\n>work at all. As I mentioned above we might push the risk onto the\n>nodes straddling the chains, but how attractive would their service be\n>if they need to charge high fees to absorb that risk?\n\nI understand. It is very interesting to me to consider about how incentives work out in this situation, and I shall study further.\n\n>I'd like to apologize for braking so much with the ideas you have come\n>up, I just wanted to make it clear that we are currently focusing on\n>slowing down the evolution of the 1.0 spec, so that we can finalize\n>our implementations and start integration testing. It should not\n>dissuade you from bringing them up, and I'd encourage discussion on\n>the ML, as long as it is understood that it likely won't be part of\n>the the 1.0 spec ;-)\n\nThere is no need to apologize, I understand completely. I am studying now the components needed to make Lightning Network work, and I shall continue to ask.\n\nA quick question. Is it possible to (at least theoretically) create an LN node software that is effectively SPV? From my current understanding of current LN software, it seems most of them require some Bitcoin core full or pruning node, or integrates such functionality. Perhaps, lit appears to use SPV, though I have not delved much into the code, so I suppose my understanding is correct.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170524/cb97e709/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Generalizing proportional routing fees to exchange rates",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Christian Decker",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 12910
        }
    },
    {
        "title": "[Lightning-dev] Consideration for user-facing interface",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-25T03:04:25",
                "message_text_only": "Good morning everyone,\n\nI would like to present my consideration for how the user-facing interface would be like, for a \"mainstream\"(-ish?) LN software.\n\nPlease inform me, if there are particular abstraction leakages that would suffer in my consideration.\n\nA Lightning-enabled wallet would have three tabs: On-chain, In-transit, and On-Lightning. The tabs would show how much Bitcoin is in each of those states, and some separate part of the interface would include the total funds of all three tabs.\n\nThe On-chain view would show the coins (abstractions of UTXO's) owned on-chain. Coins would be grouped according to PKH that unlocks that UTXO (for \"mainstream\", I think, a \"coin\" would be better term, than UTXO), especially since it would be good practice to claim all coins in a PKH in a transaction. In addition, the coin would also show an estimate of the fee required to add that UTXO as input to a transaction (basically, the bytes needed for the input spending the UTXO underneath the coin, times the fee rate done by some hidden backend fee rate estimation service/algorithm), and if the fee estimate is greater than some fraction of the coin it will be grayed (i.e. more trouble to spend the coin than hodl it).\n\nIn the On-chain view it would be possible to send on-chain, generate a receive address, and also to transfer funds from on-chain to on-Lightning. Possibly, it might also be useful to have some way to select multiple coins and \"consolidate\" them into a single larger coin, for example to reduce future fees.\n\nIn the In-transit tab, contains a list of funds that are \"in-transit\", i.e. in unconfirmed transactions. These include funding and commitment transactions. In addition, channels whose counterparty is currently offline would be included in this list (as it would not be Lightning-spendable with the counterparty offline) and the user may choose to unilaterally close to force it On-Chain; since a unilateral close has a timeout it would also be included here as \"in-transit\". Unconfirmed transactions may be \"sped up\" by either CPFP and/or RBF (possibly without actually using those terms for \"mainstream\"; instead the wallet simply includes a \"speed up\" command and perhaps use RBF-enabled on all transactions).\n\nIn the On-Lightning tab would be almost empty other than the ability to send On-Lightning, generate a LN invoice, and to transfer funds from on-Lightning to On-Chain. I hesitate to put channels in, as I do not know of some good abstraction for them (at least UTXO=coin, would be explainable as saying that Bitcoin coins have their own denominations). Of course, since counterparties in channels may go offline, perhaps I need to show them after all...\n\n(the problem with showing channels is that, if you enable \"hub mode\" (localfeatures bit 0/1) in your LN node, individual channel values will shift and change as other network participants use your node as routes, but in my opinion, for the health of LN, it should be default to have \"hub mode\" enabled)\n\nThe software would keep track of which LN nodes the user usually pays On-Lightning. When moving funds from On-Chain to On-Lightning, the software will prioritize making channels to nodes the user usually pays to, to help reduce future routing fees. In addition, the software will also perform randomized channel open (randomly select some peer to open channels to) to hopefully reduce LN centralization (or some other algorithm to improve LN mesh connectivity).\n\nWhen paying On-Lightning, and unable to find a route to the payee, the software could offer to create a direct channel (from On-chain funds) to allow payment; this has the necessary caveat that payment may be delayed due to on-chain confirmation requirements.\n\nFor On-Lightning fees, the user specifies some maximum percentage of total routing fees in some setting. If the software can find and use a route below this maximum percentage, then it simply performs the payment (for example, if the user specifies a maximum of 3% routing fees, and the software finds a route through two nodes each asking 1% fee (for a total of 2.01%) then the payment is attempted via that route). However, if routes below this setting cannot be found or fail, the software would offer to increase this maximum percentage temporarily for this payment, to allow the user to consider if higher fees can be justified for the service payment.\n\n---\n\nIt seems to me, for now, that HTLC preimages sent by update_fulfill_htlc can serve as receipts: when the payer receives this either on-chain or on-Lightning, then it definitively knows that the payee has received the money. So, it seems to me that this preimage can be given by the payer to the payee as proof-of-payment, and thereby trigger, for example, the \\delivery of goods from the payee. Is my understanding correct? If so, it seems to me that a list of such receipts should also be archived by the software, with the user able to selectively burn some receipts (for example, to burn receipts from donating to wikileaks).\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20170524/b79a285a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Consideration for user-facing interface",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5227
        }
    },
    {
        "title": "[Lightning-dev] lightning-rfc [PATCH] Enable travis to spellcheck BOLT#10 to 99",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2017-05-26T05:02:39",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> Good morning Rusty,\n>\n> I made a tiny patch to enable travis to spellcheck future BOLT#10 and so on.\n\nThanks, good catch!\n\nI've pushed this straight to the repo.\n\nCheers,\nRusty.\n\n> Regards,\n> ZmnSCPxj\n> From 7e6593154f024dcc247cc4c88f4d4a60bd5b6987 Mon Sep 17 00:00:00 2001\n> From: \"ZmnSCPxj\" <ZmnSCPxj at protonmail.com>\n> Date: Fri, 25 May 2017 19:13:34 +0000\n> Subject: [PATCH] Enable travis to spellcheck BOLT#10 to 99.\n>\n> ---\n>  .travis.yml | 2 +-\n>  1 file changed, 1 insertion(+), 1 deletion(-)\n>\n> diff --git a/.travis.yml b/.travis.yml\n> index b7e8b1f..f4f6a18 100644\n> --- a/.travis.yml\n> +++ b/.travis.yml\n> @@ -10,4 +10,4 @@ python:\n>    - \"3.6\"\n>  script:\n>    - (set -e; for i in 0?-*.md; do echo \"Extracting $i\"; python3 tools/extract-formats.py --message-types --message-fields --check-alignment $i; done)\n> -  - tools/spellcheck.sh --check 0?*.md\n> +  - tools/spellcheck.sh --check [0-9][0-9]-*.md\n> -- \n> 2.11.0"
            }
        ],
        "thread_summary": {
            "title": "lightning-rfc Enable travis to spellcheck BOLT#10 to 99",
            "categories": [
                "Lightning-dev",
                "PATCH"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 978
        }
    }
]