[
    {
        "title": "[Lightning-dev] Acknowledgements in BOLT #2",
        "thread_messages": [
            {
                "author": "Pierre",
                "date": "2016-04-01T13:32:15",
                "message_text_only": "Hello all,\n\nI noticed in the meantime Rusty recently introduced htlc ids in the\nform of absolute \"lnd-like 64 bits unique id\" vs the previous relative\n\"order-I-added-them-in\" id. I like it better and I think this is\nclosely related to the issue at hand.\n\n> This is used so we know what the other side has received when they send\n>an \"update_commit\" message, and so we know where to restart the\n>conversation after reconnect (\"authenticate\" message).\n\nTo me those two cases should be handled differently because they do\nnot happen at the same level:\n- at the protocol level I would only use the htlc id. It is currently\nalready used in add/fulfill/fail, so it would make sense to have it in\nthe update_commit msg as well, instead of relying on the acknowledge\nfield\n- at the transport level (including the reconnect scenario) I would\nrely on the acknowledge field to know which messages should be\nreplayed\n\nYes it is kind of redundant, and probably less optimal, but it does\nseparate clearly the transport from the protocol and testing might be\neasier.\n\nAlso @lnd guys: what's the thing with odd/even htlc ids? Is it just so\nthat we can use the same keyspace for incoming/outgoing htlcs and\nquickly tell the direction of a given htlc, or is there something\nelse?\n\nCheers,\n\nPierre"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2016-04-01T14:57:37",
                "message_text_only": "Hello,\n\nWe've thought about it some more and it seems now that htlc ids are\nindeed not enough and we do have to take the acknowledge field into\naccount in some cases anyway. Consider the following scenario:\nA sends ADD HTLC X, ADD HTLC Y, ADD HTLC Z\nB sends FAIL Y\nA has not yet received this last message and sends SIG Z\nB receives  SIG Z which includes (X,Y,Z) and won't match expected\nsignature (X,Z). B has no way to know whether A did receive the \"FAIL\nY\" message or not without checking the 'acknowledge' field (as\nmentioned by Rusty), and might decide that SIG Z is not valid and\nclose the channel, when it could just ignore it and keep it open.\n\nCheers,\n\nFabrice"
            },
            {
                "author": "Joseph Poon",
                "date": "2016-04-01T19:38:50",
                "message_text_only": "On Fri, Apr 01, 2016 at 03:32:15PM +0200, Pierre wrote:\n> Also @lnd guys: what's the thing with odd/even htlc ids? Is it just so\n> that we can use the same keyspace for incoming/outgoing htlcs and\n> quickly tell the direction of a given htlc, or is there something\n> else?\n\nHi Pierre,\n\nI've actually been going back and forth on HTLC IDs lately, and am\nactually currently working on a cleaner solution -- I think you might\nlike it (provided it works out). The thinking was so that one is able to\nuniquely identify HTLCs at a later time by having unique ID upon\ncreation (direction should be contextually understood by the\npositive/negative amount). The ID doesn't really need to be in the final\nwire protocol, it's more helpful for debugging than anything.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-04T02:04:34",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hello all,\n>\n> I noticed in the meantime Rusty recently introduced htlc ids in the\n> form of absolute \"lnd-like 64 bits unique id\" vs the previous relative\n> \"order-I-added-them-in\" id. I like it better and I think this is\n> closely related to the issue at hand.\n\nYes.  I wanted to avoid it (it's YA index to keep, to map these 64 bit\nIDs to the HTLC), but we can't: we really need to distinguish two HTLCs\nwith the same R value.  This is because if we don't allow that, it's\ntrivial for an attacker to probe us to find out if we've seen an HTLC.\n\nAlso, if we switch to keypair-based contracts, it's one less change to\nmake.\n\n>> This is used so we know what the other side has received when they send\n>>an \"update_commit\" message, and so we know where to restart the\n>>conversation after reconnect (\"authenticate\" message).\n>\n> To me those two cases should be handled differently because they do\n> not happen at the same level:\n> - at the protocol level I would only use the htlc id. It is currently\n> already used in add/fulfill/fail, so it would make sense to have it in\n> the update_commit msg as well, instead of relying on the acknowledge\n> field\n\nYou can't use this for (as Fabrice pointed out) because there are\nmultiple HTLCs you may be acknowledging, and you may be acknowledging\ntheir removal.  Also, you may be acking a fee change.  In future this\nmay be changes to the anchor, as well.\n\nSo it really is simplest as \"number of messages I've processed\".\n\n> - at the transport level (including the reconnect scenario) I would\n> rely on the acknowledge field to know which messages should be\n> replayed\n>\n> Yes it is kind of redundant, and probably less optimal, but it does\n> separate clearly the transport from the protocol and testing might be\n> easier.\n\nThey're actually closely tied.  Every time you send an 'ack' (that's in\nan update_commit or update_revocation), you *must* have committed state\nto persistent storage.  This matches nicely ie. you want to make sure\nyou remember if you've ever sent a revocation preimage, and you must\nremember transactions you've signed.\n\n> Also @lnd guys: what's the thing with odd/even htlc ids? Is it just so\n> that we can use the same keyspace for incoming/outgoing htlcs and\n> quickly tell the direction of a given htlc, or is there something\n> else?\n\nI really like this differentiation to catch bugs.  The latest spec\nleaves this open, but my implementation currently uses:\n\n\t/* Make it different from other node (to catch bugs!), but a\n\t * round number for simple eyeballing. */\n\tpeer->htlc_id_counter = pseudorand(1ULL << 32) * 1000;\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Acknowledgements in BOLT #2",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Joseph Poon",
                "Pierre",
                "Fabrice Drouin"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5366
        }
    },
    {
        "title": "[Lightning-dev] Lightning-dev Digest, Vol 10, Issue 14",
        "thread_messages": [
            {
                "author": "Samuel Kremser",
                "date": "2016-04-01T18:37:10",
                "message_text_only": "Hi Jerome!\n\n> A limitation I see is that service providers will need to promote \n> themselves in the open as they unfortunately cannot be anonymous and \n> hide behind TOR for example: if I am a customer, I don't want to pick \n> a consortium of 7 anonymous providers, because they could very well be \n> the same person. \n\nTrue.\nBut beside having globally distributed DSPs each controlled by several \ntrusted persons/entities, you could also set up you own DSP with some \nfriends.\nI imagine some WLAN router-sized device that act as a node of such a DSP.\nNow if you decide with some friends to set up your own DSP each one of \nyou installs such a device at home and connects it to the internet. \nTogether these devices form the DSP-network.\nAfterwards you set up your and your families payment devices to connect \nto this DSP, so do your friends.\nSince access to this DSP is probably protected with some password this \nDSP is hard to attack.\nAlso i think this is hard to regulate for a government.\n\nSam\n\nAm 01.04.2016 um 09:05 schrieb J\u00e9r\u00f4me Legoupil:\n> Hi Sam,\n>\n> I think this is a good idea. Here are a few thougths I want to throw in.\n>\n> I see this as a higher level protocol on top of Lightning network \n> (Blockchain is like IP layer, Lightning is like TCP transport layer, \n> ...): offchain wallet providers on top of LN.\n>\n> Also, having multisig bonded service providers in different \n> juridictions offers a strong protection to these providers themselves \n> and their customers against legal risks.\n>\n> A limitation I see is that service providers will need to promote \n> themselves in the open as they unfortunately cannot be anonymous and \n> hide behind TOR for example: if I am a customer, I don't want to pick \n> a consortium of 7 anonymous providers, because they could very well be \n> the same person.\n>\n> These providers would be exposed to DDoS attacks.\n>\n> 2 customers from the same consortium of providers can transact without \n> even using LN.\n>\n> The compliance rules these service providers will need to follow is an \n> open question, but I feel pretty optimistic about this.\n>\n> And I agree this would enable pretty much infinite scalability, \n> because at the end of the day, it is like scaling a dumb database. \n> These providers could also be helpful to reduce and limit the UTXO set.\n>\n> Cheers,\n> Jerome\n>\n> 2016-03-11 13:00 GMT+01:00 \n> <lightning-dev-request at lists.linuxfoundation.org \n> <mailto:lightning-dev-request at lists.linuxfoundation.org>>:\n>\n>     Send Lightning-dev mailing list submissions to\n>     lightning-dev at lists.linuxfoundation.org\n>     <mailto:lightning-dev at lists.linuxfoundation.org>\n>\n>     To subscribe or unsubscribe via the World Wide Web, visit\n>     https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>     or, via email, send a message with subject or body 'help' to\n>     lightning-dev-request at lists.linuxfoundation.org\n>     <mailto:lightning-dev-request at lists.linuxfoundation.org>\n>\n>     You can reach the person managing the list at\n>     lightning-dev-owner at lists.linuxfoundation.org\n>     <mailto:lightning-dev-owner at lists.linuxfoundation.org>\n>\n>     When replying, please edit your Subject line so it is more specific\n>     than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n>     Today's Topics:\n>\n>        1. Proposal: Decentralized Service Provider (Samuel Kremser)\n>\n>\n>     ----------------------------------------------------------------------\n>\n>     Message: 1\n>     Date: Fri, 11 Mar 2016 09:49:49 +0100\n>     From: Samuel Kremser <sam at kremser-crypto.org\n>     <mailto:sam at kremser-crypto.org>>\n>     To: lightning-dev at lists.linuxfoundation.org\n>     <mailto:lightning-dev at lists.linuxfoundation.org>\n>     Subject: [Lightning-dev] Proposal: Decentralized Service Provider\n>     Message-ID: <56E286AD.5060506 at kremser-crypto.org\n>     <mailto:56E286AD.5060506 at kremser-crypto.org>>\n>     Content-Type: text/plain; charset=utf-8; format=flowed\n>\n>     Hi Guys!\n>\n>     I wanna make a improvement proposal for the Lightning Network and\n>     would\n>     like to hear your thoughts about it.\n>     I am calling it: Decentralized Service Provider (DSP).\n>\n>     A Decentralized Service Provider (DSP) could grant end users access to\n>     the Ligthning Network, so they wouldn't have to validate\n>     the Blockchain or care about closing times of channels. Also end users\n>     would enjoy the benefit of propably much larger\n>     (filled with more Bitcoins) channels which allows them to send and\n>     receive more money, since all users of one DSP would share their\n>     channel(s).\n>\n>     Each DSP consists of several entities (propbly also geographically\n>     distributed).\n>     These entities manage the DSP's tasks in a collaborative way.\n>     These Tasks are:\n>     1. Managing Bitcoin deposits and withdrawals\n>     2. Managing the Lightning Network Channel(s)\n>     3. Managing communication with end users and the Lightning Network\n>\n>     Deposit addresses for the DSP are multi-sig addresses, so that a\n>     majority of a DSP's entities is required to sign withdrawals.\n>     Also the Lightning Network channels are managed in this multi-sig\n>     style   .....erm.....  yes i am aware that Lightning Network channels\n>     are multig-sig anyway, what i wanted to say is: a update to the\n>     channel\n>     reqiures now a majority of the DSP's entities to singn AND\n>     the other side of that channel to sign. In case both sides of the\n>     Lighting Network channel are DSPs the majority of both DSP's entities\n>     need to sign.\n>\n>     Due to this multi-sig construction a single entity of a DSP couldn't\n>     steal the end users Bitcoins. It would actually reqire the majority of\n>     entities of\n>     one DSP to collaborate to steal the end users money.\n>\n>     DSP's entities communicate with signed messages with their end\n>     users and\n>     with each other, so everything is provable. Whenever some entity\n>     of a DSP\n>     is acting malicious the other entities of that DSP can decide to\n>     exclude\n>     this entity from this DSP by transferring control of the managed\n>     Bitcoins and\n>     channels to some new multi-sig address(es)/channel(s) that doesn't\n>     require the malicous acting entity's signature.\n>     This could also be done if one entity isn't reliable available.\n>\n>     Another advantage of DSP's would be that fewer channels are reqired,\n>     since not every end user needs his own channel. Thus DSPs could\n>     save even\n>     more space on the Blockchain than Lightning alone.\n>\n>     Thanks for your attention!\n>\n>     Sam\n>\n>\n>\n>     ------------------------------\n>\n>     _______________________________________________\n>     Lightning-dev mailing list\n>     Lightning-dev at lists.linuxfoundation.org\n>     <mailto:Lightning-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>     End of Lightning-dev Digest, Vol 10, Issue 14\n>     *********************************************\n>\n>\n>\n>\n> -- \n>\n> \"If two developers can fork Bitcoin and succeed in redefining what \n> \"Bitcoin\" is, in the face of widespread technical criticism and \n> through the use of populist tactics, then I will have no choice but to \n> declare Bitcoin a failed project. Bitcoin was meant to be both \n> technically and socially robust. This present situation has been very \n> disappointing to watch unfold.\"\n>\n> Satoshi Nakamoto\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160401/047895ef/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning-dev Digest, Vol 10, Issue 14",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Samuel Kremser"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7653
        }
    },
    {
        "title": "[Lightning-dev] Maintenance service for Lightning Network",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-04-04T02:19:32",
                "message_text_only": "Kumaigorodskiy Anton <anton.kumaigorodskiy at outlook.com> writes:\n> Hi everyone,\n\nHi Anton!\n\n        Sorry for the delay in response: these are great questions and\ndeserve a thought-through response.\n\n> I think LN is a great idea and would like to add it to my Bitcoin wallet. I've been thinking for some time now about how LN could work for an end users (ideally dealing with it should be less frustrating than dealing with Bitcoin itself).\n\nThis is definitely worth thinking about.\n\n> As far as I understand a payment sender needs to obtain at least three \"core\" pieces of data before he can start interacting with LN (plus maybe some metadata):\n> 1. Required hash of R-value.\n> 2. Required list of \"full node\" URL's where receiver currently has\n> open channels.\n> 3. Required list of receiver ID's for each \"full node\" (so \"full node\"\n> will know whom to ask for R-value).\n> 4. Optional but sometimes desirable metadata like name, picture,\n> address etc.\n\nIt's slightly more general.  You need the R-hash, and one (or more)\nroutes.  In particular, you need the fee information for the route.\n\nMy current thinking is:\n0) Nodes have an ID, which is a bitcoin-style pubkey.\n1) Nodes publish their public routes by proving they own the anchor\n   transactions for their channels.\n2) Nodes occasionally update their fees for their channels.\n3) Every 24 hours(?) a new set of (10?) landmarks are selected using the\n   bitcoin block hash.\n4) Every node keeps information on routes to and from the landmarks.\n\nThis means a step in a route can be represented as a block number and a\ntransaction number, making them quite compact.  To accept a payment you\nwould give:\n\n1) A unique hash of R-value.\n2) An amount.\n3) Route information from a landmark to you.  Maybe more than one.\n\nIt also means that the receiving node doesn't know where the sending\nnode is.\n\n> And further requirements:\n> - \"Lightning address\" and QR-code approach won't work as R-value should be unique. Ideally no piece of \"core\" data should be easily accessible as text or QR to avoid confusion.\n\nIf you want you can do donation-style send by having the sender encode\nthe R-value inside the routing information.  But you'll still need\nfairly recent routing information.\n\n> - \"core\" data sould come directly from receiver's device, either via internet or locally wia bluetooth, WiFiP2P, NFC, etc.\n> - Sender needs a way to verify that receiver is who he says he is which means resistance to MITM and identity theft plus some kind of \"name authority\" to validate metadata.\n> Taking all the above into account it seems to me that:\n> 1. LN users should be able to generate stable identites on their\n> devices. EC25519 keys seem a good fit to me because of their small\n> size and applicability for both encryption and signing.\n\nWe've chosen to use the bitcoin curve, since we rely on it anyway.\n\n> 2. There has to be a service parallel to LN that can transfer \"core\"\n> data in encrypted form (easy because identities are pubKeys), perhaps\n> store requests for some time if receiver's device is offline,\n> optionally act as third-party watcher for broadcasted commitment\n> transactions and, finally, act as \"name authority\" for users who\n> supplied some metadata along with their public keys.\n\nSince we need to store and send route information, adding other\ninformation should be fairly easy.\n\nOffline receive is much harder, and I'm not planning on supporting it in\na 1.0 spec.  Either the receiver needs to trust someone to collect the\npayment, or pay extra for all the funds they will tie up in the network\nwaiting for the receiver to come online.\n\nHope that clarifies my thinking (and I'm sure others will add their\nthoughts too!).\n\nCheers,\nRusty."
            },
            {
                "author": "Kumaigorodskiy Anton",
                "date": "2016-04-05T17:47:34",
                "message_text_only": "Thanks for clarifying how routing data is supposed to work. Still I don't quite understand how one can make an initial payment request. What I mean is say I run a Lightning node on my phone and someone knows my bitcoin-pubkey-style ID only, how can our devices connect for me to provide all the info upon request?  \n\n\nOne way I can think of is both our devices should establish a socket connections to current landmark nodes and continue communication through one of them but this can be overwhelming both for a phone (10? websocket connections at once) and for landmark nodes (possibly billions of socket connections).  \n\n\nOr perhaps there could be some deterministic method that, given a user's ID and overall network topology, would determine to what exact node should that exact ID connect? This could at least distribute the load across the network.  \n\n\nAnd then there are DDoS attacks, as far as I understand it could be fairly easy for someone to spam a Lightning device with millions of payment requests. This perhaps could be mitigated with requests rationing via blind signatures but I have no idea how to enforce that on a distributed network.\n\n\nAnton Kumaigorodskiy\n\n\n> From: rusty at rustcorp.com.au\n> To: anton.kumaigorodskiy at outlook.com; lightning-dev at lists.linuxfoundation.org\n> Subject: Re: [Lightning-dev] Maintenance service for Lightning Network\n> Date: Mon, 4 Apr 2016 11:49:32 +0930\n> \n> Kumaigorodskiy Anton  writes:\n>> Hi everyone,\n> \n> Hi Anton!\n> \n> Sorry for the delay in response: these are great questions and\n> deserve a thought-through response.\n> \n>> I think LN is a great idea and would like to add it to my Bitcoin wallet. I've been thinking for some time now about how LN could work for an end users (ideally dealing with it should be less frustrating than dealing with Bitcoin itself).\n> \n> This is definitely worth thinking about.\n> \n>> As far as I understand a payment sender needs to obtain at least three \"core\" pieces of data before he can start interacting with LN (plus maybe some metadata):\n>> 1. Required hash of R-value.\n>> 2. Required list of \"full node\" URL's where receiver currently has\n>> open channels.\n>> 3. Required list of receiver ID's for each \"full node\" (so \"full node\"\n>> will know whom to ask for R-value).\n>> 4. Optional but sometimes desirable metadata like name, picture,\n>> address etc.\n> \n> It's slightly more general. You need the R-hash, and one (or more)\n> routes. In particular, you need the fee information for the route.\n> \n> My current thinking is:\n> 0) Nodes have an ID, which is a bitcoin-style pubkey.\n> 1) Nodes publish their public routes by proving they own the anchor\n> transactions for their channels.\n> 2) Nodes occasionally update their fees for their channels.\n> 3) Every 24 hours(?) a new set of (10?) landmarks are selected using the\n> bitcoin block hash.\n> 4) Every node keeps information on routes to and from the landmarks.\n> \n> This means a step in a route can be represented as a block number and a\n> transaction number, making them quite compact. To accept a payment you\n> would give:\n> \n> 1) A unique hash of R-value.\n> 2) An amount.\n> 3) Route information from a landmark to you. Maybe more than one.\n> \n> It also means that the receiving node doesn't know where the sending\n> node is.\n> \n>> And further requirements:\n>> - \"Lightning address\" and QR-code approach won't work as R-value should be unique. Ideally no piece of \"core\" data should be easily accessible as text or QR to avoid confusion.\n> \n> If you want you can do donation-style send by having the sender encode\n> the R-value inside the routing information. But you'll still need\n> fairly recent routing information.\n> \n>> - \"core\" data sould come directly from receiver's device, either via internet or locally wia bluetooth, WiFiP2P, NFC, etc.\n>> - Sender needs a way to verify that receiver is who he says he is which means resistance to MITM and identity theft plus some kind of \"name authority\" to validate metadata.\n>> Taking all the above into account it seems to me that:\n>> 1. LN users should be able to generate stable identites on their\n>> devices. EC25519 keys seem a good fit to me because of their small\n>> size and applicability for both encryption and signing.\n> \n> We've chosen to use the bitcoin curve, since we rely on it anyway.\n> \n>> 2. There has to be a service parallel to LN that can transfer \"core\"\n>> data in encrypted form (easy because identities are pubKeys), perhaps\n>> store requests for some time if receiver's device is offline,\n>> optionally act as third-party watcher for broadcasted commitment\n>> transactions and, finally, act as \"name authority\" for users who\n>> supplied some metadata along with their public keys.\n> \n> Since we need to store and send route information, adding other\n> information should be fairly easy.\n> \n> Offline receive is much harder, and I'm not planning on supporting it in\n> a 1.0 spec. Either the receiver needs to trust someone to collect the\n> payment, or pay extra for all the funds they will tie up in the network\n> waiting for the receiver to come online.\n> \n> Hope that clarifies my thinking (and I'm sure others will add their\n> thoughts too!).\n> \n> Cheers,\n> Rusty.\n \t\t \t   \t\t  \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160405/29c38836/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-13T00:36:19",
                "message_text_only": "Kumaigorodskiy Anton <anton.kumaigorodskiy at outlook.com> writes:\n> Thanks for clarifying how routing data is supposed to work. Still I don't quite understand how one can make an initial payment request. What I mean is say I run a Lightning node on my phone and someone knows my bitcoin-pubkey-style ID only, how can our devices connect for me to provide all the info upon request?  \n\nThe idea was that you provide them with the information, via a QR code\nor whatever.\n\nWe won't be (in the short term, at least) routing general messages over\nthe lightning network.\n\n> Or perhaps there could be some deterministic method that, given a user's ID and overall network topology, would determine to what exact node should that exact ID connect? This could at least distribute the load across the network.  \n\nIt has been suggested that we use a DHT for mapping nodeid -> metadata.\nThat's pretty long term though.\n\n> And then there are DDoS attacks, as far as I understand it could be fairly easy for someone to spam a Lightning device with millions of payment requests. This perhaps could be mitigated with requests rationing via blind signatures but I have no idea how to enforce that on a distributed network.\n\nIndeed.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Maintenance service for Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Kumaigorodskiy Anton"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 10337
        }
    },
    {
        "title": "[Lightning-dev] Laundry list of inter-peer wire protocol changes",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2016-04-07T20:21:53",
                "message_text_only": "CJP schreef op di 02-02-2016 om 18:56 [+0100]:\n> \n> > > * Reserving before locking: this is an optimization, to reduce the risk\n> > > of locking funds in payment channels on a part of the route, and then\n> > > having to undo the locking when it turns out that the remaining part of\n> > > the route doesn't exist (anymore). Reserving is an informal(*),\n> > > temporary locking of funds for use in the transaction, and can be done\n> > > and undone very fast, without any channel operations. It is done\n> > > together with route searching + establishment.\n> > \n> > I think that trades one DoS for another, though.  It saves cryptographic\n> > constructs, but latency is the real cost, and this increases it.\n> > \n> > Of course, we'll have to revisit that if the network in practice proves\n> > subject to these problems...\n> \n> For one category of channel designs, reserving is absolutely essential:\n> channels where bi-directional payments are made possible with a\n> decrementing lock time. There, you want to make sure that failed routing\n> attempts don't cause lock time decrements, since that would reduce the\n> channel lifetime more than necessary. I'd have to check whether there is\n> still any use case for this channel design, and whether the reserving\n> step is important for some other reason.\n\nAfter actually implementing some of these things, I'd like to revisit\nthis discussion.\n\nThe \"reserving\" stage used to be important for channel types where the\nbi-directional nature of the channel is realized with decreasing lock\ntimes (see above). Now that a large part of the community has put its\nhope on Lightning, it's more likely that the extensions required for\nbetter channel types will be included in Bitcoin, so this issue has\nbecome less important.\n\nAnother reason why the \"reserving\" stage is important, is that it it\nnecessary for bi-directional routing. In order to make both payer and\npayee anonymous, we need to provide this feature, where both route to a\nmeeting point. For the part between meeting point and payee, routing\ngoes from payee to meeting point(*), but locking goes from meeting point\nto payee, so they can't be done in the same stage.\n\nFinally, the \"reserving\" stage allows you to set a tighter value on the\nHTLC time-outs. If you do routing together with locking, then routing\nhas to go in the payer->payee direction; the time-out has to be reduced\non every hop. Assuming(**) the payer doesn't know the number of hops in\nadvance, the time-out has to be set to a very high value by the payer,\nto maximize chances of a successful transaction. If you do routing in\nthe reverse direction (payee->payer), you can start with a very low\ntime-out, and increment it on every hop. This will generally result in\nlower time-out values, which is desirable.\n\nThat's about it, for the advantages offered by the separate reserving\nstage in Amiko Pay. Let me finish with an attempt to make an ASCII-art\nsequence diagram of reserving, bi-directional routing and locking in\nAmiko Pay:\n\nH(R) = the transaction hash (also included in other messages)\nMR() = MakeRoute message without time info\nMR(t) = MakeRoute message with time info\nHR() = HaveRoute message without time info\nHR(t) = HaveRoute message\nL(t) = Lock message (adds HTLC to channel)\nA = Alice (payer)\nB = Bob (meeting point)\nC = Carol (intermediate node). There can be many intermediate nodes\nbetween A and B, and between B and D.\nD = Dave (payee)\n\nA               B               C             D\n|<------------------ H(R) --------------------|\n|------MR()---->|               |<-MR(T0+dt)--|\n                |<-MR(T0+2*dt)--|\n|<-HR(T0+3*dt)--|--HR(T0+2*dt)->|\n                                |--HR(T0+dt)->|\n|<------------------ HR() --------------------|\n|--L(T0+3*dt)-->|--L(T0+2*dt)-->|--L(T0+dt)-->|\n\n(...and then the sequence continues with removing the HTLCs and\nreleasing funds towards payee-side of each channel.)\n\n\nCJP\n\n(*) It can't go in the other direction, since the meeting point should\nnot know the identity (or network address) of the payee.\n\n(**) This is the case for non-source routing. One advantage of\nnon-source routing is that nodes don't need a map of the entire network;\nthis improves privacy, and could help to keep the network open to new\nparticipants, even against the will of many powerful existing\nparticipants. In the end, I imagine a system where a mix of\nsource-routing and non-source routing can be used, to get the best of\nboth worlds."
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-12T01:36:51",
                "message_text_only": "\"C.J. Plooy\" <cjplooy at ultimatestunts.nl> writes:\n> CJP schreef op di 02-02-2016 om 18:56 [+0100]:\n>> \n>> > > * Reserving before locking: this is an optimization, to reduce the risk\n>> > > of locking funds in payment channels on a part of the route, and then\n>> > > having to undo the locking when it turns out that the remaining part of\n>> > > the route doesn't exist (anymore). Reserving is an informal(*),\n>> > > temporary locking of funds for use in the transaction, and can be done\n>> > > and undone very fast, without any channel operations. It is done\n>> > > together with route searching + establishment.\n>> > \n>> > I think that trades one DoS for another, though.  It saves cryptographic\n>> > constructs, but latency is the real cost, and this increases it.\n>> > \n>> > Of course, we'll have to revisit that if the network in practice proves\n>> > subject to these problems...\n>> \n>> For one category of channel designs, reserving is absolutely essential:\n>> channels where bi-directional payments are made possible with a\n>> decrementing lock time. There, you want to make sure that failed routing\n>> attempts don't cause lock time decrements, since that would reduce the\n>> channel lifetime more than necessary. I'd have to check whether there is\n>> still any use case for this channel design, and whether the reserving\n>> step is important for some other reason.\n>\n> After actually implementing some of these things, I'd like to revisit\n> this discussion.\n>\n> The \"reserving\" stage used to be important for channel types where the\n> bi-directional nature of the channel is realized with decreasing lock\n> times (see above). Now that a large part of the community has put its\n> hope on Lightning, it's more likely that the extensions required for\n> better channel types will be included in Bitcoin, so this issue has\n> become less important.\n>\n> Another reason why the \"reserving\" stage is important, is that it it\n> necessary for bi-directional routing. In order to make both payer and\n> payee anonymous, we need to provide this feature, where both route to a\n> meeting point. For the part between meeting point and payee, routing\n> goes from payee to meeting point(*), but locking goes from meeting point\n> to payee, so they can't be done in the same stage.\n\nThis is an interesting problem.  I previously beleived this could be\ndone by some tunnelling mechanism in the meeting point (unknown to the\npayer), except that the timeouts are a problem.  So it can still be\ndone, but the payer would have to be told to bump their timeouts.\n\nI fear the complexity of implementing a two-way reservation scheme\nup-front, however.  It implies that the payee knows the timing of the\npayer, and adds failure modes when that's wrong.\n\nI also dislike meeting points by default: there's a whole extra layer of\ndeciding what meeting points to use.  Beacons can be bypassed (if you\nnotice the route is the same to and from, which is more likely if\nbeacons are less connected).\n\n> Finally, the \"reserving\" stage allows you to set a tighter value on the\n> HTLC time-outs. If you do routing together with locking, then routing\n> has to go in the payer->payee direction; the time-out has to be reduced\n> on every hop. Assuming(**) the payer doesn't know the number of hops in\n> advance, the time-out has to be set to a very high value by the payer,\n> to maximize chances of a successful transaction. If you do routing in\n> the reverse direction (payee->payer), you can start with a very low\n> time-out, and increment it on every hop. This will generally result in\n> lower time-out values, which is desirable.\n\nWith onioning, we need source routing.  However, we can still get some\nof the benefits by splitting the stages, and having a non-binding\npropose message.\n\nie. currently BOLT#2 has a complete HTLC negotiation looking like this:\n\n update_add_htlc ->\n update_commit ->\n                      <- update_revocation\n                      <- update_commit\n update_revocation ->                     \n\nThe receiver can't forward the htlc until it knows the sender is bound\nto honour it, which takes these three trips.\n\nIf we introduce a non-binding step before the \"add_htlc\" (say\n\"introduce_htlc\"), this is possible: the receiver could forward the\n\"introduce_htlc\" instantly.  Then there would be a (non-binding)\nfeedback message, and a \"cancel_htlc\".\n\nThat would allow faster feedback, such as fee or route changes or\noutright failure.\n\nThoughts?\n\n> That's about it, for the advantages offered by the separate reserving\n> stage in Amiko Pay. Let me finish with an attempt to make an ASCII-art\n> sequence diagram of reserving, bi-directional routing and locking in\n> Amiko Pay:\n>\n> H(R) = the transaction hash (also included in other messages)\n> MR() = MakeRoute message without time info\n> MR(t) = MakeRoute message with time info\n> HR() = HaveRoute message without time info\n> HR(t) = HaveRoute message\n> L(t) = Lock message (adds HTLC to channel)\n> A = Alice (payer)\n> B = Bob (meeting point)\n> C = Carol (intermediate node). There can be many intermediate nodes\n> between A and B, and between B and D.\n> D = Dave (payee)\n>\n> A               B               C             D\n> |<------------------ H(R) --------------------|\n> |------MR()---->|               |<-MR(T0+dt)--|\n>                 |<-MR(T0+2*dt)--|\n> |<-HR(T0+3*dt)--|--HR(T0+2*dt)->|\n>                                 |--HR(T0+dt)->|\n> |<------------------ HR() --------------------|\n> |--L(T0+3*dt)-->|--L(T0+2*dt)-->|--L(T0+dt)-->|\n>\n> (...and then the sequence continues with removing the HTLCs and\n> releasing funds towards payee-side of each channel.)\n\nThis is a more interactive protocol.  Which is nice in some ways, but I\nfeel it's also more complex and more subject to timing analysis.\n\nIf we were to extend the protocol later, this would fit fairly nicely,\nthough.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Laundry list of inter-peer wire protocol changes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "CJP"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 10288
        }
    },
    {
        "title": "[Lightning-dev] Routing & Beacons",
        "thread_messages": [
            {
                "author": "laurentmt",
                "date": "2016-04-11T09:20:49",
                "message_text_only": "Hi there,\n\nJust a LN noob here. I'm intrigued by the idea of routing based on\nbeacons. Is it somewhat similar to the Pulse Protocol\n(http://www.cs.jhu.edu/~dholmer/600.647/papers/pulse_infrastructure_access.pdf)\nwith a periodic computation of spanning trees rooted at beacons nodes ?\n\nlaurent"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-13T00:40:54",
                "message_text_only": "laurentmt <laurentmt145 at gmail.com> writes:\n> Hi there,\n>\n> Just a LN noob here. I'm intrigued by the idea of routing based on\n> beacons. Is it somewhat similar to the Pulse Protocol\n> (http://www.cs.jhu.edu/~dholmer/600.647/papers/pulse_infrastructure_access.pdf)\n> with a periodic computation of spanning trees rooted at beacons nodes ?\n\nHi Laurent!\n\n        There are several ways to do routing via a known set of\nlandmarks.  Since each node is interested in the cheapest route to and\nfrom each beacon, that's pretty easy to propagate (simply always\nbroadcast the best route you know about).\n\n        Of course, if rates are expressed as \"base + per-satoshi-amount\"\nthen \"cheapest\" depends on the amount, so some heuristics will be\nrequired.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Routing & Beacons",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "laurentmt"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1054
        }
    },
    {
        "title": "[Lightning-dev] Fwd: Re:  Routing & Beacons",
        "thread_messages": [
            {
                "author": "laurentmt",
                "date": "2016-04-15T12:20:31",
                "message_text_only": "Hi Rusty,\n\nIf I'm correct, it means that on a given period all payments go through\nthe selected beacons nodes ?\n\nI ask this because some protocols like the pulse protocol are also based\non beacons to update the routing tables but they don't require that all\n\"messages\" go through the beacons. \"Messages\" go through the first\ncommon ancestor of source and target in the spanning tree associated to\nthe selected beacon.\n\nThe main drawback with this approach is that the source doesn't know the\nroute beforehand... The main advantage is that it puts less \"pressure\"\non the beacons.\n\n\nAnother question: have you already decided on an update strategy for the\nrouting tables?\n\nAs I understand the problem, there's 2 variables which determine the\nbest route:\n\n- capacity of channels at time t (max number of bitcoins I can transfer\nthrough a given channel). It determines if a route can be used to\ntransfer the amount.\n\n- fees charged by nodes. It determines the best route.\n\nCapacity is likely the most dynamic of the two variables. Do you\nconsider capacity as an information stored in the routing tables (but it\nmay be very challenging to keep tables up to date) or is it checked \"in\nlive\" when the payment is propagated ?\n\nlaurent\n\n\n\nLe 13/04/2016 02:40, Rusty Russell a \u00e9crit :\n> laurentmt <laurentmt145 at gmail.com> writes:\n>> Hi there,\n>>\n>> Just a LN noob here. I'm intrigued by the idea of routing based on\n>> beacons. Is it somewhat similar to the Pulse Protocol\n>> (http://www.cs.jhu.edu/~dholmer/600.647/papers/pulse_infrastructure_access.pdf)\n>> with a periodic computation of spanning trees rooted at beacons nodes ?\n> \n> Hi Laurent!\n> \n>         There are several ways to do routing via a known set of\n> landmarks.  Since each node is interested in the cheapest route to and\n> from each beacon, that's pretty easy to propagate (simply always\n> broadcast the best route you know about).\n> \n>         Of course, if rates are expressed as \"base + per-satoshi-amount\"\n> then \"cheapest\" depends on the amount, so some heuristics will be\n> required.\n> \n> Cheers,\n> Rusty.\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-26T00:43:41",
                "message_text_only": "laurentmt <laurentmt145 at gmail.com> writes:\n> Hi Rusty,\n>\n> If I'm correct, it means that on a given period all payments go through\n> the selected beacons nodes ?\n\nTo a first approximation, yes (obviously, if the route would go in and\nout the same channel, it can be eliminated, but that's statistically\nunlikely for a well-connected beacon).\n\nBTW, the literature seems to use the term \"landmarks\", so I'm trying to stop\nsaying \"beacons\" :)\n\n> I ask this because some protocols like the pulse protocol are also based\n> on beacons to update the routing tables but they don't require that all\n> \"messages\" go through the beacons. \"Messages\" go through the first\n> common ancestor of source and target in the spanning tree associated to\n> the selected beacon.\n>\n> The main drawback with this approach is that the source doesn't know the\n> route beforehand... The main advantage is that it puts less \"pressure\"\n> on the beacons.\n\nYes, I'd really like something better, but the beacon/landmark idea is\nsimple, enables a one-pass communication for the route (here's a QR code\non how to reach me from N landmarks), and doesn't require the receiver\nto know the buyer's location.\n\n> Another question: have you already decided on an update strategy for the\n> routing tables?\n\nNo, I haven't.  Thoughts welcome :)\n\n> As I understand the problem, there's 2 variables which determine the\n> best route:\n>\n> - capacity of channels at time t (max number of bitcoins I can transfer\n> through a given channel). It determines if a route can be used to\n> transfer the amount.\n>\n> - fees charged by nodes. It determines the best route.\n>\n> Capacity is likely the most dynamic of the two variables. Do you\n> consider capacity as an information stored in the routing tables (but it\n> may be very challenging to keep tables up to date) or is it checked \"in\n> live\" when the payment is propagated ?\n\nMy base assumption is that payments are generally smaller than channel\ncapacity, i.e. micropayments.  Also, the route map itself is fairly\nstatic, and in fact could be fully known to a node: the pricing\ninformation is dynamic and needs careful thought.\n\nYou want a payment to Just Work most of the time; getting routefails and\nforcing retries should be unusual.\n\nMy current idea (beyond a prototype where every node chats on IRC\nindicating their current routes and prices) is that:\n\n1) Prices are indicated as base + per-satoshi cost.\n2) Nodes are ratelimited on their pricing updates (say, once every 30\n   seconds, perhaps with some burst capacity).\n\nI'm also considering that price changes phase in over time, indicating\nhow they change over time from some base (eg. \"increase by .01 satoshi\nevery second from X until Y\").  My concern is that slight price changes\nmay cause massive changes in terms of traffic (once a parallel route\nbecomes cheaper), so that makes sense.  Some ratelimiting is definitely\nnecessary because competition may well cause such route-flap.\n\nAnd note that base+per-satoshi means \"best route\" selection depends on\nthe value you're sending, so a handful of nominal values are probably\nrequired (so there may be different \"best routes\" for each one).\n\nThere's also the question of how to handle false advertising.  Ideally,\nyou should be able to broadcast the response from a node which refuses\nto route your payment.  That gets a little complicated with onioning: it\nwould have to sign the hash of the onion, HTLC and the routefail\nmessage, which would be checked by the previous node and encrypted,\nonioned all the way back to the source.  If one node signs a invalid\nmessage, that can be broadcast and the node blacklisted.  The sender can\nreveal the onion at that point and the decode key, and show that the\nnode refused to route.  It can then be temporarily blacklisted.\n\nSorry if this raises more questions than answers!\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Fwd: Re:  Routing & Beacons",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "laurentmt"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5919
        }
    },
    {
        "title": "[Lightning-dev] Concurrent sigs in BOLT #2",
        "thread_messages": [
            {
                "author": "Pierre",
                "date": "2016-04-24T19:29:22",
                "message_text_only": "Hello,\n\nI am trying to understand how we should handle concurrent signatures,\nand I am wondering if we couldn't use an ordering of some sort to\nresolve conflicts when they occur, for example by simply comparing\nsignatures. If two nodes send each other a signature at the same time,\nthey could agree that the one that sent the \"greatest\" signature has\nto immediately resend a new signature including all pending changes.\nThis new signature would encompass all the changes both parties wanted\nin the first place so everybody would be happy.\n\nFor example if \"SIG B0 > SIG A0\":\n\n           NODE A                            NODE B\n\n    Committed: []                                 Committed: []\n    Staged:    [X]                                Staged:    [Y]\n                ADD HTLC X ----        ---- ADD HTLC Y\n                               \\      /\n                                \\    /\n    Committed: [X]               \\  /             Committed: [Y]\n    Staged:    []                 \\/              Staged:    []\n                    SIG A0 ---    /\\    --- SIG B0\n                              \\  /  \\  /\n                               \\/    \\/\n                               /\\    /\\\n                           <---  \\  /  --->\n    Committed: [X]                \\/              Committed: [Y]\n    Staged:    [Y]                /\\              Staged: [X]\n                                 /  \\\n                                /    \\\n            DISCARD SIG A0 <----      -----> DISCARD SIG B0\n    Committed: []                                 Committed: []\n    Staged:    [X Y]                              Staged: [X Y]\n\n                                                  Committed: [X Y]\n                                                  Staged: []\n                           <---------------- SIG B1\n    Committed: [X Y]\n    Staged: []\n\n                REVOCATION ---------------->\n\n                    SIG A1 ---------------->\n\n                           <---------------- REVOCATION\n\nCheers,\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-26T02:21:00",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hello,\n\nHi Pierre!\n\n        I'm glad I'm not the only one who had trouble with this.  I just\nthought I was being dumb!  Concurrent updates are conceptually harder\nthan the previous synchronous model, unfortunately.\n\n> I am trying to understand how we should handle concurrent signatures,\n> and I am wondering if we couldn't use an ordering of some sort to\n> resolve conflicts when they occur, for example by simply comparing\n> signatures. If two nodes send each other a signature at the same time,\n> they could agree that the one that sent the \"greatest\" signature has\n> to immediately resend a new signature including all pending changes.\n> This new signature would encompass all the changes both parties wanted\n> in the first place so everybody would be happy.\n\nI originally had an alternating priority scheme which worked, but I don't\nthink it's necessary any more.\n\nThis diagram is a simplification.  Each node tracks two commitment\nstates: its own and the state of the other side.  This is because they\ncan run independently.\n\nThe rules are simple (though the results might not be!):\n\n1) Nodes must process packets in order.\n2) When you send something, update their state.\n3) When you ack something, update their state.\n4) When you receive something, update your own state.\n5) When you receive an ack for something, update your own state.\n\nWhen you sign a commit tx, you sign their state at the time (this makes\nsense: you're signing their commit tx, not yours).\n\nSo, when a node sends an ADD HTLC, it modifies the other side's state.\nIt only modifies its own state when it receives an ack covering that ADD\nHTLC.\n\nThe ADD HTLC receiver modifies its own state, and modifies the other\nside's state when it sends the next ack (in practice, we do that\nimmediately because it doesn't matter, but diagram below does it\nstrictly).\n\nThus, in your case:\n\n           NODE A                            NODE B\n\n    Committed: []                                 Committed: []\n    States:    [] [X]                             States:    [] [Y]\n                ADD HTLC X ----        ---- ADD HTLC Y\n                               \\      /\n                                \\    /\n    Committed: []                \\  /             Committed: []\n    States:    [] [X]             \\/              States:    [] [Y]\n                    SIG A0 ---    /\\    --- SIG B0\n                              \\  /  \\  /\n                               \\/    \\/\n                               /\\    /\\\n                           <---  \\  /  --->\n    Committed: []                 \\/              Committed: []\n    States:    [Y] [X]            /\\              States: [X] [Y]\n                                 /  \\\n                                /    \\\n                           <----      -----> \n    Committed: [Y]                                Committed: [X]\n    States:    [Y] [X]                            States: [X] [Y]\n\nNow, at this point both nodes have outstanding changes, so they can send\nanother SIG (which acks the received changes, thus modifying the other\nstate):\n\n    Committed: [Y]                                Committed: [X]\n    States:    [Y] [X Y]                          States: [X] [X Y]\n                    SIG A1 ---          --- SIG B1\n                              \\        /\n                               \\      /\n                                \\    / \n                                 \\  /      \n                                  \\/              \n                                  /\\              \n                                 /  \\\n                                /    \\\n                           <----      -----> \nPROCESS ACK:\n    Committed: [Y]                                Committed: [X]\n    States:    [X Y] [X Y]                        States: [X Y] [X Y]\nPROCESS SIG:\n    Committed: [X Y]                              Committed: [X Y]\n    States:    [X Y] [X Y]                        States: [X Y] [X Y]\n\n\nFWIW, note that the minimum single-update case is still 1.5 round-trips:\n\n           NODE A                            NODE B\n\n    Committed: []                                 Committed: []\n    States:    [] [X]                             States:    [] []\n                ADD HTLC X -------------------->\n                \n    Committed: []                                 Committed: []\n    States:    [] [X]                             States:    [X] []\n                SIG A1 -------------------->\n                \n    Committed: []                                 Committed: [X]\n    States:    [] [X]                             States:    [X] [X]\n                <---------------------- REVOKE B0\n                <------------------------- SIG B1\n                \n    Committed: [X]                                Committed: [X]\n    States:    [X] [X]                            States:    [X] [X]\n                ----------------------> REVOKE A0\n\nCheers,\nRusty."
            },
            {
                "author": "Fabrice Drouin",
                "date": "2016-04-28T10:39:51",
                "message_text_only": "Hi!\n\nOn 26 April 2016 at 04:21, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> Pierre <pm+lists at acinq.fr> writes:\n>> Hello,\n>\n> Hi Pierre!\n>\n>         I'm glad I'm not the only one who had trouble with this.  I just\n> thought I was being dumb!  Concurrent updates are conceptually harder\n> than the previous synchronous model, unfortunately.\n>\n>> I am trying to understand how we should handle concurrent signatures,\n>> and I am wondering if we couldn't use an ordering of some sort to\n>> resolve conflicts when they occur, for example by simply comparing\n>> signatures. If two nodes send each other a signature at the same time,\n>> they could agree that the one that sent the \"greatest\" signature has\n>> to immediately resend a new signature including all pending changes.\n>> This new signature would encompass all the changes both parties wanted\n>> in the first place so everybody would be happy.\n>\n> I originally had an alternating priority scheme which worked, but I don't\n> think it's necessary any more.\n>\n> This diagram is a simplification.  Each node tracks two commitment\n> states: its own and the state of the other side.  This is because they\n> can run independently.\n>\n> The rules are simple (though the results might not be!):\n>\n> 1) Nodes must process packets in order.\n> 2) When you send something, update their state.\n> 3) When you ack something, update their state.\n> 4) When you receive something, update your own state.\n> 5) When you receive an ack for something, update your own state.\n>\n> When you sign a commit tx, you sign their state at the time (this makes\n> sense: you're signing their commit tx, not yours).\n>\n> So, when a node sends an ADD HTLC, it modifies the other side's state.\n> It only modifies its own state when it receives an ack covering that ADD\n> HTLC.\n>\n> The ADD HTLC receiver modifies its own state, and modifies the other\n> side's state when it sends the next ack (in practice, we do that\n> immediately because it doesn't matter, but diagram below does it\n> strictly).\n>\n> Thus, in your case:\n>\n>            NODE A                            NODE B\n>\n>     Committed: []                                 Committed: []\n>     States:    [] [X]                             States:    [] [Y]\n>                 ADD HTLC X ----        ---- ADD HTLC Y\n>                                \\      /\n>                                 \\    /\n>     Committed: []                \\  /             Committed: []\n>     States:    [] [X]             \\/              States:    [] [Y]\n>                     SIG A0 ---    /\\    --- SIG B0\n>                               \\  /  \\  /\n>                                \\/    \\/\n>                                /\\    /\\\n>                            <---  \\  /  --->\n>     Committed: []                 \\/              Committed: []\n>     States:    [Y] [X]            /\\              States: [X] [Y]\n>                                  /  \\\n>                                 /    \\\n>                            <----      ----->\n>     Committed: [Y]                                Committed: [X]\n>     States:    [Y] [X]                            States: [X] [Y]\n>\n> Now, at this point both nodes have outstanding changes, so they can send\n> another SIG (which acks the received changes, thus modifying the other\n> state):\n>\n>     Committed: [Y]                                Committed: [X]\n>     States:    [Y] [X Y]                          States: [X] [X Y]\n>                     SIG A1 ---          --- SIG B1\n>                               \\        /\n>                                \\      /\n>                                 \\    /\n>                                  \\  /\n>                                   \\/\n>                                   /\\\n>                                  /  \\\n>                                 /    \\\n>                            <----      ----->\n> PROCESS ACK:\n>     Committed: [Y]                                Committed: [X]\n>     States:    [X Y] [X Y]                        States: [X Y] [X Y]\n> PROCESS SIG:\n>     Committed: [X Y]                              Committed: [X Y]\n>     States:    [X Y] [X Y]                        States: [X Y] [X Y]\n>\n\nWhat if instead of immediately sending a new SIG, A and B then decide\nto send each\nother a new HTLC? Could we get stuck in an infinite loop where A and B\nnever converge on a\ncommitment tx?\nOr should it be specified that the only valid answer to a signature is\neither a signature (if there\nare outstanding changes) or a revocation ?\n\nCheers,\n\nFabrice"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-30T05:45:27",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> Hi!\n\nHi!\n\n>> Now, at this point both nodes have outstanding changes, so they can send\n>> another SIG (which acks the received changes, thus modifying the other\n>> state):\n>>\n>>     Committed: [Y]                                Committed: [X]\n>>     States:    [Y] [X Y]                          States: [X] [X Y]\n>>                     SIG A1 ---          --- SIG B1\n>>                               \\        /\n>>                                \\      /\n>>                                 \\    /\n>>                                  \\  /\n>>                                   \\/\n>>                                   /\\\n>>                                  /  \\\n>>                                 /    \\\n>>                            <----      ----->\n>> PROCESS ACK:\n>>     Committed: [Y]                                Committed: [X]\n>>     States:    [X Y] [X Y]                        States: [X Y] [X Y]\n>> PROCESS SIG:\n>>     Committed: [X Y]                              Committed: [X Y]\n>>     States:    [X Y] [X Y]                        States: [X Y] [X Y]\n>>\n>\n> What if instead of immediately sending a new SIG, A and B then decide\n> to send each\n> other a new HTLC? Could we get stuck in an infinite loop where A and B\n> never converge on a\n> commitment tx?\n\nYep, they need never converge (though they probably will).  But you\ndon't really care; as long as an HTLC committed to by both sides, it's\nlocked in.  Until then the receiver can't offer it onwards.\n\nAnd once it's no longer in both side's committed tx, it's invalid;\nbefore then the offerer must watch if it is getting close to the\ndeadline:\n\nBOLT #2:\n\n        Thus a node MUST estimate the deadline for successful redemption\n        for each HTLC it offers.  A node MUST NOT offer a HTLC after\n        this deadline, and MUST fail the connection if an HTLC which it\n        offered is in either node's current commitment transaction past\n        this deadline.\n\n> Or should it be specified that the only valid answer to a signature is\n> either a signature (if there\n> are outstanding changes) or a revocation ?\n\nI think you should be able to pack in as many updates between signatures\nas you want (though there's a 1500 maximum htlcs in the spec).\n\nWhether you offer other things is independent of whether you're being\nslow on signatures.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Concurrent sigs in BOLT #2",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Pierre",
                "Fabrice Drouin"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 13848
        }
    },
    {
        "title": "[Lightning-dev] Clearing process in BOLT #2",
        "thread_messages": [
            {
                "author": "Pierre",
                "date": "2016-04-29T11:38:53",
                "message_text_only": "Hello,\n\nI see a few issues with the clearing process as currently described in BOLT #2.\n\nThere seem to be a contradiction between:\n  \u00a74.1 \"A node MUST respond with update_fail_htlc to any HTLC received\nafter it sent close_clearing.\"\nand:\n  \u00a73.3 \"There are three reasons for removing an HTLC: it has timed\nout, it has failed to route, or the R preimage is supplied.\")\n  \u00a73.3 \"A node MUST check that id corresponds to an HTLC in its\ncurrent commitment transaction.\"\n\nIn \u00a74.1, the node must decline/remove the still-uncommitted HTLC,\nwhich is explicitely forbidden by \u00a73.3. AFAICT, in this version of the\nprocotol an HTLC can only be accepted, then committed, then removed.\nThere is no way to decline an HTLC, the receiver must always accept it\nexcept when the sender doesn't have the money or there are two many\npending HTLC, in which case the connection should be failed (\u00a73.2,\nalthough it is actually not clear for the too-many-htlc case).\n\nWe could decide to just fail the connection instead of declining the\nhtlc, but there is another issue: if the sender of a \"close_clearing\"\nmessage subsequently receives an update_add_htlc, there is no way to\ntell if the other party had received the close_clearing prior to\nsending the htlc since update_add_htlc message doesn't have an 'ack'\nfield.\n\nThere is potentially the same issue with the signature process: when\nnode A sends an update_commit message to B, it is expecting an\nupdate_revocation rather sooner than later. But what if B just ignores\nthe update_commit message and keeps sending new htlcs ? There is no\nway for A to be sure that B indeed received the update_commit, for the\nsame reason as above.\n\nCheers,\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-30T10:11:34",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hello,\n>\n> I see a few issues with the clearing process as currently described in BOLT #2.\n>\n> There seem to be a contradiction between:\n>   \u00a74.1 \"A node MUST respond with update_fail_htlc to any HTLC received\n> after it sent close_clearing.\"\n> and:\n>   \u00a73.3 \"There are three reasons for removing an HTLC: it has timed\n> out, it has failed to route, or the R preimage is supplied.\")\n>   \u00a73.3 \"A node MUST check that id corresponds to an HTLC in its\n> current commitment transaction.\"\n\nHi!\n\n        Hmm, 4.1 should say: \"A node must fail to route any HTLC\nreceived after it sent close_clearing\".  Basically, once you announce\nyou're shutting down the channel, you don't accept any more routes.  You\ncould still receive them, because the other node might not have received\nyour \"close_clearing\" yet.\n\n> In \u00a74.1, the node must decline/remove the still-uncommitted HTLC,\n> which is explicitely forbidden by \u00a73.3.\n\nThat was not the intent of 4.1; all responses are delayed until receipt\nof `update_commit`.\n\n> AFAICT, in this version of the\n> procotol an HTLC can only be accepted, then committed, then removed.\n> There is no way to decline an HTLC, the receiver must always accept it\n> except when the sender doesn't have the money or there are two many\n> pending HTLC, in which case the connection should be failed (\u00a73.2,\n> although it is actually not clear for the too-many-htlc case).\n\nIt's the same with a node sending you an HTLC with too short a timeout\nor insufficient fee.  There's no harm in you signing the *offer*; you're\njust not going to redeem it.\n\nToo-many-htlcs is a protocol violation, OTOH, and fail immediately.\n\n> We could decide to just fail the connection instead of declining the\n> htlc, but there is another issue: if the sender of a \"close_clearing\"\n> message subsequently receives an update_add_htlc, there is no way to\n> tell if the other party had received the close_clearing prior to\n> sending the htlc since update_add_htlc message doesn't have an 'ack'\n> field.\n\nYes, this is why we don't have a \"that HTLC will fail\" message.  We\n*could* add one, but it would be advisory only, and require the\noriginator to send a \"HTLC_UNADD\" (?) message.\n\nSince failure should be an unusual case, I considered that a premature\noptimization.\n\n> There is potentially the same issue with the signature process: when\n> node A sends an update_commit message to B, it is expecting an\n> update_revocation rather sooner than later. But what if B just ignores\n> the update_commit message and keeps sending new htlcs ? There is no\n> way for A to be sure that B indeed received the update_commit, for the\n> same reason as above.\n\nThe intent was that B can't get more than one step ahead.  But I didn't\nsay that explicitly.  Patch below.\n\nB could ignore update_commit.  But to make progess, at some point it has\nto send update_commit to A.  Then A sends update_revocation.\n\nNow, B can keep sending more htlcs to A, but it *can't* send another\nupdate_commit, because you're not allowed to send it without receiving\nthe previous update_revocation.  So it has to ack it at that point.\n\n(My implementation never sends htlcs while waiting for an\nupdate_revocation, but it is explicitly legal, to allow more optimal\npipelining).\n\nHere's the diff, I hope it clarifies.\n\nThanks!\nRusty.\n\ndiff --git a/bolts/02-wire-protocol.md b/bolts/02-wire-protocol.md\nindex e48aa1a..637bec1 100644\n--- a/bolts/02-wire-protocol.md\n+++ b/bolts/02-wire-protocol.md\n@@ -484,6 +484,11 @@ staged changes, it generates the other node's commitment transaction with those\n \n A node MUST NOT send an `update_commit` message which does not include any updates.  Note that a node MAY send an `update_commit` message which only alters the fee, and MAY send an `update_commit` message which doesn't change the commitment transaction other than the new revocation hash (due to dust, identical HTLC replacement, or insignificant or multiple fee changes).\n \n+A node MUST acknowledge the previous `update_revocation` (if any) in\n+the `update_commit` message.  A node SHOULD fail the connection if it\n+receives an `update_commit` which does not acknowledge its previously\n+sent `update_revocation`.\n+\n A node MUST NOT send out a message with an `ack` field lower than any\n previous `ack` field.\n \n@@ -647,7 +652,7 @@ Either node (or both) can send a `close_clearing` message to initiate closing:\n A node MUST NOT send a `update_add_htlc` after a `close_clearing`, and\n must not send more than one `close_clearing`.  A node SHOULD send a `close_clearing` (if it has not already) after receiving `close_clearing`.\n \n-A node MUST respond with `update_fail_htlc` to any HTLC received after it sent `close_clearing`.\n+A node MUST fail to route any HTLC added received after it sent `close_clearing`.\n \n ### 4.1.1. close_clearing message format"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-04-30T10:15:54",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hello,\n>\n> I see a few issues with the clearing process as currently described in BOLT #2.\n\nHi!\n\n        BTW, I love these emails, they really help me clarify both my\nthinking and the text.  Please keep it up!\n\n>\n> There seem to be a contradiction between:\n>   \u00a74.1 \"A node MUST respond with update_fail_htlc to any HTLC received\n> after it sent close_clearing.\"\n> and:\n>   \u00a73.3 \"There are three reasons for removing an HTLC: it has timed\n> out, it has failed to route, or the R preimage is supplied.\")\n>   \u00a73.3 \"A node MUST check that id corresponds to an HTLC in its\n> current commitment transaction.\"\n\n        Hmm, 4.1 should say: \"A node must fail to route any HTLC\nreceived after it sent close_clearing\".  Basically, once you announce\nyou're shutting down the channel, you don't accept any more HTLCs.  You\ncould still receive them, because the other node might not have received\nyour \"close_clearing\" yet.\n\n> In \u00a74.1, the node must decline/remove the still-uncommitted HTLC,\n> which is explicitely forbidden by \u00a73.3.\n\nYes, I see how you read it that but, but the intent of 4.1 was still\nthat all responses are delayed until receipt of `update_commit`.\n\n> AFAICT, in this version of the\n> procotol an HTLC can only be accepted, then committed, then removed.\n> There is no way to decline an HTLC, the receiver must always accept it\n> except when the sender doesn't have the money or there are two many\n> pending HTLC, in which case the connection should be failed (\u00a73.2,\n> although it is actually not clear for the too-many-htlc case).\n\nIt's the same with a node sending you an HTLC with too short a timeout\nor insufficient fee.  There's no harm in you signing the *offer*; you're\njust not going to forward or redeem it.\n\nToo-many-htlcs is a protocol violation, OTOH, and should immediately\nfail such a connection.  I've clarified that.\n\n> We could decide to just fail the connection instead of declining the\n> htlc, but there is another issue: if the sender of a \"close_clearing\"\n> message subsequently receives an update_add_htlc, there is no way to\n> tell if the other party had received the close_clearing prior to\n> sending the htlc since update_add_htlc message doesn't have an 'ack'\n> field.\n\nYes, this is why we don't have a \"that HTLC will fail\" message.  We\n*could* add one, but it would be advisory only, and still require the\noriginator to send a \"HTLC_UNADD\" (?) message.\n\nSince failure should be an unusual case, I considered that a premature\noptimization.\n\n> There is potentially the same issue with the signature process: when\n> node A sends an update_commit message to B, it is expecting an\n> update_revocation rather sooner than later. But what if B just ignores\n> the update_commit message and keeps sending new htlcs ? There is no\n> way for A to be sure that B indeed received the update_commit, for the\n> same reason as above.\n\nThe intent was that B can't get more than one step ahead.  But I didn't\nsay that explicitly.  Patch below.\n\nB could ignore update_commit.  But to make progess, at some point it has\nto send update_commit to A.  Then A sends update_revocation.\n\nNow, B can keep sending more htlcs to A, but it *can't* send another\nupdate_commit, because you're not allowed to send it before you receive\nthe previous update_revocation.  So it has to ack it at that point.\n\n(My implementation never sends htlcs while waiting for an\nupdate_revocation, but it is explicitly legal, to allow more optimal\npipelining).\n\nHere's the diff, I hope it clarifies.\n\nThanks!\nRusty.\n\ndiff --git a/bolts/02-wire-protocol.md b/bolts/02-wire-protocol.md\nindex e48aa1a..bb1a14a 100644\n--- a/bolts/02-wire-protocol.md\n+++ b/bolts/02-wire-protocol.md\n@@ -379,9 +379,9 @@ Calculation\" ).  A node SHOULD fail the connection if this occurs.\n `amount_msat` MUST BE greater than 0.\n \n A node MUST NOT add a HTLC if it would result in it offering more than\n-1500 HTLCs in either commitment transaction.  At 32 bytes per HTLC\n-output, this is comfortably under the 100k soft-limit for standard\n-transaction relay.\n+1500 HTLCs in either commitment transaction.  A node SHOULD fail the\n+connection if this occurs.  At 32 bytes per HTLC output, this is\n+comfortably under the 100k soft-limit for standard transaction relay.\n \n A node SHOULD NOT offer a HTLC with a timeout less than `delay` in the\n future.  See also \"Risks With HTLC Timeouts\".\n@@ -484,6 +484,11 @@ staged changes, it generates the other node's commitment transaction with those\n \n A node MUST NOT send an `update_commit` message which does not include any updates.  Note that a node MAY send an `update_commit` message which only alters the fee, and MAY send an `update_commit` message which doesn't change the commitment transaction other than the new revocation hash (due to dust, identical HTLC replacement, or insignificant or multiple fee changes).\n \n+A node MUST acknowledge the previous `update_revocation` (if any) in\n+the `update_commit` message.  A node SHOULD fail the connection if it\n+receives an `update_commit` which does not acknowledge its previously\n+sent `update_revocation`.\n+\n A node MUST NOT send out a message with an `ack` field lower than any\n previous `ack` field.\n \n@@ -647,7 +652,7 @@ Either node (or both) can send a `close_clearing` message to initiate closing:\n A node MUST NOT send a `update_add_htlc` after a `close_clearing`, and\n must not send more than one `close_clearing`.  A node SHOULD send a `close_clearing` (if it has not already) after receiving `close_clearing`.\n \n-A node MUST respond with `update_fail_htlc` to any HTLC received after it sent `close_clearing`.\n+A node MUST fail to route any HTLC added received after it sent `close_clearing`.\n \n ### 4.1.1. close_clearing message format"
            }
        ],
        "thread_summary": {
            "title": "Clearing process in BOLT #2",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Pierre"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12253
        }
    }
]