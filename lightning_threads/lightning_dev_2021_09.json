[
    {
        "title": "[Lightning-dev] Do we really want users to solve an NP-hard problem when they wish to find a cheap way of paying each other on the Lightning Network?",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-01T04:59:32",
                "message_text_only": "Good morning Stefan,\n\n> > For myself, I think a variant of Pickhardt-Richter payments can be created which adapts to the reality of the current network where `base_fee > 0` is common, but is biased against `base_fee > 0`, can be a bridge from the current network with `base_fee > 0` and a future with `#zerobasefee`.\n>\n> I have been thinking about your idea (at least what I understood of\n> it) of using amountprop_fee + amountbase_fee/min_flow_size, where\n> min_flow_size is a suitable quantization constant (say, 10k or 100k\n> sats, may also chosen dynamically), as a component of the cost\n> function, and I am pretty sure it is great at achieving exactly what\n> you are proposing here. This is a nicely convex (even linear in this\n> component) function and so it's easy to find min-cost flows for it. It\n> solves the problem (that I hadn't thought about before) that you have\n> pointed out in splitting flows into HTLCs. If you use\n> min_flow_size=max_htlc_size, it is even optimal (for this\n> min_flow_size). If you use a smaller min_flow_size, it is still\n> optimal for channels with base_fee=0 but overestimates the fee for\n> channels with base_fee>0, and is less accurate the smaller the\n> min_flow_size and the larger the base_fee. So it will be biased\n> against channels with larger base_fee. But notice that with min-cost\n> flows, we are rarely looking for the cheapest solution anyway, because\n> these solutions (if they include more than one path) will usually\n> fully saturate the cheapest channels and thus have very low success\n> probability. So all in all, I believe you found a great practical\n> solution for this debate. Everybody is free to use any base_fee they\n> chose, we get a workable cost function, and I conjecture that\n> economics will convince most people to choose a zero or low base_fee.\n\nI am glad that this is helpful.\nStill, I have not really understood well the variant problem \"min cost flow with gains and losses\" and this scheme might not work there very well.\nOn the other hand, the current algorithms are already known to suck for large payments, so even a not-so-good algorithm based on Pickhardt-Richter may be significantly better than existing deployed code.\n\nOn the software engineering side, the fact that it took you 2 months probably means implementing this would take even longer, like 6 months or so.\nI mean to say that prior to deployment we would need the dreary tasks of unit tests and edge cases (which are needed to ensure that basic functionality is not lost if the code is later modified, or more perniciously, that bugfixes do not introduce more bugs), code review, and so on.\nAnd for C-Lightning it would have to be implemented in C, which brings its own set of problems (memory management, being a lot more stringent about dotting every i and crossing every t, explicitly passing objects around, most likely rewriting in a continuation passing style/\"callback style\"...).\nNow we could argue that C-Lightning in practice requires Python anyway, but it also depends on what libraries you pull in, even if C-Lightning in practice requires Python you still want to keep the dependencies few or else deployment can suffer.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-09-01T05:33:23",
                "message_text_only": "Please be careful accepting the faulty premise that the proposed algorithm is \u201coptimal\u201d. It is optimal under a specific heuristic used to approximate what the user wants. In reality, there are a ton of different things to balance, from CLTV to feed to estimated failure probability calculated from node online percentages at-open liquidity, and even fees. There is no such thing as \u201coptimal\u201d, only heuristics for how to balance these things into a score that you can feed into a routing algorithm.\n\n> Do we really want users to solve an NP-hard problem when they wish to find a cheap way of paying each other on the Lightning Network?\n\nI find this framing sufficiently insulting to the serious discussion people have had on this topic that I\u2019m not really sure where to go from here aside from ignoring it.\n\n> On Aug 31, 2021, at 03:35, Orfeas Stefanos Thyfronitis Litos <o.thyfronitis at ed.ac.uk> wrote:\n> \n> \ufeffHi list,\n> \n> On 8/31/21 5:01 AM, Anthony Towns wrote:\n>>> \"Do we really want users to solve an NP-hard problem when\n>>> they wish to find a cheap way of paying each other on the Lightning Network?\" \n>> FWIW, my answer to this is \"sure, if that's the way it turns out\".\n>> \n>> Another program which solves an NP-hard problem every time it runs is\n>> \"apt-get install\".\n>> [I]f it fails too often,\n>> you re-analyse what's going on manually and add a new heuristic to cope\n>> with it.\n> I've been following the conversation with interest and I acknowledge this is a thorny issue.\n> \n> I am a bit worried with a path which relies on constantly finding new heuristics to approximate a solution to an NP-hard problem:\n> * It allows too much room for nonconstructive disagreement between LN developers in the future.\n>  - In a worst case scenario, all implementations end up using different, incompatible heuristics because each group of developers thinks that they have the best one, leading to a suboptimal performance for everyone. Heuristics are less of an exact science after all.\n> * It makes the job of node operators less predictable, since it would depend more on the decisions of said developers with no guarantee of convergence to a single solution.\n>  - Node operators may perceive this as loss of decentralization to the developers.\n> \n> Such an approach is much more suitable to debian, since they have full control and a complete view over their \"network\" of packages, as opposed to LN, which is decentralized, nodes come and go at will and they can be private (even from developers!).\n> \n> Best,\n> Orfeas\n> The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th\u2019 ann an Oilthigh Dh\u00f9n \u00c8ideann, cl\u00e0raichte an Alba, \u00e0ireamh cl\u00e0raidh SC005336.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-01T07:06:23",
                "message_text_only": "Good morning Matt and all,\n\n> Please be careful accepting the faulty premise that the proposed algorithm is \u201coptimal\u201d. It is optimal under a specific heuristic used to approximate what the user wants. In reality, there are a ton of different things to balance, from CLTV to feed to estimated failure probability calculated from node online percentages at-open liquidity, and even fees.\n\nIt may be possible to translate all these \"things to balance\" to a single unit, the millisatoshi.\n\n* CLTV-delta\n  - The total CLTV-delta time is the worst-case amount of time that your outgoing payment will be stalled.\n  - We can compute the expected nominal rate of return if the funds were instead put in a random Bitcoin-denominated investment, getting back a conversion ratio from time units to percentage of your funds.\n    This is what C-Lightning already does via the `riskfactor` parameter.\n* Node failure probablity\n  - Can be multiplied with channel failure probability (the one based on the channel capacity).\n  - As I pointed out elsewhere, we can ask the user \"up to how much are you willing to pay in fees?\", and that amount is the cost of failure (because economics; see my other mail); the failure probability times the cost of failure is the effective cost of this path.\n* Fees\n  - Are already denominated in millisatoshi.\n\nOne unit to rule them all....\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-09-01T12:44:35",
                "message_text_only": "> On Sep 1, 2021, at 00:07, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> \ufeffGood morning Matt and all,\n> \n>> Please be careful accepting the faulty premise that the proposed algorithm is \u201coptimal\u201d. It is optimal under a specific heuristic used to approximate what the user wants. In reality, there are a ton of different things to balance, from CLTV to feed to estimated failure probability calculated from node online percentages at-open liquidity, and even fees.\n> \n> It may be possible to translate all these \"things to balance\" to a single unit, the millisatoshi.\n\nIndeed, in practice this is what we all do today. My point is less that you cannot create a single unit out of all the various things you consider and more that doing so involves some heuristics on the part of the application developer. There is no \u201ccorrect\u201d or \u201coptimal\u201d answer to how to do this, only various designs different folks have. How you balance competing costs may lead to different score units (eg instead of msat, probability of success) and that\u2019s fine, neither is provably better than the other.\n\nMatt"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-02T06:13:04",
                "message_text_only": "Good morning Stefan,\n\n> > > For myself, I think a variant of Pickhardt-Richter payments can be created which adapts to the reality of the current network where `base_fee > 0` is common, but is biased against `base_fee > 0`, can be a bridge from the current network with `base_fee > 0` and a future with `#zerobasefee`.\n> >\n> > I have been thinking about your idea (at least what I understood of\n> > it) of using amountprop_fee + amountbase_fee/min_flow_size, where\n> > min_flow_size is a suitable quantization constant (say, 10k or 100k\n> > sats, may also chosen dynamically), as a component of the cost\n> > function, and I am pretty sure it is great at achieving exactly what\n> > you are proposing here. This is a nicely convex (even linear in this\n> > component) function and so it's easy to find min-cost flows for it. It\n> > solves the problem (that I hadn't thought about before) that you have\n> > pointed out in splitting flows into HTLCs. If you use\n> > min_flow_size=max_htlc_size, it is even optimal (for this\n> > min_flow_size). If you use a smaller min_flow_size, it is still\n> > optimal for channels with base_fee=0 but overestimates the fee for\n> > channels with base_fee>0, and is less accurate the smaller the\n> > min_flow_size and the larger the base_fee. So it will be biased\n> > against channels with larger base_fee. But notice that with min-cost\n> > flows, we are rarely looking for the cheapest solution anyway, because\n> > these solutions (if they include more than one path) will usually\n> > fully saturate the cheapest channels and thus have very low success\n> > probability. So all in all, I believe you found a great practical\n> > solution for this debate. Everybody is free to use any base_fee they\n> > chose, we get a workable cost function, and I conjecture that\n> > economics will convince most people to choose a zero or low base_fee.\n>\n> I am glad that this is helpful.\n> Still, I have not really understood well the variant problem \"min cost flow with gains and losses\" and this scheme might not work there very well.\n> On the other hand, the current algorithms are already known to suck for large payments, so even a not-so-good algorithm based on Pickhardt-Richter may be significantly better than existing deployed code.\n\nIn yet another thread I proposed the cost function:\n\n    fee + fee_budget * (1 - success_probability)\n\nIf the base-to-prop hack (i.e. use a quantization constant like I proposed) can be done on the `fee` component above, does it now become convex?\n\nWith an amount of 0, `success_probability` is 1, and if we use the base-to-prop hack to convert base fees to proportional fees, then the output is also 0 at `amount = 0`.\n\nIt can even be made separable by clever redefinition of addition (as I pointed out in that thread) but perhaps it is too clever and breaks other properties that a mincostflow algo needs.\n\nThe above is attractive since the cost unit ends up being millisatoshi.\nIn my experience with CLBOSS, hastily-thought heuristics kinda suck unless they are based on actual economic theory, meaning everything should really be in terms of millisatoshis or other financial units.\n\nWould this be workable?\nPardon my complete ignorance of maths.\n\nPresumably, there is a reason why the Pickhardt-Richter paper suggests `-log(success_probability) + fudging_factor * fee`.\nMy initial understanding is that this makes simple addition a correct behavior (success_probabilities are multiplied), making for a separable cost function that uses \"standard\" arithmetic addition rather than the excessively clever one I came up with.\nHowever, it might affect convexity as well?\n\n(on the other hand, credibility should really be measured in decibels anyway, and one is estimating the credibility of the implied claim of a published channel that it can actually deliver the money to where it is needed...)\n\nThe neglogprob is in units of decibels, and I am not sure how to convert a millisatoshi-unit fee into decibels.\nIn particular the logarithm implies a non-linear relationship between probability and fee.\n\nI think it is reasonable for paying users to say \"if it will take more than NN millisatoshis to pay for it, never mind, I won't continue the transaction anymore\", which is precisely why I added the fee budget in the C-Lightning `pay` implementation long ago.\n\nOn the other hand, perhaps the nonlinear relationship between the success probability and the fee makes sense.\nIf the success probability is already fairly high, then any small change in fee is significant to the user, but as the success probability drops, then the user would be willing to accept up to the fee budget.\nThis implies that if success probability is high, the effect of an increase in fee should be larger in comparison to the effect of an increase in success probability, but if success probability is low, then the effect of an increase in fee should be smaller compared to an increase in success probability.\nI am uncertain if the neglogprob plus some fee times a conversion factor has that behavior.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Do we really want users to solve an NP-hard problem when they wish to find a cheap way of paying each other on the Lightning Network?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Matt Corallo",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 13654
        }
    },
    {
        "title": "[Lightning-dev] Bandwidth in Lightning Network.",
        "thread_messages": [
            {
                "author": "x raid",
                "date": "2021-09-01T11:08:13",
                "message_text_only": "Gentlemen,\n\nThe micropayment system that is LN today has some limitations in\npathfinding with hops accommodating the needed liquidity with regards\nto larger amounts, where probability of success and the forward fee\nalso needs to be accounted for in a total cost of attempt.\n\nProbability and cost for xx M sats will not today have any gain\ncompared to go on-chain.\n\nIf still in need and or requested to have tx in a near instantaneous\nsettlement using LN regularly,\none would have a setup of LN-Nodes in aggregate to facilitate tx with\nsuch profiles.\n\nIf Lady Gaga would like to send 0.6 to Madonna in a LN tx for\nremuneration of a designer purse,\nfor Us to be able to facilitate that : We would need to onboard them first ...\n\nIf A would like to send 0.6 to B, in a non anticipated recurring flow,\nA would just go on-chain,\nor A would open a channel with --push amt to B, probability asserted\nand cost minimised.\n\nIn an anticipated recurring flow, I repeat -one would have a setup of\nLN-Nodes in aggregate to facilitate liquidity in such a scenario, as I\nam sure Baller and Bird ++ other biz already do today.\n\nThere is a proposal in changing the protocol to accommodate an\nalgorithm to do pathfinding and spontaneously make larger payments\npossible in LN, where proposal fails directly in that it has a non\nreal world scenario as argument.\n\nCalculating total cost in a 0.6 balance transfer involving a MPP split\nto 500 120K tx to use a hop sequence as a-b-c-d, would require 4000\nledger entries ? ( 2 at each node ) in 1002 LN-Nodes and the\nprobability of success is \u2248 ?, with a ppm fee forward cost > then what\nWe in the real world would use and spend today.\n\nAs an application developer wishing to use LN protocol pure and\ninteroperable whole, I can see there are more pressing needs in\nrefining existing protocol and implementations than spend wetware time\non hypothetical non real world scenarios. Altho still amusing and\nstimulating as edutainment.\n\nThank you\n\n/xraid"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-02T16:23:15",
                "message_text_only": "Good morning xraid,\n\nIt helps to consider on-Lightning bitcoins as a substitute good for onchain bitcoins.\n\nConverting to or from on-Lightning coins to onchain coins has a cost, either:\n\n* Cost of channel open (converting onchain coins to on-Lightning coins) or channel close (converting on-Lightning coins to onchain coins).\n* The use of services like Boltz, an exchange that facilitates conversion between on-Lightning and onchain coins, and which charges a fee.\n\nConsider the case where Lady Gaga is already onboarded, and has on-Lightning bitcoins, and who would very much prefer that her onchain bitcoins are kept in a cold wallet that she ideally would never bring online in the foreseeable future.\nLady Gaga wishes to pay 0.6BTC to Madonna, using the loose change in her Lightning wallet, and not have to go to the bank (cold storage wallet) to move funds around (because of risk of getting the keys online and potentially hacked).\nMadonna, as it happens, has a cold wallet with onchain bitcoins but has no ability to receive on-Lightning bitcoins.\n\nLady Gaga has two choices:\n\n* Lady Gaga closes some channels to convert on-Lightning bitcoins to onchain bitcoins.\n* Lady Gaga uses Boltz to convert on-Lightning bitcoins to onchain bitcoins.\n\nNow, consider if Lady Gaga had, as is right and proper, decided to make multiple channels, in order to reduce counterparty risk (i.e. channel counterparties going offline, or deliberately impeding Lady Gaga->Madonna exchanges (because seriously Lady Gaga is sexier and Madonna should pay Lady Gaga for the privilege of existing) by raising fees for such transactions when they detect it).\nIf so, the first option, closing channels, can be a significant amount of onchain activity.\nLady Gaga would need to create multiple closing transactions, and *then* create a large (in vbytes) transaction consuming those closing transactions as inputs and outputting the amount to Madonna.\n\nAlternately, with proper design of pathfinding algorithms, Lady Gaga can deliver the same amount of funds over the Lightning Network, to a Boltz Lightning node, and the Boltz service will then send the amount to Madonna.\nBoltz can aggregate multiple such transactions into a single onchain transaction, saving on onchain fees, and passing on some of those savings to Lady Gaga and other clients of Boltz.\n\nWithout a pathfinding algorithm that can deliver 0.6BTC from Lady Gaga to Boltz over Lightning, the second choice is impossible for Lady Gaga.\n\nNow of course we could be using centralized brokers and avoid onchain fees entirely, but that risks censorship (just because Lady Gaga is sexier does not mean she is not allowed to purchase tacky purses from the inferior Madonna, even though a just and right universe would prevent such a transaction as inherent laws of physics).\nBut the point of Lightning is an attempt to provide:\n\n* Fast\n* Cheap\n* Reliable\n* Non-censorable\n\npayments.\nThat is why attempts should still be made to keep this option open.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Bandwidth in Lightning Network.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "x raid",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4977
        }
    },
    {
        "title": "[Lightning-dev] Storing the Merkle Tree in a compact way",
        "thread_messages": [
            {
                "author": "shymaa arafat",
                "date": "2021-09-11T03:00:12",
                "message_text_only": "Allow me to introduce this simple idea that could be useful ...\n\n-The Intuition was some discussion on Utreexo project about storage saving\nand some traversing issues in handling the UTXOS Merkle Tree/ forest; that\nis  N internal nodes need to be stored along with 2N pointers (left&right),\n+ maybe 1 more pointer in the leaves special nodes to handle different\ntraversing options (insert, delete, & differently proof fetch that traverse\naunt or niece node according to your implementation\nhttps://github.com/mit-dci/utreexo/discussions/316)\n.\nThen, I thought of a simple idea that gets rid of all the pointers;\nspecially appealing when we have all trees are full (complete) in the\nforest, but can work for any Merkle Tree:\n\n- 2D array with variable row size; R[j] is of length (N/2^j)\n-For example when N=8 nodes\nR[0]=0,1,2,...,7\nR[1]=8,9,10,11\nR[2]=12,13\nR[3]=14\n.\n-We can see that total storage is just 2N-1 nodes,\nno need for pointers, and traversing could be neat in any direction with\nthe right formula:\n\n-Pseudo code to fetch proof[i] ...\n\n//direction to know + or -\nIf ((i mod 2)==0) drct=1;\n            else drct=-1;\n// first, the sibling node\nproof[i]=R[0,i+drct]\n\n//add the rest thru loop\nFor(j=1; j\u2264logN; j++)\n { index= i/(2^j)+drct;\n    proof[i]=Add(R[j,index]);\n }\n\n-In fact it's just the simple primitive approach of transforming a\nrecursion to an iteration, and even if Utreexo team solved their problem\ndifferently I thought it is worth telling as it can work for any Merkle Tree\n.\nThanks for your time,\nShymaa M Arafat\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210911/1ca4abf1/attachment.html>"
            },
            {
                "author": "Vincent",
                "date": "2021-09-16T12:37:24",
                "message_text_only": "Hi.\n\nThanks for the reference, but I missed where you want save space with this compression on the Merkle Tree.\n\nRegards.\n\nVincent.\nvincenzo.palazzo at protonmail.com\nhttps://github.com/vincenzopalazzo\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, September 16th, 2021 at 5:15 AM, shymaa arafat <shymaa.arafat at gmail.com> wrote:\n\n> Allow me to introduce this simple idea that could be useful ...\n>\n> -The Intuition was some discussion on Utreexo project about storage saving and some traversing issues in handling the UTXOS Merkle Tree/ forest; that is N internal nodes need to be stored along with 2N pointers (left&right), + maybe 1 more pointer in the leaves special nodes to handle different traversing options (insert, delete, & differently proof fetch that traverse aunt or niece node according to your implementation\n> https://github.com/mit-dci/utreexo/discussions/316)\n> .\n>\n> Then, I thought of a simple idea that gets rid of all the pointers; specially appealing when we have all trees are full (complete) in the forest, but can work for any Merkle Tree:\n>\n> - 2D array with variable row size; R[j] is of length (N/2^j)\n> -For example when N=8 nodes\n> R[0]=0,1,2,...,7\n> R[1]=8,9,10,11\n> R[2]=12,13\n> R[3]=14\n> .\n> -We can see that total storage is just 2N-1 nodes,\n> no need for pointers, and traversing could be neat in any direction with the right formula:\n>\n> -Pseudo code to fetch proof[i] ...\n>\n> //direction to know + or -\n> If ((i mod 2)==0) drct=1;\n> else drct=-1;\n> // first, the sibling node\n> proof[i]=R[0,i+drct]\n>\n> //add the rest thru loop\n> For(j=1; j\u2264logN; j++)\n> { index= i/(2^j)+drct;\n> proof[i]=Add(R[j,index]);\n> }\n>\n> -In fact it's just the simple primitive approach of transforming a recursion to an iteration, and even if Utreexo team solved their problem differently I thought it is worth telling as it can work for any Merkle Tree\n> .\n> Thanks for your time,\n> Shymaa M Arafat\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210916/42856a25/attachment.html>"
            },
            {
                "author": "shymaa arafat",
                "date": "2021-09-16T15:05:24",
                "message_text_only": "It could be viewed as the simple complete tree to 1D array  with no\npointers described in lecture 8 here\nhttps://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2020/lecture-notes/index.htm\nstarting from min 15 in this video\nhttps://youtu.be/Xnpo1atN-Iw\n\nSince all trees in Utreexo forest are full binary trees, this is perfect to\nuse, and we can save *76*10\u2076*2*size of pointer(probably4bytes)*\n*~600MB *with almost no effort.\n\nHowever, I suggest to put it in a 2D array to make it more easy to handle\n(the indexing math) as we, different than the lecture, traverse in many\nways ( normally to delete or insert, and the parent siblings for the proofs)\n\nI wrote more details here\nhttps://bitcointalk.org/index.php?topic=5360009.0\n\nOn Thu, Sep 16, 2021, 14:37 Vincent <vincent.palazzo at protonmail.com> wrote:\n\n> Hi.\n>\n> Thanks for the reference, but I missed where you want save space with this\n> compression on the Merkle Tree.\n>\n> Regards.\n>\n> Vincent.\n> vincenzo.palazzo at protonmail.com\n> https://github.com/vincenzopalazzo\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Thursday, September 16th, 2021 at 5:15 AM, shymaa arafat <\n> shymaa.arafat at gmail.com> wrote:\n>\n> Allow me to introduce this simple idea that could be useful ...\n>\n> -The Intuition was some discussion on Utreexo project about storage saving\n> and some traversing issues in handling the UTXOS Merkle Tree/ forest; that\n> is  N internal nodes need to be stored along with 2N pointers (left&right),\n> + maybe 1 more pointer in the leaves special nodes to handle different\n> traversing options (insert, delete, & differently proof fetch that traverse\n> aunt or niece node according to your implementation\n> https://github.com/mit-dci/utreexo/discussions/316)\n> .\n> Then, I thought of a simple idea that gets rid of all the pointers;\n> specially appealing when we have all trees are full (complete) in the\n> forest, but can work for any Merkle Tree:\n>\n> - 2D array with variable row size; R[j] is of length (N/2^j)\n> -For example when N=8 nodes\n> R[0]=0,1,2,...,7\n> R[1]=8,9,10,11\n> R[2]=12,13\n> R[3]=14\n> .\n> -We can see that total storage is just 2N-1 nodes,\n> no need for pointers, and traversing could be neat in any direction with\n> the right formula:\n>\n> -Pseudo code to fetch proof[i] ...\n>\n> //direction to know + or -\n> If ((i mod 2)==0) drct=1;\n>             else drct=-1;\n> // first, the sibling node\n> proof[i]=R[0,i+drct]\n>\n> //add the rest thru loop\n> For(j=1; j\u2264logN; j++)\n>  { index= i/(2^j)+drct;\n>     proof[i]=Add(R[j,index]);\n>  }\n>\n> -In fact it's just the simple primitive approach of transforming a\n> recursion to an iteration, and even if Utreexo team solved their problem\n> differently I thought it is worth telling as it can work for any Merkle Tree\n> .\n> Thanks for your time,\n> Shymaa M Arafat\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210916/c0fa90ad/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: IMG_20210913_194256.jpg\nType: image/jpeg\nSize: 279763 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210916/c0fa90ad/attachment-0002.jpg>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: IMG_20210913_193322.jpg\nType: image/jpeg\nSize: 164592 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210916/c0fa90ad/attachment-0003.jpg>"
            }
        ],
        "thread_summary": {
            "title": "Storing the Merkle Tree in a compact way",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "shymaa arafat",
                "Vincent"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7415
        }
    },
    {
        "title": "[Lightning-dev] DNS records for LN nodes",
        "thread_messages": [
            {
                "author": "Andy Schroder",
                "date": "2021-09-12T22:52:06",
                "message_text_only": "Hello,\n\nWe have the <pubkey>@host format for defining a connection to a LN node.\n\nI'm wondering if it makes any sense to create DNS records that apply to \nLN nodes to serve this same information? For example:\n\n  * example.com. IN LN ln.example.com.\n      o Allows assigning an alternate host name for the ln node for a\n        domain, like an mail server has an MX record\n  * example.com. IN TXT \"LNpubkey=ybRK9h6OYmB3I4VroZBQogIadciFTw\"\n      o Allows storing the pubkey for the LN node in a DNS record\n\n\nIf one didn't know the LN node for example.com, they could query the LN \nand TXT records and then find the information and make a connection \nusing the familiar ybRK9h6OYmB3I4VroZBQogIadciFTw at ln.example.com format. \nThis may be of interest because if someone wants to open a channel in \nadvance to a company's LN node because they know they will be receiving \nan invoice from them in the future, and they want open a channel \ndirectly in order to ensure a good route (and they want the channel to \nbe fully confirmed/opened by the time they receive the invoice). This \ncould be particularly useful when dealing with machines in the physical \nworld where you want an easy way to make a connection and channel to \nwith a human readable string that is printed on the machine, but don't \neven want to deal with QR codes or NFC (for example, your desktop \ncomputer likely doesn't have either of those capabilities).\n\nRight now, the host names associated with LN nodes that are found using \nthe peer to peer gossip are more on the honor system as I understand it. \nIf these records existed, one could also validate the information found \nusing the peer to peer gossip protocol.\n\nI do realize that the DNS root servers are governed by a centralized \nentity, so this approach has it's flaws, but we could consider it sort \nof complimentary to the peer to peer gossip protocol. DNS does have a \nnice scaling property in that it is hierarchically distributed, so it \nmay be more efficient long term than every user having a full view of \nthe LN via the gossip protocol in order to find the information needed, \nespecially when we can replace the DNS root servers with something that \nis under decentralized control.\n\nlnurl-rfc seems to be doing a good job at creating workflows for payers \nand payees. However, I'm not sure if a definition like I've suggested \nabove fits better in lnurl-rfc or as part of a BOLT.\n\n\nLet me know of your thoughts,\n\n-- \nAndy Schroder\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210912/14a13a88/attachment.html>"
            },
            {
                "author": "fiatjaf",
                "date": "2021-09-12T23:18:16",
                "message_text_only": "I think this is a good idea. A very simple change that can improve\nusability.\n\nAnyone can already do this today if they want, by just shoving data into\nDNS records and telling people to confirm from there, but it would be nice\nif it was standardized in a bLIP[0] just so everybody does it in the same\nway.\n\nAdditionally there could be the reverse link in which nodes publish their\ndomain names as their alias and that is confirmed with the DNS record. Then\nwe'll finally be able to identify and trust the payee pubkeys in invoices!\n\n[0]: https://github.com/lightningnetwork/lightning-rfc/pull/884\n\nOn Sun, Sep 12, 2021 at 8:02 PM Andy Schroder <info at andyschroder.com> wrote:\n\n> Hello,\n>\n> We have the <pubkey>@host format for defining a connection to a LN node.\n>\n> I'm wondering if it makes any sense to create DNS records that apply to LN\n> nodes to serve this same information? For example:\n>\n>    - example.com. IN LN ln.example.com.\n>       - Allows assigning an alternate host name for the ln node for a\n>       domain, like an mail server has an MX record\n>       - example.com. IN TXT \"LNpubkey=ybRK9h6OYmB3I4VroZBQogIadciFTw\"\n>       - Allows storing the pubkey for the LN node in a DNS record\n>\n>\n> If one didn't know the LN node for example.com, they could query the LN\n> and TXT records and then find the information and make a connection using\n> the familiar ybRK9h6OYmB3I4VroZBQogIadciFTw at ln.example.com format. This\n> may be of interest because if someone wants to open a channel in advance to\n> a company's LN node because they know they will be receiving an invoice\n> from them in the future, and they want open a channel directly in order to\n> ensure a good route (and they want the channel to be fully confirmed/opened\n> by the time they receive the invoice). This could be particularly useful\n> when dealing with machines in the physical world where you want an easy way\n> to make a connection and channel to with a human readable string that is\n> printed on the machine, but don't even want to deal with QR codes or NFC\n> (for example, your desktop computer likely doesn't have either of those\n> capabilities).\n>\n> Right now, the host names associated with LN nodes that are found using\n> the peer to peer gossip are more on the honor system as I understand it. If\n> these records existed, one could also validate the information found using\n> the peer to peer gossip protocol.\n>\n> I do realize that the DNS root servers are governed by a centralized\n> entity, so this approach has it's flaws, but we could consider it sort of\n> complimentary to the peer to peer gossip protocol. DNS does have a nice\n> scaling property in that it is hierarchically distributed, so it may be\n> more efficient long term than every user having a full view of the LN via\n> the gossip protocol in order to find the information needed, especially\n> when we can replace the DNS root servers with something that is under\n> decentralized control.\n>\n> lnurl-rfc seems to be doing a good job at creating workflows for payers\n> and payees. However, I'm not sure if a definition like I've suggested above\n> fits better in lnurl-rfc or as part of a BOLT.\n>\n>\n> Let me know of your thoughts,\n>\n> --\n> Andy Schroder\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210912/5baf424b/attachment.html>"
            },
            {
                "author": "Andy Schroder",
                "date": "2021-09-12T23:52:10",
                "message_text_only": "On 9/12/21 7:18 PM, fiatjaf wrote:\n> I think this is a good idea. A very simple change that can improve \n> usability.\n>\n> Anyone can already do this today if they want, by just shoving data \n> into DNS records and telling people to confirm from there, but it \n> would be nice if it was standardized in a bLIP[0] just so everybody \n> does it in the same way.\n>\n> Additionally there could be the reverse link in which nodes publish \n> their domain names as their alias and that is confirmed with the DNS \n> record. Then we'll finally be able to identify and trust the payee \n> pubkeys in invoices!\n\nThis is kind of what I was referring to when I said \"Right now, the host \nnames associated with LN nodes that are found using the peer to peer \ngossip are more on the honor system as I understand it. If these records \nexisted, one could also validate the information found using the peer to \npeer gossip protocol.\". However, when I said \"host name\" I guess I was \nreally referring to the LN node \"alias\". Is there any difference in \nintent between the \"alias\" and a host name?\n\nJust because we verify against DNS doesn't mean we can fully trust since \nDNS has centrally controlled root servers, however, it does help a lot \nbecause they are mostly honest for right now. Assuming the root name \nservers are trusted, you also need to implement DNSSEC.\n\nWith DNSSEC in mind, it may make sense for LN nodes to also advertise \n\"DS\" records for a domain, that way the rest of the DNS records \n(unrelated to LN) can be more trusted. The point here being, we can have \na two way link between DNS and LN to keep DNS in check. Basically, it's \na way for the LN node's channel capacity to give some weighting to the \nauthenticity of DNS. This could be a backwards compatible way to \nindirectly make DNS more secure without having to store tons of data on \nthe blockchain because the DNS root servers will be motivated to not \npublicly contradict the lightning network .... Just brainstorming here, \nlet me know if this makes sense..\n\n\n>\n> [0]: https://github.com/lightningnetwork/lightning-rfc/pull/884\n>\n> On Sun, Sep 12, 2021 at 8:02 PM Andy Schroder <info at andyschroder.com \n> <mailto:info at andyschroder.com>> wrote:\n>\n>     Hello,\n>\n>     We have the <pubkey>@host format for defining a connection to a LN\n>     node.\n>\n>     I'm wondering if it makes any sense to create DNS records that\n>     apply to LN nodes to serve this same information? For example:\n>\n>       * example.com <http://example.com>. IN LN ln.example.com\n>         <http://ln.example.com>.\n>           o Allows assigning an alternate host name for the ln node\n>             for a domain, like an mail server has an MX record\n>       * example.com <http://example.com>. IN TXT\n>         \"LNpubkey=ybRK9h6OYmB3I4VroZBQogIadciFTw\"\n>           o Allows storing the pubkey for the LN node in a DNS record\n>\n>\n>     If one didn't know the LN node for example.com\n>     <http://example.com>, they could query the LN and TXT records and\n>     then find the information and make a connection using the familiar\n>     ybRK9h6OYmB3I4VroZBQogIadciFTw at ln.example.com\n>     <mailto:ybRK9h6OYmB3I4VroZBQogIadciFTw at ln.example.com> format.\n>     This may be of interest because if someone wants to open a channel\n>     in advance to a company's LN node because they know they will be\n>     receiving an invoice from them in the future, and they want open a\n>     channel directly in order to ensure a good route (and they want\n>     the channel to be fully confirmed/opened by the time they receive\n>     the invoice). This could be particularly useful when dealing with\n>     machines in the physical world where you want an easy way to make\n>     a connection and channel to with a human readable string that is\n>     printed on the machine, but don't even want to deal with QR codes\n>     or NFC (for example, your desktop computer likely doesn't have\n>     either of those capabilities).\n>\n>     Right now, the host names associated with LN nodes that are found\n>     using the peer to peer gossip are more on the honor system as I\n>     understand it. If these records existed, one could also validate\n>     the information found using the peer to peer gossip protocol.\n>\n>     I do realize that the DNS root servers are governed by a\n>     centralized entity, so this approach has it's flaws, but we could\n>     consider it sort of complimentary to the peer to peer gossip\n>     protocol. DNS does have a nice scaling property in that it is\n>     hierarchically distributed, so it may be more efficient long term\n>     than every user having a full view of the LN via the gossip\n>     protocol in order to find the information needed, especially when\n>     we can replace the DNS root servers with something that is under\n>     decentralized control.\n>\n>     lnurl-rfc seems to be doing a good job at creating workflows for\n>     payers and payees. However, I'm not sure if a definition like I've\n>     suggested above fits better in lnurl-rfc or as part of a BOLT.\n>\n>\n>     Let me know of your thoughts,\n>\n>     -- \n>     Andy Schroder\n>\n>     _______________________________________________\n>     Lightning-dev mailing list\n>     Lightning-dev at lists.linuxfoundation.org\n>     <mailto:Lightning-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210912/f4bce31a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "DNS records for LN nodes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "fiatjaf",
                "Andy Schroder"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 11988
        }
    },
    {
        "title": "[Lightning-dev] Deriving channel keys deterministically from seed, musig, and channel establishment v2",
        "thread_messages": [
            {
                "author": "SomberNight",
                "date": "2021-09-17T16:14:22",
                "message_text_only": "Hi all,\n\nTL;DR: an approach is described how to derive channel keys\ndeterministically that allows certain forms of recovery from just\na seed, that works today. This approach however will no longer work\nwith e.g. MuSig key aggregation in the future. An idea for a proposal\nis given how the channel-open flow (e.g. as part of channel v2) could be\nchanged to make a similar approach work independent of key aggregation.\n\n-----\n\nWhile implementing anchor output support in Electrum, we have realised\none difficulty is to do with the remote-force-close case where the\nto_remote output is no longer a simple p2wpkh.\n\nCurrently, pre-anchor-support, Electrum sets option_static_remotekey\nto required (feature bit 12), and we restrict lightning usage to wallets\nthat derive p2wpkh addresses, and payment_basepoint is set\nto a bip32-derived pubkey that corresponds to a wallet address.\nHence, if a user were to restore from seed words, and their channel\ncounterparty force closed their channel, the to_remote output of the\nbroadcast commitment tx would directly pay to the user's wallet.\nThat is, in many typical scenarios, funds are not lost when restoring\nfrom seed.\n\n(Also, if we are the channel-funder/opener, it is easy to find the\nfunding transaction, just by testing txs in the wallet history.\nFurther, for the cases we are the channel-funder/opener,\nthere is a setting to put an OP_RETURN in the funding tx, which stores\nthe nodeid of the counterparty, allowing us to identify who to contact\nto get the channel closed.\nAlso, we are (ab)using dataloss_protect to ask the remote\nto force-close when restoring from seed, so the user does not even have\nto wait for an arbitrarily long time.)\n\nWith anchors, the to_remote is now a p2wsh that involves a CSV,\nand we cannot easily make this script correspond to a wallet address,\ni.e. we lose the property that the remote-force-close pays directly\nto a wallet address.\n\nSo, the problem we would like to solve, is:\n- having seed words\n- having access to blockchain data\n- somehow having identified our channel counterparties (node IDs),\n  and our channels with them (funding outpoints)\n- and assuming we can get the remote to do a force-close\n--> we would like to be able to spend the to_remote output\n\nSolutions:\n\n1) Naively, we could just derive a static key to be used as\npayment_basepoint, reused between all our channels, and watch the\nsingle resulting p2wsh script on-chain.\nClearly this has terrible privacy implications.\n\n2) Or, we could derive a new bip32 chain/sequence of pubkeys\nused as payment_basepoint for channels, and watch these p2wsh scripts,\nwith a gap limit.\nParticularly the gap limit part makes this undesirable though\n(just consider having more than \"gap limit\" channels open and restoring\nfrom seed).\n\nInstead, it seems desirable to see whether we can extract some entropy\nfrom the blockchain, and use that as a nonce to be combined with a\nstatic private secret derived from our seed.\nWe could extract data either from the funding tx, or from the\nremote-commitment-transaction that spent the funding output.\n\n3) We exploit the fact that the funding output uses a\n2of2 OP_CHECKMULTISIG script composed of the funding pubkeys of\neach party. The funding pubkey itself can be used as a nonce, and\nit can be recovered from the witness of the commitment tx.\nThe privkey for payment_basepoint can then be derived as e.g.\nhash(bip32_derive(seed, HARDCODED_PATH) + funding_pubkey).\n\nIn fact (3) is not novel at all: eclair has been deriving\nall their channel keys like this [0] for some time, from\na static seed-based secret combined with the funding_pubkey as nonce,\nand generating the funding_privkey from ~os.urandom.\n\nElectrum will likely use (3) at least for the payment_basepoint,\nas part of adapting to anchors.\n\n-----\n\nNote that the idea (3) relies on recovering the funding_pubkey from\nthe witness of the spending transaction, which will break in the future\nif the funding script is changed to e.g. a p2tr that uses musig.\n\nCrucially, note that all the approach needs is some blockchain-visible\nnonce that is already known at the time we need to construct the\nopen_channel message (as we want to be able to derive some of the keys\nthat are sent as part of the open_channel message\n(e.g. payment_basepoint) from it).\nAs long as the funding output uses a 2of2 OP_CHECKMULTISIG,\nthe local funding_pubkey fits the bill.\n\nNote that irrespective of any restrictions on the script used in\nthe funding output, we could use the funding scriptPubKey/address as\nthe nonce, if the open_channel/accept_channel messages were\nsplit into two.\nFor example, instead of the single round of open_channel/accept_channel,\nthere could be two rounds:\n- an open_channel_part1, where the peers exchange only\n  the funding_pubkey (and the other non-pubkey fields), and\n- an open_channel_part2, where the rest of the pubkeys are sent\nThis way the peers would learn what the funding address would be after\nthe first round finishes, and could potentially use that to derive\ntheir other channel keys (needed for round 2).\n\nSo, to arrive at my point, I would like to ask whether people think\nsuch a change - or something similar - might be useful, and if so,\nwhether it could/should be incorporated to the current\nchannel establishment v2 proposal [1].\nIf there is agreement that this would be useful, a spec change\nwould be most useful before changing the 2of2 multisig script.\n\nRegards,\nghost43 (SomberNight)\n\n\n[0]: https://github.com/ACINQ/eclair/pull/1097\n[1]: https://github.com/lightningnetwork/lightning-rfc/pull/851"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-21T00:59:10",
                "message_text_only": "Good morning SomberNight,\n\n\n> Solutions:\n>\n> 1.  Naively, we could just derive a static key to be used as\n>     payment_basepoint, reused between all our channels, and watch the\n>     single resulting p2wsh script on-chain.\n>     Clearly this has terrible privacy implications.\n\nIf the only problem is horrible privacy, and you have an `OP_RETURN` identifying the channel counterparty node id anyway, would it not be possible to tweak this for each channel?\n\n    static_payment_basepoint_key + hash(seed | counterparty_node_id)\n\nThis (should) result in a unique key for each counterparty, yet each individual counterparty cannot predict this tweak (and break your privacy by deriving the `static_payment_basepoint_key * G`).\n\n?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "SomberNight",
                "date": "2021-09-21T01:36:24",
                "message_text_only": "Good morning ZmnSCPxj,\n\n> > Solutions:\n> >\n> > 1.  Naively, we could just derive a static key to be used as\n> >     payment_basepoint, reused between all our channels, and watch the\n> >     single resulting p2wsh script on-chain.\n> >     Clearly this has terrible privacy implications.\n>\n> If the only problem is horrible privacy, and you have an `OP_RETURN`identifying the channel counterparty node id anyway, would it not be possible to tweak this for each channel?\n> static_payment_basepoint_key + hash(seed | counterparty_node_id)\n> This (should) result in a unique key for each counterparty, yet each individual counterparty cannot predict this tweak (and break your privacy by deriving the `static_payment_basepoint_key * G`).\n\nThe OP_RETURN containing the encrypted counterparty node id\nis only an option, ideally it should not be required.\n\nAlso, your proposal needs a counter too, to avoid reuse between multiple\nchannels with the same counterparty. This counter is actually quite\nproblematic as users should be able to open new channels after\nrestoring from seed, which means they need to be able to figure out\nthe last value of the counter reliably, which seems potentially\nproblematic, so actually this might have to be a random nonce that is\nwide enough to make collisions unlikely... (potentially taking up\nvaluable blockchain space in the OP_RETURN)\n\nRegards,\nSomberNight"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-21T03:43:42",
                "message_text_only": "Good morning SomberNight,\n\n> Good morning ZmnSCPxj,\n>\n> > > Solutions:\n> > >\n> > > 1.  Naively, we could just derive a static key to be used as\n> > >     payment_basepoint, reused between all our channels, and watch the\n> > >     single resulting p2wsh script on-chain.\n> > >     Clearly this has terrible privacy implications.\n> > >\n> >\n> > If the only problem is horrible privacy, and you have an `OP_RETURN`identifying the channel counterparty node id anyway, would it not be possible to tweak this for each channel?\n> > static_payment_basepoint_key + hash(seed | counterparty_node_id)\n> > This (should) result in a unique key for each counterparty, yet each individual counterparty cannot predict this tweak (and break your privacy by deriving the `static_payment_basepoint_key * G`).\n>\n> The OP_RETURN containing the encrypted counterparty node id\n> is only an option, ideally it should not be required.\n>\n> Also, your proposal needs a counter too, to avoid reuse between multiple\n> channels with the same counterparty. This counter is actually quite\n> problematic as users should be able to open new channels after\n> restoring from seed, which means they need to be able to figure out\n> the last value of the counter reliably, which seems potentially\n> problematic, so actually this might have to be a random nonce that is\n> wide enough to make collisions unlikely... (potentially taking up\n> valuable blockchain space in the OP_RETURN)\n\n\nYes, that does seem to be somewhat problematic.\n\nAs to your proposal to change the open v2 protocol --- as I understand it, the current channel establishment v2 is already deployed in production on C-Lightning nodes, so at minimum your proposed extension should probably use different feature bits and message IDs, I think.\nCCing lisa for comment.\n\nIn any case, I think changing the actual commitment scheme to use MuSig1/MuSig2/MuSig-DN is lower priority than deploying PTLCs (and PTLCs can be used perfectly fine with the current commitment scheme, since you can spend from SegWitv1 P2WPKH to P2TR perfectly fine).\nThough it certainly depends on others what exactly they prioritize.\nI estimate that by the time we get around to MuSig, we may very well already have some kind of `SIGHASH_NOINPUT` or other more complicated scheme (I hope, maybe?) and might want to switch directly to Decker-Russell-Osuntokun instead of MuSig(2/DN)-Poon-Dryja.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Deriving channel keys deterministically from seed, musig, and channel establishment v2",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "SomberNight"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 10097
        }
    },
    {
        "title": "[Lightning-dev] Inherited IDs - A safer, more powerful alternative to BIP-118 (ANYPREVOUT) for scaling Bitcoin",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-09-17T16:58:45",
                "message_text_only": "Bitcoin & LN Devs,\n\nThe below is a message that was shared to me by an anon account on Telegram\n(nym: John Law). You can chat with them directly in the https://t.me/op_ctv\nor https://t.me/bips_activation group. I'm reproducing it here at their\nrequest as they were unsure of how to post to the mailing list without\ncompromising their identity (perhaps we should publish a guideline on how\nto do so?).\n\nBest,\n\nJeremy\n\n\nHi,\n\nI'd like to propose an alternative to BIP-118 [1] that is both safer and\nmore\npowerful. The proposal is called Inherited IDs (IIDs) and is described in a\npaper that can be found here [2]. The paper presents IIDs and Layer 2\nprotocols\nusing IIDs that are far more scalable and usable than those proposed for\nBIP-118\n(including eltoo [3]).\n\nLike BIP-118, IIDs are a proposal for a softfork that changes the rules for\ncalculating certain signatures. BIP-118 supports signatures that do not\ncommit to the transaction ID of the parent transaction, thus allowing\n\"floating\ntransactions\". In contrast, the IID proposal does not allow floating\ntransactions, but it does allow an output to specify that child transaction\nsignatures commit to the parent transaction's IID, rather than its\ntransaction\nID.\n\nIID Definitions\n===============\n* If T is a transaction, TXID(T) is the transaction ID of T.\n* An output is an \"IID output\" if it is a native SegWit output with version\n2\n  and a 32-byte witness program, and is a \"non-IID output\" otherwise.\n* A transaction is an \"IID transaction\" if it has at least one IID output.\n* If T is a non-IID transaction, or a coinbase transaction, IID(T) =\nTXID(T).\n* If T is a non-coinbase IID transaction, first_parent(T) = F is the\ntransaction\n  referenced by the OutPoint in T's input 0, and IID(T) = hash(IID(F) ||\nF_idx)\n  where F_idx is the index field in the OutPoint in T's input 0 (that is,\nT's\n  input 0 spends F's output F_idx).\n\nIID Signature Validation\n========================\n* Signatures that spend IID outputs commit to signature messages in which\nIIDs\n  replace transaction IDs in all OutPoints of the child transaction that\nspend\n  IID outputs.\n\nNote that IID(T) can be calculated from T (if it is a non-IID or a coinbase\ntransaction) or from T and F (otherwise). Therefore, as long as nodes store\n(or\ncalculate) the IID of each transaction in the UTXO set, they can validate\nsignatures of transactions that spend IID outputs. Thus, the IID proposal\nfits\nBitcoin's existing UTXO model, at the small cost of adding a 32-byte IID\nvalue\nfor certain unspent outputs. Also, note that the IID of a transaction may\nnot\ncommit to the exact contents of the transaction, but it does commit to how\nthe\ntransaction is related to some exactly-specified transaction (such as being\nthe\nfirst child of the second child of a specific transaction). As a result, a\ntransaction that is signed using IIDs cannot be used more than once or in an\nunanticipated location, thus making it much safer than a floating\ntransaction.\n\n2-Party Channel Protocols\n=========================\nBIP-118 supports the eltoo protocol [3] for 2-party channels, which improves\nupon the Lightning protocol for 2-party channels [4] by:\n1) simplifying the protocol,\n2) eliminating penalty transactions, and\n3) supporting late determination of transaction fees [1, Sec. 4.1.5].\n\nThe IID proposal does not support the eltoo protocol. However, the IID\nproposal\ndoes support a 2-party channel protocol, called 2Stage [2, Sec. 3.3], that\nis\narguably better than eltoo. Specifically, 2Stage achieves eltoo's 3\nimprovements\nlisted above, plus it:\n4) eliminates the need for watchtowers [2, Sec. 3.6], and\n5) has constant (rather than linear) worst-case on-chain costs [2, Sec.\n3.4].\n\nChannel Factories\n=================\nIn general, an on-chain transaction is required to create or close a 2-party\nchannel. Multi-party channel factories have been proposed in order to allow\na\nfixed set of parties to create and close numerous 2-party channels between\nthem,\nthus amortizing the on-channel costs of those channels [5]. BIP-118 also\nsupports simple and efficient multi-party channel factories via the eltoo\nprotocol [1, Sec. 5.2] (which are called \"multi-party channels\" in that\npaper).\n\nWhile the IID proposal does not support the eltoo protocol, it does support\nchannel factories that are far more scalable and powerful than any\npreviously-\nproposed channel factories (including eltoo factories). Specifically, IIDs\nsupport a simple factory protocol in which not all parties need to sign the\nfactory's funding transaction [2, Sec. 5.3], thus greatly improving the\nscale\nof the factory (at the expense of requiring an on-chain transaction to\nupdate\nthe set of channels created by the factory). These channel factories can be\ncombined with the 2Stage protocol to create trust-free and watchtower-free\nchannels including very large numbers of casual users.\n\nFurthermore, IIDs support channel factories with an unbounded number of\nparties\nthat allow all of the channels in the factory to be bought and sold by\nanyone\n(including parties not originally in the factory) with a single on-chain\ntransaction in a trust-free manner [2, Secs. 6 and 7]. As a result, a single\non-chain transaction can be used in place of thousands, or even millions, of\nLightning or eltoo on-chain transactions. These channel factory protocols\nmake\ncritical use of IIDs and do not appear to be possible with BIP-118.\n\nNext Steps\n==========\nIf IIDs sounds interesting, please take a look at the IID paper [2]. It\ncontains\nmany results not listed above, including rules for SVP nodes, protocols for\noff-chain channel networks, Layer 2 protocol extensions, support for\ncovenants\n(including vaults), and nearly matching lower and upper bounds on\nmulti-party\nchannels.\n\nThe paper also includes 3 options for how IIDs could be added to Bitcoin\nvia a\nsoftfork [2, Appendix A]. I'm new to Bitcoin and am not sure which of these\n3\noptions is best. If anyone finds the IID proposal valuable, I would greatly\nappreciate it if they were willing to pick the best option (or invent an\neven\nbetter option) for adding IIDs to Bitcoin and create a BIP for that option.\nHopefully, IIDs will provide a safe way to dramatically scale Bitcoin while\nimproving its usability.\n\nThanks,\nJohn\n\n\nReferences\n==========\n\n[1] BIP-118: https://anyprevout.xyz and\nhttps://github.com/bitcoin/bips/pull/943\n\n[2] Scaling Bitcoing with Inherited IDs, by John Law:\n    iids13.pdf at https://github.com/JohnLaw2/btc-iids\n\n[3] eltoo: A Simple Layer2 Protocol for Bitcoin, by Decker, Russell &\nOsuntokun:\n    https://blockstream.com/eltoo.pdf\n\n[4] The Bitcoin Lightning Network, by Poon & Dryja:\n    https://lightning.network/lightning-network-paper.pdf\n\n[5] Scalable Funding of Bitcoin Micropayment Channel Networks, by Burchert,\n    Decker & Wattenhofer: http://dx.doi.org/10.1098/rsos.180089\n\nAcknowledgments\n===============\nThanks to Ruben Somsen and Jeremy Rubin for their helpful comments.\n\nAlso, thanks to Bob McElrath for his original brainstorm that led to the\ncreation of the IID concept:\nhttps://diyhpl.us/wiki/transcripts/2019-02-09-mcelrath-on-chain-defense-in-depth\n\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210917/34fb43eb/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-21T02:11:42",
                "message_text_only": "Good morning John Law,\n\n\n> (at the expense of requiring an on-chain transaction to update\n> the set of channels created by the factory).\n\nHmmm this kind of loses the point of a factory?\nBy my understanding, the point is that the set of channels can be changed *without* an onchain transaction.\n\nOtherwise, it seems to me that factories with this \"expense of requiring an on-chain transaction\" can be created, today, without even Taproot:\n\n* The funding transaction output pays to a simple n-of-n.\n* The above n-of-n is spent by an *offchain* transaction that splits the funds to the current set of channels.\n* To change the set of channels, the participants perform this ritual:\n  * Create, but do not sign, an alternate transaction that spends the above n-of-n to a new n-of-n with the same participants (possibly with tweaked keys).\n  * Create and sign, but do not broadcast, a transaction that spends the above alternate n-of-n output and splits it to the new set of channels.\n  * Sign the alternate transaction and broadcast it, this is the on-chain transaction needed to update the set of channels.\n\nThe above works today without changes to Bitcoin, and even without Taproot (though for large N the witness size does become fairly large without Taproot).\n\nThe above is really just a \"no updates\" factory that cuts through its closing transaction with the opening of a new factory.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jeremy",
                "date": "2021-09-24T07:27:03",
                "message_text_only": "John let me know that he's posted some responses in his Github repo\nhttps://github.com/JohnLaw2/btc-iids\n\nprobably easiest to respond to him via e.g. a github issue or something.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210924/f1ecc8d3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Inherited IDs - A safer, more powerful alternative to BIP-118 (ANYPREVOUT) for scaling Bitcoin",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Jeremy",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9106
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Inherited IDs - A safer, more powerful alternative to BIP-118 (ANYPREVOUT) for scaling Bitcoin",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2021-09-18T11:37:40",
                "message_text_only": "On Fri, Sep 17, 2021 at 09:58:45AM -0700, Jeremy via bitcoin-dev wrote,\non behalf of John Law:\n\n> I'd like to propose an alternative to BIP-118 [1] that is both safer and more\n> powerful. The proposal is called Inherited IDs (IIDs) and is described in a\n> paper that can be found here [2]. [...]\n\nPretty sure I've skimmed this before but hadn't given it a proper look.\nSaying \"X is more powerful\" and then saying it can't actually do the\nsame stuff as the thing it's \"more powerful\" than always strikes me as\na red flag. Anyhoo..\n\nI think the basic summary is that you add to each utxo a new resettable\n\"structural\" tx id called an \"iid\" and indetify input txs that way when\nsigning, so that if the details of the transaction changes but not the\nstructure, the signature remains valid.\n\nIn particular, if you've got a tx with inputs tx1:n1, tx2:n2, tx3:n3, etc;\nand outputs out1, out2, out3, etc, then its structual id is hash(iid(tx1),\nn1) if any of its outputs are \"tagged\" and it's not a coinbase tx, and\notherwise it's just its txid.  (The proposed tagging is to use a segwit\nv2 output in the tx, though I don't think that's an essential detail)\n\nSo if you have a tx A with 3 outputs, then tx B spends \"A:0, A:1\" and\ntx C spends \"B:0\" and tx D spends \"C:0\", if you replace B with B',\nthen if both B and B' were tagged, and the signatures for C (and D,\nassuming C was tagged) will still be valid for spending from B'.\n\nSo the question is what you can do with that.\n\nThe \"2stage\" protocol is proposed as an alternative to eltoo is\nessentially just:\n\n a) funding tx gets dropped to the chain\n b) closing state is proposed by one party\n c) other party can immediately finalise by confirming a final state\n    that matches the proposed closing state, or was after it\n d) if the other party's not around for whatever delay, the party that\n    proposed the close can finalise it\n\nThat doesn't work for more than two participants, because two of\nthe participants could collude to take the fast path in (c) with some\nearlier state, robbing any other participants. That said, this is a fine\nprotocol for two participants, and might be better than doing the full\neltoo arrangement if you only have a two participant channel.\n\nTo make channel factories work in this model, I think the key step is\nusing invalidation trees to allow updating the split of funds between\ngroups of participants. I think invalidation trees introduce a tradeoff\nbetween (a) how many updates you can make, and (b) how long you have to\nnotice a close is proposed and correct it, before an invalidated state\ncan be posted, and (c) how long it will take to be able to extract your\nfunds from the factory if there are problems initially. You reduce those\ndelays substantially (to a log() factor) by introducing a hierarchy of\nupdate txs (giving you a log() number of txs), I think.\n\nThat's the \"multisig factories\" section anyway, if I'm\nfollowing correctly. The \"timeout trees\", \"update-forest\" and\n\"challenge-and-response\" approaches both introduce a trusted user (\"the\noperator\"), I think, so are perhaps more comparable to statechains\nthan eltoo?\n\nSo how does that compare, in my opinion?\n\nIf you consider special casing two-party channels with eltoo, then I\nthink eltoo-2party and 2stage are equally effective. Comparing\neltoo-nparty and the multisig iid factories approach, I think the\nuncooperative case looks like:\n\n ms-iid:\n   log(n) txs (for the invalidation tree)\n   log(n) time (?) (for the delays to ensure invalidated states don't\n                    get published)\n\n eltoo: 1 tx from you\n        1 block after you notice, plus the fixed csv delay\n\nA malicious counterparty can post many old update states prior to you\npoisting the latest state, but those don't introduce extra csv delays\nand you aren't paying the fees for those states, so I don't think it\nmakes sense to call that an O(n) delay or cost.\n\nAn additional practical problem with lightning is dealing with layered\ncommitments; that's a problem both for the delays while waiting for a\npotential rejection in 2stage and for the invalidation tree delays in the\nfactory construction. But it's not a solved problem for eltoo yet, either.\n\nAs far as implementation goes, introducing the \"iid\" concept would mean\nthat info would need to be added to the utxo database -- if every utxo\ngot an iid, that would be perhaps a 1.4GB increase to the utxo db (going\nby unique transaction rather than unique output), but presumably iid txs\nwould end up being both uncommon and short-lived, so the cost is probably\nreally mostly just in the additional complexity. Both iid and ANYPREVOUT\nrequire changes to how signatures are evaluated and apps that use the\nnew feature are written, but ANYPREVOUT doesn't need changes beyond that.\n\n(Also, the description of OP_CODESEPARATOR (footnote 13 on page 13,\nominous!) doesn't match its implementation in taproot. It also says BIP\n118 introduces a new address type for floating transactions, but while\nthis was floated on the list, the current draft of 118 just introduces\na new tapscript key type for normal taproot addresses)\n\nI think you can pretty easily simulate this construction with\nanyprevout. Where you would have had A:1 spent by B, and B:2 and B:3\nspent by C, change the derivation paths for the keys a1, b2, and b3\nto append \"/1\", \"/1/2\" and \"/1/3\" and don't reuse them, and sign with\nanyprevout when constructing B and C and any replacement transactions\nfor B and C.  So I don't think this allows any new constructions that\nanyprevout wouldn't.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Inherited IDs - A safer, more powerful alternative to BIP-118 (ANYPREVOUT) for scaling Bitcoin",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5536
        }
    },
    {
        "title": "[Lightning-dev] Stateless invoices with proof-of-payment",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2021-09-21T10:08:06",
                "message_text_only": "Problem\n\nOne of the qualities of lightning is that it can provide light-weight,\nno-login payments with minimal friction. Games, paywalls, podcasts, etc can\nimmediately present a QR code that is ready for scan and pay.\n\nOptimistically presenting payment requests does lead to many of those\npayment requests going unused. A user visits a news site and decides not to\nbuy the article. The conventional approach is to create a lightning invoice\non a node and store the invoice together with order details in a database.\nIf the order then goes unfulfilled, cleaning processes remove the data from\nthe node and database again.\n\nThe problem with this setup is that it needs protection against unbounded\ngeneration of payment requests. There are solutions for that such as rate\nlimiting, but wouldn't it be nice if invoices can be generated without the\nneed to keep any state at all?\n\nStateless invoices\n\nWhat would happen if a lightning invoice is only generated and stored\nnowhere on the recipient side? To the user, it won't make a difference.\nThey would still scan and pay the invoice. When the payment arrives at the\nrecipient though, two problems arise:\n\n1. Recipient doesn't know whom or what the payment is for.\n\nThis can be solved by attaching additional custom tlv records to the htlc.\nOn the wire, this is all arranged for. The only missing piece is the\nability to specify additional data for that custom tlv record in a bolt11\ninvoice. One way would be to define a new tagged field for this in which\nthe recipient can encode the order details.\n\nAn alternative is to use the existing invoice description field and simply\nalways pass that along with the htlc as a custom tlv record.\n\nA second alternative that already works today is to use part (for example\n16 out of 32 bytes) of the payment_secret (aka payment address) to encode\nthe order details in. This assumes that the secret is still secret enough\nwith reduced entropy. Also there may not be enough space for every\napplication.\n\n2. Recipient doesn't know the preimage that is needed to settle the htlc(s).\n\nOne option is to use a keysend payment or AMP payment. In that case, the\nsender includes the preimage with the htlc. Unfortunately this doesn't\nprovide the sender with a proof of payment that they'd get with a regular\nlightning payment.\n\nAn alternative solution is to use a deterministic preimage based on a\n(recipient node key-derived) secret, the payment secret and other relevant\nproperties. This allows the recipient to derive the same preimage twice:\nOnce when the lightning invoice is generated and again when a payment\narrives.\n\nIt could be something like this:\n\npayment_secret = random\npreimage = H(node_secret | payment_secret | payment_amount |\nencoded_order_details)\ninvoice_hash = H(preimage)\n\nThe sender sends an htlc locked to invoice_hash for payment_amount and\npasses along payment_secret and encoded_order_details in a custom tlv\nrecord.\n\nWhen the recipient receives the htlc, they reconstruct the preimage\naccording to the formula above. At this point, all data is available to do\nso. When H(preimage) indeed matches the htlc hash, they can settle the\npayment knowing that this is an order that they committed to earlier.\nSettling could be implemented as a just-in-time inserted invoice to keep\nthe diff small.\n\nThe preimage is returned to the sender and serves as a proof of payment.\n\nResilience\n\nTo me it seems that stateless invoices can be a relatively simple way to\nimprove the resiliency of systems that deal with lightning invoices.\nUnlimited amounts of invoices can be generated without worrying about\nstorage or memory, no matter if the requests are due to popularity of a\nservice or a deliberate dos attack.\n\nInterested to hear your thoughts.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/788f449b/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-21T11:11:10",
                "message_text_only": "Good morning Joost,\n\n> It could be something like this:\n>\n> payment_secret = random\n> preimage = H(node_secret | payment_secret | payment_amount | encoded_order_details)\n> invoice_hash = H(preimage)\n>\n> The sender sends an htlc locked to invoice_hash for payment_amount and passes along payment_secret and encoded_order_details in a custom tlv record.\n>\n> When the recipient receives the htlc, they reconstruct the preimage according to the formula above. At this point, all data is available to do so. When H(preimage) indeed matches the htlc hash, they can settle the payment knowing that this is an order that they committed to earlier. Settling could be implemented as a just-in-time inserted invoice to keep the diff small.\n>\n> The preimage is returned to the sender and serves as a proof of payment.\n\nDoes this actually work?\nHow does the sender know the `invoice_hash` to lock the HTLC(s) to?\n\nIf the sender does not know the `node_secret` (from its name, I am guessing it is a secret known only by the recipient?) then it cannot compute `invoice_hash`, the `invoice_hash` has to be somehow learned by the sender from the recipient.\n\nAnd that is done in the BOLT12 protocol by having the sender send a message to the recipient and getting a reply back, included in the reply is a unique BOLT11 invoice for a single intended payment.\n\n\nNote that even using point shenanigans and PTLCs seems not to work.\nIf you provide, say, a BIP32 nonhardened point / master pubkey, the sender could select an arbitrary `i` and ask for the scalar / privkey behind it, but that also lets the sender derive the master privete key used in the derivation.\nHardening the derivation would prevent master public keys from being used in derivations in the first place.\n\nHowever, we can do \"pay for signature\" protocols using PTLCs, and rather than requesting for a scalar behind a point as the proof-of-payment, we can instead ask for a signature of a message that attests \"this recipient got paid `payment_amount` with `encoded_order_details`\" and have a recipient pubkey (not necessarily the node key, it might be best to reduce signing for node keys) as the signing key.\n\n\nSo it seems to me that this cannot work with hashes, but *can* work with PTLCs if we use pay-for-signature and the proof-of-payment is a signature rather than a scalar.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Joost Jager",
                "date": "2021-09-21T11:25:41",
                "message_text_only": ">\n> > preimage = H(node_secret | payment_secret | payment_amount |\n> encoded_order_details)\n> > invoice_hash = H(preimage)\n> >\n> > The sender sends an htlc locked to invoice_hash for payment_amount and\n> passes along payment_secret and encoded_order_details in a custom tlv\n> record.\n> >\n> > When the recipient receives the htlc, they reconstruct the preimage\n> according to the formula above. At this point, all data is available to do\n> so. When H(preimage) indeed matches the htlc hash, they can settle the\n> payment knowing that this is an order that they committed to earlier.\n> Settling could be implemented as a just-in-time inserted invoice to keep\n> the diff small.\n> >\n> > The preimage is returned to the sender and serves as a proof of payment.\n>\n> Does this actually work?\n> How does the sender know the `invoice_hash` to lock the HTLC(s) to?\n\n\n> If the sender does not know the `node_secret` (from its name, I am\n> guessing it is a secret known only by the recipient?) then it cannot\n> compute `invoice_hash`, the `invoice_hash` has to be somehow learned by the\n> sender from the recipient.\n>\n\nSo to be clear: this isn't a spontaneous payment protocol with\nproof-of-payment. The sender will still request an invoice from the\nrecipient via an ordinary http request (think of a paywall with qr invoice\nthat is presented when web-browsing to a paid article). That is also how\nthe sender learns the invoice_hash. It is part of the bolt11 payment\nrequest as it always is.\n\nThe goal of the scheme is to alleviate the recipient from storing the\ninvoices that they generate.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/e9fbb17f/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-21T11:44:16",
                "message_text_only": "Good morning Joost,\n\n> > > preimage = H(node_secret | payment_secret | payment_amount | encoded_order_details)\n> > > invoice_hash = H(preimage)\n> > >\n> > > The sender sends an htlc locked to invoice_hash for payment_amount and passes along payment_secret and encoded_order_details in a custom tlv record.\n> > >\n> > > When the recipient receives the htlc, they reconstruct the preimage according to the formula above. At this point, all data is available to do so. When H(preimage) indeed matches the htlc hash, they can settle the payment knowing that this is an order that they committed to earlier. Settling could be implemented as a just-in-time inserted invoice to keep the diff small.\n> > >\n> > > The preimage is returned to the sender and serves as a proof of payment.\n> >\n> > Does this actually work?\n> > How does the sender know the `invoice_hash` to lock the HTLC(s) to?\n>\n> > If the sender does not know the `node_secret` (from its name, I am guessing it is a secret known only by the recipient?) then it cannot compute `invoice_hash`, the `invoice_hash` has to be somehow learned by the sender from the recipient.\n>\n> So to be clear: this isn't a spontaneous payment protocol with proof-of-payment. The sender will still request an invoice from the recipient via an ordinary http request (think of a paywall with qr invoice that is presented when web-browsing to a paid article). That is also how the sender learns the invoice_hash. It is part of the bolt11 payment request as it always is.\n>\n> The goal of the scheme is to alleviate the recipient from storing the invoices that they generate.\n\nAh, thanks for the clarification.\nThis should probably work, then.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-21T11:40:37",
                "message_text_only": "Good morning again Joost,\n\n> However, we can do \"pay for signature\" protocols using PTLCs, and rather than requesting for a scalar behind a point as the proof-of-payment, we can instead ask for a signature of a message that attests \"this recipient got paid `payment_amount` with `encoded_order_details`\" and have a recipient pubkey (not necessarily the node key, it might be best to reduce signing for node keys) as the signing key.\n>\n> So it seems to me that this cannot work with hashes, but can work with PTLCs if we use pay-for-signature and the proof-of-payment is a signature rather than a scalar.\n\nNo, it does not work either.\n\nThe reason is that for signing, we need an `R` as well.\nTypically, this is a transient keypair generated by the signer as `r = rand(); R = r * G`.\n\nIn order to set up a pay-for-signature, the sender needs to know an `R` from the recipient, and the recipient, being the signer, has to generate that `R` for itself.\nAnd if you are just going to do something like sender->request->receiver, receiver->R->sender, and *then* do the sender->PTLC->receiver, then you might as well just do sender->request->receiver, receiver->invoice->sender, sender->PTLC->receiver.\n\nI think your goal, as I understand it, is to reduce it to one round, i.e. sender->PTLC+some_data->receiver, then receiver responds to the PTLC that somehow generates the proof-of-payment.\nIs my understanding correct?\n\nWe cannot have the sender generate the `r` and `R = r * G` as knowledge of `r`, `s` and the signed message `m` results in learning the privkey `a`:\n\n    s = r - a * h(R | m)\n    a = (r - s) / h(R | m)\n\nEven with MuSig2 we need a separate round for `R` establishment before the round where everyone gives shares of `s`, and one can argue that a proof-of-payment, being an agreement of the sender and a receiver, is semantically equivalent to a 2-of-2 signature of both sender and the receiver signing off on the fact that the payment happened.\nThus, it seems to me that we can adapt any *secure* single-round multisignature Schnorr scheme to this problem of needing a single-round pay-for-signature.\n\n\nPerhaps another mechanism?\nWARNING: THIS IS NOVEL CRYPTOGRAPHY I THOUGHT UP IN FIVE MINUTES AND I AM NOT A CRYPTOGRAPHER, DO NOT ROLL YOUR OWN CRYPTO.\n\nInstead of having a single receiver-scalar, the receiver knows two scalars.\n\n   A = a * G\n   B = b * G\n\nThe sender knows both `A` and `B`.\n\nNow, suppose sender wants to make a payment to the receiver.\nAt its simplest, the sender can simply add `A + B` and lock an outgoing PTLC to that point.\nThe proof-of-payment is the sum `a + b`, but knowledge of this sum does not imply knowledge of either `a` or `b` (I THINK --- I AM NOT A CRYPTOGRAPHER).\n\nNow, suppose we want a proof-of-payment to be keyed to some data.\nWe can translate that data to a scalar (e.g. just hash it) and call it `d`.\nThen the sender makes a payment to the receiver using this point:\n\n    d * A + B\n\nThe sender then receives the scalar behind the above point:\n\n    d * a + b\n\nEven with knowledge of `d`, the sender cannot learn either `a` or `b` and thus cannot synthesize any other proof-of-payment with a different `d`, thus \"locking\" the proof-of-payment to a specific `d`.\n\nThe above proof-of-payment is sufficient by showing the point `d * A + B`, the committed data `d`, and the receiver public keys `A` and `B`.\n\nAGAIN THIS IS NOVEL CRYPTOGRAPHY I THOUGHT UP IN FIVE MINUTES AND I AM NOT A CRYPTOGRAPHER, THIS NEEDS ACTUAL MATHEMATICAL REVIEW FROM AN ACTUAL CRYPTOGRAPHER.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "fiatjaf",
                "date": "2021-09-21T12:03:44",
                "message_text_only": "What if instead of the payer generating the preimage the payee could\ngenerate stateless invoices? Basically just use some secret to compute the\npreimage upon receiving the HTLC, for example:\n\n1. Payer requests an invoice.\n2. Payee computes hash = sha256(hmac(local_secret, arbitrary_invoice_id)),\nthen encodes arbitrary_invoice_id into the invoice somehow.\n3. Payer sends payment with arbitrary_invoice_id as tlv_record_a.\n4. Upon receiving the HTLC, payee computes preimage = hmac(local_secret,\ntlv_record_a) and resolves it.\n\nI've implemented such a scheme on @lntxbot, but it required low level code\nin a c-lightning plugin and a hack with route hints: since TLV payloads\nwere not an option (as payers wouldn't know how to send them) I've used a\n\"shadow\" route hint to a private channel that didn't exist, so preimage was\ngenerated on the payee using preimage = hmac(local_secret,\nnext_channel_scid).\n\nIf however node implementations could provide such a thing it would reduce\ndatabase requirements and improve the lives of application developers very\nmuch.\n\nOn Tue, Sep 21, 2021 at 7:09 AM Joost Jager <joost.jager at gmail.com> wrote:\n\n> Problem\n>\n> One of the qualities of lightning is that it can provide light-weight,\n> no-login payments with minimal friction. Games, paywalls, podcasts, etc can\n> immediately present a QR code that is ready for scan and pay.\n>\n> Optimistically presenting payment requests does lead to many of those\n> payment requests going unused. A user visits a news site and decides not to\n> buy the article. The conventional approach is to create a lightning invoice\n> on a node and store the invoice together with order details in a database.\n> If the order then goes unfulfilled, cleaning processes remove the data from\n> the node and database again.\n>\n> The problem with this setup is that it needs protection against unbounded\n> generation of payment requests. There are solutions for that such as rate\n> limiting, but wouldn't it be nice if invoices can be generated without the\n> need to keep any state at all?\n>\n> Stateless invoices\n>\n> What would happen if a lightning invoice is only generated and stored\n> nowhere on the recipient side? To the user, it won't make a difference.\n> They would still scan and pay the invoice. When the payment arrives at the\n> recipient though, two problems arise:\n>\n> 1. Recipient doesn't know whom or what the payment is for.\n>\n> This can be solved by attaching additional custom tlv records to the htlc.\n> On the wire, this is all arranged for. The only missing piece is the\n> ability to specify additional data for that custom tlv record in a bolt11\n> invoice. One way would be to define a new tagged field for this in which\n> the recipient can encode the order details.\n>\n> An alternative is to use the existing invoice description field and simply\n> always pass that along with the htlc as a custom tlv record.\n>\n> A second alternative that already works today is to use part (for example\n> 16 out of 32 bytes) of the payment_secret (aka payment address) to encode\n> the order details in. This assumes that the secret is still secret enough\n> with reduced entropy. Also there may not be enough space for every\n> application.\n>\n> 2. Recipient doesn't know the preimage that is needed to settle the\n> htlc(s).\n>\n> One option is to use a keysend payment or AMP payment. In that case, the\n> sender includes the preimage with the htlc. Unfortunately this doesn't\n> provide the sender with a proof of payment that they'd get with a regular\n> lightning payment.\n>\n> An alternative solution is to use a deterministic preimage based on a\n> (recipient node key-derived) secret, the payment secret and other relevant\n> properties. This allows the recipient to derive the same preimage twice:\n> Once when the lightning invoice is generated and again when a payment\n> arrives.\n>\n> It could be something like this:\n>\n> payment_secret = random\n> preimage = H(node_secret | payment_secret | payment_amount |\n> encoded_order_details)\n> invoice_hash = H(preimage)\n>\n> The sender sends an htlc locked to invoice_hash for payment_amount and\n> passes along payment_secret and encoded_order_details in a custom tlv\n> record.\n>\n> When the recipient receives the htlc, they reconstruct the preimage\n> according to the formula above. At this point, all data is available to do\n> so. When H(preimage) indeed matches the htlc hash, they can settle the\n> payment knowing that this is an order that they committed to earlier.\n> Settling could be implemented as a just-in-time inserted invoice to keep\n> the diff small.\n>\n> The preimage is returned to the sender and serves as a proof of payment.\n>\n> Resilience\n>\n> To me it seems that stateless invoices can be a relatively simple way to\n> improve the resiliency of systems that deal with lightning invoices.\n> Unlimited amounts of invoices can be generated without worrying about\n> storage or memory, no matter if the requests are due to popularity of a\n> service or a deliberate dos attack.\n>\n> Interested to hear your thoughts.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/997189bc/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-09-21T12:40:24",
                "message_text_only": "On Tue, Sep 21, 2021 at 2:05 PM fiatjaf <fiatjaf at gmail.com> wrote:\n\n> What if instead of the payer generating the preimage the payee could\n> generate stateless invoices? Basically just use some secret to compute the\n> preimage upon receiving the HTLC, for example:\n>\n\nMaybe my explanation wasn't clear enough, but this is exactly what I am\nproposing. The payee generates a stateless invoice and gives it to the\npayer.\n\n\n> 1. Payer requests an invoice.\n> 2. Payee computes hash = sha256(hmac(local_secret, arbitrary_invoice_id)),\n> then encodes arbitrary_invoice_id into the invoice somehow.\n> 3. Payer sends payment with arbitrary_invoice_id as tlv_record_a.\n> 4. Upon receiving the HTLC, payee computes preimage = hmac(local_secret,\n> tlv_record_a) and resolves it.\n>\n\nOne way to do this that I tried to describe in the initial post is via the\npayment_secret. This is already an arbitrary invoice id that is already\nsent as a tlv record.\n\n\n> I've implemented such a scheme on @lntxbot, but it required low level code\n> in a c-lightning plugin and a hack with route hints: since TLV payloads\n> were not an option (as payers wouldn't know how to send them) I've used a\n> \"shadow\" route hint to a private channel that didn't exist, so preimage was\n> generated on the payee using preimage = hmac(local_secret,\n> next_channel_scid).\n>\n\nClever workaround.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/8f1a2a53/attachment.html>"
            },
            {
                "author": "fiatjaf",
                "date": "2021-09-21T13:05:48",
                "message_text_only": "Indeed, sorry, I misunderstood it because I read AMP/keysend and assumed\nyou were talking about payer-generated preimage.\nIt doesn't help that \"payer\" and \"payee\" are so similar words.\n\nSo yes, I agree very much.\n\nI also think the part about including the order details inside the TLV\nwould be very good to have.\n\nI would say, however, that these are two separate proposals:\n\n  1. implementations should expose a \"stateless invoice\" API for receiving\nusing the payment_secret;\n  2. when sending, implementations should attach a TLV record with encoded\norder details.\n\nOf these, 1 is very simple to do and do not require anyone to cooperate, it\njust works.\n\n2 requires full network compatibility, so it's harder. But 2 is also very\nmuch needed otherwise the payee has to keep track of all the invoice ids\nrelated to the orders they refer to, right? But I think just having 1\nalready improves the situation a lot, and there are application-specific\nworkarounds that can be applied for 2 (having a fixed, hardcoded set of\npossible orders, encoding the order very minimally in the payment secret or\nroute hint, storing order details on redis for only 3 minutes and using\nlnurlpay to reduce the delay between invoice issuance and user confirmation\nto zero, and so on).\n\nOn Tue, Sep 21, 2021 at 9:41 AM Joost Jager <joost.jager at gmail.com> wrote:\n\n> On Tue, Sep 21, 2021 at 2:05 PM fiatjaf <fiatjaf at gmail.com> wrote:\n>\n>> What if instead of the payer generating the preimage the payee could\n>> generate stateless invoices? Basically just use some secret to compute the\n>> preimage upon receiving the HTLC, for example:\n>>\n>\n> Maybe my explanation wasn't clear enough, but this is exactly what I am\n> proposing. The payee generates a stateless invoice and gives it to the\n> payer.\n>\n>\n>> 1. Payer requests an invoice.\n>> 2. Payee computes hash = sha256(hmac(local_secret,\n>> arbitrary_invoice_id)), then encodes arbitrary_invoice_id into the invoice\n>> somehow.\n>> 3. Payer sends payment with arbitrary_invoice_id as tlv_record_a.\n>> 4. Upon receiving the HTLC, payee computes preimage = hmac(local_secret,\n>> tlv_record_a) and resolves it.\n>>\n>\n> One way to do this that I tried to describe in the initial post is via the\n> payment_secret. This is already an arbitrary invoice id that is already\n> sent as a tlv record.\n>\n>\n>> I've implemented such a scheme on @lntxbot, but it required low level\n>> code in a c-lightning plugin and a hack with route hints: since TLV\n>> payloads were not an option (as payers wouldn't know how to send them) I've\n>> used a \"shadow\" route hint to a private channel that didn't exist, so\n>> preimage was generated on the payee using preimage = hmac(local_secret,\n>> next_channel_scid).\n>>\n>\n> Clever workaround.\n>\n> Joost\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/5b0b8328/attachment-0001.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-09-21T13:17:10",
                "message_text_only": "On Tue, Sep 21, 2021 at 3:06 PM fiatjaf <fiatjaf at gmail.com> wrote:\n\n> I would say, however, that these are two separate proposals:\n>\n>   1. implementations should expose a \"stateless invoice\" API for receiving\n> using the payment_secret;\n>   2. when sending, implementations should attach a TLV record with encoded\n> order details.\n>\n> Of these, 1 is very simple to do and do not require anyone to cooperate,\n> it just works.\n>\n> 2 requires full network compatibility, so it's harder. But 2 is also very\n> much needed otherwise the payee has to keep track of all the invoice ids\n> related to the orders they refer to, right?\n>\n\nNot completely sure what you mean by full network compatibility, but a\nnetwork-wide upgrade including all routing nodes isn't needed. I think to\ndo it cleanly we need a new tag for bolt11 and node implementations that\ncarry over the contents of this field to a tlv record. So senders do need\nto support this.\n\n\n> But I think just having 1 already improves the situation a lot, and there\n> are application-specific workarounds that can be applied for 2 (having a\n> fixed, hardcoded set of possible orders, encoding the order very minimally\n> in the payment secret or route hint, storing order details on redis for\n> only 3 minutes and using lnurlpay to reduce the delay between invoice\n> issuance and user confirmation to zero, and so on).\n>\n\nA stateless invoice API would be a great thing to have. I've prototyped\nthis in lnd and if you implement it so that a regular invoice is inserted\n'just in time', it isn't too involved as you say.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/e683619e/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-09-21T15:47:12",
                "message_text_only": "Hi Joost,\n\nConcept ACK, I had toyed with something similar a while ago, but I hadn't\nrealized\nthat invoice storage was such a DoS vector for merchants/hubs and wasn't\nsure it\nwould be useful.\n\nDo you have an example of what information you would usually put in your\n`encoded_order_details`?\n\nI'd imagine that it would usually be simply a skuID from the merchant's\nproduct\ndatabase, but it could also be fully self-contained data to identify a\n\"transaction\"\n(probably encrypted with a key belonging to the payee).\n\nWe'd want to ensure that this field is reasonably small, to ensure it can\nfit in\nonions without forcing the sender to use shorter routes or disable other\nfeatures.\n\nCheers,\nBastien\n\n\nLe mar. 21 sept. 2021 \u00e0 15:17, Joost Jager <joost.jager at gmail.com> a \u00e9crit :\n\n> On Tue, Sep 21, 2021 at 3:06 PM fiatjaf <fiatjaf at gmail.com> wrote:\n>\n>> I would say, however, that these are two separate proposals:\n>>\n>>   1. implementations should expose a \"stateless invoice\" API for\n>> receiving using the payment_secret;\n>>   2. when sending, implementations should attach a TLV record with\n>> encoded order details.\n>>\n>> Of these, 1 is very simple to do and do not require anyone to cooperate,\n>> it just works.\n>>\n>> 2 requires full network compatibility, so it's harder. But 2 is also very\n>> much needed otherwise the payee has to keep track of all the invoice ids\n>> related to the orders they refer to, right?\n>>\n>\n> Not completely sure what you mean by full network compatibility, but a\n> network-wide upgrade including all routing nodes isn't needed. I think to\n> do it cleanly we need a new tag for bolt11 and node implementations that\n> carry over the contents of this field to a tlv record. So senders do need\n> to support this.\n>\n>\n>> But I think just having 1 already improves the situation a lot, and there\n>> are application-specific workarounds that can be applied for 2 (having a\n>> fixed, hardcoded set of possible orders, encoding the order very minimally\n>> in the payment secret or route hint, storing order details on redis for\n>> only 3 minutes and using lnurlpay to reduce the delay between invoice\n>> issuance and user confirmation to zero, and so on).\n>>\n>\n> A stateless invoice API would be a great thing to have. I've prototyped\n> this in lnd and if you implement it so that a regular invoice is inserted\n> 'just in time', it isn't too involved as you say.\n>\n> Joost\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/f31a309c/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-09-21T17:12:52",
                "message_text_only": "On Tue, Sep 21, 2021 at 5:47 PM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Hi Joost,\n>\n> Concept ACK, I had toyed with something similar a while ago, but I hadn't\n> realized\n> that invoice storage was such a DoS vector for merchants/hubs and wasn't\n> sure it\n> would be useful.\n>\n\nYes, I definitely think it is. Especially in a future where LN invoices are\ngenerated casually everywhere.\n\nI started a PR on lightning-rfc to explore the impact points.\nhttps://github.com/lightningnetwork/lightning-rfc/pull/912\n\n\n> Do you have an example of what information you would usually put in your\n> `encoded_order_details`?\n>\n> I'd imagine that it would usually be simply a skuID from the merchant's\n> product\n> database, but it could also be fully self-contained data to identify a\n> \"transaction\"\n> (probably encrypted with a key belonging to the payee).\n>\n\nI think it depends on the application. For a paywall it could be the\narticle id and an identifier for the user - perhaps a cookie in the user's\nbrowser. But it could indeed go as far as a list of skus and the physical\ndelivery address for the goods. That obviously won't be suitable for every\napplication because of the limited space. Passing a full online supermarket\nshopping cart in the tlv payload is probably stretching it too far.\n\nLast year, me and my former colleagues Oliver and Desiree ran tlvshop.com.\nThe site is offline now, but still viewable at\nhttps://joostjager.github.io/tlvshop.com/. If you fill out all the fields,\nit encodes the data into a (non-standard) tlv field. In the case of\ntlvshop, the payment is truly spontaneous. However the idea of encoding\nmetadata is the same.\n\nAttaching metadata to a payment is almost impossible with traditional\npayments. Lightning changes this and I think that is also a great\nopportunity to rethink typical design patterns for ecommerce applications.\n\n\n> We'd want to ensure that this field is reasonably small, to ensure it can\n> fit in\n> onions without forcing the sender to use shorter routes or disable other\n> features.\n>\n\nI don't know if something bad can happen if the sender is forced to use\nshorter routes. Maybe as a method to shape traffic in a certain way? Not\ntotally sure, but perhaps this is already possible today by creating bogus\nroute hints. In general I'd say that too much metadata just decreases the\npayment success rate and therefore something the payee will consider when\ncreating the invoice. A reasonable cap is an easy fix to address any doubts\non this front though. Only what constant to pick...\n\nJoost.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/0690ebf4/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-09-22T23:40:55",
                "message_text_only": "Hi Joost,\n\n> The conventional approach is to create a lightning invoice on a node and\n> store the invoice together with order details in a database. If the order\n> then goes unfulfilled, cleaning processes remove the data from the node\n> and database again.\n\n> The problem with this setup is that it needs protection against unbounded\n> generation of payment requests. There are solutions for that such as rate\n> limiting, but wouldn't it be nice if invoices can be generated without the\n> need to keep any state at all?\n\nIsn't this ultimately an engineering issue? How much exactly is \"too much\"\nin this case? Invoices are relatively small, and also don't even necessarily\nneed to be ever written to disk assuming a slim expiration window. It's\nlikely the case that a service can just throw everything in Redis and call\nit a day. In terms of rate limiting a service would likely already need to\nimplement that on the API/service level to mitigate app level DoS attacks.\n\nAs far as pre-images go, this can already be \"stateless\" by generating a\nsingle random seed (storing that somewhere w/ a counter likely) and then\nusing shachain or elkrem to deterministically generate payment hashes. You\ncan then either use the payment_addr/secret to index into the hash chain, or\nhave the user send some counter extracted from the invoice as a custom\nrecord. Similar schemes have been proposed in the past to support \"offline\"\nvending machine payments.\n\nTaking it one step further, the service could maintain a unique\nelkrem/shachain state for each unique user, which would then allow them to\nalso collapse the pre-image into the hash chain, which lets them save space\nand be able to reproduce a given \"proof that someone in the world paid\"\n(that no service/wallet seems to accept/generate in an\nautomated/standardized manner) statement dynamically.\n\n-- Laolu\n\n\nOn Tue, Sep 21, 2021 at 3:08 AM Joost Jager <joost.jager at gmail.com> wrote:\n\n> Problem\n>\n> One of the qualities of lightning is that it can provide light-weight,\n> no-login payments with minimal friction. Games, paywalls, podcasts, etc can\n> immediately present a QR code that is ready for scan and pay.\n>\n> Optimistically presenting payment requests does lead to many of those\n> payment requests going unused. A user visits a news site and decides not to\n> buy the article. The conventional approach is to create a lightning invoice\n> on a node and store the invoice together with order details in a database.\n> If the order then goes unfulfilled, cleaning processes remove the data from\n> the node and database again.\n>\n> The problem with this setup is that it needs protection against unbounded\n> generation of payment requests. There are solutions for that such as rate\n> limiting, but wouldn't it be nice if invoices can be generated without the\n> need to keep any state at all?\n>\n> Stateless invoices\n>\n> What would happen if a lightning invoice is only generated and stored\n> nowhere on the recipient side? To the user, it won't make a difference.\n> They would still scan and pay the invoice. When the payment arrives at the\n> recipient though, two problems arise:\n>\n> 1. Recipient doesn't know whom or what the payment is for.\n>\n> This can be solved by attaching additional custom tlv records to the htlc.\n> On the wire, this is all arranged for. The only missing piece is the\n> ability to specify additional data for that custom tlv record in a bolt11\n> invoice. One way would be to define a new tagged field for this in which\n> the recipient can encode the order details.\n>\n> An alternative is to use the existing invoice description field and simply\n> always pass that along with the htlc as a custom tlv record.\n>\n> A second alternative that already works today is to use part (for example\n> 16 out of 32 bytes) of the payment_secret (aka payment address) to encode\n> the order details in. This assumes that the secret is still secret enough\n> with reduced entropy. Also there may not be enough space for every\n> application.\n>\n> 2. Recipient doesn't know the preimage that is needed to settle the\n> htlc(s).\n>\n> One option is to use a keysend payment or AMP payment. In that case, the\n> sender includes the preimage with the htlc. Unfortunately this doesn't\n> provide the sender with a proof of payment that they'd get with a regular\n> lightning payment.\n>\n> An alternative solution is to use a deterministic preimage based on a\n> (recipient node key-derived) secret, the payment secret and other relevant\n> properties. This allows the recipient to derive the same preimage twice:\n> Once when the lightning invoice is generated and again when a payment\n> arrives.\n>\n> It could be something like this:\n>\n> payment_secret = random\n> preimage = H(node_secret | payment_secret | payment_amount |\n> encoded_order_details)\n> invoice_hash = H(preimage)\n>\n> The sender sends an htlc locked to invoice_hash for payment_amount and\n> passes along payment_secret and encoded_order_details in a custom tlv\n> record.\n>\n> When the recipient receives the htlc, they reconstruct the preimage\n> according to the formula above. At this point, all data is available to do\n> so. When H(preimage) indeed matches the htlc hash, they can settle the\n> payment knowing that this is an order that they committed to earlier.\n> Settling could be implemented as a just-in-time inserted invoice to keep\n> the diff small.\n>\n> The preimage is returned to the sender and serves as a proof of payment.\n>\n> Resilience\n>\n> To me it seems that stateless invoices can be a relatively simple way to\n> improve the resiliency of systems that deal with lightning invoices.\n> Unlimited amounts of invoices can be generated without worrying about\n> storage or memory, no matter if the requests are due to popularity of a\n> service or a deliberate dos attack.\n>\n> Interested to hear your thoughts.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210922/d6fd7732/attachment-0001.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-09-23T09:48:06",
                "message_text_only": ">\n> > The conventional approach is to create a lightning invoice on a node and\n> > store the invoice together with order details in a database. If the order\n> > then goes unfulfilled, cleaning processes remove the data from the node\n> > and database again.\n>\n> > The problem with this setup is that it needs protection against unbounded\n> > generation of payment requests. There are solutions for that such as rate\n> > limiting, but wouldn't it be nice if invoices can be generated without\n> the\n> > need to keep any state at all?\n>\n> Isn't this ultimately an engineering issue? How much exactly is \"too much\"\n> in this case? Invoices are relatively small, and also don't even\n> necessarily\n> need to be ever written to disk assuming a slim expiration window. It's\n> likely the case that a service can just throw everything in Redis and call\n> it a day. In terms of rate limiting a service would likely already need to\n> implement that on the API/service level to mitigate app level DoS attacks.\n>\n\nIt is an engineering issue and indeed, you can use something like Redis to\nsolve it. Today's internet is probably doing the same thing and it seems to\nwork so far. With lightning though, there is another option. And it could\nbe an engineering advantage to not have to keep that state. I can also\nimagine that slim expiration windows aren't always desirable. Thinking of\npersonalized payment requests in mass mailings for example.\n\nSo yes, this is not about new functionality, but I still think it is worth\nexploring the path.\n\nAs far as pre-images go, this can already be \"stateless\" by generating a\n> single random seed (storing that somewhere w/ a counter likely) and then\n> using shachain or elkrem to deterministically generate payment hashes. You\n> can then either use the payment_addr/secret to index into the hash chain,\n> or\n> have the user send some counter extracted from the invoice as a custom\n> record. Similar schemes have been proposed in the past to support \"offline\"\n> vending machine payments.\n>\n\nWhat would be the advantage of using elkrem or shachain compared to just\nusing `H(receiver_node_secret | payment_secret)` as the preimage? The\nsender knows all the preimages already anyway, they aren't revealed one by\none by another party.\n\nAlso I think it could be beneficial to add more data into that hash\nfunction such as the payment amount and the order details. With that, the\nreceiver knows that they received a payment for something that they offered\nin the past, without having the actual record of that stored somewhere.\n\n\n> Taking it one step further, the service could maintain a unique\n> elkrem/shachain state for each unique user, which would then allow them to\n> also collapse the pre-image into the hash chain, which lets them save space\n> and be able to reproduce a given \"proof that someone in the world paid\"\n> (that no service/wallet seems to accept/generate in an\n> automated/standardized manner) statement dynamically\n>\n\nCan you provide an example to clarify this idea a bit more? If I read it\ncorrectly, the goal is for the receiver to produce a proof that someone in\nthe world paid. But how can this be proven if the receiver can generate all\nthe preimages that they want?\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210923/380db50c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Stateless invoices with proof-of-payment",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "fiatjaf",
                "Bastien TEINTURIER",
                "Joost Jager",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 40050
        }
    },
    {
        "title": "[Lightning-dev] Opening balanced channels using PSBT",
        "thread_messages": [
            {
                "author": "Ole Henrik Skogstr\u00f8m",
                "date": "2021-09-21T18:42:54",
                "message_text_only": "Hi\n\nI have found a way of opening balanced channels using LND's psbt option\nwhen opening channels. What I'm doing is essentially just joining funded\nPSBTs before signing and submitting them. This makes it possible to open a\nbalanced channel between two nodes or open a ring of balanced channels\nbetween multiple nodes (ROF).\n\nI found this interesting, however I don't know if this is somehow unsafe or\nfor some other reason a bad idea. If not, then it could be an interesting\nalternative to only being able to open unbalanced channels.\n\nTo do this efficiently, nodes need to collaborate by sending PSBTs back and\nforth to each other and doing this manually is a pain, so if this makes\nsense to do, it would be best to automate it through a client.\n\n----------------------\n--- Here is an example of the complete flow for a single channel:\n----------------------\n\n** Node A: generates a new address and sends address to Node B *(lncli\nnewaddress p2wkh)\n\n** Node A starts an Interactive channel **open** to Node B* *using psbt*\n(lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n\n** Node A funds the channel address *(bitcoin-cli walletcreatefundedpsbt []\n'[{\"<channel_address>\":0.02}]')\n\n** Node B funds the refund transaction to Node A and sends PSBT back to\nNode A (*bitcoin-cli walletcreatefundedpsbt []\n'[{\"<node_a_return_address>\":0.01}]')\n\n* *Node A joins the two PSBTs and sends it back to Node B (*bitcoin-cli\njoinpsbts '[\"<channel_open_psbt>\", \"<node_b_return_to_node_a_psbt>\"]')\n\n** Node B verifies the content and signs the joined PSBT before sending it\nback to Node A *(bitcoin-cli walletprocesspsbt <joined_psbt>)\n\n** Node A: Verifies the content and signs the joined PSBT *(bitcoin-cli\nwalletprocesspsbt <joined_psbt>)\n\n** Node A: Completes channel open by publishing the fully signed PSBT*\n\n\n----------------------\n--- Here is an example of the complete flow for a ring of channels between\nmultiple nodes:\n----------------------\n\n** Node A starts an Interactive open channel to Node B using psbt* (lncli\nopenchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n** Node A funds the channel address* (bitcoin-cli walletcreatefundedpsbt []\n'[{\"<channel_address>\":0.02}]')\n\n** Node B starts an Interactive open channel to Node C using psbt* (lncli\nopenchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n** Node B funds the channel address* (bitcoin-cli walletcreatefundedpsbt []\n'[{\"<channel_address>\":0.02}]')\n\n** Node C starts an Interactive open channel to Node A using psbt* (lncli\nopenchannel --psbt <node_b_pubkey> 2000000 1000000)\n** Node C funds the channel address *(bitcoin-cli walletcreatefundedpsbt []\n'[{\"<channel_address>\":0.02}]')\n\n** Node B and C sends Node A their PSBTs*\n\n** Node A joins all the PSBTs* (bitcoin-cli joinpsbts\n'[\"<A_funded_channel_psbt>\", \"<B_funded_channel_psbt>\",\n\"<C_funded_channel_psbt>\"]')\n\nUsing (bitcoin-cli walletprocesspsbt <joined_psbt>):\n\n\n\n** Node A verifies and signs the PSBT and sends it to Node B (1/3\nsignatures)* Node B verifies and signs the PSBT and sends it to Node C (2/3\nsignatures)* Node C verifies and signs the PSBT (3/3 signatures) before\nsending it to Node A and B.*\n\n\n** Node A completes channel open (no_publish)* Node B completes channel\nopen (no_publish)* Node C completes channel open and publishes the\ntransaction.*\n\n--\nOle Henrik Skogstr\u00f8m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210921/f3803583/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-09-22T06:58:18",
                "message_text_only": "Hi,\n\nThis is exactly what the dual funding proposal provides:\nhttps://github.com/lightningnetwork/lightning-rfc/pull/851\n\nCheers,\nBastien\n\nLe mer. 22 sept. 2021 \u00e0 07:29, Ole Henrik Skogstr\u00f8m <oleskogstrom at gmail.com>\na \u00e9crit :\n\n> Hi\n>\n> I have found a way of opening balanced channels using LND's psbt option\n> when opening channels. What I'm doing is essentially just joining funded\n> PSBTs before signing and submitting them. This makes it possible to open a\n> balanced channel between two nodes or open a ring of balanced channels\n> between multiple nodes (ROF).\n>\n> I found this interesting, however I don't know if this is somehow unsafe\n> or for some other reason a bad idea. If not, then it could be an\n> interesting alternative to only being able to open unbalanced channels.\n>\n> To do this efficiently, nodes need to collaborate by sending PSBTs back\n> and forth to each other and doing this manually is a pain, so if this makes\n> sense to do, it would be best to automate it through a client.\n>\n> ----------------------\n> --- Here is an example of the complete flow for a single channel:\n> ----------------------\n>\n> ** Node A: generates a new address and sends address to Node B *(lncli\n> newaddress p2wkh)\n>\n> ** Node A starts an Interactive channel **open** to Node B* *using psbt*\n> (lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n>\n> ** Node A funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node B funds the refund transaction to Node A and sends PSBT back to\n> Node A (*bitcoin-cli walletcreatefundedpsbt []\n> '[{\"<node_a_return_address>\":0.01}]')\n>\n> * *Node A joins the two PSBTs and sends it back to Node B (*bitcoin-cli\n> joinpsbts '[\"<channel_open_psbt>\", \"<node_b_return_to_node_a_psbt>\"]')\n>\n> ** Node B verifies the content and signs the joined PSBT before sending it\n> back to Node A *(bitcoin-cli walletprocesspsbt <joined_psbt>)\n>\n> ** Node A: Verifies the content and signs the joined PSBT *(bitcoin-cli\n> walletprocesspsbt <joined_psbt>)\n>\n> ** Node A: Completes channel open by publishing the fully signed PSBT*\n>\n>\n> ----------------------\n> --- Here is an example of the complete flow for a ring of channels between\n> multiple nodes:\n> ----------------------\n>\n> ** Node A starts an Interactive open channel to Node B using psbt* (lncli\n> openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n> ** Node A funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node B starts an Interactive open channel to Node C using psbt* (lncli\n> openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n> ** Node B funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node C starts an Interactive open channel to Node A using psbt* (lncli\n> openchannel --psbt <node_b_pubkey> 2000000 1000000)\n> ** Node C funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node B and C sends Node A their PSBTs*\n>\n> ** Node A joins all the PSBTs* (bitcoin-cli joinpsbts\n> '[\"<A_funded_channel_psbt>\", \"<B_funded_channel_psbt>\",\n> \"<C_funded_channel_psbt>\"]')\n>\n> Using (bitcoin-cli walletprocesspsbt <joined_psbt>):\n>\n>\n>\n> ** Node A verifies and signs the PSBT and sends it to Node B (1/3\n> signatures)* Node B verifies and signs the PSBT and sends it to Node C (2/3\n> signatures)* Node C verifies and signs the PSBT (3/3 signatures) before\n> sending it to Node A and B.*\n>\n>\n> ** Node A completes channel open (no_publish)* Node B completes channel\n> open (no_publish)* Node C completes channel open and publishes the\n> transaction.*\n>\n> --\n> Ole Henrik Skogstr\u00f8m\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210922/7eca3d87/attachment.html>"
            },
            {
                "author": "Ole Henrik Skogstr\u00f8m",
                "date": "2021-09-25T11:40:21",
                "message_text_only": "Thank you Bastien\n\nDidn't know about this PR. Should have searched more thoroughly next time.\nBut good to see this feature is underway.\n\n--\nOle Henrik Skogstr\u00f8m\nMobile: (+47) 97 42 74 44\n\n\nOn Wed, Sep 22, 2021 at 8:58 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Hi,\n>\n> This is exactly what the dual funding proposal provides:\n> https://github.com/lightningnetwork/lightning-rfc/pull/851\n>\n> Cheers,\n> Bastien\n>\n> Le mer. 22 sept. 2021 \u00e0 07:29, Ole Henrik Skogstr\u00f8m <\n> oleskogstrom at gmail.com> a \u00e9crit :\n>\n>> Hi\n>>\n>> I have found a way of opening balanced channels using LND's psbt option\n>> when opening channels. What I'm doing is essentially just joining funded\n>> PSBTs before signing and submitting them. This makes it possible to open a\n>> balanced channel between two nodes or open a ring of balanced channels\n>> between multiple nodes (ROF).\n>>\n>> I found this interesting, however I don't know if this is somehow unsafe\n>> or for some other reason a bad idea. If not, then it could be an\n>> interesting alternative to only being able to open unbalanced channels.\n>>\n>> To do this efficiently, nodes need to collaborate by sending PSBTs back\n>> and forth to each other and doing this manually is a pain, so if this makes\n>> sense to do, it would be best to automate it through a client.\n>>\n>> ----------------------\n>> --- Here is an example of the complete flow for a single channel:\n>> ----------------------\n>>\n>> ** Node A: generates a new address and sends address to Node B *(lncli\n>> newaddress p2wkh)\n>>\n>> ** Node A starts an Interactive channel **open** to Node B* *using psbt*\n>> (lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n>>\n>> ** Node A funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node B funds the refund transaction to Node A and sends PSBT back to\n>> Node A (*bitcoin-cli walletcreatefundedpsbt []\n>> '[{\"<node_a_return_address>\":0.01}]')\n>>\n>> * *Node A joins the two PSBTs and sends it back to Node B (*bitcoin-cli\n>> joinpsbts '[\"<channel_open_psbt>\", \"<node_b_return_to_node_a_psbt>\"]')\n>>\n>> ** Node B verifies the content and signs the joined PSBT before sending\n>> it back to Node A *(bitcoin-cli walletprocesspsbt <joined_psbt>)\n>>\n>> ** Node A: Verifies the content and signs the joined PSBT *(bitcoin-cli\n>> walletprocesspsbt <joined_psbt>)\n>>\n>> ** Node A: Completes channel open by publishing the fully signed PSBT*\n>>\n>>\n>> ----------------------\n>> --- Here is an example of the complete flow for a ring of channels\n>> between multiple nodes:\n>> ----------------------\n>>\n>> ** Node A starts an Interactive open channel to Node B using psbt*\n>> (lncli openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n>> ** Node A funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node B starts an Interactive open channel to Node C using psbt*\n>> (lncli openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n>> ** Node B funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node C starts an Interactive open channel to Node A using psbt*\n>> (lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n>> ** Node C funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node B and C sends Node A their PSBTs*\n>>\n>> ** Node A joins all the PSBTs* (bitcoin-cli joinpsbts\n>> '[\"<A_funded_channel_psbt>\", \"<B_funded_channel_psbt>\",\n>> \"<C_funded_channel_psbt>\"]')\n>>\n>> Using (bitcoin-cli walletprocesspsbt <joined_psbt>):\n>>\n>>\n>>\n>> ** Node A verifies and signs the PSBT and sends it to Node B (1/3\n>> signatures)* Node B verifies and signs the PSBT and sends it to Node C (2/3\n>> signatures)* Node C verifies and signs the PSBT (3/3 signatures) before\n>> sending it to Node A and B.*\n>>\n>>\n>> ** Node A completes channel open (no_publish)* Node B completes channel\n>> open (no_publish)* Node C completes channel open and publishes the\n>> transaction.*\n>>\n>> --\n>> Ole Henrik Skogstr\u00f8m\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210925/ccd224f4/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-09-22T23:30:56",
                "message_text_only": "Hi Ole,\n\nIt's generally known that one can use out of band transaction construction,\nand the push_amt feature in the base funding protocol to simulate dual\nfunded channels.\n\nThe popular 'balanceofsatoshis' tool has a command that packages up the\ninteraction (`open-balanced-channel`) into an easier to use format, IIRC it\nuses key send to ask a peer if they'll accept one and negotiate some of the\nparams.\n\nThe one thing you need to take mind of when doing this manually is that by\ndefault lnd will only lock the UTXOs allocated for the funding attempt for a\nfew minutes. As a result, you need to make sure the process is finalized\nduring that interval or the UTXOs will be unlocked and you risk accidentally\ndouble spending yourself.\n\nLightning Pool also uses this little trick to allows users to purchase\nchannels that are 50/50 balanced, and also purchase channel leases _for_ a\nthird party (called sidecar channels) to help on board them onto Lightning:\nhttps://lightning.engineering/posts/2021-05-26-sidecar-channels/. Compared\nto the above approaches, the process can be automatically batched w/ other\nchannels created in that epoch, and uses traits of the Pool account system\nto make things atomic.\n\nUltimately, the balanced-ness of a channel is a transitory state (for\nrouting nodes, it's great for on-boarding end-users) and opening channels\nlike these only serves to allow the channel to _start_ in the state. If your\nfees and channel policies aren't set accordingly, then it's possible that a\nnormal payment or balance flow shifts the channel away from equilibrium\nshortly after the channel is open.\n\n-- Laolu\n\nOn Tue, Sep 21, 2021 at 10:30 PM Ole Henrik Skogstr\u00f8m <\noleskogstrom at gmail.com> wrote:\n\n> Hi\n>\n> I have found a way of opening balanced channels using LND's psbt option\n> when opening channels. What I'm doing is essentially just joining funded\n> PSBTs before signing and submitting them. This makes it possible to open a\n> balanced channel between two nodes or open a ring of balanced channels\n> between multiple nodes (ROF).\n>\n> I found this interesting, however I don't know if this is somehow unsafe\n> or for some other reason a bad idea. If not, then it could be an\n> interesting alternative to only being able to open unbalanced channels.\n>\n> To do this efficiently, nodes need to collaborate by sending PSBTs back\n> and forth to each other and doing this manually is a pain, so if this makes\n> sense to do, it would be best to automate it through a client.\n>\n> ----------------------\n> --- Here is an example of the complete flow for a single channel:\n> ----------------------\n>\n> ** Node A: generates a new address and sends address to Node B *(lncli\n> newaddress p2wkh)\n>\n> ** Node A starts an Interactive channel **open** to Node B* *using psbt*\n> (lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n>\n> ** Node A funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node B funds the refund transaction to Node A and sends PSBT back to\n> Node A (*bitcoin-cli walletcreatefundedpsbt []\n> '[{\"<node_a_return_address>\":0.01}]')\n>\n> * *Node A joins the two PSBTs and sends it back to Node B (*bitcoin-cli\n> joinpsbts '[\"<channel_open_psbt>\", \"<node_b_return_to_node_a_psbt>\"]')\n>\n> ** Node B verifies the content and signs the joined PSBT before sending it\n> back to Node A *(bitcoin-cli walletprocesspsbt <joined_psbt>)\n>\n> ** Node A: Verifies the content and signs the joined PSBT *(bitcoin-cli\n> walletprocesspsbt <joined_psbt>)\n>\n> ** Node A: Completes channel open by publishing the fully signed PSBT*\n>\n>\n> ----------------------\n> --- Here is an example of the complete flow for a ring of channels between\n> multiple nodes:\n> ----------------------\n>\n> ** Node A starts an Interactive open channel to Node B using psbt* (lncli\n> openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n> ** Node A funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node B starts an Interactive open channel to Node C using psbt* (lncli\n> openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n> ** Node B funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node C starts an Interactive open channel to Node A using psbt* (lncli\n> openchannel --psbt <node_b_pubkey> 2000000 1000000)\n> ** Node C funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n> [] '[{\"<channel_address>\":0.02}]')\n>\n> ** Node B and C sends Node A their PSBTs*\n>\n> ** Node A joins all the PSBTs* (bitcoin-cli joinpsbts\n> '[\"<A_funded_channel_psbt>\", \"<B_funded_channel_psbt>\",\n> \"<C_funded_channel_psbt>\"]')\n>\n> Using (bitcoin-cli walletprocesspsbt <joined_psbt>):\n>\n>\n>\n> ** Node A verifies and signs the PSBT and sends it to Node B (1/3\n> signatures)* Node B verifies and signs the PSBT and sends it to Node C (2/3\n> signatures)* Node C verifies and signs the PSBT (3/3 signatures) before\n> sending it to Node A and B.*\n>\n>\n> ** Node A completes channel open (no_publish)* Node B completes channel\n> open (no_publish)* Node C completes channel open and publishes the\n> transaction.*\n>\n> --\n> Ole Henrik Skogstr\u00f8m\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210922/b4281beb/attachment.html>"
            },
            {
                "author": "Ole Henrik Skogstr\u00f8m",
                "date": "2021-09-25T12:06:21",
                "message_text_only": "Hi Olaoluwa\n\nThank you for your reply!\n\nGood point that channel state is transitory, my thinking was that opening\nbalanced channels simplifies things for new routing nodes, rather than\nhaving to balance them out through fee adjustments when most channels are\nlopsided. But I clearly need to learn more about this.\n\n\n--\nOle Henrik Skogstr\u00f8m\nMobile: (+47) 97 42 74 44\n\n\nOn Thu, Sep 23, 2021 at 1:31 AM Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Hi Ole,\n>\n> It's generally known that one can use out of band transaction construction,\n> and the push_amt feature in the base funding protocol to simulate dual\n> funded channels.\n>\n> The popular 'balanceofsatoshis' tool has a command that packages up the\n> interaction (`open-balanced-channel`) into an easier to use format, IIRC it\n> uses key send to ask a peer if they'll accept one and negotiate some of the\n> params.\n>\n> The one thing you need to take mind of when doing this manually is that by\n> default lnd will only lock the UTXOs allocated for the funding attempt for\n> a\n> few minutes. As a result, you need to make sure the process is finalized\n> during that interval or the UTXOs will be unlocked and you risk\n> accidentally\n> double spending yourself.\n>\n> Lightning Pool also uses this little trick to allows users to purchase\n> channels that are 50/50 balanced, and also purchase channel leases _for_ a\n> third party (called sidecar channels) to help on board them onto Lightning:\n> https://lightning.engineering/posts/2021-05-26-sidecar-channels/. Compared\n> to the above approaches, the process can be automatically batched w/ other\n> channels created in that epoch, and uses traits of the Pool account system\n> to make things atomic.\n>\n> Ultimately, the balanced-ness of a channel is a transitory state (for\n> routing nodes, it's great for on-boarding end-users) and opening channels\n> like these only serves to allow the channel to _start_ in the state. If\n> your\n> fees and channel policies aren't set accordingly, then it's possible that a\n> normal payment or balance flow shifts the channel away from equilibrium\n> shortly after the channel is open.\n>\n> -- Laolu\n>\n> On Tue, Sep 21, 2021 at 10:30 PM Ole Henrik Skogstr\u00f8m <\n> oleskogstrom at gmail.com> wrote:\n>\n>> Hi\n>>\n>> I have found a way of opening balanced channels using LND's psbt option\n>> when opening channels. What I'm doing is essentially just joining funded\n>> PSBTs before signing and submitting them. This makes it possible to open a\n>> balanced channel between two nodes or open a ring of balanced channels\n>> between multiple nodes (ROF).\n>>\n>> I found this interesting, however I don't know if this is somehow unsafe\n>> or for some other reason a bad idea. If not, then it could be an\n>> interesting alternative to only being able to open unbalanced channels.\n>>\n>> To do this efficiently, nodes need to collaborate by sending PSBTs back\n>> and forth to each other and doing this manually is a pain, so if this makes\n>> sense to do, it would be best to automate it through a client.\n>>\n>> ----------------------\n>> --- Here is an example of the complete flow for a single channel:\n>> ----------------------\n>>\n>> ** Node A: generates a new address and sends address to Node B *(lncli\n>> newaddress p2wkh)\n>>\n>> ** Node A starts an Interactive channel **open** to Node B* *using psbt*\n>> (lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n>>\n>> ** Node A funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node B funds the refund transaction to Node A and sends PSBT back to\n>> Node A (*bitcoin-cli walletcreatefundedpsbt []\n>> '[{\"<node_a_return_address>\":0.01}]')\n>>\n>> * *Node A joins the two PSBTs and sends it back to Node B (*bitcoin-cli\n>> joinpsbts '[\"<channel_open_psbt>\", \"<node_b_return_to_node_a_psbt>\"]')\n>>\n>> ** Node B verifies the content and signs the joined PSBT before sending\n>> it back to Node A *(bitcoin-cli walletprocesspsbt <joined_psbt>)\n>>\n>> ** Node A: Verifies the content and signs the joined PSBT *(bitcoin-cli\n>> walletprocesspsbt <joined_psbt>)\n>>\n>> ** Node A: Completes channel open by publishing the fully signed PSBT*\n>>\n>>\n>> ----------------------\n>> --- Here is an example of the complete flow for a ring of channels\n>> between multiple nodes:\n>> ----------------------\n>>\n>> ** Node A starts an Interactive open channel to Node B using psbt*\n>> (lncli openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n>> ** Node A funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node B starts an Interactive open channel to Node C using psbt*\n>> (lncli openchannel --psbt --no_publish <node_b_pubkey> 2000000 1000000)\n>> ** Node B funds the channel address* (bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node C starts an Interactive open channel to Node A using psbt*\n>> (lncli openchannel --psbt <node_b_pubkey> 2000000 1000000)\n>> ** Node C funds the channel address *(bitcoin-cli walletcreatefundedpsbt\n>> [] '[{\"<channel_address>\":0.02}]')\n>>\n>> ** Node B and C sends Node A their PSBTs*\n>>\n>> ** Node A joins all the PSBTs* (bitcoin-cli joinpsbts\n>> '[\"<A_funded_channel_psbt>\", \"<B_funded_channel_psbt>\",\n>> \"<C_funded_channel_psbt>\"]')\n>>\n>> Using (bitcoin-cli walletprocesspsbt <joined_psbt>):\n>>\n>>\n>>\n>> ** Node A verifies and signs the PSBT and sends it to Node B (1/3\n>> signatures)* Node B verifies and signs the PSBT and sends it to Node C (2/3\n>> signatures)* Node C verifies and signs the PSBT (3/3 signatures) before\n>> sending it to Node A and B.*\n>>\n>>\n>> ** Node A completes channel open (no_publish)* Node B completes channel\n>> open (no_publish)* Node C completes channel open and publishes the\n>> transaction.*\n>>\n>> --\n>> Ole Henrik Skogstr\u00f8m\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210925/fb70ffea/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Opening balanced channels using PSBT",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Olaoluwa Osuntokun",
                "Ole Henrik Skogstr\u00f8m"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 23909
        }
    },
    {
        "title": "[Lightning-dev] Dropping Tor v2 onion services from node_announcement",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-09-22T23:03:50",
                "message_text_only": "Earlier this week I was helping a user debug a Tor related issue, and\nrealized (from the logs) that some newer Tor clients are already refusing to\nconnect out to v2 onion services.\n\nOn the lnd side, I think we'll move to disallow users creating a v2 onion\nservice in our next major release (0.14), and also possibly \"upgrade\" them\nto a v3 onion service if their node supports it. I've made a tracking issue\nhere: https://github.com/lightningnetwork/lnd/issues/5771\n\nI ran a naive script to gauge how much of the network is using Tor\ngenerally, and also v2 onion services extract the following stats:\n```\nnum nodes:  12844\nnum tor:  8793\nnum num v2:  66\nnum num v3:  8777\n```\n\nThis counts advertised addresses total, so it likely over estimates, so you\ncan treat this as an upper bound. Thankfully only 60 or so v2 addresses seem\nto be even _advertised_ on the network, so I don't think this'll cause much\ndisruption.\n\nAnother interesting tidbit here is that: _over half_ of all advertised\naddresses on the network today are onion services. I wonder how the rise of\nonion service usage (many nodes being tor-only) has affected: e2e payment\nlatency, general connection stability, and gossip announcement propagation.\n\nIn terms of actions we need to take at the spec level, it's likely enough to\namend the section on addrs in the node_announcement message to advise\nimplementations to _ignore_ the v2 addr type.\n\n-- Laolu\n\nOn Tue, Jun 1, 2021 at 3:19 PM darosior via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> It's been almost 9 months since Tor v2 hidden services have been\n> deprecated.\n> The Tor project will drop v2 support in about a month in the latest\n> release. It will then be entirely be dropped from all supported releases by\n> October.\n> More at https://blog.torproject.org/v2-deprecation-timeline .\n>\n> Bitcoin Core defaults to v3 since 0.21.0 (\n> https://bitcoincore.org/en/releases/0.21.0/) and is planning to drop the\n> v2 support for 0.22 (https://github.com/bitcoin/bitcoin/pull/22050),\n> which means that v2 onions will gradually stop being gossiped on the\n> Bitcoin network.\n>\n> I think we should do the same for the Lightning network, and the timeline\n> is rather tight. Also, the configuration is user-facing (as opposed to\n> Bitcoin Core, which generates ephemeral services) which i expect to make\n> the transition trickier.\n> C-lightning is deprecating the configuration of Tor v2 services starting\n> next release, according to our deprecation policy we should be able to\n> entirely drop its support 3 releases after this one, which should be not so\n> far from the October deadline.\n>\n> Opinions? What is the state of other implementations with regard to Tor v2\n> support?\n>\n> Antoine\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210922/9352fa8b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Dropping Tor v2 onion services from node_announcement",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3122
        }
    },
    {
        "title": "[Lightning-dev] Theory: Proofs of Payment are Signatures",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-24T02:10:14",
                "message_text_only": "Introduction\n============\n\nLightning provides proof-of-payment for standard forms of payment, but does not provide it for keysend or non-high hash-based AMP.\n\nLet us consider, then, what exactly a proof-of-payment even *is*.\n\nLamport Signatures\n==================\n\nOne of the earliest cryptographic digital signing schemes is the Lamport Signature Scheme.\n\nWith Lamport signatures, you need to define:\n\n* A trapdoor/one-way hash function, which has output bits `n`.\n* A number of bits in the message, `m`.\n\nThen, to generate a private key:\n\n* Generate 2 * `m` random `n`-bit numbers, which are preimages.\n\nThen, to derive a public key from the private key:\n\n* Hash the above 2 * `m` preimages.\n\nTo sign a message:\n\n* For each bit `b` of the message:\n  * If the bit is clear, send the `b` * 2 + 0 preimage (this is 0-indexed, by the way).\n  * If the bit is set, send the `b` * 2 + 1 preimage.\n\nTo validate, simply check that the received preimage hashes to the corresponding hash in the public key.\n\nHash-based Lightning Payments\n=============================\n\nIn current Lightning, a BOLT11 invoice provides a single hash.\nThen the payer creates an outgoing HTLC, which is transported over the network and reaches the payee, who then provides the preimage to that hash.\n\n>From a certain point of view, one can consider that the preimage revelation is a Lamport signature with a 0-bit message.\nInstead of signing a message, it is the *existence* of a signature that matters, and that is what proof-of-payment is.\nIn that degenerate case of a 0-bit message, a preimage and its hash can serve as a Lamport signature.\n\nA BOLT11 invoice is signed with ECDSA secp256k1.\nOne can consider that the hash embedded in the BOLT11 invoice is a delegated key, and that the BOLT11 mechanism is really a key delegation mechanism.\nThe payee signs the BOLT11 invoice using ECDSA secp256k1 using its node id as pubkey, specifying a 0-bit Lamport public key (the hash in the BOLT11), and delegating responsibility for that particular invoice to that key.\nThen, when the payee (or its representative on the network) gets paid, it signs the Lamport signature using the delegated key by revealing the preimage.\n\n>From this point-of-view, as well, keysend and base AMP do provide a proof-of-payment, it is just the proof-of-payment is the \"wrong\" direction: the payee gets a proof-of-payment that it got paid, as it is provided the public key (the hash) and the preimage (the 0-bit Lamport signature).\nThe payee gets proof that it got paid, but typically we expect that people will charge (i.e. demand to get paid) for their autographs, so a payee getting a signature from the payer does not quite fit the expected economics.\n\nA Scheme For Point-based Payments?\n==================================\n\nGiven the above idea, would it be useful to consider that a PTLC-based LN should explicitly use Schnorr signatures for proof-of-payment?\n\nSchnorr signatures are `(R, s)`, and once `R` has been established, we do know that we can implement a pay-for-signature to acquire the `s` using PTLCs, which can be transported across the network.\n\n>From this point of view, then, proof-of-payments are signatures `(R, s)`, with `s` being acquired using PTLCs over the network.\nWhat is needed then is to somehow transport `R`.\n\nFor example, a PTLC-based invoice scheme might commit to a specific `R` in the invoice.\nThen the public key is \"really\" the payee node public key, *and* this specific `R`, which forms a one-time signature scheme (as reuse of `R` is unsafe).\nThis is similar to the current BOLT11 scheme in that the hash is \"really\" a 0-bit Lamport public key, which is similarly one-time-use.\nThen the invoice represents a delegation of the node public key to the augmented node id + `R` public key.\n\nAdditionally, we may provide a mechanism to request for an `R` from the payee, together with a message to be signed.\nThe payee may then use some determinstic `R` generation scheme to provide `R` to the payer.\n\n*How* these mechanisms might actually be *used*, I am significantly less certain about, but perhaps application developers on top of Lightning may have some ideas that can be shoehorned into this.\n\nAt its minimum, even a simple scalar-behind-this-point PTLC payment scheme could still work for proof-of-payment, as the function `f(x) = x * G` is a perfectly fine trapdoor function for the purposes of Lamport signing, so there is no real need to have \"full\" signatures as the basic mechanism in a PTLC-based Lightning Network.\n\nForwarding nodes, of course, need not know about this, but we do need to consider whether support for this would be useful at the payer and payee, and in our APIs exposed to applications built on top of Lightning."
            }
        ],
        "thread_summary": {
            "title": "Theory: Proofs of Payment are Signatures",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4725
        }
    },
    {
        "title": "[Lightning-dev] Ask First, Shoot (PTLC/HTLC) Later",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-09-29T03:40:01",
                "message_text_only": "Good morning list,\n\nWhile discussing something tangentially related with aj, I wondered this:\n\n> Why do we shoot an HTLC first and then ask the question \"can you actually resolve this?\" later?\n\nWhy not something like this instead?\n\n* For a payer:\n  * Generate a path.\n  * Ask first hop if it can resolve an HTLC with those specs (passing the encrypted onion).\n  * If first hop says \"yes\", actually do the `update_add_htlc` dance.\n    Otherwise try again.\n* For a forwarder:\n  * If anybody asks \"can you resolve this path\" (getting an encrypted onion):\n    * Decrypt one layer to learn the next hop.\n    * Check if the next hop is alive and we have the capacity towards it, if not, answer no.\n    * Ask next hop if it can resolve the next onion layer.\n    * Return the response from the next hop.\n* For a payee:\n  * If anybody asks \"can you resolve this path\":\n    * If it is not a multipart and we have the preimage, say yes.\n    * If it is a multipart and we have the preimage, wait for all the parts to arrive, then say yes to all of them.\n    * Otherwise say no.\n\nNow, the most obvious reason against this, that comes to mind, is that this is a potential DoS vector.\nRandom node can trigger a lot of network activity by asking random stuff of random nodes.\nAsking the question is free, after all.\n\nHowever, we should note that sending *actual* HTLCs is a similar DoS vector **today**.\nThis is still \"free\" in that the asker has no need to pay fees for failed HTLCs; they just lose the opportunity cost of the amount being locked up in the HTLCs.\nAnd presumably the opportunity cost is low since Lightning forwarding earnings are so tiny.\n\nOne way to mitigate against this is to make generating an onion costly but validating and decrypting it cheap.\nWe could use an encryption scheme that is more computationally expensive to encrypt but cheap to decrypt, for example.\nOr we could require proof-of-work on the onion: each unwrapped onion layer, when hashed, has to have a hash that is less than some threshold (this scales according to the number of hops in the onion, as well).\nUltimate askers need to grind the shared secret until the onion layer hash achieves the target.\n\nObviously just because you asked a few milliseconds ago if a path is viable does not mean that the path *remains* viable right now when you actually send out an HTLC, but presumably that risk is now lessened.\nUnexpected shutdowns or loss of connectivity has to appear in a smaller and shorter time frame to negatively affect intermediate nodes.\n\nAnother thought is: Does the forwarding node have an incentive to lie?\nSuppose the next hop is alive but the forwarding node has insufficient capacity towards the next hop.\nThen the forwarding node can lie and claim it can still resolve the HTLC, in the hope that a few milliseconds later, when the actual HTLC arrives, the capacity towards the next hop has changed.\nThus, even if the capacity now is insufficient, the forwarding node has an incentive to lie and claim sufficient capacity.\n\nAgainst the above, we can mitigate this by accepting \"no\" from *any* node along the path, but only accepting \"yes\" from the actual payee.\nWe already have a mechanism where any node along a route can report a forwarding or other payment error, and the sender is able to identify which node along the path raised it.\nThus, the payer can identify which node along the route responded with a \"yes\", and check that it definitely reached the payee.\nPresumably, when a node receives a question, it checks if the asking node has sufficient capacity towards it first, and if not, fails the channel between them, since obviously the asking node is not behaving according to protocol and is buggy.\n\nNow, this can be used to probe capacities, for free, but again --- we already *have* probing capacities, for free, today, by just using random hashes.\n\n\n\nWhy is this advantageous at all?\n\nOne reason for doing this is that it improves payment latency.\nSome paths *will* fail, because there is no single consistent view of the network and its capacity (which is impossible due to others also possibly sending out via the same forwarding nodes you are using, and besides, even if such a view could be made to exist, it would be dangerously anti-privacy).\nThis mechanism does not require that intermediate nodes respond with a signature and wait for a replied signature *before* they forward the onion to the next hop; when they are *just* asking, there is no HTLC involved, no updates to the channel state, and the question can be forwarded as soon as we can check locally.\nFurther, in the current mechanism where we shoot HTLCs first and ask questions later, failures also require 1.5 roundtrips due to sharing signatures; with the \"just ask first\" phase there is no need for round trips to respond to questions.\n\nBasically, we replace multiple round trips per hop in case of a failure along a route, with a single large round trip from the payer to the failure point.\nIn case of a success we just add more latency, but as we move to more multipath payments, perhaps it becomes more advantageous, since the probability of a particular sub-path failing is now higher?\n\nMore importantly, by allowing to ask first, we reduce the probability that HTLCs made in good faith --- i.e. those that are fully intended to reach a destination and be resolved --- it may now be more palatable to charge for failing actual HTLCs.\nSince we expect that HTLC failures due to a node or channel failing along the way is lessened compared to today, because the sender *asks* first before *shooting* the HTLC, then the effect of charging for failing *actual* HTLCs is lessened, possibly to a more acceptable level.\n\n\nSo, to lightning-dev --- is this a decent idea at all?\nNote that in particular this is something that requires a whole-network upgrade, as intermediate nodes have to upgrade as well.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Ask First, Shoot (PTLC/HTLC) Later",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5899
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev]  Removing the Dust Limit",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2021-09-30T22:07:08",
                "message_text_only": "Jumping in late to this thread.\n\nI very much agree with how David Harding presents things, with a few comments inline.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, August 8th, 2021 at 5:51 PM, David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > 1.  it's not our business what outputs people want to create\n>\n> Every additional output added to the UTXO set increases the amount of\n> work full nodes need to do to validate new transactions. For miners\n> for whom fast validation of new blocks can significantly affect their\n> revenue, larger UTXO sets increase their costs and so contributes\n> towards centralization of mining.\n> Allowing 0-value or 1-sat outputs minimizes the cost for polluting the\n> UTXO set during periods of low feerates.\n> If your stuff is going to slow down my node and possibly reduce my\n> censorship resistance, how is that not my business?\n\nIndeed - UTXO set size is an externality that unfortunately Bitcoin's consensus rules fail to account\nfor. Having a relay policy that avoids at the very least economically irrational behavior makes\nperfect sense to me.\n\nIt's also not obvious how consensus rules could deal with this, as you don't want consensus rules\nwith hardcoded prices/feerates. There are possibilities with designs like transactions getting\na size/weight bonus/penalty, but that's both very hardforky, and hard to get right without\nintroducing bad incentives.\n\n> > 2.  dust outputs can be used in various authentication/delegation smart\n> >     contracts\n>\n> > 3.  dust sized htlcs in lightning (\n> >     https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)\n> >     force channels to operate in a semi-trusted mode\n>\n> > 4.  thinly divisible colored coin protocols might make use of sats as value\n> >     markers for transactions.\n\nMy personal, and possibly controversial, opinion is that colored coin protocols have no business being on the Bitcoin chain, possibly\nbeyond committing to an occasional batched state update or so. Both because there is little benefit for tokens with a trusted\nissuer already, and because it competes with using Bitcoin for BTC - the token that pays for its security (at least as long as\nthe subsidy doesn't run out).\n\nOf course, personal opinions are no reason to dictate what people should or can use the chain for, but I do think it's reason to\nvoice hesitancy to worsening the system's scalability properties only to benefit what I consider misguided use.\n\n> > 5.  should we ever do confidential transactions we can't prevent it without\n> >     compromising privacy / allowed transfers\n>\n> I'm not an expert, but it seems to me that you can do that with range\n> proofs. The range proof for >dust doesn't need to become part of the\n> block chain, it can be relay only.\n\nYeah, range proofs have a non-hidden range; the lower bound can be nonzero, which could be required as part of a relay policy.\n\nCheers,\n\n--\nPieter"
            }
        ],
        "thread_summary": {
            "title": "Removing the Dust Limit",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3001
        }
    }
]