[
    {
        "title": "[Lightning-dev] Fee-free rebalancing to support JIT-routing",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-03T06:09:31",
                "message_text_only": "Good morning list,\n\nAs it happens, I was considering about JIT-routing by Rene Pickhardt.\nAnd I notice that Rene has been proposing about a \"fee-free rebalance\" in order to better support JIT-routing.\nAnd I have been thinking about this \"fee-free rebalance\" proposal.\n\nAs a review, JIT-routing allows a sort of \"semi-local multipart payment\".\nThe intuition is, that a forwarding node has better information about local channel balances, than the source node has information about remote channel balances along the route.\nWhat JIT-routing means, more specifically, is to perform channel rebalance operations \"just-in-time\" for a forwarding request.\nThe forwarding node, knows exactly the balances in its channels, and thus can determine how best to deliver the required funds to the next hop in the onion.\n\nSo I considered, the simplest case of useful JIT-routing.\nSpecifically, suppose that there exist three nodes on the network, forming a tiny cyclic superhub of three members.\nLet us call them ZmnSCPxj, YAijbOJA, and Rene.\nLet us suppose that they all have channels to each other, of total capacity 0.1 BTC, and with each channel perfectly balanced at 0.05 BTC to each side.\nLet us suppose there is a channel reserve of 0.01 BTC for each channel.\n\nSuppose ZmnSCPxj receives a forwarding request, with the next hop being 0.06BTC to YAijbOJA.\nAs the useable capacity (minus channel reserve) is only 0.04BTC, ZmnSCPxj cannot facilitate this forwarding request.\n\nUnder JIT-Routing, what ZmnSCPxj does, is to route 0.02 BTC from ZmnSCPxj->Rene->YAijbOJA->ZmnSCPxj, i.e. a rebalance of capacity from the ZmnSCPxj<->Rene channel, to the ZmnSCPxj<->YAijbOJA channel.\nBut under the current network, this would require a fee for this rebalancing attempt.\n\nNow, ZmnSCPxj could argue with YAijbOJA and show the forwarding request of 0.06 BTC to YAijbOJA.\nAs YAijbOJA also knows the current state of the ZmnSCPxj<->YAijbOJA channel, it knows this forwarding request cannot push through currently, unless the rebalance completes.\nThis is sufficient to convince YAijbOJA to waive its fee for transporting from the Rene<->YAijbOJA channel to the ZmnSCPxj<->YAijbOJA channel, since otherwise it would not gain the fee (or final payment if it is the payment termination point) for the ZmnSCPxj->YAijbOJA forward.\n\nHowever, Rene cannot be so convinced.\nAfter all, both ZmnSCPxj and YAijbOJA are strangely-named nodes, unlike Rene whose name is actually pronounceable.\nIn particular, the forwarding packet cannot even be read by Rene; and in any case, why should Rene waive the fee when it cannot benefit by doing so?\nYAijbOJA can benefit since by enabling the forward request from ZmnSCPxj->YAijbOJA, it could gain an even larger fee from forwarding onwards (assuming the same base fee, and a proportional fee, the larger forwarding from ZmnSCPxj->YAijbOJA of 0.06 BTC will lead to a larger proportional fee compared to the YAijbOJA->ZmnSCPxj forward of 0.02 BTC).\n\nThus, it seems to me that we can argue for a fee-free forwarding, but only for the last hop in the rebalance.\n\nNow, in particular, note that YAijbOJA should only be willing to waive the fee, if ZmnSCPxj will actually hand it a 0.06 BTC HTLC for ZmnSCPxj->YAijbOJA, in exchange for resolving the 0.02 BTC HTLC for YAijbOJA->ZmnSCPxj.\n\nSo I propose the following constructions below for this.\n\nWe need an HTLC-dependent HTLC construction.\nWhat this means is, that YAijbOJA will offer a construction, which requires that ZmnSCPxj reveals a preimage.\nOnchain, when ZmnSCPxj reveals this preimage, it is forced to claim this into an HTLC, which represents the original forwarding attempt from ZmnSCPxj->YAijbOJA.\nThis is needed to assure YAijbOJA that it will have an opportunity to earn fees later if it waives the fee for forwarding to ZmnSCPxj first.\n\nSo let us be more precise, and say:\n\n    orig_preimage = preimage for the original 0.06BTC forwarding from ZmnSCPxj->YAijbOJA.\n    orig_hash = h(orig_preimage)\n    rebal_preimage = preimage for the rebalance from ZmnSCPxj->Rene->YAijbOJA->ZmnSCPxj.\n    rebal_hash = h(rebal_preimage)\n\n1.  When the rebalance onion reaches YAijbOJA from Rene, YAijbOJA opens the onion packet.\n    Included in this packet is a short note from ZmnSCPxj explaining that there is an \"original onion\" that would forward 0.06 BTC to YAijbOJA, but given the current channel state, ZmnSCPxj cannot forward it unless this rebalance pushes through, so can YAijbOJA waive its fee?\n\n2.  Then, YAijbOJA requests for the original onion from ZmnSCPxj.\n    This is safe for ZmnSCPxj to send, since there is no HTLC from ZmnSCPxj->YAijbOJA yet.\n    YAijbOJA is not incentivized to forward this yet since it has no incoming HTLC, meaning it would lose money if it forwarded it immediately.\n\n3.  YAijbOJA validates the original onion.\n    If it decrypts correctly, and forwards with sufficient fee from ZmnSCPxj to YAijbOJA so that it beats the fee it is being asked to waive, or if YAijbOJA is the final payee, then it allows to continue the protocol.\n\n4.  YAijbOJA and ZmnSCPxj agree to create a 0.06 BTC output on both commitment transactions to the below SCRIPT.\n    0.02 BTC is gotten from YAijbOJA main output, and 0.04 BTC from ZmnSCPxj main output, to funds this contract.\n\n    OP_DUP OP_HASH160 <RIPEMD(SHA256(revocationpubkey))> OP_EQUAL\n    OP_IF\n      OP_CHECKSIG\n    OP_ELSE\n      OP_SIZE 32 OP_EQUAL\n      OP_IF\n          # hash branch\n          OP_HASH160 <RIPEMD(rebal_hash)> OP_EQUALVERIFY\n      OP_ELSE\n          # timelock branch\n          OP_DROP\n          <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP\n      OP_ENDIF\n      2 <ZmnSCPxj_htlcpubkey> <YAijbOJA_htlcpubkey> 2 OP_CHECKMULTISIG\n    OP_ENDIF\n\n5.  Note that the commitment transactions **cannot** be signed **yet**!\n    Both YAijbOJA first need to exchange signatures for two special transactions, HTLC-waivefee-timeout and HTLC-waivefee-success.\n\n6.  HTLC-waivefee-timeout takes the above output and spends it using the timelock branch.\n    Its `nLockTime` is thus equal to `cltv_expiry`.\n    Its witness is `<ZmnSCPxj_waivefee_timeout_signature> <YAijbOJA_waivefee_timeout_signature> 0`.\n    There are two versions, depending on which commitment transaction (that of ZmnSCPxj, or that of YAijbOJA) is being spent from.\n    Signatures for both versions must be exchanged.\n    It has two outputs, 0.04 going to ZmnSCPxj (revocable if from ZmnSCPxj commitment) and 0.02 going to YAijbOJA (revocable if from YAijbOJA commitment).\n\n7.  HTLC-waivefee-success takes te above output and spends it using the hash branch.\n    Its witness is `<ZmnSCPxj_waivefee_success_signature> <YAijbOJA_waivefee_success_signature> <rebal_preimage>`.\n    Again two version depending on which commitment transaction is spent.\n    Signatures for both versions must be exchanged.\n    It pays out to a single output, with script \"Offered HTLC Outputs\" / \"Received HTLC Outputs\" in existing BOLT#3, using the `orig_hash` as the `payment_hash`.\n\n8.  After exchanging the signatures for the above transactions, ZmnSCPxj and YAijbOJA can now exchange signatures for the commitment transactions as usual using `commitment_signed`, then `revoke_and_ack`.\n\n9.  When ZmnSCPxj fulfills the rebalancing HTLC, this puts the `orig_hash` HTLCs directly into the commitment transactions.\n    This lets YAijbOJA claim the rebaancing HTLC from Rene, and forward normally onwards.\n    If the `orig_hash` payment is later failed, then the entire 0.06 BTC amount is returned to ZmnSCPxj, since it has already transferred 0.02 BTC from its ZmnSCPxj<->Rene channel.\n\n--\n\nAnother observation I make, is the consideration of the use of Channel Factories.\n\nIn particular, JIT-routing can instead use a factory-level operation to reorganize channel funds.\n\nZmnSCPxj can request a factory channel reorganization to move some funds from the ZmnSCPxj<->Rene channel to the ZmnSCPxj<->YAijbOJA channel.\nThis has the same effect, i.e. it allows a forwarding attempt to push through, that would not be possible without the factory-level channel reorganization.\n\nFurther, assuming only ZmnSCPxj, YAijbOJA, and Rene are in the channel factory, then it is the same: all three need to be online in order for the JIT-routing to work.\n\nBut I observed above that, in a channel rebalance using current channels (without factories) Rene cannot be convinced to waive the fee.\n\nThis points to the next observation:\n\n1.  Channel rebalances really should be free, as we might imagine channel factory reorganizations to be.\n\n    OR\n\n2.  Factory-level channel reorganizations should charge a fee, paid by nodes that want to remove capacity, to the nodes whose channel is reduced by the removed capacity.\n    i.e. in the Channel Factory case, the factory-level channel reorganization should make Rene demand a fee from ZmnSCPxj in exchange for agreeing to the reorganization, because of the loss of capacity in the ZmnSCPxj<->Rene channel.\n\n\nI suspect the second is true: the reduced capacity in the ZmnSCPxj<->Rene channel means that ZmnSCPxj is less likely to successfully route to Rene, due to the reduce capacity to Rene.\nThus, Rene may be disincentivized to allow the transfer of capacity *away* from ZmnSCPxj<->Rene channel without recompense.\n\n--\n\nAnother thought is the below.\n\nSuppose that in fact, YAijbOJA thinks that the capacity of the ZmnSCPxj<->YAijbOJA channel is too high on the YAijbOJA side.\nAnd similarly, suppose Rene thinks the capacity of the Rene<->YAijbOJA channel is too high on the Rene side.\n\nThus, both YAijbOJA and Rene would welcome the ZmnSCPxj proposal to rebalance, as it moves the capacities.\nIt may be that they are so welcoming of this proposal, that they are willing to waive the fee for the rebalance.\n\nI observe that many have already proposed \"negative routing fees\" in order to support rebalancing of their channels.\nI also observe that routing fees are the cost used in pathfinding algorithms, and most pathfinding algorithms do not behave well with negative costs.\n\nBut it is perfectly fine to use ***zero*** routing fees, I think.\nFor those pathfinding algorithms that require nonzero cost, it is often easy to add a very tiny minimal cost to edges that have 0 cost.\nIndeed, this is often practical to add a tiny cost to every edge traversed, whether the edge is nominally 0-cost or not.\nFor example, C-Lightning does this, since routes with the same fees are not equal if one route has more nodes --- more nodes are less likely to succeed in routing.\n\nSo our software today, should in practice already be quite fine with handling 0 routing fees, if the node wishes to rebalance its channel.\n\nI also observe, from a skim of BOLT #7, the spec does ***NOT*** have any verbiage to the effect \"`fee_base_msat` MUST be non-zero\" or \"`fee_proportional_millionths` MUST be non-zero\".\nThus our spec implicitly allows, by not specifying otherwise, 0 routing fees, already, today.\n\nThus I think we can fix multiple problems with one solution ---\n\n* Instead of ***negative*** routing fees, use ***zero*** routing fees if a channel has too much capacity on our side.\n* Such ***zero*** routing fees also implicitly implement fee-free rebalancing, to support JIT-routing.\n\nThis requires ***no spec change***, which is a tremendously good property that JIT-routing has.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Fee-free rebalancing to support JIT-routing",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 11288
        }
    },
    {
        "title": "[Lightning-dev] Proposal: Lightning Pre-Image Encryption Standard",
        "thread_messages": [
            {
                "author": "Alexander Leishman",
                "date": "2019-07-04T22:17:41",
                "message_text_only": "Nadav,\n\nThis is an interesting proposal, but because this still requires the\ncustomer to trust the merchant, I am concerned that it adds complexity\nwithout any meaningful guarantee to the customer. Perhaps it makes sense to\nat least include some extension field here that allows the merchant to\ninclude a ZKP for ZKCP-compatible data transfers? However, there are a number\nof limitations <http://stevengoldfeder.com/papers/ZKCSP.pdf> to consider\nwith those.\n\nMy two cents, is that the proposed standard would only be useful for the\nedge case where a customer wants to pre-download the data before paying,\nbut still trusts the merchant. What's the main use you see for that? My gut\ntells me there's a higher-level abstraction here to be standardized that\nwould handle more mainstream use-cases.\n\nZmnSCPxj,\n\n> Putting MAC inside the encryption would help ensure that we can detect\ndata replacement over insecure channel, and use of shared secret ensures\nonly intended recipient can decrypt.\n\nGenerally you want to MAC the ciphertext + IV, otherwise you lose\nciphertext integrity guarantees. Why do you want to MAC, then encrypt?\n\n-Alex\n\n\nOn Wed, Jun 26, 2019 at 4:55 PM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Nadav et al.,\n>\n> > > Any node on the route of the payment knows the preimage and can\n> decrypt the data. It would be nice to tune the protocol in a way that only\n> the buyer can decrypt the data. For example we could use something like\n> this:\n> >\n> > Is this not covered by sending over the pre-image encrypted data over a\n> secure channel such as HTTPS? If anyone along the route who learns the\n> pre-image does intercept the message with the encrypted data, that data\n> will already be encrypted for the intended recipient right?\n>\n> True, but the added protection allows sending the option of sending data\n> over a non-secure channel.\n> In particular, a secure channel like HTTPS would impose an\n> encryption/decryption overhead, and then you will *also* encrypt/decrypt at\n> the application layer i.e. you are encrypting twice.\n> If you have the choice of using an insecure channel, you could take that\n> and only have the encrypt/decrypt overhead only for the preimage-encrypted\n> data.\n>\n> i.e. with this, you have the option of sending over both secure and\n> insecure channels.\n> It does not hinder use of secure channel, but enables use of insecure\n> channel.\n> Putting MAC inside the encryption would help ensure that we can detect\n> data replacement over insecure channel, and use of shared secret ensures\n> only intended recipient can decrypt.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190704/1713b5d3/attachment.html>"
            },
            {
                "author": "Chris Stewart",
                "date": "2019-07-05T00:37:19",
                "message_text_only": "Hey Alex,\n\nI think the benefit here is in reducing the client-server interaction for\nREST apis while still ensuring payment to the merchant.\n\nLet's assume that we don't have this scheme, and want to provide a\nmonetized REST API. The workflow looks like this, which is similar to what\nour behavior is now at Suredbits with websockets\n<https://suredbits.com/ws-playground/>.\n\n1. Client sends request to server for invoice\n2. Server returns invoice\n3. Client pays invoice\n4. Server sends data back, or client makes request _again_ to a server and\nthen server returns data\n\nWith Nadav's scheme this is simplified to\n\n1. Client sends request to server\n2. Serves returns invoice, and encrypted payload\n3. Client pays invoice\n4. Client decrypts data according to Nadav's scheme\n\nThis saves a round trip between the server and client. It also gives\natomicity to the transaction, although as you stated before there is no\nguarantees about integrity of the encrypted data. This is generally a hard\nproblem to solve in the technical sense, but I think the reputational harm\nof the server sending bad data will be enough to prevent this, who wants to\ndo business with some one that isn't providing the advertised service? This\nis a interaction that is could be repeated thousands of times on a daily\nbasis.\n\n-Chris\n\nOn Thu, Jul 4, 2019 at 5:18 PM Alexander Leishman <leishman3 at gmail.com>\nwrote:\n\n> Nadav,\n>\n> This is an interesting proposal, but because this still requires the\n> customer to trust the merchant, I am concerned that it adds complexity\n> without any meaningful guarantee to the customer. Perhaps it makes sense to\n> at least include some extension field here that allows the merchant to\n> include a ZKP for ZKCP-compatible data transfers? However, there are a number\n> of limitations <http://stevengoldfeder.com/papers/ZKCSP.pdf> to consider\n> with those.\n>\n> My two cents, is that the proposed standard would only be useful for the\n> edge case where a customer wants to pre-download the data before paying,\n> but still trusts the merchant. What's the main use you see for that? My gut\n> tells me there's a higher-level abstraction here to be standardized that\n> would handle more mainstream use-cases.\n>\n> ZmnSCPxj,\n>\n> > Putting MAC inside the encryption would help ensure that we can detect\n> data replacement over insecure channel, and use of shared secret ensures\n> only intended recipient can decrypt.\n>\n> Generally you want to MAC the ciphertext + IV, otherwise you lose\n> ciphertext integrity guarantees. Why do you want to MAC, then encrypt?\n>\n> -Alex\n>\n>\n> On Wed, Jun 26, 2019 at 4:55 PM ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Good morning Nadav et al.,\n>>\n>> > > Any node on the route of the payment knows the preimage and can\n>> decrypt the data. It would be nice to tune the protocol in a way that only\n>> the buyer can decrypt the data. For example we could use something like\n>> this:\n>> >\n>> > Is this not covered by sending over the pre-image encrypted data over a\n>> secure channel such as HTTPS? If anyone along the route who learns the\n>> pre-image does intercept the message with the encrypted data, that data\n>> will already be encrypted for the intended recipient right?\n>>\n>> True, but the added protection allows sending the option of sending data\n>> over a non-secure channel.\n>> In particular, a secure channel like HTTPS would impose an\n>> encryption/decryption overhead, and then you will *also* encrypt/decrypt at\n>> the application layer i.e. you are encrypting twice.\n>> If you have the choice of using an insecure channel, you could take that\n>> and only have the encrypt/decrypt overhead only for the preimage-encrypted\n>> data.\n>>\n>> i.e. with this, you have the option of sending over both secure and\n>> insecure channels.\n>> It does not hinder use of secure channel, but enables use of insecure\n>> channel.\n>> Putting MAC inside the encryption would help ensure that we can detect\n>> data replacement over insecure channel, and use of shared secret ensures\n>> only intended recipient can decrypt.\n>>\n>> Regards,\n>> ZmnSCPxj\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190704/f54ee691/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-05T03:36:37",
                "message_text_only": "Good morning Alexander,\n\n> > > Putting MAC inside the encryption would help ensure that we can detect data replacement over insecure channel, and use of shared secret ensures only intended recipient can decrypt.\n> >\n> > Generally you want to MAC the ciphertext + IV, otherwise you lose ciphertext integrity guarantees. Why do you want to MAC, then encrypt?\n\nIt is possible I simply misunderstand the proper use of MAC, so I shall research it in more depth.\n\n\n> I think the benefit here is in reducing the client-server interaction for REST apis while still ensuring payment to the merchant.\u00a0\n>\n> Let's assume that we don't have this scheme, and want to provide a monetized REST API. The workflow looks like this, which is similar to what our behavior is now at Suredbits with websockets.\n>\n> 1. Client sends request to server for invoice\n> 2. Server returns invoice\n> 3. Client pays invoice\n> 4. Server sends data back, or client makes request _again_ to a server and then server returns data\n>\n> With Nadav's scheme this is simplified to\n>\n> 1. Client sends request to server\n> 2. Serves returns invoice, and encrypted payload\n> 3. Client pays invoice\n> 4. Client decrypts data according to Nadav's scheme\n>\n> This saves a round trip between the server and client. It also gives atomicity to the transaction, although as you stated before there is no guarantees about integrity of the encrypted data. This is generally a hard problem to solve in the technical sense, but I think the reputational harm of the server sending bad data will be enough to prevent this, who wants to do business with some one that isn't providing the advertised service? This is a interaction that is could be repeated thousands of times on a daily basis.\n\nA client can easily DoS the server by requesting and requesting (thus convincing the server to encrypt and send data immediately) and never paying.\nWhereas the first would require more resources on the client side, as the server does not encrypt (or never encrypts at all) until the client has shown proof-of-payment.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Alexander Leishman",
                "date": "2019-07-05T17:34:19",
                "message_text_only": "Chris,\n\nThanks for that explanation. I could see how this makes sense for\nlightweight data payloads because it reduces the round trip count, but I\nagree with ZmnSCPxj that this could pose a DoS risk for larger data\npayloads. This DoS risk is even more magnified for ZKCPs.\n\nI would guess that APIs selling data for lightning payments might take\ndifferent approaches:\n\n1. You could purchase an auth token upfront that allows you access for some\namount of time of some number of requests (seems to be the most efficient\nfor APIs that would be called more than once)\n2. You could pay per request (good for when you would want 1 big blob of\ndata)\n\nSo for the case where a customer is calling the API multiple times per day,\nwouldn't it make more sense to pay upfront for future requests?\n\nBest,\nAlex\n\nBest,\nAlex\n\n\n\nOn Thu, Jul 4, 2019 at 8:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Alexander,\n>\n> > > > Putting MAC inside the encryption would help ensure that we can\n> detect data replacement over insecure channel, and use of shared secret\n> ensures only intended recipient can decrypt.\n> > >\n> > > Generally you want to MAC the ciphertext + IV, otherwise you lose\n> ciphertext integrity guarantees. Why do you want to MAC, then encrypt?\n>\n> It is possible I simply misunderstand the proper use of MAC, so I shall\n> research it in more depth.\n>\n>\n> > I think the benefit here is in reducing the client-server interaction\n> for REST apis while still ensuring payment to the merchant.\n> >\n> > Let's assume that we don't have this scheme, and want to provide a\n> monetized REST API. The workflow looks like this, which is similar to what\n> our behavior is now at Suredbits with websockets.\n> >\n> > 1. Client sends request to server for invoice\n> > 2. Server returns invoice\n> > 3. Client pays invoice\n> > 4. Server sends data back, or client makes request _again_ to a server\n> and then server returns data\n> >\n> > With Nadav's scheme this is simplified to\n> >\n> > 1. Client sends request to server\n> > 2. Serves returns invoice, and encrypted payload\n> > 3. Client pays invoice\n> > 4. Client decrypts data according to Nadav's scheme\n> >\n> > This saves a round trip between the server and client. It also gives\n> atomicity to the transaction, although as you stated before there is no\n> guarantees about integrity of the encrypted data. This is generally a hard\n> problem to solve in the technical sense, but I think the reputational harm\n> of the server sending bad data will be enough to prevent this, who wants to\n> do business with some one that isn't providing the advertised service? This\n> is a interaction that is could be repeated thousands of times on a daily\n> basis.\n>\n> A client can easily DoS the server by requesting and requesting (thus\n> convincing the server to encrypt and send data immediately) and never\n> paying.\n> Whereas the first would require more resources on the client side, as the\n> server does not encrypt (or never encrypts at all) until the client has\n> shown proof-of-payment.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190705/0b609eb3/attachment.html>"
            },
            {
                "author": "Chris Stewart",
                "date": "2019-07-08T11:42:19",
                "message_text_only": "> You could purchase an auth token upfront that allows you access for some\namount of time of some number of requests (seems to be the most efficient\nfor APIs that would be called more than once)\n\nThis does have privacy implications. It is yet to be seen how these things\ndevelop, but this obviously allows the server to correlate what sort of\ndata some one is interested in. However on a practical level it may super\neasy to correlate what sort of data people are querying for with normal\nheuristics.\n\nThe other thing is the accounting question, where if a person does not use\nall of their allocated requests within the given time frame. Perhaps you\ncan allow a refund invoice to be provided up front, so the server can\nrefund the user of the API after a set amount of time, but that comes with\nit's own issues.\n\nWe are already making the assumption that someone has a Lightning node\nsetup, I don't see why a user wouldn't leverage that fact to not overpay\nfor services. There could be an argument made for latency sensitive\napplications, but you probably want to go with a dedicated provider with\ncolocation and a more traditional payment system if that is the case.\n\nI agree with David Harding's analysis on DoS issues. This seems like a\npretty solvable engineering problem from the server's perspective in my\nopinion.\n\n-Chris\n\nOn Fri, Jul 5, 2019 at 12:34 PM Alexander Leishman <leishman3 at gmail.com>\nwrote:\n\n> Chris,\n>\n> Thanks for that explanation. I could see how this makes sense for\n> lightweight data payloads because it reduces the round trip count, but I\n> agree with ZmnSCPxj that this could pose a DoS risk for larger data\n> payloads. This DoS risk is even more magnified for ZKCPs.\n>\n> I would guess that APIs selling data for lightning payments might take\n> different approaches:\n>\n> 1. You could purchase an auth token upfront that allows you access for\n> some amount of time of some number of requests (seems to be the most\n> efficient for APIs that would be called more than once)\n> 2. You could pay per request (good for when you would want 1 big blob of\n> data)\n>\n> So for the case where a customer is calling the API multiple times per\n> day, wouldn't it make more sense to pay upfront for future requests?\n>\n> Best,\n> Alex\n>\n> Best,\n> Alex\n>\n>\n>\n> On Thu, Jul 4, 2019 at 8:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Alexander,\n>>\n>> > > > Putting MAC inside the encryption would help ensure that we can\n>> detect data replacement over insecure channel, and use of shared secret\n>> ensures only intended recipient can decrypt.\n>> > >\n>> > > Generally you want to MAC the ciphertext + IV, otherwise you lose\n>> ciphertext integrity guarantees. Why do you want to MAC, then encrypt?\n>>\n>> It is possible I simply misunderstand the proper use of MAC, so I shall\n>> research it in more depth.\n>>\n>>\n>> > I think the benefit here is in reducing the client-server interaction\n>> for REST apis while still ensuring payment to the merchant.\n>> >\n>> > Let's assume that we don't have this scheme, and want to provide a\n>> monetized REST API. The workflow looks like this, which is similar to what\n>> our behavior is now at Suredbits with websockets.\n>> >\n>> > 1. Client sends request to server for invoice\n>> > 2. Server returns invoice\n>> > 3. Client pays invoice\n>> > 4. Server sends data back, or client makes request _again_ to a server\n>> and then server returns data\n>> >\n>> > With Nadav's scheme this is simplified to\n>> >\n>> > 1. Client sends request to server\n>> > 2. Serves returns invoice, and encrypted payload\n>> > 3. Client pays invoice\n>> > 4. Client decrypts data according to Nadav's scheme\n>> >\n>> > This saves a round trip between the server and client. It also gives\n>> atomicity to the transaction, although as you stated before there is no\n>> guarantees about integrity of the encrypted data. This is generally a hard\n>> problem to solve in the technical sense, but I think the reputational harm\n>> of the server sending bad data will be enough to prevent this, who wants to\n>> do business with some one that isn't providing the advertised service? This\n>> is a interaction that is could be repeated thousands of times on a daily\n>> basis.\n>>\n>> A client can easily DoS the server by requesting and requesting (thus\n>> convincing the server to encrypt and send data immediately) and never\n>> paying.\n>> Whereas the first would require more resources on the client side, as the\n>> server does not encrypt (or never encrypts at all) until the client has\n>> shown proof-of-payment.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190708/0f45dc7b/attachment.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-07-26T15:43:27",
                "message_text_only": "Hey all,\n\nThe following is a link to the documentation for what we've been calling a\n*PAID* (Payment-Atomic Information Decryption) *API*:\nhttps://test.suredbits.com/api/#historical-prices-data-api-2\ndespite what the docs say it is currently only working on testnet, but\nshould be on mainnet within a week. Note, that this API implements the\noriginal proposal and we plan on iterating on this to integrate all of the\ngreat amendments in this thread.\n\nHere is an example client that can be used to query this API and decrypt\nthe returned data once the pre-image has been recovered:\nhttps://github.com/Suredbits/sb-api#jsts-client-library-for-suredbits-apis\n\nBest,\nNadav\n\nOn Mon, Jul 8, 2019 at 6:49 AM Chris Stewart <chris at suredbits.com> wrote:\n\n> > You could purchase an auth token upfront that allows you access for some\n> amount of time of some number of requests (seems to be the most efficient\n> for APIs that would be called more than once)\n>\n> This does have privacy implications. It is yet to be seen how these things\n> develop, but this obviously allows the server to correlate what sort of\n> data some one is interested in. However on a practical level it may super\n> easy to correlate what sort of data people are querying for with normal\n> heuristics.\n>\n> The other thing is the accounting question, where if a person does not use\n> all of their allocated requests within the given time frame. Perhaps you\n> can allow a refund invoice to be provided up front, so the server can\n> refund the user of the API after a set amount of time, but that comes with\n> it's own issues.\n>\n> We are already making the assumption that someone has a Lightning node\n> setup, I don't see why a user wouldn't leverage that fact to not overpay\n> for services. There could be an argument made for latency sensitive\n> applications, but you probably want to go with a dedicated provider with\n> colocation and a more traditional payment system if that is the case.\n>\n> I agree with David Harding's analysis on DoS issues. This seems like a\n> pretty solvable engineering problem from the server's perspective in my\n> opinion.\n>\n> -Chris\n>\n> On Fri, Jul 5, 2019 at 12:34 PM Alexander Leishman <leishman3 at gmail.com>\n> wrote:\n>\n>> Chris,\n>>\n>> Thanks for that explanation. I could see how this makes sense for\n>> lightweight data payloads because it reduces the round trip count, but I\n>> agree with ZmnSCPxj that this could pose a DoS risk for larger data\n>> payloads. This DoS risk is even more magnified for ZKCPs.\n>>\n>> I would guess that APIs selling data for lightning payments might take\n>> different approaches:\n>>\n>> 1. You could purchase an auth token upfront that allows you access for\n>> some amount of time of some number of requests (seems to be the most\n>> efficient for APIs that would be called more than once)\n>> 2. You could pay per request (good for when you would want 1 big blob of\n>> data)\n>>\n>> So for the case where a customer is calling the API multiple times per\n>> day, wouldn't it make more sense to pay upfront for future requests?\n>>\n>> Best,\n>> Alex\n>>\n>> Best,\n>> Alex\n>>\n>>\n>>\n>> On Thu, Jul 4, 2019 at 8:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>\n>>> Good morning Alexander,\n>>>\n>>> > > > Putting MAC inside the encryption would help ensure that we can\n>>> detect data replacement over insecure channel, and use of shared secret\n>>> ensures only intended recipient can decrypt.\n>>> > >\n>>> > > Generally you want to MAC the ciphertext + IV, otherwise you lose\n>>> ciphertext integrity guarantees. Why do you want to MAC, then encrypt?\n>>>\n>>> It is possible I simply misunderstand the proper use of MAC, so I shall\n>>> research it in more depth.\n>>>\n>>>\n>>> > I think the benefit here is in reducing the client-server interaction\n>>> for REST apis while still ensuring payment to the merchant.\n>>> >\n>>> > Let's assume that we don't have this scheme, and want to provide a\n>>> monetized REST API. The workflow looks like this, which is similar to what\n>>> our behavior is now at Suredbits with websockets.\n>>> >\n>>> > 1. Client sends request to server for invoice\n>>> > 2. Server returns invoice\n>>> > 3. Client pays invoice\n>>> > 4. Server sends data back, or client makes request _again_ to a server\n>>> and then server returns data\n>>> >\n>>> > With Nadav's scheme this is simplified to\n>>> >\n>>> > 1. Client sends request to server\n>>> > 2. Serves returns invoice, and encrypted payload\n>>> > 3. Client pays invoice\n>>> > 4. Client decrypts data according to Nadav's scheme\n>>> >\n>>> > This saves a round trip between the server and client. It also gives\n>>> atomicity to the transaction, although as you stated before there is no\n>>> guarantees about integrity of the encrypted data. This is generally a hard\n>>> problem to solve in the technical sense, but I think the reputational harm\n>>> of the server sending bad data will be enough to prevent this, who wants to\n>>> do business with some one that isn't providing the advertised service? This\n>>> is a interaction that is could be repeated thousands of times on a daily\n>>> basis.\n>>>\n>>> A client can easily DoS the server by requesting and requesting (thus\n>>> convincing the server to encrypt and send data immediately) and never\n>>> paying.\n>>> Whereas the first would require more resources on the client side, as\n>>> the server does not encrypt (or never encrypts at all) until the client has\n>>> shown proof-of-payment.\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190726/1fe378e5/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-07-08T09:20:47",
                "message_text_only": "On Fri, Jul 05, 2019 at 03:36:37AM +0000, ZmnSCPxj via Lightning-dev wrote:\n> A client can easily DoS the server by requesting and requesting (thus\n> convincing the server to encrypt and send data immediately) and never\n> paying.\n\nIs this an actual concern?  Assuming this protocol is used with web apps\nfor sites that are available over HTTPS, the client can just request the\norder form page over and over to also waste server CPU encrypting and\nbandwidth transfering (or they could use more clever ways to abuse TLS).\n\nFor the case of a downloaded file, the server can encrypt immediately\nbefore it puts data in the TCP queue so that, if the socket blocks\n(because the client isn't downloading), it only wasted CPU encrypting a\nfew more blocks than were actually delivered.\n\n-Dave"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Lightning Pre-Image Encryption Standard",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Chris Stewart",
                "Nadav Kohen",
                "David A. Harding",
                "Alexander Leishman",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 24402
        }
    },
    {
        "title": "[Lightning-dev] [RELEASE] c-lightning v0.7.1: The Unfailing Twitter Consensus Algorithm",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-07-04T23:58:06",
                "message_text_only": "This is a recommended upgrade!\n\n        https://github.com/ElementsProject/lightning/releases/tag/v0.7.1\n\nWe're pleased to announce c-lightning 0.7.1, named by new C-Lightning\nCore Team member Lisa Neigut.\n\nHighlights for Users\n--------------------\n\no Gossip (both serving to others and listchannels) is much faster and\n   uses much less memory.\no Infrastructure to fund a channel from an external wallet (probably\n   needs a plugin to make it user friendly).\no listpeers now show how many confirms until channel is open.\no Ability to set a minimum channel size to accept.\no Invoices now default to 7 days, rather than 1 hour.\no fundchannel can now specify exactly what utxos to use, if you want\n   coin control.\no Various JSON API corner cases and bugs have been removed, more\n   information added.\no Lots of new plugin hooks to play with; we expect some more impressive\n   plugins soon!\n\nHighlights for the network\n--------------------------\no We no longer ask every peer for all the gossip which ever happened!\no We respect and enforce option_upfront_shutdown_script (mainly for Eclair)\no We no longer allow tiny 1000 satoshi channels: default minimum is now\n   10,000 satoshis.\no Improved compatibility with corner cases for both lnd (esp. older\n   versions) and Eclair.\n\nMore details can be found in\n        https://github.com/ElementsProject/lightning/blob/v0.7.1/CHANGELOG.md.\n\nContributions\n-------------\n\nWe've seen a lot more contributions and bug reports coming in: please\nkeep them coming!\n\nSince 0.7.0 we've had 591 commits from 31 different authors, with a\nrecord 12 first-time contributors!\n\n    @trueptolemy\n    @darosior\n    @andrewtoth\n    Joe Netti\n    Jeff Vandrew Jr\n    Billy Garrison\n    @thestick613\n    Lawrence Nahum\n    Kristaps Kaupe\n    Hampus Sj\u00f6berg\n    @dlogemann\n    Atis Elsts\n\nCheers,\nRusty, Christian, ZmnSCPxj and Lisa."
            }
        ],
        "thread_summary": {
            "title": "c-lightning v0.7.1: The Unfailing Twitter Consensus Algorithm",
            "categories": [
                "Lightning-dev",
                "RELEASE"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1856
        }
    },
    {
        "title": "[Lightning-dev] Paper: A Composable Security Treatment of the Lightning Network",
        "thread_messages": [
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-07-10T07:57:16",
                "message_text_only": "Hi all,\n\nThe promise for fast, scalable, user-friendly and trustless use of\nbitcoin that the Lightning Network offers motivated us to author a paper\nwhere we formalize LN in the cryptographic framework of Universal\nComposition and prove its security. It can be found here:\nhttps://eprint.iacr.org/2019/778\n\nWe believe that a formal proof of security was needed to specify the\nexact operating parameters that safeguard the funds and transactions of\nusers against arbitrary attackers, to abstract, modularize and validate\nthe underlying cryptography that is used in LN, to incorporate LN in the\nbody of cryptographic protocols that have been abstracted within the\nUniversal Composition framework (and thus can be safely composed and run\nin parallel) and to increase the trust of the wider community to LN. We\nview this work as a small contribution to the amazing effort that the\nLightning community has expended both on the theoretical and the\npractical front throughout the last years.\n\nThe paper is authored by my PhD supervisor Prof. Aggelos Kiayias and me.\nAny feedback will be greatly appreciated.\n\nBest regards,\nOrfeas Stefanos Thyfronitis Litos\n\n-- \nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-07-17T18:11:54",
                "message_text_only": "Hi Orfeas,\n\nThanks for formally modelling lightning and posting your paper here. I've\ntaken a brief look at the paper so far. I am a UC novice and have no\nacademic background so please take that into account when interpreting my\ncomments. In general, I am glad that you are taking the approach to model\nthe protocol relative to the G_ledger functionality which seems like the\nright thing to do (from my amateurish view). The questions/comments I have\nare:\n\n1. When modelling things in UC the ideal functionalities should be as\nsimple and intuitive as possible. I found F_PayNet to be rather difficult\nto follow as compared to the Sprites paper [1]. For example,\n\n\"F_PayNet checks that for each payment the charged party was one of the\nfollowing: (a) the one that initiated the payment, (b) a malicious party or\n(c) an honest party that is negligent\"\n\n Why not assume that (b) never happens because a malicious party never\nwants to lose the funds from a party they've corrupted and (c) never\nhappens because honest parties follow the protocol and check each ledger\nupdate for malicious channel closes. Real world protocols always realise\nideal functionalities under some assumptions and these two things seem like\npretty reasonable things to include in your assumptions rather than\ncluttering up your ideal functionality.\n\n2. In both your paper and [1] I am not convinced that the ideal and real\nworlds aren't easily distinguishable from each other by an Environment that\njust looks at the transactions in the blockchain (G_ledger). For example,\nthe lightning protocol makes heavy use of pay-to-script-hash where as ideal\nfunctionalities have no need for this. F_PayNet can just send normal\ntransactions. I think it would be a great idea to describe how you ensure\nthat the transactions that make it onto the blockchain after an execution\nin the real world are indistinguishable from the ideal world.\n\n3. On a related note, I don't understand this \"receipt\" mechanism. In your\nprotocol description of OpenChannel, Alice uses her private key which owns\nUTXO(s) with x coins to create the funding transaction. This means she\nreceived that private key as input to the execution of the protocol so that\nshe is able to do this (why don't you explicitly include this private key\nin the OpenChannel message?). In the ideal world, the ideal functionality\nshould be the one with the private key signing the funding transaction\ndirectly (in the ideal world the parties are dummy ITMs which just send\ntheir input to the ideal functionality). But instead there is this receipt\nthing which I don't understand.\n\nCheers\n\nLL\n\n[1] https://arxiv.org/pdf/1702.05812.pdf\n\nOn Wed, Jul 10, 2019 at 6:44 PM Orfeas Stefanos Thyfronitis Litos <\no.thyfronitis at ed.ac.uk> wrote:\n\n> Hi all,\n>\n> The promise for fast, scalable, user-friendly and trustless use of\n> bitcoin that the Lightning Network offers motivated us to author a paper\n> where we formalize LN in the cryptographic framework of Universal\n> Composition and prove its security. It can be found here:\n> https://eprint.iacr.org/2019/778\n>\n> We believe that a formal proof of security was needed to specify the\n> exact operating parameters that safeguard the funds and transactions of\n> users against arbitrary attackers, to abstract, modularize and validate\n> the underlying cryptography that is used in LN, to incorporate LN in the\n> body of cryptographic protocols that have been abstracted within the\n> Universal Composition framework (and thus can be safely composed and run\n> in parallel) and to increase the trust of the wider community to LN. We\n> view this work as a small contribution to the amazing effort that the\n> Lightning community has expended both on the theoretical and the\n> practical front throughout the last years.\n>\n> The paper is authored by my PhD supervisor Prof. Aggelos Kiayias and me.\n> Any feedback will be greatly appreciated.\n>\n> Best regards,\n> Orfeas Stefanos Thyfronitis Litos\n>\n> --\n> The University of Edinburgh is a charitable body, registered in\n> Scotland, with registration number SC005336.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190718/06565966/attachment-0001.html>"
            },
            {
                "author": "Miller, Andrew",
                "date": "2019-07-17T18:36:42",
                "message_text_only": "This is a really great question. You are totally right to notice that on-chain transactions are a difference between the real and ideal world and hence can lead to distinguishability... this is something we're actively working on clarifying for Sprites/SaUCy. To give a somewhat fuzzy answer of how we're approaching it: The environment is not really the \"adversary\", instead it's a placeholder for *honest parties* running arbitrary other protocols. I like thinking of the environment as an \"app store wallet\" that runs apps like lightning in a protected sandbox. While we can't prevent the adversary from seeing the transactions in the real world, we do in fact have to prevent the environment from enumerating all the transactions created by the user for security to make sense. Basically the environment needs to only run subprotocols that are isolated from each other, i.e. cannot interfere with or observe other subprotocols' on-chain transactions. Just like UC is only applicable for \"subroutine respecting protocols\", we need to define a similar constraint like \"smart contract isolation respecting protocols\" for blockchain UC to make sense. This too is a somewhat fuzzy answer we're hoping to clarify soon. Also I'm only responding since you mentioned Sprites, Orfeas may have a completely different approach / it may be handled in their paper some other way.\n\n> 2. In both your paper and [1] I am not convinced that the ideal and real worlds aren't easily distinguishable from each other by an Environment that just looks at the transactions in the blockchain (G_ledger). For example, the lightning protocol makes heavy use of pay-to-script-hash where as ideal functionalities have no need for this. F_PayNet can just send normal transactions. I think it would be a great idea to describe how you ensure that the transactions that make it onto the blockchain after an execution in the real world are indistinguishable from the ideal world.\n\nOn Wed, Jul 17, 2019 at 1:12 PM Lloyd Fournier <lloyd.fourn at gmail.com<mailto:lloyd.fourn at gmail.com>> wrote:\nHi Orfeas,\n\nThanks for formally modelling lightning and posting your paper here. I've taken a brief look at the paper so far. I am a UC novice and have no academic background so please take that into account when interpreting my comments. In general, I am glad that you are taking the approach to model the protocol relative to the G_ledger functionality which seems like the right thing to do (from my amateurish view). The questions/comments I have are:\n\n1. When modelling things in UC the ideal functionalities should be as simple and intuitive as possible. I found F_PayNet to be rather difficult to follow as compared to the Sprites paper [1]. For example,\n\n\"F_PayNet checks that for each payment the charged party was one of the following: (a) the one that initiated the payment, (b) a malicious party or (c) an honest party that is negligent\"\n\n Why not assume that (b) never happens because a malicious party never wants to lose the funds from a party they've corrupted and (c) never happens because honest parties follow the protocol and check each ledger update for malicious channel closes. Real world protocols always realise ideal functionalities under some assumptions and these two things seem like pretty reasonable things to include in your assumptions rather than cluttering up your ideal functionality.\n\n2. In both your paper and [1] I am not convinced that the ideal and real worlds aren't easily distinguishable from each other by an Environment that just looks at the transactions in the blockchain (G_ledger). For example, the lightning protocol makes heavy use of pay-to-script-hash where as ideal functionalities have no need for this. F_PayNet can just send normal transactions. I think it would be a great idea to describe how you ensure that the transactions that make it onto the blockchain after an execution in the real world are indistinguishable from the ideal world.\n\n3. On a related note, I don't understand this \"receipt\" mechanism. In your protocol description of OpenChannel, Alice uses her private key which owns UTXO(s) with x coins to create the funding transaction. This means she received that private key as input to the execution of the protocol so that she is able to do this (why don't you explicitly include this private key in the OpenChannel message?). In the ideal world, the ideal functionality should be the one with the private key signing the funding transaction directly (in the ideal world the parties are dummy ITMs which just send their input to the ideal functionality). But instead there is this receipt thing which I don't understand.\n\nCheers\n\nLL\n\n[1] https://arxiv.org/pdf/1702.05812.pdf\n\nOn Wed, Jul 10, 2019 at 6:44 PM Orfeas Stefanos Thyfronitis Litos <o.thyfronitis at ed.ac.uk<mailto:o.thyfronitis at ed.ac.uk>> wrote:\nHi all,\n\nThe promise for fast, scalable, user-friendly and trustless use of\nbitcoin that the Lightning Network offers motivated us to author a paper\nwhere we formalize LN in the cryptographic framework of Universal\nComposition and prove its security. It can be found here:\nhttps://eprint.iacr.org/2019/778\n\nWe believe that a formal proof of security was needed to specify the\nexact operating parameters that safeguard the funds and transactions of\nusers against arbitrary attackers, to abstract, modularize and validate\nthe underlying cryptography that is used in LN, to incorporate LN in the\nbody of cryptographic protocols that have been abstracted within the\nUniversal Composition framework (and thus can be safely composed and run\nin parallel) and to increase the trust of the wider community to LN. We\nview this work as a small contribution to the amazing effort that the\nLightning community has expended both on the theoretical and the\npractical front throughout the last years.\n\nThe paper is authored by my PhD supervisor Prof. Aggelos Kiayias and me.\nAny feedback will be greatly appreciated.\n\nBest regards,\nOrfeas Stefanos Thyfronitis Litos\n\n--\nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336.\n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org<mailto:Lightning-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n--\nAndrew Miller\nUniversity of Illinois at Urbana-Champaign\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190717/ef5a4974/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Paper: A Composable Security Treatment of the Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Miller, Andrew",
                "Orfeas Stefanos Thyfronitis Litos",
                "Lloyd Fournier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12316
        }
    },
    {
        "title": "[Lightning-dev] Using Per-Update Credential to enable Eltoo-Penalty",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2019-07-13T04:35:30",
                "message_text_only": "Hi all,\n\nEltoo has been criticized to lower the cost for a malicious party to\ntest your monitoring of the chain. If we're able to reintroduce some\nform of punishment without breaking transaction symmetry that would be\ngreat.\n\nTransaction symmetry implies that we can't deduce from observing\ntxid which party broadcast a previous state. How to assign the\nfaulty broadcast to the right party to punish it in consequence ?\nThanks to taproot we have cheap witness asymmetry.\nWitness asymmetry can be used as a way to force the broadcaster to reveal\na secret, and so committing thatn the transaction is the latest one.\n\nIf the party misbehaves, we wish to use the revealed secret to punish\nhim on a second stage transaction. Doing so would be really insecure\nin case of reorg or even mempool monitoring by enabling a replay attack\nof your committed secret on a lower state update tx. i.e Mallory\nwould counterfeit being Alice, and so enable the use of a punishment tx\nagainst an honest peer.\n\nTo solve the assignment problem, we need to have per-update credentials,\na secret committed to a state number. You need a scheme were both your\nhighest credential can't be used against you while at the same time if some\nattacker broadcast a transaction with a lower credential you are able to\npunish him.\n\nHow to make Bitcoin Script aware of a secret committed to\na lower state number ? To do so, we may use some SIGHASH magic, if you sign\ntwo messages with the same key and we can be sure thatn the only difference\nbetween\nthem is the nLocktime (encoding the state-number in eltoo), that means you\ntried to breach the contract.\n\nWithout access to arbitrary messages on the stack, the only messages we can\nenforce signatures on are Bitcoin transactions. We force a party\nbroadcasting an Update tx to sign it with\nSIGHASH_ANYPREVOUTSCRIPT|SIGHASH_NONE|SIGHASH_SINGLE. If someone can shows\na\nLitigation Tx with a higher state than the Update, we know that this one\nhas\nbeen revoked, and someone is cheating among channel parties. We enter in a\nLitigation phase, the Settlement Tx will be encumbered by a Challenge Tx\nagainst\nwhich you will need to produce a signature with the same SIGHASH flags as\nthe Update Tx.,\nThe only difference will be the nLocktime inherited from Litigation.\n\nAssume Alice is trying to cheat, now Bob can take the signature from her\nbroadcast Update tx\nand Alice\u2019s signature on the Challenge tx, pass it as witness to a script\nverifying their validity\nand identity. If their validity is true and identity is false, you can\nspend with a Justice tx,\nsplitting Alice\u2019s funds between the other parties. If validity is true and\nidentity is true, then the script should fail. After timelock expiration,\nif no one has proven Alice misbehaved,\nshe can redeem her funds.\n\nEltoo-Penalty Transaction Tree\n==============================\n\n\n\n\n                               Friendly Settlement Tx\n                Challenge Tx -- Justice Tx\n                                 /\n                          /\n                                /\n                       /\nFunding-Output -- Update Tx -- Litigation Tx -- .. -- Hostile Settlement Tx\n--  Challenge Tx -- Justice Tx\n\n                      \\\n\n                       \\  Challenge Tx -- Justice Tx\n\n\nEltoo-Penalty Scripts\n================\n\n(I've omitted chaperon signatures)\n\nFUNDING_OUTPUT:\noutput 0:\nQ = P + tG\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECKSIGVERIFY <Alice_key> CHECKSIGVERIFY\" (Alice script path)\n\"OP_1 CHECKSIGVERIFY <Bob_key> CHECKSIGVERIFY\" (Bob script path)\n\"OP_1 CHECKSIGVERIFY <Caroll_key> CHECKSIGVERIFY\" (Caroll script path)\n]\n\nUPDATE TX:\nnLocktime: 500e6 + n\noutput 0:\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECKSIGVERIFY\" (friendly settlement script path)\n\"OP_1 CHECKSGIVERIFY 500e6+n OP_CLTV OP_DROP\" (litigation script path)\nwitness:\n\"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P,\nhash_type=SINGLE)\"  (Alice commitment signature)\n\"sig(B, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P,\nhash_type=SINGLE)\"  (Bob commitment signature)\n\"sig(C, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P,\nhash_type=SINGLE)\"  (Caroll commitment signature)\n\nLITIGATION TX:\nnLocktime: 500e6 + n\nnSequence: [delay]\noutput 0:\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECKSIG\" (litigation script path)\n\"OP_1 CHECKSIGVERIFY\" (hostile settlement script path)\nwitness:\n\"sig(P, hash_type=SINGLE|ANYPREVOUTANYSCRIPT)\n\n\nHOSTILE SETTLEMENT TX:\nnLocktime: 0\nnSequence: [delay]\noutput 0: (to_Alice)\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECHSIGVERIFY <Alice_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\"\n(Alice challenge script path)\n]\noutput 1: (to_Bob)\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECHSIGVERIFY <Bob_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\" (Bob\nchallenge script path)\n]\noutput 2: (to_Caroll)\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECHSIGVERIFY <Caroll_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\"\n(Caroll challenge script path)\n]\noutput N (pending HTLCs)\nwitness:\n\"sig(P, hash_type=ALL)\n\nCHALLENGE TX: (Alice case)\nnLocktime: 500e6n\nnSequence: 0\noutput 0:\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECKSIGVERIFY OP_DUP <Alice_key> CHECKSIGVERIFY OP_DUP OP_SWAP\n<Alice_key> CHECKSIGVERIFY\n    OP_EQUAL OP_NOT OP_VERIFY\"  (proof-of-Alice-fraud script path)\n\"<n> OP_CSV <Alice refund_key> (refund Alice script path)\n]\nwitness:\n\"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=ALL)\"\n\nJUSTICE TX: (Alice punishment)\nnLocktime: 500e6n\nnSequence: 0\noutput 0: (to_Caroll)\noutput 1: (to_Bob)\nwitness:\n\"sig_Alice_from_update_tx sig_Alice_from_challenge_tx sig(P, hash_type=ALL)\"\n\n\nState Update\n============\n\nAlice, Bob and Caroll build new friendly Settlement tx N, new Update Tx and\nrevoke old one by\ngenerating a Justice tx with state higher than the previous one, a hostile\nSettlement tx plus\nY challenge txn and Y justice txn with Y number of parties.\n\nCooperative Case\n================\n\nAfter X updates, Alice, Bob, Caroll, cooperate to closing transaction using\nkey path\nspending of funding Taproot output, the spending transactions contains\naccurate balances.\n\nUnilateral Case\n================\n\nAfter X updates, Alice broadcast the last Update tx N, by signing it with\nher private key with\nSIGHASH_NONE,SIGHASH_ANYPREVOUTANYSCRIPT,SIGHASH_SINGLE and use MuSig\npreviously distributed\nbetween parties at state update. Her signature doesn't protect anything\nexcept commitment to\nthe latest state number.\n\nAfter finalization of the friendly settlement tx, she can redeem her\nbalance, and timeout/fulfill\nher outputs.\n\nIf she has broadcast the latest state, none of the parties should be able\nto broadcast a Litigation\ntx with a highest state number. Her signature committing to the locktime,\nno one is able to\ncounterfeit her identity by spending the funding taproot output with a\nlowest update tx.\n\nMalicious Case\n==============\n\nBob is broadcasting a lowest Update tx with his signature committing to it.\nAlice use Litigation tx\nto spend it, if anyone has a highest Litigation tx, he can use it. After\nLitigation tx finalization,\nhostile settlement transaction is used. Each output returning to a channel\nparty, is encumbered\nby a \"challenge\". To unlock your funds, you must provide a signature\nagainst same pubkey and same\nSIGHASH flags than the one encumbering your tapscript for funding output.\n\nChallenge tx is using a taproot output, one leaf returning fund to Alice\nafter some timelock,\nThe other one, let anyone with a MuSig and two valid signatures committing\nto different nLocktime\nto send challenged fund to a Justice tx, doing an equal split between other\nchannel parties.\n\nYou need signatures to be safe against third-party malleability, i.e being\nable to tweak\nyour signatures to be still valid but diff being interpreted as a proof of\ncommitment on lowest state number. On the Justice tx, you need a new key\ntype to enforce that every signature must have sighash\nSIGHASH_MASKLOCKTIMEWITH, where you expect the signature to be followed by\nthe state number which is going to be used as locktime in transaction\ndigest algorithm. So in this way state number are provided in witness and\nyou can equivocate Justice tx as both revoked Update Tx and Challenge Tx.\n\nOkay, I'm quite sure that Script gurus on this list are going to point\nflaws of this scheme.\nIt's more a thought experiment and I was curious if anyone has other ideas\nto get Eltoo + penalties,\nif yes let it know !\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190713/421bc6e4/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-14T04:48:22",
                "message_text_only": "Good morning Atoine,\n\nThank you for your proposal.\n\n> Eltoo has been criticized to lower the cost for a malicious party to\n> test your monitoring of the chain. If we're able to reintroduce some\n> form of punishment without breaking transaction symmetry that would be great.\n\nThe primary advantage of Decker-Russell-Osuntokun is that it eliminates \"toxic waste\".\n\nBy this we mean, older version of your channel database are \"toxic\" in that you, ***or someone who wants to attack you***, can use it (accidentally in your case, deliberately in the attacker case), and then you will lose all funds in the channel.\n\nNote that access to your channel database, without necessarily accessing your node private keys, is often easier.\nFor example, C-Lightning stores channel data into an SQLITE database and exposes every transaction it makes to a `db_hook` that plugins can use to replicate the database elsewhere.\nIf you were to use an insufficiently secured plugin to replicate your database, an attacker might be able to access your channel data, replicate your database, and use an older version to frame you for theft and make you lose all your channel funds.\n\nThus, Decker-Russell-Osuntokun removes the punitive consideration so that you being framed for theft does not lose all your funds, it merely closes your channels.\n\nHowever, it look to me that you attempt to fix the toxic waste issue, as you mention a \"Mallory\" later that attempts to frame Alice (possibly by broadcasting old state).\nOn the other hand, it seems, there is no description of how Alice might go about protecting herself from Mallory.\n\nIn particular, it seems to me that it would be trivial for Alice to avoid punishment by first creating a fake \"Mallory\", then taking whatever path would let Alice \"off the hook\" for a framing Mallory when at risk of getting caught, thus returning the \"reduced cost for trying to steal channel funds\".\n\n>\n> Transaction symmetry implies that we can't deduce from observing\n> txid which party broadcast a previous state. How to assign the\n> faulty broadcast to the right party to punish it in consequence ?\n> Thanks to taproot we have cheap witness asymmetry.\n> Witness asymmetry can be used as a way to force the broadcaster to reveal\n> a secret, and so committing thatn the transaction is the latest one.\n>\n> If the party misbehaves, we wish to use the revealed secret to punish\n> him on a second stage transaction. Doing so would be really insecure\n> in case of reorg or even mempool monitoring by enabling a replay attack\n> of your committed secret on a lower state update tx. i.e Mallory\n> would counterfeit being Alice, and so enable the use of a punishment tx\n> against an honest peer.\n>\n> To solve the assignment problem, we need to have per-update credentials,\n> a secret committed to a state number. You need a scheme were both your\n> highest credential can't be used against you while at the same time if some\n> attacker broadcast a transaction with a lower credential you are able to\n> punish him.\n>\n> How to make Bitcoin Script aware of a secret committed to\n> a lower state number ? To do so, we may use some SIGHASH magic, if you sign\n> two messages with the same key and we can be sure thatn the only difference between\n> them is the nLocktime (encoding the state-number in eltoo), that means you\n> tried to breach the contract.\n\nCould a hash preimage be used instead, with revocation?\nWe would require that the hash preimage be unique per-update, but the same technique used in current Poon-Dryja (Russell shachain) can be used to store the preimages of revoked states.\n\n>\n> Without access to arbitrary messages on the stack, the only messages we can\n> enforce signatures on are Bitcoin transactions. We force a party\n> broadcasting an Update tx to sign it with\n> SIGHASH_ANYPREVOUTSCRIPT|SIGHASH_NONE|SIGHASH_SINGLE. If someone can shows a\n> Litigation Tx with a higher state than the Update, we know that this one has\n> been revoked, and someone is cheating among channel parties. We enter in a\n> Litigation phase, the Settlement Tx will be encumbered by a Challenge Tx against\n> which you will need to produce a signature with the same SIGHASH flags as the Update Tx.,\n> The only difference will be the nLocktime inherited from Litigation.\n>\n> Assume Alice is trying to cheat, now Bob can take the signature from her broadcast Update tx\n> and Alice\u2019s signature on the Challenge tx, pass it as witness to a script verifying their validity\n> and identity. If their validity is true and identity is false, you can spend with a Justice tx,\n> splitting Alice\u2019s funds between the other parties. If validity is true and identity is true, then the script should fail. After timelock expiration, if no one has proven Alice misbehaved,\n> she can redeem her funds.\n>\n> Eltoo-Penalty Transaction Tree\n> ==============================\n>\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Friendly Settlement Tx \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Challenge Tx -- Justice Tx\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0/ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 / \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0/\n> Funding-Output -- Update Tx -- Litigation Tx -- .. -- Hostile Settlement Tx -- \u00a0Challenge Tx -- Justice Tx\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \\\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\ \u00a0Challenge Tx -- Justice Tx\n>\n\nI am uncertain if some of the alignment has gotten lost above, but currently your graph is somewhat confusing.\n\n> Eltoo-Penalty Scripts\n> ================\n>\n> (I've omitted chaperon signatures)\n>\n> FUNDING_OUTPUT:\n> output 0:\n> Q = P + tG\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECKSIGVERIFY <Alice_key> CHECKSIGVERIFY\" (Alice script path)\n> \"OP_1 CHECKSIGVERIFY <Bob_key> CHECKSIGVERIFY\" (Bob script path)\n> \"OP_1 CHECKSIGVERIFY <Caroll_key> CHECKSIGVERIFY\" (Caroll script path)\n> ]\n>\n> UPDATE TX:\n> nLocktime: 500e6 + n\n> output 0:\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECKSIGVERIFY\" (friendly settlement script path)\n\nThis branch seems pointless --- could you not just use the non-taproot path?\nYou do not describe the friendly-settlement transaction anywhere.\nIs the friendly-settlement have `nSequence` delay?\nWhen is it created?\n\n\n> \"OP_1 CHECKSGIVERIFY 500e6+n OP_CLTV OP_DROP\" (litigation script path)\n> witness:\n> \"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=SINGLE)\" \u00a0(Alice commitment signature)\n> \"sig(B, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=SINGLE)\" \u00a0(Bob commitment signature)\n> \"sig(C, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=SINGLE)\" \u00a0(Caroll commitment signature)\n\nIt looks to me that you cannot use a later update transaction to replace an older update transaction, as the shared signature does not use `SIGHASH_ANYPREVOUT`?\n\n>\n> LITIGATION TX:\n> nLocktime: 500e6 + n\n> nSequence: [delay]\n> output 0:\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECKSIG\" (litigation script path) \u00a0 \u00a0\n> \"OP_1 CHECKSIGVERIFY\" (hostile settlement script path)\n> witness:\n> \"sig(P, hash_type=SINGLE|ANYPREVOUTANYSCRIPT)\n\nYou mentions later that \"if anyone has a highest Litigation tx, he can use it\", but it does not look like that the litigation script path enforces this, did you forget to add some `OP_CHECKLOCKTIMEVERIFY` here?\n\n>\n> HOSTILE SETTLEMENT TX:\n> nLocktime: 0\n> nSequence: [delay]\n> output 0: (to_Alice)\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECHSIGVERIFY <Alice_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\" (Alice challenge script path)\n> ]\n> output 1: (to_Bob)\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECHSIGVERIFY <Bob_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\" (Bob challenge script path)\n> ]\n> output 2: (to_Caroll)\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECHSIGVERIFY <Caroll_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\" (Caroll challenge script path)\n> ]\n> output N (pending HTLCs)\n> witness:\n> \"sig(P, hash_type=ALL)\n>\n> CHALLENGE TX: (Alice case)\n> nLocktime: 500e6n\n> nSequence: 0\n> output 0:\n> P = muSig(A,B,C)\n> scripts = [\n> \"OP_1 CHECKSIGVERIFY OP_DUP <Alice_key> CHECKSIGVERIFY OP_DUP OP_SWAP <Alice_key> CHECKSIGVERIFY\n> \u00a0 \u00a0 OP_EQUAL OP_NOT OP_VERIFY\" \u00a0(proof-of-Alice-fraud script path)\n> \"<n> OP_CSV <Alice refund_key> (refund Alice script path)\n> ]\n> witness:\n> \"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=ALL)\"\n>\n> JUSTICE TX: (Alice punishment)\n> nLocktime: 500e6n\n> nSequence: 0\n> output 0: (to_Caroll)\n> output 1: (to_Bob) \u00a0 \u00a0\n> witness:\n> \"sig_Alice_from_update_tx sig_Alice_from_challenge_tx sig(P, hash_type=ALL)\"\n\n`P` here is `muSig(A,B,C)`?\nWhy would Alice willingly sign a `SIGHASH_ALL` signature (meaning the transaction IDs are known at this point and have been confirmed deeply onchain, so this is after Alice has gone and performed any attempts at theft) that would punish her?\nWhat happens when the Litigation Tx is later than the initial Update Tx?\n\nMaybe this should instead be a revocation key whose privkey Alice reveals as part of the update ritual?\n\nIf a later Litigation Tx is used, than the Update Tx that was put onchain, is the signature from the Update Tx valid on the same transaction where the Challenge Tx is valid?\n\n\nExplicitly stating what transaction outputs are spent by each transaction input would be better, especially since your graph is unclear.\n\n\n>\n> State Update\n> ============\n>\n> Alice, Bob and Caroll build new friendly Settlement tx N, new Update Tx and revoke old one by\n> generating a Justice tx with state higher than the previous one, a hostile Settlement tx plus\n> Y challenge txn and Y justice txn with Y number of parties.\n\nYou do not describe the friendly settlement transaction.\nI assume it has some `nSequence` somewhere.\n\n>\n> Cooperative Case\n> ================\n>\n> After X updates, Alice, Bob, Caroll, cooperate to closing transaction using key path\n> spending of funding Taproot output, the spending transactions contains accurate balances.\n>\n> Unilateral Case\n> ================\n>\n> After X updates, Alice broadcast the last Update tx N, by signing it with her private key with\n> SIGHASH_NONE,SIGHASH_ANYPREVOUTANYSCRIPT,SIGHASH_SINGLE and use MuSig previously distributed\n> between parties at state update. Her signature doesn't protect anything except commitment to\n> the latest state number.\n>\n> After finalization of the friendly settlement tx, she can redeem her balance, and timeout/fulfill\n> her outputs.\n>\n> If she has broadcast the latest state, none of the parties should be able to broadcast a Litigation\n> tx with a highest state number. Her signature committing to the locktime, no one is able to\n> counterfeit her identity by spending the funding taproot output with a lowest update tx.\n>\n> Malicious Case\n> ==============\n>\n> Bob is broadcasting a lowest Update tx with his signature committing to it. Alice use Litigation tx\n> to spend it, if anyone has a highest Litigation tx, he can use it. After Litigation tx finalization,\n> hostile settlement transaction is used. Each output returning to a channel party, is encumbered\n> by a \"challenge\". To unlock your funds, you must provide a signature against same pubkey and same\n> SIGHASH flags than the one encumbering your tapscript for funding output.\n>\n> Challenge tx is using a taproot output, one leaf returning fund to Alice after some timelock,\n> The other one, let anyone with a MuSig and two valid signatures committing to different nLocktime\n> to send challenged fund to a Justice tx, doing an equal split between other channel parties.\n>\n> You need signatures to be safe against third-party malleability, i.e being able to tweak\n> your signatures to be still valid but diff being interpreted as a proof of commitment on lowest state number. On the Justice tx, you need a new key type to enforce that every signature must have sighash SIGHASH_MASKLOCKTIMEWITH, where you expect the signature to be followed by the state number which is going to be used as locktime in transaction digest algorithm. So in this way state number are provided in witness and you can equivocate Justice tx as both revoked Update Tx and Challenge Tx.\n>\n> Okay, I'm quite sure that Script gurus on this list are going to point flaws of this scheme.\n> It's more a thought experiment and I was curious if anyone has other ideas to get Eltoo + penalties,\n> if yes let it know !\n\nThe descriptions of the transactions and scripts involved are confusing and I am uncertain if you actually achieve your target.\nCould you clarify?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2019-07-14T13:42:30",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n\n> Good morning Atoine,\n>\n> Thank you for your proposal.\n>\n>> Eltoo has been criticized to lower the cost for a malicious party to\n>> test your monitoring of the chain. If we're able to reintroduce some\n>> form of punishment without breaking transaction symmetry that would be great.\n>\n> The primary advantage of Decker-Russell-Osuntokun is that it\n> eliminates \"toxic waste\".\n>\n> By this we mean, older version of your channel database are \"toxic\" in\n> that you, ***or someone who wants to attack you***, can use it\n> (accidentally in your case, deliberately in the attacker case), and\n> then you will lose all funds in the channel.\n\nI'm pretty sure at this point that the toxic-waste problem is inherent\nto punishment schemes, and anything we build on top of it would\nreintroduce asymmetry, undoing a lot of the benefits that we gained with\neltoo. Then again, I personally don't think that punishments are such a\ngreat idea in the first place (having been inadvertently punished myself\ndue to botched backups and similar things).\n\n> Note that access to your channel database, without necessarily\n> accessing your node private keys, is often easier.  For example,\n> C-Lightning stores channel data into an SQLITE database and exposes\n> every transaction it makes to a `db_hook` that plugins can use to\n> replicate the database elsewhere.  If you were to use an\n> insufficiently secured plugin to replicate your database, an attacker\n> might be able to access your channel data, replicate your database,\n> and use an older version to frame you for theft and make you lose all\n> your channel funds.\n\nJust a minor correction here: your own commitment transactions are not\nbeing signed until we want to release them. Therefore having access to\nyour DB doesn't give an attacker the ability to frame the user with an\nold version, since that'd still require access to the keys to add our\nown signature. Even a simple signing component that keeps a high-water\nmark for the latest state and refuses to sign an older one would be\nsufficient to guard against involuntary cheating.\n\nNevertheless, there are quite a few damaging things an attacker can do\nif he get hold of your DB, just not this one :-)\n\n> Thus, Decker-Russell-Osuntokun removes the punitive consideration so\n> that you being framed for theft does not lose all your funds, it\n> merely closes your channels.\n\nWhich is also not free: you are still paying on-chain fees for your\nfailed attempt to enforce an older state, and you still don't get the\ndesired effect, since the counterparty just overrides your attempt,\nwithout returning your fees.\n\nCheers,\nChristian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-14T23:22:43",
                "message_text_only": "Good morning list,\n\n> witness:\n> \"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=SINGLE)\"  (Alice commitment signature)\n\nI realized that this would not work.\nAlice can simply sign `sig(A, hash_type=ALL)` instead at this stage, as she is the only signatory to the `<Alice key> OP_CHECKSIGVERIFY` and nobody else can impose that she use the above `hash_type`.\nAnd this signature is intended to be used to identify Alice as the culprit, by also being used to sign for <Alice key>, but `SIGHASH_ALL` would strongly bind the signature to this particular transaction.\n\nYou could use `MuSig(A, B, C)` instead and perform the MuSig signing ritual such that Alice is the last one to generate the final signature, but this massively complicates things as you need to perform `n` such rituals where `n` is the number of participants.\n\nI think a hash/preimage challenge would work better here.\nEach participant would reveal an identifying hash on channel opening, with a preimage only each participant knows.\nThis is used to restrict which Taproot script they can use to perform a unilateral close, thus identifying which participant initiated the unilateral close (and if the unilateral close is to an old state, can be used to identify who should be punished).\n\n> > > Eltoo has been criticized to lower the cost for a malicious party to\n> > > test your monitoring of the chain. If we're able to reintroduce some\n> > > form of punishment without breaking transaction symmetry that would be great.\n> >\n> > The primary advantage of Decker-Russell-Osuntokun is that it\n> > eliminates \"toxic waste\".\n> > By this we mean, older version of your channel database are \"toxic\" in\n> > that you, or someone who wants to attack you, can use it\n> > (accidentally in your case, deliberately in the attacker case), and\n> > then you will lose all funds in the channel.\n>\n> I'm pretty sure at this point that the toxic-waste problem is inherent\n> to punishment schemes, and anything we build on top of it would\n> reintroduce asymmetry, undoing a lot of the benefits that we gained with\n> eltoo. Then again, I personally don't think that punishments are such a\n> great idea in the first place (having been inadvertently punished myself\n> due to botched backups and similar things).\n\nI largely agree.\n\n> > Note that access to your channel database, without necessarily\n> > accessing your node private keys, is often easier. For example,\n> > C-Lightning stores channel data into an SQLITE database and exposes\n> > every transaction it makes to a `db_hook` that plugins can use to\n> > replicate the database elsewhere. If you were to use an\n> > insufficiently secured plugin to replicate your database, an attacker\n> > might be able to access your channel data, replicate your database,\n> > and use an older version to frame you for theft and make you lose all\n> > your channel funds.\n>\n> Just a minor correction here: your own commitment transactions are not\n> being signed until we want to release them. Therefore having access to\n> your DB doesn't give an attacker the ability to frame the user with an\n> old version, since that'd still require access to the keys to add our\n> own signature. Even a simple signing component that keeps a high-water\n> mark for the latest state and refuses to sign an older one would be\n> sufficient to guard against involuntary cheating.\n>\n> Nevertheless, there are quite a few damaging things an attacker can do\n> if he get hold of your DB, just not this one :-)\n\nAh, I understand.\n\n> > Thus, Decker-Russell-Osuntokun removes the punitive consideration so\n> > that you being framed for theft does not lose all your funds, it\n> > merely closes your channels.\n>\n> Which is also not free: you are still paying on-chain fees for your\n> failed attempt to enforce an older state, and you still don't get the\n> desired effect, since the counterparty just overrides your attempt,\n> without returning your fees.\n\nCurrent Poon-Dryja requires a \"reserve\", a minimum amount that each participant must maintain in the channel.\nThough not fixed in the spec (each participant supposedly indicates the reserve they want from the other) all implementations I know of hardcode 1% of the channel total value as the reserve.\nThis is the amount that can be used to punish a thief.\n\nNow, an economically-maximizing thief would prefer to steal as much as possible, thus such a thief would initiate a channel, then send out funds until only 1% is left to the thief, then \"freeze\" the channel (fail all incoming HTLCs from this channel without bothering to check if they would succeed) until the participant is offline, then perform the theft attempt by using their initial commitment (the one where they own all the funds in the channel).\n\nThus, if the fee that is needed in Decker-Russell-Osuntokun is at or above 1% of the channel value, the fee lost would be larger than what a thief would risk under Poon-Dryja.\n\nOf course, an economically-maximizing thief would make channels of up to our channel limit of 16,777,215 satoshi, of which 1% would be a large fee even during congestion conditions.\nStill, a node could refuse incoming channel open requests for Decker-Russell-Osuntokun that are larger than 100 times the typical fee for a 1-input 1-output transaction, and still get similar protection to Poon-Dryja using the de facto standard 1% reserve.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-15T00:12:30",
                "message_text_only": "Good morning list,\n\nI had another realization about the use of punishment in a multiparticipant (n > 2) setting.\nAnd it has to do with contracts that have a sort of \"shared ownership\".\n\nConsider HTLC outputs.\nSuch outputs have shared ownership, as the offerer of the HTLC will be able to reclaim the money after the timelock, and the accepter of the HTLC will be able to reclaim the money before the timelock.\n\nSuppose we know that Alice cheated.\nSuppose also that Bob offered an HTLC to Alice with a hash whose preimage Alice secretly knows, and that Alice offered an HTLC to Charlie with a long future lock time with a hash that Alice secretly knows has a high probability that nobody knows the preimage.\n\nHow should Bob and Charlie split the HTLCs?\nIf we do not punish the HTLCs, then Alice can arrange such that most of her money is in HTLCs that she can recover, and thereby avoid punishment.\nIf we *do* punish the HTLCs, we would have to make the Bob->Alice revocable only in favor of Bob, and make the Alice->Carol revocable only in favor of Charlie.\n\n\nThis ties to constructions such as Channel Factories.\nI would argue that channel factories are better used than multiparticipant channels, as channel factories allow *some* limited transport of funds even if one participant is offline, whereas multiparticipant channels prevent *all* transport of funds as soon as any one participant is offline.\nAt the same time, channel factories allow arbitrary transport of funds between any participants inside the factory if all participants are online: if a channel is exhausted, but the paying participant has funds elsewhere, the paying participant can initiate a channel reorganization and move funds to the exhausted channel.\n\nChannel factories host channels.\nChannels are shared-ownership UTXOs, in much the same way that HTLCs are shared-ownership UTXOs.\n\nThus, if we will use this construction to implement channel factories, channels inside the factory should be punished by transferring the funds to the other participant of the channel.\n\nHowever, things can get more complicated as the states inside the construction change over time.\n\n--------\n\nLet us return to the HTLC example.\n\nSuppose there exists an Alice->Bob HTLC in the old state that Alice the thief publishes, and that the entire value of the construction is in that HTLC.\n\nLet us consider what happens if Alice the thief performs the theft attempt during various states:\n\n* Suppose the current state is that Charlie owns the entire funds of the channel right now.\n  Alice steals by publishing old state, but the old-state Alice->Bob HTLC is revocable only by Bob.\n  Thus the money (that rightfully belongs to Charlie) goes to Bob instead.\n  * Alice and Bob could be in cahoots, with Bob as the mastermind and Alice as the fall guy.\n* Suppose we decide that the Alice->Bob HTLC is revocable split by Bob and Charlie.\n  Suppose the current state is that Bob owns the entire funds of the channel right now.\n  Alice steals by publishing old state, but the old-state Alice->Bob HTLC is revocable split by Bob and Charlie.\n  Thus the money (that rightfully belongs only to Bob) goes partly to Charlie instead.\n  * Alice and Charlie could be in cahoots, with Charlie as the mastermind and Alice as the fall guy.\n\nIt seems to me, that punishment systems can only work if one of the following are true:\n\n* 2 participants, which prevents channel factory scaling.\n* OR, no smart contracts (HTLCs or subchannels), which prevents channel factory scaling, **and** network/routing scaling.\n\nSo I think that, in terms of multiparticipant constructions, non-punitive constructions are the only possible constructions.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-15T09:58:12",
                "message_text_only": "Good morning list,\n\nAs usual, I am spamming the list for my amusement.\n\nThus, I would like to thank you for your tolerance and continued attention.\n\n----\n\nWe have identified two requirements:\n\n1.  We must identify which participant initiated the unilateral close onchain.\n    We do so that if later, we find that the unilateral close was to an older state, we can punish the participant that initiated the unilateral close.\n2.  We must identify that a unilateral close was, in fact, to an older state.\n\nThus, I will counterpropose a construction similar to that originally proposed here, but with the weaknesses fixed and key details filled in.\n(while part of it is similar to the Decker-Russell-Osuntokun \"eltoo\", it is different enough that I would not suggest calling it \"eltoo-penalty\")\n\n----\n\nOn initiation, Alice, Bob, and Charlie indicate:\n\n* Alice/Bob/Charlie \"fingerprint\" hash/preimage.\n  Alice/Bob/Charlie publish the fingerprint hashes, but keep the fingerprint preimages secret.\n* Alice/Bob/Charlie \"normal\" pubkey.\n* Alice/Bob/Charlie \"lawyer\" pubkey.\n* All participants indicate a `delay`, a number of blocks.\n  Funds may be locked, in worst case, up to `2 * delay`.\n\nWe also introduce a \"common\" key whose private key is known to all participants.\nFor example, we can use a key whose private key is `SHA256(\"ZmnSCPxj is a human being and not any kind of AI\")` as a consensus-accepted fact.\n\nWe have the below transactions:\n\n* Funding transaction\n  * inputs: unspecified\n  * outputs:\n    * change output(s): unspecified\n    * funding output:\n      * Internal Taproot Key: `P = MuSig(Alice normal pubkey, Bob normal pubkey, Charlie normal pubkey)`\n      * Scripts:\n        * `OP_1 OP_CHECKSIGVERIFY OP_HASH160 <Alice fingerprint hash> OP_EQUALVERIFY`\n        * `OP_1 OP_CHECKSIGVERIFY OP_HASH160 <Bob fingerprint hash> OP_EQUALVERIFY`\n        * `OP_1 OP_CHECKSIGVERIFY OP_HASH160 <Charlie fingerprint> OP_EQUALVERIFY`\n\n* Update Transaction\n  * comment: this transaction initiates a unilateral close attempt.\n  * comment: Updates have a \"hidden\" `n`, which is an \"update\" number incrementing from 0.\n    This number could be encoded as `nLockTime` by using `500e6 + n`, but in principle does not need to be encoded there (we could use the current encoding in Poon-Dryja, which is encrypted so that normal unilateral closes do not reveal how many updates occurred).\n  * Update transaction might have other inputs/outputs used to pay for onchain fees.\n  * input:\n    * Funding transaction output\n    * witness: one of the following, depending on which participant initiated the unilateral close:\n      * `<Alice fingerprint preimage> sign(MuSig(A normal, B normal, C normal), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n      * `<Bob fingerprint preimage> sign(MuSig(A normal, B normal, C normal), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n      * `<Charlie fingerprint preimage> sign(MuSig(A normal, B normal, C normal), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n    * comment: which witness script appears onchain depends on which participant initiated the unilateral close.\n  * output:\n    * Internal Taproot Key: `MuSig(A normal, B normal, C normal)`\n    * Scripts:\n      * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <MuSig(A normal, B normal, C normal)> OP_CHECKSIG`\n        * This is the \"normal\" unilateral path where the participant did not steal any funds.\n      * `<500e6 + n + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <MuSig(A lawyer, B lawyer, C lawyer)> OP_CHECKSIG`\n        * This is the \"litigation\" path where the participant is proven to have stolen funds by showing a litigation transaction with later `n` than the update transaction.\n\n* Friendly Settlement Transaction\n  * comment: This transaction completes a unilateral close attempt and publishes all contracts transported in the channel without revocability branches.\n  * `nSequence`: `<delay>`\n  * input:\n    * Update transaction output\n    * witness: `sign(MuSig(A normal, B normal, C normal), SIGHASH_ANYPREVOUTANYSCRIPT)`\n  * outputs: unencumbered outputs for this state.\n\n* Litigation Transaction\n  * comment: The appearance of this transaction onchain is taken as proof that the unilateral close attempt is definitely a theft attempt.\n    It can only be broadcast and confirmed if and only if the unilateral close Update Transaction has an `n` that is less than the latest agreed `n`.\n  * comment: A Litigation Transaction can be spent by another Litigation Transaction with higher `n`.\n    The intent is to force the current state onchain, in order to punish the thief using the *latest* state instead of punishing from old state.\n  * `nLockTime`: `500e6 + n`, where `n` is the update index for this Litigation Transaction.\n    * comment: a Litigation Transaction with `n` cannot spend an Update Transaction of same `n`, only `n - 1` or less.\n  * input:\n    * Update transaction output *OR* another Litigation Transaction output; Update/Litigation tx has `n` less than this Litigation transaction.\n    * witness: `sign(MuSig(A lawyer, B lawyer, C lawyer), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n  * output:\n    * Internal Taproot Key: `MuSig(A lawyer, B lawyer, C lawyer)`\n    * scripts:\n      * `<500e6 + n + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_1 OP_CHECKSIG`\n        * comment: This allows a Litigation Transaction with later `nLockTime` to spend this Litigation Transaction.\n      * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <500e6 + n> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_1 OP_CHECKSIG`\n        * comment: This is the \"Hostile Settlement\" path that allows revocation of outputs owned by the participant that initiated the unilateral close.\n\n* Hostile Settlement Transaction\n  * `nLockTime`: `500e6 + n`\n  * input:\n    * Litigation Transaction output\n    * witness: `sign(MuSig(A lawyer, B lawyer, C lawyer), SIGHASH_ANYPREVOUTANYSCRIPT)`\n  * outputs:\n    * Depending on type of contract, outputs are revocable:\n      * Single-ownership contract (example below is Alice-owned)\n        * Taproot Internal Key: `P = NUMS point` (cannot be spent via non-Taproot path)\n        * scripts:\n          * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <A lawyer> OP_CHECKSIG`\n            * comment: This lets Alice recover its funds if it is not the thief.\n          * `OP_0 OP_CHECKSEQUENCEVERIFY OP_DROP OP_HASH160 <Alice fingerprint hash> OP_EQUALVERIFY <common key> OP_CHECKSIG`\n            * comment: Alice fingerprint preimage is published if Alice is the one who published the old Update Transaction.\n              Any participant can take that preimage and re-publish it here.\n            * comment: the `0 OP_CHECKSEQUENCEVERIFY` ensures the spending script has RBF enabled.\n            * comment: we use the common key, and the requirement to provide the Alice fingerprint preimage, *and* the requirement to enable RBF, to force the output to be revoked to miners as fees: when the entire output is given as fee, no higher RBF is possible.\n              * comment: outputs may become too tiny to care about if we split up a tiny reserve between dozens of honest participants.\n                But the important point is to punish the thief, not award the honest participants.\n              * comment: further, since the Litigation Transaction *should* make valid the latest Hostile Settlement, the outputs of the honest participants are at the latest state, already, so they cannot lose funds by having the thief-owned outputs be revoked in favor of miners.\n      * Dual-ownership contract (example below is an HTLC from Bob to Charlie)\n        * Taproot Internal Key: `P = NUMS point`\n        * scripts:\n          * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <B lawyer> OP_CHECKSIG`\n            * comment: Timelock branch, Bob reclaims money.\n          * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP OP_HASH160 <hash> OP_EQUALVERIFY <C lawyer> OP_CHECKSIG`\n            * comment: Hashlock branch, Charlie claims funds in exchange for publishing payment preimage.\n          * `OP_HASH160 <Bob fingerprint hash> OP_EQUALVERIFY <C lawyer> OP_CHECKSIG`\n            * comment: Revocation branch, Bob attempted to steal, so Charlie gets the money outright.\n          * `OP_HASH160 <Charlie fingerprint hash> OP_EQUALVERIFY <B lawyer> OP_CHECKSIG`\n            * comment: Revocation branch, Charlie attempted to steal, so Bob gets the money outright.\n        * Any two-participant contract can be made revocable by the same pattern:\n          * Use a NUMS point for taproot internal key.\n          * Give every branch explicitly as a branch in the Taproot MAST; prepend an additional `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP`.\n          * Add branches for revocation, where proof that one side attempted to steal allows the other side to control the coin immediately.\n        * Sub-channels will need to use `SIGHASH_ANYPREVOUTANYSCRIPT`, so that signatures that can spend from an output of the Friendly Settlement can also spend from an output of the Hostile Settlement (once the additional encumberance has been passed).\n\nSo, here are some changes to the original proposal:\n\n* We use a hash/preimage challenge to identify *who* attempted to steal.\n  * The \"revocation key\" is the same as the \"fingerprint\".\n    It is safe to publish the revocation key if you publish only the latest Update Transaction, as the latest Update Transaction cannot enable any Litigation Transaction.\n* Single-ownership outputs of the current state are encumbered by a revocability clause that revokes in favor of miners.\n* Dual-ownership outputs of the current state are encumbered by a revocability clause that revokes in favor of the non-thief participant if one of the participants is the thief.\n* Outputs with more than two owners are not supported by this construction.\n\nIt was not very clear from the original proposal, but the Litigation Transaction path ensures we can go to the latest state, and the Hostile Settlement transaction represents the latest state, plus allowing revocability of outputs in that state.\nThis behavior allows us to perform our punishments based on the latest state, compared to Poon-Dryja which punishes based on the old published state (which is simpler since it always just rewards the entire channel funds to the honest party).\n\nThe Friendly Settlement transaction does not allow any revocability, but can only be published if no Litigation Transaction has been published.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-07-16T18:52:41",
                "message_text_only": "Hi ZmnSCPxj,\n\nAwesome resume, it's better lay-out than I did myself !!\n\n> Thus, I would like to thank you for your tolerance and continued\nattention.\n\nPersonally, it's a pleasure to read your weird but always thoughtful\nproposals in other threads :)\n\n\"We have identified two requirements:\n\n1.  We must identify which participant initiated the unilateral close\nonchain.\n    We do so that if later, we find that the unilateral close was to an\nolder state, we can punish the participant that initiated the unilateral\nclose.\n2.  We must identify that a unilateral close was, in fact, to an older\nstate.\"\n\nI think you have well-scoped the assignment problem. But it would add\nanother requirement :\n\n3. Identity commitment must not be replayable or counterfeited by another\nparticipant.\n\nI thought to use unique preimage in a previous versions of my proposal but\nit seems really unsafe due to reorgs and mempool snooping. If another\nchannel participant is able to take back your identity preimage and uses it\nto spend with a lower state update tx you are know flagged as the\ncheater. So we want preimage to be tied to a state number and best scheme\nI've thought of is not using preimage but signatures.\n\nMay we build a commitment with preimage and state number without signatures\n?\n\n> * comment: we use the common key, and the requirement to provide the\nAlice fingerprint preimage, *and* the requirement to enable RBF, to force\nthe output to be revoked to miners as fees: when the entire output is given\nas fee, no higher RBF is possible.\n              * comment: outputs may become too tiny to care about if we\nsplit up a tiny reserve between dozens of honest participants.\n\nOn the other side, giving back funds to participants let them cover back\nthe expenses to pay onchain fees for last state enforcement.\n\n> * Add branches for revocation, where proof that one side attempted to\nsteal allows the other side to control the coin immediately.\n\nHmm that's the point we argue a lot, but by broadcasting a previous update,\nif HTLC is Bob->Caroll, Bob didn't only try to rob Caroll\nbut potentially every others channel participants. Why they should get a\npart of Bob funds as compensation ?\n\n> It is safe to publish the revocation key if you publish only the latest\nUpdate Transaction, as the latest Update Transaction cannot enable any\nLitigation Transaction.\n\nExact, even if you're a honest participant you have to commit to a secret\nor revocation key, because the blockchain can\nonly know after the nSequence expiration delay of the Friendly Settlement\ntransaction that you are honest.\n\nLe lun. 15 juil. 2019 \u00e0 05:58, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning list,\n>\n> As usual, I am spamming the list for my amusement.\n>\n> Thus, I would like to thank you for your tolerance and continued attention.\n>\n> ----\n>\n> We have identified two requirements:\n>\n> 1.  We must identify which participant initiated the unilateral close\n> onchain.\n>     We do so that if later, we find that the unilateral close was to an\n> older state, we can punish the participant that initiated the unilateral\n> close.\n> 2.  We must identify that a unilateral close was, in fact, to an older\n> state.\n>\n> Thus, I will counterpropose a construction similar to that originally\n> proposed here, but with the weaknesses fixed and key details filled in.\n> (while part of it is similar to the Decker-Russell-Osuntokun \"eltoo\", it\n> is different enough that I would not suggest calling it \"eltoo-penalty\")\n>\n> ----\n>\n> On initiation, Alice, Bob, and Charlie indicate:\n>\n> * Alice/Bob/Charlie \"fingerprint\" hash/preimage.\n>   Alice/Bob/Charlie publish the fingerprint hashes, but keep the\n> fingerprint preimages secret.\n> * Alice/Bob/Charlie \"normal\" pubkey.\n> * Alice/Bob/Charlie \"lawyer\" pubkey.\n> * All participants indicate a `delay`, a number of blocks.\n>   Funds may be locked, in worst case, up to `2 * delay`.\n>\n> We also introduce a \"common\" key whose private key is known to all\n> participants.\n> For example, we can use a key whose private key is `SHA256(\"ZmnSCPxj is a\n> human being and not any kind of AI\")` as a consensus-accepted fact.\n>\n> We have the below transactions:\n>\n> * Funding transaction\n>   * inputs: unspecified\n>   * outputs:\n>     * change output(s): unspecified\n>     * funding output:\n>       * Internal Taproot Key: `P = MuSig(Alice normal pubkey, Bob normal\n> pubkey, Charlie normal pubkey)`\n>       * Scripts:\n>         * `OP_1 OP_CHECKSIGVERIFY OP_HASH160 <Alice fingerprint hash>\n> OP_EQUALVERIFY`\n>         * `OP_1 OP_CHECKSIGVERIFY OP_HASH160 <Bob fingerprint hash>\n> OP_EQUALVERIFY`\n>         * `OP_1 OP_CHECKSIGVERIFY OP_HASH160 <Charlie fingerprint>\n> OP_EQUALVERIFY`\n>\n> * Update Transaction\n>   * comment: this transaction initiates a unilateral close attempt.\n>   * comment: Updates have a \"hidden\" `n`, which is an \"update\" number\n> incrementing from 0.\n>     This number could be encoded as `nLockTime` by using `500e6 + n`, but\n> in principle does not need to be encoded there (we could use the current\n> encoding in Poon-Dryja, which is encrypted so that normal unilateral closes\n> do not reveal how many updates occurred).\n>   * Update transaction might have other inputs/outputs used to pay for\n> onchain fees.\n>   * input:\n>     * Funding transaction output\n>     * witness: one of the following, depending on which participant\n> initiated the unilateral close:\n>       * `<Alice fingerprint preimage> sign(MuSig(A normal, B normal, C\n> normal), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n>       * `<Bob fingerprint preimage> sign(MuSig(A normal, B normal, C\n> normal), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n>       * `<Charlie fingerprint preimage> sign(MuSig(A normal, B normal, C\n> normal), SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n>     * comment: which witness script appears onchain depends on which\n> participant initiated the unilateral close.\n>   * output:\n>     * Internal Taproot Key: `MuSig(A normal, B normal, C normal)`\n>     * Scripts:\n>       * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <MuSig(A normal, B normal,\n> C normal)> OP_CHECKSIG`\n>         * This is the \"normal\" unilateral path where the participant did\n> not steal any funds.\n>       * `<500e6 + n + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <MuSig(A lawyer, B\n> lawyer, C lawyer)> OP_CHECKSIG`\n>         * This is the \"litigation\" path where the participant is proven to\n> have stolen funds by showing a litigation transaction with later `n` than\n> the update transaction.\n>\n> * Friendly Settlement Transaction\n>   * comment: This transaction completes a unilateral close attempt and\n> publishes all contracts transported in the channel without revocability\n> branches.\n>   * `nSequence`: `<delay>`\n>   * input:\n>     * Update transaction output\n>     * witness: `sign(MuSig(A normal, B normal, C normal),\n> SIGHASH_ANYPREVOUTANYSCRIPT)`\n>   * outputs: unencumbered outputs for this state.\n>\n> * Litigation Transaction\n>   * comment: The appearance of this transaction onchain is taken as proof\n> that the unilateral close attempt is definitely a theft attempt.\n>     It can only be broadcast and confirmed if and only if the unilateral\n> close Update Transaction has an `n` that is less than the latest agreed `n`.\n>   * comment: A Litigation Transaction can be spent by another Litigation\n> Transaction with higher `n`.\n>     The intent is to force the current state onchain, in order to punish\n> the thief using the *latest* state instead of punishing from old state.\n>   * `nLockTime`: `500e6 + n`, where `n` is the update index for this\n> Litigation Transaction.\n>     * comment: a Litigation Transaction with `n` cannot spend an Update\n> Transaction of same `n`, only `n - 1` or less.\n>   * input:\n>     * Update transaction output *OR* another Litigation Transaction\n> output; Update/Litigation tx has `n` less than this Litigation transaction.\n>     * witness: `sign(MuSig(A lawyer, B lawyer, C lawyer),\n> SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_SINGLE)`\n>   * output:\n>     * Internal Taproot Key: `MuSig(A lawyer, B lawyer, C lawyer)`\n>     * scripts:\n>       * `<500e6 + n + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_1 OP_CHECKSIG`\n>         * comment: This allows a Litigation Transaction with later\n> `nLockTime` to spend this Litigation Transaction.\n>       * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <500e6 + n>\n> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_1 OP_CHECKSIG`\n>         * comment: This is the \"Hostile Settlement\" path that allows\n> revocation of outputs owned by the participant that initiated the\n> unilateral close.\n>\n> * Hostile Settlement Transaction\n>   * `nLockTime`: `500e6 + n`\n>   * input:\n>     * Litigation Transaction output\n>     * witness: `sign(MuSig(A lawyer, B lawyer, C lawyer),\n> SIGHASH_ANYPREVOUTANYSCRIPT)`\n>   * outputs:\n>     * Depending on type of contract, outputs are revocable:\n>       * Single-ownership contract (example below is Alice-owned)\n>         * Taproot Internal Key: `P = NUMS point` (cannot be spent via\n> non-Taproot path)\n>         * scripts:\n>           * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <A lawyer> OP_CHECKSIG`\n>             * comment: This lets Alice recover its funds if it is not the\n> thief.\n>           * `OP_0 OP_CHECKSEQUENCEVERIFY OP_DROP OP_HASH160 <Alice\n> fingerprint hash> OP_EQUALVERIFY <common key> OP_CHECKSIG`\n>             * comment: Alice fingerprint preimage is published if Alice is\n> the one who published the old Update Transaction.\n>               Any participant can take that preimage and re-publish it\n> here.\n>             * comment: the `0 OP_CHECKSEQUENCEVERIFY` ensures the spending\n> script has RBF enabled.\n>             * comment: we use the common key, and the requirement to\n> provide the Alice fingerprint preimage, *and* the requirement to enable\n> RBF, to force the output to be revoked to miners as fees: when the entire\n> output is given as fee, no higher RBF is possible.\n>               * comment: outputs may become too tiny to care about if we\n> split up a tiny reserve between dozens of honest participants.\n>                 But the important point is to punish the thief, not award\n> the honest participants.\n>               * comment: further, since the Litigation Transaction\n> *should* make valid the latest Hostile Settlement, the outputs of the\n> honest participants are at the latest state, already, so they cannot lose\n> funds by having the thief-owned outputs be revoked in favor of miners.\n>       * Dual-ownership contract (example below is an HTLC from Bob to\n> Charlie)\n>         * Taproot Internal Key: `P = NUMS point`\n>         * scripts:\n>           * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP <locktime>\n> OP_CHECKLOCKTIMEVERIFY OP_DROP <B lawyer> OP_CHECKSIG`\n>             * comment: Timelock branch, Bob reclaims money.\n>           * `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP OP_HASH160 <hash>\n> OP_EQUALVERIFY <C lawyer> OP_CHECKSIG`\n>             * comment: Hashlock branch, Charlie claims funds in exchange\n> for publishing payment preimage.\n>           * `OP_HASH160 <Bob fingerprint hash> OP_EQUALVERIFY <C lawyer>\n> OP_CHECKSIG`\n>             * comment: Revocation branch, Bob attempted to steal, so\n> Charlie gets the money outright.\n>           * `OP_HASH160 <Charlie fingerprint hash> OP_EQUALVERIFY <B\n> lawyer> OP_CHECKSIG`\n>             * comment: Revocation branch, Charlie attempted to steal, so\n> Bob gets the money outright.\n>         * Any two-participant contract can be made revocable by the same\n> pattern:\n>           * Use a NUMS point for taproot internal key.\n>           * Give every branch explicitly as a branch in the Taproot MAST;\n> prepend an additional `<delay> OP_CHECKSEQUENCEVERIFY OP_DROP`.\n>           * Add branches for revocation, where proof that one side\n> attempted to steal allows the other side to control the coin immediately.\n>         * Sub-channels will need to use `SIGHASH_ANYPREVOUTANYSCRIPT`, so\n> that signatures that can spend from an output of the Friendly Settlement\n> can also spend from an output of the Hostile Settlement (once the\n> additional encumberance has been passed).\n>\n> So, here are some changes to the original proposal:\n>\n> * We use a hash/preimage challenge to identify *who* attempted to steal.\n>   * The \"revocation key\" is the same as the \"fingerprint\".\n>     It is safe to publish the revocation key if you publish only the\n> latest Update Transaction, as the latest Update Transaction cannot enable\n> any Litigation Transaction.\n> * Single-ownership outputs of the current state are encumbered by a\n> revocability clause that revokes in favor of miners.\n> * Dual-ownership outputs of the current state are encumbered by a\n> revocability clause that revokes in favor of the non-thief participant if\n> one of the participants is the thief.\n> * Outputs with more than two owners are not supported by this construction.\n>\n> It was not very clear from the original proposal, but the Litigation\n> Transaction path ensures we can go to the latest state, and the Hostile\n> Settlement transaction represents the latest state, plus allowing\n> revocability of outputs in that state.\n> This behavior allows us to perform our punishments based on the latest\n> state, compared to Poon-Dryja which punishes based on the old published\n> state (which is simpler since it always just rewards the entire channel\n> funds to the honest party).\n>\n> The Friendly Settlement transaction does not allow any revocability, but\n> can only be published if no Litigation Transaction has been published.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190716/f4a61b21/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-07-16T18:34:00",
                "message_text_only": "Hi ZmnSCPxj,\n\n> Just a minor correction here: your own commitment transactions are not\n> being signed until we want to release them. Therefore having access to\n> your DB doesn't give an attacker the ability to frame the user with an\n> old version, since that'd still require access to the keys to add our\n> own signature.\n\nOkay, do you plan to handover keys to the watchtower to be able to sign and\nbroadcast local commitment\ntransactions or are you thinking about another design like giving him\nsigned commitment ? That's an area\nwe still need to think more for rust-lightning too.\n\n> And this signature is intended to be used to identify Alice as the\nculprit, by also being used to sign for <Alice key>, but `SIGHASH_ALL`\nwould strongly bind the signature to this particular transaction.\n\nOkay, you maybe also need a special pubkey type to force signatures to use\na given SIGHASH. that's a lot of tricks but\nthat could be a use-case for taproot introducing key types.\n\n> Now, an economically-maximizing thief would prefer to steal as much as\npossible, thus such a thief would initiate a channel, then send out funds\nuntil only 1% is left to the thief, then \"freeze\" the channel (fail all\nincoming HTLCs from this channel without bothering to check if they would\nsucceed) until the participant is offline, then perform the theft attempt\nby using their initial commitment (the one where they own all the funds in\nthe channel).\n\nI think it's quite dubious to base our reasoning on current network\nsituation and from then say on-chain fees in Eltoo model are enough\nto deter attackers (or even lazy parties). Channels are going to increase\nin size and people are learning how they are structured.\nWith more knowledge of timeout locks and deltas, attackers may try to game\nthem, specially by exploiting others elements\nlike mempool congestion or eclipse your onchain node. I see penalty as the\nprice the attacker have to pay to test your onchain monitoring setup.\nIf it's cheap and the probabilities to win are high, given he is able to\ntrouble confirmation of your update tx, a rational attacker will try.\n\n\"Still, a node could refuse incoming channel open requests for\nDecker-Russell-Osuntokun that are larger than 100 times the typical fee for\na 1-input 1-output transaction, and still get similar protection to\nPoon-Dryja using the de facto standard 1% reserve\"\n\nAnd maybe people are going to limit of their channels to stay in a multiple\nof onchain fees, but they may also refuse to open\nchannel with unknown or \"untrusted\" parties. Relying on economical\nincentives is better than social ones.\n\n> Such outputs have shared ownership, as the offerer of the HTLC will be\nable to reclaim the money after the timelock, and the accepter of the HTLC\nwill be able to reclaim the money before the timelock.\n\nYes, I think a contract design principle is that we should enforce an order\nof claims between different channel participants. In a\nmultiparty channel between Alice, Bob, Caroll and Dave, if Alice offered a\nHTLC to Bob and then cheats, if Bob come with a\npreimage to unlock the HTLC, his claim shouldn't be canceled by the\npunitive one raised by Bob, Caroll or Dave.\n\n\"I would argue that channel factories are better used than multiparticipant\nchannels, as channel factories allow *some* limited transport of funds even\nif one participant is offline, whereas multiparticipant channels prevent\n*all* transport of funds as soon as any one participant is offline\"\n\nI agree too, with my current proposal I was just thinking in multiparty\nsetup and not a 2-party one because it's far more\nadversarial. IMO, channel factories are a better design because I would say\nthe \"valuespace\" is well isolated between\nparticipants.I.e if Alice has 1, Bob has 1, Caroll has 3, Alice shouldn't\nbe able offer a HTLC worth 3 to Bob. It's more\ntricky to enforce on a multiparty channel rather than on a channel factory.\n\n> Let us consider what happens if Alice the thief performs the theft\nattempt during various states:\n> * Suppose the current state is that Charlie owns the entire funds of the\nchannel right now.\n> Alice steals by publishing old state, but the old-state Alice->Bob HTLC\nis revocable only by Bob.\n> Thus the money (that rightfully belongs to Charlie) goes to Bob instead.\n> * Alice and Bob could be in cahoots, with Bob as the mastermind and Alice\nas the fall guy.\n> * Suppose we decide that the Alice->Bob HTLC is revocable split by Bob\nand Charlie.\n> Suppose the current state is that Bob owns the entire funds of the\nchannel right now.\n>  Alice steals by publishing old state, but the old-state Alice->Bob HTLC\nis revocable split by Bob and Charlie.\n>  Thus the money (that rightfully belongs only to Bob) goes partly to\nCharlie instead.\n> * Alice and Charlie could be in cahoots, with Charlie as the mastermind\nand Alice as the fall guy.\n\nIf a HTLC output is claimable by both a preimage + sig from a channel\nparticipant or MuSig from all\nchannel participants to a punitive tx, the punitive tx may be encumbered by\nsome delay to let the\npreimage path being used first. I agree that may be tricky due to overlap\nbetween HTLC delay and this\nnSequence one. Easiest way is you don't punish on HLTC outputs, but that\nmean you need to keep\nhigher channel reserve.\n\n> So I think that, in terms of multiparticipant constructions, non-punitive\nconstructions are the only possible constructions.\n\nI think punitive constructions are possible on the channel syntax level but\nmay not make sense on the economic\ndue to higher funds being locked as channel reserve. This being balanced\nwith an increased rate of attack, in which\ncase you may want an higher insurance policy in the form of punitive\nprovisions on your channel dishearten cheat\nattempts. Hard to guess if and how much the network is going to be\nadversarial in 2 or 3 years..\n\nLe dim. 14 juil. 2019 \u00e0 20:12, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning list,\n>\n> I had another realization about the use of punishment in a\n> multiparticipant (n > 2) setting.\n> And it has to do with contracts that have a sort of \"shared ownership\".\n>\n> Consider HTLC outputs.\n> Such outputs have shared ownership, as the offerer of the HTLC will be\n> able to reclaim the money after the timelock, and the accepter of the HTLC\n> will be able to reclaim the money before the timelock.\n>\n> Suppose we know that Alice cheated.\n> Suppose also that Bob offered an HTLC to Alice with a hash whose preimage\n> Alice secretly knows, and that Alice offered an HTLC to Charlie with a long\n> future lock time with a hash that Alice secretly knows has a high\n> probability that nobody knows the preimage.\n>\n> How should Bob and Charlie split the HTLCs?\n> If we do not punish the HTLCs, then Alice can arrange such that most of\n> her money is in HTLCs that she can recover, and thereby avoid punishment.\n> If we *do* punish the HTLCs, we would have to make the Bob->Alice\n> revocable only in favor of Bob, and make the Alice->Carol revocable only in\n> favor of Charlie.\n>\n>\n> This ties to constructions such as Channel Factories.\n> I would argue that channel factories are better used than multiparticipant\n> channels, as channel factories allow *some* limited transport of funds even\n> if one participant is offline, whereas multiparticipant channels prevent\n> *all* transport of funds as soon as any one participant is offline.\n> At the same time, channel factories allow arbitrary transport of funds\n> between any participants inside the factory if all participants are online:\n> if a channel is exhausted, but the paying participant has funds elsewhere,\n> the paying participant can initiate a channel reorganization and move funds\n> to the exhausted channel.\n>\n> Channel factories host channels.\n> Channels are shared-ownership UTXOs, in much the same way that HTLCs are\n> shared-ownership UTXOs.\n>\n> Thus, if we will use this construction to implement channel factories,\n> channels inside the factory should be punished by transferring the funds to\n> the other participant of the channel.\n>\n> However, things can get more complicated as the states inside the\n> construction change over time.\n>\n> --------\n>\n> Let us return to the HTLC example.\n>\n> Suppose there exists an Alice->Bob HTLC in the old state that Alice the\n> thief publishes, and that the entire value of the construction is in that\n> HTLC.\n>\n> Let us consider what happens if Alice the thief performs the theft attempt\n> during various states:\n>\n> * Suppose the current state is that Charlie owns the entire funds of the\n> channel right now.\n>   Alice steals by publishing old state, but the old-state Alice->Bob HTLC\n> is revocable only by Bob.\n>   Thus the money (that rightfully belongs to Charlie) goes to Bob instead.\n>   * Alice and Bob could be in cahoots, with Bob as the mastermind and\n> Alice as the fall guy.\n> * Suppose we decide that the Alice->Bob HTLC is revocable split by Bob and\n> Charlie.\n>   Suppose the current state is that Bob owns the entire funds of the\n> channel right now.\n>   Alice steals by publishing old state, but the old-state Alice->Bob HTLC\n> is revocable split by Bob and Charlie.\n>   Thus the money (that rightfully belongs only to Bob) goes partly to\n> Charlie instead.\n>   * Alice and Charlie could be in cahoots, with Charlie as the mastermind\n> and Alice as the fall guy.\n>\n> It seems to me, that punishment systems can only work if one of the\n> following are true:\n>\n> * 2 participants, which prevents channel factory scaling.\n> * OR, no smart contracts (HTLCs or subchannels), which prevents channel\n> factory scaling, **and** network/routing scaling.\n>\n> So I think that, in terms of multiparticipant constructions, non-punitive\n> constructions are the only possible constructions.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190716/61015baf/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-07-16T17:04:20",
                "message_text_only": "Hi ZmnSCPxj,\n\nDeep thanks for your review.\n\nBiggest gains with Eltoo are of course transaction symmetry and removing\ntoxic waste. Reintroducing penalty on top of\nthis shouldn't affect this two goals, that's why I'm trying to play with\nwitnesses asymmetry and signatures committed\nto a state number with my proposal\n\n> In particular, it seems to me that it would be trivial for Alice to avoid\npunishment by first creating a fake \"Mallory\", then taking whatever path\nwould let Alice \"off the hook\" for a framing Mallory when at risk of\ngetting caught, thus returning the \"reduced cost for trying to steal\nchannel funds\".\n\nBy creating a fake \"Mallory\" you mean being another party in the channel ?\nWith current design to kick-off unilateral\nclosing you need to reveal your signature to spend the funding output to\nthe Update tx, so you can't equivocate after\nfirst step. You can be both Alice and Bob, try to cheat with Alice and\ndon't broadcast Litigation as Bob, if Caroll is\nhonest she should be able to punish you on Alice funds.\n\n> Could a hash preimage be used instead, with revocation?\n> We would require that the hash preimage be unique per-update, but the\nsame technique used in current Poon-Dryja (Russell shachain) can be used to\nstore the preimages of revoked states.\n\nThere is few issues with preimages, if you use per-update preimages, you\nneed to keep a Hostile Settlement tx for\nevery update because preimages are paired with a given Hostile Settllement\ntx and can't be used to punish on any Hostile\nSettlement tx. Plus, in multiparty channels, Hostile Settlement tx at state\nN - 2, doesn't reflect the correct balance between\nhonest participants at state N. If you go with one unique preimage, which\nstays the same for every update, you're not safe\nagainst reorg or mempool snooping, where a malicious party take your\npreimage and replays it on a lower state Update tx.\n\n> I am uncertain if some of the alignment has gotten lost above, but\ncurrently your graph is somewhat confusing.\n\nFriendly Settlement Tx must spend the Update Tx after some delay.\nWe have one Challenge Tx per-party and it must spend the to_party output on\nHostile Settlement Tx.\n(transactions graph by mail are an uncertain art, sorry about that)\n\n> This branch seems pointless --- could you not just use the non-taproot\npath?\n> You do not describe the friendly-settlement transaction anywhere.\n> Is the friendly-settlement have `nSequence` delay?\n> When is it created?\n\nOh you're right, you can use the taproot key spend path there.\nFriendly Settlement transaction is spending the Update tx and supports one\noutput per party as return fund and\nHTLC outputs for every pending one. E.g to_Alice output is just encumbered\nby a Alice pubkey and HTLC outputs\nhave timeout/preimage_fulfill branches. None of these outputs is encumbered\nby a punishment path.\nIt should be created with every Update tx, it's symmetric for every channel\nparty and yes should have nSequence\nset to some delay to let someone broadcast a Litigation tx on the Update tx.\n\n> It looks to me that you cannot use a later update transaction to replace\nan older update transaction, as the shared signature does not use\n`SIGHASH_ANYPREVOUT`?\n\nYes that's intentional, IMO a current flaw of Eltoo is if you share an\nUpdate tx with watchtowers, any of them can close\nthe channel on your behalf, of course if at least one of them is honest it\nwill broadcast the latest Update tx and your funds\nare safe minus transaction fees. But you have lost a channel. Splitting\nunilateral channel closing and enforcement of correct\nstate on two different transactions should avoid this issue. Know you just\ngive the Justice tx to everyone of your watchtower\nand keep the Update tx on your local client. If you don't have HTLCs in the\nflight that should be secure.\n\n> You mentions later that \"if anyone has a highest Litigation tx, he can\nuse it\", but it does not look like that the litigation script path enforces\nthis, did you forget to add some `OP_CHECKLOCKTIMEVERIFY` here?\n\nOh yes, thanks again I forgot to add an OP_CLTV in litigation script path.\n\n> `P` here is `muSig(A,B,C)`?\n> Why would Alice willingly sign a `SIGHASH_ALL` signature (meaning the\ntransaction IDs are known at this point and have been confirmed deeply\nonchain, so this is after Alice has gone and performed any attempts at\ntheft) that would punish her?\n> What happens when the Litigation Tx is later than the initial Update Tx?\n\nYes P is muSig(A,B,C).\nIf she has misbehaved, she is not going to be willingly to sign the\nChallenge tx, and let anyone use the signature comparison as\na proof of cheat. So you're again right, a timelocked script spend path\nshould be added on the to_Alice output where after some\ndelay any honest channel party can spend it with the Justice tx.\nAt initial state, there shouldn't be any Litigation tx, if you have a\nLitigation tx with a highest state number than an Update tx\nit means the Update tx has been revoked (and shouldn't be broadcast).\n\n> Maybe this should instead be a revocation key whose privkey Alice reveals\nas part of the update ritual?\n\nHmmm I think if it's a private key revealed at update ritual, it means\nanyone can use it to spend the funding_output while\ncounterfeiting being Alice.\n\n> If a later Litigation Tx is used, than the Update Tx that was put\nonchain, is the signature from the Update Tx valid on the same transaction\nwhere the Challenge Tx is valid?\n\nMain idea of this scheme is to used Per-Update Commitment to solve the\nassignment problem in a safe way. What we need\non a higher-level are messages tied to a specific party and committed to a\ngiven state number. If anyone can prove to the\nblockchain you have broadcast 2 messages with different state number it\nmeans you breach the contract.\n\nNow how to do that with Script ? Only messages interpreted by the\nblockchain are bitcoin transactions.\n\nIf we follow Taproot current transaction digest algorithm, without sighash\nflags set, assuming we spend a taproot output\nwe have the following hashed elements : epoch, hash_type, nVersion,\nnLockTime, sha_prevouts, sha_amounts,\nsha_sequences, sha_outputs, spend_type, input_index, sha_annex.\n\nIf we use SIGHASH_ANYPREVOUTANYSCRIPT + SIGHASH_NONE, we get the following\nhashed elements :\nepoch, hash_type, nVersion, nLocktime, spend_type, amount, nSequence,\nsha_annex.\n\nIf we force to sign 2 different transactions with these both sighashes\nagainst same pubkey, and assuming there are\nspending the same amount and nSequences are equals, we should get identical\nsignatures. If they are not,\nthe only difference element is the nLocktime.\n\nThat could be a way to make script aware of committed per-party state\nnumber.\n\nUsing this in a Eltoo-Penalty scheme, the Challenge tx script is encumbered\nby a branch where if you show up\nwith 2 valid signatures but non-identical, that's a proof the challenged\nparty has tried to cheat. Of course, I guess\nyou need a bit of expansion on script primitives, like\nSIGHASH_ANYPREVOUTANYSCRIPTANYAMOUNT and\nan  OP_CHECKSIG_WITH_STATE_NUMBER with following syntax <sig>\n<state_number> <pubkey> OP_CSWSN\nand following semantic \"verify this signature against this pubkey but first\nmask nLocktime of transaction with the\nsecond-to-top stack item\". Because signatures need to be both valid on same\ntransaction but they have committed\nto different nLocktime, Justice tx need to have a mutable nLocktime field\nat verification.\n\nI didn't think about the need of something like OP_CSWSN in first mail,\nsome people pointed me the issue, so here\nthe updated scripts.\n\nCHALLENGE TX: (Alice case)\nnLocktime: 500e6n\nnSequence: 0\noutput 0:\nP = muSig(A,B,C)\nscripts = [\n\"OP_1 CHECKSIGVERIFY OP_DUP <2> OP_ROLL <Alice_key>\nCHECKSIGVERIFY_WITH_STATE_NUMBER\nOP_SWAP OP_DUP <3> OP_ROLL <Alice_key> CHECKSIGVERIFY_WITH_STATE_NUMBER\nOP_EQUAL\nOP_NOT OP_VERIFY\"  (proof-of-Alice-fraud script path)\n\"<n> OP_CSV <Alice refund_key> (refund Alice script path)\n ]\n witness:\n\"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=ALL)\"\n\nJUSTICE TX: (Alice punishment)\nnLocktime: 500e6n\nnSequence: 0\noutput 0: (to_Caroll)\noutput 1: (to_Bob)\nwitness:\n\"<state_number_update_tx> <sig_Alice_from_update_tx>\n<state_number_challenge_tx>\n<sig_Alice_from_challenge_tx> <sig(P, hash_type=ALL)>\"\n\nTo say it again, it's more a thought experiment, so if you hold so far, I\nthank you again :)\n\nBest,\nAntoine\n\n\nLe dim. 14 juil. 2019 \u00e0 00:48, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning Atoine,\n>\n> Thank you for your proposal.\n>\n> > Eltoo has been criticized to lower the cost for a malicious party to\n> > test your monitoring of the chain. If we're able to reintroduce some\n> > form of punishment without breaking transaction symmetry that would be\n> great.\n>\n> The primary advantage of Decker-Russell-Osuntokun is that it eliminates\n> \"toxic waste\".\n>\n> By this we mean, older version of your channel database are \"toxic\" in\n> that you, ***or someone who wants to attack you***, can use it\n> (accidentally in your case, deliberately in the attacker case), and then\n> you will lose all funds in the channel.\n>\n> Note that access to your channel database, without necessarily accessing\n> your node private keys, is often easier.\n> For example, C-Lightning stores channel data into an SQLITE database and\n> exposes every transaction it makes to a `db_hook` that plugins can use to\n> replicate the database elsewhere.\n> If you were to use an insufficiently secured plugin to replicate your\n> database, an attacker might be able to access your channel data, replicate\n> your database, and use an older version to frame you for theft and make you\n> lose all your channel funds.\n>\n> Thus, Decker-Russell-Osuntokun removes the punitive consideration so that\n> you being framed for theft does not lose all your funds, it merely closes\n> your channels.\n>\n> However, it look to me that you attempt to fix the toxic waste issue, as\n> you mention a \"Mallory\" later that attempts to frame Alice (possibly by\n> broadcasting old state).\n> On the other hand, it seems, there is no description of how Alice might go\n> about protecting herself from Mallory.\n>\n> In particular, it seems to me that it would be trivial for Alice to avoid\n> punishment by first creating a fake \"Mallory\", then taking whatever path\n> would let Alice \"off the hook\" for a framing Mallory when at risk of\n> getting caught, thus returning the \"reduced cost for trying to steal\n> channel funds\".\n>\n> >\n> > Transaction symmetry implies that we can't deduce from observing\n> > txid which party broadcast a previous state. How to assign the\n> > faulty broadcast to the right party to punish it in consequence ?\n> > Thanks to taproot we have cheap witness asymmetry.\n> > Witness asymmetry can be used as a way to force the broadcaster to reveal\n> > a secret, and so committing thatn the transaction is the latest one.\n> >\n> > If the party misbehaves, we wish to use the revealed secret to punish\n> > him on a second stage transaction. Doing so would be really insecure\n> > in case of reorg or even mempool monitoring by enabling a replay attack\n> > of your committed secret on a lower state update tx. i.e Mallory\n> > would counterfeit being Alice, and so enable the use of a punishment tx\n> > against an honest peer.\n> >\n> > To solve the assignment problem, we need to have per-update credentials,\n> > a secret committed to a state number. You need a scheme were both your\n> > highest credential can't be used against you while at the same time if\n> some\n> > attacker broadcast a transaction with a lower credential you are able to\n> > punish him.\n> >\n> > How to make Bitcoin Script aware of a secret committed to\n> > a lower state number ? To do so, we may use some SIGHASH magic, if you\n> sign\n> > two messages with the same key and we can be sure thatn the only\n> difference between\n> > them is the nLocktime (encoding the state-number in eltoo), that means\n> you\n> > tried to breach the contract.\n>\n> Could a hash preimage be used instead, with revocation?\n> We would require that the hash preimage be unique per-update, but the same\n> technique used in current Poon-Dryja (Russell shachain) can be used to\n> store the preimages of revoked states.\n>\n> >\n> > Without access to arbitrary messages on the stack, the only messages we\n> can\n> > enforce signatures on are Bitcoin transactions. We force a party\n> > broadcasting an Update tx to sign it with\n> > SIGHASH_ANYPREVOUTSCRIPT|SIGHASH_NONE|SIGHASH_SINGLE. If someone can\n> shows a\n> > Litigation Tx with a higher state than the Update, we know that this one\n> has\n> > been revoked, and someone is cheating among channel parties. We enter in\n> a\n> > Litigation phase, the Settlement Tx will be encumbered by a Challenge Tx\n> against\n> > which you will need to produce a signature with the same SIGHASH flags\n> as the Update Tx.,\n> > The only difference will be the nLocktime inherited from Litigation.\n> >\n> > Assume Alice is trying to cheat, now Bob can take the signature from her\n> broadcast Update tx\n> > and Alice\u2019s signature on the Challenge tx, pass it as witness to a\n> script verifying their validity\n> > and identity. If their validity is true and identity is false, you can\n> spend with a Justice tx,\n> > splitting Alice\u2019s funds between the other parties. If validity is true\n> and identity is true, then the script should fail. After timelock\n> expiration, if no one has proven Alice misbehaved,\n> > she can redeem her funds.\n> >\n> > Eltoo-Penalty Transaction Tree\n> > ==============================\n> >\n> >\n> >                                Friendly Settlement Tx\n>                     Challenge Tx -- Justice Tx\n> >                                  /\n>                             /\n> >                                 /\n>                            /\n> > Funding-Output -- Update Tx -- Litigation Tx -- .. -- Hostile Settlement\n> Tx --  Challenge Tx -- Justice Tx\n> >\n>                           \\\n> >\n>                            \\  Challenge Tx -- Justice Tx\n> >\n>\n> I am uncertain if some of the alignment has gotten lost above, but\n> currently your graph is somewhat confusing.\n>\n> > Eltoo-Penalty Scripts\n> > ================\n> >\n> > (I've omitted chaperon signatures)\n> >\n> > FUNDING_OUTPUT:\n> > output 0:\n> > Q = P + tG\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECKSIGVERIFY <Alice_key> CHECKSIGVERIFY\" (Alice script path)\n> > \"OP_1 CHECKSIGVERIFY <Bob_key> CHECKSIGVERIFY\" (Bob script path)\n> > \"OP_1 CHECKSIGVERIFY <Caroll_key> CHECKSIGVERIFY\" (Caroll script path)\n> > ]\n> >\n> > UPDATE TX:\n> > nLocktime: 500e6 + n\n> > output 0:\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECKSIGVERIFY\" (friendly settlement script path)\n>\n> This branch seems pointless --- could you not just use the non-taproot\n> path?\n> You do not describe the friendly-settlement transaction anywhere.\n> Is the friendly-settlement have `nSequence` delay?\n> When is it created?\n>\n>\n> > \"OP_1 CHECKSGIVERIFY 500e6+n OP_CLTV OP_DROP\" (litigation script path)\n> > witness:\n> > \"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P,\n> hash_type=SINGLE)\"  (Alice commitment signature)\n> > \"sig(B, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P,\n> hash_type=SINGLE)\"  (Bob commitment signature)\n> > \"sig(C, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P,\n> hash_type=SINGLE)\"  (Caroll commitment signature)\n>\n> It looks to me that you cannot use a later update transaction to replace\n> an older update transaction, as the shared signature does not use\n> `SIGHASH_ANYPREVOUT`?\n>\n> >\n> > LITIGATION TX:\n> > nLocktime: 500e6 + n\n> > nSequence: [delay]\n> > output 0:\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECKSIG\" (litigation script path)\n> > \"OP_1 CHECKSIGVERIFY\" (hostile settlement script path)\n> > witness:\n> > \"sig(P, hash_type=SINGLE|ANYPREVOUTANYSCRIPT)\n>\n> You mentions later that \"if anyone has a highest Litigation tx, he can use\n> it\", but it does not look like that the litigation script path enforces\n> this, did you forget to add some `OP_CHECKLOCKTIMEVERIFY` here?\n>\n> >\n> > HOSTILE SETTLEMENT TX:\n> > nLocktime: 0\n> > nSequence: [delay]\n> > output 0: (to_Alice)\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECHSIGVERIFY <Alice_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\"\n> (Alice challenge script path)\n> > ]\n> > output 1: (to_Bob)\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECHSIGVERIFY <Bob_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\"\n> (Bob challenge script path)\n> > ]\n> > output 2: (to_Caroll)\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECHSIGVERIFY <Caroll_key> CHECKSIGVERIFY 500e6n OP_CLTV OP_DROP\"\n> (Caroll challenge script path)\n> > ]\n> > output N (pending HTLCs)\n> > witness:\n> > \"sig(P, hash_type=ALL)\n> >\n> > CHALLENGE TX: (Alice case)\n> > nLocktime: 500e6n\n> > nSequence: 0\n> > output 0:\n> > P = muSig(A,B,C)\n> > scripts = [\n> > \"OP_1 CHECKSIGVERIFY OP_DUP <Alice_key> CHECKSIGVERIFY OP_DUP OP_SWAP\n> <Alice_key> CHECKSIGVERIFY\n> >     OP_EQUAL OP_NOT OP_VERIFY\"  (proof-of-Alice-fraud script path)\n> > \"<n> OP_CSV <Alice refund_key> (refund Alice script path)\n> > ]\n> > witness:\n> > \"sig(A, hash_type=SINGLE|ANYPREVOUTANYSCRIPT|NONE) sig(P, hash_type=ALL)\"\n> >\n> > JUSTICE TX: (Alice punishment)\n> > nLocktime: 500e6n\n> > nSequence: 0\n> > output 0: (to_Caroll)\n> > output 1: (to_Bob)\n> > witness:\n> > \"sig_Alice_from_update_tx sig_Alice_from_challenge_tx sig(P,\n> hash_type=ALL)\"\n>\n> `P` here is `muSig(A,B,C)`?\n> Why would Alice willingly sign a `SIGHASH_ALL` signature (meaning the\n> transaction IDs are known at this point and have been confirmed deeply\n> onchain, so this is after Alice has gone and performed any attempts at\n> theft) that would punish her?\n> What happens when the Litigation Tx is later than the initial Update Tx?\n>\n> Maybe this should instead be a revocation key whose privkey Alice reveals\n> as part of the update ritual?\n>\n> If a later Litigation Tx is used, than the Update Tx that was put onchain,\n> is the signature from the Update Tx valid on the same transaction where the\n> Challenge Tx is valid?\n>\n>\n> Explicitly stating what transaction outputs are spent by each transaction\n> input would be better, especially since your graph is unclear.\n>\n>\n> >\n> > State Update\n> > ============\n> >\n> > Alice, Bob and Caroll build new friendly Settlement tx N, new Update Tx\n> and revoke old one by\n> > generating a Justice tx with state higher than the previous one, a\n> hostile Settlement tx plus\n> > Y challenge txn and Y justice txn with Y number of parties.\n>\n> You do not describe the friendly settlement transaction.\n> I assume it has some `nSequence` somewhere.\n>\n> >\n> > Cooperative Case\n> > ================\n> >\n> > After X updates, Alice, Bob, Caroll, cooperate to closing transaction\n> using key path\n> > spending of funding Taproot output, the spending transactions contains\n> accurate balances.\n> >\n> > Unilateral Case\n> > ================\n> >\n> > After X updates, Alice broadcast the last Update tx N, by signing it\n> with her private key with\n> > SIGHASH_NONE,SIGHASH_ANYPREVOUTANYSCRIPT,SIGHASH_SINGLE and use MuSig\n> previously distributed\n> > between parties at state update. Her signature doesn't protect anything\n> except commitment to\n> > the latest state number.\n> >\n> > After finalization of the friendly settlement tx, she can redeem her\n> balance, and timeout/fulfill\n> > her outputs.\n> >\n> > If she has broadcast the latest state, none of the parties should be\n> able to broadcast a Litigation\n> > tx with a highest state number. Her signature committing to the\n> locktime, no one is able to\n> > counterfeit her identity by spending the funding taproot output with a\n> lowest update tx.\n> >\n> > Malicious Case\n> > ==============\n> >\n> > Bob is broadcasting a lowest Update tx with his signature committing to\n> it. Alice use Litigation tx\n> > to spend it, if anyone has a highest Litigation tx, he can use it. After\n> Litigation tx finalization,\n> > hostile settlement transaction is used. Each output returning to a\n> channel party, is encumbered\n> > by a \"challenge\". To unlock your funds, you must provide a signature\n> against same pubkey and same\n> > SIGHASH flags than the one encumbering your tapscript for funding output.\n> >\n> > Challenge tx is using a taproot output, one leaf returning fund to Alice\n> after some timelock,\n> > The other one, let anyone with a MuSig and two valid signatures\n> committing to different nLocktime\n> > to send challenged fund to a Justice tx, doing an equal split between\n> other channel parties.\n> >\n> > You need signatures to be safe against third-party malleability, i.e\n> being able to tweak\n> > your signatures to be still valid but diff being interpreted as a proof\n> of commitment on lowest state number. On the Justice tx, you need a new key\n> type to enforce that every signature must have sighash\n> SIGHASH_MASKLOCKTIMEWITH, where you expect the signature to be followed by\n> the state number which is going to be used as locktime in transaction\n> digest algorithm. So in this way state number are provided in witness and\n> you can equivocate Justice tx as both revoked Update Tx and Challenge Tx.\n> >\n> > Okay, I'm quite sure that Script gurus on this list are going to point\n> flaws of this scheme.\n> > It's more a thought experiment and I was curious if anyone has other\n> ideas to get Eltoo + penalties,\n> > if yes let it know !\n>\n> The descriptions of the transactions and scripts involved are confusing\n> and I am uncertain if you actually achieve your target.\n> Could you clarify?\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190716/809b038a/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-17T04:35:13",
                "message_text_only": "Good morning Antoine,\n\n\n> Biggest gains with Eltoo are of course transaction symmetry and removing toxic waste. Reintroducing penalty on top of\n> this shouldn't affect this two goals,\n\nI agree with Christian that introducing penalty introduces toxic waste.\nInadvertent misuse of a backup of an old database will still result in punishment.\nIndeed, this is part of the toxic waste problem: operator error can lead to loss of funds.\n\n> > If a later Litigation Tx is used, than the Update Tx that was put onchain, is the signature from the Update Tx valid on the same transaction where the Challenge Tx is valid?\n>\n> Main idea of this scheme is to used Per-Update Commitment to solve the assignment problem in a safe way. What we need\n> on a higher-level are messages tied to a specific party and committed to a given state number. If anyone can prove to the\n> blockchain you have broadcast 2 messages with different state number it means you breach the contract.\n>\n> Now how to do that with Script ? Only messages interpreted by the blockchain are bitcoin transactions.\n>\n> If we follow Taproot current transaction digest algorithm, without sighash flags set, assuming we spend a taproot output\n> we have the following hashed elements : epoch, hash_type, nVersion, nLockTime, sha_prevouts, sha_amounts,\n> sha_sequences, sha_outputs, spend_type, input_index, sha_annex.\n>\n> If we use SIGHASH_ANYPREVOUTANYSCRIPT + SIGHASH_NONE, we get the following hashed elements :\n> epoch, hash_type, nVersion, nLocktime, spend_type, amount, nSequence, sha_annex.\n>\n> If we force to sign 2 different transactions with these both sighashes against same pubkey, and assuming there are\n> spending the same amount and nSequences are equals, we should get identical signatures. If they are not,\n> the only difference element is the nLocktime.\n>\n> That could be a way to make script aware of committed per-party state number.\n>\n> Using this in a Eltoo-Penalty scheme, the Challenge tx script is encumbered by a branch where if you show up\n> with 2 valid signatures but non-identical, that's a proof the challenged party has tried to cheat. Of course, I guess\n> you need a bit of expansion on script primitives, like SIGHASH_ANYPREVOUTANYSCRIPTANYAMOUNT and\n> an\u00a0 OP_CHECKSIG_WITH_STATE_NUMBER with following syntax <sig> <state_number> <pubkey> OP_CSWSN\n> and following semantic \"verify this signature against this pubkey but first mask nLocktime of transaction with the\n> second-to-top stack item\". Because signatures need to be both valid on same transaction but they have committed\n> to different nLocktime, Justice tx need to have a mutable nLocktime field at verification.\n>\n> I didn't think about the need of something like OP_CSWSN in first mail, some people pointed me the issue, so here\u00a0\n> the updated scripts.\n\nThis requires adding more at the base layer, which is much more strongly contentious (at the Lightning layer you can arrange to use whatever construction you want with your peer, and in general still be able to route, except that with anything other than Poon-Dryja channels also have a minimum CSV delay that needs to be considered by the source).\n\nAt what little I understand there is not much consensus yet at Bitcoin blockchain layer to add *any* vsriant of `SIGHASH_NOINPUT` yet.\nBut now this construction requires, in addition to `SIGHASH_NOINPUT`:\n\n* Pubkeys that require specific `SIGHASH` flags in their signature.\n* A way to validate that a particular signature commits to a particular `nLockTime`.\n\nThe only advantage this construction has on top of Poon-Dryja is the ability to have 3 or more participants.\nThe disadvantages relative to Poon-Dryja are:\n\n* A CSV restriction on routed HTLCs.\n* Needs *much* more to be added to the blockchain, including 1 controversial feature (admittedly has a reasonable chance of appearing in some form) and 2 completely new features (which will need to be very strongly reviewed in bitcoin-dev and elsewhere first).\n\n---\n\nNow I believe you agree that channel factories are better:\n\n> \"I would argue that channel factories are better used than multiparticipant channels, as channel factories allow *some* limited transport of funds even if one participant is offline, whereas multiparticipant channels prevent *all* transport of funds as soon as any one participant is offline\"\n>\n> I agree too\n\nSo let me counterpropose instead:\n\n* Use Decker-Wattenhofer (mostly the multiple-stage decrementing `nSequence` part, drop the duplex Spilman-like channels) or Decker-Russell-Osuntokun (\"eltoo\") at the Factory level.\n  * Do not allow participants to hold a singlesig output at the Factory level, all states at this level should have only 2-of-2s that back channels.\n* Use Poon-Dryja at the Channel level for all channels inside the factory.\n\nThis prevents thieves from *practically* stealing with old factory-level state, since the funds are still in individual Poon-Dryja channels.\n\nWhen you reorganize a channel (change its total balance) during a factory-level update, you go about things this way.\n\n1.  Sign new commitment transactions for the modified channels, spending the post-modified amount of the channel.\n    (assume we use `SIGHASH_NOINPUT` in the Poon-Dryja commitment txes, to avoid the \"stale factory problem\" for channels that are not modified in the factory-level update)\n2.  Sign the new factory-level update and settlement transactions (assuming we use Decker-Russel-Osuntokun).\n3.  Revoke the previous commitment transactions of the modified channels (the ones that spent from the pre-modified amounts).\n\nIf this aborts after step 1, the new commitment transactions cannot be used since the latest factory output values will not match the values expected by the new commitment transactions.\n\nIf this aborts after step 2, the individual channels that were modified will be \"frozen\" (cannot add/fail/fulfill HTLCs) until both sides have performed step 3.\nIf the freeze lasts long enough to reach HTLC locktimes, then this forces a unilateral close of the entire factory and all its channels.\n\nWith this, an attacker that wants to steal using an older factory state would still contend with the fact that channels that have been modified since that state will have had their latest transaction revoked, thus will lose all their funds there.\nAnd as long as each individual Poon-Dryja channel has a reserve, there is still some money that each participant will be risking losing.\n\nIn short: replaying old factory state is pointless since the thief still has to contend with the individual channel-level punishments.\n\nThis returns punishment while still allowing channel factory scaling, which is the important thing we *actually* want (the goal of transaction symmetry is aesthetic, but not useful), at the cost of returning toxic waste.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Using Per-Update Credential to enable Eltoo-Penalty",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Antoine Riard",
                "ZmnSCPxj"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 95936
        }
    },
    {
        "title": "[Lightning-dev] [PROPOSAL] Gossip protocol v2",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-07-14T01:38:06",
                "message_text_only": "Hi all,\n\n        At the last Summit we discussed using Schnorr sigs for gossip;\nwe'll also need to change things for taproot-based channels, so I think\nit makes sense to combine the two changes.\n\nchannel_announcement drops from 430 to 140 (plus feature bitmap).\nchannel_update drops from to 136 to ~100 (assuming min & max specified)\nnode_announcement drops from 140 to >= 101 (plus alias, color, addresses).\n\nHere's a rough draft based on what I think we've learned from current\ngossip:\n\n1. Optional fields are move into TLVs.\n2. chain_id is moved into a TLV, with bitcoin mainnet being default.\n3. Timestamp should be a block number.\n\nThis final rule gives natural ratelimiting: you can only add one update\nper block.  SHOULD not use a block number from the last 60 seconds,\nSHOULD use previous block number to allow for emergency updates, SHOULD\nmake bottom bit different from the previous update.\n\nThis plays much better with minisketch encoding, since even if we reduce\ntimestamp to 1 bit[1], propagation will Mostly Work.\n\nFinally, it provides an implicit timestamp to channel_announcement,\nwhich avoids the current dance we have to do (for the purposes of\ntimestamp filtering, the timestamp for channel_announcement is taken\nfrom a channel_update).\n\nStrawmen below:\n\n1. type: 267 (`channel_announcementv2`)\n2. data:\n    * [`signature`:`musig_combo_signature`]\n    * [`short_channel_id`:`short_channel_id`]\n    * [`point`:`node_id_1`]\n    * [`point`:`node_id_2`]\n    * [`tlvs`:`channel_announcementv2_tlvs`]\n\n- Where musig_combo_signature is the signature of the rest of the\n  message using the node_ids and the bitcoin key.\n- The bitcoin key can be read directly from the outpoint referred to\n  by `short_channel_id`.\n- One tlv record will be chain_id, the default being bitcoin mainnet.\n- Another will be for feature bits.\n- The timestamp is implicitly the block number + 6, see below.\n\n1. type: 269 (`node_announcementv2`)\n2. data:\n    * [`signature`:`signature`]\n    * [`u32`:`timestamp`]\n    * [`point`:`node_id`]\n    * [`tlvs`:`node_announcementv2_tlvs`]\n\n- timestamp is simply a block number.\n- tlvs contain optional alias, color.\n- separate (odd) tlv types for each of IPv4/v6/Tor2/Tor3, length shows\n  if it encodes multiple addresses.\n\n1. type: 271 (`channel_updatev2`)\n2. data:\n    * [`signature`:`signature`]\n    * [`short_channel_id`:`short_channel_id`]\n    * [`u32`:`timestamp`]\n    * [`byte`:`channel_flags`]\n    * [`u16`:`cltv_expiry_delta`]\n    * [`u32`:`fee_base_msat`]\n    * [`u32`:`fee_proportional_millionths`]\n    * [`tlvs`:`channel_updatev2_tlvs`]\n\n- timestamp is a block number.\n- channel_flags is direction and disable, as now.\n- tlvs contains optional htlc_min_msat, htlc_max_msat, chain_hash (if\n  not bitcoin mainnet).\n\nCheers,\nRusty.\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-December/001741.html"
            }
        ],
        "thread_summary": {
            "title": "Gossip protocol v2",
            "categories": [
                "Lightning-dev",
                "PROPOSAL"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2856
        }
    },
    {
        "title": "[Lightning-dev] Congestion and Flow control for Multipath Routing",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-07-15T12:23:18",
                "message_text_only": "Dear fellow BOLT devs,\n\nin this mail I want to suggest a congestion and flow control mechanism to\nimprove the speed and reliability of multi path routing schemes. This is\nthe first of a couple of emails that I will write in the following weeks as\nI have used my break in hospital not only to recover but to tinker quite\na bit about path finding and routing algorithms on the lightning network.\n\nProblem statement\n===============\nCurrently on the lightning network we have the issue of stuck payments [0].\nAs soon as an onion is sent it is out of the sender's control. This problem\nseems to be in particular drastic if we wish to use Atomic Multi Path\nrouting [1] (which in the described form is not compatible with my\nproposal. I believe my proposal should be compatible with the status quo of\nbase-AMP). The entire payments and HTLCs of a multipath payment will only\nbe settled once enough incoming HTLCs arrived at the recipient (meaning the\nsum of amounts is bigger or equal to the amount specified in the invoice).\nThis has the following list of downsides:\n\n- One malicious actor (who is just not forwarding the onion but also not\nsignaling an error) is enough to interrupt the entire payment process and\nfreeze all other HTLCs even of partial payments the actor is not part of.\n- The entire payment process takes as long as `max_{p \\in paths}(t(p))`\nwhere `t(p)` is the time it took for path `p` to set up (and settle) HTLCs\n- More HTLCs will be reserved by the network for a longer time. This means\nmore liquidity is bound / reserved and channels could even become unusable\nif the 483 HTLC limit is reached.\n\nProtocol Goals\n===========\nI looked at the windowing mechanism used in TCP to achieve congestion\ncontrol and transferred this concept to the setting of the Lightning\nNetwork. This idea is motivated by the Spider Network paper [2] which\nmentions that in a simulation the success rate of payments is increased\nwhen changing the lightning network from a circuit switched payment process\n(which we currently have with our atomicity requirements) to a packet\nswitched mechanism that includes congestion control (though in that\npublication congestion control had a different semantics than in has in my\nproposal).\n\nProtocol Benefits\n=============\n- Improve the speed of multipath payments\n- Reduce load from the network (in particular don't lock liquidity for such\na long time)\n- less congestion at single nodes (I assume this is not a problem at this\npoint in time)\n- more privacy (different preimages are used along different paths and\noverall payments might become smaller or of uniform size)\n- usual benefits from AMP\n\nProtocol idea (base version)\n=====================\nDisclaimer: This base version has obvious drawbacks but I decided to\ninclude it as it transports the idea.\n\nA regular payment on the Lightning Network for amount `x` has a Payment\nHash `H` and a preimage `r`.  If a recipient would now accept that this\npayment could be split over up to `n` paths the recipient would create a\nsha-chain of preimages and payment hashes with `n` elements\n\n```\nr_0 = rand()\nH_0 = H(r_0)\nr_{i+1} = H_i\nH_{i+1} = H(r_{i+1})\n```\n\nThe payment process is initiated by the recipient providing H_{n-1} and\nsignaling (in the invoice) that up to `n` preimages are available to\ncomplete this payment.\n\nA sender can now decide to split the payment amount `x` into `n` seperate\npayments for example of the amounts `x/n` though different splits should be\npossible. Once the preimage of the first partial payment is returned the\npayer learns the payment hash wich can be used for the next partial\npayment. (One issue is that while we have a proof of payment we do not\nnecessarily have a proof of amount - which is true for the regular\nlightning case though with a single atomic payment this is not an issue as\nthe preimage will not be relased if the amount is too low. We could avoid\nthis issue by demanding that mulipath payments have to be at least of size\n`x/n`)\n\nThis protocol makes the AMP process sequential and reduces the load from\nthe network. Congestion (which is a local problem of routing nodes) becomes\nless likely if only HTLCs are locked up for a partial payment independent\nof the success or failure of other partial payments. However in the base\nversion there is a severe downside:\n\n**Sequential payments will make the payment process even longer since it is\nnot the max time needed over all payments but the sum of times needed.**\n\nWe can resolve this issue by introducing flow control via a windowing\nmechanism and allowing concurrency of partial payments\n\nProtocol Overview (suggested version)\n==============================\nLet us assume the receiving node supports a window size of `s` concurrent\npayments. Now the payee will not only create one sha-chain of `n` payment\nhashes as in the base version but `s` sha-chains of `n` payment hashes.\nIn the invoice we would now transport the following data:\n\n* `n` (we need a different letter as n is already taken) = amount of\npartial payments that are supported per payment hash\n* `s` = number of concurrent payments supported (window size)\n* `s` many `p` fields which contain the `s` different top elements H_{n-1}\nfor each sha-chain\n\nNote that technically the payment amount could now be even split up into\n`s*n` partial payments though I would recommend to still go with `n`\npartial payments.\n\nThe advantage with this mechanism are the following:\n* As long as less then `s` payments get stuck the protocol can continue to\ndeliver partial payments.\n* Nodes already agree to do some overpayments to obfuscate the payment\namount. If the stuck payments are really small they could be considered as\noverpayments (in case they eventually go through). This would work if the\nsender sends overall `n+k` payments where `k` is the number of currently\nstuck payments.\n\nPotential Improvements (for better privacy)\n================================\n* Instead of using a sha-chain we could xor every preimage with a sequence\nnumber making it harder for an attacker to correlate two consecutive\npayments in the stream of payments via\n```\nr_0=rand()\nH_0(r_0)\nr_{i+1} = H_0 ^ (i+1)\nH_{i+1} = H(r_{i+1})\n```\nInstead of a sequence number we could also do something like `(i+1)*x` (as\nattackers should not be aware of the overall payment amount it will be hard\nto guess that number). I guess you folks are aware of much better\ncryptographic tricks to achieve what I suggest here. So please take this\njust as an idea from a beginner in cryptography.\n\n* If paths are reused for partial payments the sender should switch to a\npreimage from a different sha-chain creating some path decorellation\n* Even when going away from hashedpreimages when changing to MuSig and\nmultilocks a mechanism similar to HD-wallets should be usable for this\nscheme\n\n\nSender Requirements\n=================\nThe sender needs to keep track how many payments have been successfully\nsent and how many are in transition / stuck.\nFor the privacy parts the sender additionally needs to watch out to cycle\nthrough the shachains when reusing paths\n\nReceiver Requirements\n==================\nMore data needs to be stored / held in memory. (either `s` complete\nsha-chains) or the `s` times the initial preimage of each chain and the\ncurrent payment hash. in the later case the computational overhead will be\nincreased.\n\nConclusion\n=========\n* With introduction of two new fields in BOLT 11 invoices and rather simple\ncode changes for invoice creation / preimage releasing we have the ability\nto introduce flow and congestion control to multipath routing of payments.\n* The proposed mechanism is not atomic. It is possible that a payee\nreceives only a fraction of all payments and stops collaborating\n* Less HTLCs and liquidity will be bound in multipath routing schemes\nresulting in a reduction of load for the network\n* A few stuck payments can be neglected as \"cost\" of operation. While I\nstrongly support ideas from [0] we might not need them with this simple\ntrick.\n* As I used the term `stream of payments` in the text this mechanism could\nalso be extended for a streaming payments protocol.\n\nI am curios on your thoughts.\n\nWith kind regards Rene\n\n\n[0]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002029.html\n Proposal\nfor Stuckless Payment by Hiroki\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html\nAMP:\nAtomic Multi-Path Payments over Lightning  by Conner & Laolu\n[2]: https://arxiv.org/abs/1809.05088 Routing Cryptocurrency with the\nSpider Network by Vibhaalakshmi et. al.\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190715/163114e7/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-16T03:26:57",
                "message_text_only": "Good morning Rene,\n\nThank you for continuing to think about Lightning even while in hospital.\nPlease take care your health.\n\nAs the usual list spammer, I will of course respond pointlessly.\n\n> Protocol idea (base version)\n> =====================\n> Disclaimer: This base version has obvious drawbacks but I decided to include it as it transports the idea.\u00a0\n>\n> A regular payment on the Lightning Network for amount `x` has a Payment Hash `H` and a preimage `r`.\u00a0 If a recipient would now accept that this payment could be split over up to `n` paths the recipient would create a sha-chain of preimages and payment hashes with `n` elements\n>\n> ```\n> r_0 = rand()\n> H_0 = H(r_0)\n> r_{i+1} = H_i\n> H_{i+1} = H(r_{i+1})\n> ```\n>\n> The payment process is initiated by the recipient providing H_{n-1} and signaling (in the invoice) that up to `n` preimages are available to complete this payment.\n>\n> A sender can now decide to split the payment amount `x` into `n` seperate payments for example of the amounts `x/n` though different splits should be possible. Once the preimage of the first partial payment is returned the payer learns the payment hash wich can be used for the next partial payment. (One issue is that while we have a proof of payment we do not necessarily have a proof of amount - which is true for the regular lightning case though with a single atomic payment this is not an issue as the preimage will not be relased if the amount is too low. We could avoid this issue by demanding that mulipath payments have to be at least of size `x/n`)\n\nAssuming we accept `r_0` as proof-of-complete-payment, this does not leave the payer with many options.\nFor example, suppose the payee has given `H_1 n=2` for `x = 2.0`.\nSuppose the payer can find a route that can transport 2.0 in a single attempt.\nThe payer cannot take this route, since it can only ask for `r_1`, which is the hash of `r_0`, and thus even if it could pay the entire 2.0 it is unable to acquire a proof-of-complete-payment.\n\nThis could be fixed by extending HTLC offers with the number of hash operations to perform in sequence, so that if the payer can pay the entire payment in a single routing attempt it can request for payment in exchange of a preimage of a hash of a hash (etc.).\nBut this would require an update in the peer protocol BOLT #2, not just a payer-payee interaction change in BOLT #11.\n\nThe lack of an atomic proof-of-payment is extremely disturbing and requires that payer and payee trust one another.\nI see later that you still are unable to fix this.\n\n> (which is a local problem of routing nodes)\n\nAs it solves a problem of the forwarding nodes, maybe forwarding nodes should offer a fee discount if this protocol is used?\n\n> Protocol Overview (suggested version)\n> ==============================\n> Let us assume the receiving node supports a window size of `s` concurrent payments. Now the payee will not only create one sha-chain of `n` payment hashes as in the base version but `s` sha-chains of `n` payment hashes.\u00a0\n\nIt seems to me that `s` would have to be a global consensus parameter: hop nodes would want to restrict it, payer and payee nodes would want `s` to be infinite.\n\n> * Nodes already agree to do some overpayments to obfuscate the payment amount.\n\n*grumble* Only C-lightning ever implemented this *grumble*.\n*grumble* Worse, when we reorganized the `pay` implementation we inadvertently removed the feature and nobody cared enough to file an issue about its disappearance *grumble*.\n\n>\n> Potential Improvements (for better privacy)\n> ================================\n> * Instead of using a sha-chain we could xor every preimage with a sequence number making it harder for an attacker to correlate two consecutive payments in the stream of payments via\n> ```\n> r_0=rand()\n> H_0(r_0)\n> r_{i+1} = H_0 ^ (i+1)\n> H_{i+1} = H(r_{i+1})\n> ```\n> Instead of a sequence number we could also do something like `(i+1)*x` (as attackers should not be aware of the overall payment amount it will be hard to guess that number). I guess you folks are aware of much better cryptographic tricks to achieve what I suggest here. So please take this just as an idea from a beginner in cryptography.\n\nIt would be trivial to grind `i`, especially since we expect `n` to be small, e.g. `n < 100` would be reasonable assumption.\nThe traditional solution for obfuscating easily-ground things is to add a salt and hash it.\nSo:\n\n    r_{i + 1} = H_i ^ h(salt | i)\n\nThe `salt` could be included in the invoice, but that would add even more data to invoices.\n(consider that a C-lightning-generated invoice with a routing hint would no longer fit in a tweet).\nIt would be nice to reuse some data in the invoice for the salt, but the payee node id is easily ground (a forwarding node could grind nearby nodes to see if the salt matches) and the other random data in the invoice is dependent on the hash you put in the invoice (which is what you need to compute *with* the salt...).\n\n> * The proposed mechanism is not atomic. It is possible that a payee receives only a fraction of all payments and stops collaborating\n\nI believe this to be a major problem.\n\nUnder current system, an expert testimony can show that revelation of the preimage of a payment hash implies payment has been done.\nAn invoice would have to commit (in its description) what should be done in exchange for payment (e.g. `d` should be \"delivery of 100 USA Federal Reserve Commemorative Papers to ZmnSCPxj\", not just \"100 USA Federal Reserve Commemorative Papers\").\nAn invoice is signed cryptographically, attesting that the node with the specified public key has promised to deliver on the described service, if payment is done.\nPayment can only be done by exchange of the proof-of-payment preimage, thus if anybody other than the payee is able to show the preimage, the payee has indeed been paid and it is now held liable to its promise.\nIn particular, experts can show that node software will not release the preimage if less than the agreed invoice amount is paid, and that this node software would be under the control of the payee.\n\nSimilarly, under bass amplifier (\"multipart payment\"), experts can show that node software will not release the preimage if less than the agreed amount in total has reached the payee in all paths, thus preserving the important atomicity of proof-of-payment.\n\nWithout this atomicity Lightning cannot operate as a trustless payment system.\n\n> * As I used the term `stream of payments` in the text this mechanism could also be extended for a streaming payments protocol.\n\nIt may be better to extend this proposed protocol in this direction.\nFor example, if a shachain is used, we can use the recent \"pay-for-data\" protocol (preimage is encryption key of data) for streaming live data.\nAs each payment pays for e.g. one time unit of video data, and noncooperation of the payer or payee is equivalent to simply cancelling the stream of live data.\nThere is still the issue of the payee having to be trusted to deliver the correct data, but if the payments per unit time is small enough this may be an acceptable risk.\n\nSuch streaming of pay-for-data would be expected to cause significant congestion on the LN due to the high rate of payments, so it would be more appropriate for congestion and flow control protocols here.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Congestion and Flow control for Multipath Routing",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 16149
        }
    },
    {
        "title": "[Lightning-dev] [PROPOSAL] Removal of proposal to make CSV delay symmetric",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-07-17T01:33:27",
                "message_text_only": "Hi all,\n\n        In Adelaide we proposed that CSV delays be symmetric; that the\nto-self output would be delayed to avoid weird \"no, you close!\" games.\n\n        Unfortunately, Roasbeef points out that this undermines the\ngreat strength of the option_static_remotekey, which allows a\ndisaster-recovery scenario to easily discover any unknown unilateral\ncloses using only a master seed.  Turns out, this \"I deleted everything\nbut I kept my seed!\" is a real thing.\n\n        We could still use the max of the two sides' CSV, but that's\nalready a choice that sides can make (if accepting, simply offer the\nsame value, and if opening, error and retry if their accept contains a\nlarger value).\n\nSo I think this proposal should be abandoned.\n\nThoughts?\nRusty."
            },
            {
                "author": "Pierre",
                "date": "2019-07-18T08:12:57",
                "message_text_only": "Hi Rusty,\n\nHow would bruteforcing on the CSV delay be different from a BIP32\nwallet with look ahead keys? Especially given that we could try with\nmost probable values first.\n\nCheers,\n\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-07-19T06:12:51",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hi Rusty,\n>\n> How would bruteforcing on the CSV delay be different from a BIP32\n> wallet with look ahead keys? Especially given that we could try with\n> most probable values first.\n\nIt's a big multiplier, given that CSV can be specified by the\ncounterparty.  If you accept up to 1024 and offer 144, that's 880\nvariants to look for, per key.\n\nIt also can't be done with a normal bitcoin wallet, which is unfortunate\ntoo.\n\nCheers,\nRusty."
            },
            {
                "author": "Pierre",
                "date": "2019-07-23T14:44:28",
                "message_text_only": "> > How would bruteforcing on the CSV delay be different from a BIP32\n> > wallet with look ahead keys? Especially given that we could try with\n> > most probable values first.\n>\n> It's a big multiplier, given that CSV can be specified by the\n> counterparty.  If you accept up to 1024 and offer 144, that's 880\n> variants to look for, per key.\n\nWe could restrict CSV delays to be e.g. multiple of 144 between 144\nand 2016, that would only be 14 variants.\n\n> It also can't be done with a normal bitcoin wallet, which is unfortunate\n> too.\n\nRight, but it wouldn't work for local commitments.\n\nI feel like alignment of incentives should prevail here. Funds are\nstill recoverable with just the seed, which is a huge improvement vs\nwhat is currently the case."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-07-24T00:37:51",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n>> > How would bruteforcing on the CSV delay be different from a BIP32\n>> > wallet with look ahead keys? Especially given that we could try with\n>> > most probable values first.\n>>\n>> It's a big multiplier, given that CSV can be specified by the\n>> counterparty.  If you accept up to 1024 and offer 144, that's 880\n>> variants to look for, per key.\n>\n> We could restrict CSV delays to be e.g. multiple of 144 between 144\n> and 2016, that would only be 14 variants.\n\nWell one of 6, 36, 144, 432 or 1008 is probably more than enough choice.\n\n>> It also can't be done with a normal bitcoin wallet, which is unfortunate\n>> too.\n>\n> Right, but it wouldn't work for local commitments.\n>\n> I feel like alignment of incentives should prevail here. Funds are\n> still recoverable with just the seed, which is a huge improvement vs\n> what is currently the case.\n\nMost of the time, local commitments are not in play.  But if your node\ndrops out, remote commitments definitely will be.\n\nI think being able to rescue some funds from a pre-lightning wallet is a\nnice thing to have at this stage.  In five years, it might not be as\nuseful, though.\n\nCheers,\nRusty."
            },
            {
                "author": "Pierre",
                "date": "2019-07-24T12:20:03",
                "message_text_only": "> Well one of 6, 36, 144, 432 or 1008 is probably more than enough choice.\n\nIndeed, that seems entirely reasonable.\n\n> Most of the time, local commitments are not in play.  But if your node\n> drops out, remote commitments definitely will be.\n\nThat's true, although in my experience, the refund delay after a local\ncommitment is often a period when the user may decide to do unexpected\nthings, because \"something went wrong and a reinstall may fix it\".\n\n> I think being able to rescue some funds from a pre-lightning wallet is a\n> nice thing to have at this stage.\n\nRight, but it does introduce some uncertainty: depending on the exact\nnature of the close, something may or may not appear in the user's\nwallet. I think that would have been the correct approach for BOLT 1,\nbut now I'd favor a well designed recovery tool. Since the Electrum\nteam is working on LN, maybe we could get them to support this simple\nheuristic?"
            }
        ],
        "thread_summary": {
            "title": "Removal of proposal to make CSV delay symmetric",
            "categories": [
                "Lightning-dev",
                "PROPOSAL"
            ],
            "authors": [
                "Rusty Russell",
                "Pierre"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 4272
        }
    },
    {
        "title": "[Lightning-dev] Selling Signatures: Another Reason to Move to Payment Points",
        "thread_messages": [
            {
                "author": "Nadav Kohen",
                "date": "2019-07-17T15:37:19",
                "message_text_only": "Hi All,\n\nI recently posted a proposal here for a scheme through which a trusted data\nprovider can utilize the Lightning Network to privately sell data where\ndata is received atomically with purchase.\n\nI've more recently been thinking about situations where a party, that is\n*not* trusted, is attempting to sell its signature to a known message. One\nexample of a situation where this would be useful is if someone is trying\nto offer a DLC-like Option contract where they are essentially\ncollateralizing themselves in a funding transaction and then selling their\nsignatures to Contract Execution Transactions (CETs). In this example, we\nmust ensure that the buyer of the signatures pays if and only if they\nreceive valid signatures for the CETs which are known.\n\nI believe that this is achievable in a relatively straightforward way if we\nwere to use ZmnSCPxj's proposed payment points with scalars (as opposed to\npayment hashes with pre-images). The (Schnorr) signature seller could give\nthe buyer their one-time public key, `R = k*G`, through which the buyer\ncould compute the payment point whose scalar is the seller's signature:\n`sig*G = R + h(m, R)*A` where `A` is the seller's public key. Using this\nvalue as the payment point, the buyer could be assured that they pay if and\nonly if they receive `sig` from the seller, where `sig` is the desired\nvalid signature of `m`!\n\nBest,\nNadav\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190717/95c848fb/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-07-17T16:23:15",
                "message_text_only": "Hi Nadav,\n\nThis is cool idea. I always imagined oracles would either give their DLC\nsignatures away for free or work via a subscription model.\n\nThe downside to this proposal is that the seller of the signature knows\nwhich signature they're selling and therefore learns what kind of contract\nthe buyer must be involved in.\n\nLL\n\n\nOn Thu, Jul 18, 2019 at 1:37 AM Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hi All,\n>\n> I recently posted a proposal here for a scheme through which a trusted\n> data provider can utilize the Lightning Network to privately sell data\n> where data is received atomically with purchase.\n>\n> I've more recently been thinking about situations where a party, that is\n> *not* trusted, is attempting to sell its signature to a known message. One\n> example of a situation where this would be useful is if someone is trying\n> to offer a DLC-like Option contract where they are essentially\n> collateralizing themselves in a funding transaction and then selling their\n> signatures to Contract Execution Transactions (CETs). In this example, we\n> must ensure that the buyer of the signatures pays if and only if they\n> receive valid signatures for the CETs which are known.\n>\n> I believe that this is achievable in a relatively straightforward way if\n> we were to use ZmnSCPxj's proposed payment points with scalars (as opposed\n> to payment hashes with pre-images). The (Schnorr) signature seller could\n> give the buyer their one-time public key, `R = k*G`, through which the\n> buyer could compute the payment point whose scalar is the seller's\n> signature: `sig*G = R + h(m, R)*A` where `A` is the seller's public key.\n> Using this value as the payment point, the buyer could be assured that they\n> pay if and only if they receive `sig` from the seller, where `sig` is the\n> desired valid signature of `m`!\n>\n> Best,\n> Nadav\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190718/52d55a92/attachment.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-07-17T16:56:05",
                "message_text_only": "Hi Lloyd,\n\nGlad you like it :) And to address your concern, I think that although\ncertainly it is possible for oracles to sell options contracts, it is also\npossible to have a more decentralized setup with normal DLC oracles (that\ncan be used for all kinds of things as all they do is schnorr sign messages\nwith pre-commited R values), and then have the CETs be 3-of-3 multisig\noutputs. In this way the oracle is still not learning about the contract,\njust like normal DLCs.\n\nBest,\nNadav\n\nOn Wed, Jul 17, 2019 at 11:23 AM Lloyd Fournier <lloyd.fourn at gmail.com>\nwrote:\n\n> Hi Nadav,\n>\n> This is cool idea. I always imagined oracles would either give their DLC\n> signatures away for free or work via a subscription model.\n>\n> The downside to this proposal is that the seller of the signature knows\n> which signature they're selling and therefore learns what kind of contract\n> the buyer must be involved in.\n>\n> LL\n>\n>\n> On Thu, Jul 18, 2019 at 1:37 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>\n>> Hi All,\n>>\n>> I recently posted a proposal here for a scheme through which a trusted\n>> data provider can utilize the Lightning Network to privately sell data\n>> where data is received atomically with purchase.\n>>\n>> I've more recently been thinking about situations where a party, that is\n>> *not* trusted, is attempting to sell its signature to a known message. One\n>> example of a situation where this would be useful is if someone is trying\n>> to offer a DLC-like Option contract where they are essentially\n>> collateralizing themselves in a funding transaction and then selling their\n>> signatures to Contract Execution Transactions (CETs). In this example, we\n>> must ensure that the buyer of the signatures pays if and only if they\n>> receive valid signatures for the CETs which are known.\n>>\n>> I believe that this is achievable in a relatively straightforward way if\n>> we were to use ZmnSCPxj's proposed payment points with scalars (as opposed\n>> to payment hashes with pre-images). The (Schnorr) signature seller could\n>> give the buyer their one-time public key, `R = k*G`, through which the\n>> buyer could compute the payment point whose scalar is the seller's\n>> signature: `sig*G = R + h(m, R)*A` where `A` is the seller's public key.\n>> Using this value as the payment point, the buyer could be assured that they\n>> pay if and only if they receive `sig` from the seller, where `sig` is the\n>> desired valid signature of `m`!\n>>\n>> Best,\n>> Nadav\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190717/3c637967/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-07-17T18:16:18",
                "message_text_only": "Hi Nadav,\n\nInteresting. Is there a writeup anywhere of this CET idea that I can add to\nmy reading list. I feel like I am missing some background.\n\nLL\n\nOn Thu, Jul 18, 2019 at 2:56 AM Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hi Lloyd,\n>\n> Glad you like it :) And to address your concern, I think that although\n> certainly it is possible for oracles to sell options contracts, it is also\n> possible to have a more decentralized setup with normal DLC oracles (that\n> can be used for all kinds of things as all they do is schnorr sign messages\n> with pre-commited R values), and then have the CETs be 3-of-3 multisig\n> outputs. In this way the oracle is still not learning about the contract,\n> just like normal DLCs.\n>\n> Best,\n> Nadav\n>\n> On Wed, Jul 17, 2019 at 11:23 AM Lloyd Fournier <lloyd.fourn at gmail.com>\n> wrote:\n>\n>> Hi Nadav,\n>>\n>> This is cool idea. I always imagined oracles would either give their DLC\n>> signatures away for free or work via a subscription model.\n>>\n>> The downside to this proposal is that the seller of the signature knows\n>> which signature they're selling and therefore learns what kind of contract\n>> the buyer must be involved in.\n>>\n>> LL\n>>\n>>\n>> On Thu, Jul 18, 2019 at 1:37 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>>\n>>> Hi All,\n>>>\n>>> I recently posted a proposal here for a scheme through which a trusted\n>>> data provider can utilize the Lightning Network to privately sell data\n>>> where data is received atomically with purchase.\n>>>\n>>> I've more recently been thinking about situations where a party, that is\n>>> *not* trusted, is attempting to sell its signature to a known message. One\n>>> example of a situation where this would be useful is if someone is trying\n>>> to offer a DLC-like Option contract where they are essentially\n>>> collateralizing themselves in a funding transaction and then selling their\n>>> signatures to Contract Execution Transactions (CETs). In this example, we\n>>> must ensure that the buyer of the signatures pays if and only if they\n>>> receive valid signatures for the CETs which are known.\n>>>\n>>> I believe that this is achievable in a relatively straightforward way if\n>>> we were to use ZmnSCPxj's proposed payment points with scalars (as opposed\n>>> to payment hashes with pre-images). The (Schnorr) signature seller could\n>>> give the buyer their one-time public key, `R = k*G`, through which the\n>>> buyer could compute the payment point whose scalar is the seller's\n>>> signature: `sig*G = R + h(m, R)*A` where `A` is the seller's public key.\n>>> Using this value as the payment point, the buyer could be assured that they\n>>> pay if and only if they receive `sig` from the seller, where `sig` is the\n>>> desired valid signature of `m`!\n>>>\n>>> Best,\n>>> Nadav\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190718/7d81834a/attachment.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-07-17T18:27:07",
                "message_text_only": "Here is a pretty comprehensive write-up on how to make a DLC:\nhttps://medium.com/crypto-garage/p2p-protocol-based-crypto-asset-derivative-settled-in-bitcoin-on-discreet-log-contracts-13c823448ae8\nI believe they also put the txid and such of their CET so you can find the\nactual script in a block explorer.\n\nAlso this is always great in case you haven't read it:\nhttps://adiabat.github.io/dlc.pdf\n\nBest,\nNadav\n\nOn Wed, Jul 17, 2019 at 1:16 PM Lloyd Fournier <lloyd.fourn at gmail.com>\nwrote:\n\n> Hi Nadav,\n>\n> Interesting. Is there a writeup anywhere of this CET idea that I can add\n> to my reading list. I feel like I am missing some background.\n>\n> LL\n>\n> On Thu, Jul 18, 2019 at 2:56 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>\n>> Hi Lloyd,\n>>\n>> Glad you like it :) And to address your concern, I think that although\n>> certainly it is possible for oracles to sell options contracts, it is also\n>> possible to have a more decentralized setup with normal DLC oracles (that\n>> can be used for all kinds of things as all they do is schnorr sign messages\n>> with pre-commited R values), and then have the CETs be 3-of-3 multisig\n>> outputs. In this way the oracle is still not learning about the contract,\n>> just like normal DLCs.\n>>\n>> Best,\n>> Nadav\n>>\n>> On Wed, Jul 17, 2019 at 11:23 AM Lloyd Fournier <lloyd.fourn at gmail.com>\n>> wrote:\n>>\n>>> Hi Nadav,\n>>>\n>>> This is cool idea. I always imagined oracles would either give their DLC\n>>> signatures away for free or work via a subscription model.\n>>>\n>>> The downside to this proposal is that the seller of the signature knows\n>>> which signature they're selling and therefore learns what kind of contract\n>>> the buyer must be involved in.\n>>>\n>>> LL\n>>>\n>>>\n>>> On Thu, Jul 18, 2019 at 1:37 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>>>\n>>>> Hi All,\n>>>>\n>>>> I recently posted a proposal here for a scheme through which a trusted\n>>>> data provider can utilize the Lightning Network to privately sell data\n>>>> where data is received atomically with purchase.\n>>>>\n>>>> I've more recently been thinking about situations where a party, that\n>>>> is *not* trusted, is attempting to sell its signature to a known message.\n>>>> One example of a situation where this would be useful is if someone is\n>>>> trying to offer a DLC-like Option contract where they are essentially\n>>>> collateralizing themselves in a funding transaction and then selling their\n>>>> signatures to Contract Execution Transactions (CETs). In this example, we\n>>>> must ensure that the buyer of the signatures pays if and only if they\n>>>> receive valid signatures for the CETs which are known.\n>>>>\n>>>> I believe that this is achievable in a relatively straightforward way\n>>>> if we were to use ZmnSCPxj's proposed payment points with scalars (as\n>>>> opposed to payment hashes with pre-images). The (Schnorr) signature seller\n>>>> could give the buyer their one-time public key, `R = k*G`, through which\n>>>> the buyer could compute the payment point whose scalar is the seller's\n>>>> signature: `sig*G = R + h(m, R)*A` where `A` is the seller's public key.\n>>>> Using this value as the payment point, the buyer could be assured that they\n>>>> pay if and only if they receive `sig` from the seller, where `sig` is the\n>>>> desired valid signature of `m`!\n>>>>\n>>>> Best,\n>>>> Nadav\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190717/9419f845/attachment.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-07-17T19:25:38",
                "message_text_only": "I've gotten a couple questions about the payment point idea. Here are the\nthreads I've seen where ZmnSCPxj mentions payment points may help:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002028.html\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002030.html\n\nNadav\n\nOn Wed, Jul 17, 2019 at 1:27 PM Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Here is a pretty comprehensive write-up on how to make a DLC:\n> https://medium.com/crypto-garage/p2p-protocol-based-crypto-asset-derivative-settled-in-bitcoin-on-discreet-log-contracts-13c823448ae8\n> I believe they also put the txid and such of their CET so you can find the\n> actual script in a block explorer.\n>\n> Also this is always great in case you haven't read it:\n> https://adiabat.github.io/dlc.pdf\n>\n> Best,\n> Nadav\n>\n> On Wed, Jul 17, 2019 at 1:16 PM Lloyd Fournier <lloyd.fourn at gmail.com>\n> wrote:\n>\n>> Hi Nadav,\n>>\n>> Interesting. Is there a writeup anywhere of this CET idea that I can add\n>> to my reading list. I feel like I am missing some background.\n>>\n>> LL\n>>\n>> On Thu, Jul 18, 2019 at 2:56 AM Nadav Kohen <nadav at suredbits.com> wrote:\n>>\n>>> Hi Lloyd,\n>>>\n>>> Glad you like it :) And to address your concern, I think that although\n>>> certainly it is possible for oracles to sell options contracts, it is also\n>>> possible to have a more decentralized setup with normal DLC oracles (that\n>>> can be used for all kinds of things as all they do is schnorr sign messages\n>>> with pre-commited R values), and then have the CETs be 3-of-3 multisig\n>>> outputs. In this way the oracle is still not learning about the contract,\n>>> just like normal DLCs.\n>>>\n>>> Best,\n>>> Nadav\n>>>\n>>> On Wed, Jul 17, 2019 at 11:23 AM Lloyd Fournier <lloyd.fourn at gmail.com>\n>>> wrote:\n>>>\n>>>> Hi Nadav,\n>>>>\n>>>> This is cool idea. I always imagined oracles would either give their\n>>>> DLC signatures away for free or work via a subscription model.\n>>>>\n>>>> The downside to this proposal is that the seller of the signature knows\n>>>> which signature they're selling and therefore learns what kind of contract\n>>>> the buyer must be involved in.\n>>>>\n>>>> LL\n>>>>\n>>>>\n>>>> On Thu, Jul 18, 2019 at 1:37 AM Nadav Kohen <nadav at suredbits.com>\n>>>> wrote:\n>>>>\n>>>>> Hi All,\n>>>>>\n>>>>> I recently posted a proposal here for a scheme through which a trusted\n>>>>> data provider can utilize the Lightning Network to privately sell data\n>>>>> where data is received atomically with purchase.\n>>>>>\n>>>>> I've more recently been thinking about situations where a party, that\n>>>>> is *not* trusted, is attempting to sell its signature to a known message.\n>>>>> One example of a situation where this would be useful is if someone is\n>>>>> trying to offer a DLC-like Option contract where they are essentially\n>>>>> collateralizing themselves in a funding transaction and then selling their\n>>>>> signatures to Contract Execution Transactions (CETs). In this example, we\n>>>>> must ensure that the buyer of the signatures pays if and only if they\n>>>>> receive valid signatures for the CETs which are known.\n>>>>>\n>>>>> I believe that this is achievable in a relatively straightforward way\n>>>>> if we were to use ZmnSCPxj's proposed payment points with scalars (as\n>>>>> opposed to payment hashes with pre-images). The (Schnorr) signature seller\n>>>>> could give the buyer their one-time public key, `R = k*G`, through which\n>>>>> the buyer could compute the payment point whose scalar is the seller's\n>>>>> signature: `sig*G = R + h(m, R)*A` where `A` is the seller's public key.\n>>>>> Using this value as the payment point, the buyer could be assured that they\n>>>>> pay if and only if they receive `sig` from the seller, where `sig` is the\n>>>>> desired valid signature of `m`!\n>>>>>\n>>>>> Best,\n>>>>> Nadav\n>>>>> _______________________________________________\n>>>>> Lightning-dev mailing list\n>>>>> Lightning-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>>\n>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190717/48877984/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-07-18T00:24:22",
                "message_text_only": "Good morning Nadav,\n\nI strongly disagree that I first proposed payment points + scalars for Lightning.\n\nMy understanding is that Andrew Poelstra first proposed this.\nIndeed, his work on Scriptless Script was, to my understanding, primarily motivated by a goal of eventually enabling Lightning over a MimbleWimble blockchain.\nThe first main use of Scriptless Script was as a replacement for HTLCs, the construction we currently use to enable cross-channel atomic swaps.\n\n(the efforts of Lightning over MimbleWimble have been stymied, I believe, by the difficulty of implementing relative locktimes in a MimbleWimble blockchain while retaining its \"magical shrinking blockchain\" property; Andrew Poelstra has figured out how to implement absolute locktimes without strongly requiring storage linear to block height under MimbleWimble, to my understanding)\n\nThe first time I have mentioned the use of payment points + scalars was here, I believe: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March/001100.html\n\nAt the time my understanding was already that we would eventually (but not yet in the foreseeable future at that time) switch to payment points + scalars.\n\nThe \"Multi-hop Locks\" paper is basically the proposal to use payment point + scalar and also provide path decorrelation.\n\nI believe the features we already know to be enabled or enhanced by payment point + scalar are:\n\n1.  Path decorrelation. \"Multi-hop locks\"\n2.  \"High\" AMP https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-March/001100.html\n3.  Escrow over Lightning.\n4.  Stuckless payments.\n5.  Pay-for-signature\n\nThere may be others.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, July 18, 2019 3:25 AM, Nadav Kohen <nadav at suredbits.com> wrote:\n\n> I've gotten a couple questions about the payment point idea. Here are the threads I've seen where ZmnSCPxj mentions payment points may help:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002028.html\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002030.html\n>\n> Nadav\n>\n> On Wed, Jul 17, 2019 at 1:27 PM Nadav Kohen <nadav at suredbits.com> wrote:\n>\n> > Here is a pretty comprehensive write-up on how to make a DLC: https://medium.com/crypto-garage/p2p-protocol-based-crypto-asset-derivative-settled-in-bitcoin-on-discreet-log-contracts-13c823448ae8\n> > I believe they also put the txid and such of their CET so you can find the actual script in a block explorer.\n> >\n> > Also this is always great in case you haven't read it: https://adiabat.github.io/dlc.pdf\n> >\n> > Best,\n> > Nadav\n> >\n> > On Wed, Jul 17, 2019 at 1:16 PM Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n> >\n> > > Hi Nadav,\n> > >\n> > > Interesting. Is there a writeup anywhere of this CET idea that I can add to my reading list. I feel like I am missing some background.\n> > >\n> > > LL\n> > >\n> > > On Thu, Jul 18, 2019 at 2:56 AM Nadav Kohen <nadav at suredbits.com> wrote:\n> > >\n> > > > Hi Lloyd,\n> > > >\n> > > > Glad you like it :) And to address your concern, I think that although certainly it is possible for oracles to sell options contracts, it is also possible to have a more decentralized setup with normal DLC oracles (that can be used for all kinds of things as all they do is schnorr sign messages with pre-commited R values), and then have the CETs be 3-of-3 multisig outputs. In this way the oracle is still not learning about the contract, just like normal DLCs.\n> > > >\n> > > > Best,\n> > > > Nadav\n> > > >\n> > > > On Wed, Jul 17, 2019 at 11:23 AM Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n> > > >\n> > > > > Hi Nadav,\n> > > > >\n> > > > > This is cool idea. I always imagined oracles would either give their DLC signatures away for free or work via a subscription model.\n> > > > >\n> > > > > The downside to this proposal is that the seller of the signature knows which signature they're selling and therefore learns what kind of contract the buyer must be involved in.\n> > > > >\n> > > > > LL\n> > > > >\n> > > > > On Thu, Jul 18, 2019 at 1:37 AM Nadav Kohen <nadav at suredbits.com> wrote:\n> > > > >\n> > > > > > Hi All,\n> > > > > >\n> > > > > > I recently posted a proposal here for a scheme through which a trusted data provider can utilize the Lightning Network to privately sell data where data is received atomically with purchase.\n> > > > > >\n> > > > > > I've more recently been thinking about situations where a party, that is *not* trusted, is attempting to sell its signature to a known message. One example of a situation where this would be useful is if someone is trying to offer a DLC-like Option contract where they are essentially collateralizing themselves in a funding transaction and then selling their signatures to Contract Execution Transactions (CETs). In this example, we must ensure that the buyer of the signatures pays if and only if they receive valid signatures for the CETs which are known.\n> > > > > >\n> > > > > > I believe that this is achievable in a relatively straightforward way if we were to use ZmnSCPxj's proposed payment points with scalars (as opposed to payment hashes with pre-images). The (Schnorr) signature seller could give the buyer their one-time public key, `R = k*G`, through which the buyer could compute the payment point whose scalar is the seller's signature: `sig*G = R + h(m, R)*A` where `A` is the seller's public key. Using this value as the payment point, the buyer could be assured that they pay if and only if they receive `sig` from the seller, where `sig` is the desired valid signature of `m`!\n> > > > > >\n> > > > > > Best,\n> > > > > > Nadav\n> > > > > > _______________________________________________\n> > > > > > Lightning-dev mailing list\n> > > > > > Lightning-dev at lists.linuxfoundation.org\n> > > > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Jonas Nick",
                "date": "2019-07-17T19:36:12",
                "message_text_only": "Perhaps worth noting that in addition to selling signatures, it's also possible\nto sell blind Schnorr signatures [0] and anonymous credentials [1].\n\n[0] https://github.com/ElementsProject/scriptless-scripts/blob/master/md/partially-blind-swap.md\n[1] https://youtu.be/XORDEX-RrAI?t=26552, slides https://nickler.ninja/slides/2018-bob.pdf\n\nOn 7/17/19 3:37 PM, Nadav Kohen wrote:\n> Hi All,\n> \n> I recently posted a proposal here for a scheme through which a trusted data\n> provider can utilize the Lightning Network to privately sell data where\n> data is received atomically with purchase.\n> \n> I've more recently been thinking about situations where a party, that is\n> *not* trusted, is attempting to sell its signature to a known message. One\n> example of a situation where this would be useful is if someone is trying\n> to offer a DLC-like Option contract where they are essentially\n> collateralizing themselves in a funding transaction and then selling their\n> signatures to Contract Execution Transactions (CETs). In this example, we\n> must ensure that the buyer of the signatures pays if and only if they\n> receive valid signatures for the CETs which are known.\n> \n> I believe that this is achievable in a relatively straightforward way if we\n> were to use ZmnSCPxj's proposed payment points with scalars (as opposed to\n> payment hashes with pre-images). The (Schnorr) signature seller could give\n> the buyer their one-time public key, `R = k*G`, through which the buyer\n> could compute the payment point whose scalar is the seller's signature:\n> `sig*G = R + h(m, R)*A` where `A` is the seller's public key. Using this\n> value as the payment point, the buyer could be assured that they pay if and\n> only if they receive `sig` from the seller, where `sig` is the desired\n> valid signature of `m`!\n> \n> Best,\n> Nadav\n> \n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Selling Signatures: Another Reason to Move to Payment Points",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Jonas Nick",
                "Nadav Kohen",
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 25611
        }
    },
    {
        "title": "[Lightning-dev] Fwd: Paper: A Composable Security Treatment of the Lightning Network",
        "thread_messages": [
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-07-24T08:58:34",
                "message_text_only": "-- \nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336.\n\n\n-------- Forwarded Message --------\nSubject: Re: [Lightning-dev] Paper: A Composable Security Treatment of\nthe Lightning Network\nDate: Thu, 18 Jul 2019 17:47:20 +0100\nFrom: Orfeas Stefanos Thyfronitis Litos <o.thyfronitis at ed.ac.uk>\nTo: Lloyd Fournier <lloyd.fourn at gmail.com>\n\nHi Lloyd,\n\n> Thanks for formally modelling lightning\n\nThanks for the constructive questions.\n\n> I found F_PayNet to be rather difficult to follow\n\nI completely agree. F_PayNet is too complex for anyone's liking. Long\nstory short, this was the result of:\n* staying in the UC model (easier said than done)\n* building on top of G_Ledger (with all its complexity)\n* the modelling of the entire LN as a single functionality (minimizing\nabstraction leak)\n* not depending on the `clock` functionality (thus not obstructing\nG_Ledger and other protocols that use it)\n* possibly many other reasons (such as me being a noob dev)\n\nFWIW, it's still much simpler than the real-world protocol Pi_LN (e.g.\nhalf its length).\n\nI'm currently exploring alternative models where e.g. there's one\nfunctionality per channel. It may make things more modular, but may also\nexpose more gory details to the \"user\" of the functionality (i.e. the\ncryptographer who builds on top of those channels).\n\n> \"F_PayNet checks that for each payment the charged party was one of\n> the following: (a) the one that initiated the payment, (b) a malicious\n> party or (c) an honest party that is negligent\"\n>\n> Why not assume that (b) never happens because a malicious party never\n> wants to lose the funds from a party they've corrupted[?]\n\nIn security proofs we usually let the Adversary be any polynomial\nmachine. In particular, this includes the case where the Adversary does\nsilly things, such as not fulfilling HTLCs. Sure, it's not a rational\nthing to do, but rationality is of interest in a game-theoretic\nanalysis. (BTW, LN is a fine example of a protocol that requires both a\ncryptographic and a game-theoretic analysis, each of which could uncover\ndifferent flaws.)\n\nWe could restrict the adversary to always fulfilling the HTLCs it can,\nbut that would immediately exile us from UC territory.\n\n> [Why not assume] (c) never happens because honest parties follow the\n> protocol and check each ledger update for malicious channel closes?\n\nIf activated at the correct moment and with the correct command, honest\nparties indeed check the ledger. However, parties are activated by the\nEnvironment (another polynomial machine), which may simply refuse to\nactivate them in time. This is why honest parties may end up being\nnegligent.\n\nWe could tie the advancement of the protocol to the clock functionality\nto avoid the above, but that would bring a big degree of coupling of LN\nwith other protocols that use the clock. E.g. G_Ledger could stall\nbecause the Environment decided not to let some LN parties advance,\nwhich is very counterintuitive.\n\n> I am not convinced that the ideal and real worlds aren't easily\n> distinguishable from each other by an Environment that just looks at\n> the transactions in the blockchain (G_ledger).\n\nGood point, it's not explained well enough in the main body, we should\nupdate the description (pp. 10-11). We indeed take care to have the\nexact same transactions end up on-chain in both worlds (otherwise the\nproof of security wouldn't work). F_PayNet checks at several moments\nthat the ledger really contains the txs that would be there in the real\nworld. The trick is that instead of having F_PayNet prepare all\nnecessary transactions itself (i.e. \"speak LN\"), it forces the Simulator\nto do it by halting (and thus allowing the Environment to distinguish)\nin case it doesn't find the txs.\n\n> I don't understand this \"receipt\" mechanism.\n\nThe receipt is to let the environment know which channels were\nsuccessfully opened/closed and which payments were made. Importantly, it\ndoesn't contain any keys. As such, it is unrelated to the keypair that\ncan spend Alice's coins (the coins that Alice has before opening any\nchannel).\n\n> In the ideal world, the ideal functionality should be the one with the\n> private key signing the funding transaction directly\n\nIn the real world, Alice's key is created by the protocol instance when\nshe receives REGISTER (Fig. 19, line 9), whereas in the ideal world,\nthis key is created by the Simulator when it receives REGISTER from\nF_PayNet (Fig. 40, line 5). It's a bit counterintuitive on first\nthought, but F_PayNet shouldn't be managing private keys or doing\nsignatures. It should just ensure that Alice's public key contains the\npromised coins upon channel closing.\n\nNote that our approach is different from that mentioned by Andrew\nMiller. Since we ensure that on-chain txs are the same in both worlds,\nwe don't need to hide the ledger contents from the Environment.\n\nLet me know if I left anything unclear, or if you have further\nobservations/corrections/questions.\n\nBest,\nOrfeas"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Paper: A Composable Security Treatment of the Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Orfeas Stefanos Thyfronitis Litos"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5010
        }
    }
]