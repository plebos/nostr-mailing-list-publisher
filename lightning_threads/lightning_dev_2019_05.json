[
    {
        "title": "[Lightning-dev] Ptarmigan mainnet release",
        "thread_messages": [
            {
                "author": "Hiroki Gondo",
                "date": "2019-05-01T00:22:45",
                "message_text_only": "Arigatou gozaimasu ZmnSCPxj-san.\nSome bugs have already been fixed after the release :)\n\nRegards,\nHiroki\n\n2019\u5e744\u670830\u65e5(\u706b) 13:30 ZmnSCPxj <ZmnSCPxj at protonmail.com>:\n\n> Omedetou goziemasu Hiroki-san to Nayuta.\n> I hope you have good first mainnet release and fix many bug!\n>\n> Regards,\n> ZmnSCPxj\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Tuesday, April 30, 2019 9:00 AM, Hiroki Gondo <hiroki.gondo at nayuta.co>\n> wrote:\n>\n> > Hi, all.\n> >\n> > I\u2019m Hiroki (Nayuta team).\n> > We release mainnet version (reckless version) of our implementation.\n> > The name says \uff40Ptarmigan\uff40.\n> > https://github.com/nayutaco/ptarmigan\n> > Perhaps this is the fourth implementation of BOLT compliance!\n> > This is Reckless version, so we expect user try this software with the\n> amount afford to lose.\n> > Thanks.\n> >\n> > Best\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190501/1513f165/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Ptarmigan mainnet release",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Hiroki Gondo"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1041
        }
    },
    {
        "title": "[Lightning-dev] An Argument For Single-Asset Lightning Network",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2019-05-04T04:28:39",
                "message_text_only": "Hi ZmnSCPxj,\n\nI'm glad you pointed this out. I think this protocol is practical. That\ntalk was actually given by my colleague :).\nMy post in the December thread was trying to explain the same idea but as a\n[A -> Exchange -> A] on-chain trade (rather than a [A -> Exchange -> B]\ncross chain L2 payment). For reference:\nhttps://gist.github.com/LLFourn/d0afa6b37207aed7cd73f6b9203c0def.\n\nI mentioned it was possible to do it in a channel. Although looking back at\nit now it seems I was somewhat confused at the time. I said:\n\n> As ZmnSCPxj demonstrated, the idea of sending a payment in asset A and\nthe other party receiving it as asset B with some exchange node in the\nmiddle doing a conversion is unsound given what we are able to construct in\nLightning.\n\nAs you just showed, this is wrong. [A -> Exchange -> B] with the collateral\non the last hop works fine. After all, [A -> Exchange -> A] is just a\nspecial case of [A -> Exchange -> B]. I agree that extending this idea\nacross multiple hops after the exchange securely looks impossible.\n\nNote, the Exchange should watch carefully for their counter-party delaying\nin signing the channel update on the final hop (to gain value from the\noption this gives them).  If they notice this they should close the channel\nand avoid doing business with this party.\nDespite this, it's still a far better protocol than the vanilla atomic swap\nbecause the delaying party has a far less time to realise any gains from\nthe option. The exchange can put an end to it by closing the channel within\n1 on chain tx.\n\nOn naming. I think it's better to call it *collateral* rather than an\n*option premium* because it is only paid on a failure to execute the trade.\nI was thinking we can call them collateralized HTLCs.\n\nIt's possible to modify the protocol slightly so that the party receiving\nthe option pays the *premium* regardless of whether they release x or not.\nThis makes it a proper cross chain option with guaranteed premium.\nWe made a poster describing this idea here:\nhttps://coblox.tech/docs/financial_crypto19.pdf.\n\nCheers,\n\nLloyd\nOn Tue, Apr 23, 2019 at 1:52 PM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> Reviving an old thread, but I saw this just recently:\n> http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/\n>\n> Suppose you are a BTC to WJT exchange.\n> I want to pay 1 BTC to send 1000000000 WJT to YAIjbOJA.\n> I have a BTC channel to you.\n> You have a WJT channel to YAIjbOJA.\n>\n> In order to create a properly-incentivized American Call Option with a\n> premium, you insist that 10% of the WJT value be the premium that is paid\n> if the exchange does not pull through.\n>\n> We perform this ritual:\n>\n> 1.  YAIjbOJA generates a secret x and gives h(x) to me.\n> 2.  On my channel to you, I get 1 BTC from my side and create an HTLC.\n>     Hash is h(x) payable to you, timelock is 2 days payable to me.\n> 3.  On your channel to YAIjbOJA, you get 1000000000 WJT from you, and\n> 100000000 WJT (10%, the premium) from YAIjbOJA and create an HTLC.\n>     Hash is h(x) payable to YAIjbOJA, timelock is 1 days payable to you.\n>\n> The above also forms an American Call Option, but with a premium if the\n> payment does not push through.\n>\n> However, extending this to beyond one hop after the exchange node is\n> difficult.\n> Problems in communicating with the next hop may cause the current hop\n> after the exchange node to become liable for the premium without being able\n> to forward the liability to the final payee, which is an avenue for attack.\n> And if the payee must be the hop after the exchange node, the exchange\n> node now knows exactly how much and when that node receives payment, and\n> can sell this information and/or selectively disrupt/censor some payments.\n>\n> Putting the premium before the exchange node is possible with an\n> additional transaction spending the HTLC (the timelock branch is payable to\n> a 2-of-2 with a pre-signed transaction that sends the premium to the\n> exchange and returns the rest of the value to the payer).\n> But this is unsafe, since the exchange (and any node between the payer and\n> the exchange) can stall the protocol deliberately and refuse to forward,\n> extracting the premium via the timelock branch.\n> This is effectively forcing fees even in a route failure, which does not\n> incentivize intermediate nodes to actually forward when they can do nothing\n> and receive fees anyway for not routing.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190504/e1b48144/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-06T04:51:35",
                "message_text_only": "Good morning Lloyd,\n\nI think the most generic solution is to require multiple hashlocks.\nOne hashlock for the payee, the other for the exchange.\n\nPayer acquires an exchange hash from the exchange, plus specs of the collateral.\nThen payer routes to the payee via the exchange using two hashlocks (hashlock for the payment hash, hashlock for the exchange hash) and from the payee to the exchange.\nThe exchange onion hop includes the information that the cross-currency swap is allowed by pointing at the hashlock that the exchange hash is on.\nThe exchange verifies that it is one of the exchange hashes it has issued and it releases the agreed amount to the next hop, plus the collateral agreed upon.\n\nThe payee onion hop includes the information that it should proceed to give a single hashlock to succeeding hops, as well as the agreed-upon collateral to the exchange.\nThe exchange receives the payment with a single hashlock containing the value of the collateral.\nIt verifies that the collateral value is equal to the agreed collateral for that payment, then releases the exchange preimage.\nThe payee can then release its preimage once it has acquired the exchange preimage.\n\nThe above is similar to your solution, as it effectively means the payee offers collateral to the exchange, which it can only reclaim by properly completing the payment protocol.\nThe exchange can insist on getting a short timelock for receiving the collateral (i.e. limit the time horizon that the exchange hash is valid), to reduce the time horizon in which the payee can pay or not pay the collateral for the exchange (as before the payee releases the collateral, it still has the option of doing or not doing the swap, i.e. American Option).\nThe advantage is that it can go over multiple hops, and the exchange and payee do not know each other (but the payer does).\nDisadvantage is that it requires two hashlocks, which is rather obvious on the protocol and signals \"this payment is a cross-currency exchange payment!\" to all intermediate nodes; also, it still allows a short time duration for American Option shenanigans.\n\nThe Route Maker solution by CJP is plausible, to me, only if the exchange and the Route Maker are the same, which is effectively what is done here, but now requires multiple secrets to be revealed.\n\nI was thinking it might be possible, to use point/scalar and require the sum of the payment scalar and the exchange scalar, and thereby hide from intermediate nodes that multiple secrets are needed, but now the payer receives the sum of scalars instead of two separate preimages; this can make it difficult for protocols requiring proof-of-payment secrets (such as the offline vending machine discussed before) from working correctly.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, May 4, 2019 4:28 AM, Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> I'm glad you pointed this out. I think this protocol is practical. That talk was actually given by my colleague :).\n> My post in the December thread was trying to explain the same idea but as a [A -> Exchange -> A] on-chain trade (rather than a [A -> Exchange -> B] cross chain L2 payment). For reference: https://gist.github.com/LLFourn/d0afa6b37207aed7cd73f6b9203c0def.\n>\n> I mentioned it was possible to do it in a channel. Although looking back at it now it seems I was somewhat confused at the time. I said:\n>\n> > As ZmnSCPxj demonstrated, the idea of sending a payment in asset A and the other party receiving it as asset B with some exchange node in the middle doing a conversion is unsound given what we are able to construct in Lightning.\n>\n> As you just showed, this is wrong. [A -> Exchange -> B] with the collateral on the last hop works fine. After all, [A -> Exchange -> A] is just a special case of [A -> Exchange -> B]. I agree that extending this idea across multiple hops after the exchange securely looks impossible.\n>\n> Note, the Exchange should watch carefully for their counter-party delaying in signing the channel update on the final hop (to gain value from the option this gives them).\u00a0 If they notice this they should close the channel and avoid doing business with this party.\u00a0\n> Despite this, it's still a far better protocol than the vanilla atomic swap because the delaying party has a far less time to realise any gains from the option. The exchange can put an end to it by closing the channel within 1 on chain tx.\n>\n> On naming. I think it's better to call it *collateral* rather than an *option premium* because it is only paid on a failure to execute the trade.\n> I was thinking we can call them collateralized HTLCs.\n>\n> It's possible to modify the protocol slightly so that the party receiving the option pays the *premium* regardless of whether they release x or not. This makes it a proper cross chain option with guaranteed premium.\n> We made a poster describing this idea here: https://coblox.tech/docs/financial_crypto19.pdf.\n>\n> Cheers,\n>\n> Lloyd\n> On Tue, Apr 23, 2019 at 1:52 PM ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> > Good morning list,\n> >\n> > Reviving an old thread, but I saw this just recently: http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/\n> >\n> > Suppose you are a BTC to WJT exchange.\n> > I want to pay 1 BTC to send 1000000000 WJT to YAIjbOJA.\n> > I have a BTC channel to you.\n> > You have a WJT channel to YAIjbOJA.\n> >\n> > In order to create a properly-incentivized American Call Option with a premium, you insist that 10% of the WJT value be the premium that is paid if the exchange does not pull through.\n> >\n> > We perform this ritual:\n> >\n> > 1.\u00a0 YAIjbOJA generates a secret x and gives h(x) to me.\n> > 2.\u00a0 On my channel to you, I get 1 BTC from my side and create an HTLC.\n> > \u00a0 \u00a0 Hash is h(x) payable to you, timelock is 2 days payable to me.\n> > 3.\u00a0 On your channel to YAIjbOJA, you get 1000000000 WJT from you, and 100000000 WJT (10%, the premium) from YAIjbOJA and create an HTLC.\n> > \u00a0 \u00a0 Hash is h(x) payable to YAIjbOJA, timelock is 1 days payable to you.\n> >\n> > The above also forms an American Call Option, but with a premium if the payment does not push through.\n> >\n> > However, extending this to beyond one hop after the exchange node is difficult.\n> > Problems in communicating with the next hop may cause the current hop after the exchange node to become liable for the premium without being able to forward the liability to the final payee, which is an avenue for attack.\n> > And if the payee must be the hop after the exchange node, the exchange node now knows exactly how much and when that node receives payment, and can sell this information and/or selectively disrupt/censor some payments.\n> >\n> > Putting the premium before the exchange node is possible with an additional transaction spending the HTLC (the timelock branch is payable to a 2-of-2 with a pre-signed transaction that sends the premium to the exchange and returns the rest of the value to the payer).\n> > But this is unsafe, since the exchange (and any node between the payer and the exchange) can stall the protocol deliberately and refuse to forward, extracting the premium via the timelock branch.\n> > This is effectively forcing fees even in a route failure, which does not incentivize intermediate nodes to actually forward when they can do nothing and receive fees anyway for not routing.\n> >\n> > Regards,\n> > ZmnSCPxj\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-05-19T10:28:13",
                "message_text_only": "Hi ZmnSCPxj,\n\nSorry for the late reply I only recently had time to review your comments.\nI didn't really get your motivation for multiple secrets. In my mind,\nhaving the last hop put collateral into the HTLC to make a *Collateralized\nHTLC* solves the problem without any extra complexity (your original\nexample captures this perfectly). You wrote:\n\nThe exchange can insist on getting a short timelock for receiving the\n> collateral (i.e. limit the time horizon that the exchange hash is valid),\n> to reduce the time horizon in which the payee can pay or not pay the\n> collateral for the exchange (as before the payee releases the collateral,\n> it still has the option of doing or not doing the swap, i.e. American\n> Option).\n\n\nI think this unnecessary. The \"free option\" time isn't limited by a\ntimelock (if it was, we wouldn't have solved the problem). The option is\nlimited by the exchange's willingness to wait for the other party to sign\nthe state update (assuming the exchange signs first). The minor point I was\ntrying to make was that normally when routing payments etc you can be\nwilling to wait for minutes or hours for the other party to come back\nonline if they went offline during a state update. But if you are doing a\nswap and your partner is meant to be signing a collateralized HTLC you\nshouldn't wait; you should force settlement to the blockchain within a few\nseconds. As soon as the state gets onto the blockchain the other party has\nlost any chance of getting an option.\n\nAt a glance, the simplest way to enable this functionality is to add a new\nfield to the \"update_add_htlc\" BOLT message [1] like\n\"collateral_amount_sat\". The receiver of \"collateral_amount_sat\" would have\nto contribute that amount to the HTLC (if they are willing to go through\nwith the update). Obviously you should only ever agree to do this if you\nare last hop or are willing to risk your collateral on the honest behaviour\nof nodes further down.\n\nI was actually wondering if this could be a useful feature outside of\nswaps. e.g. if there is a new node without much reputation who you are\nrouting a payment to, you could demand that they put up collateral into the\nHLTC to receive the payment. This might help prevent attacks where people\ntry and tie up funds by receiving large payments they never release the\nsecrets for.\n\nWRT to your final comments, it sounds a bit like [2] which also mentions\nthat their protocol can make atomic swaps fungible.\n\n1.\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#adding-an-htlc-update_add_htlc\n2. Anonymous Multi-Hop Locks for Blockchain Scalability and\nInteroperability: https://eprint.iacr.org/2018/472.pdf\n\nCheers,\n\nLloyd\n\nOn Mon, May 6, 2019 at 2:51 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Lloyd,\n>\n> I think the most generic solution is to require multiple hashlocks.\n> One hashlock for the payee, the other for the exchange.\n>\n> Payer acquires an exchange hash from the exchange, plus specs of the\n> collateral.\n> Then payer routes to the payee via the exchange using two hashlocks\n> (hashlock for the payment hash, hashlock for the exchange hash) and from\n> the payee to the exchange.\n> The exchange onion hop includes the information that the cross-currency\n> swap is allowed by pointing at the hashlock that the exchange hash is on.\n> The exchange verifies that it is one of the exchange hashes it has issued\n> and it releases the agreed amount to the next hop, plus the collateral\n> agreed upon.\n>\n> The payee onion hop includes the information that it should proceed to\n> give a single hashlock to succeeding hops, as well as the agreed-upon\n> collateral to the exchange.\n> The exchange receives the payment with a single hashlock containing the\n> value of the collateral.\n> It verifies that the collateral value is equal to the agreed collateral\n> for that payment, then releases the exchange preimage.\n> The payee can then release its preimage once it has acquired the exchange\n> preimage.\n>\n> The above is similar to your solution, as it effectively means the payee\n> offers collateral to the exchange, which it can only reclaim by properly\n> completing the payment protocol.\n> The exchange can insist on getting a short timelock for receiving the\n> collateral (i.e. limit the time horizon that the exchange hash is valid),\n> to reduce the time horizon in which the payee can pay or not pay the\n> collateral for the exchange (as before the payee releases the collateral,\n> it still has the option of doing or not doing the swap, i.e. American\n> Option).\n> The advantage is that it can go over multiple hops, and the exchange and\n> payee do not know each other (but the payer does).\n> Disadvantage is that it requires two hashlocks, which is rather obvious on\n> the protocol and signals \"this payment is a cross-currency exchange\n> payment!\" to all intermediate nodes; also, it still allows a short time\n> duration for American Option shenanigans.\n>\n> The Route Maker solution by CJP is plausible, to me, only if the exchange\n> and the Route Maker are the same, which is effectively what is done here,\n> but now requires multiple secrets to be revealed.\n>\n> I was thinking it might be possible, to use point/scalar and require the\n> sum of the payment scalar and the exchange scalar, and thereby hide from\n> intermediate nodes that multiple secrets are needed, but now the payer\n> receives the sum of scalars instead of two separate preimages; this can\n> make it difficult for protocols requiring proof-of-payment secrets (such as\n> the offline vending machine discussed before) from working correctly.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, May 4, 2019 4:28 AM, Lloyd Fournier <lloyd.fourn at gmail.com>\n> wrote:\n>\n> > Hi ZmnSCPxj,\n> >\n> > I'm glad you pointed this out. I think this protocol is practical. That\n> talk was actually given by my colleague :).\n> > My post in the December thread was trying to explain the same idea but\n> as a [A -> Exchange -> A] on-chain trade (rather than a [A -> Exchange ->\n> B] cross chain L2 payment). For reference:\n> https://gist.github.com/LLFourn/d0afa6b37207aed7cd73f6b9203c0def.\n> >\n> > I mentioned it was possible to do it in a channel. Although looking back\n> at it now it seems I was somewhat confused at the time. I said:\n> >\n> > > As ZmnSCPxj demonstrated, the idea of sending a payment in asset A and\n> the other party receiving it as asset B with some exchange node in the\n> middle doing a conversion is unsound given what we are able to construct in\n> Lightning.\n> >\n> > As you just showed, this is wrong. [A -> Exchange -> B] with the\n> collateral on the last hop works fine. After all, [A -> Exchange -> A] is\n> just a special case of [A -> Exchange -> B]. I agree that extending this\n> idea across multiple hops after the exchange securely looks impossible.\n> >\n> > Note, the Exchange should watch carefully for their counter-party\n> delaying in signing the channel update on the final hop (to gain value from\n> the option this gives them).  If they notice this they should close the\n> channel and avoid doing business with this party.\n> > Despite this, it's still a far better protocol than the vanilla atomic\n> swap because the delaying party has a far less time to realise any gains\n> from the option. The exchange can put an end to it by closing the channel\n> within 1 on chain tx.\n> >\n> > On naming. I think it's better to call it *collateral* rather than an\n> *option premium* because it is only paid on a failure to execute the trade.\n> > I was thinking we can call them collateralized HTLCs.\n> >\n> > It's possible to modify the protocol slightly so that the party\n> receiving the option pays the *premium* regardless of whether they release\n> x or not. This makes it a proper cross chain option with guaranteed premium.\n> > We made a poster describing this idea here:\n> https://coblox.tech/docs/financial_crypto19.pdf.\n> >\n> > Cheers,\n> >\n> > Lloyd\n> > On Tue, Apr 23, 2019 at 1:52 PM ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good morning list,\n> > >\n> > > Reviving an old thread, but I saw this just recently:\n> http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/\n> > >\n> > > Suppose you are a BTC to WJT exchange.\n> > > I want to pay 1 BTC to send 1000000000 WJT to YAIjbOJA.\n> > > I have a BTC channel to you.\n> > > You have a WJT channel to YAIjbOJA.\n> > >\n> > > In order to create a properly-incentivized American Call Option with a\n> premium, you insist that 10% of the WJT value be the premium that is paid\n> if the exchange does not pull through.\n> > >\n> > > We perform this ritual:\n> > >\n> > > 1.  YAIjbOJA generates a secret x and gives h(x) to me.\n> > > 2.  On my channel to you, I get 1 BTC from my side and create an HTLC.\n> > >     Hash is h(x) payable to you, timelock is 2 days payable to me.\n> > > 3.  On your channel to YAIjbOJA, you get 1000000000 WJT from you, and\n> 100000000 WJT (10%, the premium) from YAIjbOJA and create an HTLC.\n> > >     Hash is h(x) payable to YAIjbOJA, timelock is 1 days payable to\n> you.\n> > >\n> > > The above also forms an American Call Option, but with a premium if\n> the payment does not push through.\n> > >\n> > > However, extending this to beyond one hop after the exchange node is\n> difficult.\n> > > Problems in communicating with the next hop may cause the current hop\n> after the exchange node to become liable for the premium without being able\n> to forward the liability to the final payee, which is an avenue for attack.\n> > > And if the payee must be the hop after the exchange node, the exchange\n> node now knows exactly how much and when that node receives payment, and\n> can sell this information and/or selectively disrupt/censor some payments.\n> > >\n> > > Putting the premium before the exchange node is possible with an\n> additional transaction spending the HTLC (the timelock branch is payable to\n> a 2-of-2 with a pre-signed transaction that sends the premium to the\n> exchange and returns the rest of the value to the payer).\n> > > But this is unsafe, since the exchange (and any node between the payer\n> and the exchange) can stall the protocol deliberately and refuse to\n> forward, extracting the premium via the timelock branch.\n> > > This is effectively forcing fees even in a route failure, which does\n> not incentivize intermediate nodes to actually forward when they can do\n> nothing and receive fees anyway for not routing.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190519/b8ffbfb6/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-19T11:01:02",
                "message_text_only": "Good morning Lloyd,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, May 19, 2019 6:28 PM, Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> Sorry for the\u00a0late reply I only recently had time to review your comments.\n> I didn't really get your motivation for multiple secrets. In my mind, having the last hop put collateral into the HTLC to make a Collateralized HTLC\u00a0solves the problem without any extra complexity (your original example captures this perfectly).\n\nThe exchange node itself must impose the collateral: it cannot trust any other node to impose the collateral on its behalf.\nRemember, the intent is that the route is known only by the payer; the exchange should not know which node is the last node.\nOtherwise, the exchange node can censor payments.\n\nSo:\n\n1.  The exchange node cannot know if its direct next hop is last or not (if it could know, then it could censor).\n    So we must require that the swap protocol can be operated without the payer and payee being direct peers of the exchange.\n2.  The exchange node needs to ensure that the ultimate payee will provide collateral.\n    It cannot depend on any other node enforcing that the ultimate payee will provide collateral (it should not trust the network).\n\nThus the need for multiple secrets.\n\nThe route is from payer -> exchange -> payee -> exchange.\nMultiple hop nodes may be inserted between the above participants.\nTwo secrets are demanded from payer to exchange to payee.\nOnly one secret is demanded from payee to exchange.\n\nAs a concrete example, suppose 1 BTC is equivalent to 100000000 WJT.\nAnd we agree to a 10% collateral in the exchange.\n\n1.  Payer acquires a payment hash from payee and a exchange hash from exchange.\n2.  Payer routes from itself to exchange to payee.\n    It releases 1 BTC, requiring both the exchange and payment preimages.\n3.  On reaching the exchange, it verifies the exchange rate and the collateral value, as well as that it knows the preimage of the exchange hash.\n    It releases 110000000 WJT to the next node (which might ***not*** be the payee: remember, we do not want the exchange to know who the final payee is, and this is still onion-routed), requiring both the exchange and payment preimage.\n4.  On reaching the payee, it checks the value is correct and that it knows the preimage of the payment hash.\n    It releases 10000000 WJT (the collateral) to the next node (which might ***not*** be the exchange: we do not want payees to become prejudiced against certain exchanges either, and this is still onion-routed).\n    This time, it requires only the exchange preimage.\n5.  On reaching the exchange once again, it claims the collateral by revealing the exchange preimage.\n6.  The payee learns the exchange preimage and can claim the payment value, and reclaim the collateral, by releasing the payment preimage and exchange preimages immediately.\n\n\nHaving multiple hops means an exchange cannot determine who is the ultimate payer and ultimate payee, and cannot impose any reasonable censorship policy.\nThus the exchange cannot operate as if the second-to-last hop can be relied upon to impose the collateral rule on the payee: the exchange must impose this collateral itself!\n\n\n> You wrote:\n>\n> > The exchange can insist on getting a short timelock for receiving the collateral (i.e. limit the time horizon that the exchange hash is valid), to reduce the time horizon in which the payee can pay or not pay the collateral for the exchange (as before the payee releases the collateral, it still has the option of doing or not doing the swap, i.e. American Option).\n>\n> I think this unnecessary. The \"free option\" time isn't limited by a timelock (if it was, we wouldn't have solved the problem). The option is limited by the exchange's willingness to wait for the other party to sign the state update (assuming the exchange signs first). The minor point I was trying to make was that normally when routing payments etc you can be willing to wait for minutes or hours for the other party to come back online if they went offline during a state update. But if you are doing a swap and your partner is meant to be signing a collateralized HTLC you shouldn't wait; you should force settlement to the blockchain within a few seconds. As soon as the state gets onto the blockchain the other party has lost any chance of getting an option.\n\nWhat?\n\nAll payments are still HTLCs.\n\nHTLCs are onchain contracts.\n\nThe original formulation pointed out that HTLCs, by themselves (even directly onchain) can form an American Call Option.\n\nWhen we force settlement on the blockchain, we just publish the same HTLCs we use offchain on the blockchain.\nThus any contract that takes effect offchain takes effect onchain.\nThat includes any American Call Option formed out of HTLCs.\nForcing it onchain just means you can no longer cancel the contract but are *forced* to wait out any timelocks.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "An Argument For Single-Asset Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 28461
        }
    },
    {
        "title": "[Lightning-dev] Possibility to Include refund invoice in lightning payments",
        "thread_messages": [
            {
                "author": "Paberlance",
                "date": "2019-05-12T23:24:49",
                "message_text_only": "Hello Lightning Devs,\n\ni was wondering about the following idea: What if you attach a refund invoice to any LN payment. With this the recipient then has the possibility to refund, fully, partially or eventually tipping even a higher payment amount back to the sender.\n\nFrom the user side, the userwallet pays just as normal Lightning Invoice, but attached along with the payment of 0 sat invoice back to the seller. From a UX perspective, this all happens is controlled by the wallet, which must agree on a protocol for embedding the return invoice with the LN payment.\n\nOn the recipee side, a normal LN invoice is recieved and optionally store that invoice to be able to perform a spontaneous refund later in time if he wants.As the invoice amount is not predefined, the seller is free to refund any payment, just bounded to the invoice timeout. Probably the payer will be motivated to issue invoices with a high expiry time-out.\n\nPossible Usecases:\n\n*Promotions, like: Every 100x Purchaser wins a prize, gets the order for free.\n\n*Refunds: I order something, cancel the transaction, seller refunds the transaction partially, charging a service fee that he does not return.\n\n*Safety deposits: You rent a car, the company keeps the payment as safety deposit, that gets reverted as soon as the car is returned.\n\n*Spontanous payouts in games\n\nAlternatives:\n\n*Hodl invoice, can achieve the same goal to refund the customer, but limited as it's an \"all or nothing refund\" option. Amount can't be more than the actual payment.\nhttps://github.com/lightningnetwork/lnd/pull/2022\n\n*\"Spontaneous LN invoice creation \" with server that acts as a lookup proxy that handles the lightning creation on request. Inspiration: @georgevaccaro\n\nRequirements:\n\nPayer has to generate a invoice and provide it encoded in the payment request as payload.\nReciver: must be able to settle the actual payment. And optionaly he may support the feature After storing the refund invoice, he then has the ability to decice if or how he will use it to refunde the client in the future.\n\nDoes this exist yet? What people can help me with this idea?\n\nAny ressources or hints to digg deeper, built on top of that idea?\n\nPaberlance\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190512/716f0d0f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Possibility to Include refund invoice in lightning payments",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Paberlance"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2380
        }
    },
    {
        "title": "[Lightning-dev] Eltoo, anyprevout and chaperone signatures",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-05-15T09:23:09",
                "message_text_only": "Good morning list,\n\nI have been digging into Anthony Towns' anyprevout BIP\n<https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-anyprevout.mediawiki>\nproposal\nto verify that it has everything we need for Eltoo\n<https://blockstream.com/eltoo.pdf>.\n\nThe separation between anyprevout and anyprevoutanyscript is very handy\n(compared to the previous noinput proposal).\nUnless I'm missing something, it would simplify the funding tx (to a simple\nmultisig without cltv/csv) and remove the need for the trigger tx.\n\nThe more tricky part to integrate is the chaperone signature.\nIf I understand it correctly (which I'm not guaranteeing), we would need to\nmodify the update transactions to something like:\n\nOP_IF\n\n    10 OP_CSV\n\n    1 A(s,i) B(s,i) 2 OP_CHECKMULTISIGVERIFY          <- public keys' first\n> byte in this line is 0x02 or 0x03\n\n    2 A(s,i) B(s,i) 2 OP_CHECKMULTISIGVERIFY          <- public keys' first\n> byte in this line is 0x00 or 0x01\n\nOP_ELSE\n\n    <S(i) + 1> OP_CLTV\n\n    1 A(u) B(u) 2  OP_CHECKMULTISIGVERIFY          <- public keys' first\n> byte in this line is 0x02 or 0x03\n\n    2 A(u) B(u) 2  OP_CHECKMULTISIGVERIFY          <- public keys' first\n> byte in this line is 0x00 or 0x01\n\nOP_END\n\n\n(I ommitted the tapscript changes, ie moving to OP_CHECKSIGADD, to\nhighlight only the chaperone changes)\n\nWhen updating the channel, Alice and Bob would exchange their\nanyprevoutanyscript signatures (for the 2-of-2 multisig).\nThe chaperone signature can be provided by either Alice or Bob at\ntransaction broadcast time (so that it commits to a specific input\ntransaction).\n\nIt seems to me that using the same key for both signatures (the chaperone\none and the anyprevoutanyscript one) is safe here, but if someone knows\nbetter I'm interested.\nIf that's unsafe, we simply need to introduce another key-pair (chaperone\nkey).\n\nIs that how you guys understand it too? Do you have other ideas on how to\ncomply with the need for a chaperone signature?\n\nNote that as Anthony said himself, the BIP isn't final and we don't know\nyet if chaperone signatures will eventually be needed, but I think it's\nuseful to make sure that Eltoo could support it.\n\nCheers,\nBastien\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190515/ce50601f/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2019-05-15T20:36:32",
                "message_text_only": "Hi Bastien,\n\nthanks for investigating.\n\n> I have been digging into Anthony Towns' anyprevout BIP\n> <https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-anyprevout.mediawiki>\n> proposal\n> to verify that it has everything we need for Eltoo\n> <https://blockstream.com/eltoo.pdf>.\n>\n> The separation between anyprevout and anyprevoutanyscript is very handy\n> (compared to the previous noinput proposal).\n> Unless I'm missing something, it would simplify the funding tx (to a simple\n> multisig without cltv/csv) and remove the need for the trigger tx.\n\nI think it makes sense for us to consider both variants, one committing\nto the script and the other not committing to the script, but I think it\napplies rather to the `update_tx` <-> `settlement_tx` link and less to\nthe `funding_tx` <-> `update_tx` link and `update_tx` <-> `update_tx`\nlink. The reason is that the `settlement_tx` needs to be limited to be\nbindable only to the matching `update_tx` (`anyprevout`), while\n`update_tx` need to be bindable to the `funding_tx` as well as any prior\n`update_tx` which differ in the script by at least the state number\n(hence `anyprevoutanyscript`).\n\nLike AJ pointed out in another thread, the use of an explicit trigger\ntransaction is not really needed since any `update_tx` can act as a\ntrigger transaction (i.e., start the relative timeouts to tick). This\nwas an oversight of mine, which may have contributed more confusion than\nnecessary :-)\n\nThe `funding_tx` itself doesn't need any form of timeout, in fact\ncollaborative spending/closing without a timeout should always be\npossible. The `settlement_tx`s can have a BIP68-style relative timelock,\nwhich also saves us a few bytes.\n\n> The more tricky part to integrate is the chaperone signature.\n> If I understand it correctly (which I'm not guaranteeing), we would need to\n> modify the update transactions to something like:\n>\n> OP_IF\n>\n>     10 OP_CSV\n>\n>     1 A(s,i) B(s,i) 2 OP_CHECKMULTISIGVERIFY          <- public keys' first\n>> byte in this line is 0x02 or 0x03\n>\n>     2 A(s,i) B(s,i) 2 OP_CHECKMULTISIGVERIFY          <- public keys' first\n>> byte in this line is 0x00 or 0x01\n>\n> OP_ELSE\n>\n>     <S(i) + 1> OP_CLTV\n>\n>     1 A(u) B(u) 2  OP_CHECKMULTISIGVERIFY          <- public keys' first\n>> byte in this line is 0x02 or 0x03\n>\n>     2 A(u) B(u) 2  OP_CHECKMULTISIGVERIFY          <- public keys' first\n>> byte in this line is 0x00 or 0x01\n>\n> OP_END\n\nWe could collapse those 1-of-2 multisigs into a single-sig if we just\ncollaboratively create a shared private key that is specific to the\ninstance of the protocol upon setup. That minimizes the extra space\nneeded.\n\nSomething that I notived talking to Jonas Nick is that we might have\nsome interaction between the taproot and noinput (or any of its aliases\n:D). Specifically we can't make make use of the collaborative path where\nwe override an `update_tx` with a newer one in taproot as far as I can\nsee, since the `update_tx` needs to be signed with noinput (for\nrebindability) but there is no way for us to specify the chaperone key\nsince we're not revealing the committed script.\n\n> (I ommitted the tapscript changes, ie moving to OP_CHECKSIGADD, to\n> highlight only the chaperone changes)\n>\n> When updating the channel, Alice and Bob would exchange their\n> anyprevoutanyscript signatures (for the 2-of-2 multisig).\n> The chaperone signature can be provided by either Alice or Bob at\n> transaction broadcast time (so that it commits to a specific input\n> transaction).\n>\n> It seems to me that using the same key for both signatures (the chaperone\n> one and the anyprevoutanyscript one) is safe here, but if someone knows\n> better I'm interested.\n> If that's unsafe, we simply need to introduce another key-pair (chaperone\n> key).\n>\n> Is that how you guys understand it too? Do you have other ideas on how to\n> comply with the need for a chaperone signature?\n>\n> Note that as Anthony said himself, the BIP isn't final and we don't know\n> yet if chaperone signatures will eventually be needed, but I think it's\n> useful to make sure that Eltoo could support it.\n\nI quite like the chaperone idea, however it doesn't really play nice\nwith taproot collaborative spends that require anyprevout /\nanyprevoutanyscript / noinput, which would make our transactions stand\nout quite a bit. Then again this is only the case for the unhappy,\nunilateral close, path of the protocol, which (hopfully) should happen\nrarely.\n\nCheers,\nChristian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-16T01:48:51",
                "message_text_only": "Good morning,\n\n\n>\n> We could collapse those 1-of-2 multisigs into a single-sig if we just\n> collaboratively create a shared private key that is specific to the\n> instance of the protocol upon setup. That minimizes the extra space\n> needed.\n\nFor that matter the `OP_CHECKMULTISIG`/`OP_CHECKSIGADD` could be reduced by using MuSig on the two participants.\nFurther, there is no need for an explicit `OP_CHECKSEQUENCEVERIFY` or even separate keys for state and update paths.\nxref. https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-March/001933.html\n\nThe proposal that does not include `OP_CODESEPARATOR` is:\n\n    <index> OP_CHECKLOCKTIMEVERIFY OP_DROP\n    <MuSig(A_u, B_u)> OP_CHECKSIG <C> OP_CHECKSIG\n\nWhere `C` is the common key that Christian described above, and `index` is the update number index.\n\nFor update transactions, `nSequence` is 0.\nFor state transactions, `nSequence` is non-0.\nBoth of them will have `nLockTime` equal to the required index.\nThe `nSequence` is enforced by the participants refusing to sign invalid `nSequence`.\n\nThe above seems quite optimized.\n\n> > (I ommitted the tapscript changes, ie moving to OP_CHECKSIGADD, to\n> > highlight only the chaperone changes)\n> > When updating the channel, Alice and Bob would exchange their\n> > anyprevoutanyscript signatures (for the 2-of-2 multisig).\n> > The chaperone signature can be provided by either Alice or Bob at\n> > transaction broadcast time (so that it commits to a specific input\n> > transaction).\n> > It seems to me that using the same key for both signatures (the chaperone\n> > one and the anyprevoutanyscript one) is safe here, but if someone knows\n> > better I'm interested.\n> > If that's unsafe, we simply need to introduce another key-pair (chaperone\n> > key).\n> > Is that how you guys understand it too? Do you have other ideas on how to\n> > comply with the need for a chaperone signature?\n> > Note that as Anthony said himself, the BIP isn't final and we don't know\n> > yet if chaperone signatures will eventually be needed, but I think it's\n> > useful to make sure that Eltoo could support it.\n>\n> I quite like the chaperone idea, however it doesn't really play nice\n> with taproot collaborative spends that require anyprevout /\n> anyprevoutanyscript / noinput, which would make our transactions stand\n> out quite a bit. Then again this is only the case for the unhappy,\n> unilateral close, path of the protocol, which (hopfully) should happen\n> rarely.\n\nThe mere use of any `SIGHASH` that is not `SIGHASH_ALL` already stands out.\nSo I think this is not a significant objection.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-05-16T07:55:57",
                "message_text_only": "Thanks for your answers and links, the previous discussions probably\nhappened before I joined this list so I'll go dig into the archive ;)\n\n> I think it makes sense for us to consider both variants, one committing\n> to the script and the other not committing to the script, but I think it\n> applies rather to the `update_tx` <-> `settlement_tx` link and less to\n> the `funding_tx` <-> `update_tx` link and `update_tx` <-> `update_tx`\n> link. The reason is that the `settlement_tx` needs to be limited to be\n> bindable only to the matching `update_tx` (`anyprevout`), while\n> `update_tx` need to be bindable to the `funding_tx` as well as any prior\n> `update_tx` which differ in the script by at least the state number\n> (hence `anyprevoutanyscript`).\n\n> Like AJ pointed out in another thread, the use of an explicit trigger\n> transaction is not really needed since any `update_tx` can act as a\n> trigger transaction (i.e., start the relative timeouts to tick).\n\nThanks for confirming, that was how I understood it too.\n\n> Specifically we can't make make use of the collaborative path where\n> we override an `update_tx` with a newer one in taproot as far as I can\n> see, since the `update_tx` needs to be signed with noinput (for\n> rebindability) but there is no way for us to specify the chaperone key\n> since we're not revealing the committed script.\n\nCan you expand on that? Why do we need to \"make use of the collaborative\npath\" (maybe it's unclear to me what you mean by collaborative path here)?\nWhen we override an `update_tx` we use a new state number and we derive the\nnew keys for that state independently of the keys of the previous state\nright?\nSo we would derive new settlement keys and potentially chaperone keys, and\nre-create a merkle tree and taproot from scratch.\nI don't see where taproot interacts in a negative way with noinput there...\n\n> For that matter the `OP_CHECKMULTISIG`/`OP_CHECKSIGADD` could be reduced\nby using MuSig on the two participants.\n> Further, there is no need for an explicit `OP_CHECKSEQUENCEVERIFY` or\neven separate keys for state and update paths.\n\nThanks for the suggestions, these are good optimizations.\nI feel like there will be a few other optimizations that are unlocked by\ntaproot/tapscript, it will be interesting to dig into that.\n\nThanks,\nBastien\n\nLe jeu. 16 mai 2019 \u00e0 03:48, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning,\n>\n>\n> >\n> > We could collapse those 1-of-2 multisigs into a single-sig if we just\n> > collaboratively create a shared private key that is specific to the\n> > instance of the protocol upon setup. That minimizes the extra space\n> > needed.\n>\n> For that matter the `OP_CHECKMULTISIG`/`OP_CHECKSIGADD` could be reduced\n> by using MuSig on the two participants.\n> Further, there is no need for an explicit `OP_CHECKSEQUENCEVERIFY` or even\n> separate keys for state and update paths.\n> xref.\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-March/001933.html\n>\n> The proposal that does not include `OP_CODESEPARATOR` is:\n>\n>     <index> OP_CHECKLOCKTIMEVERIFY OP_DROP\n>     <MuSig(A_u, B_u)> OP_CHECKSIG <C> OP_CHECKSIG\n>\n> Where `C` is the common key that Christian described above, and `index` is\n> the update number index.\n>\n> For update transactions, `nSequence` is 0.\n> For state transactions, `nSequence` is non-0.\n> Both of them will have `nLockTime` equal to the required index.\n> The `nSequence` is enforced by the participants refusing to sign invalid\n> `nSequence`.\n>\n> The above seems quite optimized.\n>\n> > > (I ommitted the tapscript changes, ie moving to OP_CHECKSIGADD, to\n> > > highlight only the chaperone changes)\n> > > When updating the channel, Alice and Bob would exchange their\n> > > anyprevoutanyscript signatures (for the 2-of-2 multisig).\n> > > The chaperone signature can be provided by either Alice or Bob at\n> > > transaction broadcast time (so that it commits to a specific input\n> > > transaction).\n> > > It seems to me that using the same key for both signatures (the\n> chaperone\n> > > one and the anyprevoutanyscript one) is safe here, but if someone knows\n> > > better I'm interested.\n> > > If that's unsafe, we simply need to introduce another key-pair\n> (chaperone\n> > > key).\n> > > Is that how you guys understand it too? Do you have other ideas on how\n> to\n> > > comply with the need for a chaperone signature?\n> > > Note that as Anthony said himself, the BIP isn't final and we don't\n> know\n> > > yet if chaperone signatures will eventually be needed, but I think it's\n> > > useful to make sure that Eltoo could support it.\n> >\n> > I quite like the chaperone idea, however it doesn't really play nice\n> > with taproot collaborative spends that require anyprevout /\n> > anyprevoutanyscript / noinput, which would make our transactions stand\n> > out quite a bit. Then again this is only the case for the unhappy,\n> > unilateral close, path of the protocol, which (hopfully) should happen\n> > rarely.\n>\n> The mere use of any `SIGHASH` that is not `SIGHASH_ALL` already stands out.\n> So I think this is not a significant objection.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190516/babb713d/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-05-16T15:37:48",
                "message_text_only": "On Thu, May 16, 2019 at 09:55:57AM +0200, Bastien TEINTURIER wrote:\n> Thanks for your answers and links, the previous discussions probably happened\n> before I joined this list so I'll go dig into the archive ;)\n\nThe discussion was on a different list anyway, I think, this might be\nthe middle of the thread:\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016777.html\n\n> > Specifically we can't make make use of the collaborative path where\n> > we override an `update_tx` with a newer one in taproot as far as I can\n> > see, since the `update_tx` needs to be signed with noinput (for\n> > rebindability) but there is no way for us to specify the chaperone key\n> > since we're not revealing the committed script.\n> Can you expand on that? Why do we need to \"make use of the collaborative path\"\n> (maybe it's unclear to me what you mean by collaborative path here)?\n\nI think Christian means the \"key path\" per the terminology in the\ntaproot bip. That's the path that just provides a signature, rather than\nproviding an internal key, a script, and signatures etc for the script.\n\n> I feel like there will be a few other optimizations that are unlocked by\n> taproot/tapscript, it will be interesting to dig into that.\n\nI had a go at drafting up scripts, and passed them around privately to\nsome of the people on this list already. They're more \"thought bubble\"\nthan even \"draft\" yet, but for the sake of discussion:\n\n---\nFWIW, the eltoo scripts I'm imaginging with this spec are roughly:\n\nUPDATE TX n:\n  nlocktime: 500e6+n\n  nsequence: 0\n  output 0:\n    P = muSig(A,B)\n    scripts = [\n      \"OP_1 CHECKSIGVERIFY X CHECKSIGVERIFY 500e6+n+1 CLTV\"\n    ]\n witness:\n    sig(P,hash_type=SINGLE|ANYPREVOUTANYSCRIPT=0xc3)\n    sig(X,hash_type=0)\n\nSETTLEMENT TX n:\n  nlocktime: 500e6+n+1\n  nsequence: [delay]\n  output 0: A\n  output 1: B\n  output n: (HTLC)\n    P = muSig(A,B)\n    scripts = [\n      \"OP_1 CHECKSIGVERIFY X CHECKSIG\"\n      \"A CHECKSIGVERIFY <t> CLTV\"\n    ]\n  witness:\n    sig(P,hash_type=ALL|ANYPREVOUT=0x41)\n    sig(X,hash_type=0)\n\nHTLC CLAIM (reveal secp256k1 preimage R):\n  witness:\n    hash-of-alternative-script\n    sig(P,hash_type=SINGLE|ANYPREVOUT,reveal R)\n    sig(X,hash_type=0)\n\nHTLC REFUND (timeout):\n  witness:\n    hash-of-alternative-script\n    sig(A,hash_type=ALL)\n\nBecause \"n\" changes for each UPDATE tx, each ANYPREVOUT signature\n(for the SETTLEMENT tx) commits to a specific UPDATE tx via both the\nscriptPubKey commitment and the tapleaf_hash commitment.\n\nSo the witness data for both txs involve revealing:\n\n    33 byte control block\n    43 byte redeem script\n    65 byte anyprevout sig\n    64 byte sighash all sig\n\nCompared to a 65 byte key path spend (if ANYPREVOUT worked for key paths),\nthat's an extra 143 WU or 35.75 vbytes, so about 217% more expensive. The\nupdate tx script proposed in eltoo.pdf is (roughly):\n\n\"IF 2 Asi Bsi ELSE <500e6+n+1> CLTV DROP 2 Au Bu ENDIF 2 OP_CHECKMULTISIG\"\n\n    148 byte redeem script\n    65 byte anyprevout sig by them\n    64 byte sighash all sig by us\n    \"1\" or \"0\" to control the IF\n\nwhich I think would be about 282 WU total, or an extra 216 WU/54 vbytes\nover a 65 byte key path spend, so about 327% more expensive. So at least\nwe're a lot better than where we were with BIP 118, ECDSA and p2wsh.\n\nDepending on if you can afford generating a bunch more signatures you\ncould also have a SIGHASH_ALL key path spend for the common unilateral\ncase where only a single UPDATE TX is published.\n\nUPDATE TX n (alt):\n  input: FUNDING TX\n  witness: sig(P,hash_type=0)\n  output 0:\n    P = muSig(A,B)\n    scripts = [\n      \"OP_1 CHECKSIGVERIFY X CHECKSIGVERIFY 500e6+n+1 CLTV\"\n    ]\n\nSETTLEMENT TX n (alt):\n  nsequence: [delay]\n  input: UPDATE TX n (alt)\n  witness: sig(P+H(P||scripts)*G,hash_type=0)\n  outputs: [as above]\n\n(This approach can either use the same ANYPREVOUT sigs for the HTLC\nclaims, or could include an additional sig for each active HTLC for each\nchannel update to allow HTLC claims via SIGHASH_ALL scriptless scripts...)\n\nDespite using SIGHASH_SINGLE, I don't think you can combine two UPDATE txs\ngenerally, because the nlocktime won't match (this could possibly be fixed\nin a future soft-fork by using the annex to support per-input absolute\nlocktimes). You can't combine SETTLEMENT tx, because the ANYPREVOUT\nsignature needs to commit to multiple outputs (one for my balance, one\nfor yours, one for each active HTLC). Combining HTLC refunds is kind-of\neasy, but only possible in the first place if you've got a bunch expiring\nat the same time, which might not be that likely. Combining HTLC claims\nshould be easy enough since they just need scriptless-script signatures.\n\nFor fees, because of ALL|ANYPREVOUT, you can add a new input and new\nchange output to bring-your-own-fees for the UPDATE tx; and while you\ncan't do that for the SETTLEMENT tx, you can immediately spend your\nchannel-balance output to add fees via CPFP.\n\nAs far as \"X\" goes, calculating the private key as a HD key using ECDH\nbetween the peers to generate the seed, and including the update id \"n\"\nin the path, to vary it between each update tx might work well. You'd\nneed to give this key to watchtowers, but you'll probably have to pay\nwatchtowers to monitor your txs (so that they can add fees to the UPDATE\ntx's), so only giving this key to the watchtowers you pay should maintain\nthe security assumptions.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-18T16:45:07",
                "message_text_only": "Good morning,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, May 16, 2019 3:55 PM, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Thanks for your answers and links, the previous discussions probably happened before I joined this list so I'll go dig into the archive ;)\n>\n> > I think it makes sense for us to consider both variants, one committing\n> > to the script and the other not committing to the script, but I think it\n> > applies rather to the `update_tx` <-> `settlement_tx` link and less to\n> > the `funding_tx` <-> `update_tx` link and `update_tx` <-> `update_tx`\n> > link. The reason is that the `settlement_tx` needs to be limited to be\n> > bindable only to the matching `update_tx` (`anyprevout`), while\n> > `update_tx` need to be bindable to the `funding_tx` as well as any prior\n> > `update_tx` which differ in the script by at least the state number\n> > (hence `anyprevoutanyscript`).\n>\n> > Like AJ pointed out in another thread, the use of an explicit trigger\n> > transaction is not really needed since any `update_tx` can act as a\n> > trigger transaction (i.e., start the relative timeouts to tick).\n>\n> Thanks for confirming, that was how I understood it too.\n>\n> > Specifically we can't make make use of the collaborative path where\n> > we override an `update_tx` with a newer one in taproot as far as I can\n> > see, since the `update_tx` needs to be signed with noinput (for\n> > rebindability) but there is no way for us to specify the chaperone key\n> > since we're not revealing the committed script.\n>\n> Can you expand on that? Why do we need to \"make use of the collaborative path\" (maybe it's unclear to me what you mean by collaborative path here)?\n\nThe collaborative path is the use of the taproot-tweaked public key to sign, without revealing any scripts.\nThe bip-taproot proposal specifically disallows all `SIGHASH` that is not the current set of valid `SIGHASH` flags when using this path, and thus does not include `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`.\n\nNew `SIGHASH` types *are* allowed in bip-tapscript (i.e. when signing for a `OP_CHECKSIG` variant inside a taproot script), and this is where the proposal of aj builds upon.\n\nFor myself, I do not see any point in using the collaborative path unless we are cooperatively closing anyway.\nAnd once we are cooperatively closing, we can agree to spend the funding txo without requiring that `SIGHASH_ANYPREVOUT` be used (since we already have fallbacks in case of cooperation failure, i.e. the existing update/settlement txes).\nSo again I do not see this to be an issue.\n(I could be wrong)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2019-05-20T13:03:24",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n\n>> Can you expand on that? Why do we need to \"make use of the\n>> collaborative path\" (maybe it's unclear to me what you mean by\n>> collaborative path here)?\n>\n> The collaborative path is the use of the taproot-tweaked public key to\n> sign, without revealing any scripts.  The bip-taproot proposal\n> specifically disallows all `SIGHASH` that is not the current set of\n> valid `SIGHASH` flags when using this path, and thus does not include\n> `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`.\n>\n> New `SIGHASH` types *are* allowed in bip-tapscript (i.e. when signing\n> for a `OP_CHECKSIG` variant inside a taproot script), and this is\n> where the proposal of aj builds upon.\n>\n> For myself, I do not see any point in using the collaborative path\n> unless we are cooperatively closing anyway.  And once we are\n> cooperatively closing, we can agree to spend the funding txo without\n> requiring that `SIGHASH_ANYPREVOUT` be used (since we already have\n> fallbacks in case of cooperation failure, i.e. the existing\n> update/settlement txes).  So again I do not see this to be an issue.\n> (I could be wrong)\n\nYou are correct. I forgot that the updates, besides being signed by both\nparties, also need to enforce the correct ordering through the CLTV\nopcode which cannot be part of the key path (thanks AJ for the correct\nname). Hence only collaborative closes can use the key path, which means\nwe sadly don't gain much from using taproot in the update-settlement\nstructure, i.e., the unilateral case is always visible on-chain.\n\nCheers,\nChristian"
            }
        ],
        "thread_summary": {
            "title": "Eltoo, anyprevout and chaperone signatures",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Anthony Towns",
                "ZmnSCPxj",
                "Christian Decker"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 24301
        }
    },
    {
        "title": "[Lightning-dev] Trampoline Onion Routing proposal",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-05-23T14:35:19",
                "message_text_only": "Good morning list,\n\nI have been working on formalizing how trampoline onion routing could work\nand just published a PR here\n<https://github.com/lightningnetwork/lightning-rfc/pull/611>.\nComments are welcome as this introduces changes at several layers.\n\nMobile phones are already struggling to keep up with the bandwidth and CPU\nrequirements to do source-routing.\nTrampoline onion routing maintains the same security assumptions (and even\nincreases the anonymity set) at the\ncost of higher fees and timeout values for the payer (and thus more gains\nfor trampoline nodes).\n\nHere is a high-level summary of the changes required:\n\n   - A new version of the onion packet with a smaller size than v0 (but\n   with the same cryptographic operations and security guarantees)\n   - A new *node_update* message advertising trampoline fees and cltv\n   - New logic to run on trampoline nodes to estimate such fees and cltv\n   - A filter system for *channel_updates* and *node_updates*\n   - This doesn't change anything to the way HTLCs are forwarded, failed or\n   succeeded\n\nPlease read the full document for details (and feel free to comment\ndirectly on the PR).\n\nAn interesting side-note is that this also enables rendezvous routing and\nmany other \"onion in an onion\" constructions.\n\nCheers,\nBastien\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190523/8fcd70f4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Trampoline Onion Routing proposal",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1473
        }
    }
]