[
    {
        "title": "[Lightning-dev] PoDLEs revisited",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2021-01-04T06:13:05",
                "message_text_only": "Happy New Year Lightning Developers,\n\nI've recently been closely looking at the dual funding proposal [1] because\nit uses a DLEQ proof (PoDLE) which we are also working on specifying as\npart of DLC ECDSA adaptor signatures [2].\nWhile reading it I had some queries and ideas that I thought were worth\nsharing (even though they are very very late).\n\n# Background\n\nLisa posted a draft proposal [1] which includes the PoDLE and explained it\nin [3] along with a good list of its weaknesses.\nThe original discussion thread where the idea was conceived is [4] and\nthere is an excellent summary in the following optech [5] which I post\nbelow:\n\n> Another proposal was to use PoDLE, which was originally developed for\nJoinMarket based on a suggestion by Gregory Maxwell. This protocol allows\nan initiating user such as Mallory to commit to a UTXO in a way that\nprevents anyone from identifying that UTXO. The participating user, such as\nBob, publishes the commitment across the network (e.g. the JoinMarket\nnetwork) so that nobody else will start a session with Mallory while she\u2019s\nusing that particular UTXO. Then Bob asks Mallory to identify her UTXO and,\nif it\u2019s a valid UTXO that matches her commitment, Bob discloses his UTXO to\nMallory so that they can proceed with the protocol (e.g. a coinjoin). If\nMallory aborts the protocol before completion, the commitment previously\npublished across the network prevents her from being able to start a new\nsession with any other user and so learn their UTXO. Mallory\u2019s only option\nis to spend her coins from herself to herself in order to generate a new\nUTXO\u2014a process that costs her money and so limits her ability to spy on\nusers. (Note, though, that PoDLE as implemented in JoinMarket allows\nMallory up to three retries by default so honest users aren\u2019t penalized for\noccasional accidental failures, such as a loss of network connectivity.)\nThe idea is to adapt this protocol for LN in order to prevent attackers\nfrom learning which available UTXOs are controlled by LN users.\n\nEspecially relevant to this post is the idea posted by Darosior here [6]\nwhich was summarized as follows:\n\n> One proposal to fix this would require the person proposing to open the\nchannel (e.g. Mallory) to provide their UTXO(s) in a ready-to-spend state\nso that probing would cost money (e.g. transaction fees). A downside of\nthis approach is that the construction proposed would be easily\nidentifiable by block chain analysis, making it easy to determine when a\ndual-funded channel was opened\n\nThe goals of this post is to (i) see if I understand the PoDLE idea\ncorrectly, to (ii) refine Darosior's idea and to (iii) propose a minimal\nalternative idea.\n\n#  Requirements\n\nInformally, here are the desirable properties I came up with for a dual\nfunding protocol:\n\n1. If a malicious initiator learns a peer UTXO, then the initiator should\nhave to spend their UTXOs before reusing them against the next peer (should\nbe forced to spend them to repeat attack -- *if attacking sequentially*).\n2. A malicious initiator should not be able to use the same UTXOs in\nparallel with multiple peers (to learn the UTXOs of multiple makers with a\nsingle UTXO).\n3. An honest initiator should not have to spend their UTXOs if they execute\nwith a malicious peer.\n4. dual-funded opening transactions should not have any distinguishing\nfeatures (i.e. sighash flags).\n5. An honest but intermittently failing initiator should not have their\nUTXO details sent by an honest peer to other parties.\n\nNote I am going to ignore property (2) because of proposals below can turn\ntheir protection against sequential attacks (1) into protection against\nparallel attacks (2) by having the peer choose a random time delay and see\nif anything is gossiped to them that would indicate malicious behavior by\nthe initiator in some other channel.\n\n# PoDLEs\n\nTo solve this problem in JoinMarket, Waxwing had the idea [8] of turning\nknowledge of a secret key for a particular UTXO into a kind of unlinkable\ncredential.\nGiven a UTXO public key P1, the initiator projects their private key onto a\ndifferent generator J to produce P2.\nP2 is unlinkable to P1 (without a proof) but is fully determined by P1.\nThis allows participants to maintain a blacklist of P2s without learning\nthe P1s.\nHaving the P1s in the blacklist would make the blacklist itself useful for\nchain analysis because it contains a list of UTXOs that tried to open\nchannels (but perhaps accidentally failed).\n\nThe idea is like this:\n1. Taker asks some maker's if they want to do a coinjoin and sends them all\nSHA256(P2)\n2. When they find the maker they want to proceed with they reveal P2 and\nprove DLEQ((P1, G), (P2, J)) i.e. P1 and P2 have the same private key just\ndifferent base points.\n3. If they haven't received SHA256(P2)from the gossip network (i.e. it's\nnot in the blacklist), the maker then sends their own UTXO data AND gossips\nSHA256(P2)\n4. They carry on the protocol.\n\nThe current lightning proposal [1] follows the same logic except that it\nonly gossips SHA256(P2) in case of malicious behavior (this seems sensible).\nIf I understood it correctly, then it achieves properties (1,4,5).\n\nThe main downside is that it introduces a new gossip message. The\ndifficulties associated with this are listed in [3].\nNotably it is missing property (3) - protection against malicious peers who\ngossip SHA256(P2) even when there was no wrongdoing.\n\nA question I have is why is SHA256(P2) sent up front? I think that P2 can\njust be sent along with the proof later on in the case of dual funding.\nWaxwing gave an explanation of it in the case of joinmarket in [7] but I\ndidn't grasp it.\n\n# Darosior's SIGHASH_SINGLE|SIGHASH_ANYONECANPAY\n\nThe proposal from Darosior [6] is to have the taker provide their inputs in\na ready to broadcast state using SIGHASH_SIGNLE|SIGHASH_ANYONECANPAY.\nThis way the peer never needs to send their inputs directly to the\ninitiator (the initiator will only find out about them when the transaction\nis broadcast).\nI encourage the reader to look at [6] which has nice diagrams and is very\nshort and to the point.\nThis achieves all properties except for (4 - distinguishable on-chain)\nwhich is why it was dismissed.\n\nI think it is possible to extend the idea to achieve (4) and therefore\nobtain all desired properties.\nSimply put peers can just use the SINGLE|ANYONECANPAY signature as back ups\nin case of abort. Here's how it could work in my mind:\n\n1. Initiator requests dual-funding and provides a TX_temp spending their\ninput set to a main output and a change output (does not sign it yet). They\nalso provide a sighash SIGNLE|ANYONECANPAY signature on the main output\nspending into TX_backup-fund and a signature on the first commitment\ntransaction spending from TX_backup-fund (exactly as in [6]).\n2. Peer responds with commitment TX signature for TX_backup-fund.\n3. Initiator responds with the signatures for TX_temp.\n*Peer now has a fully functional transaction chain with which to open the\nchannel -- now they can attempt to upgrade to a SIGHASH_ALL opening*.\n4. Peer (if possible) checks there are no existing transactions in the\nchain or mempool spending from the taker's inputs. If not it responds with\nits inputs, change and commitment tx signature for a SIGHASH_ALL TX_fund.\n5. Initiator responds with commitment TX signature and TX_fund input\nsignatures.\n6. Peer broadcasts TX_fund.\n*If at any point after step 3 Initiator does not respond for ~2 seconds\nthey broadcast TX_temp and TX_backup-funding*\n\nWe have (4) because the SINGLE|ANYONECANPAY signature only appears on-chain\nin case of abort (i.e. TX_backup-funding makes it on-chain).\nIt appears to be pretty close to the ideal solution in terms of privacy and\nsecurity.\nIf the malicious initiator learns an output they will always have to spend\none of their inputs otherwise they will quickly get hit by the TX_temp +\nTX_backup-funding.\nNote that it is possible the node is just slow in which case even if step\nTX_backup-funding makes it in both parties should just carry on with the\nchannel.\n\nThe downsides are that it involves six rounds of communication and cannot\nuse the \"interactive tx building\" protocol developed for the original\nproposal\n\n# Signaling Transactions\n\nFinally I present a simple but unintuitive protocol that achieves roughly\nthe same properties as the PoDLE protocol but without lightning gossip\nmessages.\n\nWhenever the initiator adds an input in the interactive tx building they\nprovide signatures on a \"signaling\" transaction spending that input (and\nany inputs they have added so far).\nThe signaling transactions will typically spend the funds back to the\ninitiator's wallet.\nBefore revealing any of their inputs, the peer checks that none of the\ninputs added by the initiator are in their mempool/chain.\nIf the initiator aborts the protocol after learning one of the peer's\ninputs the peer broadcasts one of the signaling transactions.\n\nLike the PoDLE proposal this doesn't achieve (3) since a malicious peer\ncould broadcast the signaling transaction making the honest initiator pay a\ntransaction fee before using the input in another session.\nTo mitigate this a bit, the transactions could be RBF and have a 1\nsat-per-byte feerate to give the initiator a decent amount of time to use\ntheir input productively before the tx confirms (and paying a low fee if it\never does confirm).\n\nThe advantages of signaling transactions over PoDLE is that it doesn't\ninvolve any wonky crypto or new gossip messages.\nThe advantage of the PoDLE proposal over this is that a malicious peer can\nonly blacklist the UTXO (not necessarily force you to spend it).\n\n# Summary\n\nThe preference of protocol depends on how you weigh the importance of a\nmalicious non-initiating peer griefing the initiator.\nTo protect fully, the extended version of Darosior's protocol does not\nallow griefing.\nThere is always a lot to be said for ruling out a class of attack even if\nit costs you a few rounds of communication.\n\nIs griefing a real concern though? Layer-2 is full of opportunities to\ngrief your counterparty and the ones presented here are hardly the worst.\nIf you're opening channels with someone who wants to grief you, you are\nalready in trouble.\nPoDLEs have very weak griefing in the form of unfairly adding your UTXO to\nthe blacklist but comes at the cost of complexity and a few difficult to\nanswer questions.\nI think the simplicity of signaling transactions may be worth the extra\ngriefing capabilities it offers a malicious peer given they are hardly as\nbad as the griefing capabilities they will have if you open a channel to\nthem!\n\nCheers,\n\nLL\n\n[1] https://github.com/niftynei/lightning-rfc/pull/1\n<https://github.com/lightningnetwork/lightning-rfc/pull/524>\n[2] https://github.com/discreetlogcontracts/dlcspecs/pull/114\n[3]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-February/002516.html\n[4]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002466.html\n[5]\nhttps://bitcoinops.org/en/newsletters/2020/02/05/#interactive-construction-of-ln-funding-transactions\n[6]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002475.html\n[7]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-February/002522.html\n[8] https://joinmarket.me/blog/blog/poodle/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210104/08adc787/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-01-05T08:38:19",
                "message_text_only": "Good morning LL, and happy new year as well,\n\n\n\n> # Signaling Transactions\n>\n> Finally I present a simple but unintuitive protocol that achieves roughly the same properties as the PoDLE protocol but without lightning gossip messages.\n>\n> Whenever the initiator adds an input in the interactive tx building they provide signatures on a \"signaling\" transaction spending that input (and any inputs they have added so far).\n> The signaling transactions will typically spend the funds back to the initiator's wallet.\n> Before revealing any of their inputs, the peer checks that none of the inputs added by the initiator are in their mempool/chain.\n> If the initiator aborts the protocol after learning one of the peer's inputs the peer broadcasts one of the signaling transactions.\n\nI would suggest rather that each added input should add a one-input one-output signaling transaction, instead.\n\nConsider the case of a malicious initiator who has two coins A and B.\n\n* Mallory sends A with a signalling transaction spending A.\n* Mallory sends B with a signalling transaction spending A and B.\n* Victor the victim initiatee node sends its coins.\n* Mallory spends A to itself, using a different transaction, with a feerate that is slightly higher than the feerate of the signaling transaction spending A and B.\n\nMallory only needs to spend A, and there is no way for Victor to impose a cost on the use of B --- the signaling transactions available to Victor spend A and cannot replace the non-signaling transaction that Mallory created.\n\nSo I think it is better if there is one signaling transaction per input provided by the initiator.\n\nAlternately, we can consider that Mallory will rationally want to reduce its exposure to cost, and would prefer to just provide a single input on each initiation.\nIf Mallory is in possession of multiple coins, it is in the best interest of Mallory to use each coin on a different Victor to spread out its risk *and* retain its own privacy, anyway, and not give two or more inputs to each Victor.\nThus, we only really need one signalling transaction, that for the first input provided by the initiator, and the single signalling transaction is sufficient to impose costs on Mallory.\n\n>\n> Like the PoDLE proposal this doesn't achieve (3) since a malicious peer could broadcast the signaling transaction making the honest initiator pay a transaction fee before using the input in another session.\n> To mitigate this a bit, the transactions could be RBF and have a 1 sat-per-byte feerate to give the initiator a decent amount of time to use their input productively before the tx confirms (and paying a low fee if it ever does confirm).\n>\n> The advantages of signaling transactions over PoDLE is that it doesn't involve any wonky crypto or new gossip messages.\n> The advantage of the PoDLE proposal over this is that a malicious peer can only blacklist the UTXO (not necessarily force you to spend it).\n>\n> # Summary\n>\n> The preference of protocol depends on how you weigh the importance of a malicious non-initiating peer griefing the initiator.\n> To protect fully, the extended version of Darosior's protocol does not allow griefing.\n> There is always a lot to be said for ruling out a class of attack even if it costs you a few rounds of communication.\n>\n> Is griefing a real concern though? Layer-2 is full of opportunities to grief your counterparty and the ones presented here are hardly the worst.\n> If you're opening channels with someone who wants to grief you, you are already in trouble.\n> PoDLEs have very weak griefing in the form of unfairly adding your UTXO to the blacklist but comes at the cost of complexity and a few difficult to answer questions.\n> I think the simplicity of signaling transactions may be worth the extra griefing capabilities it offers a malicious peer given they are hardly as bad as the griefing capabilities they will have if you open a channel to them!\n\nIndeed.\n\nWith the network already \"booted up\", so to speak, in general, a node will prefer to initiate channels with existing nodes that have:\n\n* High uptime.\n* Good connectivity and capacity.\n* Long-lived channels.\n\nA node which acts as a passive malicious peer in this protocol *could* have gotten another channel to justify its high uptime and locked funds, and potentially earn more funds in the future, rather than pissing off the incoming initiator by this form of griefing.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-01-08T01:37:02",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> This achieves all properties except for (4 - distinguishable on-chain)\n> which is why it was dismissed.\n\nIt also seems to require 2 txs per channel open?  (Interestingly I\nmissed that post previously, thanks for the pointer!)\n\n> I think it is possible to extend the idea to achieve (4) and therefore\n> obtain all desired properties.\n> Simply put peers can just use the SINGLE|ANYONECANPAY signature as back ups\n> in case of abort. Here's how it could work in my mind:\n>\n> 1. Initiator requests dual-funding and provides a TX_temp spending their\n> input set to a main output and a change output (does not sign it yet). They\n> also provide a sighash SIGNLE|ANYONECANPAY signature on the main output\n> spending into TX_backup-fund and a signature on the first commitment\n> transaction spending from TX_backup-fund (exactly as in [6]).\n> 2. Peer responds with commitment TX signature for TX_backup-fund.\n> 3. Initiator responds with the signatures for TX_temp.\n> *Peer now has a fully functional transaction chain with which to open the\n> channel -- now they can attempt to upgrade to a SIGHASH_ALL opening*.\n> 4. Peer (if possible) checks there are no existing transactions in the\n> chain or mempool spending from the taker's inputs. If not it responds with\n> its inputs, change and commitment tx signature for a SIGHASH_ALL TX_fund.\n> 5. Initiator responds with commitment TX signature and TX_fund input\n> signatures.\n> 6. Peer broadcasts TX_fund.\n> *If at any point after step 3 Initiator does not respond for ~2 seconds\n> they broadcast TX_temp and TX_backup-funding*\n\n2 seconds is not sufficient; as an Australian (or Tor user) you should\nknow this :)\n\nBut otherwise, it's kinda nice (bar breaking the interactive construction).\n\n> We have (4) because the SINGLE|ANYONECANPAY signature only appears on-chain\n> in case of abort (i.e. TX_backup-funding makes it on-chain).\n> It appears to be pretty close to the ideal solution in terms of privacy and\n> security.\n> If the malicious initiator learns an output they will always have to spend\n> one of their inputs otherwise they will quickly get hit by the TX_temp +\n> TX_backup-funding.\n> Note that it is possible the node is just slow in which case even if step\n> TX_backup-funding makes it in both parties should just carry on with the\n> channel.\n>\n> The downsides are that it involves six rounds of communication and cannot\n> use the \"interactive tx building\" protocol developed for the original\n> proposal\n>\n> # Signaling Transactions\n>\n> Finally I present a simple but unintuitive protocol that achieves roughly\n> the same properties as the PoDLE protocol but without lightning gossip\n> messages.\n>\n> Whenever the initiator adds an input in the interactive tx building they\n> provide signatures on a \"signaling\" transaction spending that input (and\n> any inputs they have added so far).\n> The signaling transactions will typically spend the funds back to the\n> initiator's wallet.\n> Before revealing any of their inputs, the peer checks that none of the\n> inputs added by the initiator are in their mempool/chain.\n> If the initiator aborts the protocol after learning one of the peer's\n> inputs the peer broadcasts one of the signaling transactions.\n>\n> Like the PoDLE proposal this doesn't achieve (3) since a malicious peer\n> could broadcast the signaling transaction making the honest initiator pay a\n> transaction fee before using the input in another session.\n> To mitigate this a bit, the transactions could be RBF and have a 1\n> sat-per-byte feerate to give the initiator a decent amount of time to use\n> their input productively before the tx confirms (and paying a low fee if it\n> ever does confirm).\n>\n> The advantages of signaling transactions over PoDLE is that it doesn't\n> involve any wonky crypto or new gossip messages.\n> The advantage of the PoDLE proposal over this is that a malicious peer can\n> only blacklist the UTXO (not necessarily force you to spend it).\n\nWe only need a single UTXO for this, which is even better.\n\nSo the initiator sends a \"good faith\" signed tx, which spends one of its\nUTXOs, to the accepter.  1sat-per-byte is probably a too low, but the\naccepter can provide a feerate for it[1].  Opener aborts if that\n\"good-faith\" feerate is too high.  It's implied that this is the first\nadded input, too.\n\nIf the accepter screws the opener by broadcasting it, the opener can\nstill open a channel with someone else before it's confirmed: they just\ncan't use *that* utxo if they want another node to DF.  Or simply take\nthe loss, since the feerate is presumably minimal, and use CPFP.\n\nCheers,\nRusty.\n\n[1] The latest c-lightning implementation of the spec[2] already has the\n    accepter indicating min, max and preferred feerates (and then the\n    opener selects within that range).  This would simply add another\n    feerate field, suggest implementing as ceiling(min / 2, 1).\n[2] Which Lisa promises she'll publish RSN, so we can add your derived\n    points proposal to it."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-01-09T04:50:05",
                "message_text_only": "Rusty, Zman,\n\nA concern I have with only doing one signaling transaction out of the whole\ngroup of inputs is that it means you don't prove ownership of the other\ninputs.\nI am not exactly sure what you could do by adding inputs from the chain you\ndon't own but it does feel a bit risky.\nPerhaps it would allow you to add whale output from the chain to trick the\npeer's algorithm for deciding how much they want to add to the funding.\nPerhaps regulators of the future might check whether the LN node is\nfollowing their directive to ban certain inputs on a blacklist -- If you\ncarry on after the  funding_add_input from a blacklisted input you must not\nbe running our gov approved node!\nIf that is not a concern, then I agree a single 1-input-1-output signaling\ntransaction should be fine, otherwise requiring 1-input-1-output signaling\ntx for each input the opener adds may be prudent (as Z suggested).\n\n> [2] Which Lisa promises she'll publish RSN, so we can add your derived\n    points proposal to it.\n\nLooking forward to seeing this :)\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210109/f94f442f/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-01-13T00:54:10",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> Rusty, Zman,\n>\n> A concern I have with only doing one signaling transaction out of the whole\n> group of inputs is that it means you don't prove ownership of the other\n> inputs.\n\nBut that's by design.  You can contact two peers and middleman between\nthem to produce a single tx.\n\nThe practical problem with a signalling tx is that it's hard to tell if\nit's conflicting.  Mallory uses a single UTXO to probe for everyone's\nUTXO at once.  Poor Bob wants to both wait 60 seconds to see if a\nconflicting tx ends up in his mempool, *and* broadcast it ASAP to signal\nto others.  He wants to do both of these *before* revealing his own\nUTXOs.\n\nNot sure how to square this, but I do prefer this approach over PoDLE.\n\nCheers,\nRusty."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-01-15T01:28:49",
                "message_text_only": "On Wed, Jan 13, 2021 at 11:54 AM Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n> Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> > Rusty, Zman,\n> >\n> > A concern I have with only doing one signaling transaction out of the\n> whole\n> > group of inputs is that it means you don't prove ownership of the other\n> > inputs.\n>\n> But that's by design.  You can contact two peers and middleman between\n> them to produce a single tx.\n>\n\nAh. I missed this motivation. So you actually want to have sessions where\nyou use the same signaling transaction in all of them. That's a cool idea.\n\n>\n> The practical problem with a signalling tx is that it's hard to tell if\n> it's conflicting.  Mallory uses a single UTXO to probe for everyone's\n> UTXO at once.  Poor Bob wants to both wait 60 seconds to see if a\n> conflicting tx ends up in his mempool, *and* broadcast it ASAP to signal\n> to others.  He wants to do both of these *before* revealing his own\n> UTXOs.\n>\n>\nI think this is a problem with all three schemes I mentioned. You will\nalways have to wait for things to be gossiped in some way to catch attempts\nat parallel sessions.\nOf course there could be faster mediums than the mempool but it does seem a\nconvenient one to use.\nNote that you should not wait a predictable amount of time but rather a\nrandomly sampled amount from e.g. 0-60 seconds (or longer). If everyone is\nwaiting the same predictable amount of time it does nothing to protect you.\n\nBut the \"middleman\" idea you mentioned above makes this all the more\ncomplicated: If you are meant to have parallel sessions then this is a\nproblem for an honest Alice who initiates a funding with Bob and Carol.\nBob decides to wait 24s and Carol decides to wait 55s to check the mempool\nfor the signaling before revealing their utxos. After Bob wakes up from his\n24s he will add his own utxos and demand that Alice complete the\ntransaction by signing it. But since Alice is trying to also add Carol's\nUTXOs to the transaction she will have to wait until Carol becomes\nresponsive again. To Bob this will look like Alice has become unresponsive\nthrough no fault of her own and Bob will broadcast the signaling tx.\n\nIn other words, if parallel sessions are legal then you shouldn't try and\ncatch parallel sessions. But if parallel sessions are legal there will\nalways be an effective dual funding UTXO discovery attack by using one UTXO\nto hit many targets. I think this is true for all three schemes I mentioned.\n\nIt seems the really difficult question is: is it even worth trying to stop\nsequential attacks if parallel attacks are unstoppable?\n\nNot sure how to square this, but I do prefer this approach over PoDLE.\n>\n\nI think PoDLE might actually have an advantage in parallel attacks if the\nscheme was changed a bit. A weakness of the lightning proposal as compared\nto the joinmarket idea is that the `h2` point is not broadcast immediately\n-- rather you wait for failure and then broadcast it.  Instead, a peer\nshould broadcast h2 as soon as they have agreed to create a transaction\nwith the initiator. Then if at any time during the tx creation protocol\nthey receive the same h2 from someone else, they cancel and don't reveal\ntheir UTXOs (let's say they wait ~10s after broadcasting before revealing\nany utxos). Note that here you don't have to randomly select the time you\nwait.\n\nThere are several (perhaps addressable) downsides to this scheme but it at\nleast has better protection against parallel attacks than the others.\nSince it is effective it would also break the \"middleman\" idea unless Alice\nfunds with two utxos (a different h2 for each party) or there is some way\nfor all parties involved in the funding to distinguish gossiped h2s from\ntheir funding session from others.\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210115/db7150a5/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-01-20T01:10:07",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> I think PoDLE might actually have an advantage in parallel attacks if the\n> scheme was changed a bit. A weakness of the lightning proposal as compared\n> to the joinmarket idea is that the `h2` point is not broadcast immediately\n> -- rather you wait for failure and then broadcast it.  Instead, a peer\n> should broadcast h2 as soon as they have agreed to create a transaction\n> with the initiator. Then if at any time during the tx creation protocol\n> they receive the same h2 from someone else, they cancel and don't reveal\n> their UTXOs (let's say they wait ~10s after broadcasting before revealing\n> any utxos). Note that here you don't have to randomly select the time you\n> wait.\n\nYes, sorry.  I assumed immediate broadcast + 60 second wait for\nconflicts.  It's this scheme I was trying to shoehorn into the mempool\n(broadcast signalling tx, wait, try to RBF it with a real open).  But\nthere are three problems with doing that:\n\n1. Everyone knows what you're doing, as they see the signalling tx (and\n   it needs to commit to a challenge, such as using OP_RETURN, so you\n   can't simply reuse the same tx).\n2. Bitcoind doesn't tell you if it encounters a conflicting tx from a\n   peer, so we'd probably need to gossip this via lightning instead.\n3. If tx fees are low, the signalling tx might get mined.\n\n> There are several (perhaps addressable) downsides to this scheme but it at\n> least has better protection against parallel attacks than the others.\n> Since it is effective it would also break the \"middleman\" idea unless Alice\n> funds with two utxos (a different h2 for each party) or there is some way\n> for all parties involved in the funding to distinguish gossiped h2s from\n> their funding session from others.\n\nYes, every initiator needs to provide an h2, and it has to be their own.\nBut you don't care (and can't know) that there's an h2 for another\ninput, too.  If Alice wants to initialte an open with Carol while Bob is\ninitiating an opening with her, she's got to provide her own UTXO &\nPoDLE.\n\nAnother point: the idea was that the accepting node would sign the\ngossip msg, and only known nodes (i.e. ones with a public channel) would\nbe allowed to do so.  This gives easy anti-spam: if Alice starts\nspamming a giant pile of h2s, we start randomly dropping them.  That\ndoesn't degrade the protection much: a single UTXO reuse might slip\nthrough, but a larger number would still be detected with P approaching\n1.\n\nCheers,\nRusty."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-01-28T06:42:29",
                "message_text_only": "On Wed, Jan 20, 2021 at 12:34 PM Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n>\n>\n> Yes, sorry.  I assumed immediate broadcast + 60 second wait for\n> conflicts.  It's this scheme I was trying to shoehorn into the mempool\n> (broadcast signalling tx, wait, try to RBF it with a real open).  But\n> there are three problems with doing that:\n>\n> 1. Everyone knows what you're doing, as they see the signalling tx (and\n>    it needs to commit to a challenge, such as using OP_RETURN, so you\n>    can't simply reuse the same tx).\n> 2. Bitcoind doesn't tell you if it encounters a conflicting tx from a\n>    peer, so we'd probably need to gossip this via lightning instead.\n> 3. If tx fees are low, the signalling tx might get mined.\n>\n\nI think immediate broadcast of signaling TX is a bad idea even if it's done\nover lightning since it leaks that the UTXO associated with the signaling\nTX is creating a channel (even if the channel was meant to be private).\nYou could argue that the signaling TX need not be associated with a UTXO\nbut I find this awkward.\nLazily broadcast, signaling txs are a good way to protect against\nsequential attacks but are weak against parallel attacks. Unfortunately I\nthink protection of the former means very little without the latter.\n\n\n>\n> > There are several (perhaps addressable) downsides to this scheme but it\n> at\n> > least has better protection against parallel attacks than the others.\n> > Since it is effective it would also break the \"middleman\" idea unless\n> Alice\n> > funds with two utxos (a different h2 for each party) or there is some way\n> > for all parties involved in the funding to distinguish gossiped h2s from\n> > their funding session from others.\n>\n> Yes, every initiator needs to provide an h2, and it has to be their own.\n> But you don't care (and can't know) that there's an h2 for another\n> input, too.  If Alice wants to initialte an open with Carol while Bob is\n> initiating an opening with her, she's got to provide her own UTXO &\n> PoDLE.\n>\n> Another point: the idea was that the accepting node would sign the\n> gossip msg, and only known nodes (i.e. ones with a public channel) would\n> be allowed to do so.  This gives easy anti-spam: if Alice starts\n> spamming a giant pile of h2s, we start randomly dropping them.  That\n> doesn't degrade the protection much: a single UTXO reuse might slip\n> through, but a larger number would still be detected with P approaching\n> 1.\n>\n>\nOk since it appears eagerly broadcasted PoDLEs are the only proposal that\ncan protect against parallel attacks let's try and put the best version of\nit forward.\nHere's my shot.\n\nLet H0 and H1 be 32-byte output hash functions.\n\n1. In any of the `tx_add_input` messages the initiator may attach a PoDLE\nwhich contains the public key for an input as well as a P2 (the public key\nprojected onto a different generator).\n2. Upon receiving the PoDLE, the peer checks its validity and creates a\n\"claim\" message claiming the UTXO which contains.\n    i) H0(P2)\n    ii) A MAC (e.g. Poly1305) produced with the H1(P2) as the key and\nclaimer_node_id as the message -- required so conflicting claim messages\ncan only be produced by someone who actually knows P2.\n    iii) The claimer_node_id and a BIP340 signature under it over the rest\nof the message data -- required to stop spam: only accept and re-broadcast\nthese messages from nodes who have real channels.\n   The peer broadcasts this claim message if they haven't before received a\nvalid claim message with H0(P2) and a valid MAC.\n3. Any node receiving the claim message checks whether it has seen it\nalready (same H0(P2) and MAC). If not, checks the signature against\nclaimer_node_id and checks whether that node is valid (or perhaps\nblacklisted because it has spammed too many claim messages recently),\nstores (H0(P2), MAC, claimer_node_id) it and re-broadcasts the message to\nits peers.\n4. The claiming node waits ~60 seconds to see if it receives a conflicting\nclaim message where the H0(P2) is the same and the MAC is different and\nvalid. If they don't receive that then they carry on to add their own utxos.\n\nI believe this does guarantee what we wanted: an attacker will only be able\nto do the attack once per UTXO. This is better than I expected to find at\nthe beginning of entering into this subject!\nThis certainly seems to be the strongest in the class of solutions.\n\nNow I'd like to make the strongest possible argument against it in favor of\njust doing nothing (for now) at the protocol level about this problem.\n\nConsider the following propositions:\n1. The public nodes that will offer dual funding and are susceptible to\nthis attack will be the kind that have a lot of churn i.e. they dual fund a\nchannel, when that closes they use the remaining funds to fund another\nchannel.\n2. Chainalysis already works very well at identifying the UTXOs these kinds\nof nodes. If the change output of a funding or the closing output are\nreused in another public channel it is easy to identify which node was\nfunding what with the techniques in [1,2].\n3. It is therefore rather redundant to do this type of active UTXO probing\nsince all you need to do is wait and be patient. Churning public nodes will\neventually use their UTXO to do a dual or single funding. Then by\ncross-layer de-anonymization techniques you will be able to determine that\nthey owned that UTXO without ever interacting with the node.\n4. These techniques can even be applied to private channels at least while\nthey are identifiable on the blockchain (in [2] using chainalysis they can\nidentify one node involved in a private channel 79% of the time).\n5. There is of course some extra advantage in doing this attack but looking\nat the effectiveness of techniques in [1,2] and my intuition about how\nchurning nodes are most susceptible to these techniques I *guess* it\nwouldn't be much. If this is the case then chainalysis companies may not be\nable to justify  doing active attacks when passive attacks work almost as\nwell.\n6. It may be more effective to deal with UTXO probing outside of the\nprotocol. For example, a group of dual-funders could maintain a shared UTXO\nblacklist and use chainalysis on it to not only ban single UTXOs but entire\nclusters of outputs. i.e. do chainalysis on the chainalyzers! There are\nsome efforts to create open tools to do Chainalysis [3] that could be\nleveraged against this attack. This might be much more effective than\nPoDLEs as just spending the output somewhere else would not be enough to\nuse it again in the attack.\n7. The above PoDLE proposal actually creates a new extra bit of data that\ncan be used for chainalysis -- when you broadcast the claim message you are\nsaying you're going to make a dual funded channel sometime soon. So\nChainalysis can look in the next block for something that looks like a dual\nfunding and know you participated. This could be quite valuable for them\nand I would hesitate to give it to them in the anticipation of them doing\nan attack they may never actually do.\n8. If all of the above points are not enough to prevent this attack from\nbeing widespread and the above PoDLE proposal is still the best idea I\nguess it wouldn't be too hard to shoehorn it into the protocol later.\n\nAt the moment my bias is towards doing nothing and keeping things simple.\nIt seems chainalysis techniques are effective at associating funding UTXOs\nto nodes for the most common usage patterns. Taproot will change the game\nfor private channels but won't do much for public channels.\nHaving said that -- it was a thing in JoinMarket so I might be wrong. I can\noffer some conjecture as to why JoinMarket had this issue: if you can find\nall the maker UTXOs before and after a join then you have removed a lot of\nthe anonymity set. Since CoinJoin is a UTXO privacy technology this makes\nsense.\n\n[1] https://arxiv.org/abs/2007.00764\n[2] https://arxiv.org/pdf/2003.12470.pdf\n[3] https://graphsense.info/\n\nI am told there is a new revision of [1] coming out any day now that will\npresent a few more tricks and have contributions directly from a scientist\nat Chainalsysis (the company).\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210128/1f7d828d/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-01-28T23:50:24",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> I think immediate broadcast of signaling TX is a bad idea even if it's done\n> over lightning since it leaks that the UTXO associated with the signaling\n> TX is creating a channel (even if the channel was meant to be private).\n> You could argue that the signaling TX need not be associated with a UTXO\n> but I find this awkward.\n> Lazily broadcast, signaling txs are a good way to protect against\n> sequential attacks but are weak against parallel attacks. Unfortunately I\n> think protection of the former means very little without the latter.\n\nAgreed.  Let's PoDLE!\n\n> Let H0 and H1 be 32-byte output hash functions.\n>\n> 1. In any of the `tx_add_input` messages the initiator may attach a PoDLE\n> which contains the public key for an input as well as a P2 (the public key\n> projected onto a different generator).\n> 2. Upon receiving the PoDLE, the peer checks its validity and creates a\n> \"claim\" message claiming the UTXO which contains.\n>     i) H0(P2)\n>     ii) A MAC (e.g. Poly1305) produced with the H1(P2) as the key and\n> claimer_node_id as the message -- required so conflicting claim messages\n> can only be produced by someone who actually knows P2.\n>     iii) The claimer_node_id and a BIP340 signature under it over the rest\n> of the message data -- required to stop spam: only accept and re-broadcast\n> these messages from nodes who have real channels.\n\nNote: we can avoid leaking claimer_node_id (Hey, look at me, someone's\nopening a channel with me now!).  The purpose of claimer_node_id is to\nrestrict spam (you need to have broadcasted a valid open channel to be\nrecognized by the network as a valid node_id), but we can make this\ndirect: require a utxo + the script needed to spend it, and any key in\nthat script will serve in place of claimer_node_id (for v1\nsegwit, the output itself may serve as key).\n\nSince we're headed to an anchor (or Eltoo) world where nodes have to\nkeep a few UTXOs around for emergencies anyway, this may have better\nprivacy.  At worst, they use a key from an existing, public channel\nUTXO, which is no worse than using their node_id.\n\n> Now I'd like to make the strongest possible argument against it in favor of\n> just doing nothing (for now) at the protocol level about this problem.\n>\n> Consider the following propositions:\n> 1. The public nodes that will offer dual funding and are susceptible to\n> this attack will be the kind that have a lot of churn i.e. they dual fund a\n> channel, when that closes they use the remaining funds to fund another\n> channel.\n> 2. Chainalysis already works very well at identifying the UTXOs these kinds\n> of nodes. If the change output of a funding or the closing output are\n> reused in another public channel it is easy to identify which node was\n> funding what with the techniques in [1,2].\n\nLess true after taproot though?\n\n> 3. It is therefore rather redundant to do this type of active UTXO probing\n> since all you need to do is wait and be patient. Churning public nodes will\n> eventually use their UTXO to do a dual or single funding. Then by\n> cross-layer de-anonymization techniques you will be able to determine that\n> they owned that UTXO without ever interacting with the node.\n> 4. These techniques can even be applied to private channels at least while\n> they are identifiable on the blockchain (in [2] using chainalysis they can\n> identify one node involved in a private channel 79% of the time).\n> 5. There is of course some extra advantage in doing this attack but looking\n> at the effectiveness of techniques in [1,2] and my intuition about how\n> churning nodes are most susceptible to these techniques I *guess* it\n> wouldn't be much. If this is the case then chainalysis companies may not be\n> able to justify  doing active attacks when passive attacks work almost as\n> well.\n> 6. It may be more effective to deal with UTXO probing outside of the\n> protocol. For example, a group of dual-funders could maintain a shared UTXO\n> blacklist and use chainalysis on it to not only ban single UTXOs but entire\n> clusters of outputs. i.e. do chainalysis on the chainalyzers! There are\n> some efforts to create open tools to do Chainalysis [3] that could be\n> leveraged against this attack. This might be much more effective than\n> PoDLEs as just spending the output somewhere else would not be enough to\n> use it again in the attack.\n> 7. The above PoDLE proposal actually creates a new extra bit of data that\n> can be used for chainalysis -- when you broadcast the claim message you are\n> saying you're going to make a dual funded channel sometime soon. So\n> Chainalysis can look in the next block for something that looks like a dual\n> funding and know you participated. This could be quite valuable for them\n> and I would hesitate to give it to them in the anticipation of them doing\n> an attack they may never actually do.\n> 8. If all of the above points are not enough to prevent this attack from\n> being widespread and the above PoDLE proposal is still the best idea I\n> guess it wouldn't be too hard to shoehorn it into the protocol later.\n>\n> At the moment my bias is towards doing nothing and keeping things simple.\n> It seems chainalysis techniques are effective at associating funding UTXOs\n> to nodes for the most common usage patterns. Taproot will change the game\n> for private channels but won't do much for public channels.\n> Having said that -- it was a thing in JoinMarket so I might be wrong. I can\n> offer some conjecture as to why JoinMarket had this issue: if you can find\n> all the maker UTXOs before and after a join then you have removed a lot of\n> the anonymity set. Since CoinJoin is a UTXO privacy technology this makes\n> sense.\n\nI also agree; it's fairly easy to add later with a feature bit, and I\nthink we now have a roadmap on how it should be done.  Let's not boil\nthe ocean.\n\n> [1] https://arxiv.org/abs/2007.00764\n> [2] https://arxiv.org/pdf/2003.12470.pdf\n> [3] https://graphsense.info/\n>\n> I am told there is a new revision of [1] coming out any day now that will\n> present a few more tricks and have contributions directly from a scientist\n> at Chainalsysis (the company).\n\nI'll add to my reading list (or wait for one of my colleagues to provide\nthe TL;DR!).\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "PoDLEs revisited",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 43858
        }
    },
    {
        "title": "[Lightning-dev] Battlement: A Quorum Based Design for Lightning Network Key Management",
        "thread_messages": [
            {
                "author": "Devrandom",
                "date": "2021-01-10T23:48:31",
                "message_text_only": "Hi Omer,\n\nThank you for raising the topic of quorum key management for Lightning.  I\nbelieve this approach is an important direction for securing Lightning\nnodes.  Please see comments below.\n\nOn Tue, Dec 15, 2020 at 11:26 PM Omer Shlomovits <omer.shlomovits at gmail.com>\nwrote:\n\n> The attacker model is intuitive: an attacker attacks a machine which\n> happens to run a lightning node. The attacker is *not* part of the\n> network.\n>\n\nWell, that's an assumption. :)  In general, an attacker may also control\none or more peers, either because they compromised them or because they\ninitiated a connection to the target node.\n\n\n> Usually the attacked machine/device will have security measures in place:\n> write/read permissions for different users. Our assumption is that the\n> attacker does not necessarily\n>\nachieve full control over the node but only *some* elevated access: it may\n> have only read or only  write access for example which means it can steal\n> some keys while not\n>\n\nAlso a significant assumption, since in many cases an attacker can\ncompletely compromise a system.  It would be a much stronger security\nposture if we defended against this too.  What is the motivation for these\nassumptions?  Did you feel it's too difficult to defend against arbitrary\ncompromise?\n\nI also want to mention that there are many ways funds can be lost in\nLightning once we assume that the node software can be fully compromised.\nI believe we can defend against all these, but it requires implementation\nof a relatively large set of controls in the key management layer.  In the\nLightning Signer project we attempt to enumerate these controls - see:\nhttps://gitlab.com/lightning-signer/docs/-/blob/master/policy-controls.md\n\nFor example - one of the more complex policy controls is \"HTLC receive\nchannel validity - the funding UTXO of the receive channel must be active\non-chain with enough depth\".  i.e. we have to check that routed HTLCs are\ncoming from a valid channel or we could have all funds siphoned off over\ntime.\n\nLooking forward to further work on this.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210110/4dad4d0e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Battlement: A Quorum Based Design for Lightning Network Key Management",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Devrandom"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2244
        }
    },
    {
        "title": "[Lightning-dev] Lightning dice",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2021-01-25T11:34:30",
                "message_text_only": "Hey all,\n\nHere's a rough design for doing something like satoshi dice (ie, gambling\non \"guess the number I'm thinking of\" but provably fair after the fact\n[0]) on lighting, at least once PTLCs exist.\n\n[0] https://bitcoin.stackexchange.com/questions/4609/how-can-a-wager-with-satoshidice-be-proven-to-be-fair\n\nThe security model is that if the casino cheats, you can prove they\ncheated, but turning that proof into a way of getting your just rewards\nis out of scope. (You could use the proof to discourage other people\nfrom losing their money at the casino, or perhaps use it as evidence to\nget a court or the police to act in your favour)\n\nThat we don't try to cryptographically guarantee the payout means we\ncan send both bets over lightning, but don't need to reserve the funds\nfor the bet payout for the lifetime of the bet. The idea is that's much\nfriendlier to the lightning network (you're not holding up funds of the\nintermediary routing nodes) and it requires less capital to run the casino\nthan other approaches.\n\nSo the first thing to do is to set up a wager, between Bob the better\nand Carol the casino, say. Carol offers a standard bet to anyone, say\n1.8% chance of winning and a 50x payout, with up to 200 satoshi stake\n(so 10k satoshi max payout).\n\nWe assume the bet is implemented as Bob and Carol both picking random\nnumbers (b and c, respectively), and who wins being decided based on\nthe relationship between those numbers.\n\nWe start off with two messages:\n\n  m1: \"C owes B ${amount}, provided values b and c are given where\n       0 <= (b+c)%500 < 9 and b*G = ${Pb} and c*G = ${Pc}\"\n\n  m2: \"C has paid B ${amount} for the ${b} ${c} bet\"\n\nThe first message, if signed by C, and accompanied by consisent values\nfor b and c, serves as proof that Bob took the bet and won. The second\nmessage, if signed by B, serves as proof that Carol didn't cheat Bob.\n\nSo the idea then is that Bob should get a signature for the first message\nas soon as he pays the lightning invoice for the bet, and Carol should\nget a signature for the latter, as soon as she's gotten the payout\nafter winning.\n\nPTLCs make this possible, because when verifying a Schnorr signature,\nyou want:\n\n  s*G = R + H(R,P,m)*P\n\nbut if you provide (R,P,m) initially, then you can calculate the right\nhand side of the equation as the point, and then use a PTLC on that\npoint to pay for its preimage \"s\", at which point you have both s,R\nwhich is the signature you were hoping for.\n\nBut you want to be even cleverer than this -- because as soon as Bob pays\nCarol, Bob needs to not only have the signature but also have Carol's\n\"c\". He can't have \"c\" before he pays, because that would allow him to\ncheat (he could choose to bet only when the value of c guarantees he\nwins). We can do that by making it an adaptor signature conditional on\nc. That is, provide R,(s-c) as the adaptor signature instead of R,s.\nBob can verify \"s-c\" is correct, by verifying:\n\n  (s-c)*G = R + H(R,P,m)*P - C\n\nSo the protocol becomes:\n\n1 -- Setup)\n  Bob has a pubkey B; picks random number b, calculates Pb = b*G.\n  Sends bet, B, Pb to Carol.\n\n  Carol decides she wants to accept the bet.\n  Carol picks c, calculates Pc = c*G.\n  Carol calculates m1(amount=50*bet, C, B, Pb, Pc), and generates a\n   signature R1,s1 for it.\n  Carol sends Pc,R1,(s1-c) to Bob, and a PTLC invoice for (bet,Pc)\n\n  Bob checks the adaptor signature -- (s1-c)*G = R1 + H(C,R1,m1)*C - Pc\n\n2 -- Bet)\n  Bob pays the invoice, receiving \"c\".\n  Bob checks if (b+c)%500 < 9, and if it isn't stops, having lost the\n    bet.\n  Bob calculates m2(amount=50*bet, b, c) and produces a signature for\n    it, namely R2,s2.\n  Bob calculates S2=s2*G.\n  Bob sends b, R2 to Carol, and a PTLC invoice for (50*bet, S2)\n\n3 -- Payout)\n  Carol checks b,c complies with the bet parameters.\n  Carol checks the signature -- S2 = R2 + H(R2,B,m2)*B\n  Carol pays the invoice, receiving s2\n \nI think it's pretty straightforward to see how this meets the goals:\nas soon as Bob puts up the bet money, he can prove to anyone whether or\nnot he won the bet; and as soon as Carol pays, she has proof that she\npaid.\n\nNote that Bob could abort the protocol with a winning bet before\nrequesting the payout from Carol -- he already has enough info to prove\nhe's won and claim Carol isn't paying him out at this point. \n\nOne way of dealing with this is to vet Bob's claim by sending b,R2 and a\nPTLC invoice of (50*bet,S2) to Carol with yourself as the recipient -- you\ncan construct all that info from Bob's claim that Carol is cheating. If\nCarol isn't cheating, she won't be able to tell you're not Bob and\nwill try paying the PTLC; at which point you know Carol's not cheating.\nThis protocol does't work without better spam defenses in lightning --\nPTLC payments have to be serialised or Carol risks sending the payout\nto Bob multiple times, and if many people want to verify Carol is(n't)\ncheating, they can be delayed by just one verifier forcing Carol to wait\nfor the PTLC timeout to be reached.\n\nAnother way of dealing with it, at least for large payouts, is to just\nput the payout on the blockchain in a way that's claimable by Bob with\nthe same signature, for some reasonable period of time.\n\nIt might be useful to add a third payment: when Bob *loses* the bet,\nit may make sene for Carol to pay back a small fraction of the original\nbet for Bob to reveal their losing guess \"b\" -- that allows Carol to\nstop storing old values of c/Hb/B that won't be claimed later, and it\nlets Bob gain confidence that he can receive funds even when he loses a\nbet, rather than discovering that there's mysterious network issue\nblocking payments only when he's won big.\n\nI think this should scale pretty well: small bets are coming in over\nlightning, and the payouts are going out over lightning, so this should\nlead to fairly balanced channels (depending on how low the profits are).\nAnd there's no particular carrying cost, so I think this could work with\nbets that aren't resolved instantly, though I'm also pretty sure there's\nsome potential traps there too.\n\nIt should also generalise pretty well -- the rules are all in message\n\"m1\", but that doesn't ever go on the blockchain, so you could invent\nan arbitrarily complicated language for m1 -- eg, you could construct \na lotto-like system where you guess multiple numbers and the more you\nget correct, the higher the payout.\n\nBut more interestingly, I think you could also add in oracles in\na straightforward manner, and thus do sports gambling or prediction\nmarkets on top of it, and maybe some sorts of derivatives more generally?\n\nI think it's got some drawbacks that prevent it from being a 100% DeFi\nkiller -- you can't atomically combine bets against different casinos\nand guarantee a riskless win in the same way you can do arbitrage with\nblockchain-based DeFi (modulo MEV concerns).\n\nI believe it should be possible to do PTLCs over lightning in practice\nalready via:\n\n  https://suredbits.com/ptlc-proof-of-concept/\n\nand, of course, if anyone's running lightning on signet, you should\nbe able to implement schnorr/taproot-based PTLCs there as well, since\ntaproot is already enabled on signet.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Lightning dice",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7142
        }
    },
    {
        "title": "[Lightning-dev] An Argument For Single-Asset Lightning Network",
        "thread_messages": [
            {
                "author": "kostadin rangelov",
                "date": "2021-01-29T03:28:05",
                "message_text_only": "1\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210129/8c6d9869/attachment.html>"
            },
            {
                "author": "kostadin rangelov",
                "date": "2021-01-29T03:39:25",
                "message_text_only": "-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210129/eb1c3997/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "An Argument For Single-Asset Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "kostadin rangelov"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 370
        }
    }
]