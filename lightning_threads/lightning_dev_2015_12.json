[
    {
        "title": "[Lightning-dev] Better privacy with SNARKs",
        "thread_messages": [
            {
                "author": "Andrew Miller",
                "date": "2015-12-02T12:40:43",
                "message_text_only": "So, it turns out that a SNARK is overkill for the application in this\nthread. It was just a one-off experiment. But the performance estimates\nseemed pretty far off compared to what\u2019s reported in in the snark science\npapers. So, Sean (a Zcash engineer, in his \u201c20% fun time\u201d) replicated the\nexperiment from the original post, in libsnark (not snarklib).\n\nFirst, as a recap, this is the specification of the original post\u2019s SNARK,\nsummarized in Camenisch-Stadler notation:\nZkPoK{ (R1, R2): H1 = sha256(R1) and H2 = sha256(R2) and R1 = R2 xor X }\n\nIn other words: given a statement H1, H2, and X, you can prove that you\nknow a secret witness R1, and R2, such that the predicate holds (i.e., R1\nand R2 are preimages of H1,H2 and are related by X)\n\nThis is almost a complete specification of the SNARK: all that\u2019s left is to\nchoose a representation size for R1 and R2\u2026. here these are forced to be\n32-byte strings.\n\nHere are the results for a libsnark implementation of this, ordered up to\nthe above spec:\nhttps://github.com/ebfull/lightning_circuit/\n\nMost relevant benchmarks:\nkey generation time: 11.6270s\nproof generation time: 3.0968s\nverification time: 0.0270s\nproof size: ~287 bytes\nproving key size: ~12.85 megabytes\nverifying key size: ~573 bytes\nR1CS constraints: 56612 (mostly sha256-related)\n\nThe difference in proof time and proving key size (this is ~3x faster to\nprove, with ~10x less key size) might be explained by libsnark having a\nmore efficient SHA256 implementation. The libsnark one is hand-optimized.\nBut I don\u2019t have any idea why the OP and snarklib reported such large\nverification keys or memory consumption during verification. The verifier\nshould only have to think of about a kilobyte.\n\nOn Tue, Nov 17, 2015 at 4:14 PM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> Hi all,\n>\n> An obvious privacy limitation with lightning is that even with onion\n> routing, differents hops can be associated as being part of the same\n> transaction due to sharing a common R value. So if you see a HTLC from\n> Alice to Bob, paying $5 to Bob on receipt of R where SHA(R)=12345..;\n> and you see another HTLC from Carol to Dave, paying $4.95 to Bob on\n> receipt of R under the same condition, SHA(R)=12345..., then you know\n> it's part of the same transaction.\n>\n> If you could change R at each step in the route, this would go away,\n> improving payment anonymity and making it harder to attack the system in\n> general.\n>\n> That's hard, because as a forwarding node, if you receive a HTLC payable\n> on R1, then to send a HTLC payable on R2, you need to be able to\n> calculate R1 from R2 or you'll be out of pocket. But you also can't be\n> able to calculate R1 *without* R2, or you could just rip off whoever's\n> making the payment. And, of course you have to know SHA(R2) to forward the\n> payment at all. And if you only know SHA(R1) and SHA(R2) it's hard to\n> say anything at all about R1 and R2 because cryptographic hash functions\n> are designed to make any structural relationships go away.\n>\n> BUT! I think the magic of SNARKs [0] lets you do this!\n>\n> With a SNARK, you can \"prove\" that you have some secrets (ie, R1 and R2)\n> that satisfy some programmable condition (ie, SHA(R1)=H1 and SHA(R2)=H2\n> and R1=R2 XOR X), based on public inputs (H1, H2 and X), without revealing\n> those secrets.\n>\n> I think that's pretty safe, because if you receive an HTLC asking for a\n> preimage for H1, along with instructions in the onion saying ask Bob for\n> a preimage for H2, and here's X and a proof, then either:\n>\n>  - your forwarded HTLC will fail, and everything's fine\n>\n>  - you'll receive R2, calculate R1=R2 XOR X and see SHA(R1)=H1 as\n>    expected, and everything's fine\n>\n>  - you'll receive R2, calculate R1=R2 XOR X and see SHA(R1) != H1,\n>    which is only possible if the cryptography behind SNARKs are broken\n>\n>  - you'll receive RX, such that H2=SHA(RX) but RX being too\n>    long or too short. If SNARKs aren't broken, this means that you know\n>    R2alt and someone else knows R2 that are different but hash to the\n>    same value, meaning SHA has been broken.\n>\n> It seems like there are research-level tools out there that actually\n> make this practical to try out. I've had a go at implementing this using\n> snarkfront [1]. Using it looks like:\n>\n> 1) initial setup of proof/verification keys\n>\n>  $ ./test_lightning -m keygen > keygen.txt  # global setup\n>\n> 2) generate a proof, using a 32 byte secret, and XOR key (64 hex digits)\n>\n>  $ SECRET=\"the quick brown fox jumps lazily\"\n>  $ XOR=$(echo \"she sells sea shells\" | sha256sum | head -c64)\n>  $ cat keygen.txt |\n>      ./test_lightning -m proof -s \"$SECRET\" -x \"$XOR\" > proof.txt\n>    m: proof.\n>    f: .\n>    b: .\n>    x: 5677d356ccd6ff29b296a697791d109a1703557ecbbcf52b4f38d4b680858912.\n>    F: 74686520717569636b2062726f776e20666f78206a756d7073206c617a696c79\n>    B: 221fb676bda3964ad9b6c4e5166a7eba716c2d5ea1c9985b3c18b8d7faece56b\n>    #F: ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85\n>    #B: 166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245\n>    generate proof\n>    (6) ..................................................\n>    (5) ..................................................\n>    (4) ..................................................\n>    (3) ..................................................\n>    (2) ..................................................\n>    (1) ..................................................\n>\n> 3) Verify the proof:\n>\n>  $ F=ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85\n>  $ B=166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245\n>  $ cat keygen.txt proof.txt |\n>      ./test_lightning -m verify -h \"$F\" -b \"$B\" -x \"$XOR\"\n>    m: verify.\n>    f: ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85.\n>    b: 166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245.\n>    x: 5677d356ccd6ff29b296a697791d109a1703557ecbbcf52b4f38d4b680858912.\n>    verify proof (6) (5) (4) (3) (2) (1)\n>    proof is verified\n>\n> 4) Verify it doesn't report a valid proof with different inputs:\n>\n>   $ cat keygen.txt proof.txt |\n>      ./test_lightning -m verify -h \"$B\" -b \"$F\" -x \"$XOR\"\n>    m: verify.\n>    f: 166e4f9b8ec5895e870f0f0508327d73ba9ad9af4e9841599bafb1bf55c8a245.\n>    b: ae4d48f71fdb6f74149fab591e88f2cc07d4e696968def1aa7ca1e07096c5b85.\n>    x: 5677d356ccd6ff29b296a697791d109a1703557ecbbcf52b4f38d4b680858912.\n>    verify proof (6) (5) (4) (3) (2)\n>    proof is rejected\n>\n> Some results:\n>\n>  * the proof/verification key data take up about 100MB -- in theory\n>    one set of this data can be used by everyone; the only catch is\n>    that everyone has to trust that nobody has kept the original random\n>    numbers used to generate it.\n>\n>  * proof/verification key data takes about a minute to generate,\n>    and about 650MB of RAM.\n>\n>  * the proof data itself (which would need to be sent to the node that's\n>    going to switch R's) is just 864 bytes; so it'd use up about 5 hops\n>    worth of onion routing at 192B per hop -- in a 4096 byte packet eg,\n>    you could have four hops, changing R each time; or you could have 9\n>    hops, changing R only three times.\n>\n>  * generating the proof data for a given R1,X pair takes about 10\n>    seconds, and 260MB of RAM\n>\n>  * verifying the proof is quick-ish -- it takes 0.5s on my laptop,\n>    and uses about 150MB of RAM.\n>\n> For comparison, that last point makes a SNARK verification 500+ times\n> more expensive than an ECDH operation. If I got my maths right, you\n> can translate 3c for a linode CPU-hour into 2.5 satoshi for a linode\n> CPU-second (at $338/BTC), so you're probably looking at a minimum fee\n> of a few satoshi per SNARK verification, but that's still pretty okay\n> for transactions of 500 satoshi or more, ie anything more than about a\n> fifth of a US cent.\n>\n> The 10s proof generation time is probably more of a limitation -- though\n> you could generate them in advance easily enough and just store them until\n> you need to use them, which would avoid lag being a problem at least. But\n> even then it's still essentially adding up to 30c of additional costs to\n> your transaction (ie 10s cpu time valued at up to 3c/s), which probably\n> isn't worthwhile for transactions smaller than a dollar or two.\n>\n> A drawback is that you'd either (a) have to do all this on the merchant's\n> side (not just sending SHA(R) to whoever wants to pay you, but sending\n> SHA(R1), SHA(R2), SHA(R3), SHA(R4), X12, X23, X34, and three proofs,\n> which would be pretty painful; or (b) you'd have to generate all the\n> R secrets as a consumer, and you wouldn't get to use the fact that you\n> know R as evidence that you paid the merchant.\n>\n> Anyway, it's obviously not ready for prime time today: SNARKs are still\n> pretty new as a concept; I'm definitely not familiar enough with SNARK\n> theory to be sure I'm not misusing the concept somehow; snarkfront may not\n> have implemented the theory fully correctly; and I might not have captured\n> everything I needed to in order for my \"proof\" to actually say what I\n> want it to. So not a great idea to use this to protect real money today.\n>\n> But still, this seems like it's not all /that/ far from being practical,\n> and if the crypto's not fundamentally broken, seems like it goes a long\n> way to filling in the biggest privacy hole in lightning today [3]...\n>\n> Code is at https://github.com/ajtowns/snarkfront/ or more directly at:\n> https://github.com/ajtowns/snarkfront/blob/lightning-sha/test_lightning.cpp\n>\n> Cheers,\n> aj\n>\n> [0] https://tahoe-lafs.org/trac/tahoe-lafs/wiki/SNARKs\n>\n> [1] https://github.com/jancarlsson/snarkfront\n>\n> [2] This would also improve privacy/anonymity for other applications of\n>     HTLCs, such as atomic swaps across chains:\n>\n>      1 bitcoin, payable on R1 + Alice's sig or timeout + Bob's sig\n>      100 litecoin, payable on R2 + Robert's sig or timeout + Ally's sig\n>\n>     Alice and Bob communicate privately, agreeing to trade 1 BTC for 100\n>     litecoin and revealing their aliases Robert and Ally; Alice generates\n>     R1, R2, and reveals SHA(R1), SHA(R2), R1^R2 and the SNARK proof and\n>     publishes the litecoin payment. Bob verifies the proof, and publishes\n>     the bitcoin payment. Alice claims the bitcoin payment, revealing R1;\n>     Bob calculates R2 and claims the litecoin payment. The swap can take\n>     place trustlessly because Bob knows the only way Alice can claim his\n>     bitcoin is by revealing enough info so he can claim the corresponding\n>     litecoin. But there isn't any on-chain information linking the two\n>     transactions, because R1 and R2 are independent (and could even be\n>     using different hash functions as well as different preimages).\n>     After the funds have been claimed, the private communication is\n>     also completely deniable, since anyone could generate R1^R2 and a\n>     corresponding SNARK proof just using the info on the blockchain.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151202/97972a83/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-12-08T02:10:46",
                "message_text_only": "On Sun, Dec 06, 2015 at 05:24:54PM +0100, Martijn Meijering wrote:\n> \"So, it turns out that a SNARK is overkill for the application in this\n> thread.\"\n> Could you elaborate on this? Are the required messages too large, does\n> verification take too long, something else?\n\nNot so much that; matsjj found a way to get the same result using\nthe crypto we're already relying on (ie, just using ECC multiply and\naddition).\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Better privacy with SNARKs",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Andrew Miller"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 11752
        }
    },
    {
        "title": "[Lightning-dev]  Better privacy with SNARKs",
        "thread_messages": [
            {
                "author": "Martijn Meijering",
                "date": "2015-12-06T16:24:54",
                "message_text_only": "(Repost after subscribing)\n\nAndrew Miller wrote:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2015-December/000365.html\n\n\"So, it turns out that a SNARK is overkill for the application in this\nthread.\"\n\nCould you elaborate on this? Are the required messages too large, does\nverification take too long, something else? This may be a an ignorant\nquestion, but if it's one of the former two, wouldn't an interactive ZK\nproof using Yao garbled circuits be enough to get us what we want?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151206/6e4bc3b4/attachment.html>"
            },
            {
                "author": "Martijn Meijering",
                "date": "2015-12-07T18:28:22",
                "message_text_only": "(repost after setting the correct email address)\n\nAndrew Miller wrote:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2015-December/000365.html\n\n\"So, it turns out that a SNARK is overkill for the application in this\nthread.\"\n\nCould you elaborate on this? Are the required messages too large, does\nverification take too long, something else? This may be an ignorant\nquestion, but if it's one of the former two, wouldn't an interactive ZK\nproof using Yao garbled circuits be enough to get us what we want?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151207/ac95e985/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Better privacy with SNARKs",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Martijn Meijering"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1378
        }
    },
    {
        "title": "[Lightning-dev] Onion-Routing for Messages",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-12-08T17:13:22",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nI've been thinking a lot about the Onion Routing we designed a couple\nof weeks ago and how we would use it in practice.\n\nSo I am in full privacy mode currently and I would prefer to design a\nsystem in which sender and receiver of a payment by default do not\nlearn any additional information about each other. This means that\npayments will - by default - get routed over a rendezvous point(RP)\nand encrypted using a onion scheme.\n\nSo if A wants to make a payment to E, E will choose a RP C and create\nan onion object which will allow C to route the payment further\ntowards E. A will not know which node is receiving the payment, A only\nknows that it should route the payments towards C. So A uses the\nobject E sent him and wraps the onion layers for the routing towards C\naround it. When C receives it, it does not know that A sent it, nor\nthat it should be relayed to E finally. It will just follow the\ninstructions E put in the onion object.\n\nIn practice E can use a (reasonably sized) QR code to transmit this\nblob of data to A.\n\nHowever, we have to decide whether we want this whole onion-routing to\nbe one-time and one-directional or not.\n\nThe design where we stopped few weeks ago did fill up the onion\nobjects with zeros, so unless the nodes store some data to relate to\nthat message later, it is not possible for the receiver to send a\nmessage back to the sender. (or to have any additional communications\nat all for that matter)\n\nThis means we would need to transmit the payment hash together with\nthe blob in the QR code. Furthermore, if the payment goes missing, we\nneed some additional communications channel to address routing of the\nrefund payment. (NFC would qualify for that if we are using a mobile\nwallet)\nIt also means that payment requests are one-time only, as they include\nthe payment hash. (even though we could try to do some fancy things if\nwe settle for EC keys for payments)\n\n\nOn the other hand, it would be possible to have a message system\nintegrated. When parsing the onion object, each node could encrypt and\nappend the pubkey of the node it received the object from together\nwith the ephemeral key used initially. When the receiver wants to send\na message back, he encrypts it using some designated ephemeral key\nincluded by the sender and uses the onion object to send it back. The\nnodes on the route can unwrap the onion object again to route it back\nto the original sender.\n\nThis means that a payment request is just a way of contacting the\nreceiver to obtain information about making a payment. It can be\nstored and reused whenever you want to make a payment. You can also\nsend the necessary signatures for the pay-to-contract scheme as\ninclude other data necessary if we want to implement something like\nProof-of-Payment. In general, it would allow for very general purposes.\n\nWhich - on the other hand - is also problematic. It is difficult to\nprovide a reasonable DoS protection against nodes just spamming the\nnetwork with unnessesary messages. We could assign super tiny payments\nto the process of sending a message to counter spam, but it might be\ndifficult to implement.\n\nAdditionally it serves a security risk, as someone obtaining the onion\nobject can 'hunt down' the sender by targeting the nodes consisting\nthe route one by one. Currently this is only possible for tracking\ndown the receiver. For one to succeed in such a task, it is necessary\nto extract the private key used for encryption for ALL nodes in the rout\ne.\n\n- -- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats.jerratsch at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJWZw+yAAoJEAYZmwZ/PsbK7soQAILSfSsENE9a87YU7xBj5Cws\nB35rPYBVHcUCLWRIEOsEd3FCRmMDNQUGkzMFMaMXwWEBkVV5+csDhSCQxP8WdV3V\nb8Y/ZzkpiMj7FUdFp64dNtUken24ixgbPK1tCGyhTiDb47uUWr1GeeF+wL51oSXp\nua2XM+y07RO9ghO7Sl25vAjQqeuN4tmoEU6u0AWGw9L0vVIFz/J6IXCjUG4w/ruo\n7ljMUaSwir65euEmr1OEMGyB1doB6YBB5TmcRCP2sDENSdGizc9wQ0xeGeb9h8Kd\nZrggdX/NXpU4PS6Mn+SGNdJoVjv/NincQ5ZBBm6qtWC0f4Nq2nXgb/ISuEk/01Lp\n3MNZu3r1pM5GJ7VH+zbmJxxv4sfI7GCY+D9is8hAN5IXCSaeTwkSJY3qzevWrP/h\n5DSStjPU8K6h1JAiD+TDX1XtVNSmx7IKrRH1rEcQC6SmePYe871fQNFU1qdUro/P\nJMIza4uRrHcyI/RjLGLQoy+EHCO+LbkXzmW/7k/trAZZWZ6f6F/wtCpDAKHPsl9q\nudzjWIqv+3FHrjpgGW6WwrYzvkxDQ4rJPrSm+C/96Us4ePLn1syq+Z9m40xF/jZU\nXXmGuu8Cx9mYk8/Dthv7Zs0muK2QC0UoAYpMuWQnAYWikeTWHYgaGD33hAz43Xwt\n96Mt8FoNhSGLKoL+5YuI\n=qWKx\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Bryan Bishop",
                "date": "2015-12-08T17:53:40",
                "message_text_only": "On Tue, Dec 8, 2015 at 11:13 AM, Mats Jerratsch wrote:\n> However, we have to decide whether we want this whole onion-routing to\n> be one-time and one-directional or not.\n\nI have sort of lost track of preferences regarding what is to be sent\nthrough onion routing versus what's not...\n\nOriginally I had assumed that some out-of-band messaging would be\ntaking place (like an equivalent to a BIP70-style payment protocol).\nRather than a single QR code, I was expecting an interactive\nwallet-to-wallet protocol while both sides are busy communicating with\nthe onion routing network for the actual payment route negotiation\nstuff. When they ultimately find that no sufficiently cheap route\nexists, then the wallets would opt to create a new payment channel in\nsome circumstances.\n\nOnce a path is found, the recipient would then communicate over the\nwallet-to-wallet channel to pass over the fully-constructed onion\nrouting information. Sending that data back over the onion routing\nnetwork may not be necessary. Unfortunately this increases the\ncomplexity of the payment side (wallet-to-wallet), but meanwhile makes\nfor less message passing in onion land, which could make the problem\neasier to think about?\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-12-09T09:45:20",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n> I have sort of lost track of preferences regarding what is to be\n> sent through onion routing versus what's not...\n\nAgree, it hasn't been on list for quite some time, the last time we\ndiscussed it, we only included the route in there.\n\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-October/00\n0247.html\n\nBack then only the pubkey of the next hop has been part of the onion\nobject, with no additional message to the final receiver. For having\nthe added privacy of changing R value we would probably add a random\nnumber in there as well.\n\n> Originally I had assumed that some out-of-band messaging would be \n> taking place (like an equivalent to a BIP70-style payment\n> protocol). Rather than a single QR code, I was expecting an\n> interactive wallet-to-wallet protocol while both sides are busy\n> communicating with the onion routing network for the actual payment\n> route negotiation stuff. When they ultimately find that no\n> sufficiently cheap route exists, then the wallets would opt to\n> create a new payment channel in some circumstances.\n\nInteresting. I think the important term here is 'out-of-band', as I\nwould implement above using the actual lightning network. But I also\nfail to see how to implement a secure and private communications. I\nguess one way would be to have wallets open up a hidden service on TOR\nand take payment requests on a service listening there. But it would\nnot exactly reduce complexity nor would provide sufficient defense\nagainst DoS attacks. Everything simplifies a bit when we assume these\ncommunications using non-private way as simple\nHTTPS-requests-responses, but I think we are sacrificing too much\nprivacy on the way.\n\n> Once a path is found, the recipient would then communicate over\n> the wallet-to-wallet channel to pass over the fully-constructed\n> onion routing information. Sending that data back over the onion\n> routing network may not be necessary. Unfortunately this increases\n> the complexity of the payment side (wallet-to-wallet), but\n> meanwhile makes for less message passing in onion land, which could\n> make the problem easier to think about?\n\nDo you mind defining wallet-to-wallet channel a bit more? Which\ntechniques could/should they use without leaking information?\n\nYes, we would increase the total load for the nodes if they should\nhandle these additional messages. But I think we can go with a\nsimplified message-delivery-system where each hop costs like 1 satoshi.\nI call it simplified, because we are not using the a HTLC, but just\nrebalancing the unencumbered outputs of the commit transaction.\n\nAs the sender of a message you can go to the first node and give him\n30 satoshis for opening the onion object and passing the message to\nthe next node as instructed in the onion object. It would pay the next\nnode 29 satoshis, and so on. These would not be enforcable on the\nblockchain, so a dishonest node could just keep the 29 satoshis and\nnot deliver anything at all. However, if you receive a message to\nrelay it, it is a strong indication that there is a payment to follow\nup to that message. The general incentive is to relay these messages,\nas fees of payment are likely higher. Given that we can have\nsub-satoshi payments too, we might want to tune the cost-per-hop to\nmake it substantially less than any fees you could get of the payment.\n\nIf it remains a problem (and some people could just join the network\nand not relay anything just for the sake of it), we might either find\na way to proof this behavior or even use HTLCs for these, even though\nthat would probably be not practical and bloat commit transactions\nwaay too much.\n\n\n- -- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats.jerratsch at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJWZ/gwAAoJEAYZmwZ/PsbKv4MQAKxoeZ+G3ozifODlY7nhqYeE\nGQChU8DyDal8tAn1Bgb44s7SZMltSgpL9RR2G51/Cn0pygPMPUkT9OS5mRNMlEA1\ns1JZ3annaxkJslUlFeF86Tw1MC8LhFYi/WbnJoCPElTmR1PljOtCmpUpjlrDMx7N\nYNyjD/zUR+N1ZMqZh0q5okoZegyOkgo0biT5RHrjALUEnK3qWh/PCwUHXYdN/l22\nh0LaEi0ajTFhEPNygSFz3Z13KmwYvsmsHl9MydweLbKARx6wo7OPxOWbuNVqD7xF\n4eGgkniQZgZM+8owYFifXn/XVGj65PLQaqCN0o/gmCKphqjgoPWtbcJtKg8NtShN\n6AI54ZqAtqh4IxpOZRBm2OiFW5TTou/XICDrCS/mfCNtv0wYNANop9+WQ/KTfStx\nKnL986TDww5XkLws30Q9C6qFpBjwEgmTmGibvCM8z+HPe223kW0ElofLrWmvqyso\nNcj+iKj91cJLbs3XuzZ6pMgBwhW0ERSRj4bUm6r/oApSRyxYNNLVchOFhU9eWJxu\ndhJul2ACFpcTql2zQOUhUe3PXD6M3cRpyLgeqRMNGNNs4+3eTnFdNiqWjK+QIIvZ\nuFWpUDcPh3TJSh7TBZCHSxtAIHpCUyPL8u/LV6oZ4PHSd5aLMMm5tq95ViDNzAvm\nARTMgJtNA6q4CYlUflr3\n=b/hD\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-12-09T10:19:25",
                "message_text_only": "Mats Jerratsch via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA512\n>\n>> I have sort of lost track of preferences regarding what is to be\n>> sent through onion routing versus what's not...\n>\n> Agree, it hasn't been on list for quite some time, the last time we\n> discussed it, we only included the route in there.\n\nYes, plus some padding for future stuff.\n\n        There are two ideas here.  One is the passing of messages over\nthe lightning network.  The other is a rendezvous node for payments.\nFortunately, the two can be extricated.  The vendor negotiates with a\nnode to forward a payment, then tells the buyer to route to that node.\nBuyer doesn't need to know it's not the final recipient; there's no\nprotocol change.\n\nProvision of messaging is an interesting idea, but as you point out\nthere are problems with payments.  If we use lightning for this, then\nthe recipient will just claim the route failed and not pay for the\nmessage.  If we don't use lightning, we have to trust the nodes\ninstead.  If we don't charge, we worry about spam.\n\nMore generally, reinventing a p2p messaging network seems outside\nscope.  The good news is that there's nothing stopping us doing so in a\nfuture revision (is there?).\n\nCheers,\nRusty.\nPS.  Congratulations on the job!!"
            }
        ],
        "thread_summary": {
            "title": "Onion-Routing for Messages",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Mats Jerratsch",
                "Rusty Russell"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 11744
        }
    },
    {
        "title": "[Lightning-dev] GUI for Lightning Network?",
        "thread_messages": [
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-13T01:03:12",
                "message_text_only": "Hi everybody,\n\nDo you think it's a good idea to write a GUI for LN node management?\n\nWhich features would you like to see there?\n-- \n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/a9bcf9d7/attachment.html>"
            },
            {
                "author": "gb",
                "date": "2015-12-13T01:07:07",
                "message_text_only": "On Sun, 2015-12-13 at 01:03 +0000, Denis Gorbachev wrote:\n> Hi everybody,\n> \n> \n> Do you think it's a good idea to write a GUI for LN node management?\n> \nYes.\n> \n> Which features would you like to see there?\n> -- \nAll of them.\n> \n> @DenGorbachev\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-13T01:14:11",
                "message_text_only": "Hi Greg, thanks for encouragement :) What's the most important thing you\nwant to see in the GUI? Like, where should I start?\n\nOn Sun, Dec 13, 2015 at 8:07 AM gb <kiwigb at yahoo.com> wrote:\n\n> On Sun, 2015-12-13 at 01:03 +0000, Denis Gorbachev wrote:\n> > Hi everybody,\n> >\n> >\n> > Do you think it's a good idea to write a GUI for LN node management?\n> >\n> Yes.\n> >\n> > Which features would you like to see there?\n> > --\n> All of them.\n> >\n> > @DenGorbachev\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> --\n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/61c964ee/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2015-12-13T01:30:10",
                "message_text_only": "On Sunday, December 13, 2015 1:03:12 AM Denis Gorbachev wrote:\n> Hi everybody,\n> \n> Do you think it's a good idea to write a GUI for LN node management?\n> \n> Which features would you like to see there?\n\nI would like to see it transparently supported in Bitcoin Core GUI, using an \nexternal library.\n\nLuke"
            },
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-13T02:08:47",
                "message_text_only": "Luke,\n\nAre you talking about the wallet integration or LN node management?\n\nSuppose you are running an intermediary LN node. You want to compare your\nfees for current month VS previous month. You can do that with command line\n(dump the logs, parse them, etc) or you can do that with GUI.\n\nTwo questions:\n - Is this a real use case?\n - Why not implement it as web application that connects to LN node backend?\n\nOn Sun, Dec 13, 2015 at 8:30 AM Luke Dashjr <luke at dashjr.org> wrote:\n\n> On Sunday, December 13, 2015 1:03:12 AM Denis Gorbachev wrote:\n> > Hi everybody,\n> >\n> > Do you think it's a good idea to write a GUI for LN node management?\n> >\n> > Which features would you like to see there?\n>\n> I would like to see it transparently supported in Bitcoin Core GUI, using\n> an\n> external library.\n>\n> Luke\n>\n-- \n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/a4b90bad/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2015-12-13T03:13:01",
                "message_text_only": "This line of thinking is technically informed. Lightning nodes will have to\nbe on 24/7 in order to be routed through, so it is probably better to\napproach this the same way one would a server daemon: your favorite\nback-end API stack (REST, JSON-RPC, whatever) with request authentication,\ncopious logs, and some sort of authenticated web interface to view pretty\ngraphs. A mobile command and control application would be gravy.\n\nThat said, there is probably room for a \"lite mode\" client which is an\nendpoint -- it is not online 24/7 to be routed through, but can send or\nreceive payments when turned on. The correct approach here is to probably\nintegrate with existing wallets as another payment type.\n\nOn Sun, Dec 13, 2015 at 10:08 AM, Denis Gorbachev <\ndenis.d.gorbachev at gmail.com> wrote:\n\n> Luke,\n>\n> Are you talking about the wallet integration or LN node management?\n>\n> Suppose you are running an intermediary LN node. You want to compare your\n> fees for current month VS previous month. You can do that with command line\n> (dump the logs, parse them, etc) or you can do that with GUI.\n>\n> Two questions:\n>  - Is this a real use case?\n>  - Why not implement it as web application that connects to LN node\n> backend?\n>\n> On Sun, Dec 13, 2015 at 8:30 AM Luke Dashjr <luke at dashjr.org> wrote:\n>\n>> On Sunday, December 13, 2015 1:03:12 AM Denis Gorbachev wrote:\n>> > Hi everybody,\n>> >\n>> > Do you think it's a good idea to write a GUI for LN node management?\n>> >\n>> > Which features would you like to see there?\n>>\n>> I would like to see it transparently supported in Bitcoin Core GUI, using\n>> an\n>> external library.\n>>\n>> Luke\n>>\n> --\n> @DenGorbachev <https://twitter.com/DenGorbachev>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/3a0cc7e8/attachment-0001.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2015-12-13T06:38:35",
                "message_text_only": "On Sunday, December 13, 2015 2:08:47 AM Denis Gorbachev wrote:\n> Are you talking about the wallet integration or LN node management?\n\nI don't see a distinction. Why wouldn't every wallet be a LN node?\n\n> Suppose you are running an intermediary LN node. You want to compare your\n> fees for current month VS previous month. You can do that with command line\n> (dump the logs, parse them, etc) or you can do that with GUI.\n\nSeems to me reports on various transactions would be a useful feature in \ngeneral, not necessarily tied to LN.\n\nLuke"
            },
            {
                "author": "Lawrence Botley",
                "date": "2015-12-13T09:20:05",
                "message_text_only": "Mark: I think your approach is best, putting the effort into an RPC\ninterface leads the way for agnostic web clients with OTP as standard.\nyubikey support would be great.\n\nOn Sun, Dec 13, 2015 at 6:38 AM, Luke Dashjr <luke at dashjr.org> wrote:\n\n> On Sunday, December 13, 2015 2:08:47 AM Denis Gorbachev wrote:\n> > Are you talking about the wallet integration or LN node management?\n>\n> I don't see a distinction. Why wouldn't every wallet be a LN node?\n>\n> > Suppose you are running an intermediary LN node. You want to compare your\n> > fees for current month VS previous month. You can do that with command\n> line\n> > (dump the logs, parse them, etc) or you can do that with GUI.\n>\n> Seems to me reports on various transactions would be a useful feature in\n> general, not necessarily tied to LN.\n>\n> Luke\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/093b6abb/attachment.html>"
            },
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-13T10:18:06",
                "message_text_only": "Mark, Lawrence: yes, agree on both points. So there will be:\n1. Endpoints (consumers + providers)\n2. Relays (the LN nodes I was talking about - sorry for putting them in the\nsame basket with endpoints)\n\nEndpoints need to be integrated into wallets.\nRelays need to be standalone, with their own management console.\n\nCorrect?\n\nOn Sun, Dec 13, 2015 at 4:20 PM Lawrence Botley <lawrence.botley at gmail.com>\nwrote:\n\n> Mark: I think your approach is best, putting the effort into an RPC\n> interface leads the way for agnostic web clients with OTP as standard.\n> yubikey support would be great.\n>\n> On Sun, Dec 13, 2015 at 6:38 AM, Luke Dashjr <luke at dashjr.org> wrote:\n>\n>> On Sunday, December 13, 2015 2:08:47 AM Denis Gorbachev wrote:\n>> > Are you talking about the wallet integration or LN node management?\n>>\n>> I don't see a distinction. Why wouldn't every wallet be a LN node?\n>>\n>> > Suppose you are running an intermediary LN node. You want to compare\n>> your\n>> > fees for current month VS previous month. You can do that with command\n>> line\n>> > (dump the logs, parse them, etc) or you can do that with GUI.\n>>\n>> Seems to me reports on various transactions would be a useful feature in\n>> general, not necessarily tied to LN.\n>>\n>\n>> Luke\n>>\n>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> --\n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/009da452/attachment.html>"
            },
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-13T10:13:54",
                "message_text_only": "On Sun, Dec 13, 2015 at 1:39 PM Luke Dashjr <luke at dashjr.org> wrote:\n\n> On Sunday, December 13, 2015 2:08:47 AM Denis Gorbachev wrote:\n> > Are you talking about the wallet integration or LN node management?\n>\n> I don't see a distinction. Why wouldn't every wallet be a LN node?\n>\n\nBecause there's a risk of being hacked.\n\nAs I see it, running a node is a business. It's not like putting your money\nin a bank and forgetting about it, because you need to run a server 24/7 or\nbe out-competed by other nodes. Running a server means having to deal with\nsecurity & updates. Is that correct?\n\n\n>\n> > Suppose you are running an intermediary LN node. You want to compare your\n> > fees for current month VS previous month. You can do that with command\n> line\n> > (dump the logs, parse them, etc) or you can do that with GUI.\n>\n> Seems to me reports on various transactions would be a useful feature in\n> general, not necessarily tied to LN.\n>\n\nYes, you're right - thanks for pointing out.\n\n\n>\n> Luke\n>\n-- \n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/fe111a53/attachment.html>"
            },
            {
                "author": "Lawrence Botley",
                "date": "2015-12-13T10:24:39",
                "message_text_only": "I would say a very real use-case and concur with metrics.\n\nAdminLTE is an open source web admin template and supports multiple\ncharting libraries and has a decent dashboard. -\nhttps://almsaeedstudio.com/preview\n\nId be very interesting in implementing this with a nodejs RPC wrapper.\n\nHere is one I wrote for Ethereum\n\nhttps://github.com/LawrenceBotley/EthereumRpc-NET\n\nOn Sun, Dec 13, 2015 at 2:08 AM, Denis Gorbachev <\ndenis.d.gorbachev at gmail.com> wrote:\n\n> Luke,\n>\n> Are you talking about the wallet integration or LN node management?\n>\n> Suppose you are running an intermediary LN node. You want to compare your\n> fees for current month VS previous month. You can do that with command line\n> (dump the logs, parse them, etc) or you can do that with GUI.\n>\n> Two questions:\n>  - Is this a real use case?\n>  - Why not implement it as web application that connects to LN node\n> backend?\n>\n> On Sun, Dec 13, 2015 at 8:30 AM Luke Dashjr <luke at dashjr.org> wrote:\n>\n>> On Sunday, December 13, 2015 1:03:12 AM Denis Gorbachev wrote:\n>> > Hi everybody,\n>> >\n>> > Do you think it's a good idea to write a GUI for LN node management?\n>> >\n>> > Which features would you like to see there?\n>>\n>> I would like to see it transparently supported in Bitcoin Core GUI, using\n>> an\n>> external library.\n>>\n>> Luke\n>>\n> --\n> @DenGorbachev <https://twitter.com/DenGorbachev>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151213/bed9c424/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "GUI for Lightning Network?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "gb",
                "Lawrence Botley",
                "Luke Dashjr",
                "Mark Friedenbach",
                "Denis Gorbachev"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 11527
        }
    },
    {
        "title": "[Lightning-dev] An Alternative Onion-Routing Proposal",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2015-12-14T22:04:01",
                "message_text_only": "Hi y'all!!\n\nSo I've been drafting up some schemes for the design of onion routing\nwithin the\nLightning Network myself. Rather than create my own mixing format, and\nonion\nrouting protocol, I've instead turned to some of the existing academic\nliterature\nconcerning the subject. I found two schemes, the first building upon the\nother, which seem to fit elegantly into our problem domain, directly solving\nmany problems we've encountered along the way.\n\nThe two schemes of interest are first Sphinx[1]: a compact mixing format,\nand\nHORNET[2][3], which leverages Sphinx to build a low-latency, high-bandwidth\nonion routing protocol.\n\nAlright, let's jump into and overview of both schemes!\n\n(heads up, this post is a bit long as it includes a brain dump of ideas\nI've\nbeen been floating around in my head for the past two months or so)\n\nFirst, I'll give a brief overview of Sphinx. I won't delve into the exact\ndetails of the protocol, instead I'll highlight the key insight that allows\nfor\n*extremely* small mix-headers. If we assume a maximum diameter of 20 hops,\nand a\n16-byte MAC, then a full onion blob weighs in at only 705 bytes! This is\nconsiderably smaller (a 4X size reduction) than the 3840 bytes per\nonion-blob in\ncurrent proposal. I recommend consulting the paper for the proper\nspecifics.\nAdditionally the paper includes a formal proof of security in the Universal\nComposability model[4], achieving each of the 4 properties outlined for a\nsecure\nonion routing protocol in [5].\n\n(btw, don't dismiss figures 1 and 2 in the Sphinx paper. They may look\nstrange,\nbut finally grokking them resulted in a break through allowing me to finish\nmy\nimplementation)\n\nSo, at this point, y'all may be wondering how Sphinx achieves such compact\nmix-headers. Well, Rather, than including a group element to perform DH\nwith\nfor *each* hop in the route, mix-headers in Sphinx only contain a single\ngroup\nelement. This single group element is then deterministically re-randomized\nby\neach hop in the route, preparing the group element for the hop directly\nfollowing it.\n\nHere's a brief sketch of the mechanism (covering only the DH aspects):\n\nSay Alice wants to route a payment to Bob (Y_b) over Lightning. Alice\nconsults her\nrouting/service table, and finds a route via Carol and Dave. Next, to\ncreate the\nmix-header, Alice grabs key-pairs for Carol (Y_c) and Dave (Y_d). She then\ngenerates\nan ephemeral DH key-pair (a_0 = g^x) then proceeds to derive a shared\nsecret\nfor each hop in the route. Using multiplicative notation, the DH derivation\nlooks something like this (s = shared key, b = blinding factor):\n  * a_0 = g^x,       s_0 = (Y_c)^x,         b_0 = hash(a_0, s_0)\n  * a_1 = (a_0)^b_0, s_1 = (Y_d)^x*b_0,     b_1 = hash(a_1, s_1)\n  * a_2 = (a_1)^b_1, s_2 = (Y_b)^x*b_0*b_1, b_2 = hash(a_2, s_2)\n  ......... continued if more hops were in the route ..........\n\nAlice computes all the blinding factors and shared secrets up front,\nallowing\nher to create the mix-header for each hop using the derived hop shared\nsecret\nto derive subsequent decryption and MAC keys. Each node receives a_{i}, and\nprepares a_{i+1} for the next hop by re-randomizing the group element using\nthe\nblinding factor.\n\nThe formula for computing the size of a mix-header for a given hop count,\nand\nsecurity parameter is (ignoring the final message size):\n  * p + (2r + 2)s\n    * p = pub key size (in bytes, for DH each hop)\n    * r = max number of hops\n    * s = symmetric key size (in bytes)\n\nSo, for 20 hops the size is computed as (with a symmetric key size of 16\nbytes):\n  * 33 + (2*20 + 2) * 16 = 705 bytes!\n\n445% smaller than the 3840 bytes of the current proposal.\n\nThe original version of Sphinx was designed with anonymous mailing in mind.\nSo the final mix-header to the destination node includes a final\ndestination\nemail-address (k-bits), and an Identifier (k-bits) used to generate reply\nmessages back to the sender. If we remove these from the mix-net, we save\n2k-bits arriving at a new formula to compute the mix-header size:\n  * p + (2*r*s)\n\nSo with 20 hops the size is reduced to:\n  * 33 + (2*20*16) = 673 bytes\n\nWith this size reduction the, the base64 encoding of a mix-header for two\nhops\ncan fit entirely into a tweet!\n  * 33 + (2*2*16) = 97 bytes\n\nHowever, it occurred to me that the final destination address may be useful\nin\nthe context of a more hub-and-spoke-y network. In this scheme the payment\nwould\nbe routed to a \"shared node\", who would then use the destination address to\ndemultiplexing the payment to one of its connected links in a \"host:port\"\nfashion.\n\nFinally, Sphinx has built-in protection for replay attacks. Meaning an\nadversary\nis unable to force a node to process a previously processed mix-header. It\nachieves this protection by having all nodes remember every derived shard\nsecret\nit has ever come across. However, within the paper, the extent of the past\nwith\nwhich a node is to recall is unspecified, leading to potentially large\nstorage\noverhead. However, it's worth noting that the paper recommends frequent key\nrotation, during which this table may be safely cleared. Additionally,\nnodes may\nalso employ a decaying bloom-filter/hash-set [6] for use in-between key\nrotations to create an upper bound on the storage overhead.\n\nWith that said, Sphinx is much more compact than the current proposal,\ncarries\na formal proof of security, and specifies replay protection.\n\nIt was recently brought up in [7], that allowing nodes to use onion routing\nwith\nLightning as an end-to-end messaging interface. This is where HORNET comes\nin.\nOne could use Sphinx's Single-Use-Reply-Blocks to allow the recipient to\ncommunicate with the sender after a dummy onion circuit has been set up.\nHowever, this introduces some performance considerations, due to Sphinx\nrequiring\neach hop to perform 2 asymmetric crypto operations (shared secret\nderivation + group element blinding)\nbefore forwarding. HORNET gets around this performance issue by first using\nSphinx\nto set up a duplex onion circuit between sender and receiver, which after\nset up,\nonly requires nodes to compute purely symmetric crypto operations before\nforwarding.\n\nContinuing, both Sphinx and the current proposal only provide sender\nanonymity.\nMeaning that only the source maintains unlinkability, therefore it learns\nthe\ndestination's location. The addition of HORNET allows both side to retain\nfull\nunlinkability. HORNET has a built-in, an optional rendezvous protocol,\nwhich is\na bit similar to the way Hidden Services in TOR work.\n\nWith that said, what follows is a brief high-level overview of the HORNET\nonion-routing\nprotocol (focusing on the initial set up, instead of data transmission).\n\nUnlike Sphinx, which is essentially a \"fire-and-forget\" onion routing\nprotocol\nfrom the view of the sender, HORNET requires a cumulative circuit\nround-trip\nas a set up phase before messaging can begin. Once completed, this set up\nphase\ncreates a duplex onion circuit between the sender and destination, allowing\na\nlevel of throughput approaching 93 Gb/s as reported experimentation section\nwithin\nthe paper.\n\nThe primary addition to Sphinx's mix-header format is something they've\ndubbed the\nAnonymous Header (AHDR). Instead of requiring each node in the mix-net to\nstore\nper-session state (which would prohibit scale in large networks), all\nsession-state\nis instead stored within the onion-packet itself. Therefore, each node only\nneeds to\nmaintain a local secret. A full AHDR contains contains a series of\nForwarding\nSegments (FSes) for each hop, allowing them to decrypt the per-hop onion,\nrevealing the next hop in the path. Each FS contains: the next hop in the\nroute,\na TTL value, and a derived shared secret. A full AHDR has the following\nformat:\n  * (FS, MAC, Onion wrapped FSes)\n\nFirst, let's go over how a duplex onion circuit is achieved, maintaining\nsender\nunlinkability (once again, using multiplicative notation):\n  * Sender Set Up:\n    * The sender obtains the current keys for each hop in the path,\nconstructing\n      a forward, and backwards path (the reverse of the forward path).\n    * The sender then generates a per-session ephemeral DH key-pair: (x,\ng^x)\n    * Using the Sphinx protocol described above, then sender then generates\ntwo\n      Sphinx mix-headers: one for the forwards path, and another for the\nbackwards\n      path. At this point, the source has derived shared secrets for each\nnode along\n      both paths.\n    * The message payload (SP) of the forward Sphinx mix-header (encrypted\nto the\n      destination), is the backwards Sphinx mix-header which allows the\ndestination\n      to reply to the sender.\n    * The Sphinx mix-header (SHDR) is then extended with two additions:\n      * A empty list of FSes (P_fs), which each intermediate node can\npopulate\n        without learning the total path length, nor their position within\nthe\n        route.\n      * The Sphinx per-hop MAC is also extended over the HORNET Common\nHeader\n        (CHDR): (packet type, hops, TTL)\n    * The sender then sends this set up packet to the first node in the\nroute:\n      (CHDR, SHDR, SP, P_fsf)\n  * Intermediate Node Set Up:\n    * Upon receipt of the Sphinx packet, each node processes it as normal\n      (according to Sphinx): deriving the shared secret, recovering the\nnext hop's\n      ID, and re-blinding the group element.\n    * Next, the node verifies the next-hop is correct, and that the packet\n      hasn't yet expired according to its TTL.\n    * In order to provide forward secrecy for the messaging phase,\n      the node then derives a new DH key-pair (y, g^y), and then derives a\nnew\n      shared secret to be included within the FS: (a_i)^y\n    * Using it's local shared secret (SV_i), the node creates a FS that\nonly it\n      can decrypt, adding this to the FS payload. This payload entry\nadditionally\n      includes the new ephemeral DH-key pair (y, g^y), allowing the source\nto derive\n      the shared secret which will be used for the FS's MAC (and also when\ntransmitting data).\n    * Finally the node re-assembles the packet (CHDR', SHDR', SP, P_fsf'),\nand\n      forwards it to the next hop.\n  * Destination Set Up:\n    * The destination initially processes the packet identically to the\nintermediate\n      nodes described above.\n    * It then decrypts the Sphinx payload, uncovering the backwards SHDR.\nThe node\n      then creates a new payload each of the completed FSes in the payload.\n      destined to the source.\n    * At this point, the destination has no knowledge of any of the derived\nshared\n      secrets, other than the one it has derived with the source.\n    * Next, it creates a new FS list P_fsb, to collect FSes along the\nbackwards path.\n    * Finally, it creates the backwards set up packet (CHDR, SHDR, SP_b,\nP_fsb), and\n      sends it to the first node on the backwards path.\n    * Each intermediate node then processes the backwards packet just as\nbefore.\n  * Data Transfer (brief overview, consult the paper for proper details)\n    * The source node then recovers the Sphinx payload SP_b, recovering the\n      forwarding segments for the forward (P_fsf) and backwards path (P_fsb)\n    * At this point, set up has been completed!\n    * The source node then constructs two initial AHDR's, one so it can\nsend\n      messages to the destination via the circuit, and the other which will\n      allow the destination to reply to the source.\n    * After the first message from S -> D, D obtains the backwards AHDR,\n      allowing it to reply without knowing the actual route.\n\nThe, the following modifications are necessary to achieve sender-receiver\nunlinkability as described earlier. The modification to allow send-receiver\nunlinkability is relatively straight forward. It involves nested AHDRs.\nLets\nsay Alice wants to send a message (or a payment in our case) to Bob while\nmaintaining\nfull unlinkability. Bob will first need to select a rendezvous point (RP),\nlet's call him Rodriguez. Bob then executes the set up protocol detailed\nabove\nbetween himself and Rodriguez. As a result, Bob obtains a AHDR allowing\nRodriguez\nto route messages (via some specified path) to Bob (R -> B). Bob then\npublishes\nthis AHDR_rb to some \"public bulletin board\", or in the case that Alice has\na\nhidden service set up, directly to Alice. Alice then obtains the AHDR_rb,\nrouting as normal to Rodriguez, but then includes AHDR_rb, nested within\nthe\nregular AHDR_ar (Alice -> Bob). Once this mix-header reaches Bob, he\nrecovers the\nnested AHDR, allowing him to complete the route to Bob. Additionally, its\npossible\nfor Bob to specify several rendezvous points, allowing Alice to select the\nclosest/cheapest route to her. As a side effect, the usage  of this nested\nAHDR\ndoubles the bandwidth required for each node to forward along the path.\n\nWith this duplex onion route set up (with or without the RP), Alice can\nsend a\nmessage to Bob, asking for R (along with other payment details), then\npropagate\nHTLCs along the full path in order to pay Bob. In order to mitigate the\npotential\nDoS attacks introduced by adding a message layer for control signals, we\ncan\neither introduce a payment system (as suggested in [8]), or a required\nHashcash\nchallenge (avoiding SHA-256, using either SHA-3 or BLAKE2). However, seeing\nas\nwe'd like to maintain the responsiveness of the network, I'm personally\nleaning\ntowards payments (if we do in fact deem in network messaging attractive).\n\nOkay, so that concludes my first post on the mailing list! So at this point\ny'all may be wondering where the implementation I mentioned above is?\nWell, so far I have a working implementation of Sphinx by itself, not yet\nintegrating the aspects of HORNET, but, it's not yet publicly released.\n\nWe (me+Tadge+Joseph) are planning on publicly releasing our in progress\nimplementation of Lightning, sometime near the end of this month (December)\n:).\n\n1. http://www.cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf\n2. http://arxiv.org/pdf/1507.05724v1.pdf (HORNET w/ forward secrecy)\n3. http://www.scion-architecture.net/pdf/2015-HORNET.pdf\n4. https://eprint.iacr.org/2000/067.pdf\n5. http://cs.brown.edu/~anna/papers/cl05-full.pdf\n6. https://moderncrypto.org/mail-archive/messaging/2015/001906.html\n7.\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-December/000369.html\n8.\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-December/000371.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151214/996b3701/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-12-15T02:30:52",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> Hi y'all!!\n\nHi Olaoluwa, welcome to the list!\n\n        I've yet to read the papers, so forgive if I've made an error\nbelow.\n\n> First, I'll give a brief overview of Sphinx. I won't delve into the exact\n> details of the protocol, instead I'll highlight the key insight that allows\n> for\n> *extremely* small mix-headers. If we assume a maximum diameter of 20 hops,\n> and a\n> 16-byte MAC, then a full onion blob weighs in at only 705 bytes! This is\n> considerably smaller (a 4X size reduction) than the 3840 bytes per\n> onion-blob in\n> current proposal.\n\nNot sure where these numbers come from?  The current header overhead is\nsha256 (32 bytes) + pubkey (33 bytes), or 1300 bytes.  (Don't be\nconfused by the current test implemenation which doesn't serialize the\npubkey).\n\nIf we were to cut to a 16 byte MAC (which seems unwise), that would be\n980 bytes.\n\n> Alice computes all the blinding factors and shared secrets up front,\n> allowing\n> her to create the mix-header for each hop using the derived hop shared\n> secret\n> to derive subsequent decryption and MAC keys. Each node receives a_{i}, and\n> prepares a_{i+1} for the next hop by re-randomizing the group element using\n> the\n> blinding factor.\n>\n> The formula for computing the size of a mix-header for a given hop count,\n> and\n> security parameter is (ignoring the final message size):\n>   * p + (2r + 2)s\n>     * p = pub key size (in bytes, for DH each hop)\n>     * r = max number of hops\n>     * s = symmetric key size (in bytes)\n>\n> So, for 20 hops the size is computed as (with a symmetric key size of 16\n> bytes):\n>   * 33 + (2*20 + 2) * 16 = 705 bytes!\n>\n> 445% smaller than the 3840 bytes of the current proposal.\n\nOr, if we're standarizing on ChaCha20, with a 32-byte key:\n\n   33 + (2 * 20 + 2) * 32 = 1377 bytes.\n\n> The original version of Sphinx was designed with anonymous mailing in mind.\n> So the final mix-header to the destination node includes a final\n> destination\n> email-address (k-bits), and an Identifier (k-bits) used to generate reply\n> messages back to the sender. If we remove these from the mix-net, we save\n> 2k-bits arriving at a new formula to compute the mix-header size:\n>   * p + (2*r*s)\n>\n> So with 20 hops the size is reduced to:\n>   * 33 + (2*20*16) = 673 bytes\n\nOr 33 + 2 * 20 * 32 = 1313 bytes for ChaCha20.\n\n> With this size reduction the, the base64 encoding of a mix-header for two\n> hops\n> can fit entirely into a tweet!\n>   * 33 + (2*2*16) = 97 bytes\n\nNow, *that* is an important metric :)\n\nMore important than the size is the idea of reusing a proven design over\nan ad-hoc one, so we should use this anyway.\n\nHORNET seems a bit over-the-horizon for now, so I'll leave that reply\nfor a future message :)\n\n> We (me+Tadge+Joseph) are planning on publicly releasing our in progress\n> implementation of Lightning, sometime near the end of this month (December)\n> :).\n\nGreat!  Let's argue about protobufs and ChaCha20 vs AES before then :)\n\nThanks!\nRusty."
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2015-12-15T05:16:04",
                "message_text_only": ">\n> Not sure where these numbers come from?  The current header overhead is\n> sha256 (32 bytes) + pubkey (33 bytes), or 1300 bytes.  (Don't be\n> confused by the current test implementation which doesn't serialize the\n> pubkey).\n>\n\nHmm, I pulled those numbers from here:\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-October/000247.html:\n\"That's a fixed 3840 bytes; each node decrypts and removed the tail entry,\nthen prepends padding.\" Perhaps there's been a newer iteration I've missed,\nor the 3.8K bytes isn't the true serialized size.\n\n\n\n> If we were to cut to a 16 byte MAC (which seems unwise)\n\n\nWith Poly1035 (which takes 32-byte key and produces a 16-byte tag), forged\nmessages are rejected with a probability of 1-(n/(2^102)) for a 16n-byte\nmessage[1].  Since the MAC is computed over the 656 byte (20 hops, s=16)\nrouting-info portion (the onion-wrapped part of the mix header), forged\ntags will be rejected with a probability of 1-(656/(2^102)), which seems\nokay to me.\n\n\n\n> Or, if we're standarizing on ChaCha20, with a 32-byte key:\n>\n>    33 + (2 * 20 + 2) * 32 = 1377 bytes.\n>\n\nApologies for the ambiguity, but, the \"(..)*16\" (s) more accurately refers\nto the size of the HMAC and node ID's. So if using ChaCha for a stream\ncipher, and Poly1035 for MACs rather than AES-CTR + a truncated\nSHA-256-HMAC, the size remains the same. Either AES-CTR or ChaCha20 are\nvalid candidates for the required stream-cipher in the Sphinx construction.\n\nAs an side, my current implementation uses AES-CTR as a stream cipher, and\na truncated SHA-256-HMAC for the MAC (s=20). It was written before we\ncozied up to ChaCha20-Poly1035. I'll be porting it over to ChaCha-Poly3015\nonce I tick off some more high-priority items from my TODO list (assuming\nwe're comfortable with 16-byte node ID's, node ID's are used to map to a\nnode's current DH-key (id -> key)).\n\n\nHORNET seems a bit over-the-horizon for now\n>\n\nAgreed! Sphinx should be sufficient for now.\n\n\nGreat!  Let's argue about protobufs and ChaCha20 vs AES before then :)\n>\n\nPerhaps in a new thread :)\n\nOh, and also, we've come up with a slight variation on the current proposed\np2p crypto handshake. It builds off of the current method (ephemerals\nfirst, etc.). I should get around to posting it to the ML sometime\ntomorrow+1 (I'd like to make sure it's sound).\n\n1. https://tools.ietf.org/html/rfc7539 (Section 4)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151215/ac6be70f/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-12-15T23:38:46",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n>>\n>> Not sure where these numbers come from?  The current header overhead is\n>> sha256 (32 bytes) + pubkey (33 bytes), or 1300 bytes.  (Don't be\n>> confused by the current test implementation which doesn't serialize the\n>> pubkey).\n>>\n>\n> Hmm, I pulled those numbers from here:\n> http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-October/000247.html:\n> \"That's a fixed 3840 bytes; each node decrypts and removed the tail entry,\n> then prepends padding.\" Perhaps there's been a newer iteration I've missed,\n> or the 3.8K bytes isn't the true serialized size.\n\nHi Roasbeef!\n\nAh, that includes payloads for each node, though, not just the headers.\nThere's stuff in there for Future Use.\n\n>> If we were to cut to a 16 byte MAC (which seems unwise)\n>\n> With Poly1035 (which takes 32-byte key and produces a 16-byte tag), forged\n> messages are rejected with a probability of 1-(n/(2^102)) for a 16n-byte\n> message[1].  Since the MAC is computed over the 656 byte (20 hops, s=16)\n> routing-info portion (the onion-wrapped part of the mix header), forged\n> tags will be rejected with a probability of 1-(656/(2^102)), which seems\n> okay to me.\n\nAh, I hadn't appreciated that poly1035 was 128 bit tags already!  Let's\nargue it in the crypto thread which we'll start.  I'm happy to the\ncrypto experts debate AES-CTR + HMAC-SHA-256 (which I used) vs\nChaCha20+poly1035.\n\nIt's a simple change, code-wise.\n\n>> Or, if we're standarizing on ChaCha20, with a 32-byte key:\n>>\n>>    33 + (2 * 20 + 2) * 32 = 1377 bytes.\n>>\n>\n> Apologies for the ambiguity, but, the \"(..)*16\" (s) more accurately refers\n> to the size of the HMAC and node ID's. So if using ChaCha for a stream\n> cipher, and Poly1035 for MACs rather than AES-CTR + a truncated\n> SHA-256-HMAC, the size remains the same. Either AES-CTR or ChaCha20 are\n> valid candidates for the required stream-cipher in the Sphinx construction.\n>\n> As an side, my current implementation uses AES-CTR as a stream cipher, and\n> a truncated SHA-256-HMAC for the MAC (s=20). It was written before we\n> cozied up to ChaCha20-Poly1035. I'll be porting it over to ChaCha-Poly3015\n> once I tick off some more high-priority items from my TODO list (assuming\n> we're comfortable with 16-byte node ID's, node ID's are used to map to a\n> node's current DH-key (id -> key)).\n\n128 bits definitely seems a bit tight for node ids: I assumed a full\nbitcoin EC pubkey in my current implementation.\n\n> HORNET seems a bit over-the-horizon for now\n>>\n>\n> Agreed! Sphinx should be sufficient for now.\n\nMatts was really interested in sending messages over LN, though, so no\ndoubt he'll be salivating at the idea of extending in this direction :)\n\n> Great!  Let's argue about protobufs and ChaCha20 vs AES before then :)\n>>\n>\n> Perhaps in a new thread :)\n>\n> Oh, and also, we've come up with a slight variation on the current proposed\n> p2p crypto handshake. It builds off of the current method (ephemerals\n> first, etc.). I should get around to posting it to the ML sometime\n> tomorrow+1 (I'd like to make sure it's sound).\n\nSure, let's discuss that.  I want to modify the handshake anyway to\ninclude a <len> prefix (like every other message).  This lets us upgrade\nthe crypto later, by appending a key for a different system.\n\n> 1. https://tools.ietf.org/html/rfc7539 (Section 4)\n\nThat's a definite MUST READ for any implementer...\n\nThanks!\nRusty.\nPS.  Are we having fun yet?"
            },
            {
                "author": "Zooko Wilcox-OHearn",
                "date": "2015-12-16T17:57:56",
                "message_text_only": "I'm so happy to see this direction of re-using prior work \u2014 SPHINX \u2014\ninstead of inventing a new wheel. Thank you, roasbeef!\n\nOn Tue, Dec 15, 2015 at 11:38 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n> I'm happy to the crypto experts debate AES-CTR + HMAC-SHA-256 (which I used) vs ChaCha20+poly1035.\n\nI'd prefer ChaCha20+poly1305.\n\n> 128 bits definitely seems a bit tight for node ids: I assumed a full\n> bitcoin EC pubkey in my current implementation.\n\nI have a pretty good sense of how risky short node ids are, but I\ndon't have a good idea of how costly long node ids are in this\ncontext. I also don't know how many node ids are likely to exist in\nthe long-run, successful scenario. 10\u2079? 10\u00b9\u00b2? Not more than 10\u00b9\u2075!\n\nI'd suggest 192-bit nodeids, based on such musings as:\n\n* http://ecrypt-eu.blogspot.de/2015/11/break-dozen-secret-keys-get-million.html\n\n* http://www.keylength.com/en/compare/\n\nI feel confident that 192-bit nodeids are safe enough. Whether they\nare, practically speaking, more efficient than 256-bit nodeids I'll\nleave up to you to answer.\n\n> Matts was really interested in sending messages over LN, though, so no\n> doubt he'll be salivating at the idea of extending in this direction :)\n\n\u263a\n\n> Sure, let's discuss that.  I want to modify the handshake anyway to\n> include a <len> prefix (like every other message).  This lets us upgrade\n> the crypto later, by appending a key for a different system.\n>\n>> 1. https://tools.ietf.org/html/rfc7539 (Section 4)\n>\n> That's a definite MUST READ for any implementer...\n\n+1! Please don't assume that your endpoint can reliably update\npersistent state, and if at all possible don't assume that your\nplatform's CSPRNG is good. This is the weakest point in the system\nIMHO, based on empirical evidence.\n\nA good way to strengthen this weak point is to mix persistent state,\n*and* platform CSPRNG, *and* mix in unique and/or private information\nfrom the current protocol state, so that if any of those one is good\nthen your nonce is unique and your key unguessable.\n\n> PS.  Are we having fun yet?\n\nYES!\n\nRegards,\n\nZooko"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2015-12-17T18:08:24",
                "message_text_only": ">\n>\n> >\n> > I'm happy to the crypto experts debate AES-CTR + HMAC-SHA-256 (which I\n> used) vs ChaCha20+poly1035.\n>\n> I'd prefer ChaCha20+poly1305.\n>\n\nWelcome aboard the Cha Cha Train! [1]\n\n\n>\n> > 128 bits definitely seems a bit tight for node ids: I assumed a full\n> > bitcoin EC pubkey in my current implementation.\n>\n> I have a pretty good sense of how risky short node ids are, but I\n> don't have a good idea of how costly long node ids are in this\n> context. I also don't know how many node ids are likely to exist in\n> the long-run, successful scenario. 10\u2079? 10\u00b9\u00b2? Not more than 10\u00b9\u2075!\n>\n> I'd suggest 192-bit nodeids, based on such musings as:\n>\n> *\n> http://ecrypt-eu.blogspot.de/2015/11/break-dozen-secret-keys-get-million.html\n>\n> * http://www.keylength.com/en/compare/\n>\n> I feel confident that 192-bit nodeids are safe enough. Whether they\n> are, practically speaking, more efficient than 256-bit nodeids I'll\n> leave up to you to answer.\n>\n>\nCurrently, in our code, node ID's take two forms: either the hash160\n(Bitcoin style) of a node's current pub-key or the raw serialized pub-key\nitself. This is done such that \"nodeID at host\" locators explicitly provide a\nlevel of backwards (p2pkh) compatibility for end wallets that are unable to\nestablish a connection in a timely manner.\n\nWithin the Sphinx mix-header, I think we should be safely able to truncate\nthis (the hash160) to 16-bytes. In the case of a collision, the onion-route\npropagation across the incorrect node will simply fail, as it won't be able\nto properly derive the shared secret.\n\nOtherwise, we'd be forced to ditch chacha20+poly3015 for\nAES-CTR+SHA-256-HMAC within Sphinx if serialized pub-keys are used for node\nID's in the routing info.\n\n\n> > Matts was really interested in sending messages over LN, though, so no\n> > doubt he'll be salivating at the idea of extending in this direction :)\n>\n>\nI can't blame him! Utilizing HORNET's rendezvous protocol will allow for a\nhigh level of privacy for both sender *and* receiver.\n\n\n>\n> > Sure, let's discuss that.  I want to modify the handshake anyway to\n> > include a <len> prefix (like every other message).  This lets us upgrade\n> > the crypto later, by appending a key for a different system.\n> >\n>\n>\nSure. If we end up going with cha cha, I'd like us to adopt the practice of\nencrypting the packet lengths with a separate key (and a new instance of\nchacha20)  similar to openssh's chacha20-poly3015 specification[2]. With\nthis construction, packet-length+packet-payload remain confidential.\n\n\n> > PS.  Are we having fun yet?\n>\n>\nDefinitely! On my Winter Break atm, so getting a chance to catch up on all\nthe fun I missed out on during this past quarter :)\n\n1. https://www.youtube.com/watch?v=xGQ5OOyuaxs\n2.\nhttps://tools.ietf.org/html/draft-josefsson-ssh-chacha20-poly1305-openssh-00\n\n-- Laolu\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151217/94f6241d/attachment.html>"
            },
            {
                "author": "Zooko Wilcox-OHearn",
                "date": "2015-12-17T19:33:45",
                "message_text_only": "On Thu, Dec 17, 2015 at 6:08 PM, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>\n> Currently, in our code, node ID's take two forms: either the hash160\n> (Bitcoin style) of a node's current pub-key or the raw serialized pub-key\n> itself. This is done such that \"nodeID at host\" locators explicitly provide a\n> level of backwards (p2pkh) compatibility for end wallets that are unable to\n> establish a connection in a timely manner.\n\nI'm afraid I don't understand how this backwards-compatibility works,\nso if it is important that I understand it please point me to docs or\nexplain it more.\n\n> Within the Sphinx mix-header, I think we should be safely able to truncate\n> this (the hash160) to 16-bytes. In the case of a collision, the onion-route\n> propagation across the incorrect node will simply fail, as it won't be able\n> to properly derive the shared secret.\n\nDo you mind explaining why you think this is safe? I don't understand\nhow it could be safe, in the case that the attacker knows a private\nkey that maps to the same 128-bit nodeid as a user's private key does.\n\n> Otherwise, we'd be forced to ditch chacha20+poly3015 for\n> AES-CTR+SHA-256-HMAC within Sphinx if serialized pub-keys are used for node\n> ID's in the routing info.\n\nI don't understand why the use of entire public keys instead of\npossibly-truncated hashes of public keys would force a decision about\nwhich cipher and MAC to use.\n\nSincerely,\n\nZooko"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2015-12-18T22:16:22",
                "message_text_only": ">\n>\n> I'm afraid I don't understand how this backwards-compatibility works,\n> so if it is important that I understand it please point me to docs or\n> explain it more.\n>\n\nSo we don't have any docs out (yet). But the general ideas arises from\nconsidering the following scenario: an edge wallet wishes to send funds\nover lightning to 49hwYWYV26Qgym2n1GnpgxBffhKf at roasbeef.computer. Assuming\nwe're not use HORNET for payment related messages, the wallet attempts to\nconnect directly to roasbeef.computer but is unable to. As a fallback, the\nwallet simply decodes the ID from base58, appends the checksum, adds a\nversion byte, and then sends the coins to the resulting address.\n\nEssentially, the idea is to have an easy mechanism for a graceful fallback\nto regular on-chain Bitcoin transactions. But, it's really just a\nhalf-baked idea at this point.\n\n\nDo you mind explaining why you think this is safe? I don't understand\n> how it could be safe, in the case that the attacker knows a private\n> key that maps to the same 128-bit nodeid as a user's private key does.\n>\n\nSure. Also, I'm referring to colliding public-key hashes. So for a moment\nlet's view the network as essentially having two namespaces: global vs\nlocal. It's not a requirement that the local namespace be of lower\ncardinality than the global namespace. However, in the case of 16-byte\nlocal (mix-net) ID, and 32-byte global ID (LN) it is, therefore collisions\nare more frequent. In practice, I think this is safe because in the case a\nglobal node ID conflicts with the local mix-net ID, it doesn't undermine\nthe propagation of an HTLC, since only one node will be able to\nsuccessfully check the MAC, and unwrap the mix-header for the next hop.\n\nHere's an illustration:\n\nSay Alice wishes to send funds to Dave, and her channel sub-graph looks\nlike this:\n                 Estelle\n               /\nAlice -- Bob\n                \\\n                Carol  - Dave\n\nAlice collects the necessary public keys for the route: Bob -> Carol ->\nDave. She then generates the Sphinx mix-header for the route. As a step in\nthe process she generates 16-byte local node ID's for the \"next-hop\" part\nof each node's mix-header. She then sends the mix-header to Bob, the first\nhop. However, unbeknownst to Alice, the 16-byte ID of Estelle's public-key\ncollides with Carol's ID. Bob get's the mix-header, and processes it as\nnormal: checks the MAC, re-blinds group element, and finally peels off\nlayer from nested mix-header. Bob then realizes there's a collision in the\nlocal namespace. So he first tries to send the mix-header to Estelle first.\nEstelle rejects the mix-header because she's unable to check the MAC since\nher derived shared secret isn't the one Alice computed for this hop. Bob\ngets this error message, so he instead forwards it to Carol, who accepts,\nresulting in everything continuing as normal.\n\nTo Estelle it just looks like Bob computed the mix-header incorrectly, or\nsimply forwarded to the wrong node.\n\nI think that's okay (there may be something I'm overlooking)?\n\n\n> > Otherwise, we'd be forced to ditch chacha20+poly3015 for\n> > AES-CTR+SHA-256-HMAC within Sphinx if serialized pub-keys are used for\n> node\n> > ID's in the routing info.\n>\n> I don't understand why the use of entire public keys instead of\n> possibly-truncated hashes of public keys would force a decision about\n> which cipher and MAC to use.\n>\n\nSphinx requires that the mix-net node ID's be the same size as the MAC\nwithin the mix-header. So if node ID's in the mix-net were 32-bytes, then\nwe couldn't use poly3015 to generate tags since its tag size is 16-bytes.\n\n-- Laolu\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151218/1fcd7977/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-12-20T19:31:38",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> Sure. If we end up going with cha cha, I'd like us to adopt the practice of\n> encrypting the packet lengths with a separate key (and a new instance of\n> chacha20)  similar to openssh's chacha20-poly3015 specification[2]. With\n> this construction, packet-length+packet-payload remain confidential.\n\nNice!  While timing and packet boundary measurement will probably be\nquite effective at determining sizes anyway, let's not make it easy.\n\nNote that we have to handle some limited re-transmission, due to nodes\ngoing down.  The protocol assumes nodes store things persistently, but\nof course there can be packet loss / connection issues.\n\nSince our protocol is basically command/response, a node should respond\nto retransmission by retransmitting the response.  (There are a few\ncorner cases where we need to re-xmit more than one, but you get the\nidea).\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "An Alternative Onion-Routing Proposal",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Zooko Wilcox-OHearn",
                "Olaoluwa Osuntokun"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 34747
        }
    },
    {
        "title": "[Lightning-dev] Idea: Using DANE to store node data",
        "thread_messages": [
            {
                "author": "Douglas Roark",
                "date": "2015-12-17T20:13:29",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nHello. I wanted to throw an idea out into the open and see if anybody\nhad any thoughts.\n\nEarlier this year, I worked on an effort to attach payment data to\nDNSSEC via DANE[1]. This included working on an RFC draft[2] that\nexplained the concept. The idea was to use the DNSSEC system as a\ndatabase of sorts that could get trusted payment info out to users. If\nyou wanted to pay Top Quality Widgets for their goods, you could look\nthem up on the DNS system and be reasonably certain that you were\nactually paying them. The setup was designed to allow for all manner\nof payment methods, with ACH and Bitcoin being the first two to be\nsupported.\n\n(Note that the effort eventually fell by the wayside before a\nmuch-improved second RFC draft could get out the door; the first draft\nbarely touches Bitcoin at all. If anybody's interested, I can provide\na basic outline of what was going to be in it, at least on the Bitcoin\nside.)\n\nI'm wondering what others think of this idea, and how it could apply\nto Lightning. The main hangup out the gate would be that the payment\ninfo has to be attached to a domain (e.g., topqualitywidgets.com) that\nsupports the scheme. This would, in all likelihood, mean custom\ndomains would be needed where support for the scheme was explicitly\nincluded. This could be tricky.\n\nDespite that hangup, I think this is an interesting scheme that may be\nworth exploring, perhaps in a modified form. We had the scheme set up\nwhere, on the Bitcoin side, the keys were really flexible and could\nsupport things like per-user payment addresses (i.e., static addresses\nweren't mandatory). I thought it was pretty slick, but hey, I'm biased.\n:)\n\nOne related-but-separate thing to keep in mind is that, if there is\nany sort of ID at host scheme deployed in Lightning, it really ought to\nsupport internationalization. [3] suggests taking the ID and hashing\nit with SHA-256.\n\nAny thoughts? I really like the idea of having some sort of\nquasi-permanent method for storing data without having to rely on a\ncomplicated scheme to find other nodes in the network. It should be\noptional, of course, and should work alongside any mandatory schemes\nto find other users on the network.\n\nThanks.\n\n[1]\nhttps://en.wikipedia.org/wiki/DNS-based_Authentication_of_Named_Entities\n[2] https://tools.ietf.org/html/draft-wiley-paymentassoc-00\n[3] https://tools.ietf.org/html/draft-ietf-dane-smime-09\n\n- -- \n- ---\nDouglas Roark\nCryptocurrency, network security, travel, and art.\nhttps://onename.com/droark\njoroark at vt.edu\nPGP key ID: 26623924\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJWcxdpAAoJEEOBHRomYjkkdDAP/1eCph6RSQJoUAWo4AONWQEp\nnF9C55nRhNdtoMZI52cTN1gU75PS3HNnEfmE0oejZdlt31E+A3V7ibyzOQaHAPzm\nZyVD5/Ke29k+IxPhuk++AMLDJsCbdW/U284NMf3d6yWLZGYCDxaNVEIgs96jHuLN\nc1Ot827Wcl19D18SZjYSXeCXrYkXEZs5MQuGjw1sPOo/z8UdWHBAY9J8y8+bhS48\n4/ZHQMq+XVawrl+p65vIKwhrQvaq0PgtWjHSyG/5lTQEKQMphDppPXQRyyMdbzX8\nJO7Agrjp4MVcwccvsW6oCID+o49l3qeLY+A6sBqcgjCRIgcP3pEbsBb8zCWTNMH/\n/lTkywMisEGctbdO3IKHXGXlmOLMb96jiwY1UJBr7yws0IxPM5F/Lw7PufojrcPQ\nuPe/kQ1RSMQaDDQnxGRiY796g9OImNImhZu0WcyRoR91Mu4stJkOABHdwu2voZA8\nDrJRGJ+BbP0xV8dSGn1dqpnlAMIqKhWfUc67GPoLdgsPd021VbzlctXfLlQe8cWG\nqvLwsgnzvpzPn4MmCPrGyGg+cCOgH0XWBUeFPnPUZIFP5bosTGvXUPrsaJw+qkd+\nfiYxQlm9QuhNtdmhIMAapbfsSoiRgxhPb8PsKb6tkj/blk4QI8m5p2GRVY+2BBOr\nLPHm5WXTCn1XgdCXOZM8\n=3chy\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Idea: Using DANE to store node data",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Douglas Roark"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3421
        }
    },
    {
        "title": "[Lightning-dev] Transaction time",
        "thread_messages": [
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-15T11:33:19",
                "message_text_only": "Assuming a simple case of \"Consumer - Relay - Provider\" (2 hops), how long\nshould it take for provider to receive the payment?\n-- \n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151215/c56bb7f4/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-12-16T00:04:00",
                "message_text_only": "Denis Gorbachev <denis.d.gorbachev at gmail.com> writes:\n> Assuming a simple case of \"Consumer - Relay - Provider\" (2 hops), how long\n> should it take for provider to receive the payment?\n\nAssuming established channels already (assuming CPU is instant, so we're\njust paying for network latency):\n\nConsumer offers Relay a contract:\n        C -> R: update_add_htlc\n        R -> C: update_accept\n        C -> R: update_signature\n        R -> C: update_complete*\n\nRelay offers Provider a contract:\n        R -> P: update_add_htlc\n        P -> R: update_accept\n        R -> P: update_signature\n        P -> R: update_complete*\n\nProvider closes contract with relay:\n        P -> R: update_fulfill_htlc\n        R -> P: update_accept\n        P -> R: update_signature\n        R -> P: update_complete*\n\nRelay closes contract with Client:\n        R -> C: update_fulfill_htlc\n        C -> R: update_accept\n        R -> C: update_signature\n        C -> R: update_complete*\n\nYou don't need to wait for the update_complete packets to arrive, so\nthat works out to 3 RTTs per hop.  You might expect up to 10 hops in a\nlarge lightning network, so 30 RTTs.\n\nI'm in Australia, and my bitcoin node latency averages 330ms (ouch!).\nSo that would be 10 seconds.\n\nHope that helps!\nRusty."
            },
            {
                "author": "Mark Friedenbach",
                "date": "2015-12-16T03:48:59",
                "message_text_only": "It should be noted that this estimation is biasing towards\nworst-case-latency/best-case-decentralization. Even though we will make\nconscious efforts to keep lightning networks as decentralized as possible,\nit is still the case that we will see some centralization pressure due to\nthe desire for low latency transactions. I expect that the average user's\nexperience of a 10-hop payment would be on the order of 1-2 seconds, with\nthe inner-hops being between Tier-1 datacenter nodes primarily with payment\nchannels chosen based on network proximity. A 'near' payment to someone\ncloser to them would be under a second. But it is very good to know that a\nnetwork consisting entirely of last-mile endpoints geographically\ndistributed around the world would only have a worst-case transaction time\nof only about 10s or so. Even that is doable for PoS.\n\nOn Wed, Dec 16, 2015 at 8:04 AM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n> Denis Gorbachev <denis.d.gorbachev at gmail.com> writes:\n> > Assuming a simple case of \"Consumer - Relay - Provider\" (2 hops), how\n> long\n> > should it take for provider to receive the payment?\n>\n> Assuming established channels already (assuming CPU is instant, so we're\n> just paying for network latency):\n>\n> Consumer offers Relay a contract:\n>         C -> R: update_add_htlc\n>         R -> C: update_accept\n>         C -> R: update_signature\n>         R -> C: update_complete*\n>\n> Relay offers Provider a contract:\n>         R -> P: update_add_htlc\n>         P -> R: update_accept\n>         R -> P: update_signature\n>         P -> R: update_complete*\n>\n> Provider closes contract with relay:\n>         P -> R: update_fulfill_htlc\n>         R -> P: update_accept\n>         P -> R: update_signature\n>         R -> P: update_complete*\n>\n> Relay closes contract with Client:\n>         R -> C: update_fulfill_htlc\n>         C -> R: update_accept\n>         R -> C: update_signature\n>         C -> R: update_complete*\n>\n> You don't need to wait for the update_complete packets to arrive, so\n> that works out to 3 RTTs per hop.  You might expect up to 10 hops in a\n> large lightning network, so 30 RTTs.\n>\n> I'm in Australia, and my bitcoin node latency averages 330ms (ouch!).\n> So that would be 10 seconds.\n>\n> Hope that helps!\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151216/e4decfa4/attachment.html>"
            },
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-16T05:01:37",
                "message_text_only": "Rusty, Mark - thanks for the explanations!\n\nOn Wed, Dec 16, 2015 at 10:49 AM Mark Friedenbach <mark at friedenbach.org>\nwrote:\n\n> It should be noted that this estimation is biasing towards\n> worst-case-latency/best-case-decentralization. Even though we will make\n> conscious efforts to keep lightning networks as decentralized as possible,\n> it is still the case that we will see some centralization pressure due to\n> the desire for low latency transactions. I expect that the average user's\n> experience of a 10-hop payment would be on the order of 1-2 seconds, with\n> the inner-hops being between Tier-1 datacenter nodes primarily with payment\n> channels chosen based on network proximity. A 'near' payment to someone\n> closer to them would be under a second. But it is very good to know that a\n> network consisting entirely of last-mile endpoints geographically\n> distributed around the world would only have a worst-case transaction time\n> of only about 10s or so. Even that is doable for PoS.\n>\n> On Wed, Dec 16, 2015 at 8:04 AM, Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n>\n>> Denis Gorbachev <denis.d.gorbachev at gmail.com> writes:\n>> > Assuming a simple case of \"Consumer - Relay - Provider\" (2 hops), how\n>> long\n>> > should it take for provider to receive the payment?\n>>\n>> Assuming established channels already (assuming CPU is instant, so we're\n>> just paying for network latency):\n>>\n>> Consumer offers Relay a contract:\n>>         C -> R: update_add_htlc\n>>         R -> C: update_accept\n>>         C -> R: update_signature\n>>         R -> C: update_complete*\n>>\n>> Relay offers Provider a contract:\n>>         R -> P: update_add_htlc\n>>         P -> R: update_accept\n>>         R -> P: update_signature\n>>         P -> R: update_complete*\n>>\n>> Provider closes contract with relay:\n>>         P -> R: update_fulfill_htlc\n>>         R -> P: update_accept\n>>         P -> R: update_signature\n>>         R -> P: update_complete*\n>>\n>> Relay closes contract with Client:\n>>         R -> C: update_fulfill_htlc\n>>         C -> R: update_accept\n>>         R -> C: update_signature\n>>         C -> R: update_complete*\n>>\n>> You don't need to wait for the update_complete packets to arrive, so\n>> that works out to 3 RTTs per hop.  You might expect up to 10 hops in a\n>> large lightning network, so 30 RTTs.\n>>\n>> I'm in Australia, and my bitcoin node latency averages 330ms (ouch!).\n>> So that would be 10 seconds.\n>>\n>> Hope that helps!\n>> Rusty.\n>>\n> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> --\n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151216/b011de47/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Transaction time",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Mark Friedenbach",
                "Denis Gorbachev"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7177
        }
    },
    {
        "title": "[Lightning-dev] daemon/p2p protocol",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-12-16T06:30:23",
                "message_text_only": "On Sat, Oct 17, 2015 at 06:53:55AM +1000, Anthony Towns wrote:\n> # lightning public keys...\n> I think there are (at least) three uses for public key crypto in lightning:\n>   1) routing keys -- used for constructing the onion.\n>   2) anchor keys -- used for spending the anchor transaction for a\n>      channel and thus signing commitment transactions; only needs to be\n>      known by the counterparty you're constructing a channel with; can\n>      be different for every channel.\n\nI think you actually want separate keys for spending the anchor and\nspending the commitments.\n\nThe anchor keys get used to sign every commitment, so it's probably pretty\nimportant to make sure the secure random signing parameters chosen for\nthose signatures actually are secure. I guess using an HMAC scheme like\nin RFC 6979 based on the anchor private key and a counter/nonce from the\ncommitment id probably works? secp256k1 seems to have a function for that.\n\nThe commitment keys might never actually be used if the channel is\nclosed cooperatively, which is kindof neat. Arguably it could be a\nwin for privacy to have a collection of these, so that if a channel is\nunilaterally closed, you can't tell which transactions went which way\njust by looking at the public keys. You wouldn't want to have too many,\nthough, because working out which commitment key you used for a particular\ntransaction might make enforcement of revoked commitments hard.\n\nThe commitment (public) keys need to be known to both parties to\nconstruct/validate the p2sh addresses of course.\n\n>   3) p2p keys -- used for establishing a shared secret when talking to a\n>      node, to avoid your p2p communications being available to someone\n>      else (either a passive observer or a MITM). could be different for\n>      every connection, or could just have one the lightning instance.\n\nCheers,\naj (apologies if this was already obvious)"
            }
        ],
        "thread_summary": {
            "title": "daemon/p2p protocol",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1891
        }
    },
    {
        "title": "[Lightning-dev] Lightning hubs and pooled reserves",
        "thread_messages": [
            {
                "author": "John Newbery",
                "date": "2015-12-23T11:41:02",
                "message_text_only": "Hi all,\n\nI've created a gist describing this idea here:\nhttps://gist.github.com/jonnynewbs/a8ac4d7d27cb74c5b486 with images.\n\nI recently watched Joseph Poon's presentation at the scaling bitcoin HK\nconference. He argued that there's a natural tendency *away* from hubs and\ncentralization in lightning network, because a hub needs to hold bitcoin in\nreserve for each payment channel:\n\nimage 1:\nhttps://gist.githubusercontent.com/jonnynewbs/a8ac4d7d27cb74c5b486/raw/839cf9152630ee8c5596b55e206b6f7f42121c61/zHub1.jpg\n\nIn this example Hector has tied up 40 bitcoin in order to open channels\nwith 4 nodes. He needs to place his bitcoin in those channels in order to\nhave enough liquidity to route payments through the channels. If all the\nbitcoin in the channel had been fronted by the nodes, he wouldn't be able\nto route payments.\n\nIn this example Alice tries to pay Bob through Hector, but Hector's channel\nto Bob is depleted on Hector's side so he can't pay:\n\nimage 2:\nhttps://gist.githubusercontent.com/jonnynewbs/a8ac4d7d27cb74c5b486/raw/839cf9152630ee8c5596b55e206b6f7f42121c61/zHub2.jpg\n\nThe velocity of money through each of those channels is going to be low, so\nHector's profit opportunity to charge transfer fees on those channels is\nlow compared to the time that he's tying up his assets.\n\nI started thinking about why it was that Hector would actually need to tie\nup those funds. A properly-functioning hub should always have a net balance\nof zero - all outflows from the hub are matched by inflows from another\nnode, so if the hub is working properly, it should always be solvent. Why\nthen does it necessarily need to hold a reserve for each node it connects\nto?\n\nImagine someone wanted to create a hub in lightning *without* tying up\nfunds in lots of channels. One way he might start thinking about it:\n\n1. Create some metatoken/coloured coin on top of bitcoin. Lets call it\nHectorcoin.\n2. Open channels to different nodes, where the node provides the bitcoin\nfor the channel, and the hub provides Hectorcoins in the other direction.\nThe hub would only need to provide a negligable amount of actual bitcoin\nvalue with Hectorcoins encoded on top of that small input.\n3. If the channel gets closed and the node is net positive (ie in the\nchannel the bitcoin they initially provided plus some Hectorcoin), the node\ncan 'sell' the Hectorcoin back to the hub for bitcoin.\n\nHector's network would initially look like this. Bitcoin are in black,\nHectorcoin are in bold green:\n\nimage 3:\nhttps://gist.githubusercontent.com/jonnynewbs/a8ac4d7d27cb74c5b486/raw/839cf9152630ee8c5596b55e206b6f7f42121c61/zHub3.jpg\n\nTransactions flow through the hub, and eventually Alice is 10 'bitcoin' up.\nHector hasn't sent her 10 real bitcoin through the channel, but 10\nHectorcoin. The network now might look like this:\n\nimage 4:\nhttps://gist.githubusercontent.com/jonnynewbs/a8ac4d7d27cb74c5b486/raw/839cf9152630ee8c5596b55e206b6f7f42121c61/zHub4.jpg\n\nNote that Hector's balace of (Bitcoin + Hectorcoin) always remains 40.\n\nAlice now wants to cash out her channel. She closes the channel as normal,\nand then presents the Hectorcoin to Hector in exchange for actual bitcoin.\nAt this point either:\n\n- Hector is holding enough bitcoin in reserve to pay out to Alice; or\n- Hector doesn't hold enough bitcoin in reserve (In this scenario Hector\nhas a temporary *liquidity* issue, but remains *solvent*). He therefore\nneeds to close down his channels to Dan and Claire to free up his bitcoin\ntied up in those channels.\n\nThis basic example requires counterparty trust in Hector. That's because\nthere's no way to prove that he actually holds enough bitcoin in his\nreserves/channels to pay out in exchange for Hectorcoin *unless* those\ncoins are provable locked up somewhere (eg a multisig), which defeats the\nwhole purpose - he's trying to avoid tying up value. However, many people\nmight consider the efficiency and connectedness of dealing with a hub to be\na worthwhile trade-off on balance.\n\nHector might think about improving his hub by:\n\n- somehow providing a proof that his net position is zero and so he's\nprovably solvent. That would eliminate the risk of a hub going rogue,\nextracting coins from the network and becoming insolvent\n- Having some way for Alice to automatically exchange Hectorcoin for that\nvalue without asking Hector's permission.\n\nBoth of those things feel like they're possible, but perhaps someone\nsmarter than I am can comment on whether they actually are.\n\nI'm not suggesting that this is the way we want to go, but thought it was\ninteresting enough to share. Interested to hear people's thoughts.\n\nJohn\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151223/2f9e7486/attachment.html>"
            },
            {
                "author": "Denis Gorbachev",
                "date": "2015-12-24T09:16:24",
                "message_text_only": "Hi John,\n\nYou've brought up a *very* important topic.\n\nIf we could lower the capital requirement, we'd lower the barrier for\npeople wishing to run a Lightning Network node.\n\nHere are some thoughts:\n\n   - The trust-based system you're proposing looks like a\n   fractional-reserve banking system.\n   - Such fractional-reserve hubs will provide lower transaction fees\n   (because of lower capital requirements) \u2014 so the idea is worth pursuing.\n   - I have the same feeling that it should be possible to design a\n   proof-of-solvency.\n\nIf we could design a proof-of-solvency, we could replace the existing\nfractional-reserve system. This is kind of a big deal.\n\nSo let's connect on Skype (I'll send a personal email). Anybody wants to\njoin the discussion?\n\nP.S. Your writing style is very accessible - keep it up.\n\n-- \n@DenGorbachev <https://twitter.com/DenGorbachev>\n-- \n@DenGorbachev <https://twitter.com/DenGorbachev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151224/9173c407/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning hubs and pooled reserves",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Denis Gorbachev",
                "John Newbery"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5897
        }
    },
    {
        "title": "[Lightning-dev] Route finding",
        "thread_messages": [
            {
                "author": "Martijn Meijering",
                "date": "2015-12-28T21:03:46",
                "message_text_only": "Is there a summary somewhere of the latest ideas on how nodes should find\nroutes between themselves or between themselves and beacon nodes? I'm\nhaving a hard time visualising how a node would find routes to beacons\nwithout resorting to a floodfill search, which doesn't look as if it would\nscale. Thanks!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151228/c6d57c1e/attachment.html>"
            },
            {
                "author": "Martijn Meijering",
                "date": "2015-12-29T19:11:57",
                "message_text_only": "Never mind, the idea is probably for neighbours of beacon nodes to discover\none of their neighbours has become a beacon and to propagate that\ninformation to their other neighbours, which should not take too much\ntraffic.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151229/d3ad0d77/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Route finding",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Martijn Meijering"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 894
        }
    }
]