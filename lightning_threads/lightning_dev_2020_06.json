[
    {
        "title": "[Lightning-dev] Griefing-Penalty: A proposal for mitigating Griefing Attack",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-01T02:09:35",
                "message_text_only": "Good morning Subhra,\n\n>     There may be other issues as well with the overall setup, please wait, I am considering as well what would happen if we correctly establish the contracts from S to R.\n\nUnfortunately the Mitigating Reverse-Griefing contract reintroduces griefing.\n\nFirst, let us simplify the setup to S -> F -> R.\n\nIn the griefing attack of today the setup would be:\n\n* S->F has the contract, funded by S only:\n  * If F can reveal x such that h = h(x) for a known h, F can claim the fund.\n  * After 2 days, S can recover the fund.\n* F->R has the contract, funded by F only:\n  * If R can reveal x such that h = h(x) for a known h, R can claim the fund.\n  * After 1 day, F can recover the fund.\n\nThen, 1 Planck interval before the 1-day limit, R cancels the HTLC by doing some form of `update_fail_htlc` to F.\nThis causes F to not earn any funds, even though it had its funds locked for 1 day minus 1 Planck interval; thus in practice, R can lock the funds of F for a little less than the time limit imposed.\n\n\n\nWith the Mitigating Reverse Griefing technique, the setup would be:\n\n* S->F has the contract, funded by S and F:\n  * If F can reveal x such that h = h(x) for a known h, F can claim the fund.\n  * If F can reveal r such that y = h(r) for a known y, S and F can recover their original contributions to the fund.\n  * After 2 days, S can claim the fund.\n* F->R has the contract, funded by F and R:\n  * If R can reveal x such that h = h(x) for a known h, R can claim the fund.\n  * If R can reveal r such that y = h(r) for a known y, F and R can recover their original contributions to the fund.\n  * After 1 day, F can claim the fund.\n\nThen, 1 Planck interval before the 1-day limit, R uses the second clause to cancel the entire payment.\n\nThis is exactly the same result as with the current griefing attack: F is induced to lock its funds for 1 day minus 1 Planck interval, but is never compensated for it.\nIt is immaterial whether the mechanism used is `update_fail_htlc` or some other mechanism.\n\n\nSo not only does Mitigating Reverse-Griefing just replace reverse-griefing with the attack described in my previous post, which I am now calling backflip-reverse-griefing (because calling it \"reverse-reverse-griefing\" would be ***SO BORING AND OBVIOUS***), it also returns the original griefing attack.\n\n\nI think it is a principle of protocol design that, in general, protecting against one attack could open you up to the opposite of that attack.\n\n\nIt is helpful to remember that the original griefing attack is basically a withholding attack, wherein a participant does not respond after a particular step in the protocol.\nBy adding more steps, you simply add more places where a participant can stop responding after some step in the protocol, and thus add even more attack surface.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Subhra Mazumdar",
                "date": "2020-06-05T07:34:01",
                "message_text_only": "Hi ZmnSCPxj,\n       Thanks for your invaluable feedback. The attack stated for the\nconstruction\nhttps://gist.github.com/subhramazumdar/cf7b043a73db136f6a23091d20e51751\nholds true for the path S->A->B->C->R. A will end up paying the money\nwithout receiving anything from S.\n\n>Initial contract establishment has to be done from S to R always, not R to\nS.\n\nMulti-stage contracts can be done from R to S (arguably the simple\nresolution of HTLC chains is \"really' the second stage) for after the\ninitial establishment, but initial establishment always has to be from S to\nR.\nIf the initial contract establishment starts from S, we can still face\nreverse-griefing - if an intermediate node, say C, refuses to sign the\ncontract then again B can be reverse-griefed by A. It will deny canceling\nthe contract with B and wait for the locktime to expire, thereby\nvictimizing B.\n\n\nWhat might possibly work here is that the parties must first exchange\nsignatures for the error hash in order to unlock collateral and avoid\nreverse-griefing and only after that, exchange signatures for payment hash.\n\nAgain if S starts the locking phase by supplying the error hash in one\nround followed by exchanging signature for payment hash in the next round,\nit might supply a wrong error hash so that R is not able to supply proof of\ncancelation. Even if S has not tampered with the error hash value, an\nintermediate may refuse to forward the contract with terms of error hash.\nAgain we are stuck with the same problem because R possesses the witness to\nthe error hash. If the contract is not forwarded to R, the preimage will\nnot be revealed.\n\n\nGiven the terms of the contract is (quoting for R and C, for the rest of\nthe channel it is the same except the change in the locktime, penalty, and\npayment locked by each party): R and C establish the contract for 7 msat,\nusing 1 msat from C and 6 msat from R:\n\n  * R shows x such that h = h(x) is true, with R getting 7 msat.\n\n  * R shows r such that y = h(r) is true, with C getting 1 msat and R\ngetting 6 msat.\n\n  * After one day, C gets 7 msat.\n\nWhat we think might work for our case is that we let the exchange of\nsignature for lock phase happen over two rounds - R initiating the first\nround involving error hash and S initiating the second round involving\npayment hash, as follows:\n\nInitially, let R exchange signatures with C over the following terms of the\ncontract.\n\n\u201c  * (Terms of Cancelation) R shows r such that y = h(r) is true, with C\ngetting 1 msat and R getting 6 msat.\n\n  * After one day, C gets 7 msat.\n\nC exchange signature with B and this continues till A has established the\ncontract with S. This allows an honest intermediary in the release phase to\nunlock the money if R has triggered cancelation of the contracts.\n\nAfter S has signed the cancelation contract with A, the second round is\ninitiated for forwarding the payment. S exchange signatures with A for the\npayment hash. This will avoid the problem mentioned in the previous\nconstruction whereby an intermediate party ends up paying its successor\nwithout being remunerated by a malicious payer. The rest of the\nintermediate parties does the same. Finally, C will exchange signature with\nR over the following terms:\n\n  * (Terms of Payment) R shows x such that h = h(x) is true, with R getting\n7 msat.\n\nR will wait for a constant amount of time in order to receive incoming\ncontract request from C. After that, given the condition, it will either\nrelease the preimage of error hash or payment hash. If R griefs, it will\nlose funds in the form of penalty.\n\nRegarding the second attack:\n\n>Then, 1 Planck interval before the 1-day limit, R uses the second clause\nto cancel the entire payment.\n\nThis is exactly the same result as with the current griefing attack: F is\ninduced to lock its funds for 1 day minus 1 Planck interval, but is never\ncompensated for it.\n\nIt is immaterial whether the mechanism used is `update_fail_htlc` or some\nother mechanism.\n\nWe had mentioned in the paper <https://arxiv.org/abs/2005.09327> under\nDiscussions (Section 6.3) that we do not handle attacks concerning\nsoft-griefing, i.e., if a party withholds the preimage for a long time but\nreleases just before the expiration of locktime. We think with the current\nset of instructions supported in Bitcoin, it is hard to settle\nsoft-griefing related disputes, accounting penalty for each unit of elapsed\ntime. In case of soft-griefing, we neither impose the griefing penalty, nor\nis there a chance to reverse-grief.\n\nOn Mon, Jun 1, 2020 at 7:39 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Subhra,\n>\n> >     There may be other issues as well with the overall setup, please\n> wait, I am considering as well what would happen if we correctly establish\n> the contracts from S to R.\n>\n> Unfortunately the Mitigating Reverse-Griefing contract reintroduces\n> griefing.\n>\n> First, let us simplify the setup to S -> F -> R.\n>\n> In the griefing attack of today the setup would be:\n>\n> * S->F has the contract, funded by S only:\n>   * If F can reveal x such that h = h(x) for a known h, F can claim the\n> fund.\n>   * After 2 days, S can recover the fund.\n> * F->R has the contract, funded by F only:\n>   * If R can reveal x such that h = h(x) for a known h, R can claim the\n> fund.\n>   * After 1 day, F can recover the fund.\n>\n> Then, 1 Planck interval before the 1-day limit, R cancels the HTLC by\n> doing some form of `update_fail_htlc` to F.\n> This causes F to not earn any funds, even though it had its funds locked\n> for 1 day minus 1 Planck interval; thus in practice, R can lock the funds\n> of F for a little less than the time limit imposed.\n>\n>\n>\n> With the Mitigating Reverse Griefing technique, the setup would be:\n>\n> * S->F has the contract, funded by S and F:\n>   * If F can reveal x such that h = h(x) for a known h, F can claim the\n> fund.\n>   * If F can reveal r such that y = h(r) for a known y, S and F can\n> recover their original contributions to the fund.\n>   * After 2 days, S can claim the fund.\n> * F->R has the contract, funded by F and R:\n>   * If R can reveal x such that h = h(x) for a known h, R can claim the\n> fund.\n>   * If R can reveal r such that y = h(r) for a known y, F and R can\n> recover their original contributions to the fund.\n>   * After 1 day, F can claim the fund.\n>\n> Then, 1 Planck interval before the 1-day limit, R uses the second clause\n> to cancel the entire payment.\n>\n> This is exactly the same result as with the current griefing attack: F is\n> induced to lock its funds for 1 day minus 1 Planck interval, but is never\n> compensated for it.\n> It is immaterial whether the mechanism used is `update_fail_htlc` or some\n> other mechanism.\n>\n>\n> So not only does Mitigating Reverse-Griefing just replace reverse-griefing\n> with the attack described in my previous post, which I am now calling\n> backflip-reverse-griefing (because calling it \"reverse-reverse-griefing\"\n> would be ***SO BORING AND OBVIOUS***), it also returns the original\n> griefing attack.\n>\n>\n> I think it is a principle of protocol design that, in general, protecting\n> against one attack could open you up to the opposite of that attack.\n>\n>\n> It is helpful to remember that the original griefing attack is basically a\n> withholding attack, wherein a participant does not respond after a\n> particular step in the protocol.\n> By adding more steps, you simply add more places where a participant can\n> stop responding after some step in the protocol, and thus add even more\n> attack surface.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200605/213e7821/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-05T11:23:12",
                "message_text_only": "Good morning Subhra,\n\n> We had mentioned in the paper under Discussions (Section 6.3) that we do not handle attacks concerning soft-griefing, i.e., if a party withholds the preimage for a long time but releases just before the expiration of locktime. We think with the current set of instructions supported in Bitcoin, it is hard to settle soft-griefing related disputes, accounting penalty for each unit of elapsed time. In case of soft-griefing, we neither impose the griefing penalty, nor is there a chance to reverse-grief.\n\nIn fact, what you call the \"soft-grief\" *is* the griefing attack you expect to see on the network.\n\nIf the receiver R let the time elapse, then the forwarding node just before the receiver R will close the channel.\nClosing a channel and later re-establishing it (in order to mount the attack again, remember, this is an attempt to DoS your competitors, and is thus best done continuously) is expensive.\n\nThus all griefing attacks will, in practice, involve what you call \"soft\" griefing, i.e. the payment is cancelled just before the timeout arrives, before the last forwarding node closes the channel.\nBut it is precisely this \"soft\" griefing which is the problem.\n\nSo:\n\n* It is immaterial that you punish R if it lets the time elapse --- channel close is sufficient punishment.\n* What is material is that if R cancels the payment *just before* the lock time, it should be punished --- there is currently no way to do this.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Griefing-Penalty: A proposal for mitigating Griefing Attack",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Subhra Mazumdar",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12041
        }
    },
    {
        "title": "[Lightning-dev] Disclosure of a fee blackmail attack that can make a victim loose almost all funds of a non Wumbo channel and potential fixes",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2020-06-17T10:29:42",
                "message_text_only": "Hey everyone and of course good morning ZmnSCPxj (:\n\nabout 11 months ago I discovered a potential blackmail attack with HTLCs\nafter answering this question on stack exchange (c.f\nhttps://bitcoin.stackexchange.com/questions/89232/why-is-my-spendable-msat-much-lower-than-msatoshi-to-us/89235#89235).\nThis attack is similar to the one that was possible with tx malleability on\nthe funding transaction without the segwit upgrade (c.f.\nhttps://commons.wikimedia.org/w/index.php?title=File:Introduction_to_the_Lightning_Network_Protocol_and_the_Basics_of_Lightning_Technology_(BOLT_aka_Lightning-rfc).pdf&page=126).\nMeaning an attacker can force a victim to lose money and use this fact to\nblackmail the victim, to potentially gain / steal some of the lost funds.\n\nTL;DR:\n=====\n* Depending on the circumstances this attack allows an attacker to make\nchannel partners lose a substantial amount of BTC without substantial costs\nfor the attacker.\n* Depending on the exact circumstances this could be for example ~0.15 BTC.\nIn particular it demonstrates why opening a channel is not an entirely\ntrustless activity.\n* The attacker will reliably only be able to force the victim to lose this\namount of Bitcoin.\n* It is not clear how in practice the attacker could gain this amount or\nparts of it as this would involve not only game theory but also rather\nquick communication between attacker and victim and customized Lightning\nnodes which at least for the victim would be unlikely to exist.\n* None of the suggested fixes seems to be satisfying though the current\nsolution of lowering the maximum amount of HTLCs that can concurrently be\nin flight seems to be a reasonable start for now.\n\n\nTimeline on Disclosure\n=================\nI have disclosed this attack on Sunday July 21st 2019 to Fabrice Drouin\n(and shortly after to Christian Decker) in a phone call who in turn has\ndiscussed it with people from the other implementations. From his feedback\nI understood that people working on implementations have been more or less\naware of the possibility of this attack. Fabrice also mentioned that he\nbelieved implementations currently try to mitigate this by setting low\nlimits of allowed / accepted HTLCs in flight. However at that time this was\nonly true for e-clair. It is now also true for c-lightning and as far as I\nknow still not true for lnd. Fabrice said that the people he talked to have\nsuggested that I should eventually describe the attack in public to raise\nawareness (also from the group of node operators) for the problems related\nto this attack. He also suggested that - if I wanted to - I should update\nthe rfc with recommendations  and warnings. While I already have in mind\nhow to change the rfc I wanted to start the discussion first. Maybe some\npeople find better fixes than just a warning that I have in mind. So far I\ndidn't do anything because I wanted to also give lnd the chance to handle\nthe problem.\n\nThere are two reasons I disclose this attack today:\n1.) I think almost 1 year is enough time to do something about it. The only\nimplementation that afaik didn't yet is lnd (see below) but I got roasbeefs\nok last week to go ahead and publish the attack anyway so that we can have\na broader discussion on mitigation strategies.\n2.) The attack seems actually very similar to the one described in the\n\"Flood & Loot: A Systemic Attack On The Lightning Network\" - paper which\ncame out 2 days ago (c.f.: https://arxiv.org/abs/2006.08513 ). I believe\nany person reading that paper will understand the possibility of the attack\nthat I describe anyway so I believe it is now more or less public anyway\nand thus time for an open / public discussion.\n\nThe main difference between the two attacks (if I understand this novel\npaper correctly) is: In the \"flood and loot\"-attack one tries to steal the\nHTLC output of the victims. Where in the \"flood and blackmail\"-attack that\nI describe I try to to force the victim to lose almost all its funds due to\nhigh on chain fees (Which I could use to blackmail the victim)\n\nDescription of the attack\n===================\nLet us assume the victim has funded a channel with an attacker meaning it\nwill have to pay the fees for the commitment transaction in case of a force\nclose.\n\nDuring a fee spike (let us assume fee estimators suggest 150 sat / byte)\nthe attacker spams this channel with the maximum possible amount of HTLCs\nthat the protocol allows. The HTLCs can be of a small value but need to be\nbigger than the dust limit so that additional outputs are actually added to\nthe commitment transaction which makes it quite large in Bytes. According\nto the BOLTs these are 483 additional outputs to the commitment\ntransaction.\nThe direction of HTLCs are chosen so that the amount is taken from the\n`to_remote` output of the attacker (obviously on the victims side it will\nbe the `to_local` output) For the actual attack it does not matter in which\ndirection the HTLCs are spammed but economically the direction I propose\nmakes even more sense for the attacker and can be achieved with circular\nonions.\n\nThe attacked channel partner will happily - according to the protocol - use\na higher fee than the current fee rate. I quote from BOLT 02 which suggests\na buffer of a factor of 5\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee:\n\n\n> The node responsible for paying the Bitcoin fee [...] SHOULD send\nupdate_fee to ensure the current fee rate is sufficient (by a significant\nmargin) for timely processing of the commitment transaction. [...] Given\nthe variance in fees, and the fact that the transaction may be spent in the\nfuture, it's a good idea for the fee payer to keep a good margin (say 5x\nthe expected fee requirement); but, due to differing methods of fee\nestimation, an exact value is not specified.\n\nThis overpayment of fees will result in 750 sat / byte for this fee spike\nscenario. This is by the way not completely unrealistic [I recently opened\na channel with 2.56 sat / byte (c.f.:\nhttps://www.smartbit.com.au/tx/c0ac6cfe15e0d0c921362ab9fad998a8a8e16cd8d9d4159487dd69141ea2b9b0)\nand the channel was force closed a couple minutes later due to an\nimplementation bug resulting in fees of 101.17 sat / byte (c.f.:\nhttps://www.smartbit.com.au/tx/e32135315ec147bb27f771b2e15c7178ea573afd16cd4970bf814c9b18bc46e3\n)\n\nAs far as I understand the appendix of BOLT 03 offered HTLCs are 43 Byte in\nsize (c.f.:\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#appendix-a-expected-weights)\nresulting in the following additional fees for the spammed commitment\ntransaction:\n\nfee (for 483 htlcs)  = 483 * 43 byte * 750 sat / byte = 15576750 sat =\n0.1557675 BTC\n\nAdditionally the victim will also have to swipe all offered HTLCs (which\nwill be additional costs but could be done once the fees came down) so we\nneglect them.\n\nOnce all HTLCs are set up the attacker will stop signing commitment\ntransactions. In the beginning this is not suspicious as the HTLCs will\ntake some time to settle anyway. But also when fees go down and the victim\nwho funded the channel wants to update the fees the attacker will just not\nbe responsive. Eventually the victim will dare to force close the channel\nwith all those expensive HTLCs.\n\nKnowing that this will happen and that the victim has to spend those funds\n(publishing old state obviously does not work!) the attacker has a time\nwindow to blackmail the victim outside of the lightning network protocol:\n\"Either you will pay those 0.1557675 BTC of fees or we will collaboratively\nclose the channel but that will cost you part of the amount you lost.\" Game\ntheory suggests that the attacker will be able to claim the major fraction\nof the BTC (c.f. https://en.wikipedia.org/wiki/Ultimatum_game that are\nfrozen in tx fees as the victim effectively already has lost that money and\ncan only gain something back.\n\n\nThoughts\n=======\nYou might say that the blackmail part of this attack is unrealistic as the\nblackmailing person will not have enough time to successfully do the\nblackmail as the channel that is not operational will fail.\n\n1.) The only thing that lightning nodes might do is a fee update as the\nhtlcs stuffed the channel so I believe there is actually some time to\ncontact the victim.\n2.) What if the attacker is a mining pool who is just interested in high\nfees who does not even need to do the blackmailing stuff but will just\nforce close the channel once the htlcs are set up?\n3.) The attacker might not even be interested in blackmailing the victim.\nThe attacker could just be interested in harming the victim. Though it\nmight certainly be a challenge to target a specific victim and trick it\ninto opening a channel with an attacker.\n\nAlso you might say that an attacker needs many incoming channels to execute\nthis attack. This can be achieved by gaming the autopilot. an attacker can\nstart by creating many channels making him a highly likely channel partner\nfor autopilot users (who will also fund the channel). Such a highly\nconnected node might also be interesting for non autopilot users.\n\nImplementations\n============\n\nI looked at the code myself. I hope I do oversee things but to me it looks\nlike only eclaire was somehow mitigating this attack from being exploited.\n(by a default config of 30 accepted htlcs which will protect the average\nuser and is much lower than the 483) and c-lightning has merged a patch\nfrom me which I provided after I disclosed the attack:\n\n## clightning:\n\nc-lightning did not by default set a hard cap on htlcs before version 0.7.2\nbut then merged my patch\nhttps://github.com/ElementsProject/lightning/pull/2858 which tried to\nresemble the eclair defaults\n\n## eclaire:\n\nthe max accepted htlc value per channel is set as a constant to 483 which\nfollows the recommendation of the BOLTs:\nhttps://github.com/ACINQ/eclair/blob/e62adf2deae213d2cd0f2a6874227dcfc57880ae/eclair-core/src/main/scala/fr/acinq/eclair/channel/Channel.scala#L52\n\nThe value is tested against at:\nhttps://github.com/ACINQ/eclair/blob/f724efaa76b256048de18f706e9cb58ecbebd6aa/eclair-core/src/main/scala/fr/acinq/eclair/channel/Helpers.scala#L99\n\nand:\nhttps://github.com/ACINQ/eclair/blob/f724efaa76b256048de18f706e9cb58ecbebd6aa/eclair-core/src/main/scala/fr/acinq/eclair/channel/Helpers.scala#L132\n\nand:\nhttps://github.com/ACINQ/eclair/blob/93d9369f900766171f2ddf579e8b12e28d8f0d25/eclair-core/src/main/scala/fr/acinq/eclair/channel/Commitments.scala#L154\n\nHowever the default config file specifies a maximum amount of 30 accepted\nhtlcs at:\nhttps://github.com/ACINQ/eclair/blob/9afb26e09c69dd5d6a14732baf5dcdf2b7a9142b/eclair-core/src/main/resources/reference.conf#L62\n\n\n## lnd\nIt seems like lnd did not and last time I checked (maybe I oversaw\nsomething) does not set a hard cap on htlcs by default. The way how I\nunderstand the code they allow up to 483 htlcs by default:\n\nThe test when adding an htlc if it is beyond the maximum accepted values is\nhere:\nhttps://github.com/lightningnetwork/lnd/blob/970d7604071baae227db42d4665ef9d1b56988e8/lnwallet/channel.go#L3795\n\nthe default configuration seems to be here (and in the most recent commit\nthe line still exists):\nhttps://github.com/lightningnetwork/lnd/blob/8b04cfbf12f460853e8c55611cd1bba21b1510ef/input/size.go#L187\n\nthe software will accept up to 483 htlcs according to this line:\nhttps://github.com/lightningnetwork/lnd/blob/111cbeaa990cba78563d6cc8c19b152e2d3042f6/lnwallet/reservation.go#L314\n\nI could not find any spec lower than that in the suggested sample config\nat:\nhttps://github.com/lightningnetwork/lnd/blob/master/sample-lnd.conf\n\n\nIdeas for Fixes\n===========\n\nI am completely unhappy with each of the following ideas. I hope you will\ncome up with smarter solutions. I believe the solution is not obvious. Thus\nI thought it makes sense in the brainstorm phase to even post some ideas\nwith obvious drawbacks.\n\n1. The current solution is to just not use up the max value of\nhtlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n2. Probably the best fix (not sure if I understand the consequences\ncorrectly) is coming from this PR to bitcoin core (c.f.\nhttps://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I get it\ncorrectly with that we could always have low fees and ask the person who\nwant to claim their outputs to pay fees. This excludes overpayment and\ncould happen at a later stage when fees are not spiked. Still the victim\nwho offered the htlcs would have to spend those outputs at some time.\n3. Don't overpay fees in commitment transactions. We can't foresee the\nfuture anyway\n4. Don't add htlcs for which the on chain fee is higher than the HTLCs\nvalue (like we do with sub dust amounts and sub satoshi amounts. This would\nat least make the attack expensive as the attacker would have to bind a lot\nof liquidity.\n5. Somehow be able to aggregate htlc's. In a world where we use payment\npoints instead of preimages we might be able to do so. It would be really\ncool if separate HTLC's could be combined to 1 single output. I played\naround a little bit but I have not come up with a scheme that is more\ncompact in all cases. Thus I just threw in the idea.\n6. Split onchain fees differently (now the attacker would also lose fees by\nconducting this attack) - No I don't want to start yet another fee\nbikeshadding debate. (In particular I believe that a different split of\nfees might make the Flood & Loot attack economically more viable which\nrelies on the same principle)\n\nIndependently I think we should have a hint in our readme file about where\nand how people can disclose attacks and vulnerabilities. Implementations\nhave this but the BOLTs do not.\n\nwith kind regards Rene\n\n-- \n\nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200617/07158fbc/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-17T12:21:10",
                "message_text_only": "Good morning Rene,\n\nThank you for the report, this is good.\n\n> 1. The current solution is to just not use up the max value of htlc's.\u00a0Eclaire\u00a0and c-lightning by default only use up to 30 htlcs.\n> 2. Probably the best fix (not sure if I understand the consequences correctly) is coming from this PR to bitcoin core (c.f.\u00a0https://github.com/bitcoin/bitcoin/pull/15681\u00a0by @TheBlueMatt . If I get it correctly with that we could always have low fees and ask the person who want to claim their outputs to pay fees. This excludes overpayment and could happen at a later stage when fees are not spiked. Still the victim who offered the htlcs would have to spend those outputs at some time.\n> 3. Don't overpay fees in commitment transactions. We can't foresee the future anyway\n\nFee futures could help against this.\nI remember writing about this some time ago but cannot find where (not sure if it was in lightning-dev or bitcoin-dev).\n\nAs a rough sketch, a client contacts a fee insurance service.\nFor a fixed fee, the client arranges such that the fee insurance service pays for fees in case of a condition where feerates increase.\n\nThis is done by arranging a 2-of-2 output spending the insurance premium payment and some maximum fee the insurance service provides.\nInitially sign an `nLockTime`d transaction that represents the end of the insurance service contract.\nThen at each commitment tx, sign a variety of feerates spending the CPFP carve-out and the insurance 2-of-2, utilizing the insurnace funds for doing the CPFP.\n\n> 4. Don't add htlcs for which the on chain fee is higher than the HTLCs value (like we do with sub dust amounts and sub satoshi amounts. This would at least make the attack expensive as the attacker would have to bind a lot of liquidity.\n\nSeems a reasonable heuristic.\n\n> 5. Somehow be able to aggregate htlc's. In a world where we use payment points instead of preimages we might be able to do so. It would be really cool if separate HTLC's could be combined to 1 single output. I played around a little bit but I have not come up with a scheme that is more compact in all cases. Thus I just threw in the idea.\n\nThis seems impossible; once you add the points of two unrelated PTLCs, in order to separate them again once you learn the aggregate scalar, you need to learn the scalar of one separately from the scalar of the other, but the aggregate PTLC does not impose the requirement from the receiver to reveal each of the scalars separately.\n\nYou *could* require multiple signatures instead of a single signature, in which case each completed signature can reveal a separate scalar behind a point.\nRevealing the points and the signatures is 96 bytes, plus a few more bytes for opcodes, divided by 4 because witness, so about equivalent to 24 block space per PTLC you merge.\n\nThis cost would be paid by the receiver of the HTLC.\nThe timelock branch can be made not to have to reveal any of the points, by Taproot-signing the timelock branch, or using a separate tapscript (at the cost of additional 32 witness bytes to select branches, if my taproot understanding holds).\n\n--\n\nCombining timelocks is also bad.\nIf you combine two PTLCs with different timelocks, which do you choose, the larger or the smaller?\n\n* If you choose the larger, the sender of the PTLCs could have a larger outgoing timelock than the its incoming PTLC, then possibly might lose money when the incoming PTLC times out but the outgoing timelock is not yet timed out and can still be claimed by scalar revelation.\n* If you choose the smaller, then the next hop might not have enough block time to deliver the payment, in which case later hops on the route will fail more often (possibly an acceptable tradeoff? c-lightning does shadow routing which overallocates timelock anyway...).\n* If you cannot combine different timelocks, the attacker can arrange PTLCs with timelocks from now+2 to now+484 to mount the attack.\n\n--\n\nYou could try aggregating using `OP_CHECKTEMPLATEVERIFY`, or equivalently with a pre-signed transaction, but that just moves the revelation cost to the receiver of the PTLC, which multiple signatures above does just as well.\nIt does have the advantage of retaining the timelocks.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-17T13:41:02",
                "message_text_only": "Good morning all,\n\n>\n> Fee futures could help against this.\n> I remember writing about this some time ago but cannot find where (not sure if it was in lightning-dev or bitcoin-dev).\n\n`harding` found it: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-06-18T08:40:45",
                "message_text_only": "Hi Rene,\n\nThanks for disclosing this vulnerability,\n\nI think this blackmail scenario holds but sadly there is a lower scenario.\n\nBoth \"Flood & Loot\" and your blackmail attack rely on `update_fee`\nmechanism and unbounded commitment transaction size inflation. Though the\nfirst to provoke block congestion and yours to lockdown in-flight fees as\nfunds hostage situation.\n\n> 1. The current solution is to just not use up the max value of\nhtlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n\nAs of today, yes I would recommend capping commitment size both for\nensuring competitive propagation/block selection and limiting HTLC exposure.\n\n> 2. Probably the best fix (not sure if I understand the consequences\ncorrectly) is coming from this PR to bitcoin core (c.f.\nhttps://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I get it\ncorrectly with that we could always have low fees and ask the person who\nwant to claim their outputs to pay fees. This excludes overpayment and\ncould happen at a later stage when fees are not spiked. Still the victim\nwho offered the htlcs would have to spend those outputs at some time.\n\nIt's a bit more complex, carve-out output, even combined with anchor output\nsupport on the LN-side won't protect against different flavors of pinning.\nI invite you to go through logs of past 2 LN dev meetings.\n\n> 3. Don't overpay fees in commitment transactions. We can't foresee the\nfuture anyway\n\nOnce 2. is well-addressed we may deprecate `update_fee`.\n\n> 4. Don't add htlcs for which the on chain fee is higher than the HTLCs\nvalue (like we do with sub dust amounts and sub satoshi amounts. This would\nat least make the attack expensive as the attacker would have to bind a lot\nof liquidity.\n\nIdeally we want dust_limit to be dynamic, dust cap should be based on HTLC\neconomic value, feerate of its output, feerate of HTLC-transaction, feerate\nestimation of any CPFP to bump it. I think that's kind of worthy to do once\nwe solved 3. and 4\n\n> 5. Somehow be able to aggregate htlc's. In a world where we use payment\npoints instead of preimages we might be able to do so. It would be really\ncool if separate HTLC's could be combined to 1 single output. I played\naround a little bit but I have not come up with a scheme that is more\ncompact in all cases. Thus I just threw in the idea.\n\nYes we may encode all HTLC in some Taproot tree in the future. There are\nsome wrinkles but for a high-level theoretical construction see my post on\nCoinPool.\n\n> 6. Split onchain fees differently (now the attacker would also lose fees\nby conducting this attack) - No I don't want to start yet another fee\nbikeshadding debate. (In particular I believe that a different split of\nfees might make the Flood & Loot attack economically more viable which\nrelies on the same principle)\n\nLikely a bit more of fee bikeshedding is something we have to do to make LN\nsecure... Switching fee from pre-committed ones to a single-party, dynamic\none.\n\n> Independently I think we should have a hint in our readme file about\nwhere and how people can disclose attacks and vulnerabilities.\nImplementations have this but the BOLTs do not.\n\nI 100% agree, that's exactly\nhttps://github.com/lightningnetwork/lightning-rfc/pull/772, waiting for\nyour feedback :)\n\nCheers,\n\nAntoine\n\nLe mer. 17 juin 2020 \u00e0 09:41, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n>\n> Good morning all,\n>\n> >\n> > Fee futures could help against this.\n> > I remember writing about this some time ago but cannot find where (not\n> sure if it was in lightning-dev or bitcoin-dev).\n>\n> `harding` found it:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200618/4505fed3/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-06-20T23:13:40",
                "message_text_only": "I am not steeped enough in Lightning Protocol issues to get the full design\nspace, but I'm fairly certain BIP-119 Congestion Control trees would help\nwith this issue.\n\nYou can bucket a tree by doing a histogram of HTLC size, so that all small\nHTLCs live in a common CTV subtree and don't interfere with higher value\nHTLCs. You can also play with sequencing to prevent those HTLCs from\ngetting longchains in the mempool until they're above a certain value.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Thu, Jun 18, 2020 at 1:41 AM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi Rene,\n>\n> Thanks for disclosing this vulnerability,\n>\n> I think this blackmail scenario holds but sadly there is a lower scenario.\n>\n> Both \"Flood & Loot\" and your blackmail attack rely on `update_fee`\n> mechanism and unbounded commitment transaction size inflation. Though the\n> first to provoke block congestion and yours to lockdown in-flight fees as\n> funds hostage situation.\n>\n> > 1. The current solution is to just not use up the max value of\n> htlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n>\n> As of today, yes I would recommend capping commitment size both for\n> ensuring competitive propagation/block selection and limiting HTLC exposure.\n>\n> > 2. Probably the best fix (not sure if I understand the consequences\n> correctly) is coming from this PR to bitcoin core (c.f.\n> https://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I get\n> it correctly with that we could always have low fees and ask the person who\n> want to claim their outputs to pay fees. This excludes overpayment and\n> could happen at a later stage when fees are not spiked. Still the victim\n> who offered the htlcs would have to spend those outputs at some time.\n>\n> It's a bit more complex, carve-out output, even combined with anchor\n> output support on the LN-side won't protect against different flavors of\n> pinning. I invite you to go through logs of past 2 LN dev meetings.\n>\n> > 3. Don't overpay fees in commitment transactions. We can't foresee the\n> future anyway\n>\n> Once 2. is well-addressed we may deprecate `update_fee`.\n>\n> > 4. Don't add htlcs for which the on chain fee is higher than the HTLCs\n> value (like we do with sub dust amounts and sub satoshi amounts. This would\n> at least make the attack expensive as the attacker would have to bind a lot\n> of liquidity.\n>\n> Ideally we want dust_limit to be dynamic, dust cap should be based on HTLC\n> economic value, feerate of its output, feerate of HTLC-transaction, feerate\n> estimation of any CPFP to bump it. I think that's kind of worthy to do once\n> we solved 3. and 4\n>\n> > 5. Somehow be able to aggregate htlc's. In a world where we use payment\n> points instead of preimages we might be able to do so. It would be really\n> cool if separate HTLC's could be combined to 1 single output. I played\n> around a little bit but I have not come up with a scheme that is more\n> compact in all cases. Thus I just threw in the idea.\n>\n> Yes we may encode all HTLC in some Taproot tree in the future. There are\n> some wrinkles but for a high-level theoretical construction see my post on\n> CoinPool.\n>\n> > 6. Split onchain fees differently (now the attacker would also lose fees\n> by conducting this attack) - No I don't want to start yet another fee\n> bikeshadding debate. (In particular I believe that a different split of\n> fees might make the Flood & Loot attack economically more viable which\n> relies on the same principle)\n>\n> Likely a bit more of fee bikeshedding is something we have to do to make\n> LN secure... Switching fee from pre-committed ones to a single-party,\n> dynamic one.\n>\n> > Independently I think we should have a hint in our readme file about\n> where and how people can disclose attacks and vulnerabilities.\n> Implementations have this but the BOLTs do not.\n>\n> I 100% agree, that's exactly\n> https://github.com/lightningnetwork/lightning-rfc/pull/772, waiting for\n> your feedback :)\n>\n> Cheers,\n>\n> Antoine\n>\n> Le mer. 17 juin 2020 \u00e0 09:41, ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>>\n>> Good morning all,\n>>\n>> >\n>> > Fee futures could help against this.\n>> > I remember writing about this some time ago but cannot find where (not\n>> sure if it was in lightning-dev or bitcoin-dev).\n>>\n>> `harding` found it:\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n>>\n>> Regards,\n>> ZmnSCPxj\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200620/3c0b6b52/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-21T03:33:59",
                "message_text_only": "Good morning Jeremy,\n\n> I am not steeped enough in Lightning Protocol issues to get the full design space, but I'm fairly certain BIP-119 Congestion Control trees would help with this issue.\n>\n> You can bucket a tree by doing a histogram of HTLC size, so that all small HTLCs live in a common CTV subtree and don't interfere with higher value HTLCs. You can also play with sequencing to prevent those HTLCs from getting longchains in the mempool until they're above a certain value.\n\nIf the attacker stops responding, then all HTLC rules need to be published onchain for enforcement of the HTLC rules.\nAnd that publication onchain is the problem: every HTLC published requires onchain space, which must be paid for.\n\nThe most compact way to expose the HTLCs is as a flat array, i.e. outputs of a single transaction.\nEvery tree structure is going to take up more space than a flat array.\n\nWhat CTV buys is to be able to defer *when* you reveal scripts, possibly to a later time when blockchain space is cheaper.\nBut in case the victim owns the timelock branch of an outgoing HTLC, it is unsafe for the victim to defer: it has to enforce the locktime soon or it could end up losing both incoming and outgoing HTLC amounts.\nAnd to enforce the locktime it has to publish the HTLC.\n\nNow of course with CTV you could publish only the HTLC you have to enforce *now*, and keep the rest in an CTV output.\nThe attacker can counter this by pushing 483 HTLCs with the same timelock at the victim, so that the victim has to publish all HTLCs simultaneously.\nAnd a flat array of outputs is cheaper than a tree.\n\nWhat *can* be done would be to bin by timelock rather than amount; tree leaves are a transaction that exposes all HTLCs with a particular timelock as a flat array of outputs, but different timelocks go to different tree branches.\nBut the attacker can still do the same-timelock trick, and the tree structure is likely to take up more space in the end than just a non-treed flat array of outputs.\n\nRegards,\nZmnSCPxj\n\n\n> --\n> @JeremyRubin\n>\n> On Thu, Jun 18, 2020 at 1:41 AM Antoine Riard <antoine.riard at gmail.com> wrote:\n>\n> > Hi Rene,\n> > Thanks for disclosing this vulnerability,\n> >\n> > I think this blackmail scenario holds but sadly there is a lower scenario.\n> >\n> > Both \"Flood & Loot\" and your blackmail attack rely on `update_fee` mechanism and unbounded commitment transaction size inflation. Though the first to provoke block congestion and yours to lockdown in-flight fees as funds hostage situation.\n> >\n> > > 1. The current solution is to just not use up the max value of htlc's.\u00a0Eclaire\u00a0and c-lightning by default only use up to 30 htlcs.\n> >\n> > As of today, yes I would recommend capping commitment size both for ensuring competitive propagation/block selection and limiting HTLC exposure.\n> >\n> > > 2. Probably the best fix (not sure if I understand the consequences correctly) is coming from this PR to bitcoin core (c.f.\u00a0https://github.com/bitcoin/bitcoin/pull/15681\u00a0by @TheBlueMatt . If I get it correctly with that we could always have low fees and ask the person who want to claim their outputs to pay fees. This excludes overpayment and could happen at a later stage when fees are not spiked. Still the victim who offered the htlcs would have to spend those outputs at some time.\n> >\n> > It's a bit more complex, carve-out output, even combined with anchor output support on the LN-side won't protect against different flavors of pinning. I invite you to go through logs of past 2 LN dev meetings.\n> >\n> > > 3. Don't overpay fees in commitment transactions. We can't foresee the future anyway\n> >\n> > Once 2. is well-addressed we may deprecate `update_fee`.\n> >\n> > > 4. Don't add htlcs for which the on chain fee is higher than the HTLCs value (like we do with sub dust amounts and sub satoshi amounts. This would at least make the attack expensive as the attacker would have to bind a lot of liquidity.\n> >\n> > Ideally we want dust_limit to be dynamic, dust cap should be based on HTLC economic value, feerate of its output, feerate of HTLC-transaction, feerate estimation of any CPFP to bump it. I think that's kind of worthy to do once we solved 3. and 4\n> >\n> > > 5. Somehow be able to aggregate htlc's. In a world where we use payment points instead of preimages we might be able to do so. It would be really cool if separate HTLC's could be combined to 1 single output. I played around a little bit but I have not come up with a scheme that is more compact in all cases. Thus I just threw in the idea.\n> >\n> > Yes we may encode all HTLC in some Taproot tree in the future. There are some wrinkles but for a high-level theoretical construction see my post on CoinPool.\n> >\n> > > 6. Split onchain fees differently (now the attacker would also lose fees by conducting this attack) - No I don't want to start yet another fee bikeshadding debate. (In particular I believe that a different split of fees might make the Flood & Loot attack economically more viable which relies on the same principle)\n> >\n> > Likely a bit more of fee bikeshedding is something we have to do to make LN secure... Switching fee from pre-committed ones to a single-party, dynamic one.\n> >\n> > > Independently I think we should have a hint in our readme file about where and how people can disclose attacks and vulnerabilities. Implementations have this but the BOLTs do not.\n> >\n> > I 100% agree, that's exactly https://github.com/lightningnetwork/lightning-rfc/pull/772, waiting for your feedback :)\n> >\n> > Cheers,\n> >\n> > Antoine\n> >\n> > Le\u00a0mer. 17 juin 2020 \u00e0\u00a009:41, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> a \u00e9crit\u00a0:\n> >\n> > > Good morning all,\n> > >\n> > > >\n> > > > Fee futures could help against this.\n> > > > I remember writing about this some time ago but cannot find where (not sure if it was in lightning-dev or bitcoin-dev).\n> > >\n> > > `harding` found it: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Jeremy",
                "date": "2020-06-21T22:17:39",
                "message_text_only": "Hi ZmnSCPxj,\n\nMy understanding is that you can use the CTV deferral to also get\nindependent HTLC relative timelocks start points per output. This would\nhelp with this sort of issue right?\n\nAnd you're correct that there's overhead of indirection, but it's not super\nlarge (minimally complicated something like an extra 100 bytes per output,\nif you were to have a flat array where each entry is a CTV output so that\neach out gets its own clock).\n\nEssentially something like this:\n\nChan\n     |\n     ---------------------------------------------\n     |           |             |             |            |\nCTV(A) CTV(B) CTV(C) CTV(D)      (Optional CPFP Anchor?)\n     |           |             |             |\n1 block    1 block   1 block   1 block\n     |           |             |             |\n    A          B           C            D\n\nWhere A B C and D are all HTLCs.\n\nNow because of the one-hop indirection, A B C and D can all expand\nindependently. It's also possible for the Channel Operator to do something\nlike:\n\nChan\n     |\n     ---------------------------------------------\n     |           |             |             |            |\nCTV(A) CTV(B) CTV(C) CTV(D)      (Optional CPFP Anchor?)\n     |           |             |             |\n1 block    1 block   1 block   10 blocks\n     |           |             |             |\n    A          B           C            D\n\nTo make D have a further out resolution time to prevent the\nsimultaneous-ness issue (trees or a linear-chain rather than total fan-out\ncan also be used but I think it's a bit more confusing for a basic\nexample). The benefit of trees is that I can do something like:\n\n\nChan\n     |\n     --------------------------------------------------------\n     |           |             |             |                          |\nCTV(A) CTV(B) CTV(C) CTV(400 HTLC)      (Optional CPFP Anchor?)\n     |           |             |             |                |\n1 block    1 block   1 block   10 blocks  (Optional CPFP Anchor?)\n     |           |             |              |\n     |           |             |             / ....\\\n    A          B           C            | ..... |\n\nWhich makes it so that the low-value new HTLCs can be deprioritized fee\nwise. So that the attack, which occurs during a fee spike, doesn't end up\n*requiring* substantial fees to be added to the channel to support a burst\nof HTLCS.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sat, Jun 20, 2020 at 8:34 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Jeremy,\n>\n> > I am not steeped enough in Lightning Protocol issues to get the full\n> design space, but I'm fairly certain BIP-119 Congestion Control trees would\n> help with this issue.\n> >\n> > You can bucket a tree by doing a histogram of HTLC size, so that all\n> small HTLCs live in a common CTV subtree and don't interfere with higher\n> value HTLCs. You can also play with sequencing to prevent those HTLCs from\n> getting longchains in the mempool until they're above a certain value.\n>\n> If the attacker stops responding, then all HTLC rules need to be published\n> onchain for enforcement of the HTLC rules.\n> And that publication onchain is the problem: every HTLC published requires\n> onchain space, which must be paid for.\n>\n> The most compact way to expose the HTLCs is as a flat array, i.e. outputs\n> of a single transaction.\n> Every tree structure is going to take up more space than a flat array.\n>\n> What CTV buys is to be able to defer *when* you reveal scripts, possibly\n> to a later time when blockchain space is cheaper.\n> But in case the victim owns the timelock branch of an outgoing HTLC, it is\n> unsafe for the victim to defer: it has to enforce the locktime soon or it\n> could end up losing both incoming and outgoing HTLC amounts.\n> And to enforce the locktime it has to publish the HTLC.\n>\n> Now of course with CTV you could publish only the HTLC you have to enforce\n> *now*, and keep the rest in an CTV output.\n> The attacker can counter this by pushing 483 HTLCs with the same timelock\n> at the victim, so that the victim has to publish all HTLCs simultaneously.\n> And a flat array of outputs is cheaper than a tree.\n>\n> What *can* be done would be to bin by timelock rather than amount; tree\n> leaves are a transaction that exposes all HTLCs with a particular timelock\n> as a flat array of outputs, but different timelocks go to different tree\n> branches.\n> But the attacker can still do the same-timelock trick, and the tree\n> structure is likely to take up more space in the end than just a non-treed\n> flat array of outputs.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> > --\n> > @JeremyRubin\n> >\n> > On Thu, Jun 18, 2020 at 1:41 AM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n> >\n> > > Hi Rene,\n> > > Thanks for disclosing this vulnerability,\n> > >\n> > > I think this blackmail scenario holds but sadly there is a lower\n> scenario.\n> > >\n> > > Both \"Flood & Loot\" and your blackmail attack rely on `update_fee`\n> mechanism and unbounded commitment transaction size inflation. Though the\n> first to provoke block congestion and yours to lockdown in-flight fees as\n> funds hostage situation.\n> > >\n> > > > 1. The current solution is to just not use up the max value of\n> htlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n> > >\n> > > As of today, yes I would recommend capping commitment size both for\n> ensuring competitive propagation/block selection and limiting HTLC exposure.\n> > >\n> > > > 2. Probably the best fix (not sure if I understand the consequences\n> correctly) is coming from this PR to bitcoin core (c.f.\n> https://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I get\n> it correctly with that we could always have low fees and ask the person who\n> want to claim their outputs to pay fees. This excludes overpayment and\n> could happen at a later stage when fees are not spiked. Still the victim\n> who offered the htlcs would have to spend those outputs at some time.\n> > >\n> > > It's a bit more complex, carve-out output, even combined with anchor\n> output support on the LN-side won't protect against different flavors of\n> pinning. I invite you to go through logs of past 2 LN dev meetings.\n> > >\n> > > > 3. Don't overpay fees in commitment transactions. We can't foresee\n> the future anyway\n> > >\n> > > Once 2. is well-addressed we may deprecate `update_fee`.\n> > >\n> > > > 4. Don't add htlcs for which the on chain fee is higher than the\n> HTLCs value (like we do with sub dust amounts and sub satoshi amounts. This\n> would at least make the attack expensive as the attacker would have to bind\n> a lot of liquidity.\n> > >\n> > > Ideally we want dust_limit to be dynamic, dust cap should be based on\n> HTLC economic value, feerate of its output, feerate of HTLC-transaction,\n> feerate estimation of any CPFP to bump it. I think that's kind of worthy to\n> do once we solved 3. and 4\n> > >\n> > > > 5. Somehow be able to aggregate htlc's. In a world where we use\n> payment points instead of preimages we might be able to do so. It would be\n> really cool if separate HTLC's could be combined to 1 single output. I\n> played around a little bit but I have not come up with a scheme that is\n> more compact in all cases. Thus I just threw in the idea.\n> > >\n> > > Yes we may encode all HTLC in some Taproot tree in the future. There\n> are some wrinkles but for a high-level theoretical construction see my post\n> on CoinPool.\n> > >\n> > > > 6. Split onchain fees differently (now the attacker would also lose\n> fees by conducting this attack) - No I don't want to start yet another fee\n> bikeshadding debate. (In particular I believe that a different split of\n> fees might make the Flood & Loot attack economically more viable which\n> relies on the same principle)\n> > >\n> > > Likely a bit more of fee bikeshedding is something we have to do to\n> make LN secure... Switching fee from pre-committed ones to a single-party,\n> dynamic one.\n> > >\n> > > > Independently I think we should have a hint in our readme file about\n> where and how people can disclose attacks and vulnerabilities.\n> Implementations have this but the BOLTs do not.\n> > >\n> > > I 100% agree, that's exactly\n> https://github.com/lightningnetwork/lightning-rfc/pull/772, waiting for\n> your feedback :)\n> > >\n> > > Cheers,\n> > >\n> > > Antoine\n> > >\n> > > Le mer. 17 juin 2020 \u00e0 09:41, ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n> > >\n> > > > Good morning all,\n> > > >\n> > > > >\n> > > > > Fee futures could help against this.\n> > > > > I remember writing about this some time ago but cannot find where\n> (not sure if it was in lightning-dev or bitcoin-dev).\n> > > >\n> > > > `harding` found it:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n> > > >\n> > > > Regards,\n> > > > ZmnSCPxj\n> > > > _______________________________________________\n> > > > Lightning-dev mailing list\n> > > > Lightning-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > >\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200621/8e0db1ae/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-21T23:30:45",
                "message_text_only": "Good morning Jeremy,\n\n> My understanding is that you can use the CTV deferral to also get independent HTLC relative timelocks start points per output. This would help with this sort of issue right?\n>\n> And you're correct that there's overhead of indirection, but it's not super large (minimally complicated something like an extra 100 bytes per output, if you were to have a flat array where each entry is a CTV output so that each out gets its own clock).\n>\n> Essentially something like this:\n>\n> Chan\n> \u00a0\u00a0\u00a0\u00a0 |\n> \u00a0\u00a0\u00a0\u00a0 ------------------------------------\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0\u00a0 \u00a0 | \u00a0\u00a0 \u00a0 | \u00a0  \u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n>    CTV(A) CTV(B) CTV(C)  CTV(D)\u00a0\u00a0\u00a0\u00a0\u00a0 (Optional CPFP Anchor?)\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0 \u00a0|\u00a0\n> 1 block\u00a0 1 block\u00a01 block\u00a0 1 block\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0\u00a0|\n> \u00a0\u00a0\u00a0 A\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0D\n>\n> Where A B C and D are all HTLCs.\n>\n> Now because of the one-hop indirection, A B C and D can all expand independently. It's also possible for the Channel Operator to do something like:\n>\n> Chan\n> \u00a0\u00a0\u00a0\u00a0 |\n> \u00a0\u00a0\u00a0\u00a0 -----------------------------------\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n>    CTV(A) CTV(B) CTV(C) CTV(D)\u00a0\u00a0\u00a0\u00a0\u00a0 (Optional CPFP Anchor?)\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0|\n> 1 block\u00a0 1 block\u00a01 block 10 blocks\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0|\n> \u00a0\u00a0\u00a0 A\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0D\n>\n> To make D have a further out resolution time to prevent the simultaneous-ness issue (trees or a linear-chain rather than total fan-out can also be used but I think it's a bit more confusing for a basic example).\n\nThe Lightning HTLCs use absolute timelocks, and the timelocks are pre-arranged by the original sender.\nA forwarding node has to ensure that the outgoing HTLC timeout is respected, or else it could lose funds (by having the outgoing HTLC be claimed by outgoing peer hashlock and the incoming HTLC be calimed by the incoming peer timelock).\n\n(We cannot use relative timelocks in the timelock branches of the HTLCs because we are coordinating possibly up to 20 different nodes, and do not want to leak the entire route to any of the intermediate nodes, so everyone has to use the same clock --- the absolute blockheight --- to measure time)\n\nSo, if my understanding of your above graph is correct, you are suggesting that HTLC D could have a relative timelock of 10 blocks instead of 1.\n\nBut all that means is that if the timelock of D is at height L, then the forwarder has to ensure that the commitment transaction appears onchain no later than height L - 10 (in practice I have to publish it at L - 11 so it propagates to miners who are building L - 10).\nIf not, the HTLC cannot be published at height L and the timelock cannot be enforced, risking fund loss.\n\nThis seems to *tighten* whatever leeway I might have bought by using CTV.\nIn current C-Lightning, for instance, for a timelock in my favor at height L, I have to broadcast the commitment transaction at time L - 1 so it goes into block L and I can claim it.\nThus, I have the option to publish from now up to L - 1.\nWith a further delay of 10 on the HTLC tx D, I now only have the option to publish from now up to L - 11, thus I have *less* leeway in when I can publish the commitment tx.\n\nBasically the fund-security of the forwarding node is based on the absolute timelock of every HTLC it offers, so the timelock is an absolute bound on whatever techniques I might use to reduce fees.\n\n\n> The benefit of trees is that I can do something like:\n>\n> Chan\n> \u00a0\u00a0\u00a0\u00a0 |\n> \u00a0\u00a0\u00a0\u00a0 --------------------------------------------------------\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0 \u00a0 \u00a0 |\n>    CTV(A) CTV(B) CTV(C) CTV(400 HTLC)\u00a0\u00a0\u00a0\u00a0\u00a0 (Optional CPFP Anchor?)\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0           |\n> 1 block\u00a01 block\u00a0 1 block 10 blocks\u00a0        (Optional CPFP Anchor?)\n> \u00a0\u00a0\u00a0\u00a0 | \u00a0 \u00a0 \u00a0| \u00a0\u00a0 \u00a0 | \u00a0 \u00a0\u00a0\u00a0|\n> \u00a0\u00a0\u00a0\u00a0 |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0 / ....\\\n> \u00a0\u00a0\u00a0 A\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C\u00a0\u00a0| ..... |\n>\n> Which makes it so that the low-value new HTLCs can be deprioritized fee wise. So that the attack, which occurs during a fee spike, doesn't end up *requiring* substantial fees to be added to the channel to support a burst of HTLCS.\n\nIf the HTLCs have a timelock L, then I *need* to publish the HTLCs at timelock L or else the timelock cannot be enforced.\n\nThis means I need to publish the big `| ..... |` transaction with 400 HTLCs before timelock L, where L is `min (L) for all 400 HTLCs`.\n\nThe attacker can arrange to have the 400 low-value HTLCs have the same timelock L.\nSo even if the `| ..... |` is a tree of CTVs, I have to publish the entire tree at the same time so that the final HTLCs appear at timelock L and I can reclaim my funds.\n\nIf I do not publish, I run the risk that the total fund going to `CTV(400 HTLC)` gets stolen from me by publication of the hashlock on the outgoing and publication of the timelock at the incoming.\nNot publishing this due to fee spikes is basically trusting that the next peer is not going to steal the fund by hashlock branch.\nAnd the next peer is an attacker in this attack, so obviously cannot be trusted.\n\nSo it seems to me that this is better done by just rate-limiting simultaneous HTLCs, to limit what can be stolen.\n\nA better solution might be to allow only one HTLC at each absolute timelock, and use a single CTV tree, with one leaf for each of the absolute timelocks.\nThen I can publish parts of the CTV tree at my leisure, with my only constraint being the absolute timelock of each HTLC.\n\n\n    Chan\n      |\n     CTV\n      |\n      +------+\n      |      |\n     CTV    HTLC(L = now + 1)\n      |\n      +------+\n      |      |\n     CTV    HTLC(L = now + 2)\n      |\n      +------+\n      |      |\n     CTV    HTLC(L = now + 3)\n      |\n     ...\n\nSuch a singly-linked list would take up even more absolute block space, incidentally, and makes high-fee spikes more likely.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-06-22T01:20:23",
                "message_text_only": "Hi Jeremy,\n\nThe up-front costs can be further mitigated even without something like CTV\n(which makes things more efficient) by adding a layer of in-direction w.r.t\nhow\nHTLCs are manifested within the commitment transactions. To do this, we add\na\nnew 2-of-2 multi-sig output (an HTLC indirect block) to the commitment\ntransactions. This is then spent by a new transaction (the HTLC block) that\nactually manifests (creates the HTLC outputs) the HTLCs.\n\nWith this change, the cost to have a commitment be mined in the chain is now\n_independent of the number of HTLCs in the channel_. In the past I've called\nthis construction \"coupe commitments\" (lol).\n\nOther flavors of this technique are possible as well, allowing both sides to\ncraft varying HTLC indirection trees (double layers of indirection are\npossible, etc) which may factor in traits like HTLC expiration time (HTLCs\nthat\nexpire later are further down in the tree).\n\nSomething like CTV does indeed make this technique more powerful+efficient\nas\nit allows one to succinctly commit to all the relevant desirable\ncombinations\nof HTLC indirect blocks, and HTLC fan-out transactions.\n\n-- Laolu\n\n\nOn Sat, Jun 20, 2020 at 4:14 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> I am not steeped enough in Lightning Protocol issues to get the full\n> design space, but I'm fairly certain BIP-119 Congestion Control trees would\n> help with this issue.\n>\n> You can bucket a tree by doing a histogram of HTLC size, so that all small\n> HTLCs live in a common CTV subtree and don't interfere with higher value\n> HTLCs. You can also play with sequencing to prevent those HTLCs from\n> getting longchains in the mempool until they're above a certain value.\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Thu, Jun 18, 2020 at 1:41 AM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi Rene,\n>>\n>> Thanks for disclosing this vulnerability,\n>>\n>> I think this blackmail scenario holds but sadly there is a lower scenario.\n>>\n>> Both \"Flood & Loot\" and your blackmail attack rely on `update_fee`\n>> mechanism and unbounded commitment transaction size inflation. Though the\n>> first to provoke block congestion and yours to lockdown in-flight fees as\n>> funds hostage situation.\n>>\n>> > 1. The current solution is to just not use up the max value of\n>> htlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n>>\n>> As of today, yes I would recommend capping commitment size both for\n>> ensuring competitive propagation/block selection and limiting HTLC exposure.\n>>\n>> > 2. Probably the best fix (not sure if I understand the consequences\n>> correctly) is coming from this PR to bitcoin core (c.f.\n>> https://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I get\n>> it correctly with that we could always have low fees and ask the person who\n>> want to claim their outputs to pay fees. This excludes overpayment and\n>> could happen at a later stage when fees are not spiked. Still the victim\n>> who offered the htlcs would have to spend those outputs at some time.\n>>\n>> It's a bit more complex, carve-out output, even combined with anchor\n>> output support on the LN-side won't protect against different flavors of\n>> pinning. I invite you to go through logs of past 2 LN dev meetings.\n>>\n>> > 3. Don't overpay fees in commitment transactions. We can't foresee the\n>> future anyway\n>>\n>> Once 2. is well-addressed we may deprecate `update_fee`.\n>>\n>> > 4. Don't add htlcs for which the on chain fee is higher than the HTLCs\n>> value (like we do with sub dust amounts and sub satoshi amounts. This would\n>> at least make the attack expensive as the attacker would have to bind a lot\n>> of liquidity.\n>>\n>> Ideally we want dust_limit to be dynamic, dust cap should be based on\n>> HTLC economic value, feerate of its output, feerate of HTLC-transaction,\n>> feerate estimation of any CPFP to bump it. I think that's kind of worthy to\n>> do once we solved 3. and 4\n>>\n>> > 5. Somehow be able to aggregate htlc's. In a world where we use payment\n>> points instead of preimages we might be able to do so. It would be really\n>> cool if separate HTLC's could be combined to 1 single output. I played\n>> around a little bit but I have not come up with a scheme that is more\n>> compact in all cases. Thus I just threw in the idea.\n>>\n>> Yes we may encode all HTLC in some Taproot tree in the future. There are\n>> some wrinkles but for a high-level theoretical construction see my post on\n>> CoinPool.\n>>\n>> > 6. Split onchain fees differently (now the attacker would also lose\n>> fees by conducting this attack) - No I don't want to start yet another fee\n>> bikeshadding debate. (In particular I believe that a different split of\n>> fees might make the Flood & Loot attack economically more viable which\n>> relies on the same principle)\n>>\n>> Likely a bit more of fee bikeshedding is something we have to do to make\n>> LN secure... Switching fee from pre-committed ones to a single-party,\n>> dynamic one.\n>>\n>> > Independently I think we should have a hint in our readme file about\n>> where and how people can disclose attacks and vulnerabilities.\n>> Implementations have this but the BOLTs do not.\n>>\n>> I 100% agree, that's exactly\n>> https://github.com/lightningnetwork/lightning-rfc/pull/772, waiting for\n>> your feedback :)\n>>\n>> Cheers,\n>>\n>> Antoine\n>>\n>> Le mer. 17 juin 2020 \u00e0 09:41, ZmnSCPxj via Lightning-dev <\n>> lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n>>\n>>>\n>>> Good morning all,\n>>>\n>>> >\n>>> > Fee futures could help against this.\n>>> > I remember writing about this some time ago but cannot find where (not\n>>> sure if it was in lightning-dev or bitcoin-dev).\n>>>\n>>> `harding` found it:\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200621/934a081d/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-06-22T19:18:08",
                "message_text_only": "Yes -- to be clear, most of the feature-wise benefits of CTV for Lightning\nare only in the initial channel setup phase, lessening interactivity\nrequirements.\n\nEverything else can be emulated via multisig layers, but that can add\nsubstantial latency in doing either 2pECDSA for each layer or on chain &\nstorage overhead in the signature space. CTV helps here because it can be\nboth deterministic & compact, but is not adding a new feature to already\ninteractive protocols. This does end up helping in terms of the feasibility\nof some of the HTLC indirection tree techniques though :).\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sun, Jun 21, 2020 at 6:20 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Hi Jeremy,\n>\n> The up-front costs can be further mitigated even without something like CTV\n> (which makes things more efficient) by adding a layer of in-direction\n> w.r.t how\n> HTLCs are manifested within the commitment transactions. To do this, we\n> add a\n> new 2-of-2 multi-sig output (an HTLC indirect block) to the commitment\n> transactions. This is then spent by a new transaction (the HTLC block) that\n> actually manifests (creates the HTLC outputs) the HTLCs.\n>\n> With this change, the cost to have a commitment be mined in the chain is\n> now\n> _independent of the number of HTLCs in the channel_. In the past I've\n> called\n> this construction \"coupe commitments\" (lol).\n>\n> Other flavors of this technique are possible as well, allowing both sides\n> to\n> craft varying HTLC indirection trees (double layers of indirection are\n> possible, etc) which may factor in traits like HTLC expiration time (HTLCs\n> that\n> expire later are further down in the tree).\n>\n> Something like CTV does indeed make this technique more powerful+efficient\n> as\n> it allows one to succinctly commit to all the relevant desirable\n> combinations\n> of HTLC indirect blocks, and HTLC fan-out transactions.\n>\n> -- Laolu\n>\n>\n> On Sat, Jun 20, 2020 at 4:14 PM Jeremy <jlrubin at mit.edu> wrote:\n>\n>> I am not steeped enough in Lightning Protocol issues to get the full\n>> design space, but I'm fairly certain BIP-119 Congestion Control trees would\n>> help with this issue.\n>>\n>> You can bucket a tree by doing a histogram of HTLC size, so that all\n>> small HTLCs live in a common CTV subtree and don't interfere with higher\n>> value HTLCs. You can also play with sequencing to prevent those HTLCs from\n>> getting longchains in the mempool until they're above a certain value.\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>>\n>>\n>> On Thu, Jun 18, 2020 at 1:41 AM Antoine Riard <antoine.riard at gmail.com>\n>> wrote:\n>>\n>>> Hi Rene,\n>>>\n>>> Thanks for disclosing this vulnerability,\n>>>\n>>> I think this blackmail scenario holds but sadly there is a lower\n>>> scenario.\n>>>\n>>> Both \"Flood & Loot\" and your blackmail attack rely on `update_fee`\n>>> mechanism and unbounded commitment transaction size inflation. Though the\n>>> first to provoke block congestion and yours to lockdown in-flight fees as\n>>> funds hostage situation.\n>>>\n>>> > 1. The current solution is to just not use up the max value of\n>>> htlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n>>>\n>>> As of today, yes I would recommend capping commitment size both for\n>>> ensuring competitive propagation/block selection and limiting HTLC exposure.\n>>>\n>>> > 2. Probably the best fix (not sure if I understand the consequences\n>>> correctly) is coming from this PR to bitcoin core (c.f.\n>>> https://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I\n>>> get it correctly with that we could always have low fees and ask the person\n>>> who want to claim their outputs to pay fees. This excludes overpayment and\n>>> could happen at a later stage when fees are not spiked. Still the victim\n>>> who offered the htlcs would have to spend those outputs at some time.\n>>>\n>>> It's a bit more complex, carve-out output, even combined with anchor\n>>> output support on the LN-side won't protect against different flavors of\n>>> pinning. I invite you to go through logs of past 2 LN dev meetings.\n>>>\n>>> > 3. Don't overpay fees in commitment transactions. We can't foresee the\n>>> future anyway\n>>>\n>>> Once 2. is well-addressed we may deprecate `update_fee`.\n>>>\n>>> > 4. Don't add htlcs for which the on chain fee is higher than the HTLCs\n>>> value (like we do with sub dust amounts and sub satoshi amounts. This would\n>>> at least make the attack expensive as the attacker would have to bind a lot\n>>> of liquidity.\n>>>\n>>> Ideally we want dust_limit to be dynamic, dust cap should be based on\n>>> HTLC economic value, feerate of its output, feerate of HTLC-transaction,\n>>> feerate estimation of any CPFP to bump it. I think that's kind of worthy to\n>>> do once we solved 3. and 4\n>>>\n>>> > 5. Somehow be able to aggregate htlc's. In a world where we use\n>>> payment points instead of preimages we might be able to do so. It would be\n>>> really cool if separate HTLC's could be combined to 1 single output. I\n>>> played around a little bit but I have not come up with a scheme that is\n>>> more compact in all cases. Thus I just threw in the idea.\n>>>\n>>> Yes we may encode all HTLC in some Taproot tree in the future. There are\n>>> some wrinkles but for a high-level theoretical construction see my post on\n>>> CoinPool.\n>>>\n>>> > 6. Split onchain fees differently (now the attacker would also lose\n>>> fees by conducting this attack) - No I don't want to start yet another fee\n>>> bikeshadding debate. (In particular I believe that a different split of\n>>> fees might make the Flood & Loot attack economically more viable which\n>>> relies on the same principle)\n>>>\n>>> Likely a bit more of fee bikeshedding is something we have to do to make\n>>> LN secure... Switching fee from pre-committed ones to a single-party,\n>>> dynamic one.\n>>>\n>>> > Independently I think we should have a hint in our readme file about\n>>> where and how people can disclose attacks and vulnerabilities.\n>>> Implementations have this but the BOLTs do not.\n>>>\n>>> I 100% agree, that's exactly\n>>> https://github.com/lightningnetwork/lightning-rfc/pull/772, waiting for\n>>> your feedback :)\n>>>\n>>> Cheers,\n>>>\n>>> Antoine\n>>>\n>>> Le mer. 17 juin 2020 \u00e0 09:41, ZmnSCPxj via Lightning-dev <\n>>> lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n>>>\n>>>>\n>>>> Good morning all,\n>>>>\n>>>> >\n>>>> > Fee futures could help against this.\n>>>> > I remember writing about this some time ago but cannot find where\n>>>> (not sure if it was in lightning-dev or bitcoin-dev).\n>>>>\n>>>> `harding` found it:\n>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017601.html\n>>>>\n>>>> Regards,\n>>>> ZmnSCPxj\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200622/96c3bf3b/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-06-22T01:09:28",
                "message_text_only": "Hi Rene,\n\nIMO this is mostly mitigated by anchor commitments.  The impact of this\nattack is predicated on the \"victim\" paying 5x on-chain fees (for their\nconfirmation target) to sweep all their HTLCs.  Anchor commitments let the\ninitiator of the channel select a very low starting fee (just enough to get\ninto the mempool), and also let them actually bump the fees of second-level\nHTLC transactions.\n\nIn addition to being able to pay much lower fees (\"just enough\" to get into\nthe chain), anchor commitments allow second-level HTLC _aggregation_, This\nmeans that for HTLCs with the same expiry height, a peer is able to _batch_\nthem all into a single transaction, further saving on fees.\n\nlnd shipped with a form of anchor commitments in our past major release\n(v0.10.0-beta). In that release the format is opt in, and is enabled with a\nstartup command-line flag. For 0.11, we're planning on making this the\ndefault commitment type, giving all users that update the ability to\n_finally_ have proper fee control of their commitments, and second-level\nHTLC transactions.\n\n> The direction of HTLCs are chosen so that the amount is taken from the\n> `to_remote` output of the attacker (obviously on the victims side it will\n> be the `to_local` output)\n\nOne relevant detail here is that if the attacker is to attempt this with\nminimal setup, then they'll need to be the ones that open the channel.\nSince they're the initiator, they'll actually be the ones paying the fees\nrendering this attempt moot.\n\nAlternatively, they could use something like Lightning Loop to gain the\n_outbound_ bandwidth (Loop In) needed to attempt this attack (using inbound\nopened channels, but they'll need to pay for that bandwidth, adding a\nfurther cost to the attack. Not to mention that they'll need to pay on-chain\nfees to sweep the HTLCs they created themselves. In short, this attack isn't\ncostless as they'll need to acquire outbound liquidity for an incoming\nchannel, and also need to pay fees independent of the \"success\" of their\nattack.\n\n> I quote from BOLT 02 which suggests a buffer of a factor of 5\n\nI'm not sure how many implementations actually follow this in practice.\nFWIW, lnd doesn't.\n\n> Additionally the victim will also have to swipe all offered HTLCs (which\n> will be additional costs but could be done once the fees came down) so we\n> neglect them.\n\nNo, the attacker is the one that needs to sweep these HTLCs, since they\noffered them. This adds to their costs.\n\n> Knowing that this will happen and that the victim has to spend those funds\n> (publishing old state obviously does not work!) the attacker has a time\n> window to blackmail the victim outside of the lightning network protocol\n\nI don't think this is always the case. Depending on the minimum HTLC\nsettings in the channel (another mitigation), and the distribution of funds\nin the channel, it may be the case that the victim doesn't have any funds in\nthe channel at all (everything was on the attacker's side). In that case,\nthe \"victim\" doesn't really care if this channel is clogged up as they\nreally have no stake in this channel.\n\n> Also you might say that an attacker needs many incoming channels to\n> execute this attack. This can be achieved by gaming the autopilot.\n\nAs mentioned above, gaining purely incoming channels doesn't allow the\nattacker to launch this attack, as they'll be unable to _send out_ from any\nof those channels.\n\n> 1. The current solution is to just not use up the max value of htlc's.\n> Eclaire and c-lightning by default only use up to 30 htlcs.\n\nIMO, this isn't a solution. Lowering the max number of HTLCs in-flight just\nmakes it easier (lowers the capital costs) to jam a channel. The authors of\nthe paper you linked have another paper exploring these types of attacks\n[1], and cite the _hard coded_ limit of 483 HTLCS as an enabling factor.\n\n> 2. Probably the best fix (not sure if I understand the consequences\n> correctly) is coming from this PR to bitcoin core\n\nI think you're misinterpreting this PR, but see my first paragraph about\nanchor commitments which that PR enables.\n\n> 3. Don't overpay fees in commitment transactions. We can't foresee the\n> future anyway\n\nAnchors let you do this ;)\n\n> 4. Don't add htlcs for which the on chain fee is higher than the HTLCs\n> value (like we do with sub dust amounts and sub satoshi amounts.\n\nThis is already how \"dust HTLCs\" are calculated. The amount remaining from\nthe HTLC after it pays for its second-level transaction needs to be above\ndust. This policy can be asymmetric across commitments in the channel.\n\n> 5. Somehow be able to aggregate htlc's.\n\nAnchors let you do this on the transaction level (MIMO 2nd level HTLC\ntransactions).\n\nI hope other implementations join lnd in deploying anchor commitments to\nmitigate nuisance attacks like this, and _finally_ give users better fee\ncontrol for channels and any off-chain contracts within those channels.\n\nBTW, the \"Flood & Loot\" paper you linked mentions anchor commitments as a\nsolution towards the end of the paper. However, they erroneously state that\nan attacker would be able to spend their HTLC with a _non replaceable_\ntransaction. This isn't the case since all redemption paths are encumbered\nwith a CSV delay of 1. This delay forces the attacker to spend the output\nwith an input that has a non-final sequence, meaning the transaction is\nRBF-able.\n\n[1]: https://arxiv.org/abs/2002.06564\n\n-- Laolu\n\n\nOn Wed, Jun 17, 2020 at 3:30 AM Ren\u00e9 Pickhardt via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey everyone and of course good morning ZmnSCPxj (:\n>\n> about 11 months ago I discovered a potential blackmail attack with HTLCs\n> after answering this question on stack exchange (c.f\n> https://bitcoin.stackexchange.com/questions/89232/why-is-my-spendable-msat-much-lower-than-msatoshi-to-us/89235#89235).\n> This attack is similar to the one that was possible with tx malleability on\n> the funding transaction without the segwit upgrade (c.f.\n> https://commons.wikimedia.org/w/index.php?title=File:Introduction_to_the_Lightning_Network_Protocol_and_the_Basics_of_Lightning_Technology_(BOLT_aka_Lightning-rfc).pdf&page=126).\n> Meaning an attacker can force a victim to lose money and use this fact to\n> blackmail the victim, to potentially gain / steal some of the lost funds.\n>\n> TL;DR:\n> =====\n> * Depending on the circumstances this attack allows an attacker to make\n> channel partners lose a substantial amount of BTC without substantial costs\n> for the attacker.\n> * Depending on the exact circumstances this could be for example ~0.15\n> BTC. In particular it demonstrates why opening a channel is not an entirely\n> trustless activity.\n> * The attacker will reliably only be able to force the victim to lose this\n> amount of Bitcoin.\n> * It is not clear how in practice the attacker could gain this amount or\n> parts of it as this would involve not only game theory but also rather\n> quick communication between attacker and victim and customized Lightning\n> nodes which at least for the victim would be unlikely to exist.\n> * None of the suggested fixes seems to be satisfying though the current\n> solution of lowering the maximum amount of HTLCs that can concurrently be\n> in flight seems to be a reasonable start for now.\n>\n>\n> Timeline on Disclosure\n> =================\n> I have disclosed this attack on Sunday July 21st 2019 to Fabrice Drouin\n> (and shortly after to Christian Decker) in a phone call who in turn has\n> discussed it with people from the other implementations. From his feedback\n> I understood that people working on implementations have been more or less\n> aware of the possibility of this attack. Fabrice also mentioned that he\n> believed implementations currently try to mitigate this by setting low\n> limits of allowed / accepted HTLCs in flight. However at that time this was\n> only true for e-clair. It is now also true for c-lightning and as far as I\n> know still not true for lnd. Fabrice said that the people he talked to have\n> suggested that I should eventually describe the attack in public to raise\n> awareness (also from the group of node operators) for the problems related\n> to this attack. He also suggested that - if I wanted to - I should update\n> the rfc with recommendations  and warnings. While I already have in mind\n> how to change the rfc I wanted to start the discussion first. Maybe some\n> people find better fixes than just a warning that I have in mind. So far I\n> didn't do anything because I wanted to also give lnd the chance to handle\n> the problem.\n>\n> There are two reasons I disclose this attack today:\n> 1.) I think almost 1 year is enough time to do something about it. The\n> only implementation that afaik didn't yet is lnd (see below) but I got\n> roasbeefs ok last week to go ahead and publish the attack anyway so that we\n> can have a broader discussion on mitigation strategies.\n> 2.) The attack seems actually very similar to the one described in the\n> \"Flood & Loot: A Systemic Attack On The Lightning Network\" - paper which\n> came out 2 days ago (c.f.: https://arxiv.org/abs/2006.08513 ). I believe\n> any person reading that paper will understand the possibility of the attack\n> that I describe anyway so I believe it is now more or less public anyway\n> and thus time for an open / public discussion.\n>\n> The main difference between the two attacks (if I understand this novel\n> paper correctly) is: In the \"flood and loot\"-attack one tries to steal the\n> HTLC output of the victims. Where in the \"flood and blackmail\"-attack that\n> I describe I try to to force the victim to lose almost all its funds due to\n> high on chain fees (Which I could use to blackmail the victim)\n>\n> Description of the attack\n> ===================\n> Let us assume the victim has funded a channel with an attacker meaning it\n> will have to pay the fees for the commitment transaction in case of a force\n> close.\n>\n> During a fee spike (let us assume fee estimators suggest 150 sat / byte)\n> the attacker spams this channel with the maximum possible amount of HTLCs\n> that the protocol allows. The HTLCs can be of a small value but need to be\n> bigger than the dust limit so that additional outputs are actually added to\n> the commitment transaction which makes it quite large in Bytes. According\n> to the BOLTs these are 483 additional outputs to the commitment\n> transaction.\n> The direction of HTLCs are chosen so that the amount is taken from the\n> `to_remote` output of the attacker (obviously on the victims side it will\n> be the `to_local` output) For the actual attack it does not matter in which\n> direction the HTLCs are spammed but economically the direction I propose\n> makes even more sense for the attacker and can be achieved with circular\n> onions.\n>\n> The attacked channel partner will happily - according to the protocol -\n> use a higher fee than the current fee rate. I quote from BOLT 02 which\n> suggests a buffer of a factor of 5\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee:\n>\n>\n> > The node responsible for paying the Bitcoin fee [...] SHOULD send\n> update_fee to ensure the current fee rate is sufficient (by a significant\n> margin) for timely processing of the commitment transaction. [...] Given\n> the variance in fees, and the fact that the transaction may be spent in the\n> future, it's a good idea for the fee payer to keep a good margin (say 5x\n> the expected fee requirement); but, due to differing methods of fee\n> estimation, an exact value is not specified.\n>\n> This overpayment of fees will result in 750 sat / byte for this fee spike\n> scenario. This is by the way not completely unrealistic [I recently opened\n> a channel with 2.56 sat / byte (c.f.:\n> https://www.smartbit.com.au/tx/c0ac6cfe15e0d0c921362ab9fad998a8a8e16cd8d9d4159487dd69141ea2b9b0)\n> and the channel was force closed a couple minutes later due to an\n> implementation bug resulting in fees of 101.17 sat / byte (c.f.:\n> https://www.smartbit.com.au/tx/e32135315ec147bb27f771b2e15c7178ea573afd16cd4970bf814c9b18bc46e3\n> )\n>\n> As far as I understand the appendix of BOLT 03 offered HTLCs are 43 Byte\n> in size (c.f.:\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#appendix-a-expected-weights)\n> resulting in the following additional fees for the spammed commitment\n> transaction:\n>\n> fee (for 483 htlcs)  = 483 * 43 byte * 750 sat / byte = 15576750 sat =\n> 0.1557675 BTC\n>\n> Additionally the victim will also have to swipe all offered HTLCs (which\n> will be additional costs but could be done once the fees came down) so we\n> neglect them.\n>\n> Once all HTLCs are set up the attacker will stop signing commitment\n> transactions. In the beginning this is not suspicious as the HTLCs will\n> take some time to settle anyway. But also when fees go down and the victim\n> who funded the channel wants to update the fees the attacker will just not\n> be responsive. Eventually the victim will dare to force close the channel\n> with all those expensive HTLCs.\n>\n> Knowing that this will happen and that the victim has to spend those funds\n> (publishing old state obviously does not work!) the attacker has a time\n> window to blackmail the victim outside of the lightning network protocol:\n> \"Either you will pay those 0.1557675 BTC of fees or we will collaboratively\n> close the channel but that will cost you part of the amount you lost.\" Game\n> theory suggests that the attacker will be able to claim the major fraction\n> of the BTC (c.f. https://en.wikipedia.org/wiki/Ultimatum_game that are\n> frozen in tx fees as the victim effectively already has lost that money and\n> can only gain something back.\n>\n>\n> Thoughts\n> =======\n> You might say that the blackmail part of this attack is unrealistic as the\n> blackmailing person will not have enough time to successfully do the\n> blackmail as the channel that is not operational will fail.\n>\n> 1.) The only thing that lightning nodes might do is a fee update as the\n> htlcs stuffed the channel so I believe there is actually some time to\n> contact the victim.\n> 2.) What if the attacker is a mining pool who is just interested in high\n> fees who does not even need to do the blackmailing stuff but will just\n> force close the channel once the htlcs are set up?\n> 3.) The attacker might not even be interested in blackmailing the victim.\n> The attacker could just be interested in harming the victim. Though it\n> might certainly be a challenge to target a specific victim and trick it\n> into opening a channel with an attacker.\n>\n> Also you might say that an attacker needs many incoming channels to\n> execute this attack. This can be achieved by gaming the autopilot. an\n> attacker can start by creating many channels making him a highly likely\n> channel partner for autopilot users (who will also fund the channel). Such\n> a highly connected node might also be interesting for non autopilot users.\n>\n> Implementations\n> ============\n>\n> I looked at the code myself. I hope I do oversee things but to me it looks\n> like only eclaire was somehow mitigating this attack from being exploited.\n> (by a default config of 30 accepted htlcs which will protect the average\n> user and is much lower than the 483) and c-lightning has merged a patch\n> from me which I provided after I disclosed the attack:\n>\n> ## clightning:\n>\n> c-lightning did not by default set a hard cap on htlcs before version\n> 0.7.2 but then merged my patch\n> https://github.com/ElementsProject/lightning/pull/2858 which tried to\n> resemble the eclair defaults\n>\n> ## eclaire:\n>\n> the max accepted htlc value per channel is set as a constant to 483 which\n> follows the recommendation of the BOLTs:\n>\n> https://github.com/ACINQ/eclair/blob/e62adf2deae213d2cd0f2a6874227dcfc57880ae/eclair-core/src/main/scala/fr/acinq/eclair/channel/Channel.scala#L52\n>\n> The value is tested against at:\n>\n> https://github.com/ACINQ/eclair/blob/f724efaa76b256048de18f706e9cb58ecbebd6aa/eclair-core/src/main/scala/fr/acinq/eclair/channel/Helpers.scala#L99\n>\n> and:\n>\n> https://github.com/ACINQ/eclair/blob/f724efaa76b256048de18f706e9cb58ecbebd6aa/eclair-core/src/main/scala/fr/acinq/eclair/channel/Helpers.scala#L132\n>\n> and:\n>\n> https://github.com/ACINQ/eclair/blob/93d9369f900766171f2ddf579e8b12e28d8f0d25/eclair-core/src/main/scala/fr/acinq/eclair/channel/Commitments.scala#L154\n>\n> However the default config file specifies a maximum amount of 30 accepted\n> htlcs at:\n>\n> https://github.com/ACINQ/eclair/blob/9afb26e09c69dd5d6a14732baf5dcdf2b7a9142b/eclair-core/src/main/resources/reference.conf#L62\n>\n>\n> ## lnd\n> It seems like lnd did not and last time I checked (maybe I oversaw\n> something) does not set a hard cap on htlcs by default. The way how I\n> understand the code they allow up to 483 htlcs by default:\n>\n> The test when adding an htlc if it is beyond the maximum accepted values\n> is here:\n>\n> https://github.com/lightningnetwork/lnd/blob/970d7604071baae227db42d4665ef9d1b56988e8/lnwallet/channel.go#L3795\n>\n> the default configuration seems to be here (and in the most recent commit\n> the line still exists):\n>\n> https://github.com/lightningnetwork/lnd/blob/8b04cfbf12f460853e8c55611cd1bba21b1510ef/input/size.go#L187\n>\n> the software will accept up to 483 htlcs according to this line:\n>\n> https://github.com/lightningnetwork/lnd/blob/111cbeaa990cba78563d6cc8c19b152e2d3042f6/lnwallet/reservation.go#L314\n>\n> I could not find any spec lower than that in the suggested sample config\n> at:\n> https://github.com/lightningnetwork/lnd/blob/master/sample-lnd.conf\n>\n>\n> Ideas for Fixes\n> ===========\n>\n> I am completely unhappy with each of the following ideas. I hope you will\n> come up with smarter solutions. I believe the solution is not obvious. Thus\n> I thought it makes sense in the brainstorm phase to even post some ideas\n> with obvious drawbacks.\n>\n> 1. The current solution is to just not use up the max value of\n> htlc's. Eclaire and c-lightning by default only use up to 30 htlcs.\n> 2. Probably the best fix (not sure if I understand the consequences\n> correctly) is coming from this PR to bitcoin core (c.f.\n> https://github.com/bitcoin/bitcoin/pull/15681 by @TheBlueMatt . If I get\n> it correctly with that we could always have low fees and ask the person who\n> want to claim their outputs to pay fees. This excludes overpayment and\n> could happen at a later stage when fees are not spiked. Still the victim\n> who offered the htlcs would have to spend those outputs at some time.\n> 3. Don't overpay fees in commitment transactions. We can't foresee the\n> future anyway\n> 4. Don't add htlcs for which the on chain fee is higher than the HTLCs\n> value (like we do with sub dust amounts and sub satoshi amounts. This would\n> at least make the attack expensive as the attacker would have to bind a lot\n> of liquidity.\n> 5. Somehow be able to aggregate htlc's. In a world where we use payment\n> points instead of preimages we might be able to do so. It would be really\n> cool if separate HTLC's could be combined to 1 single output. I played\n> around a little bit but I have not come up with a scheme that is more\n> compact in all cases. Thus I just threw in the idea.\n> 6. Split onchain fees differently (now the attacker would also lose fees\n> by conducting this attack) - No I don't want to start yet another fee\n> bikeshadding debate. (In particular I believe that a different split of\n> fees might make the Flood & Loot attack economically more viable which\n> relies on the same principle)\n>\n> Independently I think we should have a hint in our readme file about where\n> and how people can disclose attacks and vulnerabilities. Implementations\n> have this but the BOLTs do not.\n>\n> with kind regards Rene\n>\n> --\n>\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200621/992826d6/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-22T14:19:20",
                "message_text_only": "On Sun, Jun 21, 2020 at 06:09:28PM -0700, Olaoluwa Osuntokun wrote:\n> IMO this is mostly mitigated by anchor commitments.  The impact of this\n> attack is predicated on the \"victim\" paying 5x on-chain fees (for their\n> confirmation target) to sweep all their HTLCs.  \n\nI think the attack is more clearly stated in absolute terms.  An\nattacker can force a victim to pay for 483 P2WSH outputs (each 43\nvbytes), or a total of about 20,000 vbytes (plus regular overhead).\n\n    20769 = 43 * 483\n\nDuring the post-halving feerate spike just a few weeks ago, paying 100\nbase units (\"satoshis\") per vbyte was plausible to ensure the commitment\ntransaction confirmed quickly.  At $9,500 USD/BTC, that's almost $200\nUSD.\n\n    197.3055 = 20769 * 100 / 1e8 * 9500\n\nWith a 5x multiplier, that's horrible, but even with no multiplier, it's\nnot good.  Moreover, a patient attacker can wait for a fee spike and\nthen attack multiple channels at once so that they compete against each\nother for block space, potentially raising feerates even higher.\n\n> In addition to being able to pay much lower fees (\"just enough\" to get into\n> the chain), anchor commitments allow second-level HTLC _aggregation_, This\n> means that for HTLCs with the same expiry height, a peer is able to _batch_\n> them all into a single transaction, further saving on fees.\n\n(I was initially confused by this, so for anyone else confused by this,\nthe batching being described here is sort of the inverse of normal\npayment batching.  Normally when you batch together multiple payments,\nyou use one input to pay more outputs than you would with separate\ntransactions.  Here, you still need to use the same number of inputs you\nwould to resolve HTLCs in separate ransactions (because each HTLC is a\nseparate UTXO), but you pay a single output.  This works and is indeed a\nnice optimization.)\n\n> Alternatively, they could use something like Lightning Loop to gain the\n> _outbound_ bandwidth (Loop In) \n\nI don't think the attacker needs outbound bandwidth.  As implied in\nRen\u00e9's post (\"achieved with circular onions\"), if the attacker is\nMallory and the victim is Bob, there just needs to be a circuit like:\n\n    Mallory \u2192 Alice \u2192 Bob \u2192 Mallory\n\nMallory can always settle with Alice offchain after Bob's timeout,\npreventing Mallory from losing any money in the attack or from having to\npay for liquidity.  IIUC, Mallory's only cost would be paying for LN\nrouting fees and the time value of locking up her money until the\nsettlement.\n\n> No, the attacker is the one that needs to sweep these HTLCs, since they\n> offered them. This adds to their costs.\n\nAs described above, the attacker doesn't need to offer the HTLCs, they\ncan simply route a payment through any of the victim's other channels.\n\nIf the attacker does that, then the victim needs to pay onchain fees to\nrecover any remaining value in those HTLCs, potentially making this\nattack two or three times more costly for the victim.\n\n> > 1. The current solution is to just not use up the max value of htlc's.\n> > Eclaire and c-lightning by default only use up to 30 htlcs.\n> \n> IMO, this isn't a solution. Lowering the max number of HTLCs in-flight just\n> makes it easier (lowers the capital costs) to jam a channel. \n\nIt looks to me like an easy and effective solution to turn a ~$200\ndownside into a ~$20 downside (at 100 base units/vbyte).  It's certainly\nhas other downsides too, but I'm personally more concerned about losing\nmoney than I am about having my channel jammed (and if jamming at 483\nHTLCs is an issue, then hopefully the mitigation for that (e.g. upfront\nfees) will make jamming at HTLCs a non-issue as well).\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200622/77824e91/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Disclosure of a fee blackmail attack that can make a victim loose almost all funds of a non Wumbo channel and potential fixes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard",
                "Jeremy",
                "Ren\u00e9 Pickhardt",
                "David A. Harding",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 87477
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] RBF Pinning with Counterparties and Competing Interest",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-19T07:44:11",
                "message_text_only": "Good morning list,\n\nSorry for being (very) late to the party on that subject, but better late\nthan never.\n\nA lot of ideas have been thrown at the problem and are scattered across\nemails, IRC discussions,\nand github issues. I've spent some time putting it all together in one\ngist, hoping that it will\nhelp stir the discussion forward as well as give newcomers all the\nbackground they need to ramp up\non this issue and join the discussion, bringing new ideas to the table.\n\nThe gist is here, and I'd appreciate your feedback if I have wrongly\ninterpreted some of the ideas:\nhttps://gist.github.com/t-bast/22320336e0816ca5578fdca4ad824d12\n\nReaders of this list can probably directly skip to the \"Future work\"\nsection. I believe my\n\"alternative proposal\" should loosely reflect Matt's proposal from the very\nfirst mail of this\nthread; note that I included anchors and new txs only in some places, as I\nthink they aren't\nnecessary everywhere.\n\nMy current state-of-mind (subject to change as I discover more potential\nattacks) is that:\n\n* The proposal to add more anchors and pre-signed txs adds non-negligible\ncomplexity and hurts\nsmall HTLCs, so it would be better if we didn't need it\n* The blind CPFP carve-out trick is a one shot, so you'll likely need to\npay a lot of fees for it\nto work which still makes you lose money in case an attacker targets you\n(but the money goes to\nminers, not to the attacker - unless he is the miner). It's potentially\nhard to estimate what fee\nyou should put into that blind CPFP carve-out because you have no idea what\nthe current fee of the\npinned success transaction package is, so it's unsure if that solution will\nreally work in practice\n* If we take a step back, the only attack we need to protect against is an\nattacker pinning a\npreimage transaction while preventing us from learning that preimage for at\nleast `N` blocks\n(see the gist for the complete explanation). Please correct me if that\nclaim is incorrect as it\nwill invalidate my conclusion! Thus if we have:\n* a high enough `cltv_expiry_delta`\n* [off-chain preimage broadcast](\nhttps://github.com/lightningnetwork/lightning-rfc/issues/783)\n(or David's proposal to do it by sending txs that can be redeemed via only\nthe preimage)\n* LN hubs (or any party commercially investing in running a lightning node)\nparticipating in\nvarious mining pools to help discover preimages\n* decent mitigations for eclipse attacks\n* then the official anchor outputs proposal should be safe enough and is\nmuch simpler?\n\nThank you for reading, I hope the work I put into this gist will be useful\nfor some of you.\n\nBastien\n\nLe ven. 24 avr. 2020 \u00e0 00:47, Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n>\n>\n> On 4/23/20 8:46 AM, ZmnSCPxj wrote:\n> >>> -   Miners, being economically rational, accept this proposal and\n> include this in a block.\n> >>>\n> >>> The proposal by Matt is then:\n> >>>\n> >>> -   The hashlock branch should instead be:\n> >>> -   B and C must agree, and show the preimage of some hash H (hashlock\n> branch).\n> >>> -   Then B and C agree that B provides a signature spending the\n> hashlock branch, to a transaction with the outputs:\n> >>> -   Normal payment to C.\n> >>> -   Hook output to B, which B can use to CPFP this transaction.\n> >>> -   Hook output to C, which C can use to CPFP this transaction.\n> >>> -   B can still (somehow) not maintain a mempool, by:\n> >>> -   B broadcasts its timelock transaction.\n> >>> -   B tries to CPFP the above hashlock transaction.\n> >>> -   If CPFP succeeds, it means the above hashlock transaction exists\n> and B queries the peer for this transaction, extracting the preimage and\n> claiming the A->B HTLC.\n> >>\n> >> Note that no query is required. The problem has been solved and the\n> preimage-containing transaction should now confirm just fine.\n> >\n> > Ah, right, so it gets confirmed and the `blocksonly` B sees it in a\n> block.\n> >\n> > Even if C hooks a tree of low-fee transactions on its hook output or\n> normal payment, miners will still be willing to confirm this and the B hook\n> CPFP transaction without, right?\n>\n> Correct, once it makes it into the mempool we can CPFP it and all the\n> regular sub-package CPFP calculation will pick it\n> and its descendants up. Of course this relies on it not spending any other\n> unconfirmed inputs.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200619/70e88f70/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-19T19:58:46",
                "message_text_only": "On Fri, Jun 19, 2020 at 09:44:11AM +0200, Bastien TEINTURIER via Lightning-dev wrote:\n> The gist is here, and I'd appreciate your feedback if I have wrongly\n> interpreted some of the ideas:\n> https://gist.github.com/t-bast/22320336e0816ca5578fdca4ad824d12\n\nQuoted text below is from the gist:\n\n> The trick to protect against a malicious participant that broadcasts a\n> low-fee HTLC-success or Remote-HTLC-success transaction is that we can\n> always blindly do a CPFP carve-out on them; we know their txid\n\nI think you're assuming here that the attacker broadcast a particular\nstate.  However, in a channel which potentially had thousands of state\nchanges, you'd have to broadcast a blind child for each previous state\n(or at least each previous state that pays the attacker more than the\nlatest state).  That's potentially thousands of transactions times\npotentially dozens of peers---not impossible, but it seems messy.\n\nI think there's a way to accomplish the same goal for less bandwidth and\nzero fees.  The only way your Bitcoin peer will relay your blind child\nis if it already has the parent transaction.  If it has the parent, you\ncan just request it using P2P getdata(type='tx', id=$txid).[1]  You can\nbatch multiple txid requests together (up to 50,000 IIRC) to minimize\noverhead, making the average cost per txid a tiny bit over 36 bytes.\nIf you receive one of the transactions you request, you can extract the\npreimage at no cost to yourself (except bandwidth).  If you don't\nreceive a transaction, then sending a blind child is hopeless\nanyway---your peers won't relay it.\n\nOverall, it's hard for me to guess how effective your proposal would be\nat defeating the attack.  I think the strongman argument for the attack\nwould be that the attacker will be able to perform a targeted relay of\ntheir outdated state to just miners---everyone else on the network\nwill receive the counterparty's honest final-state close.  Unless the\ncounterparty happens to have a connection to a miner's node, the\ncounterparty will neither be able to CPFP fee bump nor use getdata to\nretrieve the preimage.\n\nIt seems to me it's practical for a motivated attacker to research which\nIP addresses belong to miners so that they can target them, whereas\nhonest users won't practically be able to do that research (and, even if\nthey could, it would create a centralizing barrier to new miners\nentering the market if users focused on maintaining connections to\npreviously-known miners).\n\n-Dave\n\n[1] You'd have to be careful to not attempt the getdata too soon after\n    you think the attacker broadcast their old state, but I think that\n    only means waiting a single block, which you have to do anyway to\n    see if the honest final-commitment transaction confirmed.  See\n    https://github.com/bitcoin/bitcoin/pull/18861\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200619/09974bd2/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-19T20:52:20",
                "message_text_only": "On Fri, Jun 19, 2020 at 03:58:46PM -0400, David A. Harding via bitcoin-dev wrote:\n> I think you're assuming here that the attacker broadcast a particular\n> state.  \n\nWhoops, I managed to confuse myself despite looking at Bastien's\nexcellent explainer.  The attacker would be broadcasting the latest\nstate, so the honest counterparty would only need to send one blind\nchild.  However, the blind child will only be relayed by a Bitcoin peer\nif the peer also has the parent transaction (the latest state) and, if\nit has the parent transaction, you should be able to just getdata('tx',\n$txid) that transaction from the peer without CPFPing anything.  That\nwill give you the preimage and so you can immediately resolve the HTLC\nwith the upstream channel.\n\nRevising my conclusion from the previous post:\n\nI think the strongman argument for the attack would be that the attacker\nwill be able to perform a targeted relay of the low-feerate\npreimage-containing transaction to just miners---everyone else on the\nnetwork will receive the honest user's higher-feerate expired-timelock\ntransaction.  Unless the honest user happens to have a connection to a\nminer's node, the user will neither be able to CPFP fee bump nor use\ngetdata to retrieve the preimage.\n\nSorry for the confusion.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200619/917b77aa/attachment.sig>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-20T08:54:03",
                "message_text_only": "Hello Dave and list,\n\nThanks for your quick answers!\n\nThe attacker would be broadcasting the latest\n> state, so the honest counterparty would only need to send one blind\n> child.\n>\n\nExactly, if the attacker submits an outdated transaction he would be\nshooting himself in the foot,\nas we could claim the revocation paths when seeing the transaction in a\nblock and get all the\nchannel funds (since the attacker's outputs will be CSV-locked).\n\nThe only way your Bitcoin peer will relay your blind child\n> is if it already has the parent transaction.\n>\n\nThat's an excellent point that I missed in the blind CPFP carve-out trick!\nI think this makes the\nblind CPFP carve-out quite hard in practice (even using getdata - thanks\nfor detailing that option)...\n\nIn the worst case scenario where most miners' mempools contain the\nattacker's tx and the rest of\nthe network's mempools contains the honest participant's tx, I think there\nisn't much we can do.\nWe're simply missing information, so it looks like the only good solution\nis to avoid being in that\nsituation by having a foot in miners' mempools. Do you think it's\nunreasonable to expect at least\nsome LN nodes to also invest in running nodes in mining pools, ensuring\nthat they learn about\nattackers' txs and can potentially share discovered preimages with the\nnetwork off-chain (by\ngossiping preimages found in the mempool over LN)? I think that these\nrecent attacks show that\nwe need (at least some) off-chain nodes to be somewhat heavily invested in\non-chain operations\n(layers can't be fully decoupled with the current security assumptions -\nmaybe Eltoo will help\nchange that in the future?).\n\nThank you for your time!\nBastien\n\n\n\nLe ven. 19 juin 2020 \u00e0 22:53, David A. Harding <dave at dtrt.org> a \u00e9crit :\n\n> On Fri, Jun 19, 2020 at 03:58:46PM -0400, David A. Harding via bitcoin-dev\n> wrote:\n> > I think you're assuming here that the attacker broadcast a particular\n> > state.\n>\n> Whoops, I managed to confuse myself despite looking at Bastien's\n> excellent explainer.  The attacker would be broadcasting the latest\n> state, so the honest counterparty would only need to send one blind\n> child.  However, the blind child will only be relayed by a Bitcoin peer\n> if the peer also has the parent transaction (the latest state) and, if\n> it has the parent transaction, you should be able to just getdata('tx',\n> $txid) that transaction from the peer without CPFPing anything.  That\n> will give you the preimage and so you can immediately resolve the HTLC\n> with the upstream channel.\n>\n> Revising my conclusion from the previous post:\n>\n> I think the strongman argument for the attack would be that the attacker\n> will be able to perform a targeted relay of the low-feerate\n> preimage-containing transaction to just miners---everyone else on the\n> network will receive the honest user's higher-feerate expired-timelock\n> transaction.  Unless the honest user happens to have a connection to a\n> miner's node, the user will neither be able to CPFP fee bump nor use\n> getdata to retrieve the preimage.\n>\n> Sorry for the confusion.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200620/6caf18ec/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-06-20T10:36:47",
                "message_text_only": "On Sat, Jun 20, 2020 at 10:54:03AM +0200, Bastien TEINTURIER wrote:\n> We're simply missing information, so it looks like the only good\n> solution is to avoid being in that situation by having a foot in\n> miners' mempools.\n\nThe problem I have with that approach is that the incentive is to\nconnect to the highest hashrate pools and ignore the long tail of\nsmaller pools and solo miners.  If miners realize people are doing this,\nthey may begin to charge for information about their mempool and the\nlargest miners will likely be able to charge more money per hashrate\nthan smaller miners, creating a centralization force by increasing\nexisting economies of scale.\n\nWorse, information about a node's mempool is partly trusted.  A node can\neasily prove what transactions it has, but it can't prove that it\ndoesn't have a certain transaction.  This implies incumbent pools with a\nlong record of trustworthy behavior may be able to charge more per\nhashrate than a newer pools, creating a reputation-based centralizing\nforce that pushes individual miners towards well-established pools.\n\nThis is one reason I suggested using independent pay-to-preimage\ntransactions[1].  Anyone who knows the preimage can mine the\ntransaction, so it doesn't provide reputational advantage or direct\neconomies of scale---pay-to-preimage is incentive equivalent to paying\nnormal onchain transaction fees.  There is an indirect economy of\nscale---attackers are most likely to send the low-feerate\npreimage-containing transaction to just the largest pools, so small\nminers are unlikely to learn the preimage and thus unlikely to be able\nto claim the payment.  However, if the defense is effective, the attack\nshould rarely happen and so this should not have a significant effect on\nmining profitability---unlike monitoring miner mempools which would have\nto be done continuously and forever.\n\nZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2]  I was\nhoping one of Bitcoin's several inventive cryptographers would come\nalong and describe how someone with an adaptor signature could use that\ninformation to create a pubkey that could be put into a transaction with\na second output that OP_RETURN included the serialized adaptor\nsignature.  The pubkey would be designed to be spendable by anyone with\nthe final signature in a way that revealed the hidden value to the\npubkey's creator, allowing them to resolve the PTLC.  But if that's\nfundamentally not possible, I think we could advocate for making\npay-to-revealed-adaptor-signature possible using something like\nOP_CHECKSIGFROMSTACK.[3]\n\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\n[2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002667.html\n[3] https://bitcoinops.org/en/topics/op_checksigfromstack/\n\n> Do you think it's unreasonable to expect at least some LN nodes to\n> also invest in running nodes in mining pools, ensuring that they learn\n> about attackers' txs and can potentially share discovered preimages\n> with the network off-chain (by gossiping preimages found in the\n> mempool over LN)?\n\nIgnoring my concerns about mining centralization and from the\nperspective of just the Lightning Network, that doesn't sound\nunreasonable to me.  But from the perspective of a single LN node, it\nmight make more sense to get the information and *not* share it,\nincreasing your security and allowing you to charge lower routing fees\ncompared to your competitors.  This effect would only be enhanced if\nminers charged for their mempool contents (indeed, to maximize their\nrevenue, miners might require that their mempool subscribers don't share\nthe information---which they could trivially enforce by occasionally\nsending subscribers a preimage specific to the subscriber and seeing if\nit propagated to the public network).\n\n> I think that these recent attacks show that we need (at least some)\n> off-chain nodes to be somewhat heavily invested in on-chain operations\n> (layers can't be fully decoupled with the current security assumptions\n> - maybe Eltoo will help change that in the future?).\n\nI don't see how eltoo helps.  Eltoo helps ensure you reach the final\nchannel state, but this problem involves an abuse of that final state.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200620/6085153a/attachment-0001.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-20T16:01:16",
                "message_text_only": "Good morning Dave,\n\n> ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2] I was\n> hoping one of Bitcoin's several inventive cryptographers would come\n> along and describe how someone with an adaptor signature could use that\n> information to create a pubkey that could be put into a transaction with\n> a second output that OP_RETURN included the serialized adaptor\n> signature. The pubkey would be designed to be spendable by anyone with\n> the final signature in a way that revealed the hidden value to the\n> pubkey's creator, allowing them to resolve the PTLC. But if that's\n> fundamentally not possible, I think we could advocate for making\n> pay-to-revealed-adaptor-signature possible using something like\n> OP_CHECKSIGFROMSTACK.[3]\n\n\nNot a cryptographer, I just play one on the Internet, but maybe the pay-for-signature construction could work...?\n\nAssuming a PTLC has a pointlocked branch, which involves signing with MuSig(A, B).\nA offers to B the amount if B reveals the secret `t` behind `T = t * G`; A knows `T` but not `t`.\nThis is done by B handing over `R[B]` and `s'[B]`:\n\n    R = R[A] + R[B] + T\n    s'[B] = r[B] + h(MuSig(A, B) | R | m) * b\n\nThen A provides its partial signature to B.\n\n    s[A] = r[A] + h(MuSig(A, B) | R | m) * a\n\nB has to complete the signature by:\n\n    s = s[A] + s'[B] + t\n\nSince A knows both `s[A]` and `s'[B]`, once it knows `s`, it can compute `t`.\n\n\nNow, we can massage the equation for `s`:\n\n    s = r[A] + h(MuSig(A, B) | R | m) * a + r[B] + h(MuSig(A, B) | R | m) * b + t\n    ; multiply both sides by G\n    s * G = r[A] * G + h(MuSig(A, B) | R | m) * a * G + r[B] * G + h(MuSig(A, B) | R | m) * b * G + t * G\n    ; replace with public points\n    s * G = R[A] + h(MuSig(A, B) | R | m) * A + R[B] + h(MuSig(A, B) | R | m) * B + T\n\nNote that A can compute `s * G` above, because it generated `R[A]`, was given `R[B]` and `T`, and knows who `A` and `B` are.\n\nSo what A needs to do is to offer a fund that can only be claimed by leaking knowledge of `s` behind `s * G`.\nA can do this by creating a new keypair `A[p4s] = a[p4s] * G` and putting a fund into it.\n\nThen A generates an `R[A][p4s] = r[A][p4s] * G`, and computes:\n\n    R[p4s] = R[A][p4s] + s * G\n    s'[A][p4s] = r[A][p4s] + h(A | R[p4s] | m) * a[p4s]\n\nThe signed message could be a signature to `SIGHASH_NONE`, finally an actual use for that flag.\n\nA reveals publicly (in an `OP_RETURN` as you suggest):\n\n* `R[A][p4s]`\n* `s * G`\n* `s'[A][p4s]`\n* `A[p4s]` - Already the Schnorr output pubkey.\n\nIn order to complete the above signature, a third party C has to learn `s` from B.\n\nThe third party has to scan every onchain 1-of-1 signature for an `s` that matches `s * G`, so there is greater processing (point multiplies are more expensive than hashes, also there are more 1-of-1s).\nBut once learned, the third party can complete the signature and claim the funds.\nAnd A then learns `s`, from which it can derive `t`.\n\nThe third party learns about which channel (i.e. the UTXO that was spent to create the PTLC in the first place), but never learns `t` or `T`, which is a small but nice privacy bonus.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-21T02:10:32",
                "message_text_only": "Good morning again,\n\n> Good morning Dave,\n>\n> > ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2] I was\n> > hoping one of Bitcoin's several inventive cryptographers would come\n> > along and describe how someone with an adaptor signature could use that\n> > information to create a pubkey that could be put into a transaction with\n> > a second output that OP_RETURN included the serialized adaptor\n> > signature. The pubkey would be designed to be spendable by anyone with\n> > the final signature in a way that revealed the hidden value to the\n> > pubkey's creator, allowing them to resolve the PTLC. But if that's\n> > fundamentally not possible, I think we could advocate for making\n> > pay-to-revealed-adaptor-signature possible using something like\n> > OP_CHECKSIGFROMSTACK.[3]\n>\n> <snip>\n>\n> The signed message could be a signature to `SIGHASH_NONE`, finally an actual use for that flag.\n\nIf you are going to embed it in an `OP_RETURN` in the same transaction, you also need `SIGHASH_ANYPREVOUT`, otherwise you cannot embed the adaptor signature for spending from that transaction in the transaction being spent, it also implies `A[p4s] = a[p4s] * G` is a one-time-use keypair.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-22T07:35:20",
                "message_text_only": "Thanks for the detailed write-up on how it affects incentives and\ncentralization,\nthese are good points. I need to spend more time thinking about them.\n\nThis is one reason I suggested using independent pay-to-preimage\n> transactions[1]\n>\n\nWhile this works as a technical solution, I think it has some incentives\nissues too.\nIn this attack, I believe the miners that hide the preimage tx in their\nmempool have\nto be accomplice with the attacker, otherwise they would share that tx with\nsome of\ntheir peers, and some non-miner nodes would get that preimage tx and be\nable to\ngossip them off-chain (and even relay them to other mempools).\n\nIf they are actively helping the attacker, they wouldn't spend the\npay-to-preimage tx,\nunless they gain more from it than the share the attacker gives them. This\nbecomes\na simple bidding war, and the honest user will always be the losing party\nhere (the\nattacker has nothing to lose). For this reason I'm afraid it wouldn't work\nout in practice\nas well as we'd hope...what do you think? And even if the honest user wins\nthe bidding\nwar, the attack still steals money from that user; it just goes into the\nminer's pocket.\n\nBut from the perspective of a single LN node, it\n> might make more sense to get the information and *not* share it\n>\n\nI think it depends. If this attack becomes doable in practice and we see it\nhappening,\nLN routing nodes and service providers have a very high incentive to thwart\nthese attacks,\nbecause otherwise they'd lose their business as people would leave the\nlightning network.\n\nAs long as enough nodes think that way (with \"enough\" being a very hard to\ndefine quantity),\nthis should mitigate the attack. The only risk would be a big \"exit scam\"\nscenario, but the\ncoordination cost between all these nodes makes that scenario unlikely\n(IMHO).\n\nThanks,\nBastien\n\nLe sam. 20 juin 2020 \u00e0 12:37, David A. Harding <dave at dtrt.org> a \u00e9crit :\n\n> On Sat, Jun 20, 2020 at 10:54:03AM +0200, Bastien TEINTURIER wrote:\n> > We're simply missing information, so it looks like the only good\n> > solution is to avoid being in that situation by having a foot in\n> > miners' mempools.\n>\n> The problem I have with that approach is that the incentive is to\n> connect to the highest hashrate pools and ignore the long tail of\n> smaller pools and solo miners.  If miners realize people are doing this,\n> they may begin to charge for information about their mempool and the\n> largest miners will likely be able to charge more money per hashrate\n> than smaller miners, creating a centralization force by increasing\n> existing economies of scale.\n>\n> Worse, information about a node's mempool is partly trusted.  A node can\n> easily prove what transactions it has, but it can't prove that it\n> doesn't have a certain transaction.  This implies incumbent pools with a\n> long record of trustworthy behavior may be able to charge more per\n> hashrate than a newer pools, creating a reputation-based centralizing\n> force that pushes individual miners towards well-established pools.\n>\n> This is one reason I suggested using independent pay-to-preimage\n> transactions[1].  Anyone who knows the preimage can mine the\n> transaction, so it doesn't provide reputational advantage or direct\n> economies of scale---pay-to-preimage is incentive equivalent to paying\n> normal onchain transaction fees.  There is an indirect economy of\n> scale---attackers are most likely to send the low-feerate\n> preimage-containing transaction to just the largest pools, so small\n> miners are unlikely to learn the preimage and thus unlikely to be able\n> to claim the payment.  However, if the defense is effective, the attack\n> should rarely happen and so this should not have a significant effect on\n> mining profitability---unlike monitoring miner mempools which would have\n> to be done continuously and forever.\n>\n> ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2]  I was\n> hoping one of Bitcoin's several inventive cryptographers would come\n> along and describe how someone with an adaptor signature could use that\n> information to create a pubkey that could be put into a transaction with\n> a second output that OP_RETURN included the serialized adaptor\n> signature.  The pubkey would be designed to be spendable by anyone with\n> the final signature in a way that revealed the hidden value to the\n> pubkey's creator, allowing them to resolve the PTLC.  But if that's\n> fundamentally not possible, I think we could advocate for making\n> pay-to-revealed-adaptor-signature possible using something like\n> OP_CHECKSIGFROMSTACK.[3]\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\n> [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002667.html\n> [3] https://bitcoinops.org/en/topics/op_checksigfromstack/\n>\n> > Do you think it's unreasonable to expect at least some LN nodes to\n> > also invest in running nodes in mining pools, ensuring that they learn\n> > about attackers' txs and can potentially share discovered preimages\n> > with the network off-chain (by gossiping preimages found in the\n> > mempool over LN)?\n>\n> Ignoring my concerns about mining centralization and from the\n> perspective of just the Lightning Network, that doesn't sound\n> unreasonable to me.  But from the perspective of a single LN node, it\n> might make more sense to get the information and *not* share it,\n> increasing your security and allowing you to charge lower routing fees\n> compared to your competitors.  This effect would only be enhanced if\n> miners charged for their mempool contents (indeed, to maximize their\n> revenue, miners might require that their mempool subscribers don't share\n> the information---which they could trivially enforce by occasionally\n> sending subscribers a preimage specific to the subscriber and seeing if\n> it propagated to the public network).\n>\n> > I think that these recent attacks show that we need (at least some)\n> > off-chain nodes to be somewhat heavily invested in on-chain operations\n> > (layers can't be fully decoupled with the current security assumptions\n> > - maybe Eltoo will help change that in the future?).\n>\n> I don't see how eltoo helps.  Eltoo helps ensure you reach the final\n> channel state, but this problem involves an abuse of that final state.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200622/09e39b02/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-06-22T08:15:37",
                "message_text_only": "Good morning Bastien,\n\n> Thanks for the detailed write-up on how it affects incentives and centralization,\n> these are good points. I need to spend more time thinking about them.\n>\n> > This is one reason I suggested using independent pay-to-preimage\n> > transactions[1]\n>\n> While this works as a technical solution, I think it has some incentives issues too.\n> In this attack, I believe the miners that hide the preimage tx in their mempool have\n> to be accomplice with the attacker, otherwise they would share that tx with some of\n> their peers, and some non-miner nodes would get that preimage tx and be able to\n> gossip them off-chain (and even relay them to other mempools).\n\nI believe this is technically possible with current mempool rules, without miners cooperating with the attacker.\n\nBasically, the attacker releases two transactions with near-equal fees, so that neither can RBF the other.\nIt releases the preimage tx near miners, and the timelock tx near non-miners.\n\nNodes at the boundaries between those that receive the preimage tx and the timelock tx will receive both.\nHowever, they will receive one or the other first.\nWhich one they receive first will be what they keep, and they will reject the other (and *not* propagate the other), because the difference in fees is not enough to get past the RBF rules (which requires not just a feerate increase, but also an increase in absolute fee, of at least the minimum relay feerate times transaction size).\n\nBecause they reject the other tx, they do not propagate the other tx, so the boundary between the two txes is inviolate, neither can get past that boundary, this occurs even if everyone is running 100% unmodified Bitcoin Core code.\n\nI am not a mempool expert and my understanding may be incorrect.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-06-22T08:25:09",
                "message_text_only": "Hey ZmnSCPxj,\n\nI agree that in theory this looks possible, but doing it in practice with\naccurate control\nof what parts of the network get what tx feels impractical to me (but maybe\nI'm wrong!).\n\nIt feels to me that an attacker who would be able to do this would break\n*any* off-chain\nconstruction that relies on absolute timeouts, so I'm hoping this is\ninsanely hard to\nachieve without cooperation from a miners subset. Let me know if I'm too\noptimistic on\nthis!\n\nCheers,\nBastien\n\nLe lun. 22 juin 2020 \u00e0 10:15, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning Bastien,\n>\n> > Thanks for the detailed write-up on how it affects incentives and\n> centralization,\n> > these are good points. I need to spend more time thinking about them.\n> >\n> > > This is one reason I suggested using independent pay-to-preimage\n> > > transactions[1]\n> >\n> > While this works as a technical solution, I think it has some incentives\n> issues too.\n> > In this attack, I believe the miners that hide the preimage tx in their\n> mempool have\n> > to be accomplice with the attacker, otherwise they would share that tx\n> with some of\n> > their peers, and some non-miner nodes would get that preimage tx and be\n> able to\n> > gossip them off-chain (and even relay them to other mempools).\n>\n> I believe this is technically possible with current mempool rules, without\n> miners cooperating with the attacker.\n>\n> Basically, the attacker releases two transactions with near-equal fees, so\n> that neither can RBF the other.\n> It releases the preimage tx near miners, and the timelock tx near\n> non-miners.\n>\n> Nodes at the boundaries between those that receive the preimage tx and the\n> timelock tx will receive both.\n> However, they will receive one or the other first.\n> Which one they receive first will be what they keep, and they will reject\n> the other (and *not* propagate the other), because the difference in fees\n> is not enough to get past the RBF rules (which requires not just a feerate\n> increase, but also an increase in absolute fee, of at least the minimum\n> relay feerate times transaction size).\n>\n> Because they reject the other tx, they do not propagate the other tx, so\n> the boundary between the two txes is inviolate, neither can get past that\n> boundary, this occurs even if everyone is running 100% unmodified Bitcoin\n> Core code.\n>\n> I am not a mempool expert and my understanding may be incorrect.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200622/67840048/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-06-24T08:32:52",
                "message_text_only": "Given transaction relay delays and a network topology that is rather transparent if you look closely enough, I think this is very real and very practical (double-digit % success rate, at least, with some trial and error probably 50+). That said, we all also probably know most of the people who know enough to go from zero to doing this practically next week. As for motivated folks who have lots of time to read code and dig, this seems like something worth fixing in the medium term.\n\nYour observation is what\u2019s largely led me to conclude there isn\u2019t a lot we can do here without a lot of creativity and fundamental rethinking of our approach. One thing I keep harping on is maybe saving the blind-CPFP approach with a) eltoo, and b) some kind of magic transaction relay metadata that allows you to specify \u201cthis spends at least one output on any transaction that spends output X\u201d so that nodes can always apply it properly. But maybe that\u2019s a pipedream of complexity. I know Antoine has other thoughts.\n\nMatt\n\n> On Jun 22, 2020, at 04:04, Bastien TEINTURIER via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeff\n> Hey ZmnSCPxj,\n> \n> I agree that in theory this looks possible, but doing it in practice with accurate control\n> of what parts of the network get what tx feels impractical to me (but maybe I'm wrong!).\n> \n> It feels to me that an attacker who would be able to do this would break *any* off-chain\n> construction that relies on absolute timeouts, so I'm hoping this is insanely hard to\n> achieve without cooperation from a miners subset. Let me know if I'm too optimistic on\n> this!\n> \n> Cheers,\n> Bastien\n> \n>> Le lun. 22 juin 2020 \u00e0 10:15, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n>> Good morning Bastien,\n>> \n>> > Thanks for the detailed write-up on how it affects incentives and centralization,\n>> > these are good points. I need to spend more time thinking about them.\n>> >\n>> > > This is one reason I suggested using independent pay-to-preimage\n>> > > transactions[1]\n>> >\n>> > While this works as a technical solution, I think it has some incentives issues too.\n>> > In this attack, I believe the miners that hide the preimage tx in their mempool have\n>> > to be accomplice with the attacker, otherwise they would share that tx with some of\n>> > their peers, and some non-miner nodes would get that preimage tx and be able to\n>> > gossip them off-chain (and even relay them to other mempools).\n>> \n>> I believe this is technically possible with current mempool rules, without miners cooperating with the attacker.\n>> \n>> Basically, the attacker releases two transactions with near-equal fees, so that neither can RBF the other.\n>> It releases the preimage tx near miners, and the timelock tx near non-miners.\n>> \n>> Nodes at the boundaries between those that receive the preimage tx and the timelock tx will receive both.\n>> However, they will receive one or the other first.\n>> Which one they receive first will be what they keep, and they will reject the other (and *not* propagate the other), because the difference in fees is not enough to get past the RBF rules (which requires not just a feerate increase, but also an increase in absolute fee, of at least the minimum relay feerate times transaction size).\n>> \n>> Because they reject the other tx, they do not propagate the other tx, so the boundary between the two txes is inviolate, neither can get past that boundary, this occurs even if everyone is running 100% unmodified Bitcoin Core code.\n>> \n>> I am not a mempool expert and my understanding may be incorrect.\n>> \n>> Regards,\n>> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200624/7a0b11e4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "RBF Pinning with Counterparties and Competing Interest",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "David A. Harding",
                "Matt Corallo",
                "ZmnSCPxj"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 36321
        }
    },
    {
        "title": "[Lightning-dev] Pinning : The Good, The Bad, The Ugly",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2020-06-29T00:13:03",
                "message_text_only": "(tl;dr Ideally network mempools should be an efficient marketplace leading\nto discovery of best-feerate blockspace demand by miners. It's not due to\ncurrent anti-DoS rules assumptions and it's quite harmful for shared-utxo\nprotocols like LN)\n\nHello all,\n\nLightning security model relies on the unilateral capability for a channel\nparticipant to confirm transactions, like timing out an outgoing HTLC,\nclaiming an incoming HTLC or punishing a revoked commitment transaction and\nthus enforcing onchain a balance negotiated offchain. This security model\nis actually turning back the double-spend problem to a private matter,\nmaking the duty of each channel participant to timely enforce its balance\nagainst the competing interest of its counterparties. Or laid out\notherwise, contrary to a miner violating a consensus rules, base layer\npeers don't care about your LN node failing to broadcast a justice\ntransaction before the corresponding timelock expiration (CSV delay).\n\nEnsuring effective propagation and timely confirmation of LN transactions\nis so a critical-safety operation.  Its efficiency should be always\nevaluated with regards to base layer network topology, tx-relay propagation\nrules, mempools behaviors, consistent policy applied by majority of nodes\nand ongoing blockspace demand. All these components are direct parameters\nof LN security. Due to the network being public, a malicious channel\ncounterparty do have an incentive to tweak them to steal from you.\n\nThe pinning attacks which have been discussed since a few months are a\ndirect illustration of this model. Before digging into each pinning\nscenario, few properties of the base layer components should be evocated\n[0].\n\nNetwork mempools aren't guaranteed to be convergent, the local order of\nevents determines the next events accepted. I.e Alice may observe tx X, tx\nY, tx Z and Bob may observe tx Z, tx X, tx Y. If tx Z disable-RBF and tx X\ntry to replace Z, Alice accepts X and Bob rejects it. This divergence may\npersevere until a new block.\n\nTx-relay topology can be observed by spying nodes [1]. An attacker can\nexploit this fact to partition network mempools in different subset and\nhamper propagation across them of same-spending output concurrent\ntransactions. If subset X observes Alice commitment transaction and subset\nY observes Bob commitment transaction, Alice's HTLC-timeout spending her\ncommitment won't propagate beyond the X-Y set boundaries. An attacker can\nalways win the propagation race through massive connections or bypassing\ntx-relay privacy timers.\n\nMiners mempools are likely identifiable, you could announce a series of\nconflicting transactions to different subsets of the network and observe\n\"tainted\" block composition to assign to each subset a miner mempool. I'm\nnot aware of any research on this, but it sounds plausible to identify all\npower-miner mempool, i.e the ones likely to mine a block during the block\ndelay of the timelock you're looking to exploit. If you can't bid a\ntransaction in such miner mempools your channel state will stale and your\nfunds may be in danger.\n\n### Scenario 1) HTLC-Preimage Pinning\n\nAs Matt previously explained in his original mail on RBF-pinning, a\nmalicious counterparty has an interest to pin a low-feerate HTLC-preimage\ntransaction in some network mempools and thus preventing a honest\nHTLC-timeout to confirm. For details, refer to Optech newsletter [2].\n\nThis scenario doesn't bear any risk to the attacker, is easy to execute and\nhas double-digit rate of success. You don't assume network topologies\nmanipulation, mempools partitions or LN-node-to-full-node mapping [3] That\nsaid this should be solved by implementing and deploying anchor outputs,\nwhich effectively allows a party to unilaterally bump feerate of its\nHTLC-timeout transactions.\n\n### The Anchor Output Proposal\n\nAnchor Output proposal is a current spec object implemented by the LN dev\ncommunity, it introduces the ability to _unilaterally_ and _dynamically_\nbump feerate of any commitment transaction. It also opened the way to bump\nlocal 2nd-stage transactions.\n\nBeyond solving scenario 1), it makes LN node safe with regards to\nunexpected mempool congestion. If your commitment transaction is stucking\nin network mempools you can bump its feerate by attaching a CPFP on the new\n`to_local` anchor. If the remote commitment gets stuck in network mempools,\nyou're able to bump it by attaching a CPFP on the `to_remote` anchor. This\nshould keep your safe against an unresponsive or lazy counterparty in case\nof onchain funds to claim.\n\nIMO, it comes with a trade-off as it introduces a mapping oracle, i.e a\nlinking vector between a LN node and its full-node. In this case, a spying\nnode may establish a dummy, low-value channel with a probed LN node, break\nit by broadcasting thousands of different versions of the (revoked)\ncommitment and observes which one broadcast a CPFP first on the p2p layer.\nObviously, you can mitigate it by not chasing after low-value HTLC, but\nthat is a small risk of money loss. As of today,  this oracle can be seen\nas acceptable as we have other ones and we may get rid of it in the future.\n\n### Scenario 2a) Revoked Commitment Transaction Pinning\n\nDigging further, we found that there are more concerning scenarios of\npinning, at the commitment-tx level. At a period of low-feerate, a\nmalicious party incessantly updates a channel until to obtain ~10k revoked\ncommitment transactions.\n\nAt a period of mempool-congestion, by having setup a fine-grained\n`dust_limit_satoshis` and at same-time circulary routing HTLCs, our\nmalicious party can inflate absolute fee of its own commitment bounded\nwhile breaking channel in the middle of an update sequence, ensuring it has\na higher-fee than the commitment of the honest counterparty. As channel\nopener, the attacker has the amplitude of malleating the victim's\ncommitment such to keep it equal or under revoked feerate.\n\nThen our malicious party broadcast to each base layer public peer one of\nthe revoked commitment transactions, that way partitioning the network\nmempools in 10k subset. Even assuming anchor output a honest LN node won't\nbe able to confirm the remote commitment through a CPFP, this one failing\nto cross subset boundaries, the parent txid being different at each.\n\nBroadcasting the honest commitment transaction will fail, its feerate being\nknown and malleable it won't RBF already-in-mempool remote commitment\ntransactions. This prevents an honest party to timely timeout an outgoing\nHTLC or an incoming HTLC.\n\nThis scenario does bear a low-risk to the attacker, is easy to execute and\nhas a likely double-digit rate of success once you tune feerate\nmalleability. You assume mempools partitions but not any network topologies\ndiscovery. We underscore there is no current p2p/mempool mechanism to learn\nabout conflicting transactions, even learning about near-topology conflicts\ndon't guarantee you that a propagation path is uniform to make your CPFP\nsuccessful.\n\n### Scenario 2b) Previous-Latest Commitment Transaction Pinning\n\nA variant of commitment-tx pinning is to rely only on valid commitment\ntransactions. Channel update sequence not being atomic, you can legally own\n2 valid commitment transactions. An attacker can successfully map a\nLN-node's full-node and such, announce one of them and the other one to the\nrest of the network. A honest peer will fail to leverage the `to_remote`\nanchor output as its CPFP won't propagate again over network mempools\npartitions.\n\nThis scenario doesn't bear a risk to the attacker, is medium to execute and\nhas a likely double-digit rate of success. You assume mempools partitions\nand inter-layer mapping. How hard is it to map a LN-node to a full-node ?\nActually you can use the fact that a LN-node's full-node is monitoring the\nmempool for a preimage of interest and observe the announcement of such\npreimage on the offchain layer. As post-anchor HTLC-Success transactions\nare malleable you can once again create mass-conflicts to isolate the\nfull-node and improve the probe with high certainty.\n\n### Where Package Relay helps\n\nSolving scenario 2a) and 2b) in the most efficient way is likely to require\npackage relay support on the Core side. Package relay would extend the\nnotion of a mempool package (topologically ordered bundles of transactions)\nto introduce a new class of p2p traffic. So far its implementation has been\ndelayed due to refactoring mempool internals, ensuring a DoS-robust design\nand a p2p PR pipeline already congested.\n\nOnce deployed, a LN node would be able to join a commitment transaction and\na CPFP together and make them evaluated atomically by network mempools such\nto evict any malicious remote commitment assuming a higher feerate.\n\n### Scenario 3) Network-Topology-Aware Pinning for Propagation Obstruction\n\nLet's assume the following base layer tx-relay topology:\n\n                Alice ---> Bob ---> Caroll\n\nAlice wants to send her package relay to Caroll the miner to get her\ncommitment transaction confirmed. A malicious counterparty could throw\nremote commitment W in Bob mempool and remote commitment X in Caroll\nmempool. Transaction W would be attached to a high-fee CPFP Y. Transaction\nX would be attached to a low-fee CPFP Z such that X pins in Caroll mempool.\nCPFP Y and CPFP Z would be crafted such as both incorporating a conflicting\nparent to prevent Bob and Caroll mempool convergence. It looks like the\nfollowing:\n\nBob's mempool:\ntx W ---> tx Y\nparent 1 ---> tx Y\n\nCaroll's mempool:\ntx X ---> tx Z\nparent 2 ---> tx Z\n\nBob's mempool would announce and send package \"tx W + tx Y + parent 1\" to\nCaroll's one and due to parent 1 and parent 2 spending the same output\npackage would be rejected. High-fee package W will prevent Alice to\nsuccessfully broadcast her package to Caroll. This fee can be higher than\nthe maximum one that Alice would pay to confirm her transaction, as due to\nconflicts, it won't be _effectively_ paid by the malicious counterparty.\n\nThis scenario does bear a risk to the attacker only if miner mempools\nhaven't been well-mapped and high-fee package leak into them, is hard to\nexecute but has a likely double-digit rate of success. It assumes mempool\npartitions, network topology knowledge and inter-layer mapping.\n\n### Current Mempool Design Flaws in the lights of Contracting Applications\nwith Competing Interests\n\nScenario 3) does illustrate a current flaw of mempool with regards to\ncontracting applications with competing interests. A counterparty can\nleverage network propagation rules to prevent miners' mempools to discover\nthe best feerate package and thus not having to pay the real fee price to\nsuccessfully obstrucate broadcast of honest package relay spending the same\noutput.\n\nThese network propagation rules, namely RBF opt-in, have been designed to\nprotect network mempools against any DoS but don't protect a single-party\nagainst its shared-utxo co-owners. Amending these rules to enable\nmempool-convergence based on feerate will enable a honest bid market for\ncontracting applications and ensure network-wise higher feerate. Getting\nthis right will require significant study as you may allow total mempool\nfees to decrease when the transactions are near the bottom of the mempool.\nAt first sight, it sounds incentives-compatible, as miner a) gets the\nhighest fee bid b) an attacker does have to compete on feerate to attempt\nstealing.\n\nAssuming a basic package relay to evict low-feerate malicious commitment,\nan alternative proposal could be to introduce outbound tx-relay peers\nrotation to sweep and reach ~80% of the network in less than HTLC\ntimelocks.  Your LN node's full node will _probabilistically_ connect to a\nminer mempool and announce to it the best feerate package. Making the\ntx-relay topology more dynamic would make it harder for an attacker to make\npackage obstruction effective. IMHO, it sounds easier on the\nengineering-side, but likely worse for privacy due to the aggressive\nbroadcast pattern.\n\nAnother alternative could be to have more ad hoc privacy-preserving\nredundant tx-broadcast.\n\nA fourth proposal, Matt's one, is to design some blind-CPFP package relay\nwith a pointer to original funding outpoint to rebind on-the-flight but it\ndoes assume noinput.\n\n### Conclusion\n\nTo the best of my knowledge, assuming mempools congestion levels we have\nseen in the past months, currently deployed LN peers aren't secure against\nscenario 2a) and 2b) to any motivated attackers with a decent knowledge of\nboth layers. Further, ensuring scenario 3) security requires heavy,\nlong-term work at the base layer.\n\nIMO, we should a) go forward with anchor proposal implementation, it comes\nwith trade-off but enables mempool-congestion safety, b) work on package\nrelay to solve commitment-level pinning, c) study best base layer mechanism\nto ensure best feerate package discovery by any miner's mempools and d) in\nthe meanwhile increase delta and deadline timelocks.\n\nThoughts ?\n\nThanks to Matt and t-bast for conversations.\n\nCheers,\n\nAntoine\n\n[0] For newcomers, see also t-bast's great piece on LN's transactions :\nhttps://github.com/t-bast/lightning-docs/blob/master/lightning-txs.md\n\n[1] And current state of opinions is obfuscating tx-relay topology is a\nhard problem\nhttps://github.com/bitcoin/bitcoin/pull/15759#issuecomment-480398802\n\n[2]\nhttps://bitcoinops.org/en/newsletters/2020/04/29/#new-attack-against-ln-payment-atomicity\n\n[3] Obviously all these scenarios do have a setup cost scoping channel\nopening onchain fees and\nrebalancing but it's order(s) of magnitude lower if you can steal from\nmeaningful channels.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200628/42630142/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Pinning : The Good, The Bad, The Ugly",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 13763
        }
    }
]