[
    {
        "title": "[Lightning-dev] An Argument For Single-Asset Lightning Network",
        "thread_messages": [
            {
                "author": "kostadin rangelov",
                "date": "2020-07-04T21:02:10",
                "message_text_only": "-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200704/e58e4d6c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "An Argument For Single-Asset Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "kostadin rangelov"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 184
        }
    },
    {
        "title": "[Lightning-dev] Lightning - Is HTLC vulnerable? And mention of Channel Factories",
        "thread_messages": [
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-07-14T02:58:13",
                "message_text_only": "Sorry. Re-sending with correction to CC bitcoin-dev\n\n\n\n\n\n I am sorry if this was already brought up in previous threads. If I know\nlightning network correctly then HTLC is used to enforce settlements on\nblockchain if there is a dispute. Could a person lose money if their HTLC\ndoes not get confirmed in the timeframe or if an older HTLC gets\nconfirmed first? I see different ways this could happen.\n\n One, if the blockchain is very saturated with other transactions. The\nreason we need lightning network is why it might have troubles with\nsettlements? Two, competition from a different conflicting HTLC. A newer\nHTLC might not get confirmed before an older HTL. Three, denial of service\nthe lightning router so they never have a chance to send a settlement\nHTLC.\n\nI found out about a recent attack technique that sounds like it might be\nsimilar called \"flood and loot\".\n\nIs this a concern on lightning network? I humbly say that I do not fully\nunderstand all of lightning network yet. I am working to grasp the idea.\nThese are questions I look to find answer for. Another question I have. I\ndid read the paper Scalable Funding of Bitcoin Micropayment Channel\nNetworks. Would channel factories be better and eliminate my concern?\n\n\nI am sending this to lightning-dev mailing list. I do not see\nlightning-dev emails because google recaptcha blocks me from the\nsubscribe. Please CC me if you reply so I can read it.\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            }
        ],
        "thread_summary": {
            "title": "Lightning - Is HTLC vulnerable? And mention of Channel Factories",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Mr. Lee Chiffre"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1489
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Lightning - Is HTLC vulnerable? And mention of Channel Factories",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-14T14:42:21",
                "message_text_only": "Good morning Mr. Lee,\n\n> Sorry. Re-sending with correction to CC bitcoin-dev\n>\n> I am sorry if this was already brought up in previous threads. If I know\n> lightning network correctly then HTLC is used to enforce settlements on\n> blockchain if there is a dispute. Could a person lose money if their HTLC\n> does not get confirmed in the timeframe or if an older HTLC gets\n> confirmed first? I see different ways this could happen.\n>\n> One, if the blockchain is very saturated with other transactions. The\n> reason we need lightning network is why it might have troubles with\n> settlements?\n\nThis could happen, but the entire exercise is to move transactions off the blockchain, precisely to lower this risk.\n\nOtherwise, transfers onchain will take a long time.\nIn practice, a long time to settle a payment will invalidate many real-world economic exchanges anyway (consider paying for food at a restaurant --- if your payments take days to settle, the food has gotten stale before the restaurant receives payment and releases your food).\nThus, if an onchain transfer takes a long time to settle, there is already risk of economic loss present.\n\nBy moving activity offchain, we reduce pressure onchain and improve settlement speeds on both offchain and onchain, reducing risk of economic loss due to delay.\n\n\n> Two, competition from a different conflicting HTLC. A newer\n> HTLC might not get confirmed before an older HTL.\n\nI cannot make sense of this.\n\nYou cannot create conflicting HTLCs.\nEither you have some free money to create an HTLC, in which case there is no possible conflict with an existing HTLC (the fund is reserved for HTLCs, or it is yours without further encumbrance).\n\nThus it is not possible to create a conflicting HTLC in any case: either you have funds (that are not already in an HTLC) to fund an HTLC and that HTLC cannot conflict with existing ones, or you have no funds and a new HTLC cannot be created until one of the HTLCs is resolved one way or another.\n\n> Three, denial of service\n> the lightning router so they never have a chance to send a settlement\n> HTLC.\n\nThis is possible, but only that node risks loss.\n\nThe reason why unilateral close is always possible is to handle the case where a routing node comes offline.\n\nIf you have offered an HTLC to a routing node, you retain a timelock branch back to you (the \"T\" in HTLC).\n\nIf the routing node goes offline past the timelock in the HTLC, then you unilaterally close the channel and drop the HTLC onchain.\nThis is what lets you recover your funds.\n\n\n>\n> I found out about a recent attack technique that sounds like it might be\n> similar called \"flood and loot\".\n\nRoughly, my understanding of Flood and Loot is to make a lot of uneconomically tiny HTLCs going through a target victim forwarding node.\nYou make circular routes going from your own node back to yourself.\nThen you refuse to actually claim the HTLCs sent back to yourself.\n\nThen you go offline.\nThis means that the only way for the forwarding node to recover its funds is to drop the channel(s) involved onchain.\nBut if the HTLCs are many and tiny, they are simply too uneconomic to claim onchain, so they just lose the channel funds as fees.\n\n\n\n>\n> Is this a concern on lightning network?\n\nYes.\nWork is being done (anchor commitments) to mitigate the effects of onchain fees on Lightning.\n\n> I humbly say that I do not fully\n> understand all of lightning network yet. I am working to grasp the idea.\n> These are questions I look to find answer for. Another question I have. I\n> did read the paper Scalable Funding of Bitcoin Micropayment Channel\n> Networks. Would channel factories be better and eliminate my concern?\n\nThey would not.\nUltimately, your \"final defense\" is to drop the entire construction onchain until you reach the HTLCs and you can have the blockchain enforce the HTLC contract.\n\nIt would *help* to reduce blockchain bloat by reducing the size of transactions to create multiple channels, and thus also secondarily helps reduce onchain fee pressure and also reduce Flood-and-Loot (which is basically a layer-crossing attack, taking advantage of lower-layer fees to create attacks on higher layers).\n\nBut always the underlying problem remains: security costs something, and you have to pay for protection on the Internet when transacting with potentially untrusted (and untrustable) entities.\nIt seems unlikely that \"security costs something\" can be eliminated.\nOne can consider that modern-day state-imposed taxation is paying for security, for instance, of traditional face-to-face transactions.\nWith Bitcoin, you can choose to either transact and pay for security, or not transact and forgo what you would have bought.\nWith some tradeoffs, you can pay by other means that may be cheaper for you.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2020-07-15T15:23:37",
                "message_text_only": "On Tue, 14 Jul 2020 at 16:42, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Mr. Lee,\n>\n> > Sorry. Re-sending with correction to CC bitcoin-dev\n> >\n> > I am sorry if this was already brought up in previous threads. If I know\n> > lightning network correctly then HTLC is used to enforce settlements on\n> > blockchain if there is a dispute. Could a person lose money if their HTLC\n> > does not get confirmed in the timeframe or if an older HTLC gets\n> > confirmed first? I see different ways this could happen.\n> >\n> > One, if the blockchain is very saturated with other transactions. The\n> > reason we need lightning network is why it might have troubles with\n> > settlements?\n>\n> This could happen, but the entire exercise is to move transactions off the\n> blockchain, precisely to lower this risk.\n>\n> Otherwise, transfers onchain will take a long time.\n> In practice, a long time to settle a payment will invalidate many\n> real-world economic exchanges anyway (consider paying for food at a\n> restaurant --- if your payments take days to settle, the food has gotten\n> stale before the restaurant receives payment and releases your food).\n> Thus, if an onchain transfer takes a long time to settle, there is already\n> risk of economic loss present.\n>\n> By moving activity offchain, we reduce pressure onchain and improve\n> settlement speeds on both offchain and onchain, reducing risk of economic\n> loss due to delay.\n>\n>\n> > Two, competition from a different conflicting HTLC. A newer\n> > HTLC might not get confirmed before an older HTL.\n>\n> I cannot make sense of this.\n>\n> You cannot create conflicting HTLCs.\n>\n\nCorrect.  Removing or Creating an HTLC is something that both channel\npartners need to agree on.  They may create multiple pending HTLCs as long\nas there are enough funds, but creating conflicting HTLCs is not possible.\n\n\n> >\n> > I found out about a recent attack technique that sounds like it might be\n> > similar called \"flood and loot\".\n>\n> Roughly, my understanding of Flood and Loot is to make a lot of\n> uneconomically tiny HTLCs going through a target victim forwarding node.\n> You make circular routes going from your own node back to yourself.\n> Then you refuse to actually claim the HTLCs sent back to yourself.\n>\n\nNo, the way I understand it is that an attacker, say Malleroy, routes a lot\nof medium sized HTLC payments from his node to his node via a victim node,\nsay Alice's, and possibly other nodes.\nThen Malleroy *accepts* the payments by publishing the hash on the\nreceiving end, so he gets all the sent funds on his receiving channel.\nMalleroy's receiving node behaves completely honestly, and nobody can prove\nthat it belongs to the attacker.\nFinally when Alice claims her HTLC by presenting the hash, Malleroy just\nignores the claim.  Now Alice, the victim, is forced to close the channel\nto prevent the HTLC to timeout. If Malleroy does it with multiple victims\nat exactly the same time, they will all compete with each other.  The\nvictims cannot increase the fee for the HTLC claiming transaction, because\nthey are the ones who force-closed the channel.  CPFP doesn't work, because\ntheir ultimate output is CLTV'd.  As soon as the HTLC timeouts Malleroy can\nclaim the still pending HTLCs using an RBF transaction.\n\nSo it is Alice who has to force close, which puts her at a big disadvantage.\n\nMalleroy will have to pay the lightning fees, but they are negligible.  The\nfee for the on-chain force-close transaction (with the HTLC outputs) is\npaid by whoever opened the channel. AFAIK the fee for the HTLC resolving\ntransactions is paid by whoever claims the HTLC.  In this scenario it is\npaid from Alice's money.  If Malleroy opened the channel, he risks losing\nsome funds to on-chain fees.  On the other hand the one who pays the fee\ncontrols the fee.  He could negotiate a very low fee (say a cent per HTLC),\nwhen the network is idle and then wait for a natural congestion before\nstarting the attack, giving him a low risk with high success probability.\nEvery HTLC he can claim after timeout is profit.\n\nRegards,\n  Jochen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200715/ed01a6cf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning - Is HTLC vulnerable? And mention of Channel Factories",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Jochen Hoenicke",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9073
        }
    },
    {
        "title": "[Lightning-dev] Collaborated stealing. What happens when the final recipient discloses the pre-image",
        "thread_messages": [
            {
                "author": "Ankit Gangwal",
                "date": "2020-07-17T06:43:45",
                "message_text_only": "Consider A wants to send some funds to E.\n\nThey don\u2019t have a direct payment channel among them. So, they use a following path A-B-C-D-E. A is the sender of payment and E is final recipient.\n\nE sends the hash of a secret r to A, A passes on the hash to B, B to C, C to D, and D to E.\n\nE discloses the secret to C (a partner in crime with E) and E do not respond to D. C gives the secret to B (settling the HTLC between them). Then, B gives the secret to A (settling the HTLC between them).\n\nA sent (and lost) the money, as E denies receiving the money (and the promised service/good).\n\nHow the lightening network sees this? Out of their control?\n\n--\nA_G\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200717/bea3d39b/attachment.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2020-07-17T07:19:03",
                "message_text_only": "Hey Ankit,\n\nThe lightning network sees the possession of a preimage as a proof of\npayment. And I believe everyone agrees that a court should rule in favor of\nA forcing E to deliver the good or reimburse A. The reason is that\npossession of the preimage matching the signed payment hash from E is a\nmuch stronger evidence of A actually having paid than E claiming to not\nhave received anything.\nThis is also due to the fact that guessing the preimage can practically be\nconsidered impossible (though there is a tiny likelihood)\n\nIf E breaches the protocol by giving the preimage to C (for free) instead\nof claiming the money from D (and thus settling the Htlc) it will be\nconsidered E's problem, that E did not get reimbursed but just gave out the\npreimage for free. (actually E's so called \"partner in crime\" did get\nreimbursed). Even if D would testify that E never settled the Htlc one\nwould wonder why E never settled the incoming htlc as they should only have\ncreated a payment hash for which they know the preimage. Since A can\nactually provide one it is again unlikely if E for example claims they just\nused a random hash for which they didn't know the preimage because they\nwanted to just see if A has enough liquidity.\n\nWith kind regards Rene\n\nAnkit Gangwal <A.Gangwal at tudelft.nl> schrieb am Fr., 17. Juli 2020, 08:43:\n\n> Consider A wants to send some funds to E.\n>\n>\n>\n> They don\u2019t have a direct payment channel among them. So, they use a\n> following path A-B-C-D-E. A is the sender of payment and E is final\n> recipient.\n>\n>\n>\n> E sends the hash of a secret r to A, A passes on the hash to B, B to C, C\n> to D, and D to E.\n>\n>\n>\n> E discloses the secret to C (a partner in crime with E) and E do not\n> respond to D. C gives the secret to B (settling the HTLC between them).\n> Then, B gives the secret to A (settling the HTLC between them).\n>\n>\n>\n> A sent (and lost) the money, as E denies receiving the money (and the\n> promised service/good).\n>\n>\n>\n> How the lightening network sees this? Out of their control?\n>\n>\n>\n> --\n>\n> A_G\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200717/e0c86579/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-17T08:59:16",
                "message_text_only": "Good morning Ankit,\n\nI believe what you describe is a specific form of what is called the Wormhole attack.\nIn the general form, the Wormhole attack has two forwarding nodes in a path that are coordinating with each other, and they can \"teleport\" the preimage from one to the other, skipping intermediate forwarding nodes.\n\nThe case you describe is the specific case where one of the nodes performing this attack on a path is the payee itself.\n\nWhat is stolen here is not the payment amount, but the fees that the \"skipped\" forwarding nodes should have earned for honestly forwarding.\nOn the other hand, in that case, it is simply a form of the griefing attack: C and E are able to  cause D to lock its funds into HTLCs without earning fees, but C and E can mount that attack at any time regardless of A or B anyway, so it is not an additional attack surface on D.\n\nAt a high level, this attack is not a concern.\nAs long as A is able to acquire the preimage, it has proof of payment, and it is immaterial *how* A managed to get the preimage, as Rene describes.\nEven if E claims that it did not deliberately give the preimage and that it was hacked by C, then it is C who is liable, in which case C and E, being a cooperating team, have gained nothing at all (and just made C angry at E for throwing C under the bus).\n\nBasically, the preimage *is* the proof.\nThere are only two things you need to do:\n\n* Ensure that invoices are signed by E (meaning E agreed to perform some service if the preimage is revealed by anyone).\n  BOLT11 already requires this.\n* Ensure that invoices indicate *who exactly* is going to get the service or product.\n  Since the preimage is learned by every intermediate hop, it cannot be a bearer certificate, so it must indicate specifically that the beneficiary of the product or service will be A.\n\nWith the above, A can be sure that paying in exchange for getting the preimage, is a binding contract on the service indicated by the invoice.\nThe preimage and the invoice (that has a signature from E), are sufficient to show that E has an obligation to provide a service or product to A.\n\nThe wormhole attack (which steals fees from D) is fixed by using PTLCs and blinding factors.\nE learns the total of all blinding factors, and knows the final scalar, but does not know the blinding factor delta from C to E, and thus cannot give C any information on how to claim the funds.\n\nRegards,\nZmnSCPxj\n\n\n> Hey Ankit,\u00a0\n>\n> The lightning network sees the possession of a preimage as a proof of payment. And I believe everyone agrees that a court should rule in favor of A forcing E to deliver the good or reimburse A. The reason is that possession of the preimage matching the signed payment hash from E is a much stronger evidence of A actually having paid than E claiming to not have received anything.\u00a0\n> This is also due to the fact that guessing the preimage can practically be considered impossible (though there is a tiny likelihood)\u00a0\n>\n> If E breaches the protocol by giving the preimage to C (for free) instead of claiming the money from D (and thus settling the Htlc) it will be considered E's problem, that E did not get reimbursed but just gave out the preimage for free. (actually E's so called \"partner in crime\" did get reimbursed). Even if D would testify that E never settled the Htlc one would wonder why E never settled the incoming htlc as they should only have created a payment hash for which they know the preimage. Since A can actually provide one it is again unlikely if E for example claims they just used a random hash for which they didn't know the preimage because they wanted to just see if A has enough liquidity.\u00a0\n>\n> With kind regards Rene\n>\n> Ankit Gangwal <A.Gangwal at tudelft.nl> schrieb am Fr., 17. Juli 2020, 08:43:\n>\n> > Consider A wants to send some funds to E.\n> >\n> > They don\u2019t have a direct payment channel among them. So, they use a following path A-B-C-D-E. A is the sender of payment and E is final recipient.\n> >\n> > E sends the hash of a secret r to A, A passes on the hash to B, B to C, C to D, and D to E.\n> >\n> > E discloses the secret to C (a partner in crime with E) and E do not respond to D. C gives the secret to B (settling the HTLC between them). Then, B gives the secret to A (settling the HTLC between them).\n> >\n> > A sent (and lost) the money, as E denies receiving the money (and the promised service/good).\n> >\n> > How the lightening network sees this? Out of their control?\n> >\n> > --\n> >\n> > A_G\n> >\n> > \u00a0\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Christian Decker",
                "date": "2020-07-29T12:21:25",
                "message_text_only": "It might be worth mentioning here that the wormhole attack can also just\nbe considered a more efficient way of routing a payment over fewer hops,\nfreeing funds in channels that have been skipped by failing them even\nthough the overall payment has not been completed.\n\nThis is why I hesitate to even call it an attack in the first place: if\nthe skipped hops free the HTLCs, which the skipping entity that controls\nboth endpoints of the shortcut is encouraged to in order to free its own\nreserved funds, we are increasing the efficiency of the network.\n\nAs ZmnSCPxj correctly points out this requires the attacker to be able\nto collate HTLCs, which goes away with PTLCs. However even today we're\nnot worse off by nodes exploiting this.\n\nCheers,\nChristian\n\nZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n> Good morning Ankit,\n>\n> I believe what you describe is a specific form of what is called the Wormhole attack.\n> In the general form, the Wormhole attack has two forwarding nodes in a path that are coordinating with each other, and they can \"teleport\" the preimage from one to the other, skipping intermediate forwarding nodes.\n>\n> The case you describe is the specific case where one of the nodes performing this attack on a path is the payee itself.\n>\n> What is stolen here is not the payment amount, but the fees that the \"skipped\" forwarding nodes should have earned for honestly forwarding.\n> On the other hand, in that case, it is simply a form of the griefing attack: C and E are able to  cause D to lock its funds into HTLCs without earning fees, but C and E can mount that attack at any time regardless of A or B anyway, so it is not an additional attack surface on D.\n>\n> At a high level, this attack is not a concern.\n> As long as A is able to acquire the preimage, it has proof of payment, and it is immaterial *how* A managed to get the preimage, as Rene describes.\n> Even if E claims that it did not deliberately give the preimage and that it was hacked by C, then it is C who is liable, in which case C and E, being a cooperating team, have gained nothing at all (and just made C angry at E for throwing C under the bus).\n>\n> Basically, the preimage *is* the proof.\n> There are only two things you need to do:\n>\n> * Ensure that invoices are signed by E (meaning E agreed to perform some service if the preimage is revealed by anyone).\n>   BOLT11 already requires this.\n> * Ensure that invoices indicate *who exactly* is going to get the service or product.\n>   Since the preimage is learned by every intermediate hop, it cannot be a bearer certificate, so it must indicate specifically that the beneficiary of the product or service will be A.\n>\n> With the above, A can be sure that paying in exchange for getting the preimage, is a binding contract on the service indicated by the invoice.\n> The preimage and the invoice (that has a signature from E), are sufficient to show that E has an obligation to provide a service or product to A.\n>\n> The wormhole attack (which steals fees from D) is fixed by using PTLCs and blinding factors.\n> E learns the total of all blinding factors, and knows the final scalar, but does not know the blinding factor delta from C to E, and thus cannot give C any information on how to claim the funds.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n>> Hey Ankit,\u00a0\n>>\n>> The lightning network sees the possession of a preimage as a proof of payment. And I believe everyone agrees that a court should rule in favor of A forcing E to deliver the good or reimburse A. The reason is that possession of the preimage matching the signed payment hash from E is a much stronger evidence of A actually having paid than E claiming to not have received anything.\u00a0\n>> This is also due to the fact that guessing the preimage can practically be considered impossible (though there is a tiny likelihood)\u00a0\n>>\n>> If E breaches the protocol by giving the preimage to C (for free) instead of claiming the money from D (and thus settling the Htlc) it will be considered E's problem, that E did not get reimbursed but just gave out the preimage for free. (actually E's so called \"partner in crime\" did get reimbursed). Even if D would testify that E never settled the Htlc one would wonder why E never settled the incoming htlc as they should only have created a payment hash for which they know the preimage. Since A can actually provide one it is again unlikely if E for example claims they just used a random hash for which they didn't know the preimage because they wanted to just see if A has enough liquidity.\u00a0\n>>\n>> With kind regards Rene\n>>\n>> Ankit Gangwal <A.Gangwal at tudelft.nl> schrieb am Fr., 17. Juli 2020, 08:43:\n>>\n>> > Consider A wants to send some funds to E.\n>> >\n>> > They don\u2019t have a direct payment channel among them. So, they use a following path A-B-C-D-E. A is the sender of payment and E is final recipient.\n>> >\n>> > E sends the hash of a secret r to A, A passes on the hash to B, B to C, C to D, and D to E.\n>> >\n>> > E discloses the secret to C (a partner in crime with E) and E do not respond to D. C gives the secret to B (settling the HTLC between them). Then, B gives the secret to A (settling the HTLC between them).\n>> >\n>> > A sent (and lost) the money, as E denies receiving the money (and the promised service/good).\n>> >\n>> > How the lightening network sees this? Out of their control?\n>> >\n>> > --\n>> >\n>> > A_G\n>> >\n>> > \u00a0\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Collaborated stealing. What happens when the final recipient discloses the pre-image",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Ren\u00e9 Pickhardt",
                "ZmnSCPxj",
                "Ankit Gangwal"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 13765
        }
    },
    {
        "title": "[Lightning-dev] Dynamic Commitments: Upgrading Channels Without On-Chain Transactions",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-07-21T01:18:19",
                "message_text_only": "Hi y'all,\n\nIn this post, I'd like to share an early version of an extension to the spec\nand channel state machine that would allow for on-the-fly commitment\n_format/type_ changes. Notably, this would allow for us to _upgrade_\ncommitment types without any on-chain activity, executed in a\nde-synchronized and distributed manner. The core realization these proposal\nis based on the fact that the funding output is the _only_ component of a\nchannel that's actually set in stone (requires an on-chain transaction to\nmodify).\n\n\n# Motivation\n\n(you can skip this section if you already know why something like this is\nimportant)\n\nFirst, some motivation. As y'all are likely aware, the current deployed\ncommitment format has changed once so far: to introduce the\n`static_remote_key` variant which makes channels safer by sending the funds\nof the party that was force closed on to a plain pubkey w/o any extra tweaks\nor derivation. This makes channel recovery safer, as the party that may have\nlost data (or can't continue the channel), no longer needs to learn of a\nsecret value sent to them by the other party to be able to claim their\nfunds. However, as this new format was introduced sometime after the initial\nbootstrapping phase of the network, most channels in the wild today _are\nnot_ using this safer format.  Transitioning _all_ the existing channels to\nthis new format as is, would require closing them _all_, generating tens of\nthousands of on-chain transactions (to close, then re-open), not to mention\nchain fees.\n\nWith dynamic commitments, users will be able to upgrade their _existing_\nchannels to new safer types, without any new on-chain transactions!\n\nAnchor output based commitments represent another step forward in making\nchannels safer as they allow users/software to no longer have to predict\nchain fees ahead of time, and also bump up the fee of a\ncommitment/2nd-level-htlc-transaction, which is extremely important when it\ncomes to timely on-chain resolution of HTLC contracts. This upgrade process\n(as touched on below) can either be manually triggered, or automatically\ntriggered once the software updates and finds a new preferable default\ncommitment format is available.\n\nAs many of us are aware, the addition of schnorr and taproot to the Bitcoin\nprotocol dramatically increases the design space for channels as a whole. It\nmay take some time to explore this design space, particularly as entirely\nnew channel/commitment formats [1] continue to be discovered. The roll out\nof dynamic commitments allows us to defer the concrete design of the future\ncommitment formats, yet still benefit from the immediate improvement that\ncomes with morphing the funding output to be a single-key (non-p2wsh, though\nthe line starts to blur w/ taproot) output. With this new funding output\nformat in place, users/software will then be able to update to the latest\nand greatest commitment format that starts to utilize all the new tools\navailable (scriptless script based htlcs, etc) at a later date.\n\nFinally, the ability to update the commitment format itself will also allow\nus to re-parametrize portions of the channels which are currently set in\nstone. As an example, right now the # of max allowed outstanding HTLCs is\nset in stone once the channel has opened. With the ability to also swap out\ncommitment _parameters_, we can start to experiment with flow-control like\nideas such as limiting a new channel peer to only a handful of HTLC slots,\nwhich is then progressively increased based on \"good behavior\" (or the other\nway around as well). Beyond just updating the channel parameters, it's also\npossible to \"change the rules\" of a channel on the fly. An example of this\nvariant would be creating a new psuedo-type that implements a fee policy\nother than \"the initiator pays all fees\".\n\n\n# Protocol Changes\n\nWith the motivation/background set up, let's dig into some potential ways\nthe protocol can be modified to support this new meta-feature. As this\nchange is more of a meta-change, AFAICT, the amount of protocol changes\ndoesn't appear to be _too_ invasive ;). Most of the heavy lifting is done by\nthe wondrous TLV message field extensions.\n\n## Explicit Channel Type Negotiation\n\nRight now in the protocol, as new channel types are introduced (static key,\nand now anchors) we add a new feature bit. If both nodes have the feature\nbit set, then that new channel type is to be used. Notice how this is an\n_implicit_ upgrade: there's no explicit signalling during the _funding_\nprocess that a new channel type is to be used. This works OK, if there's one\nmajor accepted \"official\" channel type, but not as new types are introduced\nfor specific use cases or applications. The implicit negotiation also makes\nthings a bit ambiguous at times. As an example, if both nodes have the\n`static_remote_key` _and_ anchor outputs feature bit set, which channel type\nshould they open?\n\nTo resolve this existing ambiguity in the channel type negotiation, we'll\nneed to make the channel type used for funding _explicit_. Thankfully, we\nrecently modified the message format to be forwarding looking in order to\nallow _TLV extensions_ to be added for all existing message types. A new\n`channel_type` (type #???) TLV would be added which makes the channel type\nused in funding explicit, with the existing feature bit advertisement system\nbeing kept in place.\n\nA draft of the changes in this area would be something like:\n\n  * `open_channel` and `accept_channel` gain a new `channel_type` TLV field.\n  * retroactively the OG commitment format is numbered as `channel_type=0`,\n    `static_remote_key`, as `channel_type=1`, and anchors as\n    `channel_type=2`\n  * if one receives an `open_channel`, or `accept_channel` message with an\n    unknown `channel_type`, they're to fail the funding flow\n  * nodes MUST NOT send an `open_channel` or `accept_channel` message with a\n    `channel_type` that isn't covered by their existing advertise feature\n    bits\n  * a mapping between feature bits and expected `channel_type` values would\n    then be added\n  * during funding negotiation, the _commitment_ type itself is parametrized\n    based on the `channel_type` value\n      * as we've all implemented `static_remote_key` commitments at this\n        point, I assume the necessary code-level abstractions are already\n        in-place\n\n## Commitment State Machine Changes\n\nWith the changes described in the above section, we're now able to\nexplicitly identify _which_ channel type we want to enter a funding flow\nfor. As we add more types, there may not be a \"default\" type, so making this\nprocess explicit is important to future exploration and extensibility.  In\nthis section, we'll introduce a series of small changes to the `commit_sig`,\nand `revoke_and_ack` messages which'll allow us to implement the \"dynamic\"\nportion of this proposal.\n\nRelying once again on the wondrous power of TLV message extensions we'll\ncarry over the `channel_type` TLV (just the name, # may be diff since this\nis a diff message context) to the `commit_sig`, and `revoke_and_ack`\nmessages. The following guidelines on inclusion and interpretation would\nthen be applied:\n\n  * the `channel_type` specified on a given `commit_sig` message should be\n    the `channel_type` of the _new_ commitment being _created_\n  * when receiving a `commit_sig` with a `channel_type` that differs from\n    the `channel_type` of one's on revoked commitment:\n     * if the `channel_type` is unknown (or the `channel_type` transition\n       isn't allowed or defined), then the _p2p_ connection should be\n       aborted\n     * otherwise, using the `channel_type` as a parameter for commitment\n       transaction construction, a new commitment adhering to the rules of\n       the `channel_type` should be constructed\n  * the `channel_type` sent in the `revoke_and_ack` message should be the\n    `channel_type` of the commitment that's being _revoked_\n\nWith the above new rules, let's say Alice and Bob upgrade to new versions of\ntheir LN software that support a new channel type `1`, while they're on\nchannel type `0`. Either triggered automatically, or manually (by either\nside), the commitment flow would look something like:\n\n  1. sig_c_1   ->\n  2.          <- revoke_c_0\n  3.          <- sig_c_1\n  4. revoke_c_0 ->\n\nBy exchanging 4 messages, both sides are able to upgrade to a new commitment\nformat. However, one issue with the above flow is that it currently isn't\nallowed by the spec, since we disallow sending a `commit_sig` message that\ndoesn't cover any updates. If we end up going with this route, then we'd\nhave to relax that constraint to something like:\n\n  * an empty `commit_sig` message (one that covers no updates) is\n    disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n    differs from the channel type of the prior commitment, `c_n-1`.\n\nIt would then be up to _new protocol extension documents_ to define _how_ to\nconstruct those new channel types, and also any changes to the on-chain\nhandling that are required by those channel types. Also certain transitions\nmay be disallowed. As an example, implementations may want to prevent a user\nfrom going back to the non-static remote key channels from the\n`static_remote_key` format.\n\nIn order to prepare for these changes, implementations need to be able to\nhandle \"holding\" unrevoked commitments of heterogeneous types, as if either\nof them hit the chain, they'll need to be able to resolve all contracts\nproperly.\n\nAn alternative to attaching the `channel_type` message to the `commit_sig`\nand having _that_ kick off the commitment upgrade, we could instead possibly\nadd a _new_ update message (like `update_fee`) to make the process more\nexplicit. In either case, we may want to restrict things a bit by only\nallowing the initiator to trigger a commitment format update.\n\n## Further Channel Type Parameterization\n\nWith the above protocol sketch, we're able to handle \"simple\" upgrades,\nwhere some/all of the parameters of the channel are hard coded and/or have\nbeen negotiated out of band. More complex channel types may require the\nexchange of additional keys or parameters which need to be known in order to\nreconstruct the _new_ commitment format and verify the new signature. This\nadditional information can possibly be piggy-backed on the `commit_sig`\nmessage in the form of a _nested TLV_ type:\n\n  * a msg-local TLV type `channel_params` is added\n  * the value of this TLV type is a nested TLV blob, that contains all the\n    necessary fields and values needed to properly handle the channel switch\n    over\n\nReturning to the flow control example earlier in this post, the new limits\nfor `max_allowed_htlcs`, can be included in this blob. More complex channel\ntypes could send information such as new keys to be used, or other\nparameters\nthat govern how a commitment is to be constructed (like the size of the\nanchor outputs).\n\n# Conclusion\n\nSummarizing, in this post we've proposed a series of protocol modifications\n(with TLV fields doing most of the heavy lifting) that allows LN nodes to\nupgrade their commitments _without any on-chain_ transactions. Depending on\nthe architecture of a node, new types may even be added/removed without\nactual downtime.\n\nThe ability to upgrade commitments after the fact lessens the pressure of\nnewer possibly experimental channel types to get all the details (and\nexplore the rather large design space) correct up front. Once Taproot rolls\naround, we can simply update the funding output, roll that out, then\ncontinue to hash out the details on the possibly new channel type(s) that\ntake advantage of all the new tools.\n\nAllowing channel types to be upgraded on the fly let's us update the network\nto the new _safer_ channel types in a de-synchronized, distributed manner\nthat doesn't require any on-chain transactions! Dynamic commitments as a\nwhole also creates another point of extensibility in the protocol so we can\nstart to explore all the variants on channels as we know them that exist.\n\nI'm keen to gather feedback, as internally for `lnd` we've committed to\nexploring this direction so we can start to upgrade _all_ the existing\nlnd-involved channels to the new anchor commitment format, which is the\nsafest format yet.\n\n[1]: https://eprint.iacr.org/2020/476\n\n-- Laolu\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200720/67ee7ab2/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-07-21T08:46:12",
                "message_text_only": "Thanks for sharing this, I think it's the right time to start experimenting\nwith\nthat kind of feature (especially in the light of Taproot and the package\nrelay\nwork / pinning transactions issue).\n\nwe can start to experiment with flow-control like\n> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n> which is then progressively increased based on \"good behavior\" (or the\n> other\n> way around as well)\n\n\nNote that this is already possible today, a node can unilaterally decide its\ninternal rules for accepting channels/HTLCs. But it's true that it would be\nnicer to communicate these rules with your peer to reduce inefficiencies\n(e.g. proposing HTLCs that we know will be rejected).\n\n* `open_channel` and `accept_channel` gain a new `channel_type` TLV field.\n> * retroactively the OG commitment format is numbered as `channel_type=0`,\n> `static_remote_key`, as `channel_type=1`, and anchors as\n> `channel_type=2`\n\n\nACK! Internally eclair (and I believe lnd as well) has exactly that field in\nits DB, with exactly those values.\n\n* an empty `commit_sig` message (one that covers no updates) is\n> disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n> differs from the channel type of the prior commitment, `c_n-1`.\n\n\nThat sounds reasonable, as changing the `channel_type` is actually an update\n(it results in changes in the commit tx and/or htlc txs).\n\nAn alternative to attaching the `channel_type` message to the `commit_sig`\n> and having _that_ kick off the commitment upgrade, we could instead\n> possibly\n> add a _new_ update message (like `update_fee`) to make the process more\n> explicit. In either case, we may want to restrict things a bit by only\n> allowing the initiator to trigger a commitment format update.\n\n\nI prefer that alternative. I think it's better to explicitly signal that we\nwant to pause the channel while we upgrade the commitment format (and stop\naccepting HTLCs while we're updating, like we do once we've exchanged the\n`shutdown` message). Otherwise the asynchronocity of the protocol is likely\nto\ncreate months (years?) of tracking unwanted force-closes because of races\nbetween `commig_sig`s with the new and old commitment format.\n\nUpdating the commitment format should be a rare enough operation that we can\nafford to synchronize with a two-way `update_commitment_format` handshake,\nthen\ntemporarily freeze the channel.\n\nThe tricky part will be how we handle \"dangling\" operations that were sent\nby\nthe remote peer *after* we sent our `update_commitment_format` but *before*\nthey received it. The simplest choice is probably to have the initiator just\nignore these messages, and the non-initiator enqueue these un-acked messages\nand replay them after the commitment format update completes (or just drop\nthem\nand cancel corresponding upstream HTLCs if needed).\n\nRegarding initiating the commitment format update, how do you see this\nhappen?\nThe funder activates a new feature on his (e.g. `option_anchor_outputs`),\nand\nbroadcasts it in `init` and `node_announcement`, then waits until the remote\nalso activates it in its `init` message and then reacts to this by\ntriggering\nthe update process?\n\nThanks,\nBastien\n\nLe mar. 21 juil. 2020 \u00e0 03:18, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n\u00e9crit :\n\n> Hi y'all,\n>\n> In this post, I'd like to share an early version of an extension to the\n> spec\n> and channel state machine that would allow for on-the-fly commitment\n> _format/type_ changes. Notably, this would allow for us to _upgrade_\n> commitment types without any on-chain activity, executed in a\n> de-synchronized and distributed manner. The core realization these proposal\n> is based on the fact that the funding output is the _only_ component of a\n> channel that's actually set in stone (requires an on-chain transaction to\n> modify).\n>\n>\n> # Motivation\n>\n> (you can skip this section if you already know why something like this is\n> important)\n>\n> First, some motivation. As y'all are likely aware, the current deployed\n> commitment format has changed once so far: to introduce the\n> `static_remote_key` variant which makes channels safer by sending the funds\n> of the party that was force closed on to a plain pubkey w/o any extra\n> tweaks\n> or derivation. This makes channel recovery safer, as the party that may\n> have\n> lost data (or can't continue the channel), no longer needs to learn of a\n> secret value sent to them by the other party to be able to claim their\n> funds. However, as this new format was introduced sometime after the\n> initial\n> bootstrapping phase of the network, most channels in the wild today _are\n> not_ using this safer format.  Transitioning _all_ the existing channels to\n> this new format as is, would require closing them _all_, generating tens of\n> thousands of on-chain transactions (to close, then re-open), not to mention\n> chain fees.\n>\n> With dynamic commitments, users will be able to upgrade their _existing_\n> channels to new safer types, without any new on-chain transactions!\n>\n> Anchor output based commitments represent another step forward in making\n> channels safer as they allow users/software to no longer have to predict\n> chain fees ahead of time, and also bump up the fee of a\n> commitment/2nd-level-htlc-transaction, which is extremely important when it\n> comes to timely on-chain resolution of HTLC contracts. This upgrade process\n> (as touched on below) can either be manually triggered, or automatically\n> triggered once the software updates and finds a new preferable default\n> commitment format is available.\n>\n> As many of us are aware, the addition of schnorr and taproot to the Bitcoin\n> protocol dramatically increases the design space for channels as a whole.\n> It\n> may take some time to explore this design space, particularly as entirely\n> new channel/commitment formats [1] continue to be discovered. The roll out\n> of dynamic commitments allows us to defer the concrete design of the future\n> commitment formats, yet still benefit from the immediate improvement that\n> comes with morphing the funding output to be a single-key (non-p2wsh,\n> though\n> the line starts to blur w/ taproot) output. With this new funding output\n> format in place, users/software will then be able to update to the latest\n> and greatest commitment format that starts to utilize all the new tools\n> available (scriptless script based htlcs, etc) at a later date.\n>\n> Finally, the ability to update the commitment format itself will also allow\n> us to re-parametrize portions of the channels which are currently set in\n> stone. As an example, right now the # of max allowed outstanding HTLCs is\n> set in stone once the channel has opened. With the ability to also swap out\n> commitment _parameters_, we can start to experiment with flow-control like\n> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n> which is then progressively increased based on \"good behavior\" (or the\n> other\n> way around as well). Beyond just updating the channel parameters, it's also\n> possible to \"change the rules\" of a channel on the fly. An example of this\n> variant would be creating a new psuedo-type that implements a fee policy\n> other than \"the initiator pays all fees\".\n>\n>\n> # Protocol Changes\n>\n> With the motivation/background set up, let's dig into some potential ways\n> the protocol can be modified to support this new meta-feature. As this\n> change is more of a meta-change, AFAICT, the amount of protocol changes\n> doesn't appear to be _too_ invasive ;). Most of the heavy lifting is done\n> by\n> the wondrous TLV message field extensions.\n>\n> ## Explicit Channel Type Negotiation\n>\n> Right now in the protocol, as new channel types are introduced (static key,\n> and now anchors) we add a new feature bit. If both nodes have the feature\n> bit set, then that new channel type is to be used. Notice how this is an\n> _implicit_ upgrade: there's no explicit signalling during the _funding_\n> process that a new channel type is to be used. This works OK, if there's\n> one\n> major accepted \"official\" channel type, but not as new types are introduced\n> for specific use cases or applications. The implicit negotiation also makes\n> things a bit ambiguous at times. As an example, if both nodes have the\n> `static_remote_key` _and_ anchor outputs feature bit set, which channel\n> type\n> should they open?\n>\n> To resolve this existing ambiguity in the channel type negotiation, we'll\n> need to make the channel type used for funding _explicit_. Thankfully, we\n> recently modified the message format to be forwarding looking in order to\n> allow _TLV extensions_ to be added for all existing message types. A new\n> `channel_type` (type #???) TLV would be added which makes the channel type\n> used in funding explicit, with the existing feature bit advertisement\n> system\n> being kept in place.\n>\n> A draft of the changes in this area would be something like:\n>\n>   * `open_channel` and `accept_channel` gain a new `channel_type` TLV\n> field.\n>   * retroactively the OG commitment format is numbered as `channel_type=0`,\n>     `static_remote_key`, as `channel_type=1`, and anchors as\n>     `channel_type=2`\n>   * if one receives an `open_channel`, or `accept_channel` message with an\n>     unknown `channel_type`, they're to fail the funding flow\n>   * nodes MUST NOT send an `open_channel` or `accept_channel` message with\n> a\n>     `channel_type` that isn't covered by their existing advertise feature\n>     bits\n>   * a mapping between feature bits and expected `channel_type` values would\n>     then be added\n>   * during funding negotiation, the _commitment_ type itself is\n> parametrized\n>     based on the `channel_type` value\n>       * as we've all implemented `static_remote_key` commitments at this\n>         point, I assume the necessary code-level abstractions are already\n>         in-place\n>\n> ## Commitment State Machine Changes\n>\n> With the changes described in the above section, we're now able to\n> explicitly identify _which_ channel type we want to enter a funding flow\n> for. As we add more types, there may not be a \"default\" type, so making\n> this\n> process explicit is important to future exploration and extensibility.  In\n> this section, we'll introduce a series of small changes to the\n> `commit_sig`,\n> and `revoke_and_ack` messages which'll allow us to implement the \"dynamic\"\n> portion of this proposal.\n>\n> Relying once again on the wondrous power of TLV message extensions we'll\n> carry over the `channel_type` TLV (just the name, # may be diff since this\n> is a diff message context) to the `commit_sig`, and `revoke_and_ack`\n> messages. The following guidelines on inclusion and interpretation would\n> then be applied:\n>\n>   * the `channel_type` specified on a given `commit_sig` message should be\n>     the `channel_type` of the _new_ commitment being _created_\n>   * when receiving a `commit_sig` with a `channel_type` that differs from\n>     the `channel_type` of one's on revoked commitment:\n>      * if the `channel_type` is unknown (or the `channel_type` transition\n>        isn't allowed or defined), then the _p2p_ connection should be\n>        aborted\n>      * otherwise, using the `channel_type` as a parameter for commitment\n>        transaction construction, a new commitment adhering to the rules of\n>        the `channel_type` should be constructed\n>   * the `channel_type` sent in the `revoke_and_ack` message should be the\n>     `channel_type` of the commitment that's being _revoked_\n>\n> With the above new rules, let's say Alice and Bob upgrade to new versions\n> of\n> their LN software that support a new channel type `1`, while they're on\n> channel type `0`. Either triggered automatically, or manually (by either\n> side), the commitment flow would look something like:\n>\n>   1. sig_c_1   ->\n>   2.          <- revoke_c_0\n>   3.          <- sig_c_1\n>   4. revoke_c_0 ->\n>\n> By exchanging 4 messages, both sides are able to upgrade to a new\n> commitment\n> format. However, one issue with the above flow is that it currently isn't\n> allowed by the spec, since we disallow sending a `commit_sig` message that\n> doesn't cover any updates. If we end up going with this route, then we'd\n> have to relax that constraint to something like:\n>\n>   * an empty `commit_sig` message (one that covers no updates) is\n>     disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n>     differs from the channel type of the prior commitment, `c_n-1`.\n>\n> It would then be up to _new protocol extension documents_ to define _how_\n> to\n> construct those new channel types, and also any changes to the on-chain\n> handling that are required by those channel types. Also certain transitions\n> may be disallowed. As an example, implementations may want to prevent a\n> user\n> from going back to the non-static remote key channels from the\n> `static_remote_key` format.\n>\n> In order to prepare for these changes, implementations need to be able to\n> handle \"holding\" unrevoked commitments of heterogeneous types, as if either\n> of them hit the chain, they'll need to be able to resolve all contracts\n> properly.\n>\n> An alternative to attaching the `channel_type` message to the `commit_sig`\n> and having _that_ kick off the commitment upgrade, we could instead\n> possibly\n> add a _new_ update message (like `update_fee`) to make the process more\n> explicit. In either case, we may want to restrict things a bit by only\n> allowing the initiator to trigger a commitment format update.\n>\n> ## Further Channel Type Parameterization\n>\n> With the above protocol sketch, we're able to handle \"simple\" upgrades,\n> where some/all of the parameters of the channel are hard coded and/or have\n> been negotiated out of band. More complex channel types may require the\n> exchange of additional keys or parameters which need to be known in order\n> to\n> reconstruct the _new_ commitment format and verify the new signature. This\n> additional information can possibly be piggy-backed on the `commit_sig`\n> message in the form of a _nested TLV_ type:\n>\n>   * a msg-local TLV type `channel_params` is added\n>   * the value of this TLV type is a nested TLV blob, that contains all the\n>     necessary fields and values needed to properly handle the channel\n> switch\n>     over\n>\n> Returning to the flow control example earlier in this post, the new limits\n> for `max_allowed_htlcs`, can be included in this blob. More complex channel\n> types could send information such as new keys to be used, or other\n> parameters\n> that govern how a commitment is to be constructed (like the size of the\n> anchor outputs).\n>\n> # Conclusion\n>\n> Summarizing, in this post we've proposed a series of protocol modifications\n> (with TLV fields doing most of the heavy lifting) that allows LN nodes to\n> upgrade their commitments _without any on-chain_ transactions. Depending on\n> the architecture of a node, new types may even be added/removed without\n> actual downtime.\n>\n> The ability to upgrade commitments after the fact lessens the pressure of\n> newer possibly experimental channel types to get all the details (and\n> explore the rather large design space) correct up front. Once Taproot rolls\n> around, we can simply update the funding output, roll that out, then\n> continue to hash out the details on the possibly new channel type(s) that\n> take advantage of all the new tools.\n>\n> Allowing channel types to be upgraded on the fly let's us update the\n> network\n> to the new _safer_ channel types in a de-synchronized, distributed manner\n> that doesn't require any on-chain transactions! Dynamic commitments as a\n> whole also creates another point of extensibility in the protocol so we can\n> start to explore all the variants on channels as we know them that exist.\n>\n> I'm keen to gather feedback, as internally for `lnd` we've committed to\n> exploring this direction so we can start to upgrade _all_ the existing\n> lnd-involved channels to the new anchor commitment format, which is the\n> safest format yet.\n>\n> [1]: https://eprint.iacr.org/2020/476\n>\n> -- Laolu\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200721/9afe2378/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-07-21T22:45:03",
                "message_text_only": "> Note that this is already possible today, a node can unilaterally decide\nits\ninternal rules for accepting channels/HTLCs.\n\nMhmm, it's possible today but would generate extra failures vs knowing what\nall\nthe limits are ahead of time.\n\n> I prefer that alternative. I think it's better to explicitly signal that\n> we want to pause the channel while we upgrade the commitment format (and\n> stop accepting HTLCs while we're updating, like we do once we've exchanged\n> the `shutdown` message).\n\nYou totally read my mind! Check out this variant I posted just now:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-July/002766.html\n\n> Otherwise the asynchronocity of the protocol is likely to create months\n> (years?) of tracking unwanted force-closes because of races between\n> `commig_sig`s with the new and old commitment format.\n\nAgreed, it seems easier to just side-step any possible edge cases (that're\nlikely looming) and move the re-negotiation up a \"level\". I also like the\n\"no active HTLCs\" constraints, as there are likely some weird edge cases\nwith\nfees that would pop up. Like since the taproot output scripts are slightly\nbigger, one could imagine that a switch over w/ active HTLCs could trigger a\nscenario where the initiator isn't able to pay for the fees of all the\nactive HTLCs any longer.....\n\nAt this point in the game, I've learned to never underestimate the hidden\ncomplexity and edge cases of anything that involves fees for Bitcoin\ncontracts.... :p\n\n(\"yep, we're _still_ talking about fees!\" -- Adelaide 2018)\n\n> The tricky part will be how we handle \"dangling\" operations that were sent\n> by the remote peer *after* we sent our `update_commitment_format` but\n> *before* they received it\n\nIs this still an issue if we go with a `shutdown` like message flow\ndescribed in my linked message above? If they're update messages due to\nsettling or failing a direct HTLC, then the responder should be able to let\nthose clear _then_ send the `commit_switch_reply` message. For forwarded\nupdates, as you suggest, the responder would queue those up to send once the\ncommitment switch over has completed.\n\n> Regarding initiating the commitment format update, how do you see this\n> happen?\n\nI left one detail out of my initial message: there'd be a new feature bit\nto signal \"I know how to update commitments\". Aside from that yeah that's\nhow I envisioned things would flow. The first of your channels to update\nwould be with those node operators that are the quickest to update. Ofc\nthere'll be laggards though, and possibly some channels that just never get\nupdated due to the node operator never updating their software. In that\ncase though, it's likely best to close out that channel since their lack of\ntimely updates of their software shows a degree of apathy all together.\n\n-- Laolu\n\nOn Tue, Jul 21, 2020 at 1:46 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Thanks for sharing this, I think it's the right time to start\n> experimenting with\n> that kind of feature (especially in the light of Taproot and the package\n> relay\n> work / pinning transactions issue).\n>\n> we can start to experiment with flow-control like\n>> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n>> which is then progressively increased based on \"good behavior\" (or the\n>> other\n>> way around as well)\n>\n>\n> Note that this is already possible today, a node can unilaterally decide\n> its\n> internal rules for accepting channels/HTLCs. But it's true that it would be\n> nicer to communicate these rules with your peer to reduce inefficiencies\n> (e.g. proposing HTLCs that we know will be rejected).\n>\n> * `open_channel` and `accept_channel` gain a new `channel_type` TLV field.\n>> * retroactively the OG commitment format is numbered as `channel_type=0`,\n>> `static_remote_key`, as `channel_type=1`, and anchors as\n>> `channel_type=2`\n>\n>\n> ACK! Internally eclair (and I believe lnd as well) has exactly that field\n> in\n> its DB, with exactly those values.\n>\n> * an empty `commit_sig` message (one that covers no updates) is\n>> disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n>> differs from the channel type of the prior commitment, `c_n-1`.\n>\n>\n> That sounds reasonable, as changing the `channel_type` is actually an\n> update\n> (it results in changes in the commit tx and/or htlc txs).\n>\n> An alternative to attaching the `channel_type` message to the `commit_sig`\n>> and having _that_ kick off the commitment upgrade, we could instead\n>> possibly\n>> add a _new_ update message (like `update_fee`) to make the process more\n>> explicit. In either case, we may want to restrict things a bit by only\n>> allowing the initiator to trigger a commitment format update.\n>\n>\n> I prefer that alternative. I think it's better to explicitly signal that we\n> want to pause the channel while we upgrade the commitment format (and stop\n> accepting HTLCs while we're updating, like we do once we've exchanged the\n> `shutdown` message). Otherwise the asynchronocity of the protocol is\n> likely to\n> create months (years?) of tracking unwanted force-closes because of races\n> between `commig_sig`s with the new and old commitment format.\n>\n> Updating the commitment format should be a rare enough operation that we\n> can\n> afford to synchronize with a two-way `update_commitment_format` handshake,\n> then\n> temporarily freeze the channel.\n>\n> The tricky part will be how we handle \"dangling\" operations that were sent\n> by\n> the remote peer *after* we sent our `update_commitment_format` but *before*\n> they received it. The simplest choice is probably to have the initiator\n> just\n> ignore these messages, and the non-initiator enqueue these un-acked\n> messages\n> and replay them after the commitment format update completes (or just drop\n> them\n> and cancel corresponding upstream HTLCs if needed).\n>\n> Regarding initiating the commitment format update, how do you see this\n> happen?\n> The funder activates a new feature on his (e.g. `option_anchor_outputs`),\n> and\n> broadcasts it in `init` and `node_announcement`, then waits until the\n> remote\n> also activates it in its `init` message and then reacts to this by\n> triggering\n> the update process?\n>\n> Thanks,\n> Bastien\n>\n> Le mar. 21 juil. 2020 \u00e0 03:18, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n> \u00e9crit :\n>\n>> Hi y'all,\n>>\n>> In this post, I'd like to share an early version of an extension to the\n>> spec\n>> and channel state machine that would allow for on-the-fly commitment\n>> _format/type_ changes. Notably, this would allow for us to _upgrade_\n>> commitment types without any on-chain activity, executed in a\n>> de-synchronized and distributed manner. The core realization these\n>> proposal\n>> is based on the fact that the funding output is the _only_ component of a\n>> channel that's actually set in stone (requires an on-chain transaction to\n>> modify).\n>>\n>>\n>> # Motivation\n>>\n>> (you can skip this section if you already know why something like this is\n>> important)\n>>\n>> First, some motivation. As y'all are likely aware, the current deployed\n>> commitment format has changed once so far: to introduce the\n>> `static_remote_key` variant which makes channels safer by sending the\n>> funds\n>> of the party that was force closed on to a plain pubkey w/o any extra\n>> tweaks\n>> or derivation. This makes channel recovery safer, as the party that may\n>> have\n>> lost data (or can't continue the channel), no longer needs to learn of a\n>> secret value sent to them by the other party to be able to claim their\n>> funds. However, as this new format was introduced sometime after the\n>> initial\n>> bootstrapping phase of the network, most channels in the wild today _are\n>> not_ using this safer format.  Transitioning _all_ the existing channels\n>> to\n>> this new format as is, would require closing them _all_, generating tens\n>> of\n>> thousands of on-chain transactions (to close, then re-open), not to\n>> mention\n>> chain fees.\n>>\n>> With dynamic commitments, users will be able to upgrade their _existing_\n>> channels to new safer types, without any new on-chain transactions!\n>>\n>> Anchor output based commitments represent another step forward in making\n>> channels safer as they allow users/software to no longer have to predict\n>> chain fees ahead of time, and also bump up the fee of a\n>> commitment/2nd-level-htlc-transaction, which is extremely important when\n>> it\n>> comes to timely on-chain resolution of HTLC contracts. This upgrade\n>> process\n>> (as touched on below) can either be manually triggered, or automatically\n>> triggered once the software updates and finds a new preferable default\n>> commitment format is available.\n>>\n>> As many of us are aware, the addition of schnorr and taproot to the\n>> Bitcoin\n>> protocol dramatically increases the design space for channels as a whole.\n>> It\n>> may take some time to explore this design space, particularly as entirely\n>> new channel/commitment formats [1] continue to be discovered. The roll out\n>> of dynamic commitments allows us to defer the concrete design of the\n>> future\n>> commitment formats, yet still benefit from the immediate improvement that\n>> comes with morphing the funding output to be a single-key (non-p2wsh,\n>> though\n>> the line starts to blur w/ taproot) output. With this new funding output\n>> format in place, users/software will then be able to update to the latest\n>> and greatest commitment format that starts to utilize all the new tools\n>> available (scriptless script based htlcs, etc) at a later date.\n>>\n>> Finally, the ability to update the commitment format itself will also\n>> allow\n>> us to re-parametrize portions of the channels which are currently set in\n>> stone. As an example, right now the # of max allowed outstanding HTLCs is\n>> set in stone once the channel has opened. With the ability to also swap\n>> out\n>> commitment _parameters_, we can start to experiment with flow-control like\n>> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n>> which is then progressively increased based on \"good behavior\" (or the\n>> other\n>> way around as well). Beyond just updating the channel parameters, it's\n>> also\n>> possible to \"change the rules\" of a channel on the fly. An example of this\n>> variant would be creating a new psuedo-type that implements a fee policy\n>> other than \"the initiator pays all fees\".\n>>\n>>\n>> # Protocol Changes\n>>\n>> With the motivation/background set up, let's dig into some potential ways\n>> the protocol can be modified to support this new meta-feature. As this\n>> change is more of a meta-change, AFAICT, the amount of protocol changes\n>> doesn't appear to be _too_ invasive ;). Most of the heavy lifting is done\n>> by\n>> the wondrous TLV message field extensions.\n>>\n>> ## Explicit Channel Type Negotiation\n>>\n>> Right now in the protocol, as new channel types are introduced (static\n>> key,\n>> and now anchors) we add a new feature bit. If both nodes have the feature\n>> bit set, then that new channel type is to be used. Notice how this is an\n>> _implicit_ upgrade: there's no explicit signalling during the _funding_\n>> process that a new channel type is to be used. This works OK, if there's\n>> one\n>> major accepted \"official\" channel type, but not as new types are\n>> introduced\n>> for specific use cases or applications. The implicit negotiation also\n>> makes\n>> things a bit ambiguous at times. As an example, if both nodes have the\n>> `static_remote_key` _and_ anchor outputs feature bit set, which channel\n>> type\n>> should they open?\n>>\n>> To resolve this existing ambiguity in the channel type negotiation, we'll\n>> need to make the channel type used for funding _explicit_. Thankfully, we\n>> recently modified the message format to be forwarding looking in order to\n>> allow _TLV extensions_ to be added for all existing message types. A new\n>> `channel_type` (type #???) TLV would be added which makes the channel type\n>> used in funding explicit, with the existing feature bit advertisement\n>> system\n>> being kept in place.\n>>\n>> A draft of the changes in this area would be something like:\n>>\n>>   * `open_channel` and `accept_channel` gain a new `channel_type` TLV\n>> field.\n>>   * retroactively the OG commitment format is numbered as\n>> `channel_type=0`,\n>>     `static_remote_key`, as `channel_type=1`, and anchors as\n>>     `channel_type=2`\n>>   * if one receives an `open_channel`, or `accept_channel` message with an\n>>     unknown `channel_type`, they're to fail the funding flow\n>>   * nodes MUST NOT send an `open_channel` or `accept_channel` message\n>> with a\n>>     `channel_type` that isn't covered by their existing advertise feature\n>>     bits\n>>   * a mapping between feature bits and expected `channel_type` values\n>> would\n>>     then be added\n>>   * during funding negotiation, the _commitment_ type itself is\n>> parametrized\n>>     based on the `channel_type` value\n>>       * as we've all implemented `static_remote_key` commitments at this\n>>         point, I assume the necessary code-level abstractions are already\n>>         in-place\n>>\n>> ## Commitment State Machine Changes\n>>\n>> With the changes described in the above section, we're now able to\n>> explicitly identify _which_ channel type we want to enter a funding flow\n>> for. As we add more types, there may not be a \"default\" type, so making\n>> this\n>> process explicit is important to future exploration and extensibility.  In\n>> this section, we'll introduce a series of small changes to the\n>> `commit_sig`,\n>> and `revoke_and_ack` messages which'll allow us to implement the \"dynamic\"\n>> portion of this proposal.\n>>\n>> Relying once again on the wondrous power of TLV message extensions we'll\n>> carry over the `channel_type` TLV (just the name, # may be diff since this\n>> is a diff message context) to the `commit_sig`, and `revoke_and_ack`\n>> messages. The following guidelines on inclusion and interpretation would\n>> then be applied:\n>>\n>>   * the `channel_type` specified on a given `commit_sig` message should be\n>>     the `channel_type` of the _new_ commitment being _created_\n>>   * when receiving a `commit_sig` with a `channel_type` that differs from\n>>     the `channel_type` of one's on revoked commitment:\n>>      * if the `channel_type` is unknown (or the `channel_type` transition\n>>        isn't allowed or defined), then the _p2p_ connection should be\n>>        aborted\n>>      * otherwise, using the `channel_type` as a parameter for commitment\n>>        transaction construction, a new commitment adhering to the rules of\n>>        the `channel_type` should be constructed\n>>   * the `channel_type` sent in the `revoke_and_ack` message should be the\n>>     `channel_type` of the commitment that's being _revoked_\n>>\n>> With the above new rules, let's say Alice and Bob upgrade to new versions\n>> of\n>> their LN software that support a new channel type `1`, while they're on\n>> channel type `0`. Either triggered automatically, or manually (by either\n>> side), the commitment flow would look something like:\n>>\n>>   1. sig_c_1   ->\n>>   2.          <- revoke_c_0\n>>   3.          <- sig_c_1\n>>   4. revoke_c_0 ->\n>>\n>> By exchanging 4 messages, both sides are able to upgrade to a new\n>> commitment\n>> format. However, one issue with the above flow is that it currently isn't\n>> allowed by the spec, since we disallow sending a `commit_sig` message that\n>> doesn't cover any updates. If we end up going with this route, then we'd\n>> have to relax that constraint to something like:\n>>\n>>   * an empty `commit_sig` message (one that covers no updates) is\n>>     disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n>>     differs from the channel type of the prior commitment, `c_n-1`.\n>>\n>> It would then be up to _new protocol extension documents_ to define _how_\n>> to\n>> construct those new channel types, and also any changes to the on-chain\n>> handling that are required by those channel types. Also certain\n>> transitions\n>> may be disallowed. As an example, implementations may want to prevent a\n>> user\n>> from going back to the non-static remote key channels from the\n>> `static_remote_key` format.\n>>\n>> In order to prepare for these changes, implementations need to be able to\n>> handle \"holding\" unrevoked commitments of heterogeneous types, as if\n>> either\n>> of them hit the chain, they'll need to be able to resolve all contracts\n>> properly.\n>>\n>> An alternative to attaching the `channel_type` message to the `commit_sig`\n>> and having _that_ kick off the commitment upgrade, we could instead\n>> possibly\n>> add a _new_ update message (like `update_fee`) to make the process more\n>> explicit. In either case, we may want to restrict things a bit by only\n>> allowing the initiator to trigger a commitment format update.\n>>\n>> ## Further Channel Type Parameterization\n>>\n>> With the above protocol sketch, we're able to handle \"simple\" upgrades,\n>> where some/all of the parameters of the channel are hard coded and/or have\n>> been negotiated out of band. More complex channel types may require the\n>> exchange of additional keys or parameters which need to be known in order\n>> to\n>> reconstruct the _new_ commitment format and verify the new signature. This\n>> additional information can possibly be piggy-backed on the `commit_sig`\n>> message in the form of a _nested TLV_ type:\n>>\n>>   * a msg-local TLV type `channel_params` is added\n>>   * the value of this TLV type is a nested TLV blob, that contains all the\n>>     necessary fields and values needed to properly handle the channel\n>> switch\n>>     over\n>>\n>> Returning to the flow control example earlier in this post, the new limits\n>> for `max_allowed_htlcs`, can be included in this blob. More complex\n>> channel\n>> types could send information such as new keys to be used, or other\n>> parameters\n>> that govern how a commitment is to be constructed (like the size of the\n>> anchor outputs).\n>>\n>> # Conclusion\n>>\n>> Summarizing, in this post we've proposed a series of protocol\n>> modifications\n>> (with TLV fields doing most of the heavy lifting) that allows LN nodes to\n>> upgrade their commitments _without any on-chain_ transactions. Depending\n>> on\n>> the architecture of a node, new types may even be added/removed without\n>> actual downtime.\n>>\n>> The ability to upgrade commitments after the fact lessens the pressure of\n>> newer possibly experimental channel types to get all the details (and\n>> explore the rather large design space) correct up front. Once Taproot\n>> rolls\n>> around, we can simply update the funding output, roll that out, then\n>> continue to hash out the details on the possibly new channel type(s) that\n>> take advantage of all the new tools.\n>>\n>> Allowing channel types to be upgraded on the fly let's us update the\n>> network\n>> to the new _safer_ channel types in a de-synchronized, distributed manner\n>> that doesn't require any on-chain transactions! Dynamic commitments as a\n>> whole also creates another point of extensibility in the protocol so we\n>> can\n>> start to explore all the variants on channels as we know them that exist.\n>>\n>> I'm keen to gather feedback, as internally for `lnd` we've committed to\n>> exploring this direction so we can start to upgrade _all_ the existing\n>> lnd-involved channels to the new anchor commitment format, which is the\n>> safest format yet.\n>>\n>> [1]: https://eprint.iacr.org/2020/476\n>>\n>> -- Laolu\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200721/b4f893f1/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-21T14:50:39",
                "message_text_only": "Good morning Laolu, and list,\n\nProbably arguably off-topic, but this post triggered me into thinking about an insane idea: offchain update from existing Poon-Dryja to newer Decker-Russell-Osuntokun (\"eltoo\") mechanism.\n\nDue to the way `SIGHASH_ANYPREVOUT` will be deployed --- requires a new pubkey type and works only inside the Taproot construction --- we cannot seamlessly upgrade from a Poon-Dryja channel to a Decker-Russell-Osuntokun.\nThe funding outpoint itself has to be changed.\n\nWe can create an upgrade transaction that is a cut-through of a mutual close of the Poon-Dryja, and a funding open of a Decker-Russell-Osuntokun.\nThis transaction spends the funding outpoint of an existing Poon-Dryja channel, and creates a Decker-Russell-Osuntokun funding outpoint.\n\nHowever, once such an upgrade transaction has been created and signed by both parties (after the necessary initial state is signed in the Decker-Russell-Osuntokun mechanism), nothing prevents the participants from, say, just keeping the upgrade transaction offchain as well.\n\nThe participants can simply, after the upgrade transaction has been signed, revoke the latest Poon-Dryja state (which has been copied into the initial Decker-Russell-Osuntokun state).\nThen they can keep the upgrade transaction offchain, and treat the funding outpoint of the upgrade transaction as the \"internal funding outpoint\" for future Decker-Russell-Osuntokun updates.\n\nNow, of course, since the onchain funding outpoint remains a Poon-Dryja, it can still be spent using a revoked state.\nThus, we do not gain anything much, since the entire HTLC history of the Poon-Dryja channel needs to be retained as protection against theft attempts.\n\nHowever:\n\n* Future HTLCs in the Decker-Russell-Osuntokun domain need not be recorded permanently, thus at least bounding the information liability of the upgraded channel.\n* The channel retains its short-channel-id, which may be useful, since a provably-long-lived channel implies both channel participants have high reliability (else one or the other would have closed the channel at some point), and a pathfinding algorithm may bias towards such long-lived channels.\n\nOf note, is that if the channel is later mutually closed, the upgrade transaction, being offchain, never need appear onchain, so this potentially saves blockchain space.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-07-21T22:55:54",
                "message_text_only": "Hi Z,\n\n> Probably arguably off-topic, but this post triggered me into thinking\n> about an insane idea: offchain update from existing Poon-Dryja to newer\n> Decker-Russell-Osuntokun (\"eltoo\") mechanism.\n\nOoo, yeh I don't see why this would be possible assuming at that point\nno_input has been deployed...\n\nHowever, switching between commitment types that have distinct commitment\ninvalidation mechanisms appears to make things a bit more complex. Consider\nthat since the earlier lifetime of my channel used _revocation_ based\ninvalidation, I'd need to be able to handle two types of invalid commitment\nbroadcasts: broadcast of a revoked commitment, and broadcast of a _replaced_\ncommitment.\n\nAs a result, implementations may want to limit the types of transitions to\nonly a commitment type with the same invalidation mechanism. On the other\nhand, I don't think that additional complexity (being able to handle both\ntypes\nof contract violations) is insurmountable.\n\nFor those that wish to retain a revocation based commitment invalidation\nmodel, they may instead opt to upgrade to something like this [1], which I\nconsider to be the current best successor to the OG Poon-Dryja revocation\nmechanism (has some other tool traits too). The commitment format still\nneeds a sexy name though....\"el tres\"? ;)\n\n> We can create an upgrade transaction that is a cut-through of a mutual\n> close of the Poon-Dryja, and a funding open of a Decker-Russell-Osuntokun.\n\nSplicing reborn!\n\n> The channel retains its short-channel-id, which may be useful, since a\n> provably-long-lived channel implies both channel participants have high\n> reliability (else one or the other would have closed the channel at some\n> point), and a pathfinding algorithm may bias towards such long-lived\n> channels.\n\nIndeed, I think some implementations (eclair?) factor in the age of the\nchannel they're attempting to traverse during path finding.\n\n[1]: https://eprint.iacr.org/2020/476\n\n-- Laolu\n\nOn Tue, Jul 21, 2020 at 7:50 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Laolu, and list,\n>\n> Probably arguably off-topic, but this post triggered me into thinking\n> about an insane idea: offchain update from existing Poon-Dryja to newer\n> Decker-Russell-Osuntokun (\"eltoo\") mechanism.\n>\n> Due to the way `SIGHASH_ANYPREVOUT` will be deployed --- requires a new\n> pubkey type and works only inside the Taproot construction --- we cannot\n> seamlessly upgrade from a Poon-Dryja channel to a Decker-Russell-Osuntokun.\n> The funding outpoint itself has to be changed.\n>\n> We can create an upgrade transaction that is a cut-through of a mutual\n> close of the Poon-Dryja, and a funding open of a Decker-Russell-Osuntokun.\n> This transaction spends the funding outpoint of an existing Poon-Dryja\n> channel, and creates a Decker-Russell-Osuntokun funding outpoint.\n>\n> However, once such an upgrade transaction has been created and signed by\n> both parties (after the necessary initial state is signed in the\n> Decker-Russell-Osuntokun mechanism), nothing prevents the participants\n> from, say, just keeping the upgrade transaction offchain as well.\n>\n> The participants can simply, after the upgrade transaction has been\n> signed, revoke the latest Poon-Dryja state (which has been copied into the\n> initial Decker-Russell-Osuntokun state).\n> Then they can keep the upgrade transaction offchain, and treat the funding\n> outpoint of the upgrade transaction as the \"internal funding outpoint\" for\n> future Decker-Russell-Osuntokun updates.\n>\n> Now, of course, since the onchain funding outpoint remains a Poon-Dryja,\n> it can still be spent using a revoked state.\n> Thus, we do not gain anything much, since the entire HTLC history of the\n> Poon-Dryja channel needs to be retained as protection against theft\n> attempts.\n>\n> However:\n>\n> * Future HTLCs in the Decker-Russell-Osuntokun domain need not be recorded\n> permanently, thus at least bounding the information liability of the\n> upgraded channel.\n> * The channel retains its short-channel-id, which may be useful, since a\n> provably-long-lived channel implies both channel participants have high\n> reliability (else one or the other would have closed the channel at some\n> point), and a pathfinding algorithm may bias towards such long-lived\n> channels.\n>\n> Of note, is that if the channel is later mutually closed, the upgrade\n> transaction, being offchain, never need appear onchain, so this potentially\n> saves blockchain space.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200721/4a762a70/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-22T02:32:47",
                "message_text_only": "Good morning laolu,\n\n> Hi Z,\n>\n> > Probably arguably off-topic, but this post triggered me into thinking\n> > about an insane idea: offchain update from existing Poon-Dryja to newer\n> > Decker-Russell-Osuntokun (\"eltoo\") mechanism.\n>\n> Ooo, yeh I don't see why this would be possible assuming at that point\n> no_input has been deployed...\n>\n> However, switching between commitment types that have distinct commitment\n> invalidation mechanisms appears to make things a bit more complex. Consider\n> that since the earlier lifetime of my channel used _revocation_ based\n> invalidation, I'd need to be able to handle two types of invalid commitment\n> broadcasts: broadcast of a revoked commitment, and broadcast of a _replaced_\n> commitment.\n>\n> As a result, implementations may want to limit the types of transitions to\n> only a commitment type with the same invalidation mechanism. On the other\n> hand, I don't think that additional complexity (being able to handle both types\n> of contract violations) is insurmountable.\n\nWhat I am proposing is that there is an adaptor, an upgrade transaction, which transitions from one type to the other.\n\nThis is needed in transitioning to the Decker-Russell-Osuntokun case anyway, since as mentioned, current Poon-Dryja channels use P2WSH while `SIGHASH_ANYPREVOUT`, which Decker-Russell-Osuntokun absolutely relies on, will only be available on Taproot outputs.\n\nThen, the only thing you need to watch for will be old state for the *oldest* mechanism the channel had (i.e. the mechanism used at the time of channel construction), OR the upgrade transaction.\n\nWhen you see the upgrade transaction onchain, you then switch to watching for the next-oldest mechanism of the channel.\n\nIf a third mechanism is implemented for channels on Lightning as well and this channel is upgraded again from Decker-Russell-Osuntokun to this third mechanism, then at this point you switch to watching for revoked states of Decker-Russell-Osuntokun OR the 2-to-3 upgrade transaction.\n\n\n> For those that wish to retain a revocation based commitment invalidation\n> model, they may instead opt to upgrade to something like this [1], which I\n> consider to be the current best successor to the OG Poon-Dryja revocation\n> mechanism (has some other tool traits too). The commitment format still\n> needs a sexy name though....\"el tres\"? ;)\n\nInteresting, will check.\n\nCalling it Aumayr-Ersoy-Erwig-Faust-Hostakova-Maffei-Moreno-Sanchez-Riahi seems fine to me. :P\n\n> > We can create an upgrade transaction that is a cut-through of a mutual\n> > close of the Poon-Dryja, and a funding open of a Decker-Russell-Osuntokun.\n>\n> Splicing reborn!\n\nNot quite splicing: the issue with splice-in (and only splice-in, splice-out is trivial) is that there is another UTXO being spent, which can invalidate the transaction that does the splice-in, and leave the channel in limbo.\n\nThis upgrade transaction is a 1-input 1-output transaction, spending from the previous funding outpoint for a particular channel mechanism, and then creating a new funding outpoint.\n\nThe trick is that the upgrade tranaction is ***not*** broadcast (i.e. we do not close and reopen the channel), it is kept offchain in your database, waiting to be lost by disk failure like all the other important data, and at mutual close the upgrade transaction can be ignored.\n\nThe node only needs to keep watching for theft attempts on the *oldest* mechanism the channel has, as the upgrade transaction appearing onchain signals when the node has to switch over to watching for the newer mechanism(s).\n\n>\n> > The channel retains its short-channel-id, which may be useful, since a\n> > provably-long-lived channel implies both channel participants have high\n> > reliability (else one or the other would have closed the channel at some\n> > point), and a pathfinding algorithm may bias towards such long-lived\n> > channels.\n>\n> Indeed, I think some implementations (eclair?) factor in the age of the\n> channel they're attempting to traverse during path finding.\n>\n\nIndeed, which is why you might want to upgrade a Poon-Dryja to a Decker-Russell-Osuntokun.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-07-21T22:31:45",
                "message_text_only": "After getting some feedback from the Lightning Labs squad, we're thinking\nthat it may be better to make the initial switch over double-opt-in, similar\nto the current `shutdown` message flow. So with this variant, we'd add two\nnew messages: `commit_switch` and `commit_switch_reply` (placeholder\nnames). We may want to retain the \"initiator\" only etiquette for simplicity,\nbut if we want to allow both sides to initiate then we'll need to handle\ncollisions (with a randomized back off possibly).\n\nThe `commit_switch` message would contain the new target `channel_type` and\nthe opaque TLV blob of the re-negotiation parameters. The\n`commit_switch_reply` message would then give the receiver the ability to\n_reject_ the switch (say it doesn't want to increase `max_allowed_htlcs`),\nor accept it, and specify its own set of parameters. Similar to the\n`shutdown` message, both parties can only proceed with the switch over _once\nall HTLCs_ have been cleared. As a result, they should reject any HTLC\nforwarding attempts through the target channel once they receive the initial\nmessage. From there, they'd carry out the modified commitment dance outlined\nin my prior mail.\n\nThoughts?\n\n-- Laolu\n\n-- Laolu\n\nOn Mon, Jul 20, 2020 at 6:18 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Hi y'all,\n>\n> In this post, I'd like to share an early version of an extension to the\n> spec\n> and channel state machine that would allow for on-the-fly commitment\n> _format/type_ changes. Notably, this would allow for us to _upgrade_\n> commitment types without any on-chain activity, executed in a\n> de-synchronized and distributed manner. The core realization these proposal\n> is based on the fact that the funding output is the _only_ component of a\n> channel that's actually set in stone (requires an on-chain transaction to\n> modify).\n>\n>\n> # Motivation\n>\n> (you can skip this section if you already know why something like this is\n> important)\n>\n> First, some motivation. As y'all are likely aware, the current deployed\n> commitment format has changed once so far: to introduce the\n> `static_remote_key` variant which makes channels safer by sending the funds\n> of the party that was force closed on to a plain pubkey w/o any extra\n> tweaks\n> or derivation. This makes channel recovery safer, as the party that may\n> have\n> lost data (or can't continue the channel), no longer needs to learn of a\n> secret value sent to them by the other party to be able to claim their\n> funds. However, as this new format was introduced sometime after the\n> initial\n> bootstrapping phase of the network, most channels in the wild today _are\n> not_ using this safer format.  Transitioning _all_ the existing channels to\n> this new format as is, would require closing them _all_, generating tens of\n> thousands of on-chain transactions (to close, then re-open), not to mention\n> chain fees.\n>\n> With dynamic commitments, users will be able to upgrade their _existing_\n> channels to new safer types, without any new on-chain transactions!\n>\n> Anchor output based commitments represent another step forward in making\n> channels safer as they allow users/software to no longer have to predict\n> chain fees ahead of time, and also bump up the fee of a\n> commitment/2nd-level-htlc-transaction, which is extremely important when it\n> comes to timely on-chain resolution of HTLC contracts. This upgrade process\n> (as touched on below) can either be manually triggered, or automatically\n> triggered once the software updates and finds a new preferable default\n> commitment format is available.\n>\n> As many of us are aware, the addition of schnorr and taproot to the Bitcoin\n> protocol dramatically increases the design space for channels as a whole.\n> It\n> may take some time to explore this design space, particularly as entirely\n> new channel/commitment formats [1] continue to be discovered. The roll out\n> of dynamic commitments allows us to defer the concrete design of the future\n> commitment formats, yet still benefit from the immediate improvement that\n> comes with morphing the funding output to be a single-key (non-p2wsh,\n> though\n> the line starts to blur w/ taproot) output. With this new funding output\n> format in place, users/software will then be able to update to the latest\n> and greatest commitment format that starts to utilize all the new tools\n> available (scriptless script based htlcs, etc) at a later date.\n>\n> Finally, the ability to update the commitment format itself will also allow\n> us to re-parametrize portions of the channels which are currently set in\n> stone. As an example, right now the # of max allowed outstanding HTLCs is\n> set in stone once the channel has opened. With the ability to also swap out\n> commitment _parameters_, we can start to experiment with flow-control like\n> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n> which is then progressively increased based on \"good behavior\" (or the\n> other\n> way around as well). Beyond just updating the channel parameters, it's also\n> possible to \"change the rules\" of a channel on the fly. An example of this\n> variant would be creating a new psuedo-type that implements a fee policy\n> other than \"the initiator pays all fees\".\n>\n>\n> # Protocol Changes\n>\n> With the motivation/background set up, let's dig into some potential ways\n> the protocol can be modified to support this new meta-feature. As this\n> change is more of a meta-change, AFAICT, the amount of protocol changes\n> doesn't appear to be _too_ invasive ;). Most of the heavy lifting is done\n> by\n> the wondrous TLV message field extensions.\n>\n> ## Explicit Channel Type Negotiation\n>\n> Right now in the protocol, as new channel types are introduced (static key,\n> and now anchors) we add a new feature bit. If both nodes have the feature\n> bit set, then that new channel type is to be used. Notice how this is an\n> _implicit_ upgrade: there's no explicit signalling during the _funding_\n> process that a new channel type is to be used. This works OK, if there's\n> one\n> major accepted \"official\" channel type, but not as new types are introduced\n> for specific use cases or applications. The implicit negotiation also makes\n> things a bit ambiguous at times. As an example, if both nodes have the\n> `static_remote_key` _and_ anchor outputs feature bit set, which channel\n> type\n> should they open?\n>\n> To resolve this existing ambiguity in the channel type negotiation, we'll\n> need to make the channel type used for funding _explicit_. Thankfully, we\n> recently modified the message format to be forwarding looking in order to\n> allow _TLV extensions_ to be added for all existing message types. A new\n> `channel_type` (type #???) TLV would be added which makes the channel type\n> used in funding explicit, with the existing feature bit advertisement\n> system\n> being kept in place.\n>\n> A draft of the changes in this area would be something like:\n>\n>   * `open_channel` and `accept_channel` gain a new `channel_type` TLV\n> field.\n>   * retroactively the OG commitment format is numbered as `channel_type=0`,\n>     `static_remote_key`, as `channel_type=1`, and anchors as\n>     `channel_type=2`\n>   * if one receives an `open_channel`, or `accept_channel` message with an\n>     unknown `channel_type`, they're to fail the funding flow\n>   * nodes MUST NOT send an `open_channel` or `accept_channel` message with\n> a\n>     `channel_type` that isn't covered by their existing advertise feature\n>     bits\n>   * a mapping between feature bits and expected `channel_type` values would\n>     then be added\n>   * during funding negotiation, the _commitment_ type itself is\n> parametrized\n>     based on the `channel_type` value\n>       * as we've all implemented `static_remote_key` commitments at this\n>         point, I assume the necessary code-level abstractions are already\n>         in-place\n>\n> ## Commitment State Machine Changes\n>\n> With the changes described in the above section, we're now able to\n> explicitly identify _which_ channel type we want to enter a funding flow\n> for. As we add more types, there may not be a \"default\" type, so making\n> this\n> process explicit is important to future exploration and extensibility.  In\n> this section, we'll introduce a series of small changes to the\n> `commit_sig`,\n> and `revoke_and_ack` messages which'll allow us to implement the \"dynamic\"\n> portion of this proposal.\n>\n> Relying once again on the wondrous power of TLV message extensions we'll\n> carry over the `channel_type` TLV (just the name, # may be diff since this\n> is a diff message context) to the `commit_sig`, and `revoke_and_ack`\n> messages. The following guidelines on inclusion and interpretation would\n> then be applied:\n>\n>   * the `channel_type` specified on a given `commit_sig` message should be\n>     the `channel_type` of the _new_ commitment being _created_\n>   * when receiving a `commit_sig` with a `channel_type` that differs from\n>     the `channel_type` of one's on revoked commitment:\n>      * if the `channel_type` is unknown (or the `channel_type` transition\n>        isn't allowed or defined), then the _p2p_ connection should be\n>        aborted\n>      * otherwise, using the `channel_type` as a parameter for commitment\n>        transaction construction, a new commitment adhering to the rules of\n>        the `channel_type` should be constructed\n>   * the `channel_type` sent in the `revoke_and_ack` message should be the\n>     `channel_type` of the commitment that's being _revoked_\n>\n> With the above new rules, let's say Alice and Bob upgrade to new versions\n> of\n> their LN software that support a new channel type `1`, while they're on\n> channel type `0`. Either triggered automatically, or manually (by either\n> side), the commitment flow would look something like:\n>\n>   1. sig_c_1   ->\n>   2.          <- revoke_c_0\n>   3.          <- sig_c_1\n>   4. revoke_c_0 ->\n>\n> By exchanging 4 messages, both sides are able to upgrade to a new\n> commitment\n> format. However, one issue with the above flow is that it currently isn't\n> allowed by the spec, since we disallow sending a `commit_sig` message that\n> doesn't cover any updates. If we end up going with this route, then we'd\n> have to relax that constraint to something like:\n>\n>   * an empty `commit_sig` message (one that covers no updates) is\n>     disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n>     differs from the channel type of the prior commitment, `c_n-1`.\n>\n> It would then be up to _new protocol extension documents_ to define _how_\n> to\n> construct those new channel types, and also any changes to the on-chain\n> handling that are required by those channel types. Also certain transitions\n> may be disallowed. As an example, implementations may want to prevent a\n> user\n> from going back to the non-static remote key channels from the\n> `static_remote_key` format.\n>\n> In order to prepare for these changes, implementations need to be able to\n> handle \"holding\" unrevoked commitments of heterogeneous types, as if either\n> of them hit the chain, they'll need to be able to resolve all contracts\n> properly.\n>\n> An alternative to attaching the `channel_type` message to the `commit_sig`\n> and having _that_ kick off the commitment upgrade, we could instead\n> possibly\n> add a _new_ update message (like `update_fee`) to make the process more\n> explicit. In either case, we may want to restrict things a bit by only\n> allowing the initiator to trigger a commitment format update.\n>\n> ## Further Channel Type Parameterization\n>\n> With the above protocol sketch, we're able to handle \"simple\" upgrades,\n> where some/all of the parameters of the channel are hard coded and/or have\n> been negotiated out of band. More complex channel types may require the\n> exchange of additional keys or parameters which need to be known in order\n> to\n> reconstruct the _new_ commitment format and verify the new signature. This\n> additional information can possibly be piggy-backed on the `commit_sig`\n> message in the form of a _nested TLV_ type:\n>\n>   * a msg-local TLV type `channel_params` is added\n>   * the value of this TLV type is a nested TLV blob, that contains all the\n>     necessary fields and values needed to properly handle the channel\n> switch\n>     over\n>\n> Returning to the flow control example earlier in this post, the new limits\n> for `max_allowed_htlcs`, can be included in this blob. More complex channel\n> types could send information such as new keys to be used, or other\n> parameters\n> that govern how a commitment is to be constructed (like the size of the\n> anchor outputs).\n>\n> # Conclusion\n>\n> Summarizing, in this post we've proposed a series of protocol modifications\n> (with TLV fields doing most of the heavy lifting) that allows LN nodes to\n> upgrade their commitments _without any on-chain_ transactions. Depending on\n> the architecture of a node, new types may even be added/removed without\n> actual downtime.\n>\n> The ability to upgrade commitments after the fact lessens the pressure of\n> newer possibly experimental channel types to get all the details (and\n> explore the rather large design space) correct up front. Once Taproot rolls\n> around, we can simply update the funding output, roll that out, then\n> continue to hash out the details on the possibly new channel type(s) that\n> take advantage of all the new tools.\n>\n> Allowing channel types to be upgraded on the fly let's us update the\n> network\n> to the new _safer_ channel types in a de-synchronized, distributed manner\n> that doesn't require any on-chain transactions! Dynamic commitments as a\n> whole also creates another point of extensibility in the protocol so we can\n> start to explore all the variants on channels as we know them that exist.\n>\n> I'm keen to gather feedback, as internally for `lnd` we've committed to\n> exploring this direction so we can start to upgrade _all_ the existing\n> lnd-involved channels to the new anchor commitment format, which is the\n> safest format yet.\n>\n> [1]: https://eprint.iacr.org/2020/476\n>\n> -- Laolu\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200721/0cbf3fba/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-07-21T23:47:27",
                "message_text_only": "Hi Laolu,\n\nI think that's a must before we introduce a bunch of new features and the\nnumber of channels explodes. The de-synchronized side could be underscored\nmore as any scheduled, automatic, massive upgrade for security forcing\nchain writes can be exploited to launch  mempool-congestion attacks.\n\n> Finally, the ability to update the commitment format itself will also\nallow\n> us to re-parametrize portions of the channels which are currently set in\n> stone. As an example, right now the # of max allowed outstanding HTLCs is\n> set in stone once the channel has opened. With the ability to also swap\nout\n> commitment _parameters_, we can start to experiment with flow-control like\n> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n> which is then progressively increased based on \"good behavior\" (or the\nother\n> way around as well). Beyond just updating the channel parameters, it's\nalso\n> possible to \"change the rules\" of a channel on the fly. An example of this\n> variant would be creating a new psuedo-type that implements a fee policy\n> other than \"the initiator pays all fees\".\n\nYes, there is a wide scope of events for which you want to upgrade:\n* fine-grained security policies, like scaling your\n`channel_reserve_satoshis`/`to_self_delay` based on my balance increasing\n* fee-market adjustments, like increasing `dust_limit_satoshis` or\n`feerate_per_kw`\n* new features deployments, scoping channel types, commitment types, new\nchannel attributes (`max_dust_value`), new packets types (DLC/PTLC)\n* basepoints rotation, as a good practice you may want to swap them every X\n* routing strategies adjustments, increase `max_accepted_htlcs` to attract\nmore traffic\n\nGiven complexity negotiation, we should cleanly dissociate the signaling of\nupgraded component  (\"I want to update output type\") from the upgrade\nrational (\"I want to update because my fee-estimator sees a feerate\nincrease\"). Former should be obviously part of the spec, latter should be\nleft as a client-side policy, beyond avoiding footgunish behaviors.\n\n> To solve this existing ambiguity in the channel type negotiation, we'll\n> need to make the channel type used for funding _explicit_. Thankfully, we\n> recently modified the message format to be forwarding looking in order to\n> allow _TLV extensions_ to be added for all existing message types. A new\n> `channel_type` (type #???) TLV would be added which makes the channel type\n> used in funding explicit, with the existing feature bit advertisement\nsystem\n> being kept in place.\n\nI think we may need more than channel_type, like\ncommitment_type/output_type. Or else we may have factorial complexity to\ncheck every features combination. As you said, TLV should make it easy.\n\n> As we add more types, there may not be a \"default\" type, so making this\nprocess explicit is important to future exploration and extensibility.\n\nWe may want a \"default\" type based on the most secure/private one to avoid\ndowngrade attack a la TLS between implementations. If we introduce dynamic\nnegotiation, Alice supporting type X,Y,Z with X being the less secure, Bob\na malicious routing node only signals X to force a X channel opening. To\navoid this, we may deprecate from negotiation older types once newer ones\nare widely deployed. Maybe that you meant by \"`channel_type transition\nisn't allowed\". Experimental/advanced features can stay in allowed\nnegotiation range but feature-gated behind some flags.\n\n\n> An alternative to attaching the `channel_type` message to the `commit_sig`\n> and having _that_ kick off the commitment upgrade, we could instead\npossibly\n> add a _new_ update message (like `update_fee`) to make the process more\n> explicit. In either case, we may want to restrict things a bit by only\n> allowing the initiator to trigger a commitment format update.\n\nI favor this alternative, as your new channel type may imply a channel\ndata/round-trip extension  (like signatures round-trip for PTLCs). Or if\nyou constrain channel-flow policy, your added HTLCs might in fact be\nunlawful. We should avoid dependencies where validity of upgrades depend on\nchannel state.\n\nMoving forward, we may want to start with a minimal first-step with just\nintroducing a new `upgrade_channel` message and its handling flow + new TLV\nin `open/accept`. And then slowly increase scope of what you can actually\nupgrade/negotiate.\n\nOverall, that's a really cool proposal, dynamic commitment doesn't say\nenough on scope, maybe \"flexible channels\" :) ?\n\nAntoine\n\nLe lun. 20 juil. 2020 \u00e0 21:18, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n\u00e9crit :\n\n> Hi y'all,\n>\n> In this post, I'd like to share an early version of an extension to the\n> spec\n> and channel state machine that would allow for on-the-fly commitment\n> _format/type_ changes. Notably, this would allow for us to _upgrade_\n> commitment types without any on-chain activity, executed in a\n> de-synchronized and distributed manner. The core realization these proposal\n> is based on the fact that the funding output is the _only_ component of a\n> channel that's actually set in stone (requires an on-chain transaction to\n> modify).\n>\n>\n> # Motivation\n>\n> (you can skip this section if you already know why something like this is\n> important)\n>\n> First, some motivation. As y'all are likely aware, the current deployed\n> commitment format has changed once so far: to introduce the\n> `static_remote_key` variant which makes channels safer by sending the funds\n> of the party that was force closed on to a plain pubkey w/o any extra\n> tweaks\n> or derivation. This makes channel recovery safer, as the party that may\n> have\n> lost data (or can't continue the channel), no longer needs to learn of a\n> secret value sent to them by the other party to be able to claim their\n> funds. However, as this new format was introduced sometime after the\n> initial\n> bootstrapping phase of the network, most channels in the wild today _are\n> not_ using this safer format.  Transitioning _all_ the existing channels to\n> this new format as is, would require closing them _all_, generating tens of\n> thousands of on-chain transactions (to close, then re-open), not to mention\n> chain fees.\n>\n> With dynamic commitments, users will be able to upgrade their _existing_\n> channels to new safer types, without any new on-chain transactions!\n>\n> Anchor output based commitments represent another step forward in making\n> channels safer as they allow users/software to no longer have to predict\n> chain fees ahead of time, and also bump up the fee of a\n> commitment/2nd-level-htlc-transaction, which is extremely important when it\n> comes to timely on-chain resolution of HTLC contracts. This upgrade process\n> (as touched on below) can either be manually triggered, or automatically\n> triggered once the software updates and finds a new preferable default\n> commitment format is available.\n>\n> As many of us are aware, the addition of schnorr and taproot to the Bitcoin\n> protocol dramatically increases the design space for channels as a whole.\n> It\n> may take some time to explore this design space, particularly as entirely\n> new channel/commitment formats [1] continue to be discovered. The roll out\n> of dynamic commitments allows us to defer the concrete design of the future\n> commitment formats, yet still benefit from the immediate improvement that\n> comes with morphing the funding output to be a single-key (non-p2wsh,\n> though\n> the line starts to blur w/ taproot) output. With this new funding output\n> format in place, users/software will then be able to update to the latest\n> and greatest commitment format that starts to utilize all the new tools\n> available (scriptless script based htlcs, etc) at a later date.\n>\n> Finally, the ability to update the commitment format itself will also allow\n> us to re-parametrize portions of the channels which are currently set in\n> stone. As an example, right now the # of max allowed outstanding HTLCs is\n> set in stone once the channel has opened. With the ability to also swap out\n> commitment _parameters_, we can start to experiment with flow-control like\n> ideas such as limiting a new channel peer to only a handful of HTLC slots,\n> which is then progressively increased based on \"good behavior\" (or the\n> other\n> way around as well). Beyond just updating the channel parameters, it's also\n> possible to \"change the rules\" of a channel on the fly. An example of this\n> variant would be creating a new psuedo-type that implements a fee policy\n> other than \"the initiator pays all fees\".\n>\n>\n> # Protocol Changes\n>\n> With the motivation/background set up, let's dig into some potential ways\n> the protocol can be modified to support this new meta-feature. As this\n> change is more of a meta-change, AFAICT, the amount of protocol changes\n> doesn't appear to be _too_ invasive ;). Most of the heavy lifting is done\n> by\n> the wondrous TLV message field extensions.\n>\n> ## Explicit Channel Type Negotiation\n>\n> Right now in the protocol, as new channel types are introduced (static key,\n> and now anchors) we add a new feature bit. If both nodes have the feature\n> bit set, then that new channel type is to be used. Notice how this is an\n> _implicit_ upgrade: there's no explicit signalling during the _funding_\n> process that a new channel type is to be used. This works OK, if there's\n> one\n> major accepted \"official\" channel type, but not as new types are introduced\n> for specific use cases or applications. The implicit negotiation also makes\n> things a bit ambiguous at times. As an example, if both nodes have the\n> `static_remote_key` _and_ anchor outputs feature bit set, which channel\n> type\n> should they open?\n>\n> To resolve this existing ambiguity in the channel type negotiation, we'll\n> need to make the channel type used for funding _explicit_. Thankfully, we\n> recently modified the message format to be forwarding looking in order to\n> allow _TLV extensions_ to be added for all existing message types. A new\n> `channel_type` (type #???) TLV would be added which makes the channel type\n> used in funding explicit, with the existing feature bit advertisement\n> system\n> being kept in place.\n>\n> A draft of the changes in this area would be something like:\n>\n>   * `open_channel` and `accept_channel` gain a new `channel_type` TLV\n> field.\n>   * retroactively the OG commitment format is numbered as `channel_type=0`,\n>     `static_remote_key`, as `channel_type=1`, and anchors as\n>     `channel_type=2`\n>   * if one receives an `open_channel`, or `accept_channel` message with an\n>     unknown `channel_type`, they're to fail the funding flow\n>   * nodes MUST NOT send an `open_channel` or `accept_channel` message with\n> a\n>     `channel_type` that isn't covered by their existing advertise feature\n>     bits\n>   * a mapping between feature bits and expected `channel_type` values would\n>     then be added\n>   * during funding negotiation, the _commitment_ type itself is\n> parametrized\n>     based on the `channel_type` value\n>       * as we've all implemented `static_remote_key` commitments at this\n>         point, I assume the necessary code-level abstractions are already\n>         in-place\n>\n> ## Commitment State Machine Changes\n>\n> With the changes described in the above section, we're now able to\n> explicitly identify _which_ channel type we want to enter a funding flow\n> for. As we add more types, there may not be a \"default\" type, so making\n> this\n> process explicit is important to future exploration and extensibility.  In\n> this section, we'll introduce a series of small changes to the\n> `commit_sig`,\n> and `revoke_and_ack` messages which'll allow us to implement the \"dynamic\"\n> portion of this proposal.\n>\n> Relying once again on the wondrous power of TLV message extensions we'll\n> carry over the `channel_type` TLV (just the name, # may be diff since this\n> is a diff message context) to the `commit_sig`, and `revoke_and_ack`\n> messages. The following guidelines on inclusion and interpretation would\n> then be applied:\n>\n>   * the `channel_type` specified on a given `commit_sig` message should be\n>     the `channel_type` of the _new_ commitment being _created_\n>   * when receiving a `commit_sig` with a `channel_type` that differs from\n>     the `channel_type` of one's on revoked commitment:\n>      * if the `channel_type` is unknown (or the `channel_type` transition\n>        isn't allowed or defined), then the _p2p_ connection should be\n>        aborted\n>      * otherwise, using the `channel_type` as a parameter for commitment\n>        transaction construction, a new commitment adhering to the rules of\n>        the `channel_type` should be constructed\n>   * the `channel_type` sent in the `revoke_and_ack` message should be the\n>     `channel_type` of the commitment that's being _revoked_\n>\n> With the above new rules, let's say Alice and Bob upgrade to new versions\n> of\n> their LN software that support a new channel type `1`, while they're on\n> channel type `0`. Either triggered automatically, or manually (by either\n> side), the commitment flow would look something like:\n>\n>   1. sig_c_1   ->\n>   2.          <- revoke_c_0\n>   3.          <- sig_c_1\n>   4. revoke_c_0 ->\n>\n> By exchanging 4 messages, both sides are able to upgrade to a new\n> commitment\n> format. However, one issue with the above flow is that it currently isn't\n> allowed by the spec, since we disallow sending a `commit_sig` message that\n> doesn't cover any updates. If we end up going with this route, then we'd\n> have to relax that constraint to something like:\n>\n>   * an empty `commit_sig` message (one that covers no updates) is\n>     disallowed, unless the `commit_sig` has a `channel_type`, `c_n` that\n>     differs from the channel type of the prior commitment, `c_n-1`.\n>\n> It would then be up to _new protocol extension documents_ to define _how_\n> to\n> construct those new channel types, and also any changes to the on-chain\n> handling that are required by those channel types. Also certain transitions\n> may be disallowed. As an example, implementations may want to prevent a\n> user\n> from going back to the non-static remote key channels from the\n> `static_remote_key` format.\n>\n> In order to prepare for these changes, implementations need to be able to\n> handle \"holding\" unrevoked commitments of heterogeneous types, as if either\n> of them hit the chain, they'll need to be able to resolve all contracts\n> properly.\n>\n> An alternative to attaching the `channel_type` message to the `commit_sig`\n> and having _that_ kick off the commitment upgrade, we could instead\n> possibly\n> add a _new_ update message (like `update_fee`) to make the process more\n> explicit. In either case, we may want to restrict things a bit by only\n> allowing the initiator to trigger a commitment format update.\n>\n> ## Further Channel Type Parameterization\n>\n> With the above protocol sketch, we're able to handle \"simple\" upgrades,\n> where some/all of the parameters of the channel are hard coded and/or have\n> been negotiated out of band. More complex channel types may require the\n> exchange of additional keys or parameters which need to be known in order\n> to\n> reconstruct the _new_ commitment format and verify the new signature. This\n> additional information can possibly be piggy-backed on the `commit_sig`\n> message in the form of a _nested TLV_ type:\n>\n>   * a msg-local TLV type `channel_params` is added\n>   * the value of this TLV type is a nested TLV blob, that contains all the\n>     necessary fields and values needed to properly handle the channel\n> switch\n>     over\n>\n> Returning to the flow control example earlier in this post, the new limits\n> for `max_allowed_htlcs`, can be included in this blob. More complex channel\n> types could send information such as new keys to be used, or other\n> parameters\n> that govern how a commitment is to be constructed (like the size of the\n> anchor outputs).\n>\n> # Conclusion\n>\n> Summarizing, in this post we've proposed a series of protocol modifications\n> (with TLV fields doing most of the heavy lifting) that allows LN nodes to\n> upgrade their commitments _without any on-chain_ transactions. Depending on\n> the architecture of a node, new types may even be added/removed without\n> actual downtime.\n>\n> The ability to upgrade commitments after the fact lessens the pressure of\n> newer possibly experimental channel types to get all the details (and\n> explore the rather large design space) correct up front. Once Taproot rolls\n> around, we can simply update the funding output, roll that out, then\n> continue to hash out the details on the possibly new channel type(s) that\n> take advantage of all the new tools.\n>\n> Allowing channel types to be upgraded on the fly let's us update the\n> network\n> to the new _safer_ channel types in a de-synchronized, distributed manner\n> that doesn't require any on-chain transactions! Dynamic commitments as a\n> whole also creates another point of extensibility in the protocol so we can\n> start to explore all the variants on channels as we know them that exist.\n>\n> I'm keen to gather feedback, as internally for `lnd` we've committed to\n> exploring this direction so we can start to upgrade _all_ the existing\n> lnd-involved channels to the new anchor commitment format, which is the\n> safest format yet.\n>\n> [1]: https://eprint.iacr.org/2020/476\n>\n> -- Laolu\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200721/b9ce80c7/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Dynamic Commitments: Upgrading Channels Without On-Chain Transactions",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Olaoluwa Osuntokun",
                "Antoine Riard",
                "ZmnSCPxj"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 91627
        }
    }
]