[
    {
        "title": "[Lightning-dev] Dropping Tor v2 onion services from node_announcement",
        "thread_messages": [
            {
                "author": "darosior",
                "date": "2021-06-01T22:18:42",
                "message_text_only": "Hi all,\n\nIt's been almost 9 months since Tor v2 hidden services have been deprecated.\nThe Tor project will drop v2 support in about a month in the latest release. It will then be entirely be dropped from all supported releases by October.\nMore at https://blog.torproject.org/v2-deprecation-timeline .\n\nBitcoin Core defaults to v3 since 0.21.0 (https://bitcoincore.org/en/releases/0.21.0/) and is planning to drop the v2 support for 0.22 (https://github.com/bitcoin/bitcoin/pull/22050), which means that v2 onions will gradually stop being gossiped on the Bitcoin network.\n\nI think we should do the same for the Lightning network, and the timeline is rather tight. Also, the configuration is user-facing (as opposed to Bitcoin Core, which generates ephemeral services) which i expect to make the transition trickier.\nC-lightning is deprecating the configuration of Tor v2 services starting next release, according to our deprecation policy we should be able to entirely drop its support 3 releases after this one, which should be not so far from the October deadline.\n\nOpinions? What is the state of other implementations with regard to Tor v2 support?\n\nAntoine"
            },
            {
                "author": "Peter Todd",
                "date": "2021-06-02T02:41:11",
                "message_text_only": "On Tue, Jun 01, 2021 at 10:18:42PM +0000, darosior via Lightning-dev wrote:\n> Hi all,\n> \n> It's been almost 9 months since Tor v2 hidden services have been deprecated.\n> The Tor project will drop v2 support in about a month in the latest release. It will then be entirely be dropped from all supported releases by October.\n> More at https://blog.torproject.org/v2-deprecation-timeline .\n> \n> Bitcoin Core defaults to v3 since 0.21.0 (https://bitcoincore.org/en/releases/0.21.0/) and is planning to drop the v2 support for 0.22 (https://github.com/bitcoin/bitcoin/pull/22050), which means that v2 onions will gradually stop being gossiped on the Bitcoin network.\n> \n> I think we should do the same for the Lightning network, and the timeline is rather tight. Also, the configuration is user-facing (as opposed to Bitcoin Core, which generates ephemeral services) which i expect to make the transition trickier.\n> C-lightning is deprecating the configuration of Tor v2 services starting next release, according to our deprecation policy we should be able to entirely drop its support 3 releases after this one, which should be not so far from the October deadline.\n> \n> Opinions? What is the state of other implementations with regard to Tor v2 support?\n\nOne small point re: discussing this topic: remember that Tor is a centralized\nsystem with a centralized consensus and directory authorities. So when they say\nthey are dropping v2 hidden services, at some point in the near future that\ncentral infrastructure will also drop v2 hidden service support, and v2 hidden\nservices _will_ stop working on the Tor network. So it is pointless to keep\nsupport for v2 hidden services beyond Tor's stated deadlines (other than things\nlike maybe ignoring old v2-related config options and the like).\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210601/97f57399/attachment.sig>"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-06-10T20:40:21",
                "message_text_only": "There isn\u2019t a lot to do at the spec level to deprecate them - nodes should start ignoring the addresses bug nodes always need to know the length/parse v2 Onion addresses forever as well as store and forward them. We could amend the spec to say that nodes shouldn\u2019t produce them but it won\u2019t change the receive/process end much.\n\n> On Jun 1, 2021, at 18:19, darosior via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffHi all,\n> \n> It's been almost 9 months since Tor v2 hidden services have been deprecated.\n> The Tor project will drop v2 support in about a month in the latest release. It will then be entirely be dropped from all supported releases by October.\n> More at https://blog.torproject.org/v2-deprecation-timeline .\n> \n> Bitcoin Core defaults to v3 since 0.21.0 (https://bitcoincore.org/en/releases/0.21.0/) and is planning to drop the v2 support for 0.22 (https://github.com/bitcoin/bitcoin/pull/22050), which means that v2 onions will gradually stop being gossiped on the Bitcoin network.\n> \n> I think we should do the same for the Lightning network, and the timeline is rather tight. Also, the configuration is user-facing (as opposed to Bitcoin Core, which generates ephemeral services) which i expect to make the transition trickier.\n> C-lightning is deprecating the configuration of Tor v2 services starting next release, according to our deprecation policy we should be able to entirely drop its support 3 releases after this one, which should be not so far from the October deadline.\n> \n> Opinions? What is the state of other implementations with regard to Tor v2 support?\n> \n> Antoine\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Dropping Tor v2 onion services from node_announcement",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Peter Todd",
                "Matt Corallo",
                "darosior"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5094
        }
    },
    {
        "title": "[Lightning-dev] Improving Payment Latency by Fast Forwards",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2021-06-02T01:45:56",
                "message_text_only": "Hi Z,\n\nI just went through the presentation which made your thinking very clear.\nThanks.\nI will not be able to match this effort so please bear with me as I try and\nexplain my own thinking.\nI don't see why fast forwards (FF) need \"symmetrically encumbered outputs\"?\nTo me the protocol should be asymmetric.\n\nThis is what I think happens when offering a FF HTLC:\n1. The offerer creates and signs a new commitment tx as normal with the\nHTLC except it has the same revocation key as the last one.\n2. The offerer patches their balance output by sending a tx spending from\nit to a new tx which has the HTLC output and their balance output\n(unencumbered).\n\nThe HTLC is now irrevocably committed from the perspective of the receiver.\nNow the receiver presents the pre-image and the offerer then:\n\n1. The offerer creates and signs a new commitment tx as normal\nconsolidating the funds into the receiver's balance output except once\nagain it has the same revocation key as the last one.\n2. The offerer patches their commitment tx balance output again by sending\na tx spending from it to a new tx which splits into the receiver's balance\n(the value of the claimed HTLC) and the offerer's remaining balance.\n\nYou can repeat the above process without having the receiver's revocation\nkeys online or their commitment tx keys for many HTLCs while the offerer\nstill has balance towards the receiver.\nThe on-chain cost is about the same as before for an uncooperative close.\n\nOnce the receiver brings their keys on line they can consolidate the FF\nstate into a new commitment txs on both sides and with a proper revocation\noperate the channel normally. What has been the receiver up until now can\nfinally send funds.\n\nAm I missing something?\n\nCheers,\n\nLL\n\nOn Mon, 31 May 2021 at 19:47, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> > It may be difficult to understand this, so maybe I will make a\n> convenient presentation of some sort.\n>\n> As promised: https://zmnscpxj.github.io/offchain/2021-06-fast-forwards.odp\n>\n> The presentation is intended to be seen by semi-technical and technical\n> people, particular those that have not read (or managed to fully read and\n> understand) the original writeup in 2019.\n> Simply \"run\" the presentation (F5 in LibreOffice), as the presentation\n> uses callouts extensively for explication.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210602/d72b5993/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-02T02:45:47",
                "message_text_only": "Good morning LL,\n\n> Hi Z,\n>\n> I just went through the presentation which made your thinking very clear. Thanks.\n> I will not be able to match this effort so please bear with me as I try and explain my own thinking.\n> I don't see why fast forwards (FF) need \"symmetrically encumbered outputs\"? To me the protocol should be asymmetric.\n>\n> This is what I think happens when offering a FF HTLC:\n> 1. The offerer creates and signs a new commitment tx as normal with the HTLC except it has the same revocation key as the last one.\n> 2. The offerer patches their balance output by sending a tx spending from it to a new tx which has the HTLC output and their balance output (unencumbered).\n>\n> The HTLC is now irrevocably committed from the perspective of the receiver.\n> Now the receiver presents the pre-image and the offerer then:\n>\n> 1. The offerer creates and signs a new commitment tx as normal consolidating the funds into the receiver's balance output except once again it has the same revocation key as the last one.\n> 2. The offerer patches their commitment tx balance output again by sending a tx spending from it to a new tx which splits into the receiver's balance (the value of the claimed HTLC) and the offerer's remaining balance.\n>\n> You can repeat the above process without having the receiver's revocation keys online or their commitment tx keys for many HTLCs while the offerer still has balance towards the receiver.\n> The on-chain cost is about the same as before for an uncooperative close.\n>\n> Once the receiver brings their keys on line they can consolidate the FF state into a new commitment txs on both sides and with a proper revocation operate the channel normally. What has been the receiver up until now can finally send funds.\n>\n> Am I missing something?\n\nBasically, you are taking advantage of the fact that we **actually** let the commitments on both sides be desynchronized with each other.\nI tend to elide this fact when explaining, and also avoid it when planning protocols.\n\nHowever I believe the idea is correct.\n\nAnyway, as I understood it:\n\nSo suppose we start with this pair of commitment txes:\n\n    +--------------------------+\n    |  Commitment tx 1 of A    |\n    +------------+-------------+\n    |            | (A[0] && B) |\n    |            |||(A && CSV) |\n    |    SigB    +-------------+\n    |            |      B      |\n    |            |             |\n    +------------+-------------+\n\n    +--------------------------+\n    |  Commitment tx 1 of B    |\n    +------------+-------------+\n    |    SigA    |      A      |\n    |            |             |\n    |            +-------------+\n    |            | (A && B[0]) |\n    |            |||(B && CSV) |\n    +------------+-------------+\n\nNow Alice wants to offer an HTLC to Bob.\nWhat Alice does is:\n\n* **Retain** the Alice commitment tx and create an HTLC tx spending from it.\n* **Advance** the Bob commitment tx (and letting it desync from the Alice commitment tx), adding the same HTLC.\n\nSo after Alice sends its new signatures, our offchain txes are:\n\n    +--------------------------+    +--------------------------+\n    |  Commitment tx 1 of A    |    |          HTLC Tx         |\n    +------------+-------------+    +------------+-------------+\n    |            | (A[0] && B) |--->|  SigA[0]   | (A[0] && B) |\n    |            |||(A && CSV) |    |            |||(A && CSV) |\n    |    SigB    +-------------+    |            +-------------+\n    |            |      B      |    |            |    A->B     |\n    |            |             |    |            |    HTLC     |\n    +------------+-------------+    +------------+-------------+\n\n    +--------------------------+\n    | Commitment tx *2* of B   |\n    +------------+-------------+\n    |    SigA    |      A      |\n    |            |             |\n    |            +-------------+\n    |            | (A && B[1]) |\n    |            |||(B && CSV) |\n    |            +-------------+\n    |            |    A->B     |\n    |            |    HTLC     |\n    +------------+-------------+\n\nNotes:\n\n* Again, for Alice to offer the HTLC to Bob, only Alice has to make new signatures (`SigA[0]` and `SigA` for commitment tx *2* of Bob).\n* If Alice goes offline and Bob decides to drop onchain, Bob only needs to sign the new commitment tx.\n  We can argue that dropping channels *should* be rare enough that requiring privkeys for this operation is not a burden.\n* If Alice decides to drop the channel onchain, Bob only needs to bring in the privkey for the HTLC tx, which we can (at a lower, detailed level) be different from the \"main\" B privkey.\n\nSo yes, I think it seems workable without symmetric encumbrance.\n\nRegards.\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-02T03:30:35",
                "message_text_only": "Good morning again LL,\n\nSo I started thinking as well, about Decker-Russell-Osuntokun and the Fast Forwards technique, as well as your \"desync\" idea.\n\nAnd it seems to me that we can also adapt a variant of this idea with Decker-Russell-Osuntokun, with the advantage of **not** requiring the additional encumbrance at the outputs.\n\nThe technique is that we allow Bob the receiver to have possession of *later* states while Alice the sender only possesses an old state.\n\nAlice sends the signatures for a new state (update + settlement) whenever it offers an HTLC to Bob, and whenever Bob fulfills the HTLC.\nHowever, Alice *does not* wait for Bob to return signatures for a new state.\nSo Alice remains stuck with the old state.\n\n* Suppose Alice wants to close the channel unilaterally.\n  * Alice broadcasts the old update tx.\n  * Bob has an incentive to bring its latest state onchain (bringing its privkey online and signing the latest update).\n    * All the payments are in the Alice->Bob direction.\n  * Even though Alice broadcasted an old state, it does not lose money since Decker-Russell-Osuntokun is non-punitive.\n* Bob can bring its privkey online to close the channel unilaterally with the latest state.\n\nSo it looks to me that Decker-Russell-Osuntokun similarly does **not** require the additional encumbrance at the \"main\" outputs.\nWe simply allow the sender to remain at an older state.\n\nSo let us give a concrete example.\n\n* Alice and Bob start at state 1: Alice = 50, Bob = 50.\n* Alice offers a HTLC of value 10.\n  * Alice: state 1: Alice = 50, Bob = 50\n  * Bob: state 2: Alice = 40, Bob = 50, A->B HTLC = 10\n* Bob fulfills, so Alice sends a new state.which transfers the A->B HTLC value to Bob.\n  * Alice: state 1: Alice = 50, Bob = 50\n  * Bob: state 3: Alice = 40, Bob = 60\n* Bob brings its privkey online because it wants to send out via Alice (a forwarder).\n  It offers an HTLC B->A of value 20.\n  * Alice: state 4: Alice = 40, Bob = 40, B->A HTLC = 20\n  * Bob: state 3: Alice = 40, Bob = 60\n\nBecause publishing old state is \"safe\" under Decker-Russell-Osuntokun, it is fine for one participant to have *only* an older state!\nAnd we can arrange the incentives so that the one with the latest state is the one who is most incentivized to publish the latest state.\n\n(We should probably change the subject of this thread BTW)\n\nAnother advantage here is that unlike the Poon-Dryja Fast Forwards, we do *not* build up a long chain of HTLC txes.\nAt the worst case, we have an old update tx that is superseded by a later update tx instead, thus the overhead is expected to be at most 1 extra update tx no matter how many HTLCs are offered while Bob has its privkey offline.\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-06-07T03:21:19",
                "message_text_only": "Hi Z,\n\nI agree with your analysis. This is how I pictured eltoo fast forwards\nworking as well.\n\nAnother interesting thing about this idea is that it could allow a new type\nof custodial LN provider where the custodian is only in charge of receiving\npayments to the channel but cannot spend them.\nWith the non-custodial LN phone apps there is this annoying UX where you\nhave to keep the app open to receive a payment (because the pre-image is on\nmy phone).\nI wouldn't mind letting the provider handle receiving payments on my behalf.\nOf course this means they would be able to steal the money in the FF state\nbut this is a big reduction in risk from a full custodial solution.\nIn other words, you should be able to get the seamless experience of a\nfully custodial wallet while only giving them custody of small amounts of\ncoins for a short time.\n\nOn Wed, 2 Jun 2021 at 13:30, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n>\n> Another advantage here is that unlike the Poon-Dryja Fast Forwards, we do\n> *not* build up a long chain of HTLC txes.\n> At the worst case, we have an old update tx that is superseded by a later\n> update tx instead, thus the overhead is expected to be at most 1 extra\n> update tx no matter how many HTLCs are offered while Bob has its privkey\n> offline.\n>\n\nI don't think you need to build up a long chain of HTLC txs for the\nPoon-Dryja fast forward in the \"desync\" approach. Each one just replaces\nthe other.\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210607/510d656b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-08T02:37:27",
                "message_text_only": "Good morning LL,\n\n> Hi Z,\n>\n> I agree with your analysis. This is how I pictured eltoo fast forwards working as well.\n>\n> Another interesting thing about this idea is that it could allow a new type of custodial LN provider where the custodian is only in charge of receiving payments to the channel but cannot spend them.\n> With the non-custodial LN phone apps there is this annoying UX where you have to keep the app open to receive a payment (because the pre-image is on my phone).\n> I wouldn't mind letting the provider handle receiving payments on my behalf.\n> Of course this means they would be able to steal the money in the FF state but this is a big reduction in risk from a full custodial solution.\n> In other words, you should be able to get the seamless experience of a fully custodial wallet while only giving them custody of small amounts of coins for a short time.\n\nYes, that is indeed a good advantage and thank you for this.\n\n> On Wed, 2 Jun 2021 at 13:30, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Another advantage here is that unlike the Poon-Dryja Fast Forwards, we do *not* build up a long chain of HTLC txes.\n> > At the worst case, we have an old update tx that is superseded by a later update tx instead, thus the overhead is expected to be at most 1 extra update tx no matter how many HTLCs are offered while Bob has its privkey offline.\n>\n> I don't think you need to build up a long chain of HTLC txs for the Poon-Dryja fast forward in the \"desync\" approach. Each one just replaces the other.\n\nThinking about it more, this seems correct.\n\nReferring back to the diagrams:\n\n    +--------------------------+    +--------------------------+\n    |  Commitment tx 1 of A    |    |          HTLC Tx         |\n    +------------+-------------+    +------------+-------------+\n    |            | (A[0] && B) |--->|  SigA[0]   | (A[0] && B) |\n    |            |||(A && CSV) |    |            |||(A && CSV) |\n    |    SigB    +-------------+    |            +-------------+\n    |            |      B      |    |            |    A->B     |\n    |            |             |    |            |    HTLC     |\n    +------------+-------------+    +------------+-------------+\n\n    +--------------------------+\n    | Commitment tx *2* of B   |\n    +------------+-------------+\n    |    SigA    |      A      |\n    |            |             |\n    |            +-------------+\n    |            | (A && B[0]) |\n    |            |||(B && CSV) |\n    |            +-------------+\n    |            |    A->B     |\n    |            |    HTLC     |\n    +------------+-------------+\n\n\nOn the *next* HTLC, Alice just gives s commitment tx *3* `SigA`, and a replacement HTLC Tx `SigA[0]` to the cashier of Bob.\n\n    +--------------------------+    +--------------------------+\n    |  Commitment tx 1 of A    |    |       HTLC Tx *2*        |\n    +------------+-------------+    +------------+-------------+\n    |            | (A[0] && B) |--->|  SigA[0]   | (A[0] && B) |\n    |            |||(A && CSV) |    |            |||(A && CSV) |\n    |    SigB    +-------------+    |            +-------------+\n    |            |      B      |    |            |    A->B     |\n    |            |             |    |            |    HTLC     |\n    +------------+-------------+    |            +-------------+\n                                    |            |    A->B     |\n                                    |            |    HTLC     |\n                                    +------------+-------------+\n\n    +--------------------------+\n    | Commitment tx *3* of B   |\n    +------------+-------------+\n    |    SigA    |      A      |\n    |            |             |\n    |            +-------------+\n    |            | (A && B[0]) |\n    |            |||(B && CSV) |\n    |            +-------------+\n    |            |    A->B     |\n    |            |    HTLC     |\n    |            +-------------+\n    |            |    A->B     |\n    |            |    HTLC     |\n    +------------+-------------+\n\nThis is safe, because:\n\n* If Alice publishes Commitment tx 1 of Alice, Bob has every incentive to publish the HTLC Tx *2*, not the older HTLC Tx.\n  * Alice cannot force publishing the *previous* HTLC Tx, because Alice has no `B` key and cannot force-publish it.\n* If Bob wants to close unilaterally, it has every incentive to publish the latest Commitment tx ### of B, because that has the most HTLCs going to Bob.\n\nAgainst the above we should note that the \"HTLCs\" we are talking about in Poon-Dryja are not simple contracts but are instead revocable HTLCs, which means additional dependent transactions.\nSo I think the above *is* doable, but *does* require additional complexity and care, in that every A->B HTLC has to have some signatures exchanged as well (which, as they are HTLCs \"in flight\", we can have the keys on the cashier).\n\n---------------------\n\n\nI also have another subtlety to bring up with the above.\n\nIn particular, for a set of *simplex* Alice-to-Bob payments, Bob should ***not*** provide the revocation keys of older \"commitment transactions owned by Bob\".\n\nThat is, the cashier should ***not*** have access to the revocation keys.\n\nNotice the above example:\n\n    +--------------------------+\n    | Commitment tx *2* of B   |\n    +------------+-------------+\n    |    SigA    |      A      |\n    |            |             |\n    |            +-------------+\n    |            | (A && B[0]) |\n    |            |||(B && CSV) |\n    |            +-------------+\n    |            |    A->B     |\n    |            |    HTLC     |\n    +------------+-------------+\n\nDespite being the *2nd* commitment tx, it should have the ***same*** Bob-side revocation key `B[0]` instead of the next one in the series, `B[1]`.\n\nMy previous email was wrong in incrementing `B[1]` here.\n\nTo understand this subtlety, let us divide Bob into these characters:\n\n* The \"true\" Bob, which represents the actual economic entity that is using this scheme for their improved economic efficiency (i.e. \"because it is convenient for the user\").\n* Carol the cashier, who is in direct communication with Alice and is 100% online.\n  * This represents a piece of (hopefully open-source) software which acts as the 100%-online node.\n* Kelly the keyholder, who holds the important private keys of Bob, and *only* connects to Carol (via a direct connection) if and only if Bob wills it.\n  * This represents a piece of hardware that keeps the keys offline.\n\nNow, let us consider the below property:\n\n* Bob has access to all the activity of Carol, including all communications between Carol and Alice.\n  * More to the point, Bob has a copy of every `SigA` received by Carol.\n\nThe above property is accurate to the real world, I think, because Carol is not a true economic sentient entity.\nIt is \"just\" a piece of software you install on a piece of hardware with 100% uptime, and presumably Bob either has personally audited the software, or has hired someone to do so on its behalf.\n\nOf course, software is never perfect, and it is possible that a bug in the software will allow Alice to extract additional information from Carol the cashier-software.\nWe model this as Carol then cooperating with Alice to do as much economic damage to Bob as possible.\n\nFor example, Carol is the one who keeps the various `SigA`s from Alice.\nThus, in theory, if Carol is corrupted by Alice, Carol is capable of deleting all the `SigA`s coming from Alice, including that needed by every \"commitment transaction owned by Bob\".\nThus, a \"signature-deletion\" attack mounted by Alice and Carol on Bob can prevent Bob from unilaterally closing the channel, leading to hostage-taking of ***all*** the Bob-side funds in the channel, not just in-flight HTLCs.\n\nHowever, remember that Carol is \"really\" just a piece of (potentially buggy) software.\nBob can mitigate signature deletion:\n\n* Perhaps the backing datastore is really a copy-on-write structure, such that deletions are not actual overwrites of old data, and older version containing the signatures can be retained.\n* Bob can take snapshots of the backing datastore periodically, which reduces the damage of deletions, as Bob has a copy of some of the older data before Carol deleted signatures.\n* Perhaps the signature datastore is an append-only log, which is only periodically reaped of truly obsolete signatures by Bob.\n  As signatures are only 64 bytes, this is not an onerous amount of data for low-bandwidth Bobs.\n* The Carol software could be structured so that the signature datastore is a separate process, thus enjoys some amount of protection (process isolation) from exploits on the \"main\" Carol software that is online and connected to Alice.\n\nThus, in our model, we have the property that Bob can always recover all signatures sent by Alice, even if Carol is corrupted by Alice --- we model the signature-deletion attack as impossible, by assumption.\n(This is a strengthening of security assumptions, thus a weakening of the security of the scheme --- if Bob does not take the above mitigations, Bob ***is*** vulnerable to a signature-deletion attack and might have ***all*** funds in hostage).\n\nNow, hostaging of the funds in a channel occurs because one participant loses the ability to unilaterally close.\nIf Bob is unable to unilaterally close, Alice can refuse to cooperate on channel closures unless Bob dontes some money to Alice.\nSignature-deletion is only *one* way to lose this ability.\n\nAnother way is for a corrupted Carol to reveal all the revocation keys, including the latest revocation key, to Alice.\nThis prevents Bob from safely unilaterally closing the channel, as the latest transaction it has is revocable by Alice (because Carol has been corrupted and has leaked the latest revocation key).\n\nThus:\n\n* Carol ***MUST NOT*** be given the entire set of revocation keys `B[0]`..`B[n]`.\n  Carol should only be given *previous* revocation keys by Bob, as a hardened derivation from the keys held by KElly.\n\nOf course, since Carol has no access to the *current* revocation key, it cannot provide it once the *next* commitment is created.\n\nThis implies that, until Bob puts Kelly online and gets access to the entire sequence of revocation keys, Carol also **cannot** provide revocation keys for previous states.\nThus, as long as Kelly is offline, Alice and Carol have to reuse the same revocation key.\n\nThis is still safe, since later \"commitment transaction owned by Bob\" have more and more funds in HTLCs going to Bob.\nThus, Bob has every incentive to use only the latest \"commitment transaction owned by Bob\".\n\nSo:\n\n* As long as all transfers are Alice->Bob direction, there is no need to update the revocation key (and Carol ***cannot*** provide this key anyway without Kelly).\n* Once we have a Bob->Alice transfer (i.e. Bob sends out money), only then does the revocation key need to be exposed to Carol for sending to Alice.\n  * As the sequence of revocation keys are derived from the master privkey held by Kelly, Kelly is needed.\n  * We need Kelly to be online anyway for sends (to send the corresponding signatures as well), so this is *not* an *additional* requirement.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-06-13T04:12:36",
                "message_text_only": "Hi Z,\n\nThanks again for getting to the bottom of this. I think we are on the same\npage except for one clarification:\n\nOn Tue, 8 Jun 2021 at 12:37, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n\n> Thus, in our model, we have the property that Bob can always recover all\n> signatures sent by Alice, even if Carol is corrupted by Alice --- we model\n> the signature-deletion attack as impossible, by assumption.\n> (This is a strengthening of security assumptions, thus a weakening of the\n> security of the scheme --- if Bob does not take the above mitigations, Bob\n> ***is*** vulnerable to a signature-deletion attack and might have ***all***\n> funds in hostage).\n>\n\nOnly where ***all*** refers to the funds in the fast forward -- funds\nconsolidated into the channel balance are not at risk (modulo enforcing\ncorrect state on chain).\nI think it should be easy to get a stream of signatures so they can't be\ndeleted. The user \"Bob\" is creating and sending the invoices so they can\nalways demand and save the signatures from \"Carol the Cashier\" that\ncorrespond to each payment so the \"deletion attack\" will be thwarted.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210613/fdeacd68/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-20T00:30:09",
                "message_text_only": "Good morning LL,\n\n> Hi Z,\n>\n> Thanks again for getting to the bottom of this. I think we are on the same page except for one clarification:\n>\n> On Tue, 8 Jun 2021 at 12:37, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \u00a0\n>\n> > Thus, in our model, we have the property that Bob can always recover all signatures sent by Alice, even if Carol is corrupted by Alice --- we model the signature-deletion attack as impossible, by assumption.\n> > (This is a strengthening of security assumptions, thus a weakening of the security of the scheme --- if Bob does not take the above mitigations, Bob ***is*** vulnerable to a signature-deletion attack and might have ***all*** funds in hostage).\n>\n> Only where ***all*** refers to the funds in the fast forward -- funds consolidated into the channel balance are not at risk (modulo enforcing correct state on chain).\n> I think it should be easy to get a stream of signatures so they can't be deleted. The user \"Bob\" is creating and sending the invoices so they can always demand and save the signatures from \"Carol the Cashier\" that correspond to each payment so the \"deletion attack\" will be thwarted.\n\nTo be clear, what I meant here with \"***all***\" was that risk of funds hostage exists if Bob has absolutely no mitigation against this (i.e. makes no copies of signatures for itself).\nWhat you suggest is a mitigation that *does* prevent this \"***all***\" case (i.e. Bob makes its own copies of signatures, it does not delegate signature storage to Carol the Cashier).\n\nThus, the model outright assumes that Bob makes *some* mitigation to prevent signature deletion, as without *any* mitigation the model is insecure.\n\nOtherwise I think we are mostly in agreement here.\n\n--\n\nAnother thing I have been mulling over is an older proposal where some Lightning service-provider (who takes on the role of Alice in our description) simply generates the invoice+preimage itself.\nThen when Bob comes online, the Lightning service-provider (Alice ---- hmmm A Lightning Service-provider hence \"ALS\" or \"Alice\") simply forwards the payment to Bob at that time.\n\ni.e.\n\n* Bob makes an invoice+preimage for a third party to pay.\n* Bob hands over the preimage to Alice.\n* Bob goes offline.\n* Sender sends to Alice, who has the preimage and can claim it.\n* Bob goes online.\n* Alice sends the payment.\n\nNote that Alice is trusted to honestly forward the payment to Bob when Bob comes online in this older proposal.\n\nHowever, in this older proposal, any funds \"already\" in the Bob-side of the channel are safe --- Alice cannot steal them.\nAlice can only steal funds it has not forwarded to Bob yet.\n\nNow, let us return to the detailed FF scheme (with separate Carol the Cashier and Kelly the Keykeeper).\n\nIf Carol was operated by Alice, it would have similar security to the above older proposal.\n\n* Carol does not have any Bob privkeys or the entire set of revocation keys, so cannot steal channel funds outright.\n* We assume that Bob has mitigations against signature deletion (i.e. Bob has backups of signatures).\n* We have already established in previous discussion, Alice+Carol cannot cooperate to steal funds \"already\" in the channel --- they can only steal funds from payments that Bob has not come online to claim yet.\n\nHowever, the older proposal has significant advantage:\n\n* It is simpler and can reuse existing code and tests.\n\nIndeed, C-Lightning plus plugins can implement the older proposal today, with fairly small amount of new code (only for the plugin --- no changes to C-Lightning necessary, just add a plugin, thus significantly lower testing burden).\nContrast this with FF, which requires a new state machine and protocol to implement, with greatly increased potential for CVEs.\n\nWhat FF *does* have as an advantage is that Carol the Cashier can be operated by **Bob** rather than Alice.\n\nFor example, Bob can have a single-board computer that runs Carol-software, and the mobile phone of Bob is simply a remote control for the Carol-software.\nThe advantage here is that the single-board computer, which is 100% online, does *not* have any privkeys.\nThis is in contrast with current Lightning implementations, where such a \"remote control\" scheme would need privkeys to be kept on the single-board computer, at risk of exfiltration.\nBob can have a separate Kelly-hardware that it connects to its mobile phone whenever Bob needs to send out money, thus greatly reducing the risk experienced by Bob.\nThe previous proposal cannot do this as honest resolution of the payment is simply immediately trusted to Alice A Lightning Service-provider.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Improving Payment Latency by Fast Forwards",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 28809
        }
    },
    {
        "title": "[Lightning-dev] BIP118 confusion / SIGHASH_NOINPUT is now SIGHASH_ANYPREVOUT (i think)",
        "thread_messages": [
            {
                "author": "Ryan Grant",
                "date": "2021-06-12T19:52:45",
                "message_text_only": "Hi,\n\nI have detected some definite confusion among people who are not aware\nof the most recent updates to the bip118 draft.  I don't know if\nthat's common among readers of these lists.\n\nSubstantial edits to the bip118 draft were made through May 2019,\nincluding changing its official name to SIGHASH_ANYPREVOUT.  The\ninternal heading \"Revisions\" discusses these changes.\n\n  https://github.com/ajtowns/bips/blob/c7c6a58b7a66a5dc5f4435319577d26a34082a79/bip-0118.mediawiki#Revisions\n  https://github.com/ajtowns/bips/compare/master...ajtowns:bip-anyprevout\n  https://github.com/ajtowns/bips/blob/c7c6a58b7a66a5dc5f4435319577d26a34082a79/bip-0118.mediawiki\n\nThe version in bitcoin/bips was not modified since 2018, until it\ndiverged by collecting a minor fix two months ago.  It still uses\nSIGHASH_NOINPUT terminology.\n\n  https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki\n\nAFAICT, with taproot activating, the preferred method to ease\nlightning network client state requirements will now definitely be\nSIGHASH_ANYPREVOUT.\n\nI am not aware of reasons for bip118's updated draft to sit on the\nsidelines before consideration by a wider audience."
            },
            {
                "author": "Ryan Grant",
                "date": "2021-06-12T20:56:55",
                "message_text_only": "Apologies, I found the discussion going on here:\n  https://github.com/bitcoin/bips/pull/943\n\nOn Sat, Jun 12, 2021 at 7:52 PM Ryan Grant <bitcoin-dev at rgrant.org> wrote:\n>\n> Hi,\n>\n> I have detected some definite confusion among people who are not aware\n> of the most recent updates to the bip118 draft.  I don't know if\n> that's common among readers of these lists.\n>\n> Substantial edits to the bip118 draft were made through May 2019,\n> including changing its official name to SIGHASH_ANYPREVOUT.  The\n> internal heading \"Revisions\" discusses these changes.\n>\n>   https://github.com/ajtowns/bips/blob/c7c6a58b7a66a5dc5f4435319577d26a34082a79/bip-0118.mediawiki#Revisions\n>   https://github.com/ajtowns/bips/compare/master...ajtowns:bip-anyprevout\n>   https://github.com/ajtowns/bips/blob/c7c6a58b7a66a5dc5f4435319577d26a34082a79/bip-0118.mediawiki\n>\n> The version in bitcoin/bips was not modified since 2018, until it\n> diverged by collecting a minor fix two months ago.  It still uses\n> SIGHASH_NOINPUT terminology.\n>\n>   https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki\n>\n> AFAICT, with taproot activating, the preferred method to ease\n> lightning network client state requirements will now definitely be\n> SIGHASH_ANYPREVOUT.\n>\n> I am not aware of reasons for bip118's updated draft to sit on the\n> sidelines before consideration by a wider audience."
            }
        ],
        "thread_summary": {
            "title": "BIP118 confusion / SIGHASH_NOINPUT is now SIGHASH_ANYPREVOUT (i think)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ryan Grant"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2520
        }
    },
    {
        "title": "[Lightning-dev] Reminder: Transaction relay workshop on IRC Libera - Tuesday 15th June 19:00 UTC",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2021-06-14T14:41:21",
                "message_text_only": "Hi,\n\nA short reminder about the 1st transaction relay workshop happening\ntomorrow on #l2-onchain-support Libera chat (!), Tuesday 15th June, from\n19:00 UTC to 20:30 UTC\n\nScheduled topics are:\n* \"Guidelines about L2 protocols onchain security design\"\n* \"Coordinated cross-layers security disclosures\"\n* \"Full-RBF proposal\"\n\nFind notes and open questions for the two first topics here:\n* https://github.com/ariard/L2-zoology/blob/master/workshops/guidelines.md\n* https://github.com/ariard/L2-zoology/blob/master/workshops/coordinated.md\n\nGoing to send the \"Move toward full-rbf\" proposal soon, deserves its own\nthread. Workshops will stick to a socratic format to foster as much\nknowledge sharing among attendees and ideally we'll reach rough consensus\nabout expected goals.\n\nIf you're a second-layer protocol designer, a Lightning dev, a Bitcoin Core\ndev contributing around mempool/p2p areas, or a Bitcoin service operator\nwith intense usage of the mempool, I hope you'll find those workshops of\ninterest and you'll learn a lot :)\n\nAgain it's happening on Libera, not Freenode, contrary to the former mail\nabout agenda & schedule.\n\nCheers,\nAntoine\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210614/1f62de80/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Reminder: Transaction relay workshop on IRC Libera - Tuesday 15th June 19:00 UTC",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1332
        }
    },
    {
        "title": "[Lightning-dev] Tuesday\u2019s IRC workshop on L2 onchain support",
        "thread_messages": [
            {
                "author": "Michael Folkson",
                "date": "2021-06-17T17:06:19",
                "message_text_only": "The workshop was previously announced by ariard on the bitcoin-dev\nmailing list here:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-April/018841.html\n\nA reminder was posted to the bitcoin-dev mailing list here:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019068.html\n\nThe conversation log for the workshop is here:\nhttps://gist.github.com/ariard/5f28dffe82ddad763b346a2344092ba4\n\nI\u2019ll summarize what was discussed during the meeting but please refer\nto the L2 zoology repo ariard has set up for background context and\nadditional notes: https://github.com/ariard/L2-zoology\n\nGeneral considerations\n\nI think it is worth first reiterating the obvious that there will\nnever be perfect security guarantees on network transaction fee rates\nor transaction relay. Network fee rates can in theory go up to\nanything (upper limit of infinity) and will always to some degree be\ninherently unpredictable. In addition transaction acceptance can never\nbe guaranteed even if you attempt a direct connection to a miner. At\nthe same time L2 protocols (e.g. Lightning and DLCs) elevate\ntransaction propagation and inclusion in a time sensitive mined block\nto a security assumption from what used to just be a usability\nassumption (BlueMatt). Within those confines these workshops are\nattempting to strengthen that security assumption knowing that\nguaranteeing it is out of reach.\n\nThere are considerations that blocked transaction propagation isn\u2019t\nnecessarily a problem for the victim if it is also blocked for the\nattacker. In addition some successful attacks present an opportunity\nfor the victim to divert their funds to miner fees (e.g. scorched\nearth) ensuring the attacker doesn\u2019t financially benefit from the\nattack (harding). Personally I would argue neither of these present\nmuch assurance to the victim. Out of conservatism one should assume\nthat the attacker has greater resources than the victim (e.g. a direct\nline to a miner) and knowing a victim\u2019s lost funds went to the miner\ninstead of the attacker isn\u2019t of much comfort to the victim (other\nthan potentially presenting a disincentive for the attack in the first\nplace). This is obviously further complicated if the miner is the\nattacker. In addition any incentive for miners to not mine\ntransactions to wait for a potential pay-all-to-fee are troubling\n(t-bast).\n\nNew(ish) ideas\n\nRubenSomsen brought up the idea of fee sensitive timelocks, they would\nneed a soft fork. ariard briefly discussed the idea of a transaction\nrelay overlay network. harding stated his opinion that we should be\nleaning more on miners\u2019 profit incentive rather than attempting to\nnormalize mempool policy (e.g.\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html).\nt-bast raised the prospect of mining pools exposing public APIs to\npush them transactions directly.\n\nThe impact of changes to Bitcoin Core on L2 protocols\n\nSome changes to Core (e.g. some privacy improvements) can conflict\nwith the goal of minimizing transaction propagation times.\nChris_Stewart_5 raised the idea of a nightly bitcoind build to give L2\ndevelopers a way to write regression tests against the latest builds\nof bitcoind. He added that L2 devs should write automated regression\ntest suites against bitcoind exposed RPC commands. t-bast would like a\nbitcoind \u201cevicttx\u201d RPC to remove a transaction from the mempool on\nregtest.\n\nFull RBF\n\nIn advance of the workshop ariard posted to the mailing list a\nproposal for full RBF in a future version of Bitcoin Core:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019074.html\n\nProgress in this direction has been attempted in the past (e.g.\nhttps://github.com/bitcoin/bitcoin/pull/10823) BlueMatt pointed out\nthat even with full RBF it is trivial to create mempool partitions. As\nlong as RBF has a fee rate increase minimum an attacker can trivially\nsplit the mempool by broadcasting two conflicting transactions with\nthe same fee.\n\nariard plans to contact businesses (e.g. Lightning onboarding services\nrelying on zero confirmations) to check that this possible eventual\nmove to full RBF doesn\u2019t present a problem for them. There could well\nbe engineering work required in advance of the possible change being\nmade.\n\nNext week\u2019s meeting\n\nNext week\u2019s meeting (Tuesday 22nd June, 19:00 UTC,\n#l2-onchain-support, Libera) will be on fee bumping and package relay\nthat glozow has recently been working to advance in Bitcoin Core.\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            }
        ],
        "thread_summary": {
            "title": "Tuesday\u2019s IRC workshop on L2 onchain support",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Michael Folkson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4589
        }
    },
    {
        "title": "[Lightning-dev] Waiting SIGHASH_ANYPREVOUT and Packing Packages",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2021-06-18T22:11:38",
                "message_text_only": "Hi,\n\nIt's a big chunk, so if you don't have time browse parts 1 and 2 and share\nyour 2 sats on the deployment timeline :p\n\nThis post recalls some unsolved safety holes about Lightning, how\npackage-relay or SIGHASH_ANYPREVOUT can solve the first one, how a mempool\nhardening can solve the second one, few considerations on package-relay\ndesign trade-offs and propose a rough deployment timeline.\n\n1) Lightning Safety Holes : Pre-Signed Feerate and Tx-Pinning (to skip if\nyou're a LN dev)\n\nAs of today, Lightning is suffering from 2 safety holes w.r.t to base-layer\ninteractions, widely discussed among ln devs.\n\nThe first one, the pre-signed feerate issue with future broadcasted\ntime-sensitive transactions is laid out clearly in Matt Corallo's \"CPFP\nCarve-Out Fee-Prediction Issues in Contracting Applications (eg Lightning)\"\n[0]. This issue might provoke loss of funds, even in non-adversarial\nsettings, i.e a Lightning routing hub not being able to settle backward\nonchain a successful HTLC during occurrences of sudden mempool congestion.\n\nAs blockspace demand increases with an always growing number of\nonchain/offchain bitcoin users, coupling effects are more likely to happen\nand this pre-signed feerate issue is going to become more urgent to solve\n[1]. For e.g, few percentiles of increases in feerate being overpriced by\nLightning routing hubs to close \"fractional-reserve\" backed anchor\nchannels, driving mempools congestions, provoking anchor channels\nfee-bumping reserves becoming even more under-provisioned and thus close\ndown, etc.\n\nThe second issue, malicious transaction pinnings, is documented in Bastien\nTeinturier's \"Pinning Attacks\" [2]. AFAIK, there is a rough consensus among\ndevs on the conceptual feasibility of such a class of attacks against a LN\nnode, though so far we have not seen them executed in the wild and I'm not\naware of anyone having realized them in real-world conditions. Note, there\nis a variety of attack scenarios to consider which is function of a wide\nmatrix (channel types, LN implementation's `update_fee` policy, LN\nimplementation's `cltv_delta` policy, mempool congestion feerate groups,\nrouting hubs or end nodes) Demoing against deployed LN implementations with\ndefault settings has been on my todo for a while, though a priori One\nScenario To Exploit Them All doesn't fit well.\n\nSide-note, as a LN operator, if you're worried about those security risks,\nyou can bump your `cltv_delta`/`cltv_expiry_delta` to significantly coarse\nthe attacks.\n\nI think there is an important point to underscore. Considering the state of\nknowledge we have today, I believe there is no strong interdependency\nbetween solving pre-signed feerate and tx-pinning with the same mechanism\nfrom a safety/usability standpoint. Or last such mechanism can be deployed\nby stages.\n\n2) Solving the Pre-Signed Feerate problem : Package-Relay or\nSIGHASH_ANYPREVOUT\n\nFor Lightning, either package-relay or SIGHASH_ANYPREVOUT should be able to\nsolve the pre-signed feerate issue [3]\n\nOne of the interesting points recalled during the first transaction relay\nworkshops was that L2s making unbounded security assumptions on\nnon-normative tx-relay/mempool acceptance rules sounds a wrong direction\nfor the Bitcoin ecosystem long-term, and more prone to subtle bugs/safety\nrisks across the ecosystem.\n\nI did express the contrary, public opinion a while back [4]. That said, I\nstart to agree it's wiser ecosystem-wise to keep those non-normatives rules\nas only a groundwork for weaker assumptions than consensus ones. Though it\nwould be nice for long-term L2s stability to consider them with more care\nthan today in our base-layer protocol development process [4]\n\nOn this rational, I now share the opinion it's better long-term to solve\nthe pre-signed feerate problem with a consensus change such as\nSIGHASH_ANYPREVOUT rather than having too much off-chain coins relying on\nthe weaker assumptions offered by bitcoin core's tx-relay/mempool\nacceptance rules, and far harder to replicate and disseminate across the\necosystem.\n\nHowever, if SIGHASH_ANYPREVOUT is Things Done Right(tm), should we discard\npackage-relay ?\n\nSadly, in the worst-case scenario we might never reach consensus again\nacross the ecosystem and Taproot is the last softfork. Ever :/ *sad violons\nand tissues jingle*\n\nWith this dilemma in mind, it might be wise for the LN/L2 ecosystems to\nhave a fall-back plan to solve their safety/usability issues and\npackage-relay sounds a reasonable, temporary \"patch\".\n\nEven if package-relay requires serious engineering effort in Bitcoin Core\nto avoid introducing new DoSes, swallowing well the complexity increase in\ncritical code paths such as the mempool/p2p stack and a gentle API design\nfor our friends the L2 devs, I believe it's worthy the engineering\nresources cost. From-my-completely-biased-LN-dev viewpoint :p\n\nIn the best-case scenario, we'll activate SIGHASH_ANYPREVOUT and better\nfee-bumping primitives softforks [5] slowly strip off the \"L2 fee-bumping\nprimitive\" semantic from \"package-relay\", friendly nudge the L2 ecosystem\nto seat their fee-bumping on safer, consensus assumptions and maybe keep\nthe p2p packages to improve on the malicious mempool-partitions-side or as\na replacement of our orphan logic.\n\n3) Solving Tx-Pinnings : Hardening the Mempool against Tx-Relay Jammings\nattacks\n\nCurrent Mempool anti-DoS rules have been mostly designed at a time where\nthe shared-utxo model with competing time-sensitive transactions was still\nan idea on the whiteboard. The last few years have revealed those anti-DoS\nrules as a source of security vulnerabilities for Lightning and a research\nconcern for L2s still in the early-phase of deployment [6].\n\nBeyond real-world pinning exercises against production software as a\ncomplement of the current pinning attacks research, it would be better to\nagree on a common L2 attacker model before to modify widely-relied subset\nof the mempool, such as the replace-by-fee logic or the in-mempool package\nlimits [7]. One risk of uncareful changes in this area would be to solve a\npinning vector for a L2-alice but introduce a new vuln for a L2-bob.\n\nI believe the first part of such a revamp could hopefully land somehow next\nyear. Though, IMHO, in the years to come, we'll have to do more hard\nreasoning to ensure the mempool supports advanced Bitcoin protocols (e.g\nOP_CTV congestion tree,  CoinPool, interactive cut-through, ...)\n\nNote the opinion I raised above on quality of assumptions on mempool\nbehavior, even if we harden it on the base-layer side,  L2s should be\nwell-aware the product is shipped with a guarantee limitation :p\n\n4) Considerations on Package-Relay Design\n\nPackage relay relies on at least two cleanly separate components (awesome,\nif we schedule to deprecate the higher half in the future!)\n* \"the higher half\" : extension of the mempool logic, with a new\npackage-level policy, not strictly intersecting with the tx-level policy\n* \"the lower half\" : at least three different designs, receiver initiated,\nsender-initiated and relay-initiated\n\nOne open design question for the \"higher half\" is the package-size of the\nacceptance logic, which is ultimately a function of the L2 ecosystem state.\nDo we have deployed or in deployment phase L2 protocols with a need for\nmore than 2-stage and if yes what API bounds do they expect ? That's a\nquestion I hope we'll gather feedback during next Thursday's transaction\nrelay workshops. IMO, such package API should come out with a specification\non which L2-community can be gathered and public consensus established. For\nthe same communications reasons towards downstream projects, we have a\nBIP125 standard. And especially in this case the bitcoin core protocol\ndevelopment process should carefully listen to the needs of actual L2\nusers. Also, a lot of those L2 devs, they don't speak C++ :)\n\nOne could imagine those mempool standards as \"perishable\" contracts between\na base-layer implementation and the upper layers, with ultimately the\nfull-node implementation reserving itself the right to deprecate them,\nmaybe with a lengthy-warning period ?\n\nBeyond that, I believe there is another remaining interdependency between\n\"the lower half\" design and L2s behaviors, namely bandwidth waste in case\nof a high-frequency of package redundancy. Let's say if a package is\ncomposed of {A, B}, and the package broadcaster fee-bump, triggering the\ntransformation to {A, B'}, A bandwidth at first propagation is going to be\nwasted. Note, if we assume a dynamic fee-market, this package rebroadcast\nbehavior should be common across the ecosystem. Though ultimately, the\nseriousness of this issue is going to be a function of the number of\nLightning nodes relying on base-layer tx-relay and the number of fee-bumped\nonchain operations per Lightning node.\n\nI believe it would be great to come up with simulations on this front, just\nto avoid silently nullifying all the tedious, small improvements which have\nbeen done in the last years to minimize bitcoin core node's bandwidth.\n\nAnother alternative would be to come with a cost-effective\npackage-replacement policy, so likely more complexity. But might it not\nmake sense to not economically outlaw Lightning nodes with a small fee\nbudget ?\n\nLastly, there is a consideration to have around anti-DoS measures we'll\nhave to deploy for package-relay. Too easy, and that's a security concern\nfor the base-layer, too hard, and that's introducing yet-another tx-relay\njamming vector against L2, this time at the p2p layer (though won't be the\nfirst time [8]\n\nIn any-case we should carefully consider the upgradeability of\npackage-relay v.0, like if we upgrade some components of it such as package\nformat or package-announcement scheme.\n\nSo yeah why not early 0.24 ? Maybe a bit too short with all those p2p\nquestions to clear up among core devs. Ideally, we would land in the\nbeginning/middle of the cycle to have time for beta-testing on the L2-side\nand share feedback.\n\nThough ultimately, this question of p2p design belongs to the bitcoin core\ndev process.\n\n# Deployment timeline\n\nSo what I believe as a rough deployment timeline.\n\n* \"package-relay\" in bitcoin core, early 0.24 or 0.25: a Core's release\ncycle offered to the LN/L2 ecosystem to integrate/exercise/provide feedback\non package API\n\n* \"mempool hardening\" in bitcoin core, early 0.26 or 0.27, a Core's release\ncycle offered to the whole Bitcoin ecosystem to adapt their Bitcoin\nclients, maybe with a boolean setting to smooth the new policy deployment\n\n* SIGHASH_ANYPREVOUT softfork in the coming year(s), opt-in of any LN/L2\nimplementation to migrate its fee-bumping backend on top of it\n\n* \"optimized/multi-party fee-bumping primitive\" softfork (one of tx\nmutation/sigash_iomap/sponsorship proposals) softfork in the coming decade,\nfriendly uplift of the L2 ecosystem\n\nGlad to answer any unclarity or uncorrectness of mine :)\n\nCheers,\nAntoine,\n\n[0] see\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n\n[1] \"The Coupling Principle states that as things get larger, they often\nexhibit increased interdependence between components\".\n\n[2] see\nhttps://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n\n[2] see \"Advances in Bitcoin Contracting : Uniform Policy and Package\nRelay\"\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-July/018063.html\n\n[3] I don't think there is a clear discussion on how SIGHASH_ANYPREVOUT\nsolves pinnings beyond those LN meetings logs:\nhttps://gnusha.org/lightning-dev/2020-06-08.log\n\n[4] And I believe such great example has been done with this recent change\nproposed for bitcoin core addr-relay policy:\nhttps://github.com/bitcoin/bitcoin/pull/21528#issuecomment-809906430, where\nthe PR author did bear the burden of reaching out potentially affected\ndownstream projects.\n\n[5] Like one of tx_mutation/sighash_iomap/sponsorship proposal proposed in\nthe thread \"A Stroll through Fee-Bumping Techniques: Input-based vs\nChild-Pay-for-Parent\" :\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/019031.html\n\n[6] For a discussion about fee-bumping issues for L2s extended beyond LN\nsee the analysis of the Revault protocol :\nhttps://arxiv.org/pdf/2102.09392.pdf\n\n[7] As a WIP towards establishing an attacker model, see \"Secure\nFee-Bumping for L2s\"\nhttps://bitcoin-problems.github.io/problems/fee-bumping.html\n\n[8] Tx-relay rules as a concern for second-layers has been raised early on,\nat least during p2p segwit review\nhttps://github.com/bitcoin/bitcoin/issues/8279\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210618/4f640fc7/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-06-19T01:34:28",
                "message_text_only": "> That's a question I hope we'll gather feedback during next Thursday's\ntransaction relay workshops.\n\nAs someone kindly pointed out to me, workshop is happening Tuesday, June\n22th. Not Thursday, mistake of mine :/\n\n\n\nLe ven. 18 juin 2021 \u00e0 18:11, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Hi,\n>\n> It's a big chunk, so if you don't have time browse parts 1 and 2 and share\n> your 2 sats on the deployment timeline :p\n>\n> This post recalls some unsolved safety holes about Lightning, how\n> package-relay or SIGHASH_ANYPREVOUT can solve the first one, how a mempool\n> hardening can solve the second one, few considerations on package-relay\n> design trade-offs and propose a rough deployment timeline.\n>\n> 1) Lightning Safety Holes : Pre-Signed Feerate and Tx-Pinning (to skip if\n> you're a LN dev)\n>\n> As of today, Lightning is suffering from 2 safety holes w.r.t to\n> base-layer interactions, widely discussed among ln devs.\n>\n> The first one, the pre-signed feerate issue with future broadcasted\n> time-sensitive transactions is laid out clearly in Matt Corallo's \"CPFP\n> Carve-Out Fee-Prediction Issues in Contracting Applications (eg Lightning)\"\n> [0]. This issue might provoke loss of funds, even in non-adversarial\n> settings, i.e a Lightning routing hub not being able to settle backward\n> onchain a successful HTLC during occurrences of sudden mempool congestion.\n>\n> As blockspace demand increases with an always growing number of\n> onchain/offchain bitcoin users, coupling effects are more likely to happen\n> and this pre-signed feerate issue is going to become more urgent to solve\n> [1]. For e.g, few percentiles of increases in feerate being overpriced by\n> Lightning routing hubs to close \"fractional-reserve\" backed anchor\n> channels, driving mempools congestions, provoking anchor channels\n> fee-bumping reserves becoming even more under-provisioned and thus close\n> down, etc.\n>\n> The second issue, malicious transaction pinnings, is documented in Bastien\n> Teinturier's \"Pinning Attacks\" [2]. AFAIK, there is a rough consensus among\n> devs on the conceptual feasibility of such a class of attacks against a LN\n> node, though so far we have not seen them executed in the wild and I'm not\n> aware of anyone having realized them in real-world conditions. Note, there\n> is a variety of attack scenarios to consider which is function of a wide\n> matrix (channel types, LN implementation's `update_fee` policy, LN\n> implementation's `cltv_delta` policy, mempool congestion feerate groups,\n> routing hubs or end nodes) Demoing against deployed LN implementations with\n> default settings has been on my todo for a while, though a priori One\n> Scenario To Exploit Them All doesn't fit well.\n>\n> Side-note, as a LN operator, if you're worried about those security risks,\n> you can bump your `cltv_delta`/`cltv_expiry_delta` to significantly coarse\n> the attacks.\n>\n> I think there is an important point to underscore. Considering the state\n> of knowledge we have today, I believe there is no strong interdependency\n> between solving pre-signed feerate and tx-pinning with the same mechanism\n> from a safety/usability standpoint. Or last such mechanism can be deployed\n> by stages.\n>\n> 2) Solving the Pre-Signed Feerate problem : Package-Relay or\n> SIGHASH_ANYPREVOUT\n>\n> For Lightning, either package-relay or SIGHASH_ANYPREVOUT should be able\n> to solve the pre-signed feerate issue [3]\n>\n> One of the interesting points recalled during the first transaction relay\n> workshops was that L2s making unbounded security assumptions on\n> non-normative tx-relay/mempool acceptance rules sounds a wrong direction\n> for the Bitcoin ecosystem long-term, and more prone to subtle bugs/safety\n> risks across the ecosystem.\n>\n> I did express the contrary, public opinion a while back [4]. That said, I\n> start to agree it's wiser ecosystem-wise to keep those non-normatives rules\n> as only a groundwork for weaker assumptions than consensus ones. Though it\n> would be nice for long-term L2s stability to consider them with more care\n> than today in our base-layer protocol development process [4]\n>\n> On this rational, I now share the opinion it's better long-term to solve\n> the pre-signed feerate problem with a consensus change such as\n> SIGHASH_ANYPREVOUT rather than having too much off-chain coins relying on\n> the weaker assumptions offered by bitcoin core's tx-relay/mempool\n> acceptance rules, and far harder to replicate and disseminate across the\n> ecosystem.\n>\n> However, if SIGHASH_ANYPREVOUT is Things Done Right(tm), should we discard\n> package-relay ?\n>\n> Sadly, in the worst-case scenario we might never reach consensus again\n> across the ecosystem and Taproot is the last softfork. Ever :/ *sad violons\n> and tissues jingle*\n>\n> With this dilemma in mind, it might be wise for the LN/L2 ecosystems to\n> have a fall-back plan to solve their safety/usability issues and\n> package-relay sounds a reasonable, temporary \"patch\".\n>\n> Even if package-relay requires serious engineering effort in Bitcoin Core\n> to avoid introducing new DoSes, swallowing well the complexity increase in\n> critical code paths such as the mempool/p2p stack and a gentle API design\n> for our friends the L2 devs, I believe it's worthy the engineering\n> resources cost. From-my-completely-biased-LN-dev viewpoint :p\n>\n> In the best-case scenario, we'll activate SIGHASH_ANYPREVOUT and better\n> fee-bumping primitives softforks [5] slowly strip off the \"L2 fee-bumping\n> primitive\" semantic from \"package-relay\", friendly nudge the L2 ecosystem\n> to seat their fee-bumping on safer, consensus assumptions and maybe keep\n> the p2p packages to improve on the malicious mempool-partitions-side or as\n> a replacement of our orphan logic.\n>\n> 3) Solving Tx-Pinnings : Hardening the Mempool against Tx-Relay Jammings\n> attacks\n>\n> Current Mempool anti-DoS rules have been mostly designed at a time where\n> the shared-utxo model with competing time-sensitive transactions was still\n> an idea on the whiteboard. The last few years have revealed those anti-DoS\n> rules as a source of security vulnerabilities for Lightning and a research\n> concern for L2s still in the early-phase of deployment [6].\n>\n> Beyond real-world pinning exercises against production software as a\n> complement of the current pinning attacks research, it would be better to\n> agree on a common L2 attacker model before to modify widely-relied subset\n> of the mempool, such as the replace-by-fee logic or the in-mempool package\n> limits [7]. One risk of uncareful changes in this area would be to solve a\n> pinning vector for a L2-alice but introduce a new vuln for a L2-bob.\n>\n> I believe the first part of such a revamp could hopefully land somehow\n> next year. Though, IMHO, in the years to come, we'll have to do more hard\n> reasoning to ensure the mempool supports advanced Bitcoin protocols (e.g\n> OP_CTV congestion tree,  CoinPool, interactive cut-through, ...)\n>\n> Note the opinion I raised above on quality of assumptions on mempool\n> behavior, even if we harden it on the base-layer side,  L2s should be\n> well-aware the product is shipped with a guarantee limitation :p\n>\n> 4) Considerations on Package-Relay Design\n>\n> Package relay relies on at least two cleanly separate components (awesome,\n> if we schedule to deprecate the higher half in the future!)\n> * \"the higher half\" : extension of the mempool logic, with a new\n> package-level policy, not strictly intersecting with the tx-level policy\n> * \"the lower half\" : at least three different designs, receiver initiated,\n> sender-initiated and relay-initiated\n>\n> One open design question for the \"higher half\" is the package-size of the\n> acceptance logic, which is ultimately a function of the L2 ecosystem state.\n> Do we have deployed or in deployment phase L2 protocols with a need for\n> more than 2-stage and if yes what API bounds do they expect ? That's a\n> question I hope we'll gather feedback during next Thursday's transaction\n> relay workshops. IMO, such package API should come out with a specification\n> on which L2-community can be gathered and public consensus established. For\n> the same communications reasons towards downstream projects, we have a\n> BIP125 standard. And especially in this case the bitcoin core protocol\n> development process should carefully listen to the needs of actual L2\n> users. Also, a lot of those L2 devs, they don't speak C++ :)\n>\n> One could imagine those mempool standards as \"perishable\" contracts\n> between a base-layer implementation and the upper layers, with ultimately\n> the full-node implementation reserving itself the right to deprecate them,\n> maybe with a lengthy-warning period ?\n>\n> Beyond that, I believe there is another remaining interdependency between\n> \"the lower half\" design and L2s behaviors, namely bandwidth waste in case\n> of a high-frequency of package redundancy. Let's say if a package is\n> composed of {A, B}, and the package broadcaster fee-bump, triggering the\n> transformation to {A, B'}, A bandwidth at first propagation is going to be\n> wasted. Note, if we assume a dynamic fee-market, this package rebroadcast\n> behavior should be common across the ecosystem. Though ultimately, the\n> seriousness of this issue is going to be a function of the number of\n> Lightning nodes relying on base-layer tx-relay and the number of fee-bumped\n> onchain operations per Lightning node.\n>\n> I believe it would be great to come up with simulations on this front,\n> just to avoid silently nullifying all the tedious, small improvements which\n> have been done in the last years to minimize bitcoin core node's bandwidth.\n>\n> Another alternative would be to come with a cost-effective\n> package-replacement policy, so likely more complexity. But might it not\n> make sense to not economically outlaw Lightning nodes with a small fee\n> budget ?\n>\n> Lastly, there is a consideration to have around anti-DoS measures we'll\n> have to deploy for package-relay. Too easy, and that's a security concern\n> for the base-layer, too hard, and that's introducing yet-another tx-relay\n> jamming vector against L2, this time at the p2p layer (though won't be the\n> first time [8]\n>\n> In any-case we should carefully consider the upgradeability of\n> package-relay v.0, like if we upgrade some components of it such as package\n> format or package-announcement scheme.\n>\n> So yeah why not early 0.24 ? Maybe a bit too short with all those p2p\n> questions to clear up among core devs. Ideally, we would land in the\n> beginning/middle of the cycle to have time for beta-testing on the L2-side\n> and share feedback.\n>\n> Though ultimately, this question of p2p design belongs to the bitcoin core\n> dev process.\n>\n> # Deployment timeline\n>\n> So what I believe as a rough deployment timeline.\n>\n> * \"package-relay\" in bitcoin core, early 0.24 or 0.25: a Core's release\n> cycle offered to the LN/L2 ecosystem to integrate/exercise/provide feedback\n> on package API\n>\n> * \"mempool hardening\" in bitcoin core, early 0.26 or 0.27, a Core's\n> release cycle offered to the whole Bitcoin ecosystem to adapt their Bitcoin\n> clients, maybe with a boolean setting to smooth the new policy deployment\n>\n> * SIGHASH_ANYPREVOUT softfork in the coming year(s), opt-in of any LN/L2\n> implementation to migrate its fee-bumping backend on top of it\n>\n> * \"optimized/multi-party fee-bumping primitive\" softfork (one of tx\n> mutation/sigash_iomap/sponsorship proposals) softfork in the coming decade,\n> friendly uplift of the L2 ecosystem\n>\n> Glad to answer any unclarity or uncorrectness of mine :)\n>\n> Cheers,\n> Antoine,\n>\n> [0] see\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n>\n> [1] \"The Coupling Principle states that as things get larger, they often\n> exhibit increased interdependence between components\".\n>\n> [2] see\n> https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n>\n> [2] see \"Advances in Bitcoin Contracting : Uniform Policy and Package\n> Relay\"\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-July/018063.html\n>\n> [3] I don't think there is a clear discussion on how SIGHASH_ANYPREVOUT\n> solves pinnings beyond those LN meetings logs:\n> https://gnusha.org/lightning-dev/2020-06-08.log\n>\n> [4] And I believe such great example has been done with this recent change\n> proposed for bitcoin core addr-relay policy:\n> https://github.com/bitcoin/bitcoin/pull/21528#issuecomment-809906430,\n> where the PR author did bear the burden of reaching out potentially\n> affected downstream projects.\n>\n> [5] Like one of tx_mutation/sighash_iomap/sponsorship proposal proposed in\n> the thread \"A Stroll through Fee-Bumping Techniques: Input-based vs\n> Child-Pay-for-Parent\" :\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/019031.html\n>\n> [6] For a discussion about fee-bumping issues for L2s extended beyond LN\n> see the analysis of the Revault protocol :\n> https://arxiv.org/pdf/2102.09392.pdf\n>\n> [7] As a WIP towards establishing an attacker model, see \"Secure\n> Fee-Bumping for L2s\"\n> https://bitcoin-problems.github.io/problems/fee-bumping.html\n>\n> [8] Tx-relay rules as a concern for second-layers has been raised early\n> on, at least during p2p segwit review\n> https://github.com/bitcoin/bitcoin/issues/8279\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210618/c61cd0b8/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2021-06-19T13:36:53",
                "message_text_only": "On Fri, Jun 18, 2021 at 06:11:38PM -0400, Antoine Riard wrote:\n> 2) Solving the Pre-Signed Feerate problem : Package-Relay or\n> SIGHASH_ANYPREVOUT\n> \n> For Lightning, either package-relay or SIGHASH_ANYPREVOUT should be able to\n> solve the pre-signed feerate issue [3]\n>\n> [...]\n>\n> [3] I don't think there is a clear discussion on how SIGHASH_ANYPREVOUT\n> solves pinnings beyond those LN meetings logs:\n> https://gnusha.org/lightning-dev/2020-06-08.log\n\nFor anyone else looking, the most relevant line seems to be:\n\n  13:50 < BlueMatt> (sidenote: sighash_no_input is *really* elegant here\n  - assuming a lot of complicated logic in core to do so, you could\n  imagine blind-cpfp-bumping *any* commitment tx without knowing its\n  there or which one it is all with one tx.......in theory)\n\nThat might work for current LN-penalty, but I'm not sure it works for\neltoo.  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\nto refer to any prevout, that implies anyone else can do the same.\nMiners who were aware of two or more states from an eltoo channel would\nbe incentivized to rewrite to the oldest state, giving them fee revenue\nnow and ensuring fee revenue in the future when a later state update is\nbroadcast.\n\nIf the attacker using pinning is able to reuse their attack at no cost,\nthey can re-pin the channel again and force the honest user to pay\nanother anyprevout bounty to miners.  Repeat this a bunch of times and\nthe honest user has now spent more on fees than their balance from the\nclosed channel.\n\nEven if my analysis above is wrong, I would encourage you or Matt or\nsomeone to write up this anyprevout idea in more detail and distribute\nit before you promote it much more.\n\n> package-relay sounds a reasonable, temporary \"patch\".\n\nEven if every protocol based on presigned transactions can magically\nallow dynamically adding inputs and modifying outputs for fees, and we\nalso have a magic perfect transaction replacement protocol, package\nrelay is still fundamentally useful for CPFP fee bumping very low\nfeerate transactions received from an external party.  E.g. Alice pays\nBob, mempool min feerates increase and Alice's transaction is dropped,\nBob still wants the money, so he submits a package with Alice's\ntransaction plus his own high feerate spend of it.\n\nPackage relay is a clear improvement now, and one I expect to be\npermanent for as long as we're using anything like the current protocol.\n \n> # Deployment timeline\n> \n> So what I believe as a rough deployment timeline.\n\nI don't think it's appropriate to be creating timelines like this that\ndepend on the work of a large number of contributors who I don't believe\nyou've consulted.  For details on this point of view, please see\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014726.html\n\nStuff will get done when it gets done.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210619/cfff070b/attachment.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-06-21T08:13:32",
                "message_text_only": "Hi Dave,\n\n> That might work for current LN-penalty, but I'm not sure it works for\neltoo.\n\nWell, we have not settled yet on the eltoo design but if we take the later\nproposal in date [0], signing the update transaction with\nSIGHGASH_ANYPREVOUT lets you attach non-interactively a single-party\ncontrolled input at broadcast-time. Providing the input amount is high\nenough to bump the transaction feerate over network mempools, it should\nallow the tx to propagate across network mempools and that way solve the\npre-signed feerate problem as defined in the post ?\n\n>  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\n> to refer to any prevout, that implies anyone else can do the same.\n> Miners who were aware of two or more states from an eltoo channel would\n> be incentivized to rewrite to the oldest state, giving them fee revenue\n> now and ensuring fee revenue in the future when a later state update is\n> broadcast.\n\nYep, you can add a per-participant key to lockdown the transaction and\navoid any in-flight malleability ? I think this is discussed in the \"A\nStroll through Fee-Bumping Techniques\" thread.\n\n> If the attacker using pinning is able to reuse their attack at no cost,\n> they can re-pin the channel again and force the honest user to pay\n> another anyprevout bounty to miners.\n\nThis is also true with package-relay where your counterparty, with a better\nknowledge of network mempools, can always re-broadcast a CPFP-bumped\nmalicious package ? Under this assumption, I think you should always be\nready to bump our honest package.\n\nFurther, for the clarity of the discussion, can you point to which pinning\nscenario you're thinking of or if it's new under SIGHASH_ANYPREVOUT,\ndescribe it ?\n\n> Repeat this a bunch of times and the honest user has now spent more on\nfees than their balance from the\nclosed channel.\n\nAnd sadly, as this concern also exists in case of a miner-harvesting attack\nagainst LN nodes, a concern that Gleb and I expressed more than a year ago\nin a public post [1], a good L2 client should always upper bound its\nfee-bumping reserve. I've a short though-unclear note on this notion of\nfee-bumping upper to warn other L2 engineers  in \"On Mempool Funny Games\nagainst Multi-Party Funded Transactions\"\n\nPlease read so:\n\n\"A L2 client, with only a view of its mempool at best, won't understand why\n the transaction doesn't confirm and if it's responsible for the\n fee-bumping, it might do multiple rounds of feerate increase through CPFP,\n in vain. As the fee-bumping algorithm is assumed to be known if the victim\n client is open source code, the attacker can predict when the fee-bumping\n logic reaches its upper bound.\"\n\nThough thanks for the recall! I should log dynamic-balances in RL's\n`ChannelMonitorUpdate` for our ongoing implementation of anchor, updating\nmy TODO :p\n\n> Even if my analysis above is wrong, I would encourage you or Matt or\nsomeone to write up this anyprevout idea in more detail and distribute\nit before you promote it much more.\n\nThat's a really fair point, as a lot of the reasoning was based on private\ndiscussion with Matt. Though as SIGHASH_ANYPREVOUT isn't advocated for\ncommunity consensus and those things take time, should just take a few\nhours of my time.\n\n> Even if every protocol based on presigned transactions can magically\nallow dynamically adding inputs and modifying outputs for fees, and we\nalso have a magic perfect transaction replacement protocol,\n\n\"\u201cAny sufficiently advanced technology is indistinguishable from magic.\u201d\nArthur C. Clarke\n\nWit apart, that might be the outcome with careful bitcoin protocol\ndevelopment, where technical issues are laid out in a best effort (of\nmine!) and spread to the Bitcoin community on the most public bitcoin\ncommunication channel ?\n\nAnd humbly, on all those L2 issues I did change my opinion, as I've written\nso much explicitly in this thread post by pointing to an older post of mine\n(\"Advances in Bitcoin Contracting : Uniform Policy and Package Relay\").\nThis reversal, partially motivated by a lot of discussion with folks,\nincluding yourself, initiated since at least mid last year.\n\n> package relay is still fundamentally useful for CPFP fee bumping very low\n> feerate transactions received from an external party.  E.g. Alice pays\n> Bob, mempool min feerates increase and Alice's transaction is dropped,\n> Bob still wants the money, so he submits a package with Alice's\n> transaction plus his own high feerate spend of it.\n\nI think this point would be a reverse of our p2p design where we are now\nmaking the sender responsible for the receiver quality of its mempool\nfeerate ? This question has never been clear up during the years-long\ndiscussion of package-relay design [1].\n\nThough referring to the thread post and last week's transaction-relay\nworkshop, I did point out that package-relay might serve in the long-term\nas a mempool-sync mechanism to prevent potential malicious mempool\npartitions [2].\n\n> Package relay is a clear improvement now, and one I expect to be\npermanent for as long as we're using anything like the current protocol\n\nAgain, reading my post, I did point out that we might keep the \"lower half\"\nof package-relay and deprecate only the higher part of it as we have more\nfeerate-efficient fee-bumping primitive available. If  it sounds too much\nof a release engineering effort to synchronize on the scale of an\necosystem, think about the ongoing deprecation of Tor V2.\n\nFurther, you did express a far less assertive opinion during last Tuesday\ntransaction-relay workshops, to which a lot of folks attended, where you\npointed it might not be a good idea for L2s to make more assumptions on\nnon-normative:\n\n\"harding> I do think we should be using miners profit incentive more for\nstuff rather than trying to normalize mempool policy (which not entirely\npossible), e.g. things like\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\n\"\n\nArguing for package-relay \"permanence\" moves in the contrary decision IMHO ?\n\n> I don't think it's appropriate to be creating timelines like this that\ndepend on the work of a large number of contributors who I don't believe\n\nThanks Dave, this is your opinion and I respect this. I'll let any\nparticipant of this mailing list make an opinion on its own, following\ntheir private judgement. It might be based from a lot of different factors,\ne.g \"trusting the experts\" or gathering diverse in-field authorities'\nopinions or reasoning from scratch based on raw, public facts.\n\nThough might I ask you on which information sources are you finding your\nbelief ? I'm curious if you're aware of any contributors who feel entitled\nto be consulted in a decentralized development process...\n\nFor the records, I did consult no one. As even in the technical circle that\nwould have been a lot of open source projects teams to reach out : LND,\nc-ligtning, Eclair, coin-teleport, revault, sapio, btcsuite, bcoin,\nlibbitcoin, wasabi's coinjoin, samourai wallet's coinjoin, ...\n\nI was lazy, I just shot a mail :p\n\nW.r.t to Greg's 4-year old's piece, I'll let him express his opinion on how\nthe expressed framework applies to my post, the Bitcoin dev stage has grown\na lot since then. What was making sense when you had like ~20 Bitcoin dev\nwith 90% of the technical knowledge doesn't scale when you have multiple\nsecond-layers specifications of which you have multiple implementations\nteams, some of them  decentralized and spread through different\ncountries/timezones, IMHO.\n\nThough, Dave if you strongly hold your opinion on my behavior, I would\ninvite you to do this intellectual work by yourself.\n\nBrowsing quickly through Greg's piece, a lot of the reasoning is based on\nFOSS experience from Linux/Juniper, which to the best of my knowledge are\ncentralized software projects ?\n\nNote, also Paul Storzc's post has the simple phrase :\n\n\"I emphasized concrete numbers, and concrete dates\"\n\nI believe my post doesn't have such numbers and concrete dates ?\n\nPresence of Core version numbers are motivated as clear signalling for L2\ndeveloppers to update their backend in case of undocumented, subtle policy\nchanges slipping in the codebase. Let's minimize CVE-2020-26895\nstyle-of-bugs across the ecosystem :/\n\nFinally, the presence of timelines in this post is also a gentle call for\nthe Bitcoin ecosystem to act on those safety holes, of which the\nseriousness has been underscored by a lot of contributors in the past,\nespecially for the pre-signed feerate problem and even before I was in the\nBitcoin stage.\n\nSo better to patch them before they do manifest in the wild, and folks\nstart to bleed coins.  What you learn from practicing security research,\nthe lack of action can be harmful :/\n\n> Stuff will get done when it gets done.\n\nDon't forget bugs might slip in but that's fine if you have the skilled\nfolks around to catch them :)\n\nAnd yes I really care about Lightning, and all those cute new L2 protocols\nfostering in the community :)\n\nFinally, you know Dave, I'm just spreading ideas.\n\nIf those ideas are sound and folks love them, awesome! They're free to use,\nstudy, share and modify them to build better systems.\n\nIf I'm wrong, like I've been in the past, like I might be today and like\nI'll be in the future, I hope they will be patient to teach me back and\nwe'll learn.\n\nHacker ethos :) ?\n\nCheers,\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html\n\n[1] https://github.com/bitcoin/bitcoin/issues/14895\n\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-February/002569.html\n\nLe sam. 19 juin 2021 \u00e0 09:38, David A. Harding <dave at dtrt.org> a \u00e9crit :\n\n> On Fri, Jun 18, 2021 at 06:11:38PM -0400, Antoine Riard wrote:\n> > 2) Solving the Pre-Signed Feerate problem : Package-Relay or\n> > SIGHASH_ANYPREVOUT\n> >\n> > For Lightning, either package-relay or SIGHASH_ANYPREVOUT should be able\n> to\n> > solve the pre-signed feerate issue [3]\n> >\n> > [...]\n> >\n> > [3] I don't think there is a clear discussion on how SIGHASH_ANYPREVOUT\n> > solves pinnings beyond those LN meetings logs:\n> > https://gnusha.org/lightning-dev/2020-06-08.log\n>\n> For anyone else looking, the most relevant line seems to be:\n>\n>   13:50 < BlueMatt> (sidenote: sighash_no_input is *really* elegant here\n>   - assuming a lot of complicated logic in core to do so, you could\n>   imagine blind-cpfp-bumping *any* commitment tx without knowing its\n>   there or which one it is all with one tx.......in theory)\n>\n> That might work for current LN-penalty, but I'm not sure it works for\n> eltoo.  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\n> to refer to any prevout, that implies anyone else can do the same.\n> Miners who were aware of two or more states from an eltoo channel would\n> be incentivized to rewrite to the oldest state, giving them fee revenue\n> now and ensuring fee revenue in the future when a later state update is\n> broadcast.\n>\n> If the attacker using pinning is able to reuse their attack at no cost,\n> they can re-pin the channel again and force the honest user to pay\n> another anyprevout bounty to miners.  Repeat this a bunch of times and\n> the honest user has now spent more on fees than their balance from the\n> closed channel.\n>\n> Even if my analysis above is wrong, I would encourage you or Matt or\n> someone to write up this anyprevout idea in more detail and distribute\n> it before you promote it much more.\n>\n> > package-relay sounds a reasonable, temporary \"patch\".\n>\n> Even if every protocol based on presigned transactions can magically\n> allow dynamically adding inputs and modifying outputs for fees, and we\n> also have a magic perfect transaction replacement protocol, package\n> relay is still fundamentally useful for CPFP fee bumping very low\n> feerate transactions received from an external party.  E.g. Alice pays\n> Bob, mempool min feerates increase and Alice's transaction is dropped,\n> Bob still wants the money, so he submits a package with Alice's\n> transaction plus his own high feerate spend of it.\n>\n> Package relay is a clear improvement now, and one I expect to be\n> permanent for as long as we're using anything like the current protocol.\n>\n> > # Deployment timeline\n> >\n> > So what I believe as a rough deployment timeline.\n>\n> I don't think it's appropriate to be creating timelines like this that\n> depend on the work of a large number of contributors who I don't believe\n> you've consulted.  For details on this point of view, please see\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014726.html\n>\n> Stuff will get done when it gets done.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210621/7d375a2a/attachment-0001.html>"
            },
            {
                "author": "Michael Folkson",
                "date": "2021-06-21T10:20:40",
                "message_text_only": "I don't want to divert from the topic of this thread (\"Waiting\nSIGHASH_ANYPREVOUT and Packing Packages\"), we can set up a separate\nthread if we want to discuss this further. But just a couple of\nthings.\n\n> Browsing quickly through Greg's piece, a lot of the reasoning is based on FOSS experience from Linux/Juniper, which to the best of my knowledge are centralized software projects ?\n\nThat is Greg's point. If Linux doesn't look further than the current\nversion and the next version with a BDFL (Linus) a decentralized\nproject like Bitcoin Core is going to struggle even more with longer\nterm roadmaps.\n\nI think it is important to discuss what order changes should be\nattempted but I agree with David that putting specific future version\nnumbers on changes is speculative at best and misleading at worst. The\nrecord of previous predictions of what will be included in particular\nfuture versions is not strong :)\n\n> What was making sense when you had like ~20 Bitcoin dev with 90% of the technical knowledge doesn't scale when you have multiple second-layers specifications\n\nIt is great that we have a larger set of contributors in the ecosystem\ntoday than back in say pre 2017. But today that set of contributors is\nspread widely across a number of different projects that didn't exist\npre 2017. Changes to Core are (generally) likely to be implemented and\nreviewed by current Core contributors as Lightning implementation\ndevelopers (generally) seem to have their hands full with their own\nimplementations.\n\nI think we can get the balance right by making progress on this\n(important) discussion whilst also maintaining humility that we don't\nknow exact timelines and that getting things merged into Core relies\non a number of people who have varying levels of interest and\nunderstanding of L2 protocols.\n\nOn Mon, Jun 21, 2021 at 9:13 AM Antoine Riard <antoine.riard at gmail.com> wrote:\n>\n> Hi Dave,\n>\n> > That might work for current LN-penalty, but I'm not sure it works for\n> eltoo.\n>\n> Well, we have not settled yet on the eltoo design but if we take the later proposal in date [0], signing the update transaction with SIGHGASH_ANYPREVOUT lets you attach non-interactively a single-party controlled input at broadcast-time. Providing the input amount is high enough to bump the transaction feerate over network mempools, it should allow the tx to propagate across network mempools and that way solve the pre-signed feerate problem as defined in the post ?\n>\n> >  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\n> > to refer to any prevout, that implies anyone else can do the same.\n> > Miners who were aware of two or more states from an eltoo channel would\n> > be incentivized to rewrite to the oldest state, giving them fee revenue\n> > now and ensuring fee revenue in the future when a later state update is\n> > broadcast.\n>\n> Yep, you can add a per-participant key to lockdown the transaction and avoid any in-flight malleability ? I think this is discussed in the \"A Stroll through Fee-Bumping Techniques\" thread.\n>\n> > If the attacker using pinning is able to reuse their attack at no cost,\n> > they can re-pin the channel again and force the honest user to pay\n> > another anyprevout bounty to miners.\n>\n> This is also true with package-relay where your counterparty, with a better knowledge of network mempools, can always re-broadcast a CPFP-bumped malicious package ? Under this assumption, I think you should always be ready to bump our honest package.\n>\n> Further, for the clarity of the discussion, can you point to which pinning scenario you're thinking of or if it's new under SIGHASH_ANYPREVOUT, describe it ?\n>\n> > Repeat this a bunch of times and the honest user has now spent more on fees than their balance from the\n> closed channel.\n>\n> And sadly, as this concern also exists in case of a miner-harvesting attack against LN nodes, a concern that Gleb and I expressed more than a year ago in a public post [1], a good L2 client should always upper bound its fee-bumping reserve. I've a short though-unclear note on this notion of fee-bumping upper to warn other L2 engineers  in \"On Mempool Funny Games against Multi-Party Funded Transactions\"\n>\n> Please read so:\n>\n> \"A L2 client, with only a view of its mempool at best, won't understand why\n>  the transaction doesn't confirm and if it's responsible for the\n>  fee-bumping, it might do multiple rounds of feerate increase through CPFP,\n>  in vain. As the fee-bumping algorithm is assumed to be known if the victim\n>  client is open source code, the attacker can predict when the fee-bumping\n>  logic reaches its upper bound.\"\n>\n> Though thanks for the recall! I should log dynamic-balances in RL's `ChannelMonitorUpdate` for our ongoing implementation of anchor, updating my TODO :p\n>\n> > Even if my analysis above is wrong, I would encourage you or Matt or\n> someone to write up this anyprevout idea in more detail and distribute\n> it before you promote it much more.\n>\n> That's a really fair point, as a lot of the reasoning was based on private discussion with Matt. Though as SIGHASH_ANYPREVOUT isn't advocated for community consensus and those things take time, should just take a few hours of my time.\n>\n> > Even if every protocol based on presigned transactions can magically\n> allow dynamically adding inputs and modifying outputs for fees, and we\n> also have a magic perfect transaction replacement protocol,\n>\n> \"\u201cAny sufficiently advanced technology is indistinguishable from magic.\u201d Arthur C. Clarke\n>\n> Wit apart, that might be the outcome with careful bitcoin protocol development, where technical issues are laid out in a best effort (of mine!) and spread to the Bitcoin community on the most public bitcoin communication channel ?\n>\n> And humbly, on all those L2 issues I did change my opinion, as I've written so much explicitly in this thread post by pointing to an older post of mine (\"Advances in Bitcoin Contracting : Uniform Policy and Package Relay\"). This reversal, partially motivated by a lot of discussion with folks, including yourself, initiated since at least mid last year.\n>\n> > package relay is still fundamentally useful for CPFP fee bumping very low\n> > feerate transactions received from an external party.  E.g. Alice pays\n> > Bob, mempool min feerates increase and Alice's transaction is dropped,\n> > Bob still wants the money, so he submits a package with Alice's\n> > transaction plus his own high feerate spend of it.\n>\n> I think this point would be a reverse of our p2p design where we are now making the sender responsible for the receiver quality of its mempool feerate ? This question has never been clear up during the years-long discussion of package-relay design [1].\n>\n> Though referring to the thread post and last week's transaction-relay workshop, I did point out that package-relay might serve in the long-term as a mempool-sync mechanism to prevent potential malicious mempool partitions [2].\n>\n> > Package relay is a clear improvement now, and one I expect to be\n> permanent for as long as we're using anything like the current protocol\n>\n> Again, reading my post, I did point out that we might keep the \"lower half\" of package-relay and deprecate only the higher part of it as we have more feerate-efficient fee-bumping primitive available. If  it sounds too much of a release engineering effort to synchronize on the scale of an ecosystem, think about the ongoing deprecation of Tor V2.\n>\n> Further, you did express a far less assertive opinion during last Tuesday transaction-relay workshops, to which a lot of folks attended, where you pointed it might not be a good idea for L2s to make more assumptions on non-normative:\n>\n> \"harding> I do think we should be using miners profit incentive more for stuff rather than trying to normalize mempool policy (which not entirely possible), e.g. things like https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\"\n>\n> Arguing for package-relay \"permanence\" moves in the contrary decision IMHO ?\n>\n> > I don't think it's appropriate to be creating timelines like this that\n> depend on the work of a large number of contributors who I don't believe\n>\n> Thanks Dave, this is your opinion and I respect this. I'll let any participant of this mailing list make an opinion on its own, following their private judgement. It might be based from a lot of different factors, e.g \"trusting the experts\" or gathering diverse in-field authorities' opinions or reasoning from scratch based on raw, public facts.\n>\n> Though might I ask you on which information sources are you finding your belief ? I'm curious if you're aware of any contributors who feel entitled to be consulted in a decentralized development process...\n>\n> For the records, I did consult no one. As even in the technical circle that would have been a lot of open source projects teams to reach out : LND, c-ligtning, Eclair, coin-teleport, revault, sapio, btcsuite, bcoin, libbitcoin, wasabi's coinjoin, samourai wallet's coinjoin, ...\n>\n> I was lazy, I just shot a mail :p\n>\n> W.r.t to Greg's 4-year old's piece, I'll let him express his opinion on how the expressed framework applies to my post, the Bitcoin dev stage has grown a lot since then. What was making sense when you had like ~20 Bitcoin dev with 90% of the technical knowledge doesn't scale when you have multiple second-layers specifications of which you have multiple implementations teams, some of them  decentralized and spread through different countries/timezones, IMHO.\n>\n> Though, Dave if you strongly hold your opinion on my behavior, I would invite you to do this intellectual work by yourself.\n>\n> Browsing quickly through Greg's piece, a lot of the reasoning is based on FOSS experience from Linux/Juniper, which to the best of my knowledge are centralized software projects ?\n>\n> Note, also Paul Storzc's post has the simple phrase :\n>\n> \"I emphasized concrete numbers, and concrete dates\"\n>\n> I believe my post doesn't have such numbers and concrete dates ?\n>\n> Presence of Core version numbers are motivated as clear signalling for L2 developpers to update their backend in case of undocumented, subtle policy changes slipping in the codebase. Let's minimize CVE-2020-26895 style-of-bugs across the ecosystem :/\n>\n> Finally, the presence of timelines in this post is also a gentle call for the Bitcoin ecosystem to act on those safety holes, of which the seriousness has been underscored by a lot of contributors in the past, especially for the pre-signed feerate problem and even before I was in the Bitcoin stage.\n>\n> So better to patch them before they do manifest in the wild, and folks start to bleed coins.  What you learn from practicing security research, the lack of action can be harmful :/\n>\n> > Stuff will get done when it gets done.\n>\n> Don't forget bugs might slip in but that's fine if you have the skilled folks around to catch them :)\n>\n> And yes I really care about Lightning, and all those cute new L2 protocols fostering in the community :)\n>\n> Finally, you know Dave, I'm just spreading ideas.\n>\n> If those ideas are sound and folks love them, awesome! They're free to use, study, share and modify them to build better systems.\n>\n> If I'm wrong, like I've been in the past, like I might be today and like I'll be in the future, I hope they will be patient to teach me back and we'll learn.\n>\n> Hacker ethos :) ?\n>\n> Cheers,\n> Antoine\n>\n> [0] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html\n>\n> [1] https://github.com/bitcoin/bitcoin/issues/14895\n>\n> [2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-February/002569.html\n>\n> Le sam. 19 juin 2021 \u00e0 09:38, David A. Harding <dave at dtrt.org> a \u00e9crit :\n>>\n>> On Fri, Jun 18, 2021 at 06:11:38PM -0400, Antoine Riard wrote:\n>> > 2) Solving the Pre-Signed Feerate problem : Package-Relay or\n>> > SIGHASH_ANYPREVOUT\n>> >\n>> > For Lightning, either package-relay or SIGHASH_ANYPREVOUT should be able to\n>> > solve the pre-signed feerate issue [3]\n>> >\n>> > [...]\n>> >\n>> > [3] I don't think there is a clear discussion on how SIGHASH_ANYPREVOUT\n>> > solves pinnings beyond those LN meetings logs:\n>> > https://gnusha.org/lightning-dev/2020-06-08.log\n>>\n>> For anyone else looking, the most relevant line seems to be:\n>>\n>>   13:50 < BlueMatt> (sidenote: sighash_no_input is *really* elegant here\n>>   - assuming a lot of complicated logic in core to do so, you could\n>>   imagine blind-cpfp-bumping *any* commitment tx without knowing its\n>>   there or which one it is all with one tx.......in theory)\n>>\n>> That might work for current LN-penalty, but I'm not sure it works for\n>> eltoo.  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\n>> to refer to any prevout, that implies anyone else can do the same.\n>> Miners who were aware of two or more states from an eltoo channel would\n>> be incentivized to rewrite to the oldest state, giving them fee revenue\n>> now and ensuring fee revenue in the future when a later state update is\n>> broadcast.\n>>\n>> If the attacker using pinning is able to reuse their attack at no cost,\n>> they can re-pin the channel again and force the honest user to pay\n>> another anyprevout bounty to miners.  Repeat this a bunch of times and\n>> the honest user has now spent more on fees than their balance from the\n>> closed channel.\n>>\n>> Even if my analysis above is wrong, I would encourage you or Matt or\n>> someone to write up this anyprevout idea in more detail and distribute\n>> it before you promote it much more.\n>>\n>> > package-relay sounds a reasonable, temporary \"patch\".\n>>\n>> Even if every protocol based on presigned transactions can magically\n>> allow dynamically adding inputs and modifying outputs for fees, and we\n>> also have a magic perfect transaction replacement protocol, package\n>> relay is still fundamentally useful for CPFP fee bumping very low\n>> feerate transactions received from an external party.  E.g. Alice pays\n>> Bob, mempool min feerates increase and Alice's transaction is dropped,\n>> Bob still wants the money, so he submits a package with Alice's\n>> transaction plus his own high feerate spend of it.\n>>\n>> Package relay is a clear improvement now, and one I expect to be\n>> permanent for as long as we're using anything like the current protocol.\n>>\n>> > # Deployment timeline\n>> >\n>> > So what I believe as a rough deployment timeline.\n>>\n>> I don't think it's appropriate to be creating timelines like this that\n>> depend on the work of a large number of contributors who I don't believe\n>> you've consulted.  For details on this point of view, please see\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014726.html\n>>\n>> Stuff will get done when it gets done.\n>>\n>> -Dave\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-06-24T13:03:21",
                "message_text_only": "Hi Michael,\n\n> Browsing quickly through Greg's piece, a lot of the reasoning is based on\nFOSS experience from Linux/Juniper, which to the best of my knowledge are\ncentralized software projects ?\n\n> That is Greg's point. If Linux doesn't look further than the current\n> version and the next version with a BDFL (Linus) a decentralized\n> project like Bitcoin Core is going to struggle even more with longer\n> term roadmaps.\n\nI was far more inclined to recall the unsolved problems for Lightning/L2s\n(pre-signed feerate/tx-pinnings) than calling out strong solutions to them.\nI believe problem spaces are quite something stable in engineering/science,\nat least until they're formalized differently. But even coming to consensus\non  the existence of problems and a shared perception of the severity of\nthem can take a long time. In fact, it might even be the hardest step in a\ndecentralized ecosystem like Bitcoin.\n\nAnd I fill in on the low-relevance of roadmaps, real development is a\ncontinuous zigzag. If we look in the past and take the transaction\nmalleability issue, I think we can observe it took multiple proposals (bip\n62, normalized txid,  sighash_noinput, ...),  of which we're even\nimplemented in Core, before to finally settle on segwit. Though I would say\nlessons were drawn about shortcomings of every transient proposal.\n\n> I think it is important to discuss what order changes should be\n> attempted but I agree with David that putting specific future version\n> numbers on changes is speculative at best and misleading at worst. The\n> record of previous predictions of what will be included in particular\n> future versions is not strong :)\n\nI recognize it wasn't delicate to put exact version numbers, though note\nmultiple, alternative versions numbers were deliberately proposed for each\nspecific change and timelines given in terms of years,  more as an invite\nto open a discussion on such changes and where/when they could take place,\nthat in anyway a finite, consistent deployment proposal.\n\nFurther, I still believe it would be cool to have a bit more coordination\nwhen Core implements sophisticated mechanisms designed for downstream\nsupport, in the sense of feedback exchanged across projects all along their\nrelease schedules. For e.g, with package-relay, as a Lightning team it's\nlikely you will have to rework your tx-broadcast module which might take a\nfew good weeks of review and test. Though, coming to this best practice\n(imho) across the different Bitcoin layers might take years and that's\nperfectly fine, we'll see what emerges :)\n\n> What was making sense when you had like ~20 Bitcoin dev with 90% of the\ntechnical knowledge doesn't scale when you have multiple second-layers\nspecifications\n\n> It is great that we have a larger set of contributors in the ecosystem\n> today than back in say pre 2017. But today that set of contributors is\n> spread widely across a number of different projects that didn't exist\n> pre 2017. Changes to Core are (generally) likely to be implemented and\n> reviewed by current Core contributors as Lightning implementation\n> developers (generally) seem to have their hands full with their own\n> implementations.\n\nWell I strongly believe that the Core review process is open to anyone :) ?\nIf some upper layers contributors are generously offering their time to\nshare back their experiences, especially during the design phase of\nsoftware features, I hope we might be on path to deliver better stuff.\n\nFurther, that's a more personal note, I'm worried long-term about\nlayer-monoculture cropping up in the ecosystem, a concern echoing the\nhistory of Internet development [0].\n\n> I think we can get the balance right by making progress on this\n> (important) discussion whilst also maintaining humility that we don't\n> know exact timelines and that getting things merged into Core relies\n> on a number of people who have varying levels of interest and\n> understanding of L2 protocols.\n\nYes, as answers to my post are showing, I might have lacked patience in\nthis case :/ Sometimes, it's hard to gauge your own cognitive dissonance on\ntopics.\n\nCheers,\nAntoine\n\n[0] See \"Interactions between Layers\" in \"General Architectural and Policy\nConsiderations\", RFC 3426\n\nLe lun. 21 juin 2021 \u00e0 06:20, Michael Folkson <michaelfolkson at gmail.com> a\n\u00e9crit :\n\n> I don't want to divert from the topic of this thread (\"Waiting\n> SIGHASH_ANYPREVOUT and Packing Packages\"), we can set up a separate\n> thread if we want to discuss this further. But just a couple of\n> things.\n>\n> > Browsing quickly through Greg's piece, a lot of the reasoning is based\n> on FOSS experience from Linux/Juniper, which to the best of my knowledge\n> are centralized software projects ?\n>\n> That is Greg's point. If Linux doesn't look further than the current\n> version and the next version with a BDFL (Linus) a decentralized\n> project like Bitcoin Core is going to struggle even more with longer\n> term roadmaps.\n>\n> I think it is important to discuss what order changes should be\n> attempted but I agree with David that putting specific future version\n> numbers on changes is speculative at best and misleading at worst. The\n> record of previous predictions of what will be included in particular\n> future versions is not strong :)\n>\n> > What was making sense when you had like ~20 Bitcoin dev with 90% of the\n> technical knowledge doesn't scale when you have multiple second-layers\n> specifications\n>\n> It is great that we have a larger set of contributors in the ecosystem\n> today than back in say pre 2017. But today that set of contributors is\n> spread widely across a number of different projects that didn't exist\n> pre 2017. Changes to Core are (generally) likely to be implemented and\n> reviewed by current Core contributors as Lightning implementation\n> developers (generally) seem to have their hands full with their own\n> implementations.\n>\n> I think we can get the balance right by making progress on this\n> (important) discussion whilst also maintaining humility that we don't\n> know exact timelines and that getting things merged into Core relies\n> on a number of people who have varying levels of interest and\n> understanding of L2 protocols.\n>\n> On Mon, Jun 21, 2021 at 9:13 AM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n> >\n> > Hi Dave,\n> >\n> > > That might work for current LN-penalty, but I'm not sure it works for\n> > eltoo.\n> >\n> > Well, we have not settled yet on the eltoo design but if we take the\n> later proposal in date [0], signing the update transaction with\n> SIGHGASH_ANYPREVOUT lets you attach non-interactively a single-party\n> controlled input at broadcast-time. Providing the input amount is high\n> enough to bump the transaction feerate over network mempools, it should\n> allow the tx to propagate across network mempools and that way solve the\n> pre-signed feerate problem as defined in the post ?\n> >\n> > >  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\n> > > to refer to any prevout, that implies anyone else can do the same.\n> > > Miners who were aware of two or more states from an eltoo channel would\n> > > be incentivized to rewrite to the oldest state, giving them fee revenue\n> > > now and ensuring fee revenue in the future when a later state update is\n> > > broadcast.\n> >\n> > Yep, you can add a per-participant key to lockdown the transaction and\n> avoid any in-flight malleability ? I think this is discussed in the \"A\n> Stroll through Fee-Bumping Techniques\" thread.\n> >\n> > > If the attacker using pinning is able to reuse their attack at no cost,\n> > > they can re-pin the channel again and force the honest user to pay\n> > > another anyprevout bounty to miners.\n> >\n> > This is also true with package-relay where your counterparty, with a\n> better knowledge of network mempools, can always re-broadcast a CPFP-bumped\n> malicious package ? Under this assumption, I think you should always be\n> ready to bump our honest package.\n> >\n> > Further, for the clarity of the discussion, can you point to which\n> pinning scenario you're thinking of or if it's new under\n> SIGHASH_ANYPREVOUT, describe it ?\n> >\n> > > Repeat this a bunch of times and the honest user has now spent more on\n> fees than their balance from the\n> > closed channel.\n> >\n> > And sadly, as this concern also exists in case of a miner-harvesting\n> attack against LN nodes, a concern that Gleb and I expressed more than a\n> year ago in a public post [1], a good L2 client should always upper bound\n> its fee-bumping reserve. I've a short though-unclear note on this notion of\n> fee-bumping upper to warn other L2 engineers  in \"On Mempool Funny Games\n> against Multi-Party Funded Transactions\"\n> >\n> > Please read so:\n> >\n> > \"A L2 client, with only a view of its mempool at best, won't understand\n> why\n> >  the transaction doesn't confirm and if it's responsible for the\n> >  fee-bumping, it might do multiple rounds of feerate increase through\n> CPFP,\n> >  in vain. As the fee-bumping algorithm is assumed to be known if the\n> victim\n> >  client is open source code, the attacker can predict when the\n> fee-bumping\n> >  logic reaches its upper bound.\"\n> >\n> > Though thanks for the recall! I should log dynamic-balances in RL's\n> `ChannelMonitorUpdate` for our ongoing implementation of anchor, updating\n> my TODO :p\n> >\n> > > Even if my analysis above is wrong, I would encourage you or Matt or\n> > someone to write up this anyprevout idea in more detail and distribute\n> > it before you promote it much more.\n> >\n> > That's a really fair point, as a lot of the reasoning was based on\n> private discussion with Matt. Though as SIGHASH_ANYPREVOUT isn't advocated\n> for community consensus and those things take time, should just take a few\n> hours of my time.\n> >\n> > > Even if every protocol based on presigned transactions can magically\n> > allow dynamically adding inputs and modifying outputs for fees, and we\n> > also have a magic perfect transaction replacement protocol,\n> >\n> > \"\u201cAny sufficiently advanced technology is indistinguishable from magic.\u201d\n> Arthur C. Clarke\n> >\n> > Wit apart, that might be the outcome with careful bitcoin protocol\n> development, where technical issues are laid out in a best effort (of\n> mine!) and spread to the Bitcoin community on the most public bitcoin\n> communication channel ?\n> >\n> > And humbly, on all those L2 issues I did change my opinion, as I've\n> written so much explicitly in this thread post by pointing to an older post\n> of mine (\"Advances in Bitcoin Contracting : Uniform Policy and Package\n> Relay\"). This reversal, partially motivated by a lot of discussion with\n> folks, including yourself, initiated since at least mid last year.\n> >\n> > > package relay is still fundamentally useful for CPFP fee bumping very\n> low\n> > > feerate transactions received from an external party.  E.g. Alice pays\n> > > Bob, mempool min feerates increase and Alice's transaction is dropped,\n> > > Bob still wants the money, so he submits a package with Alice's\n> > > transaction plus his own high feerate spend of it.\n> >\n> > I think this point would be a reverse of our p2p design where we are now\n> making the sender responsible for the receiver quality of its mempool\n> feerate ? This question has never been clear up during the years-long\n> discussion of package-relay design [1].\n> >\n> > Though referring to the thread post and last week's transaction-relay\n> workshop, I did point out that package-relay might serve in the long-term\n> as a mempool-sync mechanism to prevent potential malicious mempool\n> partitions [2].\n> >\n> > > Package relay is a clear improvement now, and one I expect to be\n> > permanent for as long as we're using anything like the current protocol\n> >\n> > Again, reading my post, I did point out that we might keep the \"lower\n> half\" of package-relay and deprecate only the higher part of it as we have\n> more feerate-efficient fee-bumping primitive available. If  it sounds too\n> much of a release engineering effort to synchronize on the scale of an\n> ecosystem, think about the ongoing deprecation of Tor V2.\n> >\n> > Further, you did express a far less assertive opinion during last\n> Tuesday transaction-relay workshops, to which a lot of folks attended,\n> where you pointed it might not be a good idea for L2s to make more\n> assumptions on non-normative:\n> >\n> > \"harding> I do think we should be using miners profit incentive more for\n> stuff rather than trying to normalize mempool policy (which not entirely\n> possible), e.g. things like\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html\n> \"\n> >\n> > Arguing for package-relay \"permanence\" moves in the contrary decision\n> IMHO ?\n> >\n> > > I don't think it's appropriate to be creating timelines like this that\n> > depend on the work of a large number of contributors who I don't believe\n> >\n> > Thanks Dave, this is your opinion and I respect this. I'll let any\n> participant of this mailing list make an opinion on its own, following\n> their private judgement. It might be based from a lot of different factors,\n> e.g \"trusting the experts\" or gathering diverse in-field authorities'\n> opinions or reasoning from scratch based on raw, public facts.\n> >\n> > Though might I ask you on which information sources are you finding your\n> belief ? I'm curious if you're aware of any contributors who feel entitled\n> to be consulted in a decentralized development process...\n> >\n> > For the records, I did consult no one. As even in the technical circle\n> that would have been a lot of open source projects teams to reach out :\n> LND, c-ligtning, Eclair, coin-teleport, revault, sapio, btcsuite, bcoin,\n> libbitcoin, wasabi's coinjoin, samourai wallet's coinjoin, ...\n> >\n> > I was lazy, I just shot a mail :p\n> >\n> > W.r.t to Greg's 4-year old's piece, I'll let him express his opinion on\n> how the expressed framework applies to my post, the Bitcoin dev stage has\n> grown a lot since then. What was making sense when you had like ~20 Bitcoin\n> dev with 90% of the technical knowledge doesn't scale when you have\n> multiple second-layers specifications of which you have multiple\n> implementations teams, some of them  decentralized and spread through\n> different countries/timezones, IMHO.\n> >\n> > Though, Dave if you strongly hold your opinion on my behavior, I would\n> invite you to do this intellectual work by yourself.\n> >\n> > Browsing quickly through Greg's piece, a lot of the reasoning is based\n> on FOSS experience from Linux/Juniper, which to the best of my knowledge\n> are centralized software projects ?\n> >\n> > Note, also Paul Storzc's post has the simple phrase :\n> >\n> > \"I emphasized concrete numbers, and concrete dates\"\n> >\n> > I believe my post doesn't have such numbers and concrete dates ?\n> >\n> > Presence of Core version numbers are motivated as clear signalling for\n> L2 developpers to update their backend in case of undocumented, subtle\n> policy changes slipping in the codebase. Let's minimize CVE-2020-26895\n> style-of-bugs across the ecosystem :/\n> >\n> > Finally, the presence of timelines in this post is also a gentle call\n> for the Bitcoin ecosystem to act on those safety holes, of which the\n> seriousness has been underscored by a lot of contributors in the past,\n> especially for the pre-signed feerate problem and even before I was in the\n> Bitcoin stage.\n> >\n> > So better to patch them before they do manifest in the wild, and folks\n> start to bleed coins.  What you learn from practicing security research,\n> the lack of action can be harmful :/\n> >\n> > > Stuff will get done when it gets done.\n> >\n> > Don't forget bugs might slip in but that's fine if you have the skilled\n> folks around to catch them :)\n> >\n> > And yes I really care about Lightning, and all those cute new L2\n> protocols fostering in the community :)\n> >\n> > Finally, you know Dave, I'm just spreading ideas.\n> >\n> > If those ideas are sound and folks love them, awesome! They're free to\n> use, study, share and modify them to build better systems.\n> >\n> > If I'm wrong, like I've been in the past, like I might be today and like\n> I'll be in the future, I hope they will be patient to teach me back and\n> we'll learn.\n> >\n> > Hacker ethos :) ?\n> >\n> > Cheers,\n> > Antoine\n> >\n> > [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html\n> >\n> > [1] https://github.com/bitcoin/bitcoin/issues/14895\n> >\n> > [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-February/002569.html\n> >\n> > Le sam. 19 juin 2021 \u00e0 09:38, David A. Harding <dave at dtrt.org> a \u00e9crit :\n> >>\n> >> On Fri, Jun 18, 2021 at 06:11:38PM -0400, Antoine Riard wrote:\n> >> > 2) Solving the Pre-Signed Feerate problem : Package-Relay or\n> >> > SIGHASH_ANYPREVOUT\n> >> >\n> >> > For Lightning, either package-relay or SIGHASH_ANYPREVOUT should be\n> able to\n> >> > solve the pre-signed feerate issue [3]\n> >> >\n> >> > [...]\n> >> >\n> >> > [3] I don't think there is a clear discussion on how\n> SIGHASH_ANYPREVOUT\n> >> > solves pinnings beyond those LN meetings logs:\n> >> > https://gnusha.org/lightning-dev/2020-06-08.log\n> >>\n> >> For anyone else looking, the most relevant line seems to be:\n> >>\n> >>   13:50 < BlueMatt> (sidenote: sighash_no_input is *really* elegant here\n> >>   - assuming a lot of complicated logic in core to do so, you could\n> >>   imagine blind-cpfp-bumping *any* commitment tx without knowing its\n> >>   there or which one it is all with one tx.......in theory)\n> >>\n> >> That might work for current LN-penalty, but I'm not sure it works for\n> >> eltoo.  If Bitcoin Core can rewrite the blind CPFP fee bump transaction\n> >> to refer to any prevout, that implies anyone else can do the same.\n> >> Miners who were aware of two or more states from an eltoo channel would\n> >> be incentivized to rewrite to the oldest state, giving them fee revenue\n> >> now and ensuring fee revenue in the future when a later state update is\n> >> broadcast.\n> >>\n> >> If the attacker using pinning is able to reuse their attack at no cost,\n> >> they can re-pin the channel again and force the honest user to pay\n> >> another anyprevout bounty to miners.  Repeat this a bunch of times and\n> >> the honest user has now spent more on fees than their balance from the\n> >> closed channel.\n> >>\n> >> Even if my analysis above is wrong, I would encourage you or Matt or\n> >> someone to write up this anyprevout idea in more detail and distribute\n> >> it before you promote it much more.\n> >>\n> >> > package-relay sounds a reasonable, temporary \"patch\".\n> >>\n> >> Even if every protocol based on presigned transactions can magically\n> >> allow dynamically adding inputs and modifying outputs for fees, and we\n> >> also have a magic perfect transaction replacement protocol, package\n> >> relay is still fundamentally useful for CPFP fee bumping very low\n> >> feerate transactions received from an external party.  E.g. Alice pays\n> >> Bob, mempool min feerates increase and Alice's transaction is dropped,\n> >> Bob still wants the money, so he submits a package with Alice's\n> >> transaction plus his own high feerate spend of it.\n> >>\n> >> Package relay is a clear improvement now, and one I expect to be\n> >> permanent for as long as we're using anything like the current protocol.\n> >>\n> >> > # Deployment timeline\n> >> >\n> >> > So what I believe as a rough deployment timeline.\n> >>\n> >> I don't think it's appropriate to be creating timelines like this that\n> >> depend on the work of a large number of contributors who I don't believe\n> >> you've consulted.  For details on this point of view, please see\n> >>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014726.html\n> >>\n> >> Stuff will get done when it gets done.\n> >>\n> >> -Dave\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at gmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210624/9995e15b/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Waiting SIGHASH_ANYPREVOUT and Packing Packages",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "David A. Harding",
                "Michael Folkson",
                "Antoine Riard"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 77372
        }
    },
    {
        "title": "[Lightning-dev] On the recent softforks survey, forget to fulfill my answer!",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2021-06-21T15:05:57",
                "message_text_only": "Hi,\n\nI was super glad to see the recent survey on potential softforks for the\nnear-future of Bitcoin! I didn't have time to answer this one but will do\nso for the future. I wanna to salute the grassroots involvement in bitcoin\nprotocol development, that's cool to see :)\n\nThough softforks are what shine in the media and social networks, one\nshould not ignore they represent the aggregation of thousands of hours of\nsweat from contributors all across the ecosystem with discussion extending\nfrom IRC public or private chans, mailing list, medias, etc.\n\nWhat makes softfork discussion especially hard is that no one is following\nall those communications channels to collect the trace of information and\nas such it can be hard to reason on the Big Picture(tm). That's why\nsoft-forks take time, and we might somehow be prepared for them to take\neven more time in the future...\n\nThat said, where I would like to draw awareness of the community is about\nthe submerged part of bitcoin protocol development iceberg. Softforks are\nsexy, though you have far more areas of Bitcoin dev who would benefit from\na gentle boost by happy hands :p\n\nFor e.g, if you take Bitcoin Core, you have few ongoing projects were folks\nhave a hard time moving forward, e.g assumeutxo/mempool\nrefactos/addr-relay/rebroadcasting module/mutation testing/\nmultiprocess/wallet external signer/GUI maintenance/libbitcoin_kernel[0]\n\nThose projects start to be \"softfork\"-in-itself-size-of-engineering, and\nfor a lot of them might  require more than pure \"coding\" skills, such as\nspecification, simulations, extensive code coverage, up-to-date meeting\ndocuments. See what is currently done with the Core wiki [1]\n\nAll those projects are modifying critical areas of Bitcoin such as the\nvalidation engine or the p2p stack and AFAICT, they deserve more care.\nHopefully, by drawing the light there, more folks are going to understand\nthem, we'll have more skilled reviewers, reducing the reliance on a few\nsegments of the codebase being only understood by some seen experts and\nideally, ingenious, \"Many Eyes Make All Bugs Shallow\" :)\n\nThat said, it's only the technical ground and I believe the human layer of\nBitcoin dev might be the one where grassroots-involvement might be the most\nfruitful.\n\nI would say the Bitcoin dev stage has changed a bit since the last 18\nmonths, especially w.r.t to few factors, the arrival of massive development\nfunding, the sudden mediatisation of protocol developers and the pursued\ngeographical spreading, diversification and education of the poolset of\ncontributors.\n\nWhen I did arrive on the stage a few years ago, funding was still a hard\nquestion, even for well-known, long-term contributors and only a few actors\nwere taking care of Bitcoin. Really differently, from what we have seen on\nthe last months, where we have seen a plethora of new organisations\nentering the game and benefiting from the generosity of the Bitcoin\nindustry [2]\n\nThings have been so fast that sometimes one can wonder if there isn't a\nbubble around Bitcoin dev ? Few OGs might suggest we're back to 2017, with\nICO-like webpage pinning \"developers-as-brands\".  In reality, we see new\ngrant announcements every month or week, but still the number of reviewers\non Core doesn't seem to increase ? [3]\n\nHopefully, a lot of those new structures pretending to work for Bitcoin\nbetterness will get out of their childerness phase and slowly mature to\nsomething as sound as Chaincode or Square Crypto. Small, friendly,\npolitics-free engineering teams with years-long stability, solving bitcoin\nproblems with a \"forever\" perspective mindset.\n\nThough, as of today, you do have the opposite with the grant model. Being\nfunded on the rational that yours peers \"appreciate\" your work is more\ngoing to generate implicit compliance at review time where you should\ninstead spot their errors. Bitcoin development process is highly contrarian\nper nature, and constantly challenging your peers assumptions has been\npreserving software robustness.\n\nTime will separate the wheat from the chaff though how to make things\nbetter in the short term ? I don't know, maybe those structures could be\nexemplary and outsource their grant allocation decisions framework ? Or ask\nthem to publish grant contract under which contributors are engaging\nthemselves to observe if the usual independence provisions are present [4]\n\nIn another direction, I believe the ongoing mediatization increase of the\nBitcoin dev stage in the last months or so didn't improve the current state\nof affairs. We now see technical proposals, of which the soundness have not\nbeen thoroughly discussed in the traditional venues, being announced in big\npump as some kind of \"done-deal\", potentially sustaining the false belief\nit has been already blessed or approved by the rest of the development\ncommunity.\n\nAnd honestly, it's quite easy to approach any Bitcoin media today once\nyou're a bit technical, and rely on lingo to create a perception of\ncompetency towards your interlocutors. In fact, your talking isn't going to\nbe debunked by your peers as most of the time they have other,\non-the-ground, engineering issues to care about. Or say differently, if\nyou're a Bitcoin journalist today, it's quite easy for smart ass like me to\nhijack your production :p\n\nDon't trust, verify :)\n\nAnother bottleneck in Bitcoin development is the ongoing spreading of\ncontributors around many geographical areas and timezones, making\nintra-communication far harder. Lightning dev or Bitcoin Core technical\nmeetings might happen at the end of your local day but another attendee\nmight just get started, and with time you feel how divergence in level of\nenergies influences the serendipity of engineering discussions.\n\nCommunication might not flow smoothly through all the development\nstakeholders and how do we make communications more distributed and\nfault-tolerance without losing on the quality ? I don't have the\nanswers...Yes, the Earth isn't flat and that's an issue for Bitcoin dev :/\n\nThe ongoing increase in developer diversity is also something to salute.\nAnyone is invited to contribute without regards to technical experience,\nrace, \"expertise\", OSS experience, age, gender, language or any other\nsocial concern. I believe diversity is a force for Bitcoin development and\nI would like to congrat my fellow female Bitcoin hackers of which the\ncontinuous hard work and smartness should inspire more women to follow\ntheir tracks in the coming years. Pioneering has always been hard :/\n\nAnother remaining issue is developer education. The development of\ncryptocurrencies demands a high-level of rigor, adversarial thinking,\nthorough testing and risk-minimization development strategy. Any bug may\ncost users real money and disrupt folks' lives. We still have a lot to\nlearn from the Old Guard, which sadely are less and less active on the\ndaily ground and I would say the ecosystem infrastructure would be far more\nsane with more security-oriented folks.\n\nAs a young developer, even armed with the best intentions it takes years to\nadopt a security-first mindset and continuously extend and mature your\ntechnical stack. One has to become fluent through a wide variety of areas\nto be an efficient contributor, distributed systems, internet protocol,\napplied cryptography, database, game theory, professional english,\nquality-assurance best practices, the list is never ending and there is\nalways a nice chunk of knowledge to go after :)\n\nLastly, another uncomfortable issue to talk about is direct pressure\nexercised on the developers themselves to bend their works, as the ongoing\nCSW case sadly recalls. Flavors of those concerns  have been mentioned a\nlot through Bitcoin archives [5].\n\nSo far, I've never heard about angry calls passed backstage to Bitcoin\ncontributors, deliberately made to influence the expression of their public\ntechnical opinions. Though in the future, if that kind  of thorny situation\nhappens to you as a Bitcoin FOSS contributor, remember that you're always\nfree to discuss discretely about potential conflict of interests you\nobserve with folks of confidence around you. Or if you prefer to keep the\nanonymity, reach out to some investigative journalists under a cover\nidentity.\n\nHere is, I think that's all the area where I would be glad to see more\ngrassroot-engagement or even any coming from the industry with eager\nmotivation to help on those fronts.\n\nAsk not what Bitcoin can do for you - ask what you can do for Bitcoin :)\n\nCheers,\nAntoine\n\nPS: oh, and SIGHAsH_PURPLE for the win :p\n\n[0] That's a joke on mutation testing, it's a trillion-dollar codebase, but\nwe don't do\nmutation testing. Sad :/\n\n[1] See https://github.com/bitcoin-core/bitcoin-devwiki/wiki\n\n[2] Disclaimer: I'm not open to outbound sponsorship proposals.\n\n[3] As backed by data here :\nhttps://adamjonas.com/bitcoin/coredev/retro/coredev-2020-retro/\n\n[4] For e.g, a lot of grant legal frameworks don't have clauses\nguaranteeing the independence of the\ngeneral Bitcoin Core or Lightning development, just a smaller subset around\nvalidity of block rules,\ninspired from the BitMex open one. Clearly a hole if you ask any competent\nlawyer...\n\n[5] Flavors of those concerns have been mentioned a lot through Bitcoin\narchives:\n\nSee \"Bitcoin in 2021\":\nhttps://www.erisian.com.au/wordpress/2021/01/07/bitcoin-in-2021\n\n\" After all, if you can replace all the people who would\u2019ve objected to\nwhat you want to do, there\u2019s\nno need to sneak it in and hope no one notices in review, you can just do\nit, and even if you don\u2019t\ngetrid of everyone who would object you at least lower the chances that\nyour patch will get a thorough\nreview by whoever remains. There are a variety of ways you can do that. One\nis finding way of making\ncontributing unpleasant enough that your targets just leave on their own:\nconstant arguments about\nhings that don\u2019t really matter, slowing down progress so it feels like\nyou\u2019re just wasting time,\nand personal attacks in the media (or on social media), for instance.\nAnother is the cancel-culture\napproach of trying to make them a pariah so no one else will have anything\nto do with them.\"\n\nOr see \"Working on social contracts (was: Paper currency)\" :\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-May/005851.html\n\n\"I promise that if bad people show up with a sufficient pointy gun that\nI'll do whatever they tell me to do. I'll make bad proposals, submit\nbackdoors, and argue with querulous folks on mailing lists, diverting\nthem from real development and review work, all as commanded. Maybe\nI'll try to sneak out a warning of some kind, maybe... but with my\nlife or my families or friends lives on the line\u2014 probably not.\n\n... and I think that anyone who tells you otherwise probably just\nhasn't really thought it through.  So what is the point of commitments\nlike that?  People change, people go crazy, people are coerced. Crap\nhappens, justifications are made, life goes on\u2014 or so we hope.\"\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210621/fef4c314/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "On the recent softforks survey, forget to fulfill my answer!",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 11124
        }
    },
    {
        "title": "[Lightning-dev] complementing lightning with with a discreet physical delivery protocol?",
        "thread_messages": [
            {
                "author": "vzxplnhqr at tutanota.com",
                "date": "2021-06-25T18:05:25",
                "message_text_only": "Dear Lightning-dev,\n\nI would like to share some initial research and ask for some feedback. https://github.com/VzxPLnHqr/discreet-physical-delivery-protocol\u00a0is a repository to gather some thoughts around how it might be possible to utilize some of the current features (hodl invoices), and/or forthcoming features (payment points? dlcs?) of lightning to create a robust, reasonably private, and incentive-compatible network for physical delivery of items.\n\nThere has been mention of using hodl invoices for atomic item delivery[1]. However, I seem to remember reading that, essentially, hodl invoices (e.g. invoices which may not settle for quite some time, if ever) are also the primary culprit for some attacks on the network?\n\nDoes lightning in a post-taproot world solve any of these issues?\n\nThere is some motivation given in the readme for why such a protocol may be desirable, but as quick refresher for those reading who may not be familiar with how lightning and hodl invoices can be used for atomic package delivery:\n\n0. Merchant Mary operates an e-commerce website and Purchaser Paul would like to buy something and have it delivered. For initial simplicity, assume that both Paul and Mary have a relationship with Charlie, an independent Courier (e.g. neither Paul nor Mary is playing the role of Charlie, but Charlie knows the geographical locations of both).\n\n1. During checkout, Paul generates preimage\u00a0and sends\u00a0hash\u00a0of\u00a0preimage\u00a0to Mary\nMary creates a hodl invoice\u00a0invoice0\u00a0with\u00a0hash. The amount of the invoice includes the cost of shipment as quoted to Mary by Courier Charlie. Paul pays\u00a0invoice0, but Mary cannot yet settle it because\u00a0preimage\u00a0is still unknown to Mary.\n\n2. Merchant Mary now sends\u00a0hash\u00a0to Charlie and Charlie creates another hodl invoice\u00a0invoice1\u00a0(for the delivery costs). Mary pays it and gives the physical package to Charlie.\n\n3. Charlie now has the package and delivers it to Paul.\n\n4. Upon delivery, Paul gives\u00a0preimage\u00a0to Charlie who now can use it to settle his outstanding invoice (invoice1) with Mary, thereby revealing\u00a0preimage\u00a0to Mary who then settles her outstanding\u00a0invoice0\u00a0with Paul.\n\nTaking the above, allowing it to be multi-hop (multiple Couriers) and blinding the physical location from one hop to the next, is non-trivial but seems doable. Some of you may have thought a lot more about these types of of protocols (digital-meets-physical-world) already, so please chime in!\n\nWarm Regards,\n-VzxPLnHqr\n[1]\u00a0https://wiki.ion.radar.tech/tech/research/hodl-invoice\u00a0(though, I think first proposed by Joost?)\n-- \n Sent with Tutanota, the secure & ad-free mailbox: \n https://tutanota.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210625/2c24ce70/attachment.html>"
            },
            {
                "author": "vzxplnhqr at tutanota.com",
                "date": "2021-06-25T18:34:56",
                "message_text_only": "Sorry for the double mailing. My mail client may have messed up the link to the repo. It is here:\u00a0https://github.com/VzxPLnHqr/discreet-physical-delivery-protocol\n\nJun 25, 2021, 18:05 by vzxplnhqr at tutanota.com:\n\n>\n> Dear Lightning-dev,\n>\n> I would like to share some initial research and ask for some feedback. > https://github.com/VzxPLnHqr/discreet-physical-delivery-protocol> \u00a0is a repository to gather some thoughts around how it might be possible to utilize some of the current features (hodl invoices), and/or forthcoming features (payment points? dlcs?) of lightning to create a robust, reasonably private, and incentive-compatible network for physical delivery of items.\n>\n> There has been mention of using hodl invoices for atomic item delivery[1]. However, I seem to remember reading that, essentially, hodl invoices (e.g. invoices which may not settle for quite some time, if ever) are also the primary culprit for some attacks on the network?\n>\n> Does lightning in a post-taproot world solve any of these issues?\n>\n> There is some motivation given in the readme for why such a protocol may be desirable, but as quick refresher for those reading who may not be familiar with how lightning and hodl invoices can be used for atomic package delivery:\n>\n> 0. Merchant Mary operates an e-commerce website and Purchaser Paul would like to buy something and have it delivered. For initial simplicity, assume that both Paul and Mary have a relationship with Charlie, an independent Courier (e.g. neither Paul nor Mary is playing the role of Charlie, but Charlie knows the geographical locations of both).\n>\n> 1. During checkout, Paul generates preimage\u00a0and sends\u00a0hash\u00a0of\u00a0preimage\u00a0to Mary\n> Mary creates a hodl invoice\u00a0invoice0\u00a0with\u00a0hash. The amount of the invoice includes the cost of shipment as quoted to Mary by Courier Charlie. Paul pays\u00a0invoice0, but Mary cannot yet settle it because\u00a0preimage\u00a0is still unknown to Mary.\n>\n> 2. Merchant Mary now sends\u00a0hash\u00a0to Charlie and Charlie creates another hodl invoice\u00a0invoice1\u00a0(for the delivery costs). Mary pays it and gives the physical package to Charlie.\n>\n> 3. Charlie now has the package and delivers it to Paul.\n>\n> 4. Upon delivery, Paul gives\u00a0preimage\u00a0to Charlie who now can use it to settle his outstanding invoice (invoice1) with Mary, thereby revealing\u00a0preimage\u00a0to Mary who then settles her outstanding\u00a0invoice0\u00a0with Paul.\n>\n> Taking the above, allowing it to be multi-hop (multiple Couriers) and blinding the physical location from one hop to the next, is non-trivial but seems doable. Some of you may have thought a lot more about these types of of protocols (digital-meets-physical-world) already, so please chime in!\n>\n> Warm Regards,\n> -VzxPLnHqr\n>\n> [1]\u00a0> https://wiki.ion.radar.tech/tech/research/hodl-invoice> \u00a0(though, I think first proposed by Joost?)\n> -- \n> Sent with Tutanota, the secure & ad-free mailbox: \n> https://tutanota.com\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-27T05:03:18",
                "message_text_only": "Good morning VzxPLnHqr,\n\nThis certainly seems workable.\n\nI first encountered similar ideas when people were asking about how to implement a vending machine with Lightning, with the vending machine being offline and not having any keys.\n\nThe idea was to have the vending machine record pregenerated invoices with their hashes.\nThen a separate online machine (disconnected from the vending machine) would operate a LN node and receive the payment, releasing the preimage.\nThe payer would then enter the preimage into the vending machine, which would validate it and release the item being vended.\n\nUnder your framework, the vending machine operates as the Courier, except it has a fixed geographical location and the Paul goes to the Courier (vending machine) to get their item.\n\nRegards,\nZmnSCPxj\n\n> Dear Lightning-dev,\n>\n> I would like to share some initial research and ask for some feedback. https://github.com/VzxPLnHqr/discreet-physical-delivery-protocol\u00a0is a repository to gather some thoughts around how it might be possible to utilize some of the current features (hodl invoices), and/or forthcoming features (payment points? dlcs?) of lightning to create a robust, reasonably private, and incentive-compatible network for physical delivery of items.\n>\n> There has been mention of using hodl invoices for atomic item delivery[1]. However, I seem to remember reading that, essentially, hodl invoices (e.g. invoices which may not settle for quite some time, if ever) are also the primary culprit for some attacks on the network?\n>\n> Does lightning in a post-taproot world solve any of these issues?\n>\n> There is some motivation given in the readme for why such a protocol may be desirable, but as quick refresher for those reading who may not be familiar with how lightning and hodl invoices can be used for atomic package delivery:\n>\n> 0. Merchant Mary operates an e-commerce website and Purchaser Paul would like to buy something and have it delivered. For initial simplicity, assume that both Paul and Mary have a relationship with Charlie, an independent Courier (e.g. neither Paul nor Mary is playing the role of Charlie, but Charlie knows the geographical locations of both).\n>\n> 1. During checkout, Paul generates preimage\u00a0and sends\u00a0hash\u00a0of\u00a0preimage\u00a0to Mary\n> Mary creates a hodl invoice\u00a0invoice0\u00a0with\u00a0hash. The amount of the invoice includes the cost of shipment as quoted to Mary by Courier Charlie. Paul pays\u00a0invoice0, but Mary cannot yet settle it because\u00a0preimage\u00a0is still unknown to Mary.\n>\n> 2. Merchant Mary now sends\u00a0hash\u00a0to Charlie and Charlie creates another hodl invoice\u00a0invoice1\u00a0(for the delivery costs). Mary pays it and gives the physical package to Charlie.\n>\n> 3. Charlie now has the package and delivers it to Paul.\n>\n> 4. Upon delivery, Paul gives\u00a0preimage\u00a0to Charlie who now can use it to settle his outstanding invoice (invoice1) with Mary, thereby revealing\u00a0preimage\u00a0to Mary who then settles her outstanding\u00a0invoice0\u00a0with Paul.\n>\n> Taking the above, allowing it to be multi-hop (multiple Couriers) and blinding the physical location from one hop to the next, is non-trivial but seems doable. Some of you may have thought a lot more about these types of of protocols (digital-meets-physical-world) already, so please chime in!\n>\n> Warm Regards,\n> -VzxPLnHqr\n>\n> [1]\u00a0https://wiki.ion.radar.tech/tech/research/hodl-invoice\u00a0(though, I think first proposed by Joost?)\n> --\n> Sent with Tutanota, the secure & ad-free mailbox:\n> https://tutanota.com"
            },
            {
                "author": "VzxPLnHqr",
                "date": "2021-06-28T23:58:47",
                "message_text_only": "Dear ZmnSCPxj,\n\nThank you for your reply. I see how the vending machine can be mapped into the Courier role. There are some questions around how to extend this to a multi-courier situation, but let us solve that problem later and further discuss the nuances of hodl-invoices. One thing that seems currently difficult to ascertain right now is how much \"time preference liquidity\" (for lack of a better term) there exists in the network. \n\nFor example, let's say the Merchant is an on-demand furniture maker, and it takes 90 days for her to produce the item. The protocol we are considering, in its current naive form as contemplated in this email thread, stacks up a sequence of hodl invoices which, at least in theory, tries to align the incentives of Merchant, Courier, Purchaser. It could, of course, go even further up/down the entire supply chain too.\n\nHowever, since the payments themselves are routed through the lightning network, and, in the example here, stuck in this hodling-pattern for up to 90 days, then any routing nodes along the way may feel they are not being fairly compensated for having their funds locked up for such time.\n\nDo I correctly understand that moving to payment points[1] instead of HTLCs can help reduce concern here by allowing each node along the route to earn a fee irrespective of whether the hodl invoice is settled or canceled?\n\nOutside of doing a large-scale test on mainnet (which could quickly become expensive and cause some unsuspecting node operators displeasure), is there any way right now for a node operator to determine the likelihood of, for example, being able to even route (e.g. receive payment but not yet be able to settle) a 90-day hodl invoice?\n\nWarm regards,\n-VzxPLnHqr\n[1]\u00a0https://suredbits.com/payment-points-part-1/\nJun 27, 2021, 05:03 by ZmnSCPxj at protonmail.com:\n\n> Good morning VzxPLnHqr,\n>\n> This certainly seems workable.\n>\n> I first encountered similar ideas when people were asking about how to implement a vending machine with Lightning, with the vending machine being offline and not having any keys.\n>\n> The idea was to have the vending machine record pregenerated invoices with their hashes.\n> Then a separate online machine (disconnected from the vending machine) would operate a LN node and receive the payment, releasing the preimage.\n> The payer would then enter the preimage into the vending machine, which would validate it and release the item being vended.\n>\n> Under your framework, the vending machine operates as the Courier, except it has a fixed geographical location and the Paul goes to the Courier (vending machine) to get their item.\n>\n> Regards,\n> ZmnSCPxj\n>\n>> Dear Lightning-dev,\n>>\n>> I would like to share some initial research and ask for some feedback. https://github.com/VzxPLnHqr/discreet-physical-delivery-protocol\u00a0is a repository to gather some thoughts around how it might be possible to utilize some of the current features (hodl invoices), and/or forthcoming features (payment points? dlcs?) of lightning to create a robust, reasonably private, and incentive-compatible network for physical delivery of items.\n>>\n>> There has been mention of using hodl invoices for atomic item delivery[1]. However, I seem to remember reading that, essentially, hodl invoices (e.g. invoices which may not settle for quite some time, if ever) are also the primary culprit for some attacks on the network?\n>>\n>> Does lightning in a post-taproot world solve any of these issues?\n>>\n>> There is some motivation given in the readme for why such a protocol may be desirable, but as quick refresher for those reading who may not be familiar with how lightning and hodl invoices can be used for atomic package delivery:\n>>\n>> 0. Merchant Mary operates an e-commerce website and Purchaser Paul would like to buy something and have it delivered. For initial simplicity, assume that both Paul and Mary have a relationship with Charlie, an independent Courier (e.g. neither Paul nor Mary is playing the role of Charlie, but Charlie knows the geographical locations of both).\n>>\n>> 1. During checkout, Paul generates preimage\u00a0and sends\u00a0hash\u00a0of\u00a0preimage\u00a0to Mary\n>> Mary creates a hodl invoice\u00a0invoice0\u00a0with\u00a0hash. The amount of the invoice includes the cost of shipment as quoted to Mary by Courier Charlie. Paul pays\u00a0invoice0, but Mary cannot yet settle it because\u00a0preimage\u00a0is still unknown to Mary.\n>>\n>> 2. Merchant Mary now sends\u00a0hash\u00a0to Charlie and Charlie creates another hodl invoice\u00a0invoice1\u00a0(for the delivery costs). Mary pays it and gives the physical package to Charlie.\n>>\n>> 3. Charlie now has the package and delivers it to Paul.\n>>\n>> 4. Upon delivery, Paul gives\u00a0preimage\u00a0to Charlie who now can use it to settle his outstanding invoice (invoice1) with Mary, thereby revealing\u00a0preimage\u00a0to Mary who then settles her outstanding\u00a0invoice0\u00a0with Paul.\n>>\n>> Taking the above, allowing it to be multi-hop (multiple Couriers) and blinding the physical location from one hop to the next, is non-trivial but seems doable. Some of you may have thought a lot more about these types of of protocols (digital-meets-physical-world) already, so please chime in!\n>>\n>> Warm Regards,\n>> -VzxPLnHqr\n>>\n>> [1]\u00a0https://wiki.ion.radar.tech/tech/research/hodl-invoice\u00a0(though, I think first proposed by Joost?)\n>> --\n>> Sent with Tutanota, the secure & ad-free mailbox:\n>> https://tutanota.com\n>>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-29T01:56:58",
                "message_text_only": "Good morning VzxPLnHqr,\n\n> Dear ZmnSCPxj,\n>\n> Thank you for your reply. I see how the vending machine can be mapped into the Courier role. There are some questions around how to extend this to a multi-courier situation, but let us solve that problem later and further discuss the nuances of hodl-invoices. One thing that seems currently difficult to ascertain right now is how much \"time preference liquidity\" (for lack of a better term) there exists in the network.\n>\n> For example, let's say the Merchant is an on-demand furniture maker, and it takes 90 days for her to produce the item. The protocol we are considering, in its current naive form as contemplated in this email thread, stacks up a sequence of hodl invoices which, at least in theory, tries to align the incentives of Merchant, Courier, Purchaser. It could, of course, go even further up/down the entire supply chain too.\n>\n> However, since the payments themselves are routed through the lightning network, and, in the example here, stuck in this hodling-pattern for up to 90 days, then any routing nodes along the way may feel they are not being fairly compensated for having their funds locked up for such time.\n>\n> Do I correctly understand that moving to payment points[1] instead of HTLCs can help reduce concern here by allowing each node along the route to earn a fee irrespective of whether the hodl invoice is settled or canceled?\n\nThis does not need payment points.\n\n*However*, this hodl-payment-problem has multiple proposed solutions (none of which *require* payment points, but should still be compatible with them), none of which have gained much support, since all of them kind of suck in one way or another.\n\nPayment points do allow for certain escrows to be created in a low-trust way, but they still involve holding PTLCs for long periods of time, and locking up funds until the escrow conditions are satisfied.\nNote that one may consider the hodl-invoice as a sort of escrow, and thus the generalized escrow services that are proposed in that series of blog posts is a strict superset of that, but they still involve PTLCs being unclaimed for long periods of time.\n\n>\n> Outside of doing a large-scale test on mainnet (which could quickly become expensive and cause some unsuspecting node operators displeasure), is there any way right now for a node operator to determine the likelihood of, for example, being able to even route (e.g. receive payment but not yet be able to settle) a 90-day hodl invoice?\n\n0, since I think most implementations impose a maximum limit on the timelocks HTLCs passing through them, which is far lower than 90 days.\nThough I should probably go check the code, haha.\n\n--\n\nI think the issue here is the just-in-time nature of the Merchant in your example.\n\nConsider an ahead-of-time furniture maker instead.\nThe furniture maker can, like the vending machine example, simply consign furniture to a Vendor.\nThe Vendor simply releases the already-built furniture conditional on receiving the payment secret (i.e. proof-of-payment) of an invoice issued by the Merchant.\n\nThe payment secret could then use the payment point homomorphism.\nThe Vendor acts as a Retailer, buying furniture at reduced prices, in bulk, from the Merchant.\nBecause it buys in bulk, the Retailer+Merchant can probably afford to use a hodl PTLC directly onchain, instead of over Lightning, since they makes fewer but larger transactions, buying in bulk.\n\nOn the other hand, this reduces flexibility --- end consumers can only choose among pre-built furniture, and cannot customize.\nBuying the flexibility that just-in-time gives requires us to pay with some deep thinking over here in Lightning-land on how to implement this without sucking.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "complementing lightning with with a discreet physical delivery protocol?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "VzxPLnHqr",
                "vzxplnhqr at tutanota.com",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 18310
        }
    },
    {
        "title": "[Lightning-dev] Lightning Mints",
        "thread_messages": [
            {
                "author": "Casey Rodarmor",
                "date": "2021-06-28T01:45:42",
                "message_text_only": "Dear Lightning Devs,\n\nChaumian mints, or blind mints, are a potentially interesting way to make\nhosted lightning wallets more private and secure, and I recently wrote a blog\npost on the topic that I wanted to share with the list:\n\nhttps://rodarmor.com/blog/lightning-mints/\n\nIt is also reproduced below for convenience.\n\nSelf-hosted Lightning wallets present distinct usability challenges not present\nin on-chain wallets, such as channel and liquidity management, which may make\nhosted wallets a popular option. Given that, I think the problem of making\nthese wallets more private and secure deserves attention, and blind mints may\nprovide nice solutions to these problems.\n\nAnother site of interest is fedimint.org, which has some additional information\non blind mints in the context of Bitcoin and Lightning.\n\nBest regards,\nCasey Rodarmor\n\n---\n\nFederated blind mints have attractive privacy, scaling, and security properties\nthat are highly complementary to those of Bitcoin and the Lightning Network.\n\nI originally became interested in blind mints while thinking about Lightning\nNetwork wallet usability issues. When Lightning works, it is fantastic, but\nkeeping a node running and managing a wallet present a number of challenges,\nsuch as channel unavailability due to force closes, the unpredictability of the\non-chain fee environment, the complexity of channel backup, and the involved\nand often subtle need to manage liquidity.\n\nAll of these problems *are* tractable for a skilled node operator, but may not\nbe soluble in the context of self-hosted wallets operated by non-technical\nusers, hereafter *normies*. If this is the case, then normies may have no\nchoice but to use hosted Lightning wallets, compromising their privacy and\nexposing them to custodial risk.\n\nChaumian mints, also known as Chaumian banks, or blind mints, offer a\ncompelling solution to these problems, particularly when operation is\nfederated. Chaumian mints, through the use of blind signatures[0], have\nextremely appealing privacy properties. The mint operators do not know the\nnumber of users, their identities, account balances, or transaction histories.\nAdditionally, mint transactions are cheap and can be performed at unlimited\nscale.\n\nMint implementations, typified by eCash[1], have hitherto been centralized, and\nthus, like all centralized, custodial services, expose users to custodial risk\nin the form of operator absquatulation and mismanagement. To fix this, mint\noperation can be federated, with all operations performed by a quorum of nodes\ncontrolled by different parties.\n\nDespite these interesting properties, Chaumian mints have largely been\nforgotten. This post[2] gives an excellent overview of the phenomenon. I\nbelieve that Chaumian mints are currently severely underrated in general, and\nin particular deserve consideration as a potential avenue for improving\ncustodial Lightning Network wallets.\n\nCompared to a na\u00efve hosted Lightning Network wallet, a service operated as a\nfederated Chaumian mint offers excellent privacy, usability, security, and\nscaling.\n\n**Privacy:** Privacy leaks from a Lightning mint come in two forms, *internal*\nand *external*, when an mint operator or an outside actor, respectively,\nobserves sensitive information.\n\nBlind signatures protect against internal privacy leaks, making them a strict\nimprovement in that respect over custodial Lightning wallets.\n\nWhen compared to a single-user Lightning network wallet, Lightning mints also\nprotect against external privacy leaks. If the activity of a single-user\nLightning Network wallet can be observed, which is possible but non-trivial,\nall such activity is preemptively that of the owner of the wallet. However,\nsimilar to a standard custodial Lightning Network wallet, any observable\nLightning Network activity of a Lightning mint is the aggregate activity of its\nusers, who thus form an anonymity set. If the number of users, and thus the\nanonymity set size, is large, external privacy leaks are also prevented.\n\n**Usability:** Compared to a self-managed Lightning Network wallet, and similar\nto a standard custodial Lightning Network wallet, Lightning mint wallets offer\nsuperior usability. A user need not be concerned with the details of node\noperation or channel management, and can deposit to and withdraw from their\naccount with standard Lightning Network invoices.\n\n**Security:** The security of a Lightning mint is weaker than that of a\nself-hosted wallet. A quorum of federation members can abscond with funds.\nHowever, compared to a standard custodial Lightning Network wallet, security is\ngreatly improved. Additionally, federations members might be located in\ndifferent jurisdictions, making the mint robust to regulatory interference.\nFurthermore, members might be entities with online reputations, such as\nanonymous Bitcoin Twitter users with an established history of productive\nshitposting, providing further assurances against mismanagement and fraud.\n\n**Scaling:** Mint operations are extremely lightweight, similar to Lightning\nNetwork transactions, so scaling properties are similar to the Lightning\nNetwork itself.  Additionally, users need not manage their own channels, so a\nwell-capitalized federation can open channels efficiently, lowering the\nper-transaction channel management overhead.\n\n**Interoperability and market dynamics:** Additionally, my hope is that such\nsystems will be developed with a standardized protocol for communication\nbetween wallet interfaces and mint backends. This would allow users to use\ndifferent backends the same local wallet interface, encouraging competition in\nthe market.\n\nFor more discussion of Chaumian mints and their applicability to Bitcoin, see\nfedimint.org[3]. Elsirion, the author, is also at work on MiniMint, a federated\nChaumian mint with Bitcoin and eventually Lightning Network support.\n\nTo close with a bit of speculation, I believe that Chaumian mints were never of\nparticular interest of importance because they were limited to interoperating\nwith the fiat currencies of the time. With the ascendance of Bitcoin, mints now\nhave access to a powerful, decentralized, and uncensorable currency , made\neconomical and fast by the Lightning Network.\n\nI believe this layering of Chaumian mints on top of Bitcoin and the Lightning\nNetwork will, in the fullness of time, be demonstrated to be enormously\npowerful, and make Chaumian mints themselves worthy of renewed study and\nconsideration.\n\n[0] https://en.wikipedia.org/wiki/Blind_signature\n[1] https://en.wikipedia.org/wiki/Ecash\n[2] https://opaque.link/post/digitalmoneydbc/\n[3] https://fedimint.org"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-28T05:40:28",
                "message_text_only": "Good morning Casey,\n\nI believe a major failing of Chaumian mints is that they are, at their core, inherently custodial.\nThe mint issues blinded minted coins in exchaange for people handing over other resources to their custody.\nWhile the mint itself cannot identify who owns how much, it can outright deny all its clients access to their funds and then run off with the money to places unknown.\n\nHowever, do note that both Wasabi and WabiSabi are extensions of Chaumian mints.\nThese avoid the custodiality issue of Chaumian mints by operating the mint as a temporary entity, whose output is then counterchecked by the users of the Wasabi/WabiSabi scheme.\n\n\nI think a lot of problems are very easy if we go with custodiality; it is the variant rule of non-custodiality that makes this field interesting in the first place.\n\nFidelity bonds are hard since the bond has to be at least the value of the funds being managed (otherwise the mint can still sacrifice the bond to run off with the funds being managed; it would still earn more than what it lost).\nThat means, at best, locking up to twice the managed amount (i.e. locking it in a channel, *and* locking a similar amount in a separate fidelity bond).\n\n\nIn any case, you might also be interested in the \"nodelets\" I described some years ago.\nThis link has a presentation where I introduce nodelets towards the end, sorry but most of the beginning is about LN pathfinding (which is currently a non-problem since nobody makes published channels anymore).\nThis allows multiple users to implement a single node without a central custodian, and may allow for similar flexibility of liquidity if there are enough users, but every action requires all users to have keys online.\n\n\n> I originally became interested in blind mints while thinking about Lightning\n> Network wallet usability issues. When Lightning works, it is fantastic, but\n> keeping a node running and managing a wallet present a number of challenges,\n> such as channel unavailability due to force closes, the unpredictability of the\n> on-chain fee environment, the complexity of channel backup, and the involved\n> and often subtle need to manage liquidity.\n>\n> All of these problems *are* tractable for a skilled node operator, but may not\n> be soluble in the context of self-hosted wallets operated by non-technical\n> users, hereafter *normies*. If this is the case, then normies may have no\n> choice but to use hosted Lightning wallets, compromising their privacy and\n> exposing them to custodial risk.\n\nOne of my projects is CLBOSS, which manages a C-Lightning node for you.\n\n* https://github.com/ZmnSCPxj/clboss\n* https://lists.ozlabs.org/pipermail/c-lightning/2020-October/000197.html\n\nThe target is that at some point, the algorithms and heuristics developed for CLBOSS will be widespread and it would be trivial for a \"normie\" to run a well-managed forwarding node, they just have to keep it powered on 100% of the time, which should be easy, people keep their refrigerators powered on 100% of the time, after all.\n\nI am actually kind of puzzled that nobody else seems to be building node managers, everyone just focuses on peer selection, but ignores stuff like channel feerates, closing heuristics, liquidity monitoring, etc.....\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-28T15:20:43",
                "message_text_only": "Good morning again CAsey,\n\n>\n> I believe a major failing of Chaumian mints is that they are, at their core, inherently custodial.\n> The mint issues blinded minted coins in exchaange for people handing over other resources to their custody.\n> While the mint itself cannot identify who owns how much, it can outright deny all its clients access to their funds and then run off with the money to places unknown.\n>\n> However, do note that both Wasabi and WabiSabi are extensions of Chaumian mints.\n> These avoid the custodiality issue of Chaumian mints by operating the mint as a temporary entity, whose output is then counterchecked by the users of the Wasabi/WabiSabi scheme.\n>\n> ...\n>\n> In any case, you might also be interested in the \"nodelets\" I described some years ago.\n> This link has a presentation where I introduce nodelets towards the end, sorry but most of the beginning is about LN pathfinding (which is currently a non-problem since nobody makes published channels anymore).\n> This allows multiple users to implement a single node without a central custodian, and may allow for similar flexibility of liquidity if there are enough users, but every action requires all users to have keys online.\n\n\nThinking more, it helps to consider how Wasabi and WabiSabi are constructed.\n\nIn Wasabi, there exists a coordinator, which is a server that works as a temporary Chaumian mint.\nClients of the coordinator register some UTXOs of some common value to the mint (indicating any change outputs if the UTXO total value exceeds the fixed common value).\nThen the coordinator issues blind signatures, which serve as tokens in a Chaumian mint.\nThen users re-connect via a different pseudonym, unblind signatures and reclaim the funds, indicating a target output address.\nThe coordinator then creates a single transaction that consumes the registered input UTXOs and the indicated outputs.\n\nAs a *final* step, the clients then check that the produced transaction is correct.\nThis final step prevents the coordinator from absconding with the funds.\n\nWabiSabi \"simply\" replaces blinded signatures with blinded credentials.\nBlinded signatures are fairly low-bandwidth ---- either you have a blinded signature, or you do not.\nCredentials, however, also include a blinded homomorphic value.\nOn issuing, the issuer can ensure that a particular value is encoded, then when the credential is blinded by the receiver, and the issuer can ensure that multiple credentials can be presented which sum up to a newly issued credential, with the value being correctly added.\nThus, I think for a modern Chaumian mint, you should really consider the credentials scheme used by WabiSabi.\n\n--\n\nNow, let us consider the \"nodelets\" idea as well.\nThe \"nodelets\" system allows for a coordinator (which can be a separate entity, or, for the reduction of needed entities, any nodelet of the node).\n\nThis coordinator in nodelets is simply a way to implement a broadcast medium among all the nodelets in a node.\nHowever, the same coordinator in a nodelets system can also serve as a coordinator in something very much like a WabiSabi system.\n\nSo it seems to me that this can be implemented in a way that is non-custodial, as long as we can actually implement nodelets.\n(which \"just\" requires that we use a multiparticipant signing scheme for Schnorr signatures that is composable.)\n\nBasically, just as in the WabiSabi case, nodelets can connect to the coordinator, register some of the values they have in channels, then get back some equivalent credentials.\nThen the nodelets can \"self-mix\" their coins, then get back a new set of values, then request that some part of their value be sent over the network.\nThen, before signing off on the new state of any channel, the actual nodelets check the new state that the coordinator wants them to sign off on, thus preventing custodial risk in the same manner as Waasabi/WabiSabi does.\n\nThus, each state update of the channel is created by a Chaumian mint (using credentials instead of blinded signatures), then the state update is \"ratified\" by the actual nodelets, preventing the Chaumian mint from stealing the funds; new states are simply not signed (and presumably one or more of the nodelets will drop the previous valid state onchain, which allows them to recover funds without loss) until all nodelets can confirm that the coordinator has not stolen anything.\n\n\nNodelets can use pseudonyms in between states of channels, to reduce the ability of the coordinator, or the other nodelets, to guess who owns how much.\n\n\nAn issue however is how to handle forwarding.\nForwarding is an important privacy technique.\nIf you are a forwarder, you can plausibly claim that an outgoing HTLC is not from your own funds, but instead was a forward.\nBy supporting forwarding, the nodelets composing the node can reduce the ability of non-participants to determine the payments of the node.\n\nHandling forwarding in such a system requires that nodelets be willing to leak that they have funds in the outgoing channel, in exchange for getting some earned forwarding fees.\n\n\nSo it seems to me that this is plausible with nodelets.\n\nIn addition, ti seems to me that the node management problem can be solved in software, by something similar in purpose to CLBOSS.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "elsirion",
                "date": "2021-06-29T12:22:00",
                "message_text_only": "Hi ZmnSCPxj,\n\nlet me chime in here, I've been working on federated mint for quite some time now but only recently began talking about it more publicly.\n\n> WabiSabi \"simply\" replaces blinded signatures with blinded credentials.\n> Blinded signatures are fairly low-bandwidth ---- either you have a blinded signature, or you do not.\n> Credentials, however, also include a blinded homomorphic value.\n\nThis is a very intriguing idea Casey actually mentioned to me (at least I think it's about the same problem):\n\nIn traditional mints we use tokens of the same denomination. For efficiency reasons amount tiers are introduced, reducing the anonymity set per tier. If we had blind signatures not only on random tokens but they also committed to a separately blinded amount with a range proof that would allow one big anonymity set over all tokens instead. Such tokens could then be combined similarly to Liquid transaction inputs.\n\nI think the concept is very interesting, but for now I see a few obstacles:\n\n* WabiSabi uses KVACs which afaik do not allow client side validation. While I can't say if it will be a big problem it makes detecting certain failure scenarios harder imo.\n* The KVAC scheme referred to in WabiSabi [1] is not a threshold scheme afaik, undermining the central premise of federated mints. If I got that wrong this would be awesome!\n* Building such an enhanced threshold blind signature scheme is more complex and probably needs further research. A naive implementation would be more interactive which in a federated context means waiting for consensus rounds for each round trip which is unappealing.\n\nSo while I'm very sympathetic to the idea and want to pursue it in the future, threshold blind signatures seem like the more efficient way to get to a working implementation with still adequate performance and privacy in time.\n\n\n> Now, let us consider the \"nodelets\" idea as well.\n> The \"nodelets\" system allows for a coordinator (which can be a separate entity, or, for the reduction of needed entities, any nodelet of the node).\n\nI didn't know of nodelets so far and went back to your 2019 post about it. It seems that blind multisig or threshold credentials (the idea seems to be m-of-m, so doesn't nee a general threshold scheme I guess) would improve the privacy of the system. I think the nodelets idea is very interesting for technical people that would otherwise be priced out of running a LN node in a high-fee future. But the complexity of the protocol and online requirements seem to make it suboptimal for non-technical, disinterested users. While automating a lot of the complexity away is possible (big fan of clboss) it's also a lot of work and probably will take a while if ever to get to a point where the experience is plug-and-play as most non-technical users have come to expect.\n\nIn that sense both systems just have different target audiences. I think of federated mints mostly as a replacement for Banks and other custodial services that are used for their superior UX. It is fundamentally a compromise. E.g. Bitcoin Beach currently uses Galoy [2], a centralized hosted LN wallet without much privacy. I don't see a future where everyone there is technical enough to run their own node or nodelet client reliably enough. But if we can allow community driven federations with privacy built-in we can mitigate most of the risks inherent to custodial wallets imo.\n\nI really hope that I'm too pessimistic here, but if not I'd rather have a backup plan in the form of federated mints than letting banks eat our lunch. The idea is still early, but I hope some can agree with my reasoning. If so, come and help build this future with me [3]!\n\nRegards,\nelsirion\n\n[1] https://eprint.iacr.org/2019/1416\n[2] https://github.com/GaloyMoney/galoy\n[3] https://fedimint.org/\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: publickey - elsirion at protonmail.com - 0xB3CDFF6F.asc\nType: application/pgp-keys\nSize: 3270 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210629/de82471d/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 855 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210629/de82471d/attachment.sig>"
            },
            {
                "author": "Yuval Kogman",
                "date": "2021-06-29T13:12:01",
                "message_text_only": "Hi,\n\n> * WabiSabi uses KVACs which afaik do not allow client side validation. While I can't say if it will be a big problem it makes detecting certain failure scenarios harder imo.\n> * The KVAC scheme referred to in WabiSabi [1] is not a threshold scheme afaik, undermining the central premise of federated mints. If I got that wrong this would be awesome!\n\nCorrect on both counts. Furthermore, WabiSabi is deliberately designed\nfor short lived credentials, since the entire nullifier set can be\ndiscarded once a CoinJoin round terminates (successfully or\nunsuccessfully). For longer lived tokens a generational/epoch based\napproach is likely to be more practical.\n\nAlternative credential schemes can be applied in a similar way, with\nfairly minor differences in how attribute commitments are handled\n(e.g. in the balance proofs)\n\n- The ACL scheme[1] is publicly verifiable, but still relies on a\nsingle issuer. see [2] for a wallet based on thereof, as well as the\ncited works for some variations which rely on more general zero\nknowledge proofs.\n- The Coconut scheme [3] provides threshold issuance. I have not\nstudied this scheme in detail, but IIRC it only supports scalar\nattributes (as opposed the KVACs used in WabiSabi, which also support\ngroup elements. See also Danake [4] which relies on scalar attributes\nonly and uses epoch schemes.\n\nAnother related project is zkChannels (formerly and confusingly known\nas BOLT) [5], the website hints at dropping the requirement for a new\nopcode but no details appear to be available on the website yet.\n\n[1] https://cs.brown.edu/people/fbaldimt/papers/CCS13.pdf\n[2] https://eprint.iacr.org/2020/382.pdf\n[3] https://arxiv.org/pdf/1802.07344.pdf\n[4] https://lightweight.money\n[5] https://boltlabs.tech/research"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-29T13:23:05",
                "message_text_only": "Good morning elsirion,\n\n\n> Hi ZmnSCPxj,\n>\n> let me chime in here, I've been working on federated mint for quite some time now but only recently began talking about it more publicly.\n>\n> > WabiSabi \"simply\" replaces blinded signatures with blinded credentials.\n> > Blinded signatures are fairly low-bandwidth ---- either you have a blinded signature, or you do not.\n> > Credentials, however, also include a blinded homomorphic value.\n>\n> This is a very intriguing idea Casey actually mentioned to me (at least I think it's about the same problem):\n>\n> In traditional mints we use tokens of the same denomination. For efficiency reasons amount tiers are introduced, reducing the anonymity set per tier. If we had blind signatures not only on random tokens but they also committed to a separately blinded amount with a range proof that would allow one big anonymity set over all tokens instead. Such tokens could then be combined similarly to Liquid transaction inputs.\n>\n> I think the concept is very interesting, but for now I see a few obstacles:\n>\n> -   WabiSabi uses KVACs which afaik do not allow client side validation. While I can't say if it will be a big problem it makes detecting certain failure scenarios harder imo.\n> -   The KVAC scheme referred to in WabiSabi [1] is not a threshold scheme afaik, undermining the central premise of federated mints. If I got that wrong this would be awesome!\n> -   Building such an enhanced threshold blind signature scheme is more complex and probably needs further research. A naive implementation would be more interactive which in a federated context means waiting for consensus rounds for each round trip which is unappealing.\n\nWell, WabiSabi is effectively n-of-n signing, as the produced transaction has to be signed by all clients of the coordinator, so threshold federated signatures are not necessary.\nSo yes, the use of credentials seems not possible to the federated mints project.\n(note: I am not a mathist and have no idea what the hell credentials are, I only know how to use them)\n\n>\n>     So while I'm very sympathetic to the idea and want to pursue it in the future, threshold blind signatures seem like the more efficient way to get to a working implementation with still adequate performance and privacy in time.\n>\n>\n> > Now, let us consider the \"nodelets\" idea as well.\n> > The \"nodelets\" system allows for a coordinator (which can be a separate entity, or, for the reduction of needed entities, any nodelet of the node).\n>\n> I didn't know of nodelets so far and went back to your 2019 post about it. It seems that blind multisig or threshold credentials (the idea seems to be m-of-m, so doesn't nee a general threshold scheme I guess) would improve the privacy of the system. I think the nodelets idea is very interesting for technical people that would otherwise be priced out of running a LN node in a high-fee future. But the complexity of the protocol and online requirements seem to make it suboptimal for non-technical, disinterested users. While automating a lot of the complexity away is possible (big fan of clboss) it's also a lot of work and probably will take a while if ever to get to a point where the experience is plug-and-play as most non-technical users have come to expect.\n>\n> In that sense both systems just have different target audiences. I think of federated mints mostly as a replacement for Banks and other custodial services that are used for their superior UX. It is fundamentally a compromise. E.g. Bitcoin Beach currently uses Galoy [2], a centralized hosted LN wallet without much privacy. I don't see a future where everyone there is technical enough to run their own node or nodelet client reliably enough. But if we can allow community driven federations with privacy built-in we can mitigate most of the risks inherent to custodial wallets imo.\n\n>From my PoV, any \"bank-replacement\" that is inherently custodial will eventually become a bank, with all the problems that implies.\n\nIt is helpful to remember that banks have, historically, been federations: they are typically implemented as corporations, which are basically a bunch of people pooling their money and skill together to start a business.\nThus, I argue that banks already *are* federations that take custody of your money and manage it for you.\n\nTo my mind, any system that is a federation that takes custody of user money *will* face the same social, political, and economic forces that the legacy banking system faced in the past.\nYou puny humans simply do not evolve as fast as you think, you know --- your instincts still demand that your body stock up on fat and salt and sugar in a modern era where such things are available in too much abundance that it is killing you, so I imagine that a modern federated system (like Liquid or your federated mints) will face similar forces as past successful financial custodial federations (i.e. the banks of today).\n\nThus, it seems to me that with high probability, any custodial federated financial system will evolve to a similar state as banks today --- that is, cryptocurrency systems based on custodial federations will just \"kick the can\", and eventually be the same (with the same pros and cons) as modern banks.\n\nThis is not completely negative, since modern banks do provide vital services, but at the same time, one can argue that this is uninteresting in terms of exploration --- i.e. federated custodians have already been done before, they are the banks of today.\nThat is why CLBOSS exists --- it manages your money for you, but you run it on your own hardware and are responsible for auditing it, so it does *not* take control of your funds.\n\n>\n> I really hope that I'm too pessimistic here, but if not I'd rather have a backup plan in the form of federated mints than letting banks eat our lunch. The idea is still early, but I hope some can agree with my reasoning. If so, come and help build this future with me [3]!\n\nWell, I agree that kicking the can down the road is better as a backup plan than not having anything in case we really cannot find a reasonable way to make Bitcoin cheap and easy without losing noncustodiality.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Casey Rodarmor",
                "date": "2021-06-30T01:05:41",
                "message_text_only": "Good afternoon ZmnSCPxj,\n\nThank you for your thoughtful reply! I agree with many of your points.\nOne thing I wanted to say regarding the forces that act on banks:\n\n> It is helpful to remember that banks have, historically, been federations: they are typically implemented as corporations, which are basically a bunch of people pooling their money and skill together to start a business.\n> Thus, I argue that banks already *are* federations that take custody of your money and manage it for you.\n>\n> To my mind, any system that is a federation that takes custody of user money *will* face the same social, political, and economic forces that the legacy banking system faced in the past.\n\nI actually think that banks operating on top of bitcoin may be subject\nto different forces. A major factor in the misbehavior of legacy banks\nhas been lack of competition due to artificial barriers to entry due\nto regulation. I think in the absence of regulation, with competitors\nbeing able to enter the market at little cost, and without needing a\nlicense, we would see much less bad behavior from banks. I don't think\nthat, aside from regulation, there is anything inherent to the\nbusiness of banking that makes banks behave badly. If federated\nchaumian banks that interface exclusively with the Bitcoin and\nLightning networks are able to evade regulators, the market for such\nbanking services will hopefully see healthy competition between\nparticipants. This would be enhanced by the fact that such banks would\nbe able to serve a global audience, and not be closely tied to a\ncountry, national currency, legacy settlement network, or region.\n\n> In addition, ti seems to me that the node management problem can be solved in software, by something similar in purpose to CLBOSS.\n\nI think projects like CLBOSS are great, but I share elsirion's\npessimism that LN node UX not be a fully soluble problem, no matter\nhow good management software gets. Users will be choosing between\nservices like Wallet of Satoshi, which are completely seamless, and it\nmight not be possible for management software to fully abstract over\nthings like high fees, uptime requirements, and unexpected fund\nunavailability due to channel closure.\n\nBest regards,\nCasey"
            }
        ],
        "thread_summary": {
            "title": "Lightning Mints",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Yuval Kogman",
                "Casey Rodarmor",
                "elsirion",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 29716
        }
    },
    {
        "title": "[Lightning-dev] Interactive tx construction and UTXO privacy, some thoughts",
        "thread_messages": [
            {
                "author": "lisa neigut",
                "date": "2021-06-29T02:21:58",
                "message_text_only": "Hey all,\n\nThe dual-funding proposal has been up for a while now, and while we've had\nsome really great reviews from a few people (@ariard + @rustyrussell thanks\nfor\nyour comments in particular).\n\nAs a refresher, the PR is available here:\nhttps://github.com/lightningnetwork/lightning-rfc/pull/851.\n\nI wanted to make a quick summary of some of the biggest objections to\nthe protocol. Most of these were made during the course of the 2018 spec\nmeeting in Adelaide and while we've done a decent job of architecting\naround them,\nI wanted to make them explicit.\n\nIf there's more to add, please do.\n\n## Point One\nOne: dual-funding (really the collaborative transaction protocol) requires\nyou to share your UTXO set with the channel peer.\n\nThis is true, in a 'limited' sense, where 'UTXO set' is actually constricted\nto 'UTXOs you're using for funding transactions'.\n\nOn the face of it, this seems to be quite concerning to folks.  Here's a\nfew things\nthat I think make this less concerning than it might appear at the outset.\n\nFirst, let's consider the current opening case. You (or your channel peer)\nconstructs a transaction and shares the TXID and outpoint that the funding\noutput can be found at. This transaction is published and mined,\nafter the transaction is at sufficient depth a gossip announcement\nis broadcast to the entire network, explaining where the transaction can be\nfound.\n\nUnder the current protocol, it's reasonable\\* to conclude that\nevery UTXO in the funding transaction belongs to a single party, the opener.\n\nAssuming that all the UTXOs in your wallet will, at some point, end up\nin a lightning channel, all of your UTXOs will be *publicly* associated with\nyour node at some point (in the current model). Your UTXO set is only\nprivate in the present, given a long enough time period (and channel opens)\nthey will all be tied to your node.\n\nFor this reason, it's probably not a great idea to fund wallets using a\nseparate wallet that hasn't been coinjoined or otherwise obfuscated. In\nfact, I think you can make a fairly decent argument (under the existing UTXO\nmodel) for not mixing lightning funds with any funds you wish to remain\ntruly\nprivate/unassociated to an 'entity'.\n\nGiven that you're currently telling everyone what UTXOs your node owns\n(or at least has a 50/50 chance of owning..) let's consider the interactive\ntransaction protocol.\nAssuming a 2-party dual-funded open, as an outside observer it's much more\ndifficult to tell which\nUTXOs belong to who (though you can probably guess given input amounts and\nchange outputs; maybe a good heuristic for opens is to use whole UTXOs).\n\nIn this on-chain respect, the dual-funding protocol is no worse, and in the\nbest case much\nbetter for on-chain coin-analysis heuristics than the current protocol.\n\n\\* There are a few clear exceptions where other protocols (such as Pool,\niiuc)\nhave been developed that make this heuristic bunk as they *also* build a\nmulti-party\ntransaction, however afaik all of these other protocols (joinmmarket, pool)\nstill require sharing\nyour UTXOs with another (trusted) party, difference is you know in theory\nwhere \"the Pool\nauctioneer\" lives, whereas you don't really know much about \"any random\nnode that wants to open\na channel\". Seems like there might be some room in this space for better\ninformation\nabout prospective channel peers...\n\n## Point Two\nTwo: an active prober can use the interactive transaction protocol to\ndiscover your wallet's entire UTXO set.\n\nGiven the assumption that all of your node funds will, at some point,\nbe used to open a lightning channel, a single attacker discovering a subset\nof your UTXOs is simply a 'fast-forward' of what will eventually become\npublic information.\n\nThat being said, much smarter minds (e.g. JoinMarket, which suffers from\na very similar issue in what I would argue an even more privacy-conscious\ncontext) than mine have employed the PoDLE protocol to make the discovery\nof every UTXO more costly for a potential attacker. This is something\n we can add quite trivially to the protocol, at the cost of grossly\nincreasing\nthe gossip traffic.\n\nWorth noting that even without PoDLE you can much slow this type of\nattack by reusing the same UTXO across every open attempt, being choosy\nabout which peers you do offer liquidity up to (do they have other\nestablished\nchannels? what's their uptime?) etc.\n\nA dedicated attacker could probably figure out your UTXO set, but that's not\nmuch different from the current system; the only difference is the span of\ntime\nit takes them to figure it out.\n\n## Things We've Done to Counter This:\nI had the pleasure of finally meeting Nadav of SuredBits and DLC fame in\nMiami\na few weeks ago. The DLC team has adopted a version of the interactive\ntransaction protocol for their own purposes. Nadav pointed out that the\nprotocol we landed on for lightning interactive construction transactions\nis *quite* interactive; the DLC version modified it to use batching to\ntransmit the input/output sets (the interactive protocol is one-by-one).\n\nThe rationale for doing the addition of inputs and outputs in a non-batched\nfashion is that this allows for you to interleave UTXOs from a variety\nof sources, for example multiple channel opens in the same tx. With the\ncurrent\nprotocol, you can initiate a dual-funded open with many peers at the same\ntime,\neach of which may contribute UTXOs and outputs for their own respective\nchannel opens or UTXO consolidations etc.\n\nThis gives us the real possibility of doing multiparty coinjoins on\nlightning.\nIn fact, this is currently possible with c-lightning *today* using\nthe multifundchannel command (h/t to ZmnSCPjx for the original framework\nfor multifund opens).\n\nAs written, the interactive transaction protocol is exceedingly flexible.\nWe traded off succinctness for some plausible deniablity wrt\nany UTXOs you send to any peer -- are they yours or are they\nsome third party's? How to tell?\n\nI think it's interesting to point out that \"succinctness\" in rounds\nof required interaction is typically a *highly* desirable trait for\nany cryptographic protocol. The establishment of a lightning channel\nrelationship,\nhowever, isn't a cryptographic signature. A lightning channel, by its very\nnature, is typically a highly interactive relationship between two peers.\nIncreasing the rounds of messaging required to establish the channel doesn't\nchange the overall interactivity profile of a channel's operation, thus\nadding rounds of comms to channel open is generally a no-op in terms of\nperformance/uptime requirements of a node's operations.\n\n## How important is UTXO privacy on lightning?\nObviously important. But given that the real transactions happen inside\nof channels, invisibly, and that your public channels really truly\nare public via the gossip protocol the much more important \"thing\" in the\nlightning arena isn't your UTXO privacy so much as *not* associating your\nidentity with your node.\n\n## Does Taproot fix this?\nI'm not up to date enough on the progress of Taproot scripts, however,\nassuming the current requirement that every routing node is able to\nindependently\nverify the opening output script via the signatures provided\nin the channel_announcement, it seems reasonable that on-chain transactions\nwill still be assignable to a node given gossip data. (Purely on-chain\nanalysis\nwill be stymied, however.)\n\n# In Exitus\nThere are legitimate concerns regarding sharing UTXOs with other peers\nin the process of opening a channel. The current protocol, as implemented,\nintroduces a mechanism for some plausible deniability wrt who those UTXOs\nactually belong to, as well as providing the tools for building multi-party\ncoinjoins as\nopens. Further, with PoDLEs, we can at least achieve a similar level of\nprotection\nas JoinMarket currently enjoys.\n\nFinally, regardless of what open mechanism you're using, it's worth\nreiterating\nthat best practice is to not *ever* tie your identity to your lightning\nnode.\nAnd it may be worth reconsidering what wallet source you're using to fund\nannounced channel opens.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210628/71a44fbe/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-06-29T13:03:33",
                "message_text_only": "Good morning lisa,\n\n> A dedicated attacker could probably figure out your UTXO set, but that's not\n> much different from the current system; the only difference is the span of time\n> it takes them to figure it out.\n>\n> ## Things We've Done to Counter This:\n> I had the pleasure of finally meeting Nadav of SuredBits and DLC fame in Miami\n> a few weeks ago. The DLC team has adopted a version of the interactive\n> transaction protocol for their own purposes. Nadav pointed out that the\n> protocol we landed on for lightning interactive construction transactions\n> is *quite* interactive; the DLC version modified it to use batching to\n> transmit the input/output sets (the interactive protocol is one-by-one).\n>\n> The rationale for doing the addition of inputs and outputs in a non-batched\n> fashion is that this allows for you to interleave UTXOs from a variety\n> of sources, for example multiple channel\u00a0opens in the same tx. With the current\n> protocol, you can initiate a dual-funded open with many peers at the same time,\n> each of which may contribute UTXOs and outputs for their own respective\n> channel opens or UTXO consolidations etc.\n>\n> This gives us the real possibility of doing multiparty coinjoins on lightning.\n> In fact, this is currently possible with c-lightning *today* using\n> the multifundchannel command (h/t to ZmnSCPjx for the original framework\n> for multifund opens).\n>\n> As written, the interactive transaction protocol is exceedingly flexible.\n> We traded off succinctness for some plausible deniablity wrt\n> any UTXOs you send to any peer -- are they yours or are they\n> some third party's? How to tell?\n>\n> I think it's interesting to point out that \"succinctness\" in rounds\n> of required interaction is typically a *highly* desirable trait for\n> any cryptographic protocol. The establishment of a lightning channel relationship,\n> however, isn't a cryptographic signature. A lightning channel, by its very\n> nature, is typically a highly interactive relationship between two peers.\n> Increasing the rounds of messaging required to establish the channel doesn't\n> change the overall interactivity profile of a channel's operation, thus\n> adding rounds of comms to channel open is generally a no-op in terms of\n> performance/uptime requirements of a node's operations.\n\nPossibly, a difference between the DLC use-case and the Lightning use-case is that the DLC use-case has a definite deadline when the contract expires, whereas the Lightning use-case has no definite end termination for the channel.\n\nIn addition, DLC requires transmitting significant amounts of data measurable in megabytes, whereas Lightning transmits little 32-byte blobs (well not really mostly 1366-byte onion-wrapped packages but still much tinier than the megabytes of adaptor signatures in DLCs).\nSo the DLC setup stage getting hit with the optimization hammer (as a collateral damage from the optimization hammer being used on the actual core DLC) seems like a reasonably thing happening in the DLC use-case.\n\nFinally, there is a big enough directory of Lightning nodes that you can reasonably pick up this directory in lots of places, pick some random number of them to channel to, and then make channels to them, and making them in a single tx is always a good thing.\nWhereas I imagine that the DLC use-cases (even in the future) are more limited userbase (and with payment points on Lightning I believe the smaller and shorter-term DLCs can run on top of Lightning), so the opportunity to aggregate may be much rarer in DLCs than in Lightning channel opens.\n\n\n> ## How important is UTXO privacy on lightning?\n> Obviously important. But given that the real transactions happen inside\n> of channels, invisibly, and that your public channels really truly\n> are public via the gossip protocol the much more important \"thing\" in the\n> lightning arena isn't your UTXO privacy so much as *not* associating your\n> identity with your node.\n\nI broadly agree here --- published channels trade off onchain privacy (marking \"hey this UTXO is totally owned by these two peeps!\") but gain offchain privacy (\"no, that is not my payment, somebody else asked me to forward it, promise!\")\n\n>\n> ## Does Taproot fix this?\n> I'm not up to date enough on the progress of Taproot scripts, however,\n> assuming the current requirement that every routing node is able to independently\n> verify the opening output script via the signatures provided\n> in the channel_announcement, it seems reasonable that on-chain transactions\n> will still be assignable to a node given gossip data. (Purely on-chain analysis\n> will be stymied, however.)\n\nHmm wait Taproot fixes this?\nWe can drop/reinterpret `short_channel_id` post-Taproot?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Cycryptr",
                "date": "2021-06-29T15:27:52",
                "message_text_only": "Hi Lisa,\n\nFirst of all great work on dual-funding and I appreciate this write up too. A couple thoughts I had.\n\n> Assuming that all the UTXOs in your wallet will, at some point, end up in a lightning channel, all of your UTXOs will be *publicly* associated with your node at some point\n\n> Given the assumption that all of your node funds will, at some point, be used to open a lightning channel, a single attacker discovering a subset of your UTXOs is simply a 'fast-forward' of what will eventually become public information.\n\nI think there\u2019s still enough 50-50 doubt. With careful consideration to coin selection, you can keep that 50-50 across all your channels too. With a determined enough prober, they can get 100% proof of your funds for future channels. That would be what my main concern is, going from doubt to certainty. That said, I think what\u2019s important here is that the whole world doesn\u2019t know, unless of course the bad actor publishes to the whole world out of band. But it can\u2019t be figured out after the fact.\n\nI do think combining a picky acceptor with your idea that you keep using the same UTXO until it gets used is a nice approach. I am not aware of how PoDLE works yet, but I do know with other coinjoining protocols, there\u2019s a coordinator involved to handle bans, bad actors, etc.\n\nPerhaps eventually we can see a sort of coordinator(s) develop here as well. One that can be used to help facilitate multi openings via dual-funding and/or handle the bad actors that might be probing. For instance, say someone has proof that another node backed out with a specific UTXO they were offering up. They could post that information to a coordinator that keeps track of others as well. Whenever a new dual-funding request comes in, the coordinator can be queried (perhaps for a small fee), to check it\u2019s DB of bad actors/UTXOs. It would be centralized, but could be distributed to multiple coordinators, or even just your own if you have multiple nodes you\u2019d like to share that logic between. This wouldn\u2019t be on the protocol level, just a thought I had that could help solve the problem.\n\nIn either case, I should probably look at how PoDLE/JoinMarket solves this at all given like you said, it\u2019s a problem amongst a way more privacy minded context. Even the fact that dual-funding exists in the world is a net positive alone to help give some doubt to all channel openings from now on.\n\nRegards,\nAnthony\n\nOn 28 Jun 2021, at 21:21, lisa neigut wrote:\n\n> Hey all,\n>\n> The dual-funding proposal has been up for a while now, and while we've had\n> some really great reviews from a few people (@ariard + @rustyrussell thanks for\n> your comments in particular).\n>\n> As a refresher, the PR is available here: https://github.com/lightningnetwork/lightning-rfc/pull/851.\n>\n> I wanted to make a quick summary of some of the biggest objections to\n> the protocol. Most of these were made during the course of the 2018 spec\n> meeting in Adelaide and while we've done a decent job of architecting around them,\n> I wanted to make them explicit.\n>\n> If there's more to add, please do.\n>\n> ## Point One\n> One: dual-funding (really the collaborative transaction protocol) requires\n> you to share your UTXO set with the channel peer.\n>\n> This is true, in a 'limited' sense, where 'UTXO set' is actually constricted\n> to 'UTXOs you're using for funding transactions'.\n>\n> On the face of it, this seems to be quite concerning to folks. Here's a few things\n> that I think make this less concerning than it might appear at the outset.\n>\n> First, let's consider the current opening case. You (or your channel peer)\n> constructs a transaction and shares the TXID and outpoint that the funding\n> output can be found at. This transaction is published and mined,\n> after the transaction is at sufficient depth a gossip announcement\n> is broadcast to the entire network, explaining where the transaction can be found.\n>\n> Under the current protocol, it's reasonable\\* to conclude that\n> every UTXO in the funding transaction belongs to a single party, the opener.\n>\n> Assuming that all the UTXOs in your wallet will, at some point, end up\n> in a lightning channel, all of your UTXOs will be *publicly* associated with\n> your node at some point (in the current model). Your UTXO set is only\n> private in the present, given a long enough time period (and channel opens)\n> they will all be tied to your node.\n>\n> For this reason, it's probably not a great idea to fund wallets using a\n> separate wallet that hasn't been coinjoined or otherwise obfuscated. In\n> fact, I think you can make a fairly decent argument (under the existing UTXO\n> model) for not mixing lightning funds with any funds you wish to remain truly\n> private/unassociated to an 'entity'.\n>\n> Given that you're currently telling everyone what UTXOs your node owns\n> (or at least has a 50/50 chance of owning..) let's consider the interactive transaction protocol.\n> Assuming a 2-party dual-funded open, as an outside observer it's much more difficult to tell which\n> UTXOs belong to who (though you can probably guess given input amounts and change outputs; maybe a good heuristic for opens is to use whole UTXOs).\n>\n> In this on-chain respect, the dual-funding protocol is no worse, and in the best case much\n> better for on-chain coin-analysis heuristics than the current protocol.\n>\n> \\* There are a few clear exceptions where other protocols (such as Pool, iiuc)\n> have been developed that make this heuristic bunk as they *also* build a multi-party\n> transaction, however afaik all of these other protocols (joinmmarket, pool) still require sharing\n> your UTXOs with another (trusted) party, difference is you know in theory where \"the Pool\n> auctioneer\" lives, whereas you don't really know much about \"any random node that wants to open\n> a channel\". Seems like there might be some room in this space for better information\n> about prospective channel peers...\n>\n> ## Point Two\n> Two: an active prober can use the interactive transaction protocol to\n> discover your wallet's entire UTXO set.\n>\n> Given the assumption that all of your node funds will, at some point,\n> be used to open a lightning channel, a single attacker discovering a subset\n> of your UTXOs is simply a 'fast-forward' of what will eventually become\n> public information.\n>\n> That being said, much smarter minds (e.g. JoinMarket, which suffers from\n> a very similar issue in what I would argue an even more privacy-conscious\n> context) than mine have employed the PoDLE protocol to make the discovery\n> of every UTXO more costly for a potential attacker. This is something\n> we can add quite trivially to the protocol, at the cost of grossly increasing\n> the gossip traffic.\n>\n> Worth noting that even without PoDLE you can much slow this type of\n> attack by reusing the same UTXO across every open attempt, being choosy\n> about which peers you do offer liquidity up to (do they have other established\n> channels? what's their uptime?) etc.\n>\n> A dedicated attacker could probably figure out your UTXO set, but that's not\n> much different from the current system; the only difference is the span of time\n> it takes them to figure it out.\n>\n> ## Things We've Done to Counter This:\n> I had the pleasure of finally meeting Nadav of SuredBits and DLC fame in Miami\n> a few weeks ago. The DLC team has adopted a version of the interactive\n> transaction protocol for their own purposes. Nadav pointed out that the\n> protocol we landed on for lightning interactive construction transactions\n> is *quite* interactive; the DLC version modified it to use batching to\n> transmit the input/output sets (the interactive protocol is one-by-one).\n>\n> The rationale for doing the addition of inputs and outputs in a non-batched\n> fashion is that this allows for you to interleave UTXOs from a variety\n> of sources, for example multiple channel opens in the same tx. With the current\n> protocol, you can initiate a dual-funded open with many peers at the same time,\n> each of which may contribute UTXOs and outputs for their own respective\n> channel opens or UTXO consolidations etc.\n>\n> This gives us the real possibility of doing multiparty coinjoins on lightning.\n> In fact, this is currently possible with c-lightning *today* using\n> the multifundchannel command (h/t to ZmnSCPjx for the original framework\n> for multifund opens).\n>\n> As written, the interactive transaction protocol is exceedingly flexible.\n> We traded off succinctness for some plausible deniablity wrt\n> any UTXOs you send to any peer -- are they yours or are they\n> some third party's? How to tell?\n>\n> I think it's interesting to point out that \"succinctness\" in rounds\n> of required interaction is typically a *highly* desirable trait for\n> any cryptographic protocol. The establishment of a lightning channel relationship,\n> however, isn't a cryptographic signature. A lightning channel, by its very\n> nature, is typically a highly interactive relationship between two peers.\n> Increasing the rounds of messaging required to establish the channel doesn't\n> change the overall interactivity profile of a channel's operation, thus\n> adding rounds of comms to channel open is generally a no-op in terms of\n> performance/uptime requirements of a node's operations.\n>\n> ## How important is UTXO privacy on lightning?\n> Obviously important. But given that the real transactions happen inside\n> of channels, invisibly, and that your public channels really truly\n> are public via the gossip protocol the much more important \"thing\" in the\n> lightning arena isn't your UTXO privacy so much as *not* associating your\n> identity with your node.\n>\n> ## Does Taproot fix this?\n> I'm not up to date enough on the progress of Taproot scripts, however,\n> assuming the current requirement that every routing node is able to independently\n> verify the opening output script via the signatures provided\n> in the channel_announcement, it seems reasonable that on-chain transactions\n> will still be assignable to a node given gossip data. (Purely on-chain analysis\n> will be stymied, however.)\n> # In Exitus\n> There are legitimate concerns regarding sharing UTXOs with other peers\n> in the process of opening a channel. The current protocol, as implemented,\n> introduces a mechanism for some plausible deniability wrt who those UTXOs\n> actually belong to, as well as providing the tools for building multi-party coinjoins as\n> opens. Further, with PoDLEs, we can at least achieve a similar level of protection\n> as JoinMarket currently enjoys.\n>\n> Finally, regardless of what open mechanism you're using, it's worth reiterating\n> that best practice is to not *ever* tie your identity to your lightning node.\n> And it may be worth reconsidering what wallet source you're using to fund\n> announced channel opens.\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210629/97a52143/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Interactive tx construction and UTXO privacy, some thoughts",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "lisa neigut",
                "Cycryptr",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 23930
        }
    },
    {
        "title": "[Lightning-dev] Turbo channels spec?",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-06-29T05:34:18",
                "message_text_only": "Hi all!\n\n        John Carvalo recently pointed out that not every implementation\naccepts zero-conf channels, but they are useful.  Roasbeef also recently\nnoted that they're not spec'd.\n\nHow do you all do it?  Here's a strawman proposal:\n\n1. Assign a new feature bit \"I accept zeroconf channels\".\n2. If both negotiate this, you can send update_add_htlc (etc) *before*\n   funding_locked without the peer getting upset.\n3. Nodes are advised *not* to forward HTLCs from an unconfirmed channel\n   unless they have explicit reason to trust that node (they can still\n   send *out* that channel, because that's not their problem!).\n\nIt's a pretty simple change, TBH (this zeroconf feature would also\ncreate a new set of channel_types, altering that PR).\n\nI can draft something this week?\n\nThanks!\nRusty."
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-06-29T07:41:35",
                "message_text_only": "Hi Rusty,\n\nOn the eclair side, we instead send `funding_locked` as soon as we\nsee the funding tx in the mempool.\n\nBut I think your proposal would work as well.\n\nWe may want to defer sending `announcement_signatures` until\nafter the funding tx has been confirmed? What `min_depth` should\nwe use here? Should we keep a non-zero value in `accept_channel`\nor should it be zero?\n\nCheers,\nBastien\n\n\n\nLe mar. 29 juin 2021 \u00e0 07:34, Rusty Russell <rusty at rustcorp.com.au> a\n\u00e9crit :\n\n> Hi all!\n>\n>         John Carvalo recently pointed out that not every implementation\n> accepts zero-conf channels, but they are useful.  Roasbeef also recently\n> noted that they're not spec'd.\n>\n> How do you all do it?  Here's a strawman proposal:\n>\n> 1. Assign a new feature bit \"I accept zeroconf channels\".\n> 2. If both negotiate this, you can send update_add_htlc (etc) *before*\n>    funding_locked without the peer getting upset.\n> 3. Nodes are advised *not* to forward HTLCs from an unconfirmed channel\n>    unless they have explicit reason to trust that node (they can still\n>    send *out* that channel, because that's not their problem!).\n>\n> It's a pretty simple change, TBH (this zeroconf feature would also\n> create a new set of channel_types, altering that PR).\n>\n> I can draft something this week?\n>\n> Thanks!\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210629/a9f7eb76/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-06-30T00:09:27",
                "message_text_only": "Bastien TEINTURIER <bastien at acinq.fr> writes:\n> Hi Rusty,\n>\n> On the eclair side, we instead send `funding_locked` as soon as we\n> see the funding tx in the mempool.\n>\n> But I think your proposal would work as well.\n\nThis would be backward compatible, I think.  Eclair would send\n`funding_locked`, which is perfectly legal, but a normal peer would\nstill wait for confirms before also sending `funding_locked`; it's\njust that option_zeroconf_channels would mean it doesn't have to\nwait for that before sending HTLCs?\n\n> We may want to defer sending `announcement_signatures` until\n> after the funding tx has been confirmed? What `min_depth` should\n> we use here? Should we keep a non-zero value in `accept_channel`\n> or should it be zero?\n\nYou can't send it before you know the channel_id, so it has to be at\nleast 1.  Spec says:\n\n      - MUST NOT send `announcement_signatures` messages until `funding_locked`\n      has been sent and received AND the funding transaction has at least six confirmations.\n\nSo still compliant there?\n\nCheers,\nRusty."
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-06-30T07:10:56",
                "message_text_only": ">\n> - MUST NOT send `announcement_signatures` messages until `funding_locked`\n>       has been sent and received AND the funding transaction has at least\n> six confirmations.\n>\n> So still compliant there?\n>\n\nGreat, I hadn't spotted that one, so we're good on the\n`announcement_signatures` side.\n\nI'm wondering if `option_zeroconf` implies that we should set `min_depth =\n0` in\n`accept_channel`, since that's the number of confirmations before we can\nsend\n`funding_locked`.\n\nWe need a signal that this channel uses zero-conf, and the two obvious\nchoices are:\n\n   - set `min_depth = 0`\n   - use a `channel_type` that sets `option_zeroconf`\n\nI think the second option is better, this way we can keep a \"normal\"\n`min_depth` set\nand when we send `funding_locked`, we know that the channel is now\nperfectly safe\nto use (out of the zero-conf zone).\n\nCheers,\nBastien\n\n\n\nLe mer. 30 juin 2021 \u00e0 02:09, Rusty Russell <rusty at rustcorp.com.au> a\n\u00e9crit :\n\n> Bastien TEINTURIER <bastien at acinq.fr> writes:\n> > Hi Rusty,\n> >\n> > On the eclair side, we instead send `funding_locked` as soon as we\n> > see the funding tx in the mempool.\n> >\n> > But I think your proposal would work as well.\n>\n> This would be backward compatible, I think.  Eclair would send\n> `funding_locked`, which is perfectly legal, but a normal peer would\n> still wait for confirms before also sending `funding_locked`; it's\n> just that option_zeroconf_channels would mean it doesn't have to\n> wait for that before sending HTLCs?\n>\n> > We may want to defer sending `announcement_signatures` until\n> > after the funding tx has been confirmed? What `min_depth` should\n> > we use here? Should we keep a non-zero value in `accept_channel`\n> > or should it be zero?\n>\n> You can't send it before you know the channel_id, so it has to be at\n> least 1.  Spec says:\n>\n>       - MUST NOT send `announcement_signatures` messages until\n> `funding_locked`\n>       has been sent and received AND the funding transaction has at least\n> six confirmations.\n>\n> So still compliant there?\n>\n> Cheers,\n> Rusty.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210630/f022c575/attachment.html>"
            },
            {
                "author": "Bitcoin Error Log",
                "date": "2021-06-29T07:53:23",
                "message_text_only": "Thanks for instigating this, Rusty! 0conf/turbo channels have been hackable\nfor a long time, and we would love to unlock new user experiences for our\nplatforms with it, formally if possible.\n\n0conf is desired by every wallet, every LN exchange, and truly shows off\nsomething only LN can uniquely offer as a UX.\n\nWe are happy to support how we can, and answer any questions from the\ntrenches.\n\nOn Tue, Jun 29, 2021 at 8:34 AM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Hi all!\n>\n>         John Carvalo recently pointed out that not every implementation\n> accepts zero-conf channels, but they are useful.  Roasbeef also recently\n> noted that they're not spec'd.\n>\n> How do you all do it?  Here's a strawman proposal:\n>\n> 1. Assign a new feature bit \"I accept zeroconf channels\".\n> 2. If both negotiate this, you can send update_add_htlc (etc) *before*\n>    funding_locked without the peer getting upset.\n> 3. Nodes are advised *not* to forward HTLCs from an unconfirmed channel\n>    unless they have explicit reason to trust that node (they can still\n>    send *out* that channel, because that's not their problem!).\n>\n> It's a pretty simple change, TBH (this zeroconf feature would also\n> create a new set of channel_types, altering that PR).\n>\n> I can draft something this week?\n>\n> Thanks!\n> Rusty.\n>\n\n\n-- \n~ John Carvalho\n\nSchedule: https://calendly.com/bitcoinerrorlog\nChat: https://t.me/bitcoinerrorlog\nSocial: https://twitter.com/bitcoinerrorlog\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210629/9dd76388/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Turbo channels spec?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Bastien TEINTURIER",
                "Bitcoin Error Log"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 7408
        }
    },
    {
        "title": "[Lightning-dev] Last week's second IRC workshop on L2 onchain support and wrap up",
        "thread_messages": [
            {
                "author": "Michael Folkson",
                "date": "2021-06-29T09:44:11",
                "message_text_only": "A summary of the first workshop is here:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019079.html\n\nThe focus for this second workshop was fee bumping and package relay.\nFor more details on package relay see:\nhttps://github.com/ariard/L2-zoology/blob/master/workshops/package-relay-and-friends.md\n\nThe conversation log for the second workshop is here:\nhttps://gist.github.com/ariard/32b51ecceccc5c6f647bae86d083c442\n\nPackage relay background\n\nPackage relay is potentially useful for L2 protocols to address the\ninherent unpredictability of future fees. CPFP (child-pays-for-parent)\nseeks to ensure say a justice transaction, in Lightning\u2019s case, with a\nlower fee, gets confirmed in a more timely manner because miners are\nincentivized to include the child transaction in a block. To do so\nthey must include the parent transaction in that block or a preceding\nblock. By \u201cpackaging\u201d the parent and the child the initiator of the\ntransaction(s) can ensure the miner\u2019s mempool doesn\u2019t initially reject\nthe parent transaction for having a too low fee.\n\nThere has been prior work done in previous years on package relay,\nmainly by Suhas Daftuar.\n\nDraft BIP: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a\n\nPackage relay design questions: https://github.com/bitcoin/bitcoin/issues/14895\n\nRecently Gloria Zhao has been advancing package relay in Bitcoin Core:\nhttps://gist.github.com/glozow/7064717e727a3eb27fad4f8504513add\n\nPackage relay implementation\n\nAttendees seemed in agreement that enabling 2 transaction packages\nwould be sufficient (at least for now) for Lightning and DLCs. A L2\nprotocol should always be able to design a two step process where the\nfirst transaction has an effective zero fee rate and the second\ntransaction sets the fee. Restricting the size of the package to 2 may\nhave the cost of slightly longer confirmation times and/or slightly\nhigher fees (t-bast) but it compares well to the increased\nimplementation complexity of larger package sizes. Two generation:\nmulti parent, single child shouldn\u2019t introduce material implementation\ncomplexity over two generation: single parent, single child (glozow).\n\nPackage RBF (replace-by-fee) is possible where there are two competing\npackages with competing Lightning commitment transactions in them and\nthe second package is given a higher fee to attempt to get it\nconfirmed before the first package. However, supporting RBF within a\npackage (ie replacing a transaction in a package with a higher fee\ntransaction) increases implementation complexity and makes it harder\nto reason about (glozow).\n\nrgrant raised the possibility of using two packages {A,B} and {B,C} if\nthree transaction packages e.g. {A,B,C} weren\u2019t supported but it was\nsuggested it is perhaps better to just broadcast a high fee CPFP\ntransaction for the {A,B} package rather than creating two packages.\nIf the first package has been evicted from the mempool the {B,C}\npackage wouldn\u2019t propagate because it would be an orphan package\n(t-bast).\n\nglozow suggested that only hints (wtxids of transactions you think\nshould be package validated) could be communicated rather than\nrelaying the transaction themselves but there were concerns from\nothers on whether these hints would successfully propagate across the\nnetwork. Instead fee rate hints could be sent to inform a peer\u2019s\ndecision on whether it makes sense to fetch the rest of the package\n(t-bast).\n\ndarosior suggested the idea of a package based CBlockPolicyEstimator\nin Bitcoin Core if CPFP is going to be increasingly used on the\nnetwork.\n\nWitness replacement and Taproot\n\nTapscripts can be unlimited in size so with current Taproot rules you\ncould in theory go from a 100,000 vbyte witness to an empty witness.\nL2 protocols may have a UTXO shared by two parties where Alice\u2019s\nwitness for her branch is say 1,000 vbytes and Bob\u2019s witness is only\nsay 250 vbytes. Replacing Alice\u2019s larger witness with Bob\u2019s smaller\nwitness could reduce transaction fees. For Lightning the best case is\na Taproot key path spend (16 vbyte witness) and the worst case is\ngoing to be a 150 vbyte witness. Miniscript can tell you your worst\ncase transaction size and this can be used to assess the transaction\npinning risk of a bloated witness (all harding).\n\nA future soft fork could give meaning to the annex in Taproot\n(darosior) which could be used for inflating the fee rate of a\nwitness. Then you could have a same-txid-different-wtxid coming after\nwith a lower fee rate but higher vbytes size to override package\nlimits (ariard). But fee rate is purely a policy concept and the annex\noperates at the consensus level. In addition the annex can only\nincrease the weight of a transaction, it cannot decrease it (harding).\n\nWrap up and initial goals\n\nWith regards to the goals of the workshops that were initially\nannounced here:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003002.html\n\n1) 2 transactions packages sounds enough to support currently deployed\nL2 protocols\n2) There are ongoing discussions in the ecosystem regarding\ndeprecation of opt in RBF and implementation of full RBF:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019074.html\n3) Generally status quo and ad hoc security incident response policy\nin the case of cross-layer security issues\n4) Generally status quo on L2 security philosophy design. L2 protocol\ndesigners should seek to minimize assumptions on the base layer.\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            }
        ],
        "thread_summary": {
            "title": "Last week's second IRC workshop on L2 onchain support and wrap up",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Michael Folkson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5577
        }
    },
    {
        "title": "[Lightning-dev] bLIPs: A proposal for community-driven app layer and protocol extension standardization",
        "thread_messages": [
            {
                "author": "Ryan Gentry",
                "date": "2021-06-30T14:10:25",
                "message_text_only": "Hi all,\n\nThe recent thread around zero-conf channels [1] provides an opportunity to\ndiscuss how the BOLT process handles features and best practices that arise\nin the wild vs. originating within the process itself. Zero-conf channels\nare one of many LN innovations on the app layer that have struggled to make\ntheir way into the spec. John Carvalho and Bitrefill launched Turbo\nchannels in April 2019 [2], Breez posted their solution to the mailing list\nfor feedback in August 2020 [3], and we know at least ACINQ and Muun\n(amongst others) have their own implementations. In an ideal world there\nwould be a descriptive design document that the app layer implementers had\ncollaborated on over the years that the spec group could then pick up and\nmerge into the BOLTs now that the feature is deemed spec-worthy.\n\nOver the last couple of months, we have discussed the idea of adding a\nBIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\nmembers of the community, and have received positive feedback from both app\nlayer and protocol devs. This would not affect the existing BOLT process at\nall, but simply add a place for app layer best practices to be succinctly\ndescribed and organized, especially those that require coordination. These\nfeatures are being built outside of the BOLT process today anyways, so\nideally a bLIP process would bring them into the fold instead of leaving\nthem buried in old ML posts or not documented at all.\n\nSome potential bLIP ideas that people have mentioned include: each lnurl\nvariant, on-the-fly channel opens, AMP, dynamic commitments, podcast\npayment metadata, p2p messaging formats, new pathfinding heuristics, remote\nnode connection standards, etc.\n\nIf the community is interested in moving forward, we've started a branch\n[5] describing such a process. It's based on BIP-0002, so not trying to\nreinvent any wheels. It would be great to have developers from various\nimplementations and from the broader app layer ecosystem volunteer to be\nlisted as editors (basically the same role as in the BIPs).\n\nLooking forward to hearing your thoughts!\n\nBest,\nRyan\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n\n[2]\nhttps://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n\n[3]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n\n[4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\nStandardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n\n[5]\nhttps://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210630/ed2d0adc/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2021-06-30T14:15:42",
                "message_text_only": "Or just use BIPs instead of further fracturing...?\n\nOn Jun 30, 2021 10:10 AM, Ryan Gentry via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi all,\n>\n>\n> The recent thread around zero-conf channels [1] provides an opportunity to discuss how the BOLT process handles features and best practices that arise in the wild vs. originating within the process itself. Zero-conf channels are one of many LN innovations on the app layer that have struggled to make their way into the spec. John Carvalho and Bitrefill launched Turbo channels in April 2019 [2], Breez posted their solution to the mailing list for feedback in August 2020 [3], and we know at least ACINQ and Muun (amongst others) have their own implementations. In an ideal world there would be a descriptive design document that the app layer implementers had collaborated on over the years that the spec group could then pick up and merge into the BOLTs now that the feature is deemed spec-worthy.\n>\n>\n> Over the last couple of months, we have discussed the idea of adding a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various members of the community, and have received positive feedback from both app layer and protocol devs. This would not affect the existing BOLT process at all, but simply add a place for app layer best practices to be succinctly described and organized, especially those that require coordination. These features are being built outside of the BOLT process today anyways, so ideally a bLIP process would bring them into the fold instead of leaving them buried in old ML posts or not documented at all.\n>\n>\n> Some potential bLIP ideas that people have mentioned include: each lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast payment metadata, p2p messaging formats, new pathfinding heuristics, remote node connection standards, etc.\n>\n>\n> If the community is interested in moving forward, we've started a branch [5] describing such a process. It's based on BIP-0002, so not trying to reinvent any wheels. It would be great to have developers from various implementations and from the broader app layer ecosystem volunteer to be listed as editors (basically the same role as in the BIPs).\u00a0\n>\n>\n> Looking forward to hearing your thoughts!\n>\n>\n> Best,\n> Ryan\n>\n>\n> [1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>\n> [2] https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>\n> [3] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>\n> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK = Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>\n> [5] https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2021-06-30T14:35:21",
                "message_text_only": "Hey everyone,\n\njust for reference when I was new here (and did not understand the\nprocesses well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n\n\nI wonder what exactly has changed in the reasoning by roasbeef which I will\nrepeat here:\n\n*> We already have the equiv of improvement proposals: BOLTs. Historically*\n\n>* new standardization documents are proposed initially as issues or PR's when *\n\n>* ultimately accepted. Why do we need another repo? *\n\n\nAs far as I can tell there was always some form of (invisible?) barrier to\nparticipate in the BOLTs but there are also new BOLTs being offered:\n* BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n* BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\nand topics to be included like:\n* dual funding\n* splicing\n* the examples given by Ryan\n\nI don't see how a new repo would reduce that barrier - Actually I think it\nwould even create more confusion as I for example would not know where\nsomething belongs. That being said I think all the points that are\naddressed in Ryan's mail could very well be formalized into BOLTs but maybe\nwe just need to rethink the current process of the BOLTs to make it more\naccessible for new ideas to find their way into the BOLTs? One thing that I\ncan say from answering lightning-network questions on stackexchange is that\nit would certainly help if the BOLTs where referenced  on lightning.network\nweb page and in the whitepaper as the place to be if one wants to learn\nabout the Lightning Network\n\nwith kind regards Rene\n\nOn Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> The recent thread around zero-conf channels [1] provides an opportunity to\n> discuss how the BOLT process handles features and best practices that arise\n> in the wild vs. originating within the process itself. Zero-conf channels\n> are one of many LN innovations on the app layer that have struggled to make\n> their way into the spec. John Carvalho and Bitrefill launched Turbo\n> channels in April 2019 [2], Breez posted their solution to the mailing list\n> for feedback in August 2020 [3], and we know at least ACINQ and Muun\n> (amongst others) have their own implementations. In an ideal world there\n> would be a descriptive design document that the app layer implementers had\n> collaborated on over the years that the spec group could then pick up and\n> merge into the BOLTs now that the feature is deemed spec-worthy.\n>\n> Over the last couple of months, we have discussed the idea of adding a\n> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n> members of the community, and have received positive feedback from both app\n> layer and protocol devs. This would not affect the existing BOLT process at\n> all, but simply add a place for app layer best practices to be succinctly\n> described and organized, especially those that require coordination. These\n> features are being built outside of the BOLT process today anyways, so\n> ideally a bLIP process would bring them into the fold instead of leaving\n> them buried in old ML posts or not documented at all.\n>\n> Some potential bLIP ideas that people have mentioned include: each lnurl\n> variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n> node connection standards, etc.\n>\n> If the community is interested in moving forward, we've started a branch\n> [5] describing such a process. It's based on BIP-0002, so not trying to\n> reinvent any wheels. It would be great to have developers from various\n> implementations and from the broader app layer ecosystem volunteer to be\n> listed as editors (basically the same role as in the BIPs).\n>\n> Looking forward to hearing your thoughts!\n>\n> Best,\n> Ryan\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>\n> [2]\n> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>\n> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>\n> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>\n> [5]\n> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nhttps://www.rene-pickhardt.de\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210630/eeeb1aa7/attachment-0001.html>"
            },
            {
                "author": "Ryan Gentry",
                "date": "2021-06-30T15:09:24",
                "message_text_only": "Hi Rene,\n\nThank you for the feedback! Very interesting to look back at the same\nproposal from 2018, we clearly could have done a better job researching\npast attempts. I have two main comments:\n\n1) not trying to introduce a new repo, the linked lightning-rfc branch [1]\nsimply adds a new bLIPs folder in the existing repo (like you suggested as\nan option in 2018)\n2) major difference between 2018 and now is one of scale (which is a great\nproblem to have!). In 2018 the LN dev ecosystem was mostly ACINQ,\nBlockstream, and Lightning Labs and the minimalist BOLTs process worked\nwell. At this point the broader ecosystem is significantly bigger than\nthose three teams combined, and it seems the process should adjust to\nreflect the new environment.\n\nThe main goal of the suggested change is simply to provide a home for\nemerging \"best practices\", especially those that require coordination\namongst multiple groups. I think LNURL provides a good example of a \"best\npractice\" that has been spec'd out [2], is completely extra protocol so\nprobably doesn't belong as a BOLT, but carries tension with it for new\ndevelopers since it's been widely adopted yet not \"officially supported\".\nWhat do you think about that?\n\nBest,\nRyan\n\n[1]\nhttps://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n[2] https://github.com/fiatjaf/lnurl-rfc\n\nOn Wed, Jun 30, 2021 at 9:35 AM Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\nwrote:\n\n> Hey everyone,\n>\n> just for reference when I was new here (and did not understand the\n> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>\n>\n> I wonder what exactly has changed in the reasoning by roasbeef which I\n> will repeat here:\n>\n> *> We already have the equiv of improvement proposals: BOLTs. Historically*\n>\n> >* new standardization documents are proposed initially as issues or PR's when *\n>\n> >* ultimately accepted. Why do we need another repo? *\n>\n>\n> As far as I can tell there was always some form of (invisible?) barrier to\n> participate in the BOLTs but there are also new BOLTs being offered:\n> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> and topics to be included like:\n> * dual funding\n> * splicing\n> * the examples given by Ryan\n>\n> I don't see how a new repo would reduce that barrier - Actually I think it\n> would even create more confusion as I for example would not know where\n> something belongs. That being said I think all the points that are\n> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n> we just need to rethink the current process of the BOLTs to make it more\n> accessible for new ideas to find their way into the BOLTs? One thing that I\n> can say from answering lightning-network questions on stackexchange is that\n> it would certainly help if the BOLTs where referenced  on lightning.network\n> web page and in the whitepaper as the place to be if one wants to learn\n> about the Lightning Network\n>\n> with kind regards Rene\n>\n> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all,\n>>\n>> The recent thread around zero-conf channels [1] provides an opportunity\n>> to discuss how the BOLT process handles features and best practices that\n>> arise in the wild vs. originating within the process itself. Zero-conf\n>> channels are one of many LN innovations on the app layer that have\n>> struggled to make their way into the spec. John Carvalho and Bitrefill\n>> launched Turbo channels in April 2019 [2], Breez posted their solution to\n>> the mailing list for feedback in August 2020 [3], and we know at least\n>> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n>> world there would be a descriptive design document that the app layer\n>> implementers had collaborated on over the years that the spec group could\n>> then pick up and merge into the BOLTs now that the feature is deemed\n>> spec-worthy.\n>>\n>> Over the last couple of months, we have discussed the idea of adding a\n>> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n>> members of the community, and have received positive feedback from both app\n>> layer and protocol devs. This would not affect the existing BOLT process at\n>> all, but simply add a place for app layer best practices to be succinctly\n>> described and organized, especially those that require coordination. These\n>> features are being built outside of the BOLT process today anyways, so\n>> ideally a bLIP process would bring them into the fold instead of leaving\n>> them buried in old ML posts or not documented at all.\n>>\n>> Some potential bLIP ideas that people have mentioned include: each lnurl\n>> variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n>> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n>> node connection standards, etc.\n>>\n>> If the community is interested in moving forward, we've started a branch\n>> [5] describing such a process. It's based on BIP-0002, so not trying to\n>> reinvent any wheels. It would be great to have developers from various\n>> implementations and from the broader app layer ecosystem volunteer to be\n>> listed as editors (basically the same role as in the BIPs).\n>>\n>> Looking forward to hearing your thoughts!\n>>\n>> Best,\n>> Ryan\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>>\n>> [2]\n>> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>>\n>> [3]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>>\n>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n>> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>>\n>> [5]\n>> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n> --\n> https://www.rene-pickhardt.de\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210630/9934ead9/attachment.html>"
            },
            {
                "author": "fiatjaf",
                "date": "2021-06-30T16:47:48",
                "message_text_only": "hello Ren\u00e9,\n\nI think the idea of having separate standards is good because we can\nkeep the core spec mandatory and other things optional.\n\nSince the core spec, defined by the BOLTs, is mandatory, it's better\nif it's as small as possible, basically barely enough to allow peers\nto talk to each other and open a channel, then define what an HTLC is\nand the basic payment flow.\n\nAll the rest is optional. The BOLTs themselves encourage\nexperimentation by having TLVs, rules for optional and experimental\nmessage type numbers and so on.\n\nAnd then it doesn't make sense to put optional things in the BOLTs\notherwise no one will be spec-compliant anymore and it will cause\nconfusion.\n\nSome things, like splicing and dual-funded channels could be created\nas blips and after everybody had implemented them moved to the BOLTs,\nother things, like the podcast tipping protocol, cannot.\n\nStill, it is better to have a spec for the podcast tipping protocol\nthan to not have, or to have it hidden somewhere. It makes it more\nopen and easier for everyone.\n\nUltimately I think dual-funded channels, trampoline routing and other\nlower level things should still be kept out of the BOLTs as long as\nthey are optional. While things like splicing and blinded paths seem\nto be more like things that should enforced. This is my opinion, but I\nthink it's good to have this clear distinction.\n\nFinally, a list of other things that deserve a spec so they are made\nstandard and interoperable across wallets and services:\n\n1. keysend\n2. AMP\n3. hosted channels\n4. trampoline routing v1\n5. trampoline routing v2\n6. turbo channels\n7. podcast tipping protocol\n8. dual-funding\n9. on-demand channels\n10. sphinx chat messaging thing\n11. private routing as done by immortan\n12. alternative graph for unannounced channels as done by immortan\n13. lnurl-withdraw\n14. lnurl-pay\n15. lnurl-channel\n16. bitcoin-liquid lightning bridge\n17. I thought I had more but apparently I forgot\n\nSo we have to hunt these people down and make them submit specs.\n\n---\nfiatjaf\n\n2021-06-30 16:35 (GMT+02:00), \"Ren\u00e9 Pickhardt via Lightning-dev\"\n<lightning-dev at lists.linuxfoundation.org> said:\n> Hey everyone,\n> just for reference when I was new here (and did not understand the processes\n> well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n> I wonder what exactly has changed in the reasoning by roasbeef which I will\n> repeat here:\n> We already have the equiv of improvement proposals: BOLTs. Historically  new\n> standardization documents are proposed initially as issues or PR's when\n> ultimately accepted. Why do we need another repo?\n> As far as I can tell there was always some form of (invisible?) barrier to\n> participate in the BOLTs but there are also new BOLTs being offered:\n> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> and topics to be included like:\n> * dual funding\n> * splicing\n> * the examples given by Ryan\n> I don't see how a new repo would reduce that barrier - Actually I think it\n> would even create more confusion as I for example would not know where\n> something belongs. That being said I think all the points that are addressed in\n> Ryan's mail could very well be formalized into BOLTs but maybe we just need to\n> rethink the current process of the BOLTs to make it more accessible for new\n> ideas to find their way into the BOLTs? One thing that I can say from answering\n> lightning-network questions on stackexchange is that it would certainly help if\n> the BOLTs where referenced on lightning.network web page and in the whitepaper\n> as the place to be if one wants to learn about the Lightning Network\n> with kind regards Rene\n> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev  wrote:\n>\n>\n>\n> Hi all,\n>\n>\n>\n>\n> The recent thread around zero-conf channels [1] provides an opportunity to\n> discuss how the BOLT process handles features and best practices that\n> arise in the wild vs. originating within the process itself. Zero-conf\n> channels are one of many LN innovations on the app layer that have\n> struggled to make their way into the spec. John Carvalho and Bitrefill\n> launched Turbo channels in April 2019 [2], Breez posted their solution to\n> the mailing list for feedback in August 2020 [3], and we know at least\n> ACINQ and Muun (amongst others) have their own implementations. In an\n> ideal world there would be a descriptive design document that the app\n> layer implementers had collaborated on over the years that the spec group\n> could then pick up and merge into the BOLTs now that the feature is deemed\n> spec-worthy.\n>\n>\n>\n>\n> Over the last couple of months, we have discussed the idea of adding a\n> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n> members of the community, and have received positive feedback from both\n> app layer and protocol devs. This would not affect the existing BOLT\n> process at all, but simply add a place for app layer best practices to be\n> succinctly described and organized, especially those that require\n> coordination. These features are being built outside of the BOLT process\n> today anyways, so ideally a bLIP process would bring them into the fold\n> instead of leaving them buried in old ML posts or not documented at all.\n>\n>\n>\n>\n> Some potential bLIP ideas that people have mentioned include: each lnurl\n> variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n> payment metadata, p2p messaging formats, new pathfinding heuristics,\n> remote node connection standards, etc.\n>\n>\n>\n>\n> If the community is interested in moving forward, we've started a branch\n> [5] describing such a process. It's based on BIP-0002, so not trying to\n> reinvent any wheels. It would be great to have developers from various\n> implementations and from the broader app layer ecosystem volunteer to be\n> listed as editors (basically the same role as in the BIPs).\n>\n>\n>\n>\n> Looking forward to hearing your thoughts!\n>\n>\n>\n>\n> Best,\n> Ryan\n>\n>\n>\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>\n>\n>\n>\n> [2]\n> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>\n>\n>\n>\n> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>\n>\n>\n>\n> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>\n>\n>\n>\n> [5]\n> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> --\n> https://www.rene-pickhardt.de_______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-06-30T20:15:42",
                "message_text_only": "> That being said I think all the points that are addressed in Ryan's mail\n> could very well be formalized into BOLTs but maybe we just need to rethink\n> the current process of the BOLTs to make it more accessible for new ideas\n> to find their way into the BOLTs?\n\nI think part of what bLIPs are trying to solve here is promoting more\nloosely\ncoupled evolution of the network. I think the BOLTs do a good job currently\nof\nspecifying what _base_ functionality is required for a routing node in a\nprescriptive manner (you must forward an HTLC like this, etc). However\nthere's\na rather large gap in describing functionality that has emerged over time\ndue\nto progressive evolution, and aren't absolutely necessary, but enhance\nnode/wallet operation.\n\nExamples of  include things like: path finding heuristics (BOLTs just say\nyou\nshould get from Alice to Bob, but provides no recommendations w.r.t _how_\nto do\nso), fee bumping heuristics, breach retribution handling, channel\nmanagement,\nrebalancing, custom records usage (like the podcast index meta-data,\nmessaging,\netc), JIT channel opening, hosted channels, randomized channel IDs, fee\noptimization, initial channel boostrapping, etc.\n\nAll these examples are effectively optional as they aren't required for base\nnode operation, but they've organically evolved over time as node\nimplementations and wallet seek to solve UX and operational problems for\ntheir users. bLIPs can be a _descriptive_ (this is how things can be done)\nhome for these types of standards, while BOLTs can be reserved for\n_prescriptive_ measures (an HTLC looks like this, etc).\n\nThe protocol as implemented today has a number of extensions (TLVs, message\ntypes, feature bits, etc) that allow implementations to spin out their own\nsub-protocols, many of which won't be considered absolutely necessary for\nnode\noperation. IMO we should embrace more of a \"bazaar\" style of evolution, and\nacknowledge that loosely coupled evolution allows participants to more\nbroadly\nexplore the design space, without the constraints of \"it isn't a thing\nuntil N\nof us start to do it\".\n\nHistorically, BOLTs have also had a rather monolithic structure. We've used\nthe same 11 or so documents for the past few years with the size of the\ndocuments swelling over time with new exceptions, features, requirements,\netc. If you were hired to work on a new codebase and saw that everything is\ndefined in 11 \"functions\" that have been growing linearly over time, you'd\nprobably declare the codebase as being unmaintainable. By having distinct\ndocuments for proposals/standards, bLIPs (author documents really), each new\nstandard/proposal is able to be more effectively explained, motivated,\nversionsed,\netc.\n\n-- Laolu\n\n\nOn Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey everyone,\n>\n> just for reference when I was new here (and did not understand the\n> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>\n>\n> I wonder what exactly has changed in the reasoning by roasbeef which I\n> will repeat here:\n>\n> *> We already have the equiv of improvement proposals: BOLTs. Historically*\n>\n> >* new standardization documents are proposed initially as issues or PR's when *\n>\n> >* ultimately accepted. Why do we need another repo? *\n>\n>\n> As far as I can tell there was always some form of (invisible?) barrier to\n> participate in the BOLTs but there are also new BOLTs being offered:\n> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> and topics to be included like:\n> * dual funding\n> * splicing\n> * the examples given by Ryan\n>\n> I don't see how a new repo would reduce that barrier - Actually I think it\n> would even create more confusion as I for example would not know where\n> something belongs. That being said I think all the points that are\n> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n> we just need to rethink the current process of the BOLTs to make it more\n> accessible for new ideas to find their way into the BOLTs? One thing that I\n> can say from answering lightning-network questions on stackexchange is that\n> it would certainly help if the BOLTs where referenced  on lightning.network\n> web page and in the whitepaper as the place to be if one wants to learn\n> about the Lightning Network\n>\n> with kind regards Rene\n>\n> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all,\n>>\n>> The recent thread around zero-conf channels [1] provides an opportunity\n>> to discuss how the BOLT process handles features and best practices that\n>> arise in the wild vs. originating within the process itself. Zero-conf\n>> channels are one of many LN innovations on the app layer that have\n>> struggled to make their way into the spec. John Carvalho and Bitrefill\n>> launched Turbo channels in April 2019 [2], Breez posted their solution to\n>> the mailing list for feedback in August 2020 [3], and we know at least\n>> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n>> world there would be a descriptive design document that the app layer\n>> implementers had collaborated on over the years that the spec group could\n>> then pick up and merge into the BOLTs now that the feature is deemed\n>> spec-worthy.\n>>\n>> Over the last couple of months, we have discussed the idea of adding a\n>> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n>> members of the community, and have received positive feedback from both app\n>> layer and protocol devs. This would not affect the existing BOLT process at\n>> all, but simply add a place for app layer best practices to be succinctly\n>> described and organized, especially those that require coordination. These\n>> features are being built outside of the BOLT process today anyways, so\n>> ideally a bLIP process would bring them into the fold instead of leaving\n>> them buried in old ML posts or not documented at all.\n>>\n>> Some potential bLIP ideas that people have mentioned include: each lnurl\n>> variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n>> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n>> node connection standards, etc.\n>>\n>> If the community is interested in moving forward, we've started a branch\n>> [5] describing such a process. It's based on BIP-0002, so not trying to\n>> reinvent any wheels. It would be great to have developers from various\n>> implementations and from the broader app layer ecosystem volunteer to be\n>> listed as editors (basically the same role as in the BIPs).\n>>\n>> Looking forward to hearing your thoughts!\n>>\n>> Best,\n>> Ryan\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>>\n>> [2]\n>> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>>\n>> [3]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>>\n>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n>> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>>\n>> [5]\n>> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n> --\n> https://www.rene-pickhardt.de\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210630/a9d3e7a4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bLIPs: A proposal for community-driven app layer and protocol extension standardization",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "fiatjaf",
                "Luke Dashjr",
                "Ren\u00e9 Pickhardt",
                "Olaoluwa Osuntokun",
                "Ryan Gentry"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 32088
        }
    }
]