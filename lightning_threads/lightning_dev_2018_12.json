[
    {
        "title": "[Lightning-dev] [bitcoin-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "Bob McElrath",
                "date": "2018-12-02T15:08:39",
                "message_text_only": "I've long thought about using SIGHASH_SINGLE, then either party can add inputs\nto cover whatever fee they want on channel close and it doesn't have to be\npre-planned at setup.\n\nFor Lightning I think you'd want to cross-sign, e.g. Alice signs her input\nand Bob's output, while Bob signs his input and Alice's output.  This would\ndemotivate the two parties from picking apart the transaction and broadcasting\none of the two SIGHASH_SINGLE's in a Lightning transaction.\n\nMatt Corallo via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n> (cross-posted to both lists to make lightning-dev folks aware, please take\n> lightning-dev off CC when responding).\n> \n> As I'm sure everyone is aware, Lightning (and other similar systems) work by\n> exchanging pre-signed transactions for future broadcast. Of course in many\n> cases this requires either (a) predicting what the feerate required for\n> timely confirmation will be at some (or, really, any) point in the future,\n> or (b) utilizing CPFP and dependent transaction relay to allow parties to\n> broadcast low-feerate transactions with children created at broadcast-time\n> to increase the effective feerate. Ideally transactions could be constructed\n> to allow for after-the-fact addition of inputs to increase fee without CPFP\n> but it is not always possible to do so.\n> \n> Option (a) is rather obviously intractible, and implementation complexity\n> has led to channel failures in lightning in practice (as both sides must\n> agree on a reasonable-in-the-future feerate). Option (b) is a much more\n> natural choice (assuming some form of as-yet-unimplemented package relay on\n> the P2P network) but is made difficult due to complexity around RBF/CPFP\n> anti-DoS rules.\n> \n> For example, if we take a simplified lightning design with pre-signed\n> commitment transaction A with one 0-value anyone-can-spend output available\n> for use as a CPFP output, a counterparty can prevent confirmation\n> of/significantly increase the fee cost of confirming A by chaining a\n> large-but-only-moderate-feerate transaction off of this anyone-can-spend\n> output. This transaction, B, will have a large absolute fee while making the\n> package (A, B) have a low-ish feerate, placing it solidly at the bottom of\n> the mempool but without significant risk of it getting evicted during memory\n> limiting. This large absolute fee forces a counterparty which wishes to have\n> the commitment transaction confirm to increase on this absolute fee in order\n> to meet RBF rules.\n> \n> For this reason (and many other similar attacks utilizing the package size\n> limits), in discussing the security model around CPFP, we've generally\n> considered it too-difficulty-to-prevent third parties which are able to\n> spend an output of a transaction from delaying its confirmation, at least\n> until/unless the prevailing feerates decline and some of the mempool backlog\n> gets confirmed.\n> \n> You'll note, however, that this attack doesn't have to be permanent to work\n> - Lightning's (and other contracting/payment channel systems') security\n> model assumes the ability to get such commitment transactions confirmed in a\n> timely manner, as otherwise HTLCs may time out and counterparties can claim\n> the timeout-refund before we can claim the HTLC using the hash-preimage.\n> \n> To partially-address the CPFP security model considerations, a next step\n> might involve tweaking Lightning's commitment transaction to have two\n> small-value outputs which are immediately spendable, one by each channel\n> participant, allowing them to chain children off without allowng unrelated\n> third-parties to chain children. Obviously this does not address the\n> specific attack so we need a small tweak to the anti-DoS CPFP rules in\n> Bitcoin Core/BIP 125:\n> \n> The last transaction which is added to a package of dependent transactions\n> in the mempool must:\n>  * Have no more than one unconfirmed parent,\n>  * Be of size no greater than 1K in virtual size.\n> (for implementation sanity, this would effectively reduce all mempool\n> package size limits by 1 1K-virtual-size transaction, and the last would be\n> \"allowed to violate the limits\" as long as it meets the above criteria).\n> \n> For contracting applications like lightning, this means that as long as the\n> transaction we wish to confirm (in this case the commitment transaction)\n>  * Has only two immediately-spendable (ie non-CSV) outputs,\n>  * where each immediately-spendable output is only spendable by one\n> counterparty,\n>  * and is no larger than MAX_PACKAGE_VIRTUAL_SIZE - 1001 Vsize,\n> each counterparty will always be able to independantly CPFP the transaction\n> in question. ie because if the \"malicious\" (ie transaction-delaying) party\n> bradcasts A with a child, it can never meet the \"last transaction\" carve-out\n> as its transaction cannot both meet the package limit and have only one\n> unconfirmed ancestor. Thus, the non-delaying counterparty can always\n> independently add its own CPFP transaction, increasing the (A, Tx2) package\n> feerate and confirming A without having to concern themselves with the (A,\n> Tx1) package.\n> \n> As an alternative proposal, at various points there have been discussions\n> around solving the \"RBF-pinning\" problem by allowing transactors to mark\n> their transactions as \"likely-to-be-RBF'ed\", which could enable a relay\n> policy where children of such transactions would be rejected unless the\n> resulting package would be \"near the top of the mempool\". This would\n> theoretically imply such attacks are not possible to pull off consistently,\n> as any \"transaction-delaying\" channel participant will have to place the\n> package containing A at an effective feerate which makes confirmation to\n> occur soon with some likelihood. It is, however, possible to pull off this\n> attack with low probability in case of feerate spikes right after broadcast.\n> \n> Note that this clearly relies on some form of package relay, which comes\n> with its own challenges, but I'll start a separate thread on that.\n> \n> See-also: lightning-dev thread about the changes to lightning spec required\n> to incorporate this: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001643.html\n> \n> Matt\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> !DSPAM:5c014daf168271726154759!\n--\nCheers, Bob McElrath\n\n\"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n    -- H. L. Mencken"
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Bob McElrath"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 6565
        }
    },
    {
        "title": "[Lightning-dev] Funds locked in channel and MAX_HTLC",
        "thread_messages": [
            {
                "author": "Cezary Dziemian",
                "date": "2018-12-02T16:31:42",
                "message_text_only": "Hello guys,\n\nI red BOLT. Do I understand correctly, that  max_accepted_htlcs means that\nfor single channel there is possibility to have such amount of transactions\npending at the same time?\n\nBest Regards,\nCezary Dziemian\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181202/c5988f00/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-02T22:43:52",
                "message_text_only": "Cezary Dziemian <cezary.dziemian at gmail.com> writes:\n> Hello guys,\n>\n> I red BOLT. Do I understand correctly, that  max_accepted_htlcs means that\n> for single channel there is possibility to have such amount of transactions\n> pending at the same time?\n\nYes.\n\n  - if result would be offering more than the remote's\n  `max_accepted_htlcs` HTLCs, in the remote commitment transaction:\n    - MUST NOT add an HTLC.\n\nNote there is also a maximum amount:\n\n  - if the sum of total offered HTLCs would exceed the remote's\n`max_htlc_value_in_flight_msat`:\n    - MUST NOT add an HTLC.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Funds locked in channel and MAX_HTLC",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Cezary Dziemian"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 996
        }
    },
    {
        "title": "[Lightning-dev] Dual Funding Proposal",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-12-02T22:47:02",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n>> 128-bit seed in\n>> open_channel2 could be added, with sorting by SHA(seed | <marshal of\n>> input> | <marshal of witness>) and SHA(seed | <marshal of output>)?\n>\n> `open_channel2` contains a good amount of entropy --- temporary channel ID, various basepoints.\n> Would not hashing `open_channel2` to get this `seed` be sufficient?\n\nGood point.  Something we already have to remember would be ideal, so\nany of the basepoints would work, and is not exposed onchain.\n\nseed = revocation_basepoint of open_channel2?\n\nCheers,\nRusty."
            },
            {
                "author": "lisa neigut",
                "date": "2018-12-03T18:33:16",
                "message_text_only": ">\n>\n> >    +----+                              +----+\n> >   where node A is the \u2018initiator\u2019 and node B is the \u2018dual-funder\u2019\n>\n> We currently use the terms funder and fundee, which are now\n> inaccurate ofc.  Perhaps 'opener' and 'accepter' are not great english,\n> but they map to the messages well?\n>\n\n'opener' and 'accepter' do map to the messages. I've adopted it for the\nrest of this response, to see how it fits in context.\n\n\"Another subtle point is the feerate_per_kw field; in the old scheme it\napplied to the first commitment tx, but here it applies to both the\nfirst commitment tx and the funding tx itself\"\n\nYou're right. Initially I didn't think the `accepter` would care since\nthey're not paying them,\nbut you need it to be able to construct the funding transaction. I'll add a\nsecond field, it seems\nimportant to keep them separated esp since the timing consideration for the\nfees is different (now vs the future).\n\n> The sending node:\n> >    -\n> >    MAY begin channel establishment using `open_channel2`\n>\n>  - MUST NOT send `open_channel`.\n>\n> > Otherwise the receiving node:\n> >    -\n> >    MUST return an error.\n>\n> This is a requirement for receiving `open_channel`  IIUC?\n>\n> ie.\n>\n> The receiving node MUST fail the channel if:\n>    ...\n>    - `option_dual_fund` has been negotiated.\n>\n\nDoes v2 of channel open necessarily deprecate the original between two\nupgraded nodes?\n\nThis seems more sane than having both as an option...will update.\n\n\n>\n> > ____`funding_puts2`\n>\n> We can probably drop the 2 here and call it, um.. `funding_compose`?\n> (Thanks thesaurus.com).  I get where you're going with 'puts, but it\n> took me a while :)\n\n\nInitially only the duplicated messages had the 2-suffix, but ended up\nadding it to all of them to denote that they belonged to the v2 of channel\nopen... I can see how that's confusing though.\n\n+1 for `funding_compose`, it's definitely more easily understood. :-D\n\n...\n\n> >    MUST NOT send a number of `input_data` and/or `output_data` which\n> >    exceeds the `put_limit`\n>\n> Side note: I wonder if we should relax this limit when we talk about\n> `option_will_fund_for_food`?\n>\n\nYes! Thanks for pointing this out.\n\n\n>\n> >    -\n> >    MAY send an empty message\n>\n> Be explicit? MAY offer zero `num_inputs` and `num_outputs`.  That's not\n> quite an empty message...\n>\n\nI defined it a few lines above, but that's not super easy to see from this.\nWill fix.\n\n\n>\n> > The receiving node:\n> >\n> >   If is the initiator (A):\n> >\n> >    -\n> >    MUST fail the channel if the `num_inputs` plus `num_outputs` is\n> greater\n> >    than the `put_limit`\n>\n> How about MAY?  It's a protection thing, but less to change when we\n> option_will_fund_for_food.  Unless we set the `put_limit` to min (4) or\n> something in that case?\n>\n\n+1 for MAY, considering that the opener will be paying the fees.\nThe limit for what's reasonable to pay is fairly subjective, i.e. perhaps\nthe opener doesn't\n care how many inputs/outputs the acceptor adds.\n\n\n>\n> Oh, it needs to check max_extra_witness_len is reasonable too, since\n> that will affect the fees.  Each signature adds 74, and pubkey adds 34,\n> so I think MUST BE less than 500 is perfectly reasonable (for both\n> reader and writer).\n>\n\nAck\n\n\n> > ___`funding_locked2`\n> >\n> > // same as v1\n> >\n> > Requirements:\n> >\n> > A dual-funding node (B):\n> >\n> >    -\n> >\n> >    SHOULD broadcast their funding transaction if it does not see the\n> >    transaction broadcast after a reasonable timeout.\n>\n> Let's just reuse `funding_locked` maybe?\n>\n> Not sure why this should wait for broadcast?\n>\n\nI was overthinking this*. Can't think of a reason for both sides not to\nbroadcast; will amend.\n\n* confused it with conflicting transaction broadcast behavior\n\n\n> > == RBF for Channel Establishment v2\n> >\n> > _____`init_rbf`\n> >\n> > This message is sent by the initiator, after the funding transaction has\n> > been broadcast but before the `funding_locked2` has been exchanged.\n> >\n> > [32: `channel_id`]\n> > [8: funding_satoshis]\n> > [8:dust_limit_satoshis]\n> > [8:channel_reserve_satoshis]\n> > [4: feerate_per_kw]\n> > [`2`:`num_inputs`]\n> > [`num_inputs*input_info`]\n> > [`2`:`num_outputs`]\n> > [`num_outputs`*ouput_info`]\n>\n> Typo again :)\n>\n> > Requirements\n> >\n> > The sending node:\n> >    - MUST be the initiator (A)\n> >    - MAY update the amount, fee rate, dust limit, or channel reserve for\n> the\n> >    channel\n>\n>  - MAY send init_rbf if it considers the most recent funding tx unlikely\n>    to be confirmed in reasonable time.\n>  - MUST set `feerate_per_kw` larger than the most recent funding tx.\n>\n\nAnother good reason to break out `funding_txn_feerate_per_kw` from\n`commitment_txn_feerate_per_kw` in `open_channel2`\n\n\n>\n> Do we really want to negotiate everything again?  It seems like the\n> funder should be able to maybe add *new* inputs and outputs (though TBH\n> I think that's going to be unusual enough that we could omit it), but\n> doing a wholesale replacement means we have to be careful that the all\n> RBFs end up having at least one input in common.  Yech.\n>\n\nOnly allowing the opener to add new inputs/outputs drives down the scope of\na RBF a good deal. I like it.\nAdding new inputs seems like a common sense bare minimum, especially if we\nassume wildly unpredictable fee rates.\n\n\n> >\n> > Rationale:\n> >\n> > Once an `init_rbf` has been accepted by the dual-funding node, the\n> message\n> > flow returns to `commitment_signed2` and proceeds as above, with the\n> > exception that the `temporary_channel_id` remains as the `channel_id` for\n> > the currently published but unmined transaction.\n>\n> By this stage, we are no longer using temporary_channel_id though.\n>\n> But it's an excellent point I had missed.  The channel_id changes on\n> each renegotiation.  We could either switch channel_id *after*\n> each accept_rbf, or keep the original channel_id until funding_locked2 (in\n> which case it should have a \"final_channel_id\" field, to make sure we're\n> talking about the same funding tx).\n>\n> Since we have to handle the \"oops, old one got in!\" it might be weird to\n> see `funding_locked2` with an old txid.  Perhaps we stick with the\n> original channel_id until then, and flip *after* funding_locked2 is sent\n> and received.\n>\n>\nWould it be more sane to continue to include the temporary channel id,\nin addition to the 'current' (i.e. most recently negotiated funding txn)\nchannel id,\nuntil the funding_locked2 is sent  (adds a `temporary_channel_id` field for\n`commitment_signed2`, ` funding_signed2` and `funding_locked2`, in addition\nto `channel_id`)?\nThat way, all opening messages would have a stable id across an RBF\nre-negotiation, `temp_channel_id`.\nSticking with the first broadcast funding transaction hash feels\na bit misleading in the case of a second round of `commitment_signed2` and\n`funding_signed2`.\n\n\n> And yeah, no `update_fee`, `announcement_signatures` until that\n> funding_locked2 exchange is complete, so we don't get those with an\n> unsettled channel_id.\n>\n> > The channel id that becomes fixed for this node will be determined by the\n> > `funding_locked2` message.\n> >\n> > ___`accept_rbf`\n> >\n> > This message accepts an RBF request, and renegotiates a dual-funder\u2019s\n> > funds, dust limit, and channel reserve, and sends the dual-funder\u2019s\n> updated\n> > puts.\n>\n> I would make this an empty message, simply an ack.  And note that\n> the channel_id after this is that of the RBFed tx.\n>\n> The question then becomes what do we do about reconnection.  I suggest:\n>\n> opener: if we haven't sent funding_signed, consider it cancelled.  If\n>    we've received funding_signed, it's obviously locked in.  If we sent\n>    and didn't received, re-xmit.\n>\n> accepter: must remember rbf if we sent commitment_signed2.  If we\n>    received funding_signed it's locked in.  If we receive an init_rbf,\n>    drop the one we remembered.  If we receive funding_signed, continue.\n>\n> We still need to address the funding_tx construction; BIP69-style seems\n> like an unnecessary information leak here.  A 128-bit seed in\n> open_channel2 could be added, with sorting by SHA(seed | <marshal of\n> input> | <marshal of witness>) and SHA(seed | <marshal of output>)?\n>\n> Phew!\n> Rusty.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181203/4ac6a8cb/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-04T02:00:18",
                "message_text_only": "lisa neigut <niftynei at gmail.com> writes:\n>> The receiving node MUST fail the channel if:\n>>    ...\n>>    - `option_dual_fund` has been negotiated.\n>>\n>\n> Does v2 of channel open necessarily deprecate the original between two\n> upgraded nodes?\n>\n> This seems more sane than having both as an option...will update.\n\nYes.  This is a nod to the future in which we drop the old open_channel\nmechanics altogether.\n\n>> Oh, it needs to check max_extra_witness_len is reasonable too, since\n>> that will affect the fees.  Each signature adds 74, and pubkey adds 34,\n>> so I think MUST BE less than 500 is perfectly reasonable (for both\n>> reader and writer).\n\nOK, I've reconsidered the format slightly; we should just send\n`max_witness_len` and not send *any* witness at this stage.  Send the\nentire witness in `funding_signed2`.\n\nThis now means we need room for the script itself, so perhaps relax this\nvalue to 1000?\n\n>>  - MAY send init_rbf if it considers the most recent funding tx unlikely\n>>    to be confirmed in reasonable time.\n>>  - MUST set `feerate_per_kw` larger than the most recent funding tx.\n>>\n>\n> Another good reason to break out `funding_txn_feerate_per_kw` from\n> `commitment_txn_feerate_per_kw` in `open_channel2`\n\nAgreed; BTW I kinda wish bitcoin uses 'txn' instead of 'tx' to\nabbreviate transaction since I used to read 'tx' as 'transmit'.  But\nI've been brainwashed now so it doesn't matter any more...\n\n>> Do we really want to negotiate everything again?  It seems like the\n>> funder should be able to maybe add *new* inputs and outputs (though TBH\n>> I think that's going to be unusual enough that we could omit it), but\n>> doing a wholesale replacement means we have to be careful that the all\n>> RBFs end up having at least one input in common.  Yech.\n>>\n>\n> Only allowing the opener to add new inputs/outputs drives down the scope of\n> a RBF a good deal. I like it.\n> Adding new inputs seems like a common sense bare minimum, especially if we\n> assume wildly unpredictable fee rates.\n\nYou need be able to specify new outputs with new inputs (change); except\nof course you want to be able to simply so you probably need to specify\n*new* inputs, and *all* your outputs (since the other side doesn't care\nabout what outputs you use, you might even eliminate some for all I\ncare).\n\nThis seems asymmetrical, but I love protocols which are hard to\nmis-implement.\n\n>> But it's an excellent point I had missed.  The channel_id changes on\n>> each renegotiation.  We could either switch channel_id *after*\n>> each accept_rbf, or keep the original channel_id until funding_locked2 (in\n>> which case it should have a \"final_channel_id\" field, to make sure we're\n>> talking about the same funding tx).\n>>\n>> Since we have to handle the \"oops, old one got in!\" it might be weird to\n>> see `funding_locked2` with an old txid.  Perhaps we stick with the\n>> original channel_id until then, and flip *after* funding_locked2 is sent\n>> and received.\n>>\n>>\n> Would it be more sane to continue to include the temporary channel id,\n> in addition to the 'current' (i.e. most recently negotiated funding txn)\n> channel id,\n> until the funding_locked2 is sent  (adds a `temporary_channel_id` field for\n> `commitment_signed2`, ` funding_signed2` and `funding_locked2`, in addition\n> to `channel_id`)?\n> That way, all opening messages would have a stable id across an RBF\n> re-negotiation, `temp_channel_id`.\n> Sticking with the first broadcast funding transaction hash feels\n> a bit misleading in the case of a second round of `commitment_signed2` and\n> `funding_signed2`.\n\nI hate temporary_channel_id, because (as specced) it's an untrusted\nvalue.  See Matt's complaints about it:\n        https://github.com/lightningnetwork/lightning-rfc/pull/496\n\nThat was bearable though, because it only lasted 3 messages (open,\naccept, funding_created).\n\nStrawman idea: for dual funded channels, `channel_id` is based not on\nthe txid, but the SHA256(open_channel2.revocation_basepoint |\naccept_channel2.revocation_basepoint).  That must be unique, and we can\nuse this same value to sort the tx, FWIW.\n\nWe'd still use the `temporary_channel_id` for open_channel2 and the\naccept_channel2 reply (to match them), but we don't ever need to change\nagain.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Dual Funding Proposal",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "lisa neigut"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 13190
        }
    },
    {
        "title": "[Lightning-dev] Base AMP",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-12-02T22:48:04",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> But what if 2 of those paths fail?\n> It would be better to merge them into a single payment along the expensive 4th path.\n> However, the remaining succeeding path has already given `numpaths`=3.\n>\n> Using `numpaths` overcommits to what you will do in the future, and is unnecessary anyway.\n> The payee is interested in the total value, not the details of the split.\n\nExcellent point.\n\nThanks,\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2018-12-04T11:40:00",
                "message_text_only": "Which brings us back to the initial proposal that just signals the\nawareness of a temporary underpayment with the single \"more is coming\"-bit.\n\nOn Sun, Dec 2, 2018 at 11:49 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> > But what if 2 of those paths fail?\n> > It would be better to merge them into a single payment along the\n> expensive 4th path.\n> > However, the remaining succeeding path has already given `numpaths`=3.\n> >\n> > Using `numpaths` overcommits to what you will do in the future, and is\n> unnecessary anyway.\n> > The payee is interested in the total value, not the details of the split.\n>\n> Excellent point.\n>\n> Thanks,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181204/de818531/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-04T18:52:58",
                "message_text_only": "Except we have invoices with no specified amount (payer dictates how much to pay).\nWhich is why we need to send the total amount to the payee as part of the onion final hop, for the case the invoice has no specified amount.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, December 4, 2018 7:40 PM, Christian Decker <decker.christian at gmail.com> wrote:\n\n> Which brings us back to the initial proposal that just signals the awareness of a temporary underpayment with the single \"more is coming\"-bit.\n>\n> On Sun, Dec 2, 2018 at 11:49 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>> ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n>>> But what if 2 of those paths fail?\n>>> It would be better to merge them into a single payment along the expensive 4th path.\n>>> However, the remaining succeeding path has already given `numpaths`=3.\n>>>\n>>> Using `numpaths` overcommits to what you will do in the future, and is unnecessary anyway.\n>>> The payee is interested in the total value, not the details of the split.\n>>\n>> Excellent point.\n>>\n>> Thanks,\n>> Rusty.\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181204/0ff8e291/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Base AMP",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Rusty Russell",
                "Christian Decker"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3053
        }
    },
    {
        "title": "[Lightning-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-12-04T03:33:53",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> As an alternative proposal, at various points there have been \n> discussions around solving the \"RBF-pinning\" problem by allowing \n> transactors to mark their transactions as \"likely-to-be-RBF'ed\", which \n> could enable a relay policy where children of such transactions would be \n> rejected unless the resulting package would be \"near the top of the \n> mempool\". This would theoretically imply such attacks are not possible \n> to pull off consistently, as any \"transaction-delaying\" channel \n> participant will have to place the package containing A at an effective \n> feerate which makes confirmation to occur soon with some likelihood. It \n> is, however, possible to pull off this attack with low probability in \n> case of feerate spikes right after broadcast.\n\nI like this idea.\n\nFirstly, it's incentive-compatible[1]: assuming blocks are full, miners\nshould always take a higher feerate tx if that tx would be in the\ncurrent block and the replaced txs would not.[2]\n\nSecondly, it reduces the problem that the current lightning proposal\nadds to the UTXO set with two anyone-can-spend txs for 1000 satoshis,\nwhich might be too small to cleanup later.  This rule would allow a\nsimple single P2WSH(OP_TRUE) output, or, with IsStandard changed,\na literal OP_TRUE.\n\n> Note that this clearly relies on some form of package relay, which comes \n> with its own challenges, but I'll start a separate thread on that.\n\nCould be done client-side, right?  Do a quick check if this is above 250\nsatoshi per kweight but below minrelayfee, put it in a side-cache with a\n60 second timeout sweep.  If something comes in which depends on it\nwhich is above minrelayfee, then process them as a pair[3].\n\nCheers,\nRusty.\n[1] Miners have generally been happy with Defaults Which Are Good For The\n    Network, but I feel a long term development aim should to be reduce\n    such cases to smaller and smaller corners.\n[2] The actual condition is subtler, but this is a clear subset AFAICT.\n[3] For Lightning, we don't care about child-pays-for-grandparent etc."
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2089
        }
    },
    {
        "title": "[Lightning-dev] Reason for having HMACs in Sphinx",
        "thread_messages": [
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-12-04T10:23:28",
                "message_text_only": "Thanks Christian, that makes sense. Unfortunately it's not very clear\nfrom the BOLT, at least not for me.\n\nNow that I think of this type of attack: *in general* the HMAC prevents\nthis kind of attack, but isn't the attack still possible in certain\nspecific cases?\n\n\nFor instance, the attacking intermediate node might guess that the next\nnode in the route is the final node; it can test this by completely\nreplacing the onion packet it sends to the next node with a self-written\nonion packet that has the next hop as final node, with the same amount\nand payment hash as instructed by the incoming payment. If that\nsucceeds, it has learned that the next node is indeed the final node\n(and nobody gets to know about the attack); if that fails, it might\nretry the payment with the original onion packet. In that case, it\nlearned that the next node is *not* the final node. In this case, the\nattack is detectable by the next node though: it first receives an\nincoming payment with a payment hash it doesn't recognize, and then it\nreceives a payment forwarding request with the same payment hash.\n\n\nGiven that the attacker has good knowledge of the shape of the Lightning\nnetwork, this type of attack can be generalized to test whether a\ncertain second-degree neighbor, third-degree neighbor etc. is the final\nnode; it scales pretty badly with increasing network distance though. An\nadditional advantage for the attacker is that this gives plausible\ndeniability: if the attack becomes visible, the attacker can always\nclaim it wasn't him, but some node upstream in the route. A practical\ndifficulty for the attacker might be that the exact amount forwarded in\nfurther-away hops is unknown, but it's probably not that difficult to guess.\n\n\nI think we could stop this type of attack by including some kind of\nshared secret in the onion message to the final node:\n\n* Payee generates shared secret and passes this to payer, as part of the\ninvoice\n\n* Payer includes shared secret in the per hop data to payee\n\n* On receiving the incoming message, payee checks whether the received\nshared secret corresponds to the generated one. If this is not the case,\nbehave in exactly the same way as when the payment hash is unrecognized\n(including timing, to prevent timing side-channel attacks).\n\nIf this shared secret is encrypted like the rest of the per hop data,\nthe attacker can't learn the shared secret, and can't include it in his\nown replacement onion. He can't copy-paste the encrypted shared secret\nfrom the original onion either, since he has to use his own, different\nephemeral key in his own onion. With this protocol in place, a final\nnode can no longer be distinguished from a non-final node with this attack.\n\n\nThe shared secret doesn't need to be very large: the number of attempts\nper second (to guess the shared secret) is limited by network latency,\nbandwidth and maybe some artificial rate limiting. If an attacker can do\n100 attempts per second, then a 32-bit shared secret will take (on\naverage) 2^31 / (100*3600*24) = 248 days to crack, for a single guess of\nwhich node is the final node. In the mean time, people will have noticed\nthe ongoing attack and will have taken countermeasures. Besides, the\ntransaction lock time will likely have expired in the mean time as well.\n\n\nCJP\n\n\nOn 29-11-18 18:13, Christian Decker wrote:\n> Hi Corne,\n>\n> the HMACs are necessary in order to make sure that a hop cannot modify\n> the packet before forwarding, and the next node not detecting that\n> modification.\n>\n> One potential attack that could facilitate is that an attacker could\n> learn the path length by messing with different per-hop payloads: set\n> n=0 the attacker flips bits in the nth per-hop payload, and forwards\n> it. If the next node doesn't return an error it was the final recipient,\n> if if returns an error, increment n and flip bits in the (n+1)th per-hop\n> payload, until no error is returned. Congratulation you just learned the\n> path length after you. The same can probably be done with the error\n> packet, meaning you can learn the exact position in the route. Add to\n> that the information you already know about the network (cltv_deltas,\n> amounts, fees, ...) and you can probably detect sender and recipient.\n>\n> Adding HMACs solves this by ensuring that the next hop will return an\n> error if anything was changed, i.e., removing the leak about which node\n> would have failed the route.\n>\n> Cheers,\n> Christian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-04T10:38:58",
                "message_text_only": "Good morning CJP,\n\n\n> I think we could stop this type of attack by including some kind of\n> shared secret in the onion message to the final node:\n\nI think we get this \"for free\" if we switch to path decorrelation and points+privkeys instead of hashes+preimages.\n\nPath decorrelation means that each hop is given a random point, to be added to the next SS \"HTLC\".\nThe final node needs to be given the total of the scalars of each hop random point along the route, most likely within the last hop of the onion.\nThe final node also cannot differentiate between an incorrect total for this scalar, or an incorrect \"invoice hash\"/invoice point.\n\nHence, some intermediate node along the way cannot guess this, and the final node will give the same error, i.e. \"invoice point not found\".\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-12-04T10:47:59",
                "message_text_only": ">> I think we could stop this type of attack by including some kind of\n>> shared secret in the onion message to the final node:\n> I think we get this \"for free\" if we switch to path decorrelation and points+privkeys instead of hashes+preimages.\n>\n> Path decorrelation means that each hop is given a random point, to be added to the next SS \"HTLC\".\n> The final node needs to be given the total of the scalars of each hop random point along the route, most likely within the last hop of the onion.\n> The final node also cannot differentiate between an incorrect total for this scalar, or an incorrect \"invoice hash\"/invoice point.\n>\n> Hence, some intermediate node along the way cannot guess this, and the final node will give the same error, i.e. \"invoice point not found\".\n>\n>\nThat might indeed stop an attacker from testing 2nd-degree, 3rd-degree\netc. neighbors, making the attack much less versatile. However, for his\ndirect neighbor in the route, the attacker does learn the point to be\nused in that hop. Therefore I think the attacker can still test whether\nor not the next node is the final hop.\n\n\nCJP"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-04T18:45:56",
                "message_text_only": "Good morning CJP,\n\n\n> > > I think we could stop this type of attack by including some kind of\n> > > shared secret in the onion message to the final node:\n> > > I think we get this \"for free\" if we switch to path decorrelation and points+privkeys instead of hashes+preimages.\n> >\n> > Path decorrelation means that each hop is given a random point, to be added to the next SS \"HTLC\".\n> > The final node needs to be given the total of the scalars of each hop random point along the route, most likely within the last hop of the onion.\n> > The final node also cannot differentiate between an incorrect total for this scalar, or an incorrect \"invoice hash\"/invoice point.\n> > Hence, some intermediate node along the way cannot guess this, and the final node will give the same error, i.e. \"invoice point not found\".\n>\n> That might indeed stop an attacker from testing 2nd-degree, 3rd-degree\n> etc. neighbors, making the attack much less versatile. However, for his\n> direct neighbor in the route, the attacker does learn the point to be\n> used in that hop. Therefore I think the attacker can still test whether\n> or not the next node is the final hop.\n\nI believe not?\n\nFor example if the route is A -> B -> C:\n\n1.  C creates an invoice secret i, and the invoice point I = i * G, and gives I to node A.\n2.  A creates two secrets k[a] and k[b], and total sum k = k[a] + k[b].\n3.  A creates points K[A] = k[a] * G and K[B] = k[b] * G.\n4.  A creates an onion as below:\n    * layer 0 (to B): decorrelation_secret = k[b]\n    * layer 1 (to B): total_decorrelation_secrets = k = k[a] + k[b]\n5.  A offers the HTLC to B, for the secret to the point (I + K[A]).\n6.  B offers the HTLC to C, for the secret to the point ((I + K[A]) + K[B]).\n\nThe total_decorrelation_secrets serves as the payer-generated shared secret between payer and payee.\nB cannot learn this, and thus cannot fake its own secret.\nEven if it instead offers ((I + K[A]) + k[z] * G) for a new secret k[z], it cannot know how to change total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2018-12-06T11:51:30",
                "message_text_only": "> * layer 0 (to B): decorrelation_secret = k[b]\n> * layer 1 (to B): total_decorrelation_secrets = k = k[a] + k[b]\n\n\nI would have less trouble understanding that if it were layer 1 (to C)\ninstead of (to B).\n\n\n> The total_decorrelation_secrets serves as the payer-generated shared secret between payer and payee.\n> B cannot learn this, and thus cannot fake its own secret.\n> Even if it instead offers ((I + K[A]) + k[z] * G) for a new secret k[z], it cannot know how to change total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.\n>\nThe way things are now, the ephemeral key generation and the payment\nhash/preimage generation are completely unrelated. This is what allows\nan attacker to use the same payment hash, and use his own ephemeral key\npair to create a new onion packet around it.\n\n\nPrimarily, path decorrelation replaces the payment hash/preimage part.\nMaybe I still don't understand something, but if that's the only thing\n(without changing the ephemeral key / onion shared secret generation),\nattacking the direct neighbor should still work; in your case, B would\nstill offer ((I + K[A]) + K[B]) to C, with an onion packet B created\nhimself. I'm not familiar enough with the path correlation to understand\nwhat happens after step 6, but for C it looks the same, so she should do\nthe same.\n\n\nI do see that, if you couple the \"H\"TLC payment secret generation to the\nonion shared secret generation, you can make the attack impossible. Do I\nunderstand correctly that this is the idea? After all, C still needs to\nreceive k somehow; my crypto math isn't that good, but my intuitive\nguess is that i + k is the secret that allows C to claim funds locked in\n((I + K[A]) + K[B]) =? (i + (k[a] + k[b])) * G. If k is submitted from A\nto C through some mechanism that replaces the current ephemeral key\nsystem, then I understand what you're at.\n\n\nAssuming this is the case, it's pretty neat. I do wonder how it\ninteracts with rendezvous routing. If the sender and receiver each\ncreate the k[..] values for their own part of the route, can the\nreceiver-generated onion packet still use points of the form ((I + K[A])\n+ K[B]), including K[..] values related to the sender side? I need to\ndig deeper into this path decorrelation idea.\n\n\nCJP"
            },
            {
                "author": "Christian Decker",
                "date": "2018-12-06T15:24:20",
                "message_text_only": "Corn\u00e9 Plooy <corne at bitonic.nl> writes:\n\n>> The total_decorrelation_secrets serves as the payer-generated shared\n>> secret between payer and payee.  B cannot learn this, and thus cannot\n>> fake its own secret.  Even if it instead offers ((I + K[A]) + k[z] *\n>> G) for a new secret k[z], it cannot know how to change\n>> total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.\n>>\n> The way things are now, the ephemeral key generation and the payment\n> hash/preimage generation are completely unrelated. This is what allows\n> an attacker to use the same payment hash, and use his own ephemeral key\n> pair to create a new onion packet around it.\n\nThat is correct, one is generated by the recipient (secret and preimage)\nand the other one is generated by the sender (ephemeral key). Mixing the\ntwo seems very unwise, since the sender has very little control over\nwhat the effective ephemeral key that is going to be used for the last\nhop. This is the same issue that we have with rendez-vous routing, i.e.,\nthat if we require the ephemeral key to be something specific at a given\nnode we'd be breaking the hardness assumption of for the ephemeral key\nrotation.\n\n> Primarily, path decorrelation replaces the payment hash/preimage part.\n> Maybe I still don't understand something, but if that's the only thing\n> (without changing the ephemeral key / onion shared secret generation),\n> attacking the direct neighbor should still work; in your case, B would\n> still offer ((I + K[A]) + K[B]) to C, with an onion packet B created\n> himself. I'm not familiar enough with the path correlation to understand\n> what happens after step 6, but for C it looks the same, so she should do\n> the same.\n>\n>\n> I do see that, if you couple the \"H\"TLC payment secret generation to the\n> onion shared secret generation, you can make the attack impossible. Do I\n> understand correctly that this is the idea? After all, C still needs to\n> receive k somehow; my crypto math isn't that good, but my intuitive\n> guess is that i + k is the secret that allows C to claim funds locked in\n> ((I + K[A]) + K[B]) =? (i + (k[a] + k[b])) * G. If k is submitted from A\n> to C through some mechanism that replaces the current ephemeral key\n> system, then I understand what you're at.\n\nI can't quite follow where we would be mixing in the ephemeral key here,\ncould you elaborate on that?\n\n> Assuming this is the case, it's pretty neat. I do wonder how it\n> interacts with rendezvous routing. If the sender and receiver each\n> create the k[..] values for their own part of the route, can the\n> receiver-generated onion packet still use points of the form ((I + K[A])\n> + K[B]), including K[..] values related to the sender side? I need to\n> dig deeper into this path decorrelation idea.\n\nSince we have very little control over what ephemeral key will actually\nbe presented to the last hop if we have a multi-hop route, we can't\nreally hide any information in the ephemeral key itself. What we could\ndo is change the way the last hop generates the shared secret from it,\ni.e., have a last hop mode and a forwarding hop mode, and mix in the\npayment secret somehow, but I can't think of a good way to do that, and\nit seems contorted. Let's just have the sender prove knowledge of the\noriginal invoice by adding a TLV field with a shared secret from the\ninvoice instead.\n\nCheers,\nChristian"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-05T00:44:44",
                "message_text_only": "Corn\u00e9 Plooy via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org> writes:\n> For instance, the attacking intermediate node might guess that the next\n> node in the route is the final node; it can test this by completely\n> replacing the onion packet it sends to the next node with a self-written\n> onion packet that has the next hop as final node, with the same amount\n> and payment hash as instructed by the incoming payment. If that\n> succeeds, it has learned that the next node is indeed the final node\n> (and nobody gets to know about the attack)\n\nThis is always true, regardless of construction, with our current\nscheme.\n\n> ; if that fails, it might\n> retry the payment with the original onion packet. In that case, it\n> learned that the next node is *not* the final node. In this case, the\n> attack is detectable by the next node though: it first receives an\n> incoming payment with a payment hash it doesn't recognize, and then it\n> receives a payment forwarding request with the same payment hash.\n\nTrue.  Note that we go as far as preventing forwarding of the same onion\n(for traffic analysis), but we don't block this more obvious attack.\n\n> I think we could stop this type of attack by including some kind of\n> shared secret in the onion message to the final node:\n>\n> * Payee generates shared secret and passes this to payer, as part of the\n> invoice\n>\n> * Payer includes shared secret in the per hop data to payee\n>\n> * On receiving the incoming message, payee checks whether the received\n> shared secret corresponds to the generated one. If this is not the case,\n> behave in exactly the same way as when the payment hash is unrecognized\n> (including timing, to prevent timing side-channel attacks).\n\nThis would indeed be an incremental improvement: I generally prefer not\nto rely on the privacy of the invoice delivery, but this certainly makes\nit no worse.\n\n> The shared secret doesn't need to be very large: the number of attempts\n> per second (to guess the shared secret) is limited by network latency,\n> bandwidth and maybe some artificial rate limiting. If an attacker can do\n> 100 attempts per second, then a 32-bit shared secret will take (on\n> average) 2^31 / (100*3600*24) = 248 days to crack, for a single guess of\n> which node is the final node. In the mean time, people will have noticed\n> the ongoing attack and will have taken countermeasures. Besides, the\n> transaction lock time will likely have expired in the mean time as well.\n\nWe could really just use the last 4 bytes of the signature, AFAICT.\n\nCheers,\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2018-12-05T12:13:40",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n>> The shared secret doesn't need to be very large: the number of attempts\n>> per second (to guess the shared secret) is limited by network latency,\n>> bandwidth and maybe some artificial rate limiting. If an attacker can do\n>> 100 attempts per second, then a 32-bit shared secret will take (on\n>> average) 2^31 / (100*3600*24) = 248 days to crack, for a single guess of\n>> which node is the final node. In the mean time, people will have noticed\n>> the ongoing attack and will have taken countermeasures. Besides, the\n>> transaction lock time will likely have expired in the mean time as well.\n>\n> We could really just use the last 4 bytes of the signature, AFAICT.\n\nA stupid idea came to mind that would allow us to use no more space in\nthe onion at all: store the secret from the invoice in the HMAC\nfield. That would complicate the final hop checking on the recipient to\neither being all 0x00, or some known secret (could also use a partial\nHMAC so we can reduce the number of lookups we need to do). Another\noption is that we could XOR it with some other field as well. The\nrecipient already signaled that it supports this by including a secret\nin the invoice in the first place anyway, so no need for a lockstep\nupgrade either.\n\nJust putting it out there, I'm still unsure if I like it at all, since\nit mixes field purposes, but it is an option if we decide this is a\nserious issue.\n\nCheers,\nChristian"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-06T00:22:22",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n>>> The shared secret doesn't need to be very large: the number of attempts\n>>> per second (to guess the shared secret) is limited by network latency,\n>>> bandwidth and maybe some artificial rate limiting. If an attacker can do\n>>> 100 attempts per second, then a 32-bit shared secret will take (on\n>>> average) 2^31 / (100*3600*24) = 248 days to crack, for a single guess of\n>>> which node is the final node. In the mean time, people will have noticed\n>>> the ongoing attack and will have taken countermeasures. Besides, the\n>>> transaction lock time will likely have expired in the mean time as well.\n>>\n>> We could really just use the last 4 bytes of the signature, AFAICT.\n>\n> A stupid idea came to mind that would allow us to use no more space in\n> the onion at all: store the secret from the invoice in the HMAC\n> field. That would complicate the final hop checking on the recipient to\n> either being all 0x00, or some known secret (could also use a partial\n> HMAC so we can reduce the number of lookups we need to do). Another\n> option is that we could XOR it with some other field as well. The\n> recipient already signaled that it supports this by including a secret\n> in the invoice in the first place anyway, so no need for a lockstep\n> upgrade either.\n\nWell, I think we're heading to a TLV mechanism for the onion \"padding\"\nanyway, so it works well there.\n\nThe only problem with this scheme is timing:\n1. It's only useful once it's compulsory, since an adversary can always\n   just not use it (downgrade attack).\n2. Will we be able to upgrade the network to make it compulsory before\n   Schnorr and decorrelation make it irrelevant?\n\nI think it's a *maybe*, so I suspect we should Just Do It, since it's\nsimple.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Reason for having HMACs in Sphinx",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Christian Decker",
                "Rusty Russell",
                "Corn\u00e9 Plooy"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 19868
        }
    },
    {
        "title": "[Lightning-dev] Colored coins or non-fungible tokens",
        "thread_messages": [
            {
                "author": "Joao Joyce",
                "date": "2018-12-04T13:29:02",
                "message_text_only": "Hi list,\n\nThank you all for the great work. LN is looking amazing!\n\nI was wondering if there is any discussion about exchanging colored-coins or non-fungible tokens through the LN.\nOr even issuance, which I'm not seeing how it would be possible, but recognise that  this space is full of surprises.\n\nThat would be a great addition to LN and it would enable new use-cases.\n\nThank you all for the great work.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181204/c6228c5c/attachment.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2018-12-04T13:51:20",
                "message_text_only": "Dear Joao,\n\nthere are the people from BHB Networks (in Itally) working on colored coins\nfor Bitcoin and Lightning. The main contributor seems to be Alekos Filini.\nAs far as I understand there is quite some progress. You can find more\ninformation in their spec repo at:\nhttps://github.com/rgb-org/spec The 4th. md file in that repo is about the\nlightning network (not sure if this is still up to date with the current\nimplementation that Alekos is also working on.)\n\nI believe Alekos has talked about this at the third lightning hackday in\nBerlin and on the LightningHackdayNYC both talks have been recorded and can\nbe found on youtube. Therefor I suggest to talk to Alekos (ccd) directly.\n\nI hope that helps.\n\nbest Rene\n\nOn Tue, Dec 4, 2018 at 2:29 PM Joao Joyce <joao.joyce at netcabo.pt> wrote:\n\n> Hi list,\n>\n> Thank you all for the great work. LN is looking amazing!\n>\n> I was wondering if there is any discussion about exchanging colored-coins\n> or non-fungible tokens through the LN.\n> Or even issuance, which I'm not seeing how it would be possible, but\n> recognise that  this space is full of surprises.\n>\n> That would be a great addition to LN and it would enable new use-cases.\n>\n> Thank you all for the great work.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181204/476e355f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Colored coins or non-fungible tokens",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "Joao Joyce"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2282
        }
    },
    {
        "title": "[Lightning-dev] Fulgurite: ideas for making a more flexible Lightning Network protocol",
        "thread_messages": [
            {
                "author": "Trey Del Bonis",
                "date": "2018-12-05T19:12:54",
                "message_text_only": "Hello all,\n\nI've been doing some thinking lately about some of the Lightning extension\nproposals like splicing and have been trying and try to generalize it into\nsomething that makes Lightning a lot more flexible and fault-tolerant overall.\n\nSo I wrote up a document describing what I call \"Fulgurite\", after the term for\nfossilized lightning.\n\nLink: https://tr3y.io/media/docs/fulgurite.pdf (also attached)\nSHA1: d25371836a56630571182a65684df19027c3b9af\n\nIt makes tracking channel state into building on a graph with moving forward in\ntime, and merges the ideas of user balances and HTLCs into different types of\n\"channel partitions\" which are also used for other things I talk about in the\ndoc.\n\nIdeally, it can make splicing and subchannels simpler.  It also makes it pretty\ntrivial to do discreet log contracts in channels vs on-chain, which is good for\nanonymity.\n\nI've been working on a toy implementation of the things in Fulgurite here, this\nisn't usable yet but there's the core parts: https://gitlab.com/delbonis/roz\n\n- Trey Del Bonis\n\nPS. If you were at the Chaincode Residency in October, you might know me as the\nguy that did Conway's Place! (= Conway's Game of Life + satoshis.place)\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: fulgurite.pdf\nType: application/pdf\nSize: 187975 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181205/8d2821d2/attachment-0001.pdf>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-06T00:41:05",
                "message_text_only": "Hi Trey,\n\nThis document is a description of how I view individual channels on Lightning currently.\nThe document is valuable as it provide a viewpoint of how Lightning works at each channel.\n\nBurchert-Decker-Wattenhofer channel factories are essentially multiparty (> 2 participants) \"channels\" (\"offchain updateable cryptocurrency systems\") with multiple \"child\" 2-party channels.\nIn general though having multiple channels between the same 2 participants is not as valuable (which is why Burchert-Decker-Wattenhofer only has two levels in the hierarchy, and why the parent level is multiparty while the child level is 2-party).\n\nPunishment mechanisms are simply part of the update protocol (they are a witness that older states have been superseded).\nWe can abstract away the update protocol (Decker-Wattenhofer, Poon-Dryja, Decker-Russell-Osuntokun) from the description in the document.\n\nOf note is that the existing update protocols can carry almost any Bitcoin-enforceable contract, including the same contracts used to enforce them.\nThis is what allows update protocols to \"nest\" as in Burchert-Decker-Wattenhofer (or your concept of \"parent\" and \"child\" channels).\nThere are some important details like the fact that Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on their transported contracts, and most contracts cannot be transported across systems (HTLCs can but with longer timelocks for each step).\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, December 6, 2018 3:12 AM, Trey Del Bonis <j.delbonis.3 at gmail.com> wrote:\n\n> Hello all,\n>\n> I've been doing some thinking lately about some of the Lightning extension\n> proposals like splicing and have been trying and try to generalize it into\n> something that makes Lightning a lot more flexible and fault-tolerant overall.\n>\n> So I wrote up a document describing what I call \"Fulgurite\", after the term for\n> fossilized lightning.\n>\n> Link: https://tr3y.io/media/docs/fulgurite.pdf (also attached)\n> SHA1: d25371836a56630571182a65684df19027c3b9af\n>\n> It makes tracking channel state into building on a graph with moving forward in\n> time, and merges the ideas of user balances and HTLCs into different types of\n> \"channel partitions\" which are also used for other things I talk about in the\n> doc.\n>\n> Ideally, it can make splicing and subchannels simpler. It also makes it pretty\n> trivial to do discreet log contracts in channels vs on-chain, which is good for\n> anonymity.\n>\n> I've been working on a toy implementation of the things in Fulgurite here, this\n> isn't usable yet but there's the core parts: https://gitlab.com/delbonis/roz\n>\n> -   Trey Del Bonis\n>\n>     PS. If you were at the Chaincode Residency in October, you might know me as the\n>     guy that did Conway's Place! (= Conway's Game of Life + satoshis.place)\n>\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-06T11:20:43",
                "message_text_only": "Good morning list, and also Trey,\n\nI confirmed that Trey accidentally replied only to me, but intended to reply to the list.\n\n> > Burchert-Decker-Wattenhofer channel factories are essentially multiparty (> 2 participants) \"channels\" (\"offchain updateable cryptocurrency systems\") with multiple \"child\" 2-party channels. In general though having multiple channels between the same 2 participants is not as valuable (which is why Burchert-Decker-Wattenhofer only has two levels in the hierarchy, and why the parent level is multiparty while the child level is 2-party).\n>\n> Where I was going with the paper is to figure out some of the details\n> surrounding how to actually implement the protocols described by the\n> more formal reasearch in the area and leave space in the design for\n> other protocols that have yet to be designed to be implemented without\n> having to do a large overhaul of the protocol. If we want to go and\n> do Burchert-Decker-Wattenhofer-style channel factories we just have to\n> describe it in terms of manipulating the Fulgurite state graph,\n> without everyone in the channel actually having to understand\n> Burchert-Decker-Wattenhofer. Note that Fulgurite subchannels are\n> expected to have only a subset of the participants of their parents.\n\nIn effect, Fulgurite simply generalizes Lightning shared-ownership update systems (\"channels\").\nThe insight effectively is that:\n\n1.  Any contract of interest to participants of a single \"shared-ownership update system\" can be done, as long as the contract is enforceable onchain.\n2.  The \"shared-ownership update system\" itself is a contract that is enforceable onchain.\n3.  Therefore, a \"shared-ownership update system\" can contain \"shared-ownership update systems\" of interest to its participants.\n\nSo \"subsystems\" here can have the same set of participants, or a subset of participants.\nNon-participants cannot safely (non-custodially) use any such \"shared-ownership update system\" and any subsystems within it since they have no power to refuse to sign off an invalid state transition.\n\n*However*, I wonder if Fulgurite adds more complexity than necessary.\n\n2-party shared-ownership update systems (\"channels\") are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.\n\nBurchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.\n\n\n> > Of note is that the existing update protocols can carry almost any Bitcoin-enforceable contract, including the same contracts used to enforce them. This is what allows update protocols to \"nest\" as in Burchert-Decker-Wattenhofer (or your concept of \"parent\" and \"child\" channels).\n>\n> Of course. But unless I'm mistaken I haven't seen any practical\n> implentations of it yet, which is what I'm attempting to do. I know I\n> won't get much adoption without BOLT support, but that's not a goal in\n> the short term at least.\n\nCode speaks louder than words.\n\n> > There are some important details like the fact that Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on their transported contracts, and most contracts cannot be transported across systems (HTLCs can but with longer timelocks for each step).\n>\n> Building transactions might not be able to be 100% transparent to the\n> partition behavior, but I don't really think that's a major\n> restriction we need to worry about right now. Partitions talk about\n> their on-chain representation at a relatively high level (see the\n> `Contract` enum in the `core` crate) and the transaction builder (yet\n> to be written) figures out how to implement that.\n\nI believe it *is* important to worry about it right now.\nThe only objection I have to Decker-Russell-Osuntokun is that it adds an additional CSV requirement to transported contracts.\nOtherwise it is strictly superior to Poon-Dryja.\nCSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\nIt is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\nIn particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.\n\nBasically:\n\n1.  Any absolute timelocked contract implies a timeout for the lifetime of the Fulgurite system/channel it is in.\n2.  The contract must be fulfilled via a non-timelocked branch before that lifetime.\n3.  If not fulfilled via a non-timelocked branch, the Fulgurite system must collapse onchain 1 block before the lifetime.\n4.  If the Fulgurite system is based on Decker-Wattenhofer or Decker-Russell-Osuntokun, it must collapse onchain N+1 blocks before the lifetime, where N is the CSV timeout for the update system used.\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-06T23:22:57",
                "message_text_only": "Good morning Trey,\n> One thing\n> we've talked about is if you and your counterparty want to route\n> payments through each other but also want to enter into discreet log\n> contracts, it might make sense to set up a subchannel for each purpose\n> so you don't have to re-sign for all the potential outcomes for the\n> DLCs (slow!) every time you add/remove an HTLC. Only the routing\n> (sub)channel would be announced to the routing network.\n\nOf note, the routing gossip is not trust-based.\nInstead, part of the routing gossip is the block and transaction and output on which the channel is anchored onchain.\nNodes check if the specified txo is unspent, and matches the purported capacity of the channel.\nOnce a channel outpoint is spent, nodes automatically remove it from their maps.\n\nIn a world with Burchert-Decker-Wattenhofer factories, the factory would have an onchain txo.\nGossip would contain all the channels in the factory, and would be signed by the same signatories as the onchain txo.\nNodes would check that the channels purported to be contained in the factory sum up to the value of this txo.\n\nI suppose that could be relaxed, so that the channels purported to be in the factory would sum up to less than or equal to the value of the channel factory txo instead.\nThis would allow a Fulgurite system to allocate only part of its funds to Lightning-visible routing nodes.\n\nIt strikes me that the issue of re-signing the DLC subcontracts could be avoided if you use `SIGHASH_NOINPUT`.\nThe same signatories could be used for the DLCs, and even if the update transaction changes, you can reanchor the DLC subcontracts with `SIGHASH_NOINPUT`.\n\n> > Code speaks louder than words.\n>\n> Of course. :)\n\nYes, so feel free to ignore whatever I say, since I have not coded for a while.\n\n> > CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n> > It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n> > In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks before the absolute timelock expires.\n>\n> Restrictions regarding when to publish could be managed at a higher\n> level. What Fulgurite is trying to solve is how to manage the state\n> negotiation rather than the high-level logic about when exactly to\n> publish commitment txs. Maybe we should slightly alter the mechanics\n> for how HTLC expiry works in-channel vs on-chain for this problem?\n\nAt minimum the lower-level system would have to alert the higher-level system that a time-sensitive contract needs to collapse the Fulgrite system or else it would not be possible to enforce the timelock.\n\nSince contracts inside a multiparticipant updatable system can be cancelled by the agreement of all participants, I suppose the higher layer can decide to demand an update that the timelock be followed within the multiparticipant updatable system.\nBut the upper layer needs to be informed of the latest time that the contract can be enforced onchain.\nYour alternative is that the upper layer needs to know whether the lower layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can argue is a layering violation.\nFurther the exact specs (how many blocks do all participants agree is reasonable for the CSV requirement?) would vary.\n\nSo it seems to me better to move time-sensitivity to Fulgurite than to higher layers.\nHigher layers can simply be concerned about what contracts it wants to enter into.\nThe higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.\nThe Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Trey Del Bonis",
                "date": "2018-12-07T20:37:11",
                "message_text_only": "Good afternoon,\n\n>Of note, the routing gossip is not trust-based.\n>Instead, part of the routing gossip is the block and transaction and output on which the channel is anchored onchain.\n>Nodes check if the specified txo is unspent, and matches the purported capacity of the channel.\n>Once a channel outpoint is spent, nodes automatically remove it from their maps.\n\n>I suppose that could be relaxed, so that the channels purported to be in the factory would sum up to less than or equal to the value of the channel factory txo instead.\n>This would allow a Fulgurite system to allocate only part of its funds to Lightning-visible routing nodes.\n\nI haven't really thought much about what the consequences for routing\ndiscovery would be.  There's already some amount of trust in the\ninformation you're getting about channels, so I think we have a bit of\nflexibility with regard to what we announce to the rest of the\nnetwork.  We might have to loosen the restrictions a bit how that\ninformation is validated of course.  Someone smarter than me should\ncomment on that in case it's a horrible idea though.\n\n>It strikes me that the issue of re-signing the DLC subcontracts could be avoided if you use `SIGHASH_NOINPUT`.\n\nOh yes.  SIGHASH_NOINPUT makes a lot of things nicer and cleaner.  And\nwhile I'm confident everyone is going to reach an agreement about it\non Bitcoin eventually, I'm not exactly holding my breath.  Plus\nthere's other coins that might *never* support it, so I'd like to make\nsure designs can not require it if we can.\n\n>At minimum the lower-level system would have to alert the higher-level system that a time-sensitive contract needs to collapse the Fulgrite system or else it would not be possible to enforce the timelock.\n\n>But the upper layer needs to be informed of the latest time that the contract can be enforced onchain.\n>Your alternative is that the upper layer needs to know whether the lower layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can argue is a layering violation.\n>Further the exact specs (how many blocks do all participants agree is reasonable for the CSV requirement?) would vary.\n\nI think I actually just devised an elegant way to make that work using\ndeadline timing flags being passed out of the update state machine,\nit'll be in the repo later.  As long as the update mechanism impl is\nsmart enough to know when to emit that the upper layer shouldn't care.\nOf course still have checks underneath where necessary.\n\nThere'd have to be negotiation beforehand about the CSV requirements,\nlike during channel setup.  It could be adjusted later though I figure\nout a good way to make that work.\n\n>So it seems to me better to move time-sensitivity to Fulgurite than to higher layers.\n>Higher layers can simply be concerned about what contracts it wants to enter into.\n>The higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.\n>The Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.\n\nThat's a good way to do it.  I'll try something like that.\n\n- Trey Del Bonis\n\nOn Thu, Dec 6, 2018 at 6:23 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Trey,\n> > One thing\n> > we've talked about is if you and your counterparty want to route\n> > payments through each other but also want to enter into discreet log\n> > contracts, it might make sense to set up a subchannel for each purpose\n> > so you don't have to re-sign for all the potential outcomes for the\n> > DLCs (slow!) every time you add/remove an HTLC. Only the routing\n> > (sub)channel would be announced to the routing network.\n>\n> Of note, the routing gossip is not trust-based.\n> Instead, part of the routing gossip is the block and transaction and output on which the channel is anchored onchain.\n> Nodes check if the specified txo is unspent, and matches the purported capacity of the channel.\n> Once a channel outpoint is spent, nodes automatically remove it from their maps.\n>\n> In a world with Burchert-Decker-Wattenhofer factories, the factory would have an onchain txo.\n> Gossip would contain all the channels in the factory, and would be signed by the same signatories as the onchain txo.\n> Nodes would check that the channels purported to be contained in the factory sum up to the value of this txo.\n>\n> I suppose that could be relaxed, so that the channels purported to be in the factory would sum up to less than or equal to the value of the channel factory txo instead.\n> This would allow a Fulgurite system to allocate only part of its funds to Lightning-visible routing nodes.\n>\n> It strikes me that the issue of re-signing the DLC subcontracts could be avoided if you use `SIGHASH_NOINPUT`.\n> The same signatories could be used for the DLCs, and even if the update transaction changes, you can reanchor the DLC subcontracts with `SIGHASH_NOINPUT`.\n>\n> > > Code speaks louder than words.\n> >\n> > Of course. :)\n>\n> Yes, so feel free to ignore whatever I say, since I have not coded for a while.\n>\n> > > CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n> > > It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n> > > In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks before the absolute timelock expires.\n> >\n> > Restrictions regarding when to publish could be managed at a higher\n> > level. What Fulgurite is trying to solve is how to manage the state\n> > negotiation rather than the high-level logic about when exactly to\n> > publish commitment txs. Maybe we should slightly alter the mechanics\n> > for how HTLC expiry works in-channel vs on-chain for this problem?\n>\n> At minimum the lower-level system would have to alert the higher-level system that a time-sensitive contract needs to collapse the Fulgrite system or else it would not be possible to enforce the timelock.\n>\n> Since contracts inside a multiparticipant updatable system can be cancelled by the agreement of all participants, I suppose the higher layer can decide to demand an update that the timelock be followed within the multiparticipant updatable system.\n> But the upper layer needs to be informed of the latest time that the contract can be enforced onchain.\n> Your alternative is that the upper layer needs to know whether the lower layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can argue is a layering violation.\n> Further the exact specs (how many blocks do all participants agree is reasonable for the CSV requirement?) would vary.\n>\n> So it seems to me better to move time-sensitivity to Fulgurite than to higher layers.\n> Higher layers can simply be concerned about what contracts it wants to enter into.\n> The higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.\n> The Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-08T19:37:07",
                "message_text_only": "Good morning Trey,\n> There's already some amount of trust in the\n> information you're getting about channels, so I think we have a bit of\n> flexibility with regard to what we announce to the rest of the\n> network. We might have to loosen the restrictions a bit how that\n> information is validated of course.\n\nThe validation of channel data (other than the fact that it is locked on the blockchain) is simply checking that both sides of the channel have agreed, i.e. signatures from one or both endpoints.\nThat is the only validation necessary, since any details of the channel will be their inviolate demesne; we do not need global consensus for things like what fees the node wants to charge for the use of the channel.\nOnly that the channel truly exists, is the only consensus validation we need.\n\nFor the case of Burchert-Decker-Wattenhofer channel factories, a single channel announcement will be done for all channels within the factory, signed off by all of the participants in the channel factory, and we presume that the factory participants have validated that the money owned by who is actually owned by that who.  However, each channel within the factory would then need channel updates only signed off by the two direct participants in the channel.  When channels within the factory are reorganized, a new announcement will need to be done and signed off on by participants in the factory who performed the reorg.\n\nBurchert-Decker-Wattenhofer also allows channels to close and then reorganized with only a proper subset of the original factory participants, but this creates even more transactions and possibly greater CSV requirements.\n\n\n> > So it seems to me better to move time-sensitivity to Fulgurite than to higher layers.\n> > Higher layers can simply be concerned about what contracts it wants to enter into.\n> > The higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.\n> > The Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.\n>\n> That's a good way to do it. I'll try something like that.\n\nOf note, is that the update mechanism can always cancel any contract if all participants in the updateable cryptocurrency system have agreed.\n\nOne can consider the fulfillment of the hashlock in an HTLC to actually cancel the contract, and put its fund into whoever fulfilled it.\nSimilarly, if the timelock on an HTLC is about to expire, then both sides can agree to simply cancel it back to the beneficiary of the timelock branch.\n\n>From this point-of-view, then, when the timelock is about to expire, and the other side refuses to sign off on the cancellation, our only remaining remedy is to fail the system and drop to onchain for enforcement.\n\nUnder Poon-Dryja there is no CSV requirement and the above point-of-view is easy to consider.\n\nUnder Decker-Wattenhofer and Decker-Russell-Osuntokun, there exists this CSV requirement and this becomes complicated.\nSuppose we have a contract with a timelock at time N.\nAnd this contract is put inside an update mechanism with CSV requirement of time M.\nThe contract must be cancelled by the participants at time N - M.\nHowever, if not cancelled, the contract will be dropped onchain, and its true expiry will still be at time N.\nIn short, the contract changes between offchain (expires at time N - M) and onchain (expires at time N).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Trey Del Bonis",
                "date": "2018-12-10T03:01:16",
                "message_text_only": "Hi,\n\n> > We might have to loosen the restrictions a bit how that information is validated of course.\n\n> For the case of Burchert-Decker-Wattenhofer channel factories, a single channel announcement will be done for all channels within the factory, signed off by all of the participants in the channel factory, and we presume that the factory participants have validated that the money owned by who is actually owned by that who.  However, each channel within the factory would then need channel updates only signed off by the two direct participants in the channel.  When channels within the factory are reorganized, a new announcement will need to be done and signed off on by participants in the factory who performed the reorg.\n\nI was more talking about situations where we *aren't* doing\nBurchert-Decker-Wattenhofer and want (unannounced) subchannels.\nAnother idea is to have peers lie in the channel announcement which\nparticular channel has the funds moving when routing a payment.  So\nyou say \"this channel has x msat capacity\" and when other peers\nrequest to route payments through it, the parties already have agreed\nto send it through the unannounced subchannel.  Or just leave the\nability to route through unanounced secret subchannels to situations\nwhere you've been given an invoice with a partial path already\nprovided and the sender just \"assumes\" that the payment will work.\n\nIt should be trivial to compose Fulgurite in\nBurchert-Decker-Wattenhofer exactly as-is, and you'd still get all the\nnice scalability benefits.\n\n> Suppose we have a contract with a timelock at time N.\n> And this contract is put inside an update mechanism with CSV requirement of time M.\n> The contract must be cancelled by the participants at time N - M.\n> However, if not cancelled, the contract will be dropped onchain, and its true expiry will still be at time N.\n> In short, the contract changes between offchain (expires at time N - M) and onchain (expires at time N).\n\nTo do that generally would be to have partitions give an optional\n\"must be gone by\" deadline where we should either get rid of the\npartition by then (somehow, we don't actually care) or force the\nchannel on-chain if we're not using a \"timeless\" update mechanism like\nPoon-Dryja.  Operations like ExpireHtlc should calculate an earlier\ndeadline at which they'd become accepted, and be the thing to actually\nremove the in-channel HTLC \"the right way\".\n\nComplementary to that, I have the update mechanism update a \"validity\ndeadline\" as a side effect after a state has been re-signed, which\nhelps us to know when to do periodic re-signings.\n\n- Trey Del Bonis\nOn Sat, Dec 8, 2018 at 2:37 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Trey,\n> > There's already some amount of trust in the\n> > information you're getting about channels, so I think we have a bit of\n> > flexibility with regard to what we announce to the rest of the\n> > network. We might have to loosen the restrictions a bit how that\n> > information is validated of course.\n>\n> The validation of channel data (other than the fact that it is locked on the blockchain) is simply checking that both sides of the channel have agreed, i.e. signatures from one or both endpoints.\n> That is the only validation necessary, since any details of the channel will be their inviolate demesne; we do not need global consensus for things like what fees the node wants to charge for the use of the channel.\n> Only that the channel truly exists, is the only consensus validation we need.\n>\n> For the case of Burchert-Decker-Wattenhofer channel factories, a single channel announcement will be done for all channels within the factory, signed off by all of the participants in the channel factory, and we presume that the factory participants have validated that the money owned by who is actually owned by that who.  However, each channel within the factory would then need channel updates only signed off by the two direct participants in the channel.  When channels within the factory are reorganized, a new announcement will need to be done and signed off on by participants in the factory who performed the reorg.\n>\n> Burchert-Decker-Wattenhofer also allows channels to close and then reorganized with only a proper subset of the original factory participants, but this creates even more transactions and possibly greater CSV requirements.\n>\n>\n> > > So it seems to me better to move time-sensitivity to Fulgurite than to higher layers.\n> > > Higher layers can simply be concerned about what contracts it wants to enter into.\n> > > The higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.\n> > > The Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.\n> >\n> > That's a good way to do it. I'll try something like that.\n>\n> Of note, is that the update mechanism can always cancel any contract if all participants in the updateable cryptocurrency system have agreed.\n>\n> One can consider the fulfillment of the hashlock in an HTLC to actually cancel the contract, and put its fund into whoever fulfilled it.\n> Similarly, if the timelock on an HTLC is about to expire, then both sides can agree to simply cancel it back to the beneficiary of the timelock branch.\n>\n> From this point-of-view, then, when the timelock is about to expire, and the other side refuses to sign off on the cancellation, our only remaining remedy is to fail the system and drop to onchain for enforcement.\n>\n> Under Poon-Dryja there is no CSV requirement and the above point-of-view is easy to consider.\n>\n> Under Decker-Wattenhofer and Decker-Russell-Osuntokun, there exists this CSV requirement and this becomes complicated.\n> Suppose we have a contract with a timelock at time N.\n> And this contract is put inside an update mechanism with CSV requirement of time M.\n> The contract must be cancelled by the participants at time N - M.\n> However, if not cancelled, the contract will be dropped onchain, and its true expiry will still be at time N.\n> In short, the contract changes between offchain (expires at time N - M) and onchain (expires at time N).\n>\n> Regards,\n> ZmnSCPxj\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-10T04:30:51",
                "message_text_only": "Good morning Trey,\n\n\n> > > We might have to loosen the restrictions a bit how that information is validated of course.\n>\n> > For the case of Burchert-Decker-Wattenhofer channel factories, a single channel announcement will be done for all channels within the factory, signed off by all of the participants in the channel factory, and we presume that the factory participants have validated that the money owned by who is actually owned by that who. However, each channel within the factory would then need channel updates only signed off by the two direct participants in the channel. When channels within the factory are reorganized, a new announcement will need to be done and signed off on by participants in the factory who performed the reorg.\n>\n> I was more talking about situations where wearen't doing\n> Burchert-Decker-Wattenhofer and want (unannounced) subchannels.\n\nYes, but if you want to interoperate, and it is Burchert-Decker-Wattenhofer that gets into BOLT instead of Fulgurite, then we will need to have some way to interoperate a Fulgurite system as masquerading as a Burchert-Decker-Wattenhofer factory.\n\n> Another idea is to have peers lie in the channel announcement which\n> particular channel has the funds moving when routing a payment.\n\nLN cannot support lying on gossip.\nThe issue is that if lying were possible, then it would be possible to just give fake channels that do not exist at all (rather than being an alias to some other channel) and which cannot actually route payments.\nBy requiring that funds be visibly locked onchain, we ensure that lying attacks are costly and that attackers have the option of behaving honestly (performing forwarding requests) and get compensated for the opportunity cost, or swallowing the opportunity cost.\n\nIn the future, as the LN size increases, some nodes may remove channels of low capacity from their local routemaps in an effort to reduce their memory consumption.\nLarger capacity channels that are near to my node are more likely to succeed in forwarding, so it is better to retain them.\nThis implies removing low-capacity channels that are far away from my node from my routemap to keep my routemap size manageable.\n\n> So\n> you say \"this channel has x msat capacity\" and when other peers\n> request to route payments through it, the parties already have agreed\n> to send it through the unannounced subchannel.\n\nThis is already allowed in BOLT 1.1.\nShort channel IDs are only used as a cheap (8-byte) indicator for the next node in the route.\nIf there is some private unannounced channel, or some other channel on the route, the forwarding node may use that if the publicly announced channel has insufficient capacity on the forwarding node side.\n\nOf course, if the publicly-visible channel has low total capacity, it becomes unlikely to be used for forwarding by third parties.\nAgain, this is the tradeoff the Fulgurite user must consider.\n\nWhat could be done today would be this:\n\n1.  You and your peer lock your funds in a Fulgurite system.\n2.  The Fulgurite system is split into two subchannels, one is an \"ordinary\" HTLC-only channel, the other supports HTLC and DLC.\n3.  Everyone else on LN assumes your LN channel is the entire Fulgurite system (because that is what is committed onchain and that is what they will use).\n4.  If somebody routes through you, you prefer the HTLC-only subchannel.\n5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n\nIn the future, when Burchert-Decker-Wattenhofer gets onto BOLT:\n\n1.  You and your peer lock your funds in a Fulgurite system.\n2.  The Fulgurite system is split into two subchannels, one is an \"ordinary\" HTLC-only channel, the other supports HTLC and DLC.\n3.  You and your peer pretend to create a Burchert-Decker-Wattenhofer channel factory that contains a single channel (the HTLC-only subchannel), with the rest of the funds not claimed to be used on LN.\n4.  If somebody routes through you, you prefer the HTLC-only subchannel.\n5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n\n\n> It should be trivial to compose Fulgurite in\n> Burchert-Decker-Wattenhofer exactly as-is, and you'd still get all the\n> nice scalability benefits.\n\nExactly, which is why I mentioned how Burchert-Decker-Wattenhofer channel gossip will have to work.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Trey Del Bonis",
                "date": "2018-12-10T20:37:46",
                "message_text_only": "Hello ZmnSCPxj,\n\n> Yes, but if you want to interoperate, and it is Burchert-Decker-Wattenhofer that gets into BOLT instead of Fulgurite, then we will need to have some way to interoperate a Fulgurite system as masquerading as a Burchert-Decker-Wattenhofer factory.\n\nWould it really be masquerading though?  The standard shouldn't care\nabout how a multiparty channel is implemented, only the effective\nbalance between each party in each subchannel.  And that's regardless\nof if it's with Fulgurite being nested in BDW as previously mentioned,\nor with multiparty Fulgurite acting as though it were just BDW.\n\n> LN cannot support lying on gossip.\n> The issue is that if lying were possible, then it would be possible to just give fake channels that do not exist at all (rather than being an alias to some other channel) and which cannot actually route payments.\n> By requiring that funds be visibly locked onchain, we ensure that lying attacks are costly and that attackers have the option of behaving honestly (performing forwarding requests) and get compensated for the opportunity cost, or swallowing the opportunity cost.\n\nI'm not saying lie altogether, you still have to have the funds locked\non-chain.  Just say \"here's this (layer 1) channel, we can route x\nmsat through it\" and leave it at that, and have peers verify that x is\nless than or equal to what the on-chain txo says it should have.  And\napparently that's already in BOLT 1.1 so that should be doable soon.\nYou still have the same security guarantees (with regard to verifying\nfunds actually seem to exist) with BDW as you would with Fulgurite\nsubchannels as external users can't verify that there's actually funds\nin a channel if there's no tx spending into it on-chain, which still\nhappens with both systems as I understand it.\n\nAnd I'd say that it is (somewhat) possible to lie in gossip.  If\nparties in a BDW channel collude they could absolutely produce\nannouncements that say there's much more balance in subchannels than\nthere actually is, or vice-versa.  But that's not really a problem\nwhen routing payments since they don't get much of anything from it\nsince large payments would fail there anyways.\n\n> 5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n\nI'm not really sure how this is an issue since if the HTLC+DLC didn't\nexist at all then you'd have to reject the payments anyways.  I'm in\nfavor of publishing messages that say \"yes I know it looks like\nthere's more balance, there's actually less than that\" for this\nreason, so that nodes would know not to send payments that way.  What\n*would* be nice to do is just \"lie\" about the effective capacity of\nthe channel in the announce or update message.  And it's not really\nlying, you just don't have a way of justifying that announcement vs\nwhat it looks like on-chain.  And of course NOINPUT would make DLCs\nless of a hassle, even in Poon-Dryja, as previously mentioned.\n\nAlso aside from that, it'd be nice to have update_channel messages\nhave a way to say the balances (and fees) in each direction in a\nchannel.  Since for very public nodes you'd be able to deduce roughly\nhow much balance can flow in a particular direction and it would aid\nin calculating the optimal payment in the long run, especially for\nscenarios where you don't care about privacy as much as usability (and\nyou can still fuzz the balances, etc.).  You don't even have\nto publish update_channels very often, say every hour or day,\ndepending on the capacity and usage of the channel.\n\n- Trey Del Bonis\n\nOn Sun, Dec 9, 2018 at 11:31 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Trey,\n>\n>\n> > > > We might have to loosen the restrictions a bit how that information is validated of course.\n> >\n> > > For the case of Burchert-Decker-Wattenhofer channel factories, a single channel announcement will be done for all channels within the factory, signed off by all of the participants in the channel factory, and we presume that the factory participants have validated that the money owned by who is actually owned by that who. However, each channel within the factory would then need channel updates only signed off by the two direct participants in the channel. When channels within the factory are reorganized, a new announcement will need to be done and signed off on by participants in the factory who performed the reorg.\n> >\n> > I was more talking about situations where wearen't doing\n> > Burchert-Decker-Wattenhofer and want (unannounced) subchannels.\n>\n> Yes, but if you want to interoperate, and it is Burchert-Decker-Wattenhofer that gets into BOLT instead of Fulgurite, then we will need to have some way to interoperate a Fulgurite system as masquerading as a Burchert-Decker-Wattenhofer factory.\n>\n> > Another idea is to have peers lie in the channel announcement which\n> > particular channel has the funds moving when routing a payment.\n>\n> LN cannot support lying on gossip.\n> The issue is that if lying were possible, then it would be possible to just give fake channels that do not exist at all (rather than being an alias to some other channel) and which cannot actually route payments.\n> By requiring that funds be visibly locked onchain, we ensure that lying attacks are costly and that attackers have the option of behaving honestly (performing forwarding requests) and get compensated for the opportunity cost, or swallowing the opportunity cost.\n>\n> In the future, as the LN size increases, some nodes may remove channels of low capacity from their local routemaps in an effort to reduce their memory consumption.\n> Larger capacity channels that are near to my node are more likely to succeed in forwarding, so it is better to retain them.\n> This implies removing low-capacity channels that are far away from my node from my routemap to keep my routemap size manageable.\n>\n> > So\n> > you say \"this channel has x msat capacity\" and when other peers\n> > request to route payments through it, the parties already have agreed\n> > to send it through the unannounced subchannel.\n>\n> This is already allowed in BOLT 1.1.\n> Short channel IDs are only used as a cheap (8-byte) indicator for the next node in the route.\n> If there is some private unannounced channel, or some other channel on the route, the forwarding node may use that if the publicly announced channel has insufficient capacity on the forwarding node side.\n>\n> Of course, if the publicly-visible channel has low total capacity, it becomes unlikely to be used for forwarding by third parties.\n> Again, this is the tradeoff the Fulgurite user must consider.\n>\n> What could be done today would be this:\n>\n> 1.  You and your peer lock your funds in a Fulgurite system.\n> 2.  The Fulgurite system is split into two subchannels, one is an \"ordinary\" HTLC-only channel, the other supports HTLC and DLC.\n> 3.  Everyone else on LN assumes your LN channel is the entire Fulgurite system (because that is what is committed onchain and that is what they will use).\n> 4.  If somebody routes through you, you prefer the HTLC-only subchannel.\n> 5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n>\n> In the future, when Burchert-Decker-Wattenhofer gets onto BOLT:\n>\n> 1.  You and your peer lock your funds in a Fulgurite system.\n> 2.  The Fulgurite system is split into two subchannels, one is an \"ordinary\" HTLC-only channel, the other supports HTLC and DLC.\n> 3.  You and your peer pretend to create a Burchert-Decker-Wattenhofer channel factory that contains a single channel (the HTLC-only subchannel), with the rest of the funds not claimed to be used on LN.\n> 4.  If somebody routes through you, you prefer the HTLC-only subchannel.\n> 5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n>\n>\n> > It should be trivial to compose Fulgurite in\n> > Burchert-Decker-Wattenhofer exactly as-is, and you'd still get all the\n> > nice scalability benefits.\n>\n> Exactly, which is why I mentioned how Burchert-Decker-Wattenhofer channel gossip will have to work.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-11T03:55:57",
                "message_text_only": "Good morning Trey,\n\n>\n> Would it really be masquerading though? The standard shouldn't care\n> about how a multiparty channel is implemented, only the effective\n> balance between each party in each subchannel. And that's regardless\n> of if it's with Fulgurite being nested in BDW as previously mentioned,\n> or with multiparty Fulgurite acting as though it were just BDW.\n\nI suppose it would depend on how we end up defining words.\nIn any case, it is certainly possible for the spec to simply specify allowing some multiparty system with unspecified link-level behavior, but with specified global-level behavior (i.e. contains some channels that can be routed through, but the spec will not define how the multiparty system communicates between the nodes in order to coordinate updates to the system).\n\n>\n> > LN cannot support lying on gossip.\n> > The issue is that if lying were possible, then it would be possible to just give fake channels that do not exist at all (rather than being an alias to some other channel) and which cannot actually route payments.\n> > By requiring that funds be visibly locked onchain, we ensure that lying attacks are costly and that attackers have the option of behaving honestly (performing forwarding requests) and get compensated for the opportunity cost, or swallowing the opportunity cost.\n>\n> I'm not saying lie altogether, you still have to have the funds locked\n> on-chain. Just say \"here's this (layer 1) channel, we can route x\n> msat through it\" and leave it at that, and have peers verify that x is\n> less than or equal to what the on-chain txo says it should have. And\n> apparently that's already in BOLT 1.1 so that should be doable soon.\n> You still have the same security guarantees (with regard to verifying\n> funds actually seem to exist) with BDW as you would with Fulgurite\n> subchannels as external users can't verify that there's actually funds\n> in a channel if there's no tx spending into it on-chain, which still\n> happens with both systems as I understand it.\n\nYes.\n\n> And I'd say that it is (somewhat) possible to lie in gossip. If\n> parties in a BDW channel collude they could absolutely produce\n> announcements that say there's much more balance in subchannels than\n> there actually is, or vice-versa. But that's not really a problem\n> when routing payments since they don't get much of anything from it\n> since large payments would fail there anyways.\n\nBut they cannot produce announcements where the total balance in subchannels is greater than what the actual specified UTXO has.\nAgain, as I mentioned, in the future where the public mainnet LN is very large, it is likely that nodes with limited working memories will drop channels below a specified capacity from their in-memory routemaps, since the capacity is something they can verify and in general dropping lower-capacity channels is less likely to cause future payment failures.\n\n> > 5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n>\n> I'm not really sure how this is an issue since if the HTLC+DLC didn't\n> exist at all then you'd have to reject the payments anyways.\n\nThis is not an issue.\nIt is simply the option that the Fulgurite user has.\nThat is, balance the cost of transmitting a large number of DLC signatures, vs. the benefit of earning a little money for routing.\n\n>I'm in\n> favor of publishing messages that say \"yes I know it looks like\n> there's more balance, there's actually less than that\" for this\n> reason, so that nodes would know not to send payments that way. What\n> would be nice to do is just \"lie\" about the effective capacity of\n> the channel in the announce or update message. And it's not really\n> lying, you just don't have a way of justifying that announcement vs\n> what it looks like on-chain.\n\nCertainly that can be done.\nIt is not lying but being more honest --- it looks like you have more capacity, but you admit that there is less useable capacity than that.\nI suppose I fixated too much on the term \"lie\" here, since it is not the correct term as you are being *more* honest about the actual situation, not less.\n\n> Also aside from that, it'd be nice to have update_channel messages\n> have a way to say the balances (and fees) in each direction in a\n> channel.\n\nWe would have to design this carefully.\nOne side may be willing to let such information be known, but the other side might not.\nCurrent `channel_update` contains only signature from one side of the channel, as it contains data like \"how much do I want to charge as fees if you use this channel to forward\", which requires only the consent of one side.\nIf one side admits \"I have 1.0BTC\" on a channel that publicly can be verified as 3.5BTC capacity, that immediately implies that the other side has 2.5BTC on that channel.\nPerhaps a new `channel_balance_update` gossip message that is signed by both sides instead.\n\nBut the fact that we do not *currently* publish such, and yet payments in current LN are reasonably successful, suggests that it might not be at all necessary.\nCurrent implementations already retry routes, and work well enough without this information.\nVarious mini-enhancements like non-binding short-channel-id in onion hops, as well as the potential to reuse rendezvous routing for rerouting via alternative routes (modulo reservations Christian Decker has with actually doing the math) can help improve payment success even with no accurate knowledge of the channel state.\n\n> You don't even have\n> to publish update_channels very often, say every hour or day,\n> depending on the capacity and usage of the channel.\n\nThis greatly increases bandwidth use for gossip, though.\nIn addition, most of the time the information will not be useful, since it is not likely I will need the accurate information about this channel state if I never have to make a payment that will route through that channel.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Trey Del Bonis",
                "date": "2018-12-11T19:58:42",
                "message_text_only": "Hello ZmnSCPxj,\n\n>In any case, it is certainly possible for the spec to simply specify allowing some multiparty system with unspecified link-level behavior, but with specified global-level behavior (i.e. contains some channels that can be routed through, but the spec will not define how the multiparty system communicates between the nodes in order to coordinate updates to the system).\n\nMaybe discussion on this should be left for the standards meeting in a\nfew weeks.\n\n>It is simply the option that the Fulgurite user has.\n>That is, balance the cost of transmitting a large number of DLC signatures, vs. the benefit of earning a little money for routing.\n\nOh I see what you're saying now.  Misunderstanding on my part there.\n\nI think that these kinds of decisions should be communicated when\nsetting up a channel.  Perhaps during channel setup peers should\nspecify how they expect to use a channel, like \"should we do\npseudo-BDW or are we ok with doing Layer-1 payments even in a\nmultiparty scenario?\".\n\n>Perhaps a new `channel_balance_update` gossip message that is signed by both sides instead.\n\n>But the fact that we do not *currently* publish such, and yet payments in current LN are reasonably successful, suggests that it might not be at all necessary.\n\nI would agree with both statements.\n\n>This greatly increases bandwidth use for gossip, though.\n>In addition, most of the time the information will not be useful, since it is not likely I will need the accurate information about this channel state if I never have to make a payment that will route through that channel.\n>Current implementations already retry routes, and work well enough without this information.\n>Various mini-enhancements like non-binding short-channel-id in onion hops, as well as the potential to reuse rendezvous routing for rerouting via alternative routes (modulo reservations Christian Decker has with actually doing the math) can help improve payment success even with no accurate knowledge of the channel state.\n\nPerhaps clients should try to talk to each node in the route and ask\nif they would be willing to or are able to relay a payment (or in the\ncase of AMP, how much they can relay of the total).  Of course they\ncould lie (say they can but then refuse), but it would at least inform\nabout peers that are genuinely dead.  I'm not sure if this has been\nthroughly discussed before or not.\n\n~~~\n\nSome of this is straying from Fulgurite itself and is relatively\ninconsequential.  Should this be moved to another thread or IRC?\n\n- Trey Del Bonis\n\nOn Mon, Dec 10, 2018 at 10:56 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Trey,\n>\n> >\n> > Would it really be masquerading though? The standard shouldn't care\n> > about how a multiparty channel is implemented, only the effective\n> > balance between each party in each subchannel. And that's regardless\n> > of if it's with Fulgurite being nested in BDW as previously mentioned,\n> > or with multiparty Fulgurite acting as though it were just BDW.\n>\n> I suppose it would depend on how we end up defining words.\n> In any case, it is certainly possible for the spec to simply specify allowing some multiparty system with unspecified link-level behavior, but with specified global-level behavior (i.e. contains some channels that can be routed through, but the spec will not define how the multiparty system communicates between the nodes in order to coordinate updates to the system).\n>\n> >\n> > > LN cannot support lying on gossip.\n> > > The issue is that if lying were possible, then it would be possible to just give fake channels that do not exist at all (rather than being an alias to some other channel) and which cannot actually route payments.\n> > > By requiring that funds be visibly locked onchain, we ensure that lying attacks are costly and that attackers have the option of behaving honestly (performing forwarding requests) and get compensated for the opportunity cost, or swallowing the opportunity cost.\n> >\n> > I'm not saying lie altogether, you still have to have the funds locked\n> > on-chain. Just say \"here's this (layer 1) channel, we can route x\n> > msat through it\" and leave it at that, and have peers verify that x is\n> > less than or equal to what the on-chain txo says it should have. And\n> > apparently that's already in BOLT 1.1 so that should be doable soon.\n> > You still have the same security guarantees (with regard to verifying\n> > funds actually seem to exist) with BDW as you would with Fulgurite\n> > subchannels as external users can't verify that there's actually funds\n> > in a channel if there's no tx spending into it on-chain, which still\n> > happens with both systems as I understand it.\n>\n> Yes.\n>\n> > And I'd say that it is (somewhat) possible to lie in gossip. If\n> > parties in a BDW channel collude they could absolutely produce\n> > announcements that say there's much more balance in subchannels than\n> > there actually is, or vice-versa. But that's not really a problem\n> > when routing payments since they don't get much of anything from it\n> > since large payments would fail there anyways.\n>\n> But they cannot produce announcements where the total balance in subchannels is greater than what the actual specified UTXO has.\n> Again, as I mentioned, in the future where the public mainnet LN is very large, it is likely that nodes with limited working memories will drop channels below a specified capacity from their in-memory routemaps, since the capacity is something they can verify and in general dropping lower-capacity channels is less likely to cause future payment failures.\n>\n> > > 5.  If the HTLC-only subchannel has insufficient capacity you have two options: (1) swallow the cost of signing all 1 million DLC sub-contract signatures for every update of the HTLC, or (2) just pretend you're out of funds in the specified direction, regardless of the DLC-subchannel state (nobody can force you to use it anyway, and it is your choice to give up on the routing fees).\n> >\n> > I'm not really sure how this is an issue since if the HTLC+DLC didn't\n> > exist at all then you'd have to reject the payments anyways.\n>\n> This is not an issue.\n> It is simply the option that the Fulgurite user has.\n> That is, balance the cost of transmitting a large number of DLC signatures, vs. the benefit of earning a little money for routing.\n>\n> >I'm in\n> > favor of publishing messages that say \"yes I know it looks like\n> > there's more balance, there's actually less than that\" for this\n> > reason, so that nodes would know not to send payments that way. What\n> > would be nice to do is just \"lie\" about the effective capacity of\n> > the channel in the announce or update message. And it's not really\n> > lying, you just don't have a way of justifying that announcement vs\n> > what it looks like on-chain.\n>\n> Certainly that can be done.\n> It is not lying but being more honest --- it looks like you have more capacity, but you admit that there is less useable capacity than that.\n> I suppose I fixated too much on the term \"lie\" here, since it is not the correct term as you are being *more* honest about the actual situation, not less.\n>\n> > Also aside from that, it'd be nice to have update_channel messages\n> > have a way to say the balances (and fees) in each direction in a\n> > channel.\n>\n> We would have to design this carefully.\n> One side may be willing to let such information be known, but the other side might not.\n> Current `channel_update` contains only signature from one side of the channel, as it contains data like \"how much do I want to charge as fees if you use this channel to forward\", which requires only the consent of one side.\n> If one side admits \"I have 1.0BTC\" on a channel that publicly can be verified as 3.5BTC capacity, that immediately implies that the other side has 2.5BTC on that channel.\n> Perhaps a new `channel_balance_update` gossip message that is signed by both sides instead.\n>\n> But the fact that we do not *currently* publish such, and yet payments in current LN are reasonably successful, suggests that it might not be at all necessary.\n> Current implementations already retry routes, and work well enough without this information.\n> Various mini-enhancements like non-binding short-channel-id in onion hops, as well as the potential to reuse rendezvous routing for rerouting via alternative routes (modulo reservations Christian Decker has with actually doing the math) can help improve payment success even with no accurate knowledge of the channel state.\n>\n> > You don't even have\n> > to publish update_channels very often, say every hour or day,\n> > depending on the capacity and usage of the channel.\n>\n> This greatly increases bandwidth use for gossip, though.\n> In addition, most of the time the information will not be useful, since it is not likely I will need the accurate information about this channel state if I never have to make a payment that will route through that channel.\n>\n> Regards,\n> ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Fulgurite: ideas for making a more flexible Lightning Network protocol",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Trey Del Bonis"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 60228
        }
    },
    {
        "title": "[Lightning-dev] Fwd: Fulgurite: ideas for making a more flexible Lightning Network protocol",
        "thread_messages": [
            {
                "author": "Trey Del Bonis",
                "date": "2018-12-07T01:41:30",
                "message_text_only": "(Resubmitted because it was accidentally auto-discarded.)\n\nHello list and ZmnSCPxj,\n\n>Non-participants cannot safely (non-custodially) use any such \"shared-ownership update system\" and any subsystems within it since they have no power to refuse to sign off an invalid state transition.\n\nI'm not trying to solve that problem.  Although I don't foresee it\nbeing difficult to allow participants to cooperatively join channels\nin a procedure like a splice, the output would be to a (n+1)-of-(n+1)\nmultisig address (or alternatively, -1 for leaving channels).\n\n>*However*, I wonder if Fulgurite adds more complexity than necessary.\n\nI believe that the step up in complexity is justified given the change\nin how we express information in channels.\n\n>2-party shared-ownership update systems (\"channels\") are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.\n\nYou're right.  The point of bringing multiparty channels into this\ndiscussion was to say \"here's how we'd do it in Fulgurite if somebody\nwanted to\", it just requires a lot more coordination that not every\nenvironment would be able to have.  Points of failure, etc.\n\n>Burchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.\n\nThat's true.  My construction should still be able to do\nBurchert-Decker-Wattenhofer exactly as described with a little work\nusing the same primitives, although I haven't gone out of my way yet\nto formulate how to do it yet since it's a little auxiliary to what\nwe've been wanting to do with subchannels here at the DCI.  One thing\nwe've talked about is if you and your counterparty want to route\npayments through each other but also want to enter into discreet log\ncontracts, it might make sense to set up a subchannel for each purpose\nso you don't have to re-sign for all the potential outcomes for the\nDLCs (slow!) every time you add/remove an HTLC.  Only the routing\n(sub)channel would be announced to the routing network.\n\n>Code speaks louder than words.\n\nOf course. :)\n\n>CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n>It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n>In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.\n\nRestrictions regarding when to publish could be managed at a higher\nlevel.  What Fulgurite is trying to solve is how to manage the state\nnegotiation rather than the high-level logic about when exactly to\npublish commitment txs.  Maybe we should slightly alter the mechanics\nfor how HTLC expiry works in-channel vs on-chain for this problem?\n\nI'll admit that there's still a few unknowns that I have yet to think\nabout and figure out how to deal with, like this.  But it's my\nintuition that there's probably a simple solution just by making sure\nthe right checks happen in the right places.\n\n- Trey Del Bonis\n\nOn Thu, Dec 6, 2018 at 6:20 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning list, and also Trey,\n>\n> I confirmed that Trey accidentally replied only to me, but intended to reply to the list.\n>\n> > > Burchert-Decker-Wattenhofer channel factories are essentially multiparty (> 2 participants) \"channels\" (\"offchain updateable cryptocurrency systems\") with multiple \"child\" 2-party channels. In general though having multiple channels between the same 2 participants is not as valuable (which is why Burchert-Decker-Wattenhofer only has two levels in the hierarchy, and why the parent level is multiparty while the child level is 2-party).\n> >\n> > Where I was going with the paper is to figure out some of the details\n> > surrounding how to actually implement the protocols described by the\n> > more formal reasearch in the area and leave space in the design for\n> > other protocols that have yet to be designed to be implemented without\n> > having to do a large overhaul of the protocol. If we want to go and\n> > do Burchert-Decker-Wattenhofer-style channel factories we just have to\n> > describe it in terms of manipulating the Fulgurite state graph,\n> > without everyone in the channel actually having to understand\n> > Burchert-Decker-Wattenhofer. Note that Fulgurite subchannels are\n> > expected to have only a subset of the participants of their parents.\n>\n> In effect, Fulgurite simply generalizes Lightning shared-ownership update systems (\"channels\").\n> The insight effectively is that:\n>\n> 1.  Any contract of interest to participants of a single \"shared-ownership update system\" can be done, as long as the contract is enforceable onchain.\n> 2.  The \"shared-ownership update system\" itself is a contract that is enforceable onchain.\n> 3.  Therefore, a \"shared-ownership update system\" can contain \"shared-ownership update systems\" of interest to its participants.\n>\n> So \"subsystems\" here can have the same set of participants, or a subset of participants.\n> Non-participants cannot safely (non-custodially) use any such \"shared-ownership update system\" and any subsystems within it since they have no power to refuse to sign off an invalid state transition.\n>\n> *However*, I wonder if Fulgurite adds more complexity than necessary.\n>\n> 2-party shared-ownership update systems (\"channels\") are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.\n>\n> Burchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.\n>\n>\n> > > Of note is that the existing update protocols can carry almost any Bitcoin-enforceable contract, including the same contracts used to enforce them. This is what allows update protocols to \"nest\" as in Burchert-Decker-Wattenhofer (or your concept of \"parent\" and \"child\" channels).\n> >\n> > Of course. But unless I'm mistaken I haven't seen any practical\n> > implentations of it yet, which is what I'm attempting to do. I know I\n> > won't get much adoption without BOLT support, but that's not a goal in\n> > the short term at least.\n>\n> Code speaks louder than words.\n>\n> > > There are some important details like the fact that Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on their transported contracts, and most contracts cannot be transported across systems (HTLCs can but with longer timelocks for each step).\n> >\n> > Building transactions might not be able to be 100% transparent to the\n> > partition behavior, but I don't really think that's a major\n> > restriction we need to worry about right now. Partitions talk about\n> > their on-chain representation at a relatively high level (see the\n> > `Contract` enum in the `core` crate) and the transaction builder (yet\n> > to be written) figures out how to implement that.\n>\n> I believe it *is* important to worry about it right now.\n> The only objection I have to Decker-Russell-Osuntokun is that it adds an additional CSV requirement to transported contracts.\n> Otherwise it is strictly superior to Poon-Dryja.\n> CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n> It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n> In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.\n>\n> Basically:\n>\n> 1.  Any absolute timelocked contract implies a timeout for the lifetime of the Fulgurite system/channel it is in.\n> 2.  The contract must be fulfilled via a non-timelocked branch before that lifetime.\n> 3.  If not fulfilled via a non-timelocked branch, the Fulgurite system must collapse onchain 1 block before the lifetime.\n> 4.  If the Fulgurite system is based on Decker-Wattenhofer or Decker-Russell-Osuntokun, it must collapse onchain N+1 blocks before the lifetime, where N is the CSV timeout for the update system used.\n>\n>\n>\n> Regards,\n> ZmnSCPxj\n>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Fulgurite: ideas for making a more flexible Lightning Network protocol",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Trey Del Bonis"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8668
        }
    },
    {
        "title": "[Lightning-dev] OpenCAP alias integrations with invoices/destination",
        "thread_messages": [
            {
                "author": "Lane Wagner",
                "date": "2018-12-07T13:14:20",
                "message_text_only": "Im working on a protocol that allows users to host crypto public addresses,\nusing a standard DNS lookup schema. It offers some advantages over\nOpenAlias and I'm hopeful that we will see actual adoption.\n\nI want users to be able to post lightning invoices as well, although I know\nthis is difficult because typically invoices must be generated uniquely for\neach payment. I was thinking maybe posting a destination could be good, so\nthat people can open channels with you, but then people with existing\nchannels still couldnt send to you.\n\nDoes anyone have thoughts on this?\n\nProtocol: https://GitHub.com/OpenCAP/protocol (link to discord for\ndiscussion is there)\n\nImplementation: https://ogdolo.com\n\nOpen source implementation: https://GitHub.com/OpenCAP/go-server\n\n\nOn Fri, Dec 7, 2018, 5:00 AM <\nlightning-dev-request at lists.linuxfoundation.org wrote:\n\n> Send Lightning-dev mailing list submissions to\n>         lightning-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> or, via email, send a message with subject or body 'help' to\n>         lightning-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         lightning-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: Reason for having HMACs in Sphinx (Christian Decker)\n>    2. Re: Fulgurite: ideas for making a more flexible   Lightning\n>       Network protocol (ZmnSCPxj)\n>    3. Fwd: Fulgurite: ideas for making a more flexible Lightning\n>       Network protocol (Trey Del Bonis)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Thu, 06 Dec 2018 16:24:20 +0100\n> From: Christian Decker <decker.christian at gmail.com>\n> To: Corn? Plooy <corne at bitonic.nl>, ZmnSCPxj    <ZmnSCPxj at protonmail.com>\n> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>         <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] Reason for having HMACs in Sphinx\n> Message-ID: <875zw6adaz.fsf at gmail.com>\n> Content-Type: text/plain; charset=utf-8\n>\n> Corn? Plooy <corne at bitonic.nl> writes:\n>\n> >> The total_decorrelation_secrets serves as the payer-generated shared\n> >> secret between payer and payee.  B cannot learn this, and thus cannot\n> >> fake its own secret.  Even if it instead offers ((I + K[A]) + k[z] *\n> >> G) for a new secret k[z], it cannot know how to change\n> >> total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.\n> >>\n> > The way things are now, the ephemeral key generation and the payment\n> > hash/preimage generation are completely unrelated. This is what allows\n> > an attacker to use the same payment hash, and use his own ephemeral key\n> > pair to create a new onion packet around it.\n>\n> That is correct, one is generated by the recipient (secret and preimage)\n> and the other one is generated by the sender (ephemeral key). Mixing the\n> two seems very unwise, since the sender has very little control over\n> what the effective ephemeral key that is going to be used for the last\n> hop. This is the same issue that we have with rendez-vous routing, i.e.,\n> that if we require the ephemeral key to be something specific at a given\n> node we'd be breaking the hardness assumption of for the ephemeral key\n> rotation.\n>\n> > Primarily, path decorrelation replaces the payment hash/preimage part.\n> > Maybe I still don't understand something, but if that's the only thing\n> > (without changing the ephemeral key / onion shared secret generation),\n> > attacking the direct neighbor should still work; in your case, B would\n> > still offer ((I + K[A]) + K[B]) to C, with an onion packet B created\n> > himself. I'm not familiar enough with the path correlation to understand\n> > what happens after step 6, but for C it looks the same, so she should do\n> > the same.\n> >\n> >\n> > I do see that, if you couple the \"H\"TLC payment secret generation to the\n> > onion shared secret generation, you can make the attack impossible. Do I\n> > understand correctly that this is the idea? After all, C still needs to\n> > receive k somehow; my crypto math isn't that good, but my intuitive\n> > guess is that i + k is the secret that allows C to claim funds locked in\n> > ((I + K[A]) + K[B]) =? (i + (k[a] + k[b])) * G. If k is submitted from A\n> > to C through some mechanism that replaces the current ephemeral key\n> > system, then I understand what you're at.\n>\n> I can't quite follow where we would be mixing in the ephemeral key here,\n> could you elaborate on that?\n>\n> > Assuming this is the case, it's pretty neat. I do wonder how it\n> > interacts with rendezvous routing. If the sender and receiver each\n> > create the k[..] values for their own part of the route, can the\n> > receiver-generated onion packet still use points of the form ((I + K[A])\n> > + K[B]), including K[..] values related to the sender side? I need to\n> > dig deeper into this path decorrelation idea.\n>\n> Since we have very little control over what ephemeral key will actually\n> be presented to the last hop if we have a multi-hop route, we can't\n> really hide any information in the ephemeral key itself. What we could\n> do is change the way the last hop generates the shared secret from it,\n> i.e., have a last hop mode and a forwarding hop mode, and mix in the\n> payment secret somehow, but I can't think of a good way to do that, and\n> it seems contorted. Let's just have the sender prove knowledge of the\n> original invoice by adding a TLV field with a shared secret from the\n> invoice instead.\n>\n> Cheers,\n> Christian\n>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Thu, 06 Dec 2018 23:22:57 +0000\n> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> To: Trey Del Bonis <j.delbonis.3 at gmail.com>\n> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>         <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] Fulgurite: ideas for making a more\n>         flexible        Lightning Network protocol\n> Message-ID:\n>\n> <qyU2TN0y6zXLjNtCrgEwlNjJh9WvMEnHLGoLEnS4c_9OXh8hyEn-gxnAwloz2cjUT1aedkonILtSJingtEucQYQiT6Y0wUgwZWkRmSKK_FA=@\n> protonmail.com>\n>\n> Content-Type: text/plain; charset=UTF-8\n>\n> Good morning Trey,\n> > One thing\n> > we've talked about is if you and your counterparty want to route\n> > payments through each other but also want to enter into discreet log\n> > contracts, it might make sense to set up a subchannel for each purpose\n> > so you don't have to re-sign for all the potential outcomes for the\n> > DLCs (slow!) every time you add/remove an HTLC. Only the routing\n> > (sub)channel would be announced to the routing network.\n>\n> Of note, the routing gossip is not trust-based.\n> Instead, part of the routing gossip is the block and transaction and\n> output on which the channel is anchored onchain.\n> Nodes check if the specified txo is unspent, and matches the purported\n> capacity of the channel.\n> Once a channel outpoint is spent, nodes automatically remove it from their\n> maps.\n>\n> In a world with Burchert-Decker-Wattenhofer factories, the factory would\n> have an onchain txo.\n> Gossip would contain all the channels in the factory, and would be signed\n> by the same signatories as the onchain txo.\n> Nodes would check that the channels purported to be contained in the\n> factory sum up to the value of this txo.\n>\n> I suppose that could be relaxed, so that the channels purported to be in\n> the factory would sum up to less than or equal to the value of the channel\n> factory txo instead.\n> This would allow a Fulgurite system to allocate only part of its funds to\n> Lightning-visible routing nodes.\n>\n> It strikes me that the issue of re-signing the DLC subcontracts could be\n> avoided if you use `SIGHASH_NOINPUT`.\n> The same signatories could be used for the DLCs, and even if the update\n> transaction changes, you can reanchor the DLC subcontracts with\n> `SIGHASH_NOINPUT`.\n>\n> > > Code speaks louder than words.\n> >\n> > Of course. :)\n>\n> Yes, so feel free to ignore whatever I say, since I have not coded for a\n> while.\n>\n> > > CSV requirements are a time-based requirement that affect the behavior\n> of absolute timelocks used by HTLCs.\n> > > It is better to admit this earlier than later, since it becomes\n> possible as an attack point if you do not take care to pay attention to the\n> CSV requirement.\n> > > In particular, timelocked contracts need to be published onchain\n> before the timeout expires, and a N-block CSV requirement then means you\n> have to publish onchain N+1 blocks before the absolute timelock expires.\n> >\n> > Restrictions regarding when to publish could be managed at a higher\n> > level. What Fulgurite is trying to solve is how to manage the state\n> > negotiation rather than the high-level logic about when exactly to\n> > publish commitment txs. Maybe we should slightly alter the mechanics\n> > for how HTLC expiry works in-channel vs on-chain for this problem?\n>\n> At minimum the lower-level system would have to alert the higher-level\n> system that a time-sensitive contract needs to collapse the Fulgrite system\n> or else it would not be possible to enforce the timelock.\n>\n> Since contracts inside a multiparticipant updatable system can be\n> cancelled by the agreement of all participants, I suppose the higher layer\n> can decide to demand an update that the timelock be followed within the\n> multiparticipant updatable system.\n> But the upper layer needs to be informed of the latest time that the\n> contract can be enforced onchain.\n> Your alternative is that the upper layer needs to know whether the lower\n> layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV\n> requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can\n> argue is a layering violation.\n> Further the exact specs (how many blocks do all participants agree is\n> reasonable for the CSV requirement?) would vary.\n>\n> So it seems to me better to move time-sensitivity to Fulgurite than to\n> higher layers.\n> Higher layers can simply be concerned about what contracts it wants to\n> enter into.\n> The higher layer informs the Fulgurite layer of the shortest absolute\n> timelock in each contract it enters into.\n> The Fulgurite layer then returns to the higher layer the latest\n> blockheight at which it can still safely collapse the Fulgurite system, or\n> an error that the absolute timelock is too near and is already not\n> enforceable at the Fulgurite layer.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Thu, 6 Dec 2018 20:41:30 -0500\n> From: Trey Del Bonis <j.delbonis.3 at gmail.com>\n> To: lightning-dev at lists.linuxfoundation.org\n> Subject: [Lightning-dev] Fwd: Fulgurite: ideas for making a more\n>         flexible Lightning Network protocol\n> Message-ID:\n>         <CAFUsdzpDzwQF=n5zVWOezN35Ng0htw=\n> CWbyeNaoryqxmOp1skA at mail.gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> (Resubmitted because it was accidentally auto-discarded.)\n>\n> Hello list and ZmnSCPxj,\n>\n> >Non-participants cannot safely (non-custodially) use any such\n> \"shared-ownership update system\" and any subsystems within it since they\n> have no power to refuse to sign off an invalid state transition.\n>\n> I'm not trying to solve that problem.  Although I don't foresee it\n> being difficult to allow participants to cooperatively join channels\n> in a procedure like a splice, the output would be to a (n+1)-of-(n+1)\n> multisig address (or alternatively, -1 for leaving channels).\n>\n> >*However*, I wonder if Fulgurite adds more complexity than necessary.\n>\n> I believe that the step up in complexity is justified given the change\n> in how we express information in channels.\n>\n> >2-party shared-ownership update systems (\"channels\") are best, since\n> everyone has to sign.  Fewer participants means fewer points of failure.\n> Larger participant sets mean it is more likely somebody will be absent when\n> any one of them wants to update the shared-ownership update system.\n>\n> You're right.  The point of bringing multiparty channels into this\n> discussion was to say \"here's how we'd do it in Fulgurite if somebody\n> wanted to\", it just requires a lot more coordination that not every\n> environment would be able to have.  Points of failure, etc.\n>\n> >Burchert-Decker-Wattenhofer channel factories have the advantage that\n> once the channels within the factory have been set up, participants can\n> then be absent, and only their channels are affected.\n>\n> That's true.  My construction should still be able to do\n> Burchert-Decker-Wattenhofer exactly as described with a little work\n> using the same primitives, although I haven't gone out of my way yet\n> to formulate how to do it yet since it's a little auxiliary to what\n> we've been wanting to do with subchannels here at the DCI.  One thing\n> we've talked about is if you and your counterparty want to route\n> payments through each other but also want to enter into discreet log\n> contracts, it might make sense to set up a subchannel for each purpose\n> so you don't have to re-sign for all the potential outcomes for the\n> DLCs (slow!) every time you add/remove an HTLC.  Only the routing\n> (sub)channel would be announced to the routing network.\n>\n> >Code speaks louder than words.\n>\n> Of course. :)\n>\n> >CSV requirements are a time-based requirement that affect the behavior of\n> absolute timelocks used by HTLCs.\n> >It is better to admit this earlier than later, since it becomes possible\n> as an attack point if you do not take care to pay attention to the CSV\n> requirement.\n> >In particular, timelocked contracts need to be published onchain before\n> the timeout expires, and a N-block CSV requirement then means you have to\n> publish onchain N+1 blocks *before* the absolute timelock expires.\n>\n> Restrictions regarding when to publish could be managed at a higher\n> level.  What Fulgurite is trying to solve is how to manage the state\n> negotiation rather than the high-level logic about when exactly to\n> publish commitment txs.  Maybe we should slightly alter the mechanics\n> for how HTLC expiry works in-channel vs on-chain for this problem?\n>\n> I'll admit that there's still a few unknowns that I have yet to think\n> about and figure out how to deal with, like this.  But it's my\n> intuition that there's probably a simple solution just by making sure\n> the right checks happen in the right places.\n>\n> - Trey Del Bonis\n>\n> On Thu, Dec 6, 2018 at 6:20 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > Good morning list, and also Trey,\n> >\n> > I confirmed that Trey accidentally replied only to me, but intended to\n> reply to the list.\n> >\n> > > > Burchert-Decker-Wattenhofer channel factories are essentially\n> multiparty (> 2 participants) \"channels\" (\"offchain updateable\n> cryptocurrency systems\") with multiple \"child\" 2-party channels. In general\n> though having multiple channels between the same 2 participants is not as\n> valuable (which is why Burchert-Decker-Wattenhofer only has two levels in\n> the hierarchy, and why the parent level is multiparty while the child level\n> is 2-party).\n> > >\n> > > Where I was going with the paper is to figure out some of the details\n> > > surrounding how to actually implement the protocols described by the\n> > > more formal reasearch in the area and leave space in the design for\n> > > other protocols that have yet to be designed to be implemented without\n> > > having to do a large overhaul of the protocol. If we want to go and\n> > > do Burchert-Decker-Wattenhofer-style channel factories we just have to\n> > > describe it in terms of manipulating the Fulgurite state graph,\n> > > without everyone in the channel actually having to understand\n> > > Burchert-Decker-Wattenhofer. Note that Fulgurite subchannels are\n> > > expected to have only a subset of the participants of their parents.\n> >\n> > In effect, Fulgurite simply generalizes Lightning shared-ownership\n> update systems (\"channels\").\n> > The insight effectively is that:\n> >\n> > 1.  Any contract of interest to participants of a single\n> \"shared-ownership update system\" can be done, as long as the contract is\n> enforceable onchain.\n> > 2.  The \"shared-ownership update system\" itself is a contract that is\n> enforceable onchain.\n> > 3.  Therefore, a \"shared-ownership update system\" can contain\n> \"shared-ownership update systems\" of interest to its participants.\n> >\n> > So \"subsystems\" here can have the same set of participants, or a subset\n> of participants.\n> > Non-participants cannot safely (non-custodially) use any such\n> \"shared-ownership update system\" and any subsystems within it since they\n> have no power to refuse to sign off an invalid state transition.\n> >\n> > *However*, I wonder if Fulgurite adds more complexity than necessary.\n> >\n> > 2-party shared-ownership update systems (\"channels\") are best, since\n> everyone has to sign.  Fewer participants means fewer points of failure.\n> Larger participant sets mean it is more likely somebody will be absent when\n> any one of them wants to update the shared-ownership update system.\n> >\n> > Burchert-Decker-Wattenhofer channel factories have the advantage that\n> once the channels within the factory have been set up, participants can\n> then be absent, and only their channels are affected.\n> >\n> >\n> > > > Of note is that the existing update protocols can carry almost any\n> Bitcoin-enforceable contract, including the same contracts used to enforce\n> them. This is what allows update protocols to \"nest\" as in\n> Burchert-Decker-Wattenhofer (or your concept of \"parent\" and \"child\"\n> channels).\n> > >\n> > > Of course. But unless I'm mistaken I haven't seen any practical\n> > > implentations of it yet, which is what I'm attempting to do. I know I\n> > > won't get much adoption without BOLT support, but that's not a goal in\n> > > the short term at least.\n> >\n> > Code speaks louder than words.\n> >\n> > > > There are some important details like the fact that\n> Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on\n> their transported contracts, and most contracts cannot be transported\n> across systems (HTLCs can but with longer timelocks for each step).\n> > >\n> > > Building transactions might not be able to be 100% transparent to the\n> > > partition behavior, but I don't really think that's a major\n> > > restriction we need to worry about right now. Partitions talk about\n> > > their on-chain representation at a relatively high level (see the\n> > > `Contract` enum in the `core` crate) and the transaction builder (yet\n> > > to be written) figures out how to implement that.\n> >\n> > I believe it *is* important to worry about it right now.\n> > The only objection I have to Decker-Russell-Osuntokun is that it adds an\n> additional CSV requirement to transported contracts.\n> > Otherwise it is strictly superior to Poon-Dryja.\n> > CSV requirements are a time-based requirement that affect the behavior\n> of absolute timelocks used by HTLCs.\n> > It is better to admit this earlier than later, since it becomes possible\n> as an attack point if you do not take care to pay attention to the CSV\n> requirement.\n> > In particular, timelocked contracts need to be published onchain before\n> the timeout expires, and a N-block CSV requirement then means you have to\n> publish onchain N+1 blocks *before* the absolute timelock expires.\n> >\n> > Basically:\n> >\n> > 1.  Any absolute timelocked contract implies a timeout for the lifetime\n> of the Fulgurite system/channel it is in.\n> > 2.  The contract must be fulfilled via a non-timelocked branch before\n> that lifetime.\n> > 3.  If not fulfilled via a non-timelocked branch, the Fulgurite system\n> must collapse onchain 1 block before the lifetime.\n> > 4.  If the Fulgurite system is based on Decker-Wattenhofer or\n> Decker-Russell-Osuntokun, it must collapse onchain N+1 blocks before the\n> lifetime, where N is the CSV timeout for the update system used.\n> >\n> >\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n>\n>\n> ------------------------------\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> End of Lightning-dev Digest, Vol 40, Issue 8\n> ********************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181207/bd4e84c8/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-08T19:13:59",
                "message_text_only": "Good morning Lane,\n\nI believe Rusty is creating a spec for reusable payment offers, which would let payers request for BOLT11 invoices over the LN network.\nIn addition, I believe Laolu and friends are building some spontaneous-payment protocol without proof-of-payment, although I am uncertain the details.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, December 7, 2018 9:14 PM, Lane Wagner <lane.c.wagner at gmail.com> wrote:\n\n> Im working on a protocol that allows users to host crypto public addresses, using a standard DNS lookup schema. It offers some advantages over OpenAlias and I'm hopeful that we will see actual adoption.\n>\n> I want users to be able to post lightning invoices as well, although I know this is difficult because typically invoices must be generated uniquely for each payment. I was thinking maybe posting a destination could be good, so that people can open channels with you, but then people with existing channels still couldnt send to you.\n>\n> Does anyone have thoughts on this?\n>\n> Protocol: https://GitHub.com/OpenCAP/protocol (link to discord for discussion is there)\n>\n> Implementation: https://ogdolo.com\n>\n> Open source implementation: https://GitHub.com/OpenCAP/go-server\n>\n> On Fri, Dec 7, 2018, 5:00 AM <lightning-dev-request at lists.linuxfoundation.org wrote:\n>\n>> Send Lightning-dev mailing list submissions to\n>>         lightning-dev at lists.linuxfoundation.org\n>>\n>> To subscribe or unsubscribe via the World Wide Web, visit\n>>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> or, via email, send a message with subject or body 'help' to\n>>         lightning-dev-request at lists.linuxfoundation.org\n>>\n>> You can reach the person managing the list at\n>>         lightning-dev-owner at lists.linuxfoundation.org\n>>\n>> When replying, please edit your Subject line so it is more specific\n>> than \"Re: Contents of Lightning-dev digest...\"\n>>\n>> Today's Topics:\n>>\n>>    1. Re: Reason for having HMACs in Sphinx (Christian Decker)\n>>    2. Re: Fulgurite: ideas for making a more flexible   Lightning\n>>       Network protocol (ZmnSCPxj)\n>>    3. Fwd: Fulgurite: ideas for making a more flexible Lightning\n>>       Network protocol (Trey Del Bonis)\n>>\n>> ----------------------------------------------------------------------\n>>\n>> Message: 1\n>> Date: Thu, 06 Dec 2018 16:24:20 +0100\n>> From: Christian Decker <decker.christian at gmail.com>\n>> To: Corn? Plooy <corne at bitonic.nl>, ZmnSCPxj    <ZmnSCPxj at protonmail.com>\n>> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>>         <lightning-dev at lists.linuxfoundation.org>\n>> Subject: Re: [Lightning-dev] Reason for having HMACs in Sphinx\n>> Message-ID: <875zw6adaz.fsf at gmail.com>\n>> Content-Type: text/plain; charset=utf-8\n>>\n>> Corn? Plooy <corne at bitonic.nl> writes:\n>>\n>>>> The total_decorrelation_secrets serves as the payer-generated shared\n>>>> secret between payer and payee.  B cannot learn this, and thus cannot\n>>>> fake its own secret.  Even if it instead offers ((I + K[A]) + k[z] *\n>>>> G) for a new secret k[z], it cannot know how to change\n>>>> total_decorrelation_secrets from k[a] + k[b] to k[a] + k[z] instead.\n>>>>\n>>> The way things are now, the ephemeral key generation and the payment\n>>> hash/preimage generation are completely unrelated. This is what allows\n>>> an attacker to use the same payment hash, and use his own ephemeral key\n>>> pair to create a new onion packet around it.\n>>\n>> That is correct, one is generated by the recipient (secret and preimage)\n>> and the other one is generated by the sender (ephemeral key). Mixing the\n>> two seems very unwise, since the sender has very little control over\n>> what the effective ephemeral key that is going to be used for the last\n>> hop. This is the same issue that we have with rendez-vous routing, i.e.,\n>> that if we require the ephemeral key to be something specific at a given\n>> node we'd be breaking the hardness assumption of for the ephemeral key\n>> rotation.\n>>\n>>> Primarily, path decorrelation replaces the payment hash/preimage part.\n>>> Maybe I still don't understand something, but if that's the only thing\n>>> (without changing the ephemeral key / onion shared secret generation),\n>>> attacking the direct neighbor should still work; in your case, B would\n>>> still offer ((I + K[A]) + K[B]) to C, with an onion packet B created\n>>> himself. I'm not familiar enough with the path correlation to understand\n>>> what happens after step 6, but for C it looks the same, so she should do\n>>> the same.\n>>>\n>>>\n>>> I do see that, if you couple the \"H\"TLC payment secret generation to the\n>>> onion shared secret generation, you can make the attack impossible. Do I\n>>> understand correctly that this is the idea? After all, C still needs to\n>>> receive k somehow; my crypto math isn't that good, but my intuitive\n>>> guess is that i + k is the secret that allows C to claim funds locked in\n>>> ((I + K[A]) + K[B]) =? (i + (k[a] + k[b])) * G. If k is submitted from A\n>>> to C through some mechanism that replaces the current ephemeral key\n>>> system, then I understand what you're at.\n>>\n>> I can't quite follow where we would be mixing in the ephemeral key here,\n>> could you elaborate on that?\n>>\n>>> Assuming this is the case, it's pretty neat. I do wonder how it\n>>> interacts with rendezvous routing. If the sender and receiver each\n>>> create the k[..] values for their own part of the route, can the\n>>> receiver-generated onion packet still use points of the form ((I + K[A])\n>>> + K[B]), including K[..] values related to the sender side? I need to\n>>> dig deeper into this path decorrelation idea.\n>>\n>> Since we have very little control over what ephemeral key will actually\n>> be presented to the last hop if we have a multi-hop route, we can't\n>> really hide any information in the ephemeral key itself. What we could\n>> do is change the way the last hop generates the shared secret from it,\n>> i.e., have a last hop mode and a forwarding hop mode, and mix in the\n>> payment secret somehow, but I can't think of a good way to do that, and\n>> it seems contorted. Let's just have the sender prove knowledge of the\n>> original invoice by adding a TLV field with a shared secret from the\n>> invoice instead.\n>>\n>> Cheers,\n>> Christian\n>>\n>> ------------------------------\n>>\n>> Message: 2\n>> Date: Thu, 06 Dec 2018 23:22:57 +0000\n>> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>> To: Trey Del Bonis <j.delbonis.3 at gmail.com>\n>> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>>         <lightning-dev at lists.linuxfoundation.org>\n>> Subject: Re: [Lightning-dev] Fulgurite: ideas for making a more\n>>         flexible        Lightning Network protocol\n>> Message-ID:\n>>         <qyU2TN0y6zXLjNtCrgEwlNjJh9WvMEnHLGoLEnS4c_9OXh8hyEn-gxnAwloz2cjUT1aedkonILtSJingtEucQYQiT6Y0wUgwZWkRmSKK_FA=@protonmail.com>\n>>\n>> Content-Type: text/plain; charset=UTF-8\n>>\n>> Good morning Trey,\n>>> One thing\n>>> we've talked about is if you and your counterparty want to route\n>>> payments through each other but also want to enter into discreet log\n>>> contracts, it might make sense to set up a subchannel for each purpose\n>>> so you don't have to re-sign for all the potential outcomes for the\n>>> DLCs (slow!) every time you add/remove an HTLC. Only the routing\n>>> (sub)channel would be announced to the routing network.\n>>\n>> Of note, the routing gossip is not trust-based.\n>> Instead, part of the routing gossip is the block and transaction and output on which the channel is anchored onchain.\n>> Nodes check if the specified txo is unspent, and matches the purported capacity of the channel.\n>> Once a channel outpoint is spent, nodes automatically remove it from their maps.\n>>\n>> In a world with Burchert-Decker-Wattenhofer factories, the factory would have an onchain txo.\n>> Gossip would contain all the channels in the factory, and would be signed by the same signatories as the onchain txo.\n>> Nodes would check that the channels purported to be contained in the factory sum up to the value of this txo.\n>>\n>> I suppose that could be relaxed, so that the channels purported to be in the factory would sum up to less than or equal to the value of the channel factory txo instead.\n>> This would allow a Fulgurite system to allocate only part of its funds to Lightning-visible routing nodes.\n>>\n>> It strikes me that the issue of re-signing the DLC subcontracts could be avoided if you use `SIGHASH_NOINPUT`.\n>> The same signatories could be used for the DLCs, and even if the update transaction changes, you can reanchor the DLC subcontracts with `SIGHASH_NOINPUT`.\n>>\n>>> > Code speaks louder than words.\n>>>\n>>> Of course. :)\n>>\n>> Yes, so feel free to ignore whatever I say, since I have not coded for a while.\n>>\n>>> > CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n>>> > It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n>>> > In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks before the absolute timelock expires.\n>>>\n>>> Restrictions regarding when to publish could be managed at a higher\n>>> level. What Fulgurite is trying to solve is how to manage the state\n>>> negotiation rather than the high-level logic about when exactly to\n>>> publish commitment txs. Maybe we should slightly alter the mechanics\n>>> for how HTLC expiry works in-channel vs on-chain for this problem?\n>>\n>> At minimum the lower-level system would have to alert the higher-level system that a time-sensitive contract needs to collapse the Fulgrite system or else it would not be possible to enforce the timelock.\n>>\n>> Since contracts inside a multiparticipant updatable system can be cancelled by the agreement of all participants, I suppose the higher layer can decide to demand an update that the timelock be followed within the multiparticipant updatable system.\n>> But the upper layer needs to be informed of the latest time that the contract can be enforced onchain.\n>> Your alternative is that the upper layer needs to know whether the lower layer is using Poon-Dryja (no CSV requirement) or Decker-Wattenhofer (CSV requirement) or Decker-Russell-Osuntokun (CSV requirement), which you can argue is a layering violation.\n>> Further the exact specs (how many blocks do all participants agree is reasonable for the CSV requirement?) would vary.\n>>\n>> So it seems to me better to move time-sensitivity to Fulgurite than to higher layers.\n>> Higher layers can simply be concerned about what contracts it wants to enter into.\n>> The higher layer informs the Fulgurite layer of the shortest absolute timelock in each contract it enters into.\n>> The Fulgurite layer then returns to the higher layer the latest blockheight at which it can still safely collapse the Fulgurite system, or an error that the absolute timelock is too near and is already not enforceable at the Fulgurite layer.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>> ------------------------------\n>>\n>> Message: 3\n>> Date: Thu, 6 Dec 2018 20:41:30 -0500\n>> From: Trey Del Bonis <j.delbonis.3 at gmail.com>\n>> To: lightning-dev at lists.linuxfoundation.org\n>> Subject: [Lightning-dev] Fwd: Fulgurite: ideas for making a more\n>>         flexible Lightning Network protocol\n>> Message-ID:\n>>         <CAFUsdzpDzwQF=n5zVWOezN35Ng0htw=CWbyeNaoryqxmOp1skA at mail.gmail.com>\n>> Content-Type: text/plain; charset=\"UTF-8\"\n>>\n>> (Resubmitted because it was accidentally auto-discarded.)\n>>\n>> Hello list and ZmnSCPxj,\n>>\n>>>Non-participants cannot safely (non-custodially) use any such \"shared-ownership update system\" and any subsystems within it since they have no power to refuse to sign off an invalid state transition.\n>>\n>> I'm not trying to solve that problem.  Although I don't foresee it\n>> being difficult to allow participants to cooperatively join channels\n>> in a procedure like a splice, the output would be to a (n+1)-of-(n+1)\n>> multisig address (or alternatively, -1 for leaving channels).\n>>\n>>>*However*, I wonder if Fulgurite adds more complexity than necessary.\n>>\n>> I believe that the step up in complexity is justified given the change\n>> in how we express information in channels.\n>>\n>>>2-party shared-ownership update systems (\"channels\") are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.\n>>\n>> You're right.  The point of bringing multiparty channels into this\n>> discussion was to say \"here's how we'd do it in Fulgurite if somebody\n>> wanted to\", it just requires a lot more coordination that not every\n>> environment would be able to have.  Points of failure, etc.\n>>\n>>>Burchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.\n>>\n>> That's true.  My construction should still be able to do\n>> Burchert-Decker-Wattenhofer exactly as described with a little work\n>> using the same primitives, although I haven't gone out of my way yet\n>> to formulate how to do it yet since it's a little auxiliary to what\n>> we've been wanting to do with subchannels here at the DCI.  One thing\n>> we've talked about is if you and your counterparty want to route\n>> payments through each other but also want to enter into discreet log\n>> contracts, it might make sense to set up a subchannel for each purpose\n>> so you don't have to re-sign for all the potential outcomes for the\n>> DLCs (slow!) every time you add/remove an HTLC.  Only the routing\n>> (sub)channel would be announced to the routing network.\n>>\n>>>Code speaks louder than words.\n>>\n>> Of course. :)\n>>\n>>>CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n>>>It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n>>>In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.\n>>\n>> Restrictions regarding when to publish could be managed at a higher\n>> level.  What Fulgurite is trying to solve is how to manage the state\n>> negotiation rather than the high-level logic about when exactly to\n>> publish commitment txs.  Maybe we should slightly alter the mechanics\n>> for how HTLC expiry works in-channel vs on-chain for this problem?\n>>\n>> I'll admit that there's still a few unknowns that I have yet to think\n>> about and figure out how to deal with, like this.  But it's my\n>> intuition that there's probably a simple solution just by making sure\n>> the right checks happen in the right places.\n>>\n>> - Trey Del Bonis\n>>\n>> On Thu, Dec 6, 2018 at 6:20 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>>>\n>>> Good morning list, and also Trey,\n>>>\n>>> I confirmed that Trey accidentally replied only to me, but intended to reply to the list.\n>>>\n>>> > > Burchert-Decker-Wattenhofer channel factories are essentially multiparty (> 2 participants) \"channels\" (\"offchain updateable cryptocurrency systems\") with multiple \"child\" 2-party channels. In general though having multiple channels between the same 2 participants is not as valuable (which is why Burchert-Decker-Wattenhofer only has two levels in the hierarchy, and why the parent level is multiparty while the child level is 2-party).\n>>> >\n>>> > Where I was going with the paper is to figure out some of the details\n>>> > surrounding how to actually implement the protocols described by the\n>>> > more formal reasearch in the area and leave space in the design for\n>>> > other protocols that have yet to be designed to be implemented without\n>>> > having to do a large overhaul of the protocol. If we want to go and\n>>> > do Burchert-Decker-Wattenhofer-style channel factories we just have to\n>>> > describe it in terms of manipulating the Fulgurite state graph,\n>>> > without everyone in the channel actually having to understand\n>>> > Burchert-Decker-Wattenhofer. Note that Fulgurite subchannels are\n>>> > expected to have only a subset of the participants of their parents.\n>>>\n>>> In effect, Fulgurite simply generalizes Lightning shared-ownership update systems (\"channels\").\n>>> The insight effectively is that:\n>>>\n>>> 1.  Any contract of interest to participants of a single \"shared-ownership update system\" can be done, as long as the contract is enforceable onchain.\n>>> 2.  The \"shared-ownership update system\" itself is a contract that is enforceable onchain.\n>>> 3.  Therefore, a \"shared-ownership update system\" can contain \"shared-ownership update systems\" of interest to its participants.\n>>>\n>>> So \"subsystems\" here can have the same set of participants, or a subset of participants.\n>>> Non-participants cannot safely (non-custodially) use any such \"shared-ownership update system\" and any subsystems within it since they have no power to refuse to sign off an invalid state transition.\n>>>\n>>> *However*, I wonder if Fulgurite adds more complexity than necessary.\n>>>\n>>> 2-party shared-ownership update systems (\"channels\") are best, since everyone has to sign.  Fewer participants means fewer points of failure.  Larger participant sets mean it is more likely somebody will be absent when any one of them wants to update the shared-ownership update system.\n>>>\n>>> Burchert-Decker-Wattenhofer channel factories have the advantage that once the channels within the factory have been set up, participants can then be absent, and only their channels are affected.\n>>>\n>>>\n>>> > > Of note is that the existing update protocols can carry almost any Bitcoin-enforceable contract, including the same contracts used to enforce them. This is what allows update protocols to \"nest\" as in Burchert-Decker-Wattenhofer (or your concept of \"parent\" and \"child\" channels).\n>>> >\n>>> > Of course. But unless I'm mistaken I haven't seen any practical\n>>> > implentations of it yet, which is what I'm attempting to do. I know I\n>>> > won't get much adoption without BOLT support, but that's not a goal in\n>>> > the short term at least.\n>>>\n>>> Code speaks louder than words.\n>>>\n>>> > > There are some important details like the fact that Decker-Wattenhofer and Decker-Russell-Osuntokun impose an extra CSV on their transported contracts, and most contracts cannot be transported across systems (HTLCs can but with longer timelocks for each step).\n>>> >\n>>> > Building transactions might not be able to be 100% transparent to the\n>>> > partition behavior, but I don't really think that's a major\n>>> > restriction we need to worry about right now. Partitions talk about\n>>> > their on-chain representation at a relatively high level (see the\n>>> > `Contract` enum in the `core` crate) and the transaction builder (yet\n>>> > to be written) figures out how to implement that.\n>>>\n>>> I believe it *is* important to worry about it right now.\n>>> The only objection I have to Decker-Russell-Osuntokun is that it adds an additional CSV requirement to transported contracts.\n>>> Otherwise it is strictly superior to Poon-Dryja.\n>>> CSV requirements are a time-based requirement that affect the behavior of absolute timelocks used by HTLCs.\n>>> It is better to admit this earlier than later, since it becomes possible as an attack point if you do not take care to pay attention to the CSV requirement.\n>>> In particular, timelocked contracts need to be published onchain before the timeout expires, and a N-block CSV requirement then means you have to publish onchain N+1 blocks *before* the absolute timelock expires.\n>>>\n>>> Basically:\n>>>\n>>> 1.  Any absolute timelocked contract implies a timeout for the lifetime of the Fulgurite system/channel it is in.\n>>> 2.  The contract must be fulfilled via a non-timelocked branch before that lifetime.\n>>> 3.  If not fulfilled via a non-timelocked branch, the Fulgurite system must collapse onchain 1 block before the lifetime.\n>>> 4.  If the Fulgurite system is based on Decker-Wattenhofer or Decker-Russell-Osuntokun, it must collapse onchain N+1 blocks before the lifetime, where N is the CSV timeout for the update system used.\n>>>\n>>>\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>>\n>> ------------------------------\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>> End of Lightning-dev Digest, Vol 40, Issue 8\n>> ********************************************\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181208/a668a67b/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "OpenCAP alias integrations with invoices/destination",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Lane Wagner"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 41747
        }
    },
    {
        "title": "[Lightning-dev] [META] Organization of 1.1 Spec Effort",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2018-12-10T22:27:30",
                "message_text_only": "Any update on this? It seems like the people who bothered to respond \nwere pretty in favor of not using calls (and, at least based on the \nlatest call doc, which is the only one I've seen, they seem to be only \nsomewhat sparsely attended).\n\nWhen are the regular calls right now, anyway? Probably should just hold \nan IRC meeting at the same time on #lightning-dev.\n\nMatt\n\nOn 11/28/18 2:43 PM, Peter Todd wrote:\n> \n> \n> On November 27, 2018 12:13:27 AM UTC, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n>> +100 for IRC meetings, though, really, I'd much much stronger prefer\n>> substantive discussion happen on GitHub or the mailing list. Doing\n>> finalization in a live meeting is really unfair to those who can't find\n>> the time to attend regularly (or happen to miss the one where that\n>> thing was discussed that they care about).\n> \n> Also keep in mind that textual communication poses less barriers for many people vs. audio/visual meetings. Not everyone wants their face to be seen or voice (literally) heard.\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-12-11T00:48:59",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> Any update on this? It seems like the people who bothered to respond \n> were pretty in favor of not using calls (and, at least based on the \n> latest call doc, which is the only one I've seen, they seem to be only \n> somewhat sparsely attended).\n\nWe always have a representative from Eclair, lnd and c-lightning\n(Fabrice didn't add himself to the attendee list, I've added him now).\nAnd usually several others.\n\n> When are the regular calls right now, anyway? Probably should just hold \n> an IRC meeting at the same time on #lightning-dev.\n\nGlad you asked!  At the Hangouts meeting (about 5 hours ago now), we got\nconsensus to try IRC format for next meeting.  I'll send a proper\nannounce message now.\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Organization of 1.1 Spec Effort",
            "categories": [
                "Lightning-dev",
                "META"
            ],
            "authors": [
                "Rusty Russell",
                "Matt Corallo"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1793
        }
    },
    {
        "title": "[Lightning-dev] Spec Meeting: Tuesday, January 8, 2019 at 19:00:00 UTC (~1hr)",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-12-11T01:11:38",
                "message_text_only": "Hi all,\n\n        As agreed at last spec meeting, the next will be held on IRC:\nfreenode, #lightning-dev.  Since that would be Christmas Eve[1], I\ndeferred it to January[2].  All are welcome!\n\nThe rough ground rules are as follows:\n\n1. I post the agenda to the index about 12 hours prior:\nhttps://docs.google.com/document/d/1oU4wxzGsYd0T084rTXJbedb7Gvdtj4ax638nMkYUmco/edit\n2. People can add to the agenda; make suggestions or ask for edit access.\n3. All spec changes have to pass without objection at this meeting to be\n   included.\n4. There is an exception for spelling & wording fixes, which only\n   require two positive reviews from contributors.\n5. We generally walk through each pending PR and issue, note which ones\n   are acked, and someone applies the approved ones post-meeting.\n6. We also share concerns, upcoming events, implementation headaches on\n   Other Business.\n\nWhile most of the work occurs on the mailing list and github, this\nmeeting has given us a chance to nag each other, discuss directly, and\ncontributes greatly to the bonhomie of Lightning.\n\nLook forward to seeing you there!\nRusty.\n\n[1] Early Christmas morning for me and I doubt my kids will sleep in somehow...\n[2] Here's a timezone converter:\nhttps://www.timeanddate.com/worldclock/meetingdetails.html?year=2019&month=1&day=8&hour=19&min=0&sec=0&p1=5\nAnd here's a Google Calendar link:\nhttps://calendar.google.com/event?action=TEMPLATE&tmeid=dHA5aHV0cXE4dGdnYmQ2OHVjcHJuNmFjdjhfMjAxOTAxMDdUMTkwMDAwWiBydXN0eUBibG9ja3N0cmVhbS5pbw&tmsrc=rusty%40blockstream.io&scp=ALL"
            }
        ],
        "thread_summary": {
            "title": "Spec Meeting: Tuesday, January 8, 2019 at 19:00:00 UTC (~1hr)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1546
        }
    },
    {
        "title": "[Lightning-dev] Minisketch and lightning gossip",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-12-12T02:06:09",
                "message_text_only": "Hi all,\n\n        In case you're bored with the limited range of improvements\ngoing into the 1.1 spec, you might like to ruminate on:\n\n  https://github.com/sipa/minisketch/blob/master/README.md\n\nIt's a library for efficient summaries of data, such as bitcoin\ntransaction gossip.  It has an implementation sweet-spot at 64-bits,\nwhich almost works well for our gossip messages.  I've a straw-man\nprotocol below.\n\n===\n1. type: 260 (`gossip_sync`) (`option_gossip_sync`)\n2. data:\n    * [`32`:`chain_hash`]\n    * [`32`:`latest_block_hash`]\n    * [`minisketch_len`:`minisketch`]\n\nThe `latest_block_hash` is because the whole sync is less reliable if\nthis differs between nodes, so a node may choose to wait, or adapt\naccordingly if the other node is behind.\n\nBecause there is some overhead in maintaining the minisketch, it'd be\nnice if we can have global agreement on the format so each peer need\nonly maintain one (i.e. no seed, no changing encodings depending on\nblock height, etc).\n\nFitting everything we need into 64 bits is possible, with various\ndegrees of ugliness; I've proposed one here:\n\nWe currently use a short_channel_id which has 3-byte block height,\n3-byte txindex, 2-byte output index.  The biggest win is to combine\nblock height & txindex into a \"txnumber since block 500,000\", which only\nneeds about 27 bits per year; 40 bits for this number is sufficient for\nthe forseeable future.  2 bits for type, 1 for channel direction,\nleaving 21 bits for output number and timestamp.\n\nWe can encode output number as N ones followed by a zero followed by\nN*2+1 bits (commonly, this means 2 bits, but future mixers may make this\nmuch larger).  The remaining bits are used as the lower bits of the\ntimestamp[1].\n\nA node announcement is encoded by using the scid of the oldest channel\nassociated with the node, and the direction bit.\n\nUsing this direct encoding (rather than a hash of values) allows us to\nimmediately use an INV-style query, or maybe send automatically the\nstuff the peer doesn't have.\n\nThe required size of the minisketch we send depends on the number of\ndifferences with our peer.  We can use some minimum value (maybe based\non past gossip rates?), and add the number of changes we've received\nsince last time, increasing if we failed to reconstruct a previous one.\n\nThere doesn't need to be consensus between peers on the minisketch size\nthough, since truncated minisketches regrow into whole ones when tossed\nback into the ocean[3].\n\nCheers,\nRusty.\n[1]  You're supposed to refresh gossip every week, 17 bits should\n    be sufficient.   And since the originator controls timestamps\n    they can mitigate collisions themselves.[2]\n[2] I wish I'd insisted we use block numbers for timestamps though\n[3] I may have misunderstood this part, but it's basically magic."
            },
            {
                "author": "Pieter Wuille",
                "date": "2018-12-12T23:34:42",
                "message_text_only": "On Tue, 11 Dec 2018 at 18:07, Rusty Russell <rusty at rustcorp.com.au> wrote:>\n> Hi all,\n>\n>         In case you're bored with the limited range of improvements\n> going into the 1.1 spec, you might like to ruminate on:\n>\n>   https://github.com/sipa/minisketch/blob/master/README.md\n>\n> It's a library for efficient summaries of data, such as bitcoin\n> transaction gossip.  It has an implementation sweet-spot at 64-bits,\n> which almost works well for our gossip messages.  I've a straw-man\n> protocol below.\n\nCool to see there is interesting in exploring using minisketch for\nthis application.\n\nGenerally when trying to minimize the amount of data to transfer, I\nthink you should pick a field size that is appropriate for the data to\nsend, or if you're hashing the data, a size that gives an acceptable\ncollision rate. In case it isn't quite clear what the trade-off is,\nyou can prefer a size that permits faster implementation (like 15, 22,\n28, 30, 46, 60, or 64 bits).\n\nAlso, if there is a use for, it wouldn't be too much work to support\nfields over 64 bits in size. I expect it'd come at a ~2x performance\nreduction (compared to the expected continuation of the performance in\nfunction of field size), but we'd need to benchmark to be sure.\n\n> The required size of the minisketch we send depends on the number of\n> differences with our peer.  We can use some minimum value (maybe based\n> on past gossip rates?), and add the number of changes we've received\n> since last time, increasing if we failed to reconstruct a previous one.\n\nThere is some research on estimating the sizes of differences that are\nlinked to in https://github.com/sipa/minisketch/blob/master/doc/protocoltips.md\nwhich may be useful.\n\nThere are also techniques based on subdivision. In such a model, both\nsides maintain a separate sketch for (say) the first and the second\nhalf of the domain (one for all elements starting with leading bit 0,\nand one for all elements with leading bit 1). Let's call those\nsketches A1, A2, B1, B2.\n* A initially sends A12=merge(A1,A2) (a sketch of the entire set).\n* B tries to reconcile A12 against B12=merge(B1,B2). If that works,\nall good; otherwise B responds \"I needz moar\".\n* A now just sends its first sketch A1 (and not A2)\n* B reconciles A1 against B1, and also reconciles merge(A1,A12) against B2.\n\nThe trick here is that merge(A1,A12) is equal to A2, but A2 never\nneeded transferring; it was computed by combining the two sketches B\nalready received. This can be done several levels deep of course if\nneeded, and reduces the amount of \"overestimation\" needed for likely\nreconciliation in exchange for more roundtrips (one per level) in case\nof larger differences.\n\n> There doesn't need to be consensus between peers on the minisketch size\n> though, since truncated minisketches regrow into whole ones when tossed\n> back into the ocean[3].\n\nEh... if you have a sketch of size p and a sketch of size q, you can\nreconcile up to min(p,q) elements with them. They don't need to agree\nin size, but the excess of one size is not useful.\n\nCheers,\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "Minisketch and lightning gossip",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Pieter Wuille"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5850
        }
    },
    {
        "title": "[Lightning-dev] Data piggybacking within the payment_preimage for offline payments in wallets",
        "thread_messages": [
            {
                "author": "JOSE FEMENIAS CA\u00d1UELO",
                "date": "2018-12-15T11:53:12",
                "message_text_only": "Hi, I'd like to share an idea to piggyback information within the payment_preimage. (The intended use case is for offline payments, but I suppose there could be more). \nAFIK the Bolt documentation doesn't have any provision for a scheme like this, but I am am still trying to digest all the Bolt documentation, so maybe I am missing something.\n\nAlso, maybe there is some functional problem or major security concern that makes this scheme unfeasible, so please correct me if I'm wrong. \n\nOne paragraph description: \n\nAn offline device and a online LN Node share a common secret seed, so they can both independently calculate the same per_transaction_secret (PIN). Right before payment, the LN Node encrypts the PIN within the payment_preimage and sends the LN Wallet the encryption key.  Upon payment, having received the payment_preimage, the LN Wallet decrypts and shows the PIN. The user provides this PIN to the offline device so it can verify the payment. A standard is needed so that every compliant wallet knows how to decode and present the information to the user.\n\nThe scheme could work like this:\n\n\t1\u2022 An offline device (say a vending machine) shares a secret S1 with an online LN Node.\n\t2\u2022 When a payment is due, the offline device uses that secret S1, the Device_Id, the Product_Id and a Transaction_Id to generate a second secret S2 (let's say a six digit PIN) which will act as proof of payment to the offline device. S2 is specific for each transaction and is calculated using an HTOP algorithm.\n\t3\u2022 Both S1 and S2 stay within the offline device at all times.\n\t4\u2022 When the user selects a product, the offline device provides the LN Wallet (possibly through a QR code) with three pieces of information (Transaction_Id, Product_Id and Device_Id) which the LN Wallet relays to the online LN Node. \n\nNote: To support payments with static QR codes, the Transaction_Id  doesn't need to be sent. It can be replaced with an implicit time stamp (the way Google Authenticator works).\n\t5\u2022 The LN Node, using the information from [4] and the shared secret S1, calculates independently the secret S2 and encodes it using L bits.\n\t6\u2022 The LN Node generates a random number R, and slices it into two parts, the first L bits OTP = R[0..L-1] and the remaining 256-L bits R2 = R[L..255].\n\t7\u2022 OTP is sent back to the LN Wallet BEFORE the payment is made.\n\t8\u2022 The LN Node uses OTP as a one time pad to encrypt the secret S2 using a XOR operation: S3 = S2 XOR .OTP\n\t9\u2022 The LN Node creates a payment_preimage by concatenating the encrypted secret with the last bits of the random number from [6]: payment_preimage = S3 & R2 \n\t10\u2022 The LN Wallet, upon payment of the invoice, receives the payment_preimage.\n\t11\u2022 The LN Wallet, uses the payment_preimage from [10] and extracts the piggybacked information S3 = payment_preimage[0..L-1]. Then, it uses the one time pad received in [7] to decrypt S2 =  S3 XOR OTP.\n\t12\u2022 The LN Wallet shows the user S2 (a six digit PIN in our example), so she can type it in the offline device to claim her product.\n\n\nThe key thing for a scheme like this to be useful is to have a standard way for the LN Wallet to extract and handle the secret S2 from the payment_preimage. This way it can know that it has to show -let's say- a six digit numerical PIN instead of a four digit alphanumeric PIN or a QR code. I envision it as a MAGIC_NUMBER encoded within the secret, for which it should be somewhere in the standard documentation, so that every LN Wallet knows how to handle each use case.\n\n\nBelow, I rephrase the same scheme with a more detailed implementation example for a vending machine.\n\nUSER EXPERIENCE (for a vending machine):\n\nA customer of an offline vending machine  selects a product. The display of the vending machine shows a QR code that the user reads into her LN Wallet App. Upon payment of the required amount, the LN Wallet App shows her a six digit PIN that she types in the machine to get the chosen product.\n\nPROPOSED IMPLEMENTATION:\n\nA payment server and a vending machine share a common secret, a seed for an HTOP algorithm (HMac One Time Password). The vending machine can be offline at all times.\n\nWhen the customer selects a product, the vending machine generates a Transaction_Id (say 28481117450284) and encodes a payment url within a QR code for the user to read.\n\nThe url could be something like this:\n\nhttps://example.com/cgi-bin/lnpay.py?pid=231&tid=28481117450284&vid=B4AF2F\n\nWhere:\n\nPid = 231 is the id of the selected product.\nTid = 28481117450284 is a random number to identify this transaction.\nVid = B4AF2F is a unique identifier for this particular vending machine.\n\nThe vending machine uses this information, along with the shared secret seed, to calculate a secret PIN, unique to this transaction, using the HTOP algorithm. Let's say the result is a 6 digit PIN like 998376 (hex 0x000F8B3E), which the vending machine MUST NOT show.\n\nWith all this information plus the shared secret, the server at example.com calculates the same PIN number (0x000F8B3E) and it then commands a LN node to create an invoice with the proper payment for the product 231 that the customer has chosen.\n\nThe LN node generates a random 32 byte number; let's say:\n\nea8caa790486e66e70fa::2da6fff89d1ba1678b834fe162c58fcbbef25ea3177c\n\nIt then slices the number into two fields, namely:\n\n\t\u2022 OneTimePad: The first 10 bytes (ea8caa790486e66e70fa)\n\t\u2022 Entropy: The last 22 bytes (2da6fff89d1ba1678b834fe162c58fcbbef25ea3177c)\n\nThe piggybacked data will also be (in this example) 10 bytes, of which the first 6 constitute the magic number (0x000000001234 in the example) and the next 4 are the PIN (0x000F8B3E)\n\nSo the third field will be:\n\nc) Piggybacked data (raw): 000000001234000F8B3E2\n\nNow, it encrypts the Piggybacked data by XORing a) and c) to obtain:\n\nd) Piggybacked data (encrypted): ea8caa7916b2e661fbc40 \n\nIt then concatenates d) to b) to obtain the payment_preimage:\n\nea8caa7916b2e661fbc40::da6fff89d1ba1678b834fe162c58fcbbef25ea3177c\n\nThe payment gateway sends the wallet the OneTimePad a) and the invoice to pay.\n\nAfter paying the proper amount, the mobile wallet of the customer, receives this payment_preimage that contains the -encrypted- piggybacked information.\n\nIt then uses the OneTimePad a), XORs it with the first 10 bytes of the preimage and recovers c) the Piggybacked data 000000001234000F8B3E2\n\nUpon recognizing the first six bytes as the magic number for this use case, the LN Wallet App decodes the next 4 bytes and presents the user with the six digit PIN (decimal 998376). The customer then enters this PIN in the vending machine and gets her product."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-17T03:56:52",
                "message_text_only": "Good morning JOSE,\n\n>  An offline device (say a vending machine) shares a secret S1 with an online LN Node.\n\nIs this the same problem that is solved by: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001579.html ?\n\nI believe the solution presented at the summit is superior technology-wise.\n\n1.  The offline device holds no secrets.  Hacking it (if somehow possible) is thus not incentivized.\n2.  The offline device can verify the hashes it holds in memory come from its owner.  Invoices require a signature, and invoices include the payment hash.  A payment hash stored in the offline device is thus committed to in the signature of the invoice, and the invoice signature can be verified.\n3.  It works as-is without additions to the BOLT spec or to current wallets.\n\nThe only problem is that the hash preimage is 32 bytes.\nBut if an invoice can acceptably be sent via QR code, why cannot hash preimages also?\n(it may simplify the design of the vending machine, which now needs only present a standard keypad for a PIN)\n\n6-digit decimal codes may be acceptable.\nGiven about 1 second to enter 6 digits (superhuman speed) it would take about 6 days or so to go through about half the space of 6-digit decimal codes.\nPerhaps the vending machine can simply delay if too many failing 6-digit decimal codes are entered.\nAt the same time, it is easier for meat-based humans to remember and enter a mere 6-digit decimal code.\n\n\nPerhaps a compromise is possible.\n\nLet me propose this instead, which again *requires no changes to BOLT spec or special changes in wallet implementations*.\n\n1.  The online LN node prepares a set of invoices.\n    * The first 6 hexadecimal digits of the preimages are restricted to the set of decimal digits (or just put 6 more keys into your keypad, of course meat-based humans can understand letters too).\n    * The succeeding 58 digits of the preimage are a salt.\n2.  The offline vending machine stores the payment hash, salt, and invoice signature from the online LN node.\n3.  When a customer arrives and indicates desire to purchase, the offline vending machine presents one of the unclaimed invoices.\n4.  Upon paying, the vending machine instructs the customer to enter the first 6 digits of the payment preimage.\n5.  The vending machine looks through its list of unclaimed invoices to find one where the 6 digits, concatenated with the salt, hash to the given payment hash.\n    * If so, it marks that invoice as used and dispenses the product.\n    * Otherwise, it is a failure and the vending machine will delay.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jose Femenias",
                "date": "2018-12-20T09:43:17",
                "message_text_only": "An HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181220/ab452ceb/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-20T10:05:10",
                "message_text_only": "Good morning Jose,\n\n\n\n> Anyway, my point here is that it is actually desirable having both standards and modified wallets, to radically increase usability, which will be needed if we want to have widespread adoption of LN payments.\n\nThis is badly undesirable.\nWe should have standard wallets that can talk to other standard-following software well.\nModifications to wallets are dangerous in many ways, as well as greatly increasing effort overall.\n\n>\n> The biggest drawback to the system you propose is -IMHO- the logistics needed for replenishing the hashes into offline vending machines. The system I propose only requires an initial configuration of the machine with the shared secret for an unlimited series of payments.\n\nDo your vending machines generate product out of quantum foam, like I sometimes do on a boring afternoon?\nOr are they replenished as they run out of product?\n\nEach product sold is one invoice claimed.\nThus, replenishing of products, is same operation as replenishing of invoices.\nYou have to open the vending machine anyway to replenish its stock of products for sale.\nWhile your technician is replenishing the machine and doing whatever basic checks, your technician also replaces a EEPROM board with a new EEPROM board with fresh invoices.\nEven tiny EEPROM chip can hold enough data to support thousands of invoices.\nAnd it is unlikely you would fill a vending machine with thousands of product.\n\n>\n> I still have a few doubts however on how the scheme you propose would handle these concerns:\n>\n> a) Price changes: With the piggybacking scheme I propose, the vending machine (or toll both, or whatever) doesn't set the price of the item or service. It only sends the product/service Id to the remote LN Node. This way, prices can be adjusted in real time.\n\nWhy would you sell products with widely fluctuating BTC value?\nWe sell products with a fixed BTC value!\nAnd because BTC is deflationary, BTC value of product will never change.\nWe can see very readily that BTC price relative to dollar does not change except for dollar inflation rate and there is no such thing as massive bear market.\n\nNote that what you want is not an invoice system.\nWhat you want is a static offer system.\nI suggest to look at Rusty proposal for static offers.\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001602.html\n\n>\n> b) Static QR codes: Again, the piggybacking scheme allows for static QR codes to be used by having an implicit transaction Id (the timestamp in 30 seconds  increments).\n\nSame as above.\n\n\n>\n> c) Privacy and security: By sending the six digits code in the clear, within the preimage, intermediate nodes have access to this information. I think that poses both a privacy and a security problem. That's the reason I proposed XORing the piggybacked secret with a one time pad.\n\nWill be fixed by payment decorrelation when we move to points and scalars.\nThis will require either using `OP_CODESEPARATOR`, which is hard to understand, or waiting for Schnorr.\n\n\n(incidentally, because I am actually a human being and not a machine superintelligence, in fact I am ***not*** capable of creating product out of quantum foam. by my understanding, this idea is what you humans call a joke.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-20T10:11:17",
                "message_text_only": "Good morning Jose,\n\n> > I still have a few doubts however on how the scheme you propose would handle these concerns:\n> > a) Price changes: With the piggybacking scheme I propose, the vending machine (or toll both, or whatever) doesn't set the price of the item or service. It only sends the product/service Id to the remote LN Node. This way, prices can be adjusted in real time.\n>\n> Why would you sell products with widely fluctuating BTC value?\n> We sell products with a fixed BTC value!\n> And because BTC is deflationary, BTC value of product will never change.\n> We can see very readily that BTC price relative to dollar does not change except for dollar inflation rate and there is no such thing as massive bear market.\n>\n\nYou probably still want your technician to periodically visit vending machines anyway.\nThis is to check for mechanical damage or attempts to pay via crowbar.\nIf so, you can regularly have the invoices replenished with more up-to-date prices.\n\nThen your risk is limited to only the period at which your technician visits each vending machine.\n\nStatic QR codes are unimportant.\nAs long as you can generate the invoice at the vending machine, you can show a QR code to pay to.\nIn addition, the QR code is needed to be stable only up to getting paid and having the product claimed.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jose Femen\u00edas Ca\u00f1uelo",
                "date": "2018-12-21T16:10:18",
                "message_text_only": "DISCLAIMER:\n\nThese next two messages come out of order. One was scrubbed by the list (html), the other I sent inadvertently only in private to ZmnSCPxj.\nI repost them here for completeness of the thread.\n\nMy excuses.\n\n----------------------------------------------------\n\n\nHello ZmnSCPxj,\n\n> Is this the same problem that is solved by: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001579.html\n>  ?\n> \n\nIt essentially is; but I guess there will be other use cases where it may be interesting to transmit some information encoded within the preimage, so that it is only revealed after payment. \n\nOne use case that comes to mind is what we could call 'pay to pay':\n\nAlice wants to pay Bob some sizable amount, onchain. Bob gives Alice a tiny LN invoice and piggybacks his onchain address for Alice to pay him (160 bits in this case).\nUpon payment of the LN invoice, Alice decrypts Bob's address.\nThis could help preventing Mallory from spamming Bob to get countless payment addresses that won't ever be used (I am thinking Wikileaks for instance). \n\n\n> I believe the solution presented at the summit is superior technology-wise.\n> \n\nRegarding what solution is superior, I wouldn't say it is a matter of superiority but rather one of fitness for the purpose, I will elaborate below.\n\n\n> 1.  The offline device holds no secrets.  Hacking it (if somehow possible) is thus not incentivized.\n> 2.  The offline device can verify the hashes it holds in memory come from its owner.  Invoices require a signature, and invoices include the payment hash.  A payment hash stored in the offline device is thus committed to in the signature of the invoice, and the invoice signature can be verified\n> \n\nThe risk of hacking will always be there, I believe, although neither proposal stores keys in the vending machine, so hacking it won't be catatrophic.\nAnyway, rather than stealing secrets from the vending machine, I believe a hacker would replace the payment hashes and ancillary information with his own.\n\nThis way, the future payments would go to the hacker's address instead of the machine's owner. \n\nThis vulnerability applies to both systems, so I don't see a clear winner here. I guess only using an HSM device within the machine could provide a high level of protection against these attacks. In the end, nothing can really beat a hacker that has physical access to a machine (which I guess is the case of many vending machines).\n\n\n> 3.  It works as-is without additions to the BOLT spec or to current wallets.\n\nThat is a clear plus for your scheme, at least short term, since interested parties would be able to roll out an implementation without having to depend on any external dependencies. Anyway, my point here is that it is actually desirable having both standards and modified wallets, to radically increase usability, which will be needed if we want to have widespread adoption of LN payments.\n\nThe biggest drawback to the system you propose is -IMHO- the logistics needed for replenishing the hashes into offline vending machines. The system I propose only requires an initial configuration of the machine with the shared secret for an unlimited series of payments.\n \nAs for the 'compromise' you suggest, I find it really smart and workable. I think the six digit code is cheap to implement and secure enough for most use cases.\n\nOTHER THOUGHTS\n---------------------\n\nI still have a few doubts however on how the scheme you propose would handle these concerns:\n\na) Price changes: With the piggybacking scheme I propose, the vending machine (or toll both, or whatever) doesn't set the price of the item or service. It only sends the product/service Id to the remote LN Node. This way, prices can be adjusted in real time.\n\nb) Static QR codes: Again, the piggybacking scheme allows for static QR codes to be used by having an implicit transaction Id (the timestamp in 30 seconds  increments).\n\nc) Privacy and security: By sending the six digits code in the clear, within the preimage, intermediate nodes have access to this information. I think that poses both a privacy and a security problem. That's the reason I proposed XORing the piggybacked secret with a one time pad.\n\nAll in all, I guess there can be use cases for both schemes. I see yours more fit for devices that have intermittent connectivity, rather than being offline all the time, since that overcomes in a great manner the problem of replenishing hashes, but maybe I am missing something here.\n\nRegards.\n\n\nGood morning ZmnSCPxj,\n\n> We should have standard wallets that can talk to other standard-following software well.\n> Modifications to wallets are dangerous in many ways, as well as greatly increasing effort overall.\n> \nFully agreed; that is why I said it is vital to have standards.\n> Do your vending machines generate product out of quantum foam, like I sometimes do on a boring afternoon?\n> Or are they replenished as they run out of product?\n> \nI wish they could ;-)\nNot all machines sell products. Some sell services: Arcade machines, Toll booths, etc., are examples of machines that provide a service instead of a physical product, where not having to replentish invoices ever is desirable.\n\n> While your technician is replenishing the machine and doing whatever basic checks, your technician also replaces a EEPROM board with a new EEPROM board with fresh invoices.\nTrue, but -in my experience at least- the person that replenishes the machine isn't usually a technician.\n> Why would you sell products with widely fluctuating BTC value?\n> We sell products with a fixed BTC value!\n> \nIt isn't really me, I swear, I truly enjoy giving things away, particularly during Christmas... ;-)\nHowever, some evil, greedy people have invented congestion pricing, to match price and demand (https://en.wikipedia.org/wiki/Congestion_pricing). \nThat is probably more fit for machines that sell services instead of products (say entry to a Zoo, car toll booths, ...) but I wouldn't rule out some evil machine owner linking the price of a Coke to the ambient temperature.\n\n\n\n>> b) Static QR codes: Again, the piggybacking scheme allows for static QR codes to be used by having an implicit transaction Id (the timestamp in 30 seconds  increments).\n>> \n> Same as above.\n> \nMy point with the static  QR codes is not about price optimization (price gouging, one could say...). \nIt is more about minimizing the hardware requirements a machine needs to have in order to accept offline payments through LN.\n\nWhile an arcade machine can be 'easily' reprogrammed to show a dynamic QR code with a new invoice for each game with no hardware modifications, there are other cases where the device has no obvious way to do that. I guess that will be much less of a problem in the future though.\n\n> Will be fixed by payment decorrelation when we move to points and scalars.\n> This will require either using `OP_CODESEPARATOR`, which is hard to understand, or waiting for Schnorr.\n> \n\nWasn't aware of that, good to know. Are hash preimages dissapearing then?\n\n> Note that what you want is not an invoice system.\n> What you want is a static offer system.\n> I suggest to look at Rusty proposal for static offers.\n> \n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001602.html\nI'll have a look, thanks for the info.\n> (incidentally, because I am actually a human being and not a machine superintelligence, in fact I am ***not*** capable of creating product out of quantum foam. by my understanding, this idea is what you humans call a joke.)\nDon't sell yourself short! Judging by your work, I wouldn't dare to say that you are not superintelligent, machine or not... (this wasn't a joke)\n\nRegards, again, thanks for your comments."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-22T14:38:21",
                "message_text_only": "Good morning Jose,\n\n>\n> I wish they could ;-)\n> Not all machines sell products. Some sell services: Arcade machines, Toll booths, etc., are examples of machines that provide a service instead of a physical product, where not having to replentish invoices ever is desirable.\n\nI imagine even a cheap EEPROM can contain several hundred thousand invoices.\nAnd you will want to regularly do checkups on your machines anyway, so you might as well replenish invoices at each checkup.\n\n> > While your technician is replenishing the machine and doing whatever basic checks, your technician also replaces a EEPROM board with a new EEPROM board with fresh invoices.\n>\n> True, but -in my experience at least- the person that replenishes the machine isn't usually a technician.\n\nWhatever you may call them.\nThey open the machine, they put things in it.\nAdding an instruction \"remove this thing from the slot, then replace with this thing, press this internal button to see if it got inserted properly\" is not so hard.\n\n> > Will be fixed by payment decorrelation when we move to points and scalars.\n> > This will require either using `OP_CODESEPARATOR`, which is hard to understand, or waiting for Schnorr.\n>\n> Wasn't aware of that, good to know. Are hash preimages dissapearing then?\n\nYes, in A Few Years (hint: longer than you think).\n\nMoving to points and scalars would let us use hierarchical derivation, where the offline machine would contain only the root pubkey (point), while the online Lightning node would contain the root privkey (scalar).\nThis would not require any storage of invoices in the offline machine.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Data piggybacking within the payment_preimage for offline payments in wallets",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "JOSE FEMENIAS CA\u00d1UELO",
                "Jose Femenias",
                "Jose Femen\u00edas Ca\u00f1uelo"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 23270
        }
    },
    {
        "title": "[Lightning-dev] Proposal: Unspecified BOLT Protocol Extensions",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-16T11:20:11",
                "message_text_only": "Good morning list,\n\nI followed with some interest the discussion some days ago where MIT DCI Lit wanted to autodetect fellow Lit nodes using the BOLT protocol.\n\nNow, my thoughts:\n\n1.\u00a0 The desired feature, is essentially a question \"is this node an X implementation?\"\n2.\u00a0 However, the feature bits we use currently, is essentially a question \"has this node an X feature?\"\n3.\u00a0 Our feature bits are centrally allocated on the BOLT spec. This makes difficult, permissionless innovation.\n\nI think, \"has-a\" query is better than \"is-a\" query.\nBut I admit that requiring that features allocate some feature bit are difficult, for the view of permissionless innovation, as it requires coordination across multiple implementations.\nYet experimental extensions might be experimental.\n\nSo rather than code, I decide to waste precious bandwidth and spam the mailing list again.\n\nI propose the concept of Unspecified Protocol Extensions.\nThey are \"unspecified\" as they are not part of the BOLT specifications.\n\nEach such protocol extension must select its own random 20-byte identifier.\nIt is strongly suggested that the name of the protocol extension be hashed with RIPEMD160 or some other hash.\nAlternately, the protocol extension developer can grab 20 random byte from random.org or from their local /dev/random.\n\nFurther:\n\n1.  In BOLT messages, the `type` >= 49152 (0xC000 or more) is reserved for unspecified protocol extensions.\n2.  In onion hops, the `tlv` `type` >= 192 (0xC0 or more) is reserved for unspecified protocol extensions.\n3.  In `node_announcement`s with `tlv`, a specific `tlv` `type` is reserved for unspecified protocol extensions.\n\nAt link level, we add the concept of \"current extension\".\nBy default, at the start of a connection, there is no current extension and messages >= 49154 are unrecognized.\n\nThe following new messages are defined.\n\n1.  `type`: `can_i_has_extension` (49152)\n2.  `data`\n    * [`20`: `unspecified_protocol_extension_id`]\n\nThis message queries if the receiver has a particular extension.\nThe extension id composed of only 0s is the nonexistence of an extension.\n\nThe sender may set the ID to 0.\nThis indicates that the sender does not intend to send any particular extension in the foreseeable future.\n\nThe receiver:\n* SHOULD reply with `i_has_a_extension`.\n    * MAY reply with a `i_has_a_extension` with null ID to indicate it does not have the extension.\n\nThe sender:\n* MUST NOT send any extension-specific messages until the other side indicates agreement to process extension-specific messages via `i_has_a_extension`.\n\n1.  `type`: `i_has_a_extension` (49153)\n2.  `data`\n    * [`20`: `unspecified_protocol_extension_id`]\n\nThis message indicates that the sender is capable of understanding the indicated unspecified protocol extension ID.\nThe receiver can then send future messages within the range 49154->65535 and those will be interpreted as part of the protocol extension.\n\nThe sender of this message may set the ID to all 0s.\nThis indicates that the sender will not recognize succeeding messages as belonging to any particular extension, and implicitly denies a previous `can_i_has_extension` request.\n\nNote that message IDs 49154 to 65535 are effectively multiplexed across different protocol extensions.\n\nThe message `can_i_has_extension` indicates that the sender would like to send messages with the specified protocol extension in the close future.\nThe message `i_has_a_extension` indicates whether the sender would accept such protocol extensions.\nThis sets the protocol extension for one direction of the channel only.\nIf the protocol extension requires requests and responses from both sides of the connection, then both sides need to request the extension (via `can_i_has_extension`) independently of the other side.\n\nFor each direction, only one protocol extension is the current protocol extension.\n\n\nFor onion hops, the following additional `tlv` `type` is defined:\n\n1. `type`: `im_in_yr_hop_extending_yr_protocol` (192)\n2. `len`: 20\n3. `data`:\n    * [`20` : `unspecified_protocol_extension_id`]\n\nThis indicates that future `tlv` `type`s in the range 193 to 255 are to be interpreted as belonging to the specific protocol extension.\n\nSimilar to message codes, onion hop `tlv` `type`s 193 to 255 are effectively multiplexed across different protocol extensions.\n\nNote that this implies that only a single unspecified protocol extension can be used on a hop.\n\n\nAn additional `node_announcement` `tlv` `type` is defined:\n\n1. `type`: `hai_im_extended` (TBD)\n2. `len`: multiple of 20\n3. `data`:\n    * [`len` : `unspecifed_protocol_extension_ids`]\n\nThis `tlv` type advertises support for the indicated unspecified protocol extensions.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Unspecified BOLT Protocol Extensions",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4703
        }
    },
    {
        "title": "[Lightning-dev] Need Updates on Lightning Network",
        "thread_messages": [
            {
                "author": "Van Ezquer",
                "date": "2018-12-17T15:47:05",
                "message_text_only": "Hello Lightning Network devs,\nI am a crypto youtuber seeking knowledge of btc, lightning network especially the latest developments. But I want to give truth to my audience not Hopium so I need facts. My problem is am not a techie so can you tell me where I can find details on the latest lightning development that is not too technical?\u00a0\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181217/0f042e6a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Need Updates on Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Van Ezquer"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 528
        }
    },
    {
        "title": "[Lightning-dev] visual identification of payee node id",
        "thread_messages": [
            {
                "author": "Pavol Rusnak",
                "date": "2018-12-23T18:49:15",
                "message_text_only": "Hi all!\n\nCurrently, when I perform a payment via QR code, I usually check the\npayee node id (public key) in the send dialog. However, this is a rather\nlong hex value, so for example Eclair app shows just the beginning and\nthe end of the value.\n\nIdea: Can we show an identicon (for example https://jdenticon.com/) of\npayee node id (= public key) next to the QR code, so user can visually\nquickly check whether the recipient is correct?\n\nWe'd need to add this to UI of all Lightning user-facing wallets to make\nsense, though.\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nCTO, SatoshiLabs"
            },
            {
                "author": "William Casarin",
                "date": "2018-12-29T16:16:05",
                "message_text_only": "Pavol Rusnak via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n\n> Hi all!\n>\n> Currently, when I perform a payment via QR code, I usually check the\n> payee node id (public key) in the send dialog. However, this is a rather\n> long hex value, so for example Eclair app shows just the beginning and\n> the end of the value.\n>\n> Idea: Can we show an identicon (for example https://jdenticon.com/) of\n> payee node id (= public key) next to the QR code, so user can visually\n> quickly check whether the recipient is correct?\n\nI think it would be interesting if someone came up with a visual hashing\nalgorithm, where small changes in the inputs had uniformly random visual\noutputs. I was testing jdenticon with my node id:\n\n  03f3c108ccd536b8526841f0a5c58212bb9e6584a1eb493080e7c1cc34f82dad71\n\nI was surprised to see that small changes to the first digit didn't\nchange the visual output at all. Whether or not this is a useful\nproperty in this use case, it's something to keep in mind.\n\nCheers,\nWill\n\n-- \nhttps://jb55.com"
            }
        ],
        "thread_summary": {
            "title": "visual identification of payee node id",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Pavol Rusnak",
                "William Casarin"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1628
        }
    },
    {
        "title": "[Lightning-dev] An Argument For Single-Asset Lightning Network",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-27T05:43:51",
                "message_text_only": "HTLCs as American Call Option, or, How Lightning Currently Cannot Work Across Assets, or, An Argument For Single-Asset Lightning Network\n\nIntroduction\n============\n\nIn theory, the Lightning Network could potentially perform \"seamless\" currency conversions, allowing a payer to spend one currency to pay a payee requesting for another currency.\nHowever, a significant technical barrier prevents implementation of such feature as of current designs (late 2018) for Lightning.\n\nThe root cause of this significant technical barrier is the use of hashlocked timelocked contracts to route payments.\nHTLCs can be used across cryptocurrency systems to transfer value between them.\n>From this point-of-view, every single Lightning Network channel is a cryptocurrency system whose custodians are two entities, who are the only entities who can use the system (the single Lightning Network channel).\nHTLCs allow cross-system trades to be performed, so that participation on any single Lightning Network channel can be leveraged to participation over the entire Lightning Network.\n\nHowever, HTLCs can also be used to construct American Call Options.\nFurther, due to UX concerns, on the Lightning Network, there is no cost incurred in merely setting up HTLCs for routing.\nBy using the low-level HTLCs provided as primitives by Lightning Network, one can set up American Call Options.\nThese on-Lightning American Call Options, however, can be \"purchased\" for free (gratis), thus potentially earning money in a completely risk-free manner.\nAbusing this gratis ability means that any Lightning Network node advertising cross-asset on-Lightning exchange will find large amounts of its liquidity tied up in stalled forwarding payments (in reality, American Call Options) with a risk of monetary loss in case of large fluctuations in exchange rate.\n\nHashlocked Timelocked Contracts as American Call Options\n========================================================\n\nAn American CallOption is a right (but not obligation) to purchase an asset at a specific price, on or before an expiration date.\nHTLCs allow building American Call Options.\n\nSuppose we have Bitcoin, and some other asset, and both are on blockchains that support the same hash function and can define HTLCs.\nIt is unimportant if both are on the same blockchain, or on different blockchains, since HTLCs can work across cryptocurrency systems.\n\nAn American Call Option has these properties:\n\n1.  `P` = the price at which the asset can be purchased.\n2.  `E` = the date at which the option expires.\n\nSuppose I, ZmnSCPxj, wanted to sell you an American Call Option  for 1 Widget (WJT) on the WJT blockchain.\nWe would then do the below ritual:\n\n1.  You provide me a hash of some secret preimage that only you know.\n2.  You make an HTLC on the Bitcoin blockchain.\n    The value of this HTLC is `P`, the hash is the hash you gave above, and the timelock is `E` + 1 day.\n3.  I make an HTLC on the WJT blockchain.\n    The value of this HTLC is 1, the hash is the hash you gave, and the timelock is `E`.\n\nOn or before `E`, you can claim the WJT on the WJT blockchain by providing a transaction that reveals the preimage.\nSince the preimage is now revealed, I can then claim the Bitcoins of price `P` on the Bitcoin blockchain.\nAlternately, you can simply not exercise this right, and at time `E` I would then reclaim my WJT, and at time `E` + 1 day you would reclaim your bitcoins.\n\nOf course, I want to *sell* this contract to you, so you would have to pay me some bitcoins before we set up the above.\nA multi-stage construction of transactions that go through HTLC-like constructs can be done on both blockchains to ensure that the above contracts appear on both chains only if the payment for the actual contract (i.e. the \"premium\") is done, and to enforce that both contracts appear if the premium is paid, but that is beyond the scope of *this* writeup, which will focus on how Lightning Network HTLCs can form the above construction without any premium being paid.\n\nHTLCs For Routing\n=================\n\nHTLCs can be used to enforce trades across different cryptocurrency systems.\nThis property is used to allow routing of payments across different channels.\nEach channel is its own cryptocurrency system.\n\nSuppose I, ZmnSCPxj, am an intermediate node on Lightning, and I wanted to sell you my service of facilitating payments on Lightning.\nSuppose you want to pay to somebody, who, for the sake of convenience, we shall randomly call YAIjbOJA.\nAs it happens, I have a channel with you, and a channel with YAIjbOJa.\n\nYou need to pay YAIjbOJA `P` bitcoins.\nWe then perform the below ritual:\n\n1.  YAIjbOJA provides you a hash, whose preimage only YAIjbOJA knows.\n2.  On your channel with me, you set up an HTLC.\n    The value is `P`+1 bitcoin (the 1 being my fee), the hash is the hash you were given, and the timelock is 2 days from now.\n3.  On my channel with YAIjbOJA, I set up an HTLC.\n    The value is `P`, the hash is the same hash as above, and the timelock is 1 day from now.\n\n(in reality, the timelocks are parameterized and selected by the payer (you), and LN nodes will impose some \"reasonable\" limits on the timelocks; but the first HTLCs set up must have longer timelocks than the later HTLCs)\n\nAfterward, YAIjbOJA may claim, or may not claim, the money in the HTLC by releasing (or not releasing) the hash to me.\nIf YAIjbOJA claims the money, then I can take the hash and claim the money, plus fee, from you.\nIf not, then this is a payment failure and I will then cancel the HTLC you offered using standard Lightning Network primitives.\n\nIn general, we expect that YAIjbOJA wants to have the money because every randomly-generated imaginary entity likes money.\nThus, in the case of payments, YAIjbOJA has a strong incentive to claim the money without waiting for the timelock to expire or nearly expire.\nWe can see that in practice, on the current Lightning Network, HTLCs are often very transient and will be quickly claimed, despite having long timelocks.\n\nThis speed may mislead us into thinking that such convenience may be possible across different assets.\n\nCross-Asset Lightning Nodes Offer Premium-Free American Call Options\n====================================================================\n\nSuppose that Lightning Network supports multiple assets.\nEach channel has a single asset.\nSome nodes will advertise themselves as providing exchange capability, taking one asset on one channel and exchanging it for another asset on a different channel.\n\nSuppose I advertise myself as such an exchange.\nSuppose you want to pay to YAIjbOJA for 1 WJT, but have no WJT on hand to pay YAIjbOJA, only bitcoins.\nAs it happens, I have a bitcoin channel with you and a WJT channel with YAIjbOJA.\nI advertise myself as exchanging `P` bitcoins for 1 WJT as of the current time.\n\nFurther suppose that in reality, YAIjbOJA is *you*, random Internet person reading my thoughts.\n\nYou, your fake persona YAIjbOJA, and me, then perform the following ritual:\n\n1.  YAIjbOJA (really you) provides you with a hash whose preimage only YAIjbOJA (actually you) know. (i.e. you just make it up)\n2.  On the bitcoin channel with me, you set up an HTLC.\n    The value is `P`+1 bitcoin (the 1 being my fee), the hash is the hash that \"YAIjbOJA\" gave you (i.e. you really just made it up), and the timelock is 2 days from now.\n3.  On the WJT channel with YAIjbOJA (really you), I set up an HTLC.\n    The value is 1 WJT, the hash is the hash you gave me, and the timelock is 1 day from now.\n\nThe above is now the same as the setup for an American Call Option with expiration of 1 day from now.\nFurther, within certain limits, you can set up the expiration of the American Call Option to be longer or shorter.\nThus, I have inadvertently given you an American Call Option, for *no premium* (completely gratis), when my only intent was to facilitate cross-currency Lightning Network payments.\n\nSuppose that the price of 1 WJT rises far above the price of `P`+1 bitcoins before the expiration (1 day from now).\nIn such a case, \"YAIjbOJA\" (really you) will then release the hash and acquire the 1 WJT.\nYou then close this channel and claim the WJT onchain, then sell it immediately to earn more than the `P`+1 bitcoins you paid.\nAlternatively, presumably I would have a new exchange rate I would be willing to exchange WJT for, and you can just send the WJT with the new exchange rate immediately over the Lightning Network.\n\nSuppose that the price of WJT does not rise.\nSince this is an option and *not* a future, \"YAIjbOJA\" (really you) will simply claim that the payment errored somewhere and cancel the HTLCs.\nSince even payment errors are not unwrappable and are onion-wrapped, I cannot determine whether the payment really errored, or you were just setting up an American Call Option that you have now decided not to exercise.\n\nPremium-free American Call Options Are Risk-free Earning Pumps\n==============================================================\n\nTraditionally, options are analyzed assuming that the option itself has a price, the premium.\nThis premium is the risk of the user of the option.\nIf the user of the option does not exercise the option before the expiration, then the premium is a pure loss of the user.\n\nHowever, the above setup does not involve any payment when the option is not exercised.\nPayment failures are \"free\" (gratis) on the Lightning Network.\nHowever, payment failures are also the non-exercised branch of the American Call Option that can be set up on a cross-currency on-Lightning exchange.\n\nBecause the American Call Option is premium-free, even if the expiration is very near, rational entities will still construct such options.\nExtreme volatility may occur in short time frames, especially in the realm of digital assets.\n\nThus, it is strongly likely that, if cross-asset exchange nodes on Lightning Network exist, they will be exploited to create risk-free American Call Options.\nThey will find that significant liquidity will be tied up in such American Call Options, and find that they will lose funds especially at times of volatility.\n\nWe can try to mitigate this, but the solutions below all have significant drawbacks.\n\n1.  We could force that setting up the HTLCs requires payment.\n    This forces the above American Call Options to have a premium.\n    The effect, however, is that routing failure is not free.\n    The current Lightning Network works despite not everyone publishing the balances of channels, precisely because routing failure is free.\n    We only need to have one route succeed in order to actually successfully pay to the payee.\n    With non-free routing failure, we cannot try many routes until one succeeds.\n    * Suppose we limited this only to cross-asset exchanges.\n      It would still require accurate knowledge of channel balances.\n      This is because if a payment fails on a hop *after* the exchange, the payer still loses money from that attempt to the exchange node.\n2.  Exchange nodes could increase their fees.\n    This would create a wider \"spread\" of buying and selling assets.\n    This spread would increase friction in crossing assets.\n    Also, this would only reduce risk; if the exchange rate is volatile enough, then the option could still be exercised for riskless earnings.\n    Rational entities will still tie up most of the liquidity on the exchange on riskless American Call Options; even if the exchange rate is very stable, they lose nothing.\n3.  Exchange nodes could limit the timelock of cross-asset swaps.\n    This would increase friction in crossing assets, since a timelock limit also imposes a limit to the route length.\n    If one asset is much stronger than the other, then the weaker asset will find its part of the Lightning Network to be strongly centralized around the exchanges between the two assets.\n    Payees of the weaker asset will strongly prefer to be at most one hop away from exchanges in order to viably receive payments from payers who are using the stronger asset.\n    Again, rational entities will also still tie up most of the liquidity on the exchange on riskless American Call Options; again, even if the exchange rate is very stable in short time frames, they lose nothing anyway.\n\nConclusion\n==========\n\nHTLCs allow creation of American Call Options.\nThe same HTLCs are used in Lightning Network to route across channels.\nIf using a single asset, there is no issue related to time.\nRegardless of the value of bitcoin relative to any other asset, in the future, 1 BTC is 1 BTC.\n\nHowever, across assets, the ability of HTLCs to create American Call Options becomes troublesome.\nThese can then be exploited to earn money from exercise of the option.\nFurther, because Lightning UX would be degraded otherwise, payment failures are free (gratis), leading to the American Call Options also being free of premium.\nThis means that creating such options would be riskless, allowing potential earnings upon any strong volatility of exchange rates.\n\nThis implies that a multi-asset Lightning Network may not be economically viable.\nInstead, Lightning Network would strongly prefer having a single asset across the network."
            },
            {
                "author": "Will Yager",
                "date": "2018-12-27T12:47:57",
                "message_text_only": "Very good point.\n\nTwo possible responses come to mind.\n\n1. Cross-asset brokers charge a standard option premium to perform the brokerage. I can't tell if you think this is totally broken or if it's just sad. I don't understand lightning well enough to figure that out on my own - could you expand more on what effects this would have?\n\n2. Cross-asset brokers require counterparties to issue them a symmetric but slightly more out-of-the-money call, which they can redeem in the event of a large FX swing. This bounds their FX losses.\n\n\nWill\n\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, December 27, 2018 1:43 PM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n\n>     HTLCs allow creation of American Call Options."
            },
            {
                "author": "Alexander Leishman",
                "date": "2018-12-27T14:02:02",
                "message_text_only": "There\u2019s another potential partial solution here if we can create some cryptographic protocol for atomically swapping information. This would be used to swap the final HTLC sig for the hash preimage, preventing the optionality issue. This idea was inspired by a paper called \u201cTimed Commitments\u201d by Dan Boneh \n(https://www.iacr.org/archive/crypto2000/18800237/18800237.pdf). \n\nThe high level idea is that each party swaps a commitment to the information they want to atomically swap and then slowly reveal verifiable \u201chints\u201d that make it easier and easier to brute force the commitment. Each party takes turns revealing a hint. \n\nThe protocol to do something like this in lightning doesn\u2019t exist afaik but it seems feasible. This also may fail to work when there are intermediary nodes not controlled by the two trading parties. \n\nI also could be completely off here but I thought the idea was worth sharing. \n\nBest\nAlex\n\n> On Dec 27, 2018, at 10:47, Will Yager <lists at yager.io> wrote:\n> \n> Very good point.\n> \n> Two possible responses come to mind.\n> \n> 1. Cross-asset brokers charge a standard option premium to perform the brokerage. I can't tell if you think this is totally broken or if it's just sad. I don't understand lightning well enough to figure that out on my own - could you expand more on what effects this would have?\n> \n> 2. Cross-asset brokers require counterparties to issue them a symmetric but slightly more out-of-the-money call, which they can redeem in the event of a large FX swing. This bounds their FX losses.\n> \n> \n> Will\n> \n> \n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Thursday, December 27, 2018 1:43 PM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> \n> \n>>    HTLCs allow creation of American Call Options.\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181227/191b02f9/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-27T16:01:37",
                "message_text_only": "Good morning Alex and Will,\n\n> 1. Cross-asset brokers charge a standard option premium to perform the brokerage. I can't tell if you think this is totally broken or if it's just sad. I don't understand lightning well enough to figure that out on my own - could you expand more on what effects this would have?\n\nIt is quite broken.\nWe assume generally that if a payment route fails, that the payer making the payment route loses nothing.\n\nUnfortunately, once there is a premium involved for cross-asset swaps, it implies that any failures *after* the swap will now have a cost, specifically, the premium paid.\nPerhaps you could inform the cross-asset broker who the ultimate payee is so it can retry failures after it on your behalf, but now the broker has the ability to censor payments to payees it does not like.\n\n> 2. Cross-asset brokers require counterparties to issue them a symmetric but slightly more out-of-the-money call, which they can redeem in the event of a large FX swing. This bounds their FX losses.\n\nI am uncertain what you mean exactly.\n\nDo you mean, that if you make a swap on Lightning, which *might* be a Bitcoin-to-WJT American Call Option, I will refuse to forward until I also get something that is a WJT-to-Bitcoin call option, similar to a butterfly spread?\nThat implies that in the \"normal\", non-American-call-option case, the payer has the target asset, which brings up the question: why would the payer even go through the cross-asset broker in a Lightning route if the payer already has the target asset?\n\n\n> There\u2019s another potential partial solution here if we can create some cryptographic protocol for atomically swapping information. This would be used to swap the final HTLC sig for the hash preimage, preventing the optionality issue. This idea was inspired by a paper called \u201cTimed Commitments\u201d by Dan Boneh\u00a0\n> (https://www.iacr.org/archive/crypto2000/18800237/18800237.pdf).\u00a0\n>\n> The high level idea is that each party swaps a commitment to the information they want to atomically swap and then slowly reveal verifiable \u201chints\u201d that make it easier and easier to brute force the commitment. Each party takes turns revealing a hint.\u00a0\n>\n> The protocol to do something like this in lightning doesn\u2019t exist afaik but it seems feasible. This also may fail to work when there are intermediary nodes not controlled by the two trading parties.\u00a0\n\nThe entire point of using HTLCs in Lightning routing is to enforce that the final payee actually gets paid, or nobody along the route gets paid.\n>From my understanding of this, if this is used, then an intermediate node can try to brute force the preimage instead of actually bothering to forward payments or hints.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Alexander Leishman",
                "date": "2018-12-28T01:01:57",
                "message_text_only": "Hello ZmnSCPxj,\n\n> Do you mean, that if you make a swap on Lightning, which *might* be a\nBitcoin-to-WJT American Call Option, I will refuse to forward until I also\nget something that is a WJT-to-Bitcoin call option, similar to a butterfly\nspread?\n> That implies that in the \"normal\", non-American-call-option case, the\npayer has the target asset, which brings up the question: why would the\npayer even go through the cross-asset broker in a Lightning route if the\npayer already has the target asset?\n\nNo this isn't what I'm suggesting. Let me try to explain again. Apologies\nif this isn't clear:\n\nLet's assume only two parties are engaging in this interaction, you and me.\nYou offer me the WJT/BTC exchange rate from your mult-chain node and I\nroute an LN payment from my BTC node to my WJT node through your\nmulti-chain node. My understanding is that the main problem with this is\nthe free optionality I get when my WJT node does not return the hash\npreimage immediately to you and instead waits to see if the market price\nfluctuates out of my favor until option/HTLC expiry. But what if we could\natomically swap this preimage for the final HTLC you sent me? If this\nmagical atomic information swap could happen (I don't get the final HTLC\nunless I reveal the preimage) the payment would settle immediately (in the\ntwo party case, let's assume no other intermediary nodes). A timed\ncommitment approach could potentially be feasible if the time required to\nbrute force the commitment is longer than the life of the \"option\"/HTLC.\nI'm not necessarily suggesting this the optimal solution, but I haven't\nseen the idea mentioned before.\n\n-Alex\n\n\nOn Thu, Dec 27, 2018 at 2:01 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Alex and Will,\n>\n> > 1. Cross-asset brokers charge a standard option premium to perform the\n> brokerage. I can't tell if you think this is totally broken or if it's just\n> sad. I don't understand lightning well enough to figure that out on my own\n> - could you expand more on what effects this would have?\n>\n> It is quite broken.\n> We assume generally that if a payment route fails, that the payer making\n> the payment route loses nothing.\n>\n> Unfortunately, once there is a premium involved for cross-asset swaps, it\n> implies that any failures *after* the swap will now have a cost,\n> specifically, the premium paid.\n> Perhaps you could inform the cross-asset broker who the ultimate payee is\n> so it can retry failures after it on your behalf, but now the broker has\n> the ability to censor payments to payees it does not like.\n>\n> > 2. Cross-asset brokers require counterparties to issue them a symmetric\n> but slightly more out-of-the-money call, which they can redeem in the event\n> of a large FX swing. This bounds their FX losses.\n>\n> I am uncertain what you mean exactly.\n>\n> Do you mean, that if you make a swap on Lightning, which *might* be a\n> Bitcoin-to-WJT American Call Option, I will refuse to forward until I also\n> get something that is a WJT-to-Bitcoin call option, similar to a butterfly\n> spread?\n> That implies that in the \"normal\", non-American-call-option case, the\n> payer has the target asset, which brings up the question: why would the\n> payer even go through the cross-asset broker in a Lightning route if the\n> payer already has the target asset?\n>\n>\n> > There\u2019s another potential partial solution here if we can create some\n> cryptographic protocol for atomically swapping information. This would be\n> used to swap the final HTLC sig for the hash preimage, preventing the\n> optionality issue. This idea was inspired by a paper called \u201cTimed\n> Commitments\u201d by Dan Boneh\n> > (https://www.iacr.org/archive/crypto2000/18800237/18800237.pdf).\n> >\n> > The high level idea is that each party swaps a commitment to the\n> information they want to atomically swap and then slowly reveal verifiable\n> \u201chints\u201d that make it easier and easier to brute force the commitment. Each\n> party takes turns revealing a hint.\n> >\n> > The protocol to do something like this in lightning doesn\u2019t exist afaik\n> but it seems feasible. This also may fail to work when there are\n> intermediary nodes not controlled by the two trading parties.\n>\n> The entire point of using HTLCs in Lightning routing is to enforce that\n> the final payee actually gets paid, or nobody along the route gets paid.\n> From my understanding of this, if this is used, then an intermediate node\n> can try to brute force the preimage instead of actually bothering to\n> forward payments or hints.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181227/ea806ad1/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-28T03:14:39",
                "message_text_only": "Good morning Alex,\n\n> > Do you mean, that if you make a swap on Lightning, which *might* be a Bitcoin-to-WJT American Call Option, I will refuse to forward until I also get something that is a WJT-to-Bitcoin call option, similar to a butterfly spread?\n> > That implies that in the \"normal\", non-American-call-option case, the payer has the target asset, which brings up the question: why would the payer even go through the cross-asset broker in a Lightning route if the payer already has the target asset?\n>\n> No this isn't what I'm suggesting. Let me try to explain again. Apologies if this isn't clear:\n>\n> Let's assume only two parties are engaging in this interaction, you and me. You offer me the WJT/BTC exchange rate from your mult-chain node and I route an LN payment from my BTC node to my WJT node through your multi-chain node. My understanding is that the main problem with this is the free optionality I get when my WJT node does not return the hash preimage immediately to you and instead waits to see if the market price fluctuates out of my favor until option/HTLC expiry. But what if we could atomically swap this preimage for the final HTLC you sent me? If this magical atomic information swap could happen (I don't get the final HTLC unless I reveal the preimage) the payment would settle immediately (in the two party case, let's assume no other intermediary nodes). A timed commitment approach could potentially be feasible if the time required to brute force the commitment is longer than the life of the \"option\"/HTLC. I'm not necessarily suggesting this the optimal solution, but I haven't seen the idea mentioned before.\n\n\nThe issue is that it is impossible for the exchange node to determine if it is talking to one other entity, or several distinct self-interested entities.\n\nIf you and YAIjbOJO were distinct entities, then this issue would not happen.\n\nBecause of Onion routing and the use of pseudonymous public keys, ZmnSCPxj cannot determine if you and YAIjbOJO are different entities.\n\nThus, your proposal must work both in the case where there is multiple hop nodes, and in the case where you and YAIjbOJO are the same entity actually.\n\nSo let us consider the case where you are using BTC to pay a node, randomly named bQqZrrEM, 1.0 WJT.\nYou have found the below route:\n\nyou ->BTC-> ZmnSCPxj ->WJT-> YAIjbOJO ->WJT-> bQqZrrEM\n\nBecause ZmnSCPxj is an exchange node, ZmnSCPxj demands a timed commitment so that the payment pushes through.\n\nNow suppose that the following sequence of events occurs.\n\n1.  Zeus has an affair.\n2.  bQqZrrEM generates a random preimage and provides the hash to you.\n3.  In the domestic argument after Hera finds out about the affair, Zeus randomly throws a lightning bolt that by chance hits and destroys bQqZrrEM.\n4.  You initiate payment starting with ZmnSCPxj.\n\nWhat happens then?\nIf the payment does not push through, then you could instead do:\n\n1.  you/YAIjbOJO/bQqZrrEM (really the same entity) generate a preimage and its hash.\n2.  You delete the bQqZrrEM identity.\n3.  You inititate payment starting with ZmnSCPxj\n\nThis still lets you make an American Call Option by suddenly \"reviving\" the bQqZrrEM identity later in the \"exercise\" branch, or deciding to not revive the bQqZrrEM identity in the \"not exercise\" branch.\n\nOn the other hand, if the payment pushes through regardless of whether or not bQqZrrEm survives, then in the world where bQqZrrEm dies of stray lover quarrel lightning bolt, YAIjbOJO gets paid and I get the money from you, and you are sad because you paid for something you will never get.\n\n> If this magical atomic information swap could happen (I don't get the final HTLC unless I reveal the preimage)\n\nWhat mechanism creates this?\nIf this mechanism involves timelocks also, then what prevents the same American Call Option from being created using the timelock of this magic mechanism?\nThe timelocks could be shorter, but it is still the same riskless free-of-premium American Call Option, so rational entities will continuosly spam exchange nodes with such attempts even if the timelock is short.\n\nDoes this mechanism require that the exchange know who the final destination will be?\nWhat happens if while negotiating this information, one of the intermediate nodes drops?\n\nIf we disallow intermediate nodes, then I know who the final destination will be (it will be the next hop) and I can then exercise my newfound right to censor transactions.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Tamas Blummer",
                "date": "2018-12-27T18:33:18",
                "message_text_only": "ZmnSCPxj,\n\nBrilliant reasoning. I sum it up to make it more accessible: \n\nFailing to route on purpose can be used to opt out of a previously agreed exchange of two differents assets.\nA rational actor will opt out if the exchange is no longer fair. Anyone who grants an option for free heads financial disaster.\n\nThis is not an issue for same asset exchange, as in payment routing, since the exchange remains fair at any later time point. \n\nAlthough there is no escape from above reasoning, a market maker could still be profitable as long as the option is worth less than the bid-ask spread. \nTherefore the issue does not mean that LN cross asset exchange is not feasible, but that there is lower bound on bid-ask spread, that of the option premium.\n\nTamas Blummer\n \n\n> On Dec 27, 2018, at 06:43, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> \n> HTLCs as American Call Option, or, How Lightning Currently Cannot Work Across Assets, or, An Argument For Single-Asset Lightning Network\n> \n> Introduction\n> ============\n> \n> In theory, the Lightning Network could potentially perform \"seamless\" currency conversions, allowing a payer to spend one currency to pay a payee requesting for another currency.\n> However, a significant technical barrier prevents implementation of such feature as of current designs (late 2018) for Lightning.\n> \n> The root cause of this significant technical barrier is the use of hashlocked timelocked contracts to route payments.\n> HTLCs can be used across cryptocurrency systems to transfer value between them.\n> From this point-of-view, every single Lightning Network channel is a cryptocurrency system whose custodians are two entities, who are the only entities who can use the system (the single Lightning Network channel).\n> HTLCs allow cross-system trades to be performed, so that participation on any single Lightning Network channel can be leveraged to participation over the entire Lightning Network.\n> \n> However, HTLCs can also be used to construct American Call Options.\n> Further, due to UX concerns, on the Lightning Network, there is no cost incurred in merely setting up HTLCs for routing.\n> By using the low-level HTLCs provided as primitives by Lightning Network, one can set up American Call Options.\n> These on-Lightning American Call Options, however, can be \"purchased\" for free (gratis), thus potentially earning money in a completely risk-free manner.\n> Abusing this gratis ability means that any Lightning Network node advertising cross-asset on-Lightning exchange will find large amounts of its liquidity tied up in stalled forwarding payments (in reality, American Call Options) with a risk of monetary loss in case of large fluctuations in exchange rate.\n> \n> Hashlocked Timelocked Contracts as American Call Options\n> ========================================================\n> \n> An American CallOption is a right (but not obligation) to purchase an asset at a specific price, on or before an expiration date.\n> HTLCs allow building American Call Options.\n> \n> Suppose we have Bitcoin, and some other asset, and both are on blockchains that support the same hash function and can define HTLCs.\n> It is unimportant if both are on the same blockchain, or on different blockchains, since HTLCs can work across cryptocurrency systems.\n> \n> An American Call Option has these properties:\n> \n> 1.  `P` = the price at which the asset can be purchased.\n> 2.  `E` = the date at which the option expires.\n> \n> Suppose I, ZmnSCPxj, wanted to sell you an American Call Option  for 1 Widget (WJT) on the WJT blockchain.\n> We would then do the below ritual:\n> \n> 1.  You provide me a hash of some secret preimage that only you know.\n> 2.  You make an HTLC on the Bitcoin blockchain.\n>    The value of this HTLC is `P`, the hash is the hash you gave above, and the timelock is `E` + 1 day.\n> 3.  I make an HTLC on the WJT blockchain.\n>    The value of this HTLC is 1, the hash is the hash you gave, and the timelock is `E`.\n> \n> On or before `E`, you can claim the WJT on the WJT blockchain by providing a transaction that reveals the preimage.\n> Since the preimage is now revealed, I can then claim the Bitcoins of price `P` on the Bitcoin blockchain.\n> Alternately, you can simply not exercise this right, and at time `E` I would then reclaim my WJT, and at time `E` + 1 day you would reclaim your bitcoins.\n> \n> Of course, I want to *sell* this contract to you, so you would have to pay me some bitcoins before we set up the above.\n> A multi-stage construction of transactions that go through HTLC-like constructs can be done on both blockchains to ensure that the above contracts appear on both chains only if the payment for the actual contract (i.e. the \"premium\") is done, and to enforce that both contracts appear if the premium is paid, but that is beyond the scope of *this* writeup, which will focus on how Lightning Network HTLCs can form the above construction without any premium being paid.\n> \n> HTLCs For Routing\n> =================\n> \n> HTLCs can be used to enforce trades across different cryptocurrency systems.\n> This property is used to allow routing of payments across different channels.\n> Each channel is its own cryptocurrency system.\n> \n> Suppose I, ZmnSCPxj, am an intermediate node on Lightning, and I wanted to sell you my service of facilitating payments on Lightning.\n> Suppose you want to pay to somebody, who, for the sake of convenience, we shall randomly call YAIjbOJA.\n> As it happens, I have a channel with you, and a channel with YAIjbOJa.\n> \n> You need to pay YAIjbOJA `P` bitcoins.\n> We then perform the below ritual:\n> \n> 1.  YAIjbOJA provides you a hash, whose preimage only YAIjbOJA knows.\n> 2.  On your channel with me, you set up an HTLC.\n>    The value is `P`+1 bitcoin (the 1 being my fee), the hash is the hash you were given, and the timelock is 2 days from now.\n> 3.  On my channel with YAIjbOJA, I set up an HTLC.\n>    The value is `P`, the hash is the same hash as above, and the timelock is 1 day from now.\n> \n> (in reality, the timelocks are parameterized and selected by the payer (you), and LN nodes will impose some \"reasonable\" limits on the timelocks; but the first HTLCs set up must have longer timelocks than the later HTLCs)\n> \n> Afterward, YAIjbOJA may claim, or may not claim, the money in the HTLC by releasing (or not releasing) the hash to me.\n> If YAIjbOJA claims the money, then I can take the hash and claim the money, plus fee, from you.\n> If not, then this is a payment failure and I will then cancel the HTLC you offered using standard Lightning Network primitives.\n> \n> In general, we expect that YAIjbOJA wants to have the money because every randomly-generated imaginary entity likes money.\n> Thus, in the case of payments, YAIjbOJA has a strong incentive to claim the money without waiting for the timelock to expire or nearly expire.\n> We can see that in practice, on the current Lightning Network, HTLCs are often very transient and will be quickly claimed, despite having long timelocks.\n> \n> This speed may mislead us into thinking that such convenience may be possible across different assets.\n> \n> Cross-Asset Lightning Nodes Offer Premium-Free American Call Options\n> ====================================================================\n> \n> Suppose that Lightning Network supports multiple assets.\n> Each channel has a single asset.\n> Some nodes will advertise themselves as providing exchange capability, taking one asset on one channel and exchanging it for another asset on a different channel.\n> \n> Suppose I advertise myself as such an exchange.\n> Suppose you want to pay to YAIjbOJA for 1 WJT, but have no WJT on hand to pay YAIjbOJA, only bitcoins.\n> As it happens, I have a bitcoin channel with you and a WJT channel with YAIjbOJA.\n> I advertise myself as exchanging `P` bitcoins for 1 WJT as of the current time.\n> \n> Further suppose that in reality, YAIjbOJA is *you*, random Internet person reading my thoughts.\n> \n> You, your fake persona YAIjbOJA, and me, then perform the following ritual:\n> \n> 1.  YAIjbOJA (really you) provides you with a hash whose preimage only YAIjbOJA (actually you) know. (i.e. you just make it up)\n> 2.  On the bitcoin channel with me, you set up an HTLC.\n>    The value is `P`+1 bitcoin (the 1 being my fee), the hash is the hash that \"YAIjbOJA\" gave you (i.e. you really just made it up), and the timelock is 2 days from now.\n> 3.  On the WJT channel with YAIjbOJA (really you), I set up an HTLC.\n>    The value is 1 WJT, the hash is the hash you gave me, and the timelock is 1 day from now.\n> \n> The above is now the same as the setup for an American Call Option with expiration of 1 day from now.\n> Further, within certain limits, you can set up the expiration of the American Call Option to be longer or shorter.\n> Thus, I have inadvertently given you an American Call Option, for *no premium* (completely gratis), when my only intent was to facilitate cross-currency Lightning Network payments.\n> \n> Suppose that the price of 1 WJT rises far above the price of `P`+1 bitcoins before the expiration (1 day from now).\n> In such a case, \"YAIjbOJA\" (really you) will then release the hash and acquire the 1 WJT.\n> You then close this channel and claim the WJT onchain, then sell it immediately to earn more than the `P`+1 bitcoins you paid.\n> Alternatively, presumably I would have a new exchange rate I would be willing to exchange WJT for, and you can just send the WJT with the new exchange rate immediately over the Lightning Network.\n> \n> Suppose that the price of WJT does not rise.\n> Since this is an option and *not* a future, \"YAIjbOJA\" (really you) will simply claim that the payment errored somewhere and cancel the HTLCs.\n> Since even payment errors are not unwrappable and are onion-wrapped, I cannot determine whether the payment really errored, or you were just setting up an American Call Option that you have now decided not to exercise.\n> \n> Premium-free American Call Options Are Risk-free Earning Pumps\n> ==============================================================\n> \n> Traditionally, options are analyzed assuming that the option itself has a price, the premium.\n> This premium is the risk of the user of the option.\n> If the user of the option does not exercise the option before the expiration, then the premium is a pure loss of the user.\n> \n> However, the above setup does not involve any payment when the option is not exercised.\n> Payment failures are \"free\" (gratis) on the Lightning Network.\n> However, payment failures are also the non-exercised branch of the American Call Option that can be set up on a cross-currency on-Lightning exchange.\n> \n> Because the American Call Option is premium-free, even if the expiration is very near, rational entities will still construct such options.\n> Extreme volatility may occur in short time frames, especially in the realm of digital assets.\n> \n> Thus, it is strongly likely that, if cross-asset exchange nodes on Lightning Network exist, they will be exploited to create risk-free American Call Options.\n> They will find that significant liquidity will be tied up in such American Call Options, and find that they will lose funds especially at times of volatility.\n> \n> We can try to mitigate this, but the solutions below all have significant drawbacks.\n> \n> 1.  We could force that setting up the HTLCs requires payment.\n>    This forces the above American Call Options to have a premium.\n>    The effect, however, is that routing failure is not free.\n>    The current Lightning Network works despite not everyone publishing the balances of channels, precisely because routing failure is free.\n>    We only need to have one route succeed in order to actually successfully pay to the payee.\n>    With non-free routing failure, we cannot try many routes until one succeeds.\n>    * Suppose we limited this only to cross-asset exchanges.\n>      It would still require accurate knowledge of channel balances.\n>      This is because if a payment fails on a hop *after* the exchange, the payer still loses money from that attempt to the exchange node.\n> 2.  Exchange nodes could increase their fees.\n>    This would create a wider \"spread\" of buying and selling assets.\n>    This spread would increase friction in crossing assets.\n>    Also, this would only reduce risk; if the exchange rate is volatile enough, then the option could still be exercised for riskless earnings.\n>    Rational entities will still tie up most of the liquidity on the exchange on riskless American Call Options; even if the exchange rate is very stable, they lose nothing.\n> 3.  Exchange nodes could limit the timelock of cross-asset swaps.\n>    This would increase friction in crossing assets, since a timelock limit also imposes a limit to the route length.\n>    If one asset is much stronger than the other, then the weaker asset will find its part of the Lightning Network to be strongly centralized around the exchanges between the two assets.\n>    Payees of the weaker asset will strongly prefer to be at most one hop away from exchanges in order to viably receive payments from payers who are using the stronger asset.\n>    Again, rational entities will also still tie up most of the liquidity on the exchange on riskless American Call Options; again, even if the exchange rate is very stable in short time frames, they lose nothing anyway.\n> \n> Conclusion\n> ==========\n> \n> HTLCs allow creation of American Call Options.\n> The same HTLCs are used in Lightning Network to route across channels.\n> If using a single asset, there is no issue related to time.\n> Regardless of the value of bitcoin relative to any other asset, in the future, 1 BTC is 1 BTC.\n> \n> However, across assets, the ability of HTLCs to create American Call Options becomes troublesome.\n> These can then be exploited to earn money from exercise of the option.\n> Further, because Lightning UX would be degraded otherwise, payment failures are free (gratis), leading to the American Call Options also being free of premium.\n> This means that creating such options would be riskless, allowing potential earnings upon any strong volatility of exchange rates.\n> \n> This implies that a multi-asset Lightning Network may not be economically viable.\n> Instead, Lightning Network would strongly prefer having a single asset across the network.\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "James Asefa",
                "date": "2018-12-27T22:33:43",
                "message_text_only": "It seems like the router in this case is essentially short a straddle on\nthe BTC vs. WJT exchange rate with almost 0 premium. One way for the router\nto hedge this is to be long an equivalent straddle by constructing their\nown cross-chain payment to themselves with some other node, for the same\namount.\n\nThis obviously can't scale to all participants, but can possibly provide a\nhedge for a single node.\n\nOn Thu, Dec 27, 2018 at 1:33 PM Tamas Blummer <tamas.blummer at gmail.com>\nwrote:\n\n> ZmnSCPxj,\n>\n> Brilliant reasoning. I sum it up to make it more accessible:\n>\n> Failing to route on purpose can be used to opt out of a previously agreed\n> exchange of two differents assets.\n> A rational actor will opt out if the exchange is no longer fair. Anyone\n> who grants an option for free heads financial disaster.\n>\n> This is not an issue for same asset exchange, as in payment routing, since\n> the exchange remains fair at any later time point.\n>\n> Although there is no escape from above reasoning, a market maker could\n> still be profitable as long as the option is worth less than the bid-ask\n> spread.\n> Therefore the issue does not mean that LN cross asset exchange is not\n> feasible, but that there is lower bound on bid-ask spread, that of the\n> option premium.\n>\n> Tamas Blummer\n>\n>\n> > On Dec 27, 2018, at 06:43, ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >\n> > HTLCs as American Call Option, or, How Lightning Currently Cannot Work\n> Across Assets, or, An Argument For Single-Asset Lightning Network\n> >\n> > Introduction\n> > ============\n> >\n> > In theory, the Lightning Network could potentially perform \"seamless\"\n> currency conversions, allowing a payer to spend one currency to pay a payee\n> requesting for another currency.\n> > However, a significant technical barrier prevents implementation of such\n> feature as of current designs (late 2018) for Lightning.\n> >\n> > The root cause of this significant technical barrier is the use of\n> hashlocked timelocked contracts to route payments.\n> > HTLCs can be used across cryptocurrency systems to transfer value\n> between them.\n> > From this point-of-view, every single Lightning Network channel is a\n> cryptocurrency system whose custodians are two entities, who are the only\n> entities who can use the system (the single Lightning Network channel).\n> > HTLCs allow cross-system trades to be performed, so that participation\n> on any single Lightning Network channel can be leveraged to participation\n> over the entire Lightning Network.\n> >\n> > However, HTLCs can also be used to construct American Call Options.\n> > Further, due to UX concerns, on the Lightning Network, there is no cost\n> incurred in merely setting up HTLCs for routing.\n> > By using the low-level HTLCs provided as primitives by Lightning\n> Network, one can set up American Call Options.\n> > These on-Lightning American Call Options, however, can be \"purchased\"\n> for free (gratis), thus potentially earning money in a completely risk-free\n> manner.\n> > Abusing this gratis ability means that any Lightning Network node\n> advertising cross-asset on-Lightning exchange will find large amounts of\n> its liquidity tied up in stalled forwarding payments (in reality, American\n> Call Options) with a risk of monetary loss in case of large fluctuations in\n> exchange rate.\n> >\n> > Hashlocked Timelocked Contracts as American Call Options\n> > ========================================================\n> >\n> > An American CallOption is a right (but not obligation) to purchase an\n> asset at a specific price, on or before an expiration date.\n> > HTLCs allow building American Call Options.\n> >\n> > Suppose we have Bitcoin, and some other asset, and both are on\n> blockchains that support the same hash function and can define HTLCs.\n> > It is unimportant if both are on the same blockchain, or on different\n> blockchains, since HTLCs can work across cryptocurrency systems.\n> >\n> > An American Call Option has these properties:\n> >\n> > 1.  `P` = the price at which the asset can be purchased.\n> > 2.  `E` = the date at which the option expires.\n> >\n> > Suppose I, ZmnSCPxj, wanted to sell you an American Call Option  for 1\n> Widget (WJT) on the WJT blockchain.\n> > We would then do the below ritual:\n> >\n> > 1.  You provide me a hash of some secret preimage that only you know.\n> > 2.  You make an HTLC on the Bitcoin blockchain.\n> >    The value of this HTLC is `P`, the hash is the hash you gave above,\n> and the timelock is `E` + 1 day.\n> > 3.  I make an HTLC on the WJT blockchain.\n> >    The value of this HTLC is 1, the hash is the hash you gave, and the\n> timelock is `E`.\n> >\n> > On or before `E`, you can claim the WJT on the WJT blockchain by\n> providing a transaction that reveals the preimage.\n> > Since the preimage is now revealed, I can then claim the Bitcoins of\n> price `P` on the Bitcoin blockchain.\n> > Alternately, you can simply not exercise this right, and at time `E` I\n> would then reclaim my WJT, and at time `E` + 1 day you would reclaim your\n> bitcoins.\n> >\n> > Of course, I want to *sell* this contract to you, so you would have to\n> pay me some bitcoins before we set up the above.\n> > A multi-stage construction of transactions that go through HTLC-like\n> constructs can be done on both blockchains to ensure that the above\n> contracts appear on both chains only if the payment for the actual contract\n> (i.e. the \"premium\") is done, and to enforce that both contracts appear if\n> the premium is paid, but that is beyond the scope of *this* writeup, which\n> will focus on how Lightning Network HTLCs can form the above construction\n> without any premium being paid.\n> >\n> > HTLCs For Routing\n> > =================\n> >\n> > HTLCs can be used to enforce trades across different cryptocurrency\n> systems.\n> > This property is used to allow routing of payments across different\n> channels.\n> > Each channel is its own cryptocurrency system.\n> >\n> > Suppose I, ZmnSCPxj, am an intermediate node on Lightning, and I wanted\n> to sell you my service of facilitating payments on Lightning.\n> > Suppose you want to pay to somebody, who, for the sake of convenience,\n> we shall randomly call YAIjbOJA.\n> > As it happens, I have a channel with you, and a channel with YAIjbOJa.\n> >\n> > You need to pay YAIjbOJA `P` bitcoins.\n> > We then perform the below ritual:\n> >\n> > 1.  YAIjbOJA provides you a hash, whose preimage only YAIjbOJA knows.\n> > 2.  On your channel with me, you set up an HTLC.\n> >    The value is `P`+1 bitcoin (the 1 being my fee), the hash is the hash\n> you were given, and the timelock is 2 days from now.\n> > 3.  On my channel with YAIjbOJA, I set up an HTLC.\n> >    The value is `P`, the hash is the same hash as above, and the\n> timelock is 1 day from now.\n> >\n> > (in reality, the timelocks are parameterized and selected by the payer\n> (you), and LN nodes will impose some \"reasonable\" limits on the timelocks;\n> but the first HTLCs set up must have longer timelocks than the later HTLCs)\n> >\n> > Afterward, YAIjbOJA may claim, or may not claim, the money in the HTLC\n> by releasing (or not releasing) the hash to me.\n> > If YAIjbOJA claims the money, then I can take the hash and claim the\n> money, plus fee, from you.\n> > If not, then this is a payment failure and I will then cancel the HTLC\n> you offered using standard Lightning Network primitives.\n> >\n> > In general, we expect that YAIjbOJA wants to have the money because\n> every randomly-generated imaginary entity likes money.\n> > Thus, in the case of payments, YAIjbOJA has a strong incentive to claim\n> the money without waiting for the timelock to expire or nearly expire.\n> > We can see that in practice, on the current Lightning Network, HTLCs are\n> often very transient and will be quickly claimed, despite having long\n> timelocks.\n> >\n> > This speed may mislead us into thinking that such convenience may be\n> possible across different assets.\n> >\n> > Cross-Asset Lightning Nodes Offer Premium-Free American Call Options\n> > ====================================================================\n> >\n> > Suppose that Lightning Network supports multiple assets.\n> > Each channel has a single asset.\n> > Some nodes will advertise themselves as providing exchange capability,\n> taking one asset on one channel and exchanging it for another asset on a\n> different channel.\n> >\n> > Suppose I advertise myself as such an exchange.\n> > Suppose you want to pay to YAIjbOJA for 1 WJT, but have no WJT on hand\n> to pay YAIjbOJA, only bitcoins.\n> > As it happens, I have a bitcoin channel with you and a WJT channel with\n> YAIjbOJA.\n> > I advertise myself as exchanging `P` bitcoins for 1 WJT as of the\n> current time.\n> >\n> > Further suppose that in reality, YAIjbOJA is *you*, random Internet\n> person reading my thoughts.\n> >\n> > You, your fake persona YAIjbOJA, and me, then perform the following\n> ritual:\n> >\n> > 1.  YAIjbOJA (really you) provides you with a hash whose preimage only\n> YAIjbOJA (actually you) know. (i.e. you just make it up)\n> > 2.  On the bitcoin channel with me, you set up an HTLC.\n> >    The value is `P`+1 bitcoin (the 1 being my fee), the hash is the hash\n> that \"YAIjbOJA\" gave you (i.e. you really just made it up), and the\n> timelock is 2 days from now.\n> > 3.  On the WJT channel with YAIjbOJA (really you), I set up an HTLC.\n> >    The value is 1 WJT, the hash is the hash you gave me, and the\n> timelock is 1 day from now.\n> >\n> > The above is now the same as the setup for an American Call Option with\n> expiration of 1 day from now.\n> > Further, within certain limits, you can set up the expiration of the\n> American Call Option to be longer or shorter.\n> > Thus, I have inadvertently given you an American Call Option, for *no\n> premium* (completely gratis), when my only intent was to facilitate\n> cross-currency Lightning Network payments.\n> >\n> > Suppose that the price of 1 WJT rises far above the price of `P`+1\n> bitcoins before the expiration (1 day from now).\n> > In such a case, \"YAIjbOJA\" (really you) will then release the hash and\n> acquire the 1 WJT.\n> > You then close this channel and claim the WJT onchain, then sell it\n> immediately to earn more than the `P`+1 bitcoins you paid.\n> > Alternatively, presumably I would have a new exchange rate I would be\n> willing to exchange WJT for, and you can just send the WJT with the new\n> exchange rate immediately over the Lightning Network.\n> >\n> > Suppose that the price of WJT does not rise.\n> > Since this is an option and *not* a future, \"YAIjbOJA\" (really you) will\n> simply claim that the payment errored somewhere and cancel the HTLCs.\n> > Since even payment errors are not unwrappable and are onion-wrapped, I\n> cannot determine whether the payment really errored, or you were just\n> setting up an American Call Option that you have now decided not to\n> exercise.\n> >\n> > Premium-free American Call Options Are Risk-free Earning Pumps\n> > ==============================================================\n> >\n> > Traditionally, options are analyzed assuming that the option itself has\n> a price, the premium.\n> > This premium is the risk of the user of the option.\n> > If the user of the option does not exercise the option before the\n> expiration, then the premium is a pure loss of the user.\n> >\n> > However, the above setup does not involve any payment when the option is\n> not exercised.\n> > Payment failures are \"free\" (gratis) on the Lightning Network.\n> > However, payment failures are also the non-exercised branch of the\n> American Call Option that can be set up on a cross-currency on-Lightning\n> exchange.\n> >\n> > Because the American Call Option is premium-free, even if the expiration\n> is very near, rational entities will still construct such options.\n> > Extreme volatility may occur in short time frames, especially in the\n> realm of digital assets.\n> >\n> > Thus, it is strongly likely that, if cross-asset exchange nodes on\n> Lightning Network exist, they will be exploited to create risk-free\n> American Call Options.\n> > They will find that significant liquidity will be tied up in such\n> American Call Options, and find that they will lose funds especially at\n> times of volatility.\n> >\n> > We can try to mitigate this, but the solutions below all have\n> significant drawbacks.\n> >\n> > 1.  We could force that setting up the HTLCs requires payment.\n> >    This forces the above American Call Options to have a premium.\n> >    The effect, however, is that routing failure is not free.\n> >    The current Lightning Network works despite not everyone publishing\n> the balances of channels, precisely because routing failure is free.\n> >    We only need to have one route succeed in order to actually\n> successfully pay to the payee.\n> >    With non-free routing failure, we cannot try many routes until one\n> succeeds.\n> >    * Suppose we limited this only to cross-asset exchanges.\n> >      It would still require accurate knowledge of channel balances.\n> >      This is because if a payment fails on a hop *after* the exchange,\n> the payer still loses money from that attempt to the exchange node.\n> > 2.  Exchange nodes could increase their fees.\n> >    This would create a wider \"spread\" of buying and selling assets.\n> >    This spread would increase friction in crossing assets.\n> >    Also, this would only reduce risk; if the exchange rate is volatile\n> enough, then the option could still be exercised for riskless earnings.\n> >    Rational entities will still tie up most of the liquidity on the\n> exchange on riskless American Call Options; even if the exchange rate is\n> very stable, they lose nothing.\n> > 3.  Exchange nodes could limit the timelock of cross-asset swaps.\n> >    This would increase friction in crossing assets, since a timelock\n> limit also imposes a limit to the route length.\n> >    If one asset is much stronger than the other, then the weaker asset\n> will find its part of the Lightning Network to be strongly centralized\n> around the exchanges between the two assets.\n> >    Payees of the weaker asset will strongly prefer to be at most one hop\n> away from exchanges in order to viably receive payments from payers who are\n> using the stronger asset.\n> >    Again, rational entities will also still tie up most of the liquidity\n> on the exchange on riskless American Call Options; again, even if the\n> exchange rate is very stable in short time frames, they lose nothing anyway.\n> >\n> > Conclusion\n> > ==========\n> >\n> > HTLCs allow creation of American Call Options.\n> > The same HTLCs are used in Lightning Network to route across channels.\n> > If using a single asset, there is no issue related to time.\n> > Regardless of the value of bitcoin relative to any other asset, in the\n> future, 1 BTC is 1 BTC.\n> >\n> > However, across assets, the ability of HTLCs to create American Call\n> Options becomes troublesome.\n> > These can then be exploited to earn money from exercise of the option.\n> > Further, because Lightning UX would be degraded otherwise, payment\n> failures are free (gratis), leading to the American Call Options also being\n> free of premium.\n> > This means that creating such options would be riskless, allowing\n> potential earnings upon any strong volatility of exchange rates.\n> >\n> > This implies that a multi-asset Lightning Network may not be\n> economically viable.\n> > Instead, Lightning Network would strongly prefer having a single asset\n> across the network.\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181227/f5c23e96/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-28T03:53:22",
                "message_text_only": "Good morning James,\n\n\n> It seems like the router in this case is essentially short a straddle on the BTC vs. WJT exchange rate with almost 0 premium. One way for the router to hedge this is to be long an equivalent straddle by constructing their own cross-chain payment to themselves with some other node, for the same amount.\u00a0\n\nSuppose there are two nodes on the LN who provide a BTC/WJT exchange.\nNow suppose one of those nodes is selected as an intermediate hop node for somebody paying using BTC somebody who wants WJT.\n\nThat node uses the other node to construct an American Call Option to construct a straddle.\n\nThe other node, in response, uses the first node to construct a straddle.\n\nThe first node, now being short a straddle, uses the other node to construct an American Call Option to construct a straddle.\n\nThis goes on until both nodes now have all their liquidity locked up in hedges.\n\nIf the payment that originally started this whole monstrosity turns out to be an American Call Option in the first place, then neither exchange node will be willing to \"disarm\" any of their hedges.\nThe liquidity of the exchange nodes is tied up and nobody can make any BTC->WJT and WJT->BTC exchanges on Lightning.\n\nIn short, this simply attempts to make it a problem of somebody else, not solve the problem.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-28T03:34:13",
                "message_text_only": "Good morning Tamas,\n\n> Although there is no escape from above reasoning, a market maker could still be profitable as long as the option is worth less than the bid-ask spread.\n> Therefore the issue does not mean that LN cross asset exchange is not feasible, but that there is lower bound on bid-ask spread, that of the option premium.\n\nThe option premium cannot be charged in the not-exercised branch.\nThis is effectively a premium-free option.\nThis means that rational entities who know of this technique will create options \"for free\" until the exchange runs out of liquidity.\nThis is because, even if the exchange rate does not go beyond the bid-ask spread, the not-exercised branch is free of charge.\n\nSince all their liquidity is tied up in premium-free American Call Options, exchange nodes cannot usefully bridge between a BTC Lightning Network and any other asset.\nRouting attempts will usually fail.\nIn a very practical sense, it would not be possible to create a multi-asset LN.\n\n\n--\n\nI had long ago figured out that HTLCs can create American Call Options (more than a year ago).\nThe problem was that they tied up the assets involved into the contract, so I never bothered to publish this insight.\nHowever, on LN, HTLCs are created \"for free\" with no payment, which is a significant advantage to the user of an American Call Option, who would be quite willing to tie up their funds in HTLCs since the not-exercised branch of the American Call Option formed was free of premium.\nTheir only cost is opportunity cost, and on the LN, with tiny tiny tiny fees, opportunity cost of having the funds free is very small.\nOne can say that the opportunity cost is the premium paid, but note that it is not paid to the exchange, since the exchange itself is also forced to tie up its other asset into another HTLC (meaning it also pays the opportunity cost).\n\nWhat I suspect will happen is that the LN on the weaker asset (i.e. less popular, fewer users, etc.) will find itself unable to be paid by the LN on the stronger asset.\nThis will weaken the weaker asset even further (users will leave it for the stronger asset).\nThis creates a shift in exchange rate, which is precisely what the American Call Options are waiting for.\nThese American Call Options drain funds from the exchange, until the exchange stops being profitable and stops operating as an exchange, again further weakening the weaker asset as it is now even harder to pay from the stronger asset network to the weaker asset network, and so on.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Tamas Blummer",
                "date": "2018-12-28T21:22:18",
                "message_text_only": "Hi ZmnSCPxj,\n\nMaking an asset swap offer using HTLC ties up funds and the offer may be taken up-until  the timelock expiry.\nTherefore making such an offer implies both opportunity cost and a premium for optional exercise.\n\nThere is no mechanism in LN to require compensation for above costs, therefore you imply that no sane person would make such an offer.\n\nI think, that instead exchanges will still make such offers but with an exchange rate between the assets that compensate them for the cost they incure by making the offer.\nExchanges will also limit the quantity of outstanding offers, so they can manage the risk of options written. This might lead to making offers only to known traders or to those,\nwho pay for receiving an offer with a regular LN payment in-advance.\n\nTamas Blummer\n\n\n\n> On Dec 28, 2018, at 04:34, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Tamas,\n> \n>> Although there is no escape from above reasoning, a market maker could still be profitable as long as the option is worth less than the bid-ask spread.\n>> Therefore the issue does not mean that LN cross asset exchange is not feasible, but that there is lower bound on bid-ask spread, that of the option premium.\n> \n> The option premium cannot be charged in the not-exercised branch.\n> This is effectively a premium-free option.\n> This means that rational entities who know of this technique will create options \"for free\" until the exchange runs out of liquidity.\n> This is because, even if the exchange rate does not go beyond the bid-ask spread, the not-exercised branch is free of charge.\n> \n> Since all their liquidity is tied up in premium-free American Call Options, exchange nodes cannot usefully bridge between a BTC Lightning Network and any other asset.\n> Routing attempts will usually fail.\n> In a very practical sense, it would not be possible to create a multi-asset LN.\n> \n> \n> --\n> \n> I had long ago figured out that HTLCs can create American Call Options (more than a year ago).\n> The problem was that they tied up the assets involved into the contract, so I never bothered to publish this insight.\n> However, on LN, HTLCs are created \"for free\" with no payment, which is a significant advantage to the user of an American Call Option, who would be quite willing to tie up their funds in HTLCs since the not-exercised branch of the American Call Option formed was free of premium.\n> Their only cost is opportunity cost, and on the LN, with tiny tiny tiny fees, opportunity cost of having the funds free is very small.\n> One can say that the opportunity cost is the premium paid, but note that it is not paid to the exchange, since the exchange itself is also forced to tie up its other asset into another HTLC (meaning it also pays the opportunity cost).\n> \n> What I suspect will happen is that the LN on the weaker asset (i.e. less popular, fewer users, etc.) will find itself unable to be paid by the LN on the stronger asset.\n> This will weaken the weaker asset even further (users will leave it for the stronger asset).\n> This creates a shift in exchange rate, which is precisely what the American Call Options are waiting for.\n> These American Call Options drain funds from the exchange, until the exchange stops being profitable and stops operating as an exchange, again further weakening the weaker asset as it is now even harder to pay from the stronger asset network to the weaker asset network, and so on.\n> \n> \n> Regards,\n> ZmnSCPxj\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20181228/af759a5d/attachment.sig>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2018-12-28T22:25:20",
                "message_text_only": "Hi ZmnSCPxj,\n\nYou are right that an exchange can not simply embed the option into the offer price as there is no payment in case the offer is not taken,  so nothing would pay for their hedging costs.\n\nThis however is not a unique situation, but people deal with it frequently. Every offer has a timespan within which the market maker can not back out, and in your language writes a free option. \nThat timespan might be very short on an electronic trading platform or rather long in trade finance. Bid-ask spreads of the offer reflect that and those making the offers manage or at least limit the market and liquidity risk of outstanding offers.\n\nJust because there is no trustless automated solution in sight, we should not assume things will not exist. In contrary, this imperfection will invite people offering a service for profit.\n\nTamas Blummer\n\n\n> On Dec 28, 2018, at 22:22, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> Hi ZmnSCPxj,\n> \n> Making an asset swap offer using HTLC ties up funds and the offer may be taken up-until  the timelock expiry.\n> Therefore making such an offer implies both opportunity cost and a premium for optional exercise.\n> \n> There is no mechanism in LN to require compensation for above costs, therefore you imply that no sane person would make such an offer.\n> \n> I think, that instead exchanges will still make such offers but with an exchange rate between the assets that compensate them for the cost they incure by making the offer.\n> Exchanges will also limit the quantity of outstanding offers, so they can manage the risk of options written. This might lead to making offers only to known traders or to those,\n> who pay for receiving an offer with a regular LN payment in-advance.\n> \n> Tamas Blummer\n> \n> \n> \n>> On Dec 28, 2018, at 04:34, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>> \n>> Good morning Tamas,\n>> \n>>> Although there is no escape from above reasoning, a market maker could still be profitable as long as the option is worth less than the bid-ask spread.\n>>> Therefore the issue does not mean that LN cross asset exchange is not feasible, but that there is lower bound on bid-ask spread, that of the option premium.\n>> \n>> The option premium cannot be charged in the not-exercised branch.\n>> This is effectively a premium-free option.\n>> This means that rational entities who know of this technique will create options \"for free\" until the exchange runs out of liquidity.\n>> This is because, even if the exchange rate does not go beyond the bid-ask spread, the not-exercised branch is free of charge.\n>> \n>> Since all their liquidity is tied up in premium-free American Call Options, exchange nodes cannot usefully bridge between a BTC Lightning Network and any other asset.\n>> Routing attempts will usually fail.\n>> In a very practical sense, it would not be possible to create a multi-asset LN.\n>> \n>> \n>> --\n>> \n>> I had long ago figured out that HTLCs can create American Call Options (more than a year ago).\n>> The problem was that they tied up the assets involved into the contract, so I never bothered to publish this insight.\n>> However, on LN, HTLCs are created \"for free\" with no payment, which is a significant advantage to the user of an American Call Option, who would be quite willing to tie up their funds in HTLCs since the not-exercised branch of the American Call Option formed was free of premium.\n>> Their only cost is opportunity cost, and on the LN, with tiny tiny tiny fees, opportunity cost of having the funds free is very small.\n>> One can say that the opportunity cost is the premium paid, but note that it is not paid to the exchange, since the exchange itself is also forced to tie up its other asset into another HTLC (meaning it also pays the opportunity cost).\n>> \n>> What I suspect will happen is that the LN on the weaker asset (i.e. less popular, fewer users, etc.) will find itself unable to be paid by the LN on the stronger asset.\n>> This will weaken the weaker asset even further (users will leave it for the stronger asset).\n>> This creates a shift in exchange rate, which is precisely what the American Call Options are waiting for.\n>> These American Call Options drain funds from the exchange, until the exchange stops being profitable and stops operating as an exchange, again further weakening the weaker asset as it is now even harder to pay from the stronger asset network to the weaker asset network, and so on.\n>> \n>> \n>> Regards,\n>> ZmnSCPxj\n>"
            },
            {
                "author": "CJP",
                "date": "2018-12-28T08:27:11",
                "message_text_only": "Hi ZmnSCPxj,\n\nI think we've already addressed this issue before:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/0012\n92.html\n\nand especially this proposal of me:\nhttps://bitonic.nl/public/slowdown_prevention.pdf\n\nIt's not completely trustless, but I tend to see trustlessness in a\nvery pragmatic sense anyway. Trust creates a risk, but if the\nalternative trustless system is very impractical, and the risk is small\nenough, the benefits might simply be worth the risks. Note that this is\na completely subjective trade-off, so it is only acceptable on an\nindividual, voluntary basis.\n\nCJP\n\nZmnSCPxj via Lightning-dev schreef op do 27-12-2018 om 05:43 [+0000]:\n> HTLCs as American Call Option, or, How Lightning Currently Cannot\n> Work Across Assets, or, An Argument For Single-Asset Lightning\n> Network\n> \n> Introduction\n> ============\n> \n> In theory, the Lightning Network could potentially perform \"seamless\"\n> currency conversions, allowing a payer to spend one currency to pay a\n> payee requesting for another currency.\n> However, a significant technical barrier prevents implementation of\n> such feature as of current designs (late 2018) for Lightning.\n> \n> The root cause of this significant technical barrier is the use of\n> hashlocked timelocked contracts to route payments.\n> HTLCs can be used across cryptocurrency systems to transfer value\n> between them.\n> From this point-of-view, every single Lightning Network channel is a\n> cryptocurrency system whose custodians are two entities, who are the\n> only entities who can use the system (the single Lightning Network\n> channel).\n> HTLCs allow cross-system trades to be performed, so that\n> participation on any single Lightning Network channel can be\n> leveraged to participation over the entire Lightning Network.\n> \n> However, HTLCs can also be used to construct American Call Options.\n> Further, due to UX concerns, on the Lightning Network, there is no\n> cost incurred in merely setting up HTLCs for routing.\n> By using the low-level HTLCs provided as primitives by Lightning\n> Network, one can set up American Call Options.\n> These on-Lightning American Call Options, however, can be \"purchased\"\n> for free (gratis), thus potentially earning money in a completely\n> risk-free manner.\n> Abusing this gratis ability means that any Lightning Network node\n> advertising cross-asset on-Lightning exchange will find large amounts\n> of its liquidity tied up in stalled forwarding payments (in reality,\n> American Call Options) with a risk of monetary loss in case of large\n> fluctuations in exchange rate.\n> \n> Hashlocked Timelocked Contracts as American Call Options\n> ========================================================\n> \n> An American CallOption is a right (but not obligation) to purchase an\n> asset at a specific price, on or before an expiration date.\n> HTLCs allow building American Call Options.\n> \n> Suppose we have Bitcoin, and some other asset, and both are on\n> blockchains that support the same hash function and can define HTLCs.\n> It is unimportant if both are on the same blockchain, or on different\n> blockchains, since HTLCs can work across cryptocurrency systems.\n> \n> An American Call Option has these properties:\n> \n> 1.\u00a0\u00a0`P` = the price at which the asset can be purchased.\n> 2.\u00a0\u00a0`E` = the date at which the option expires.\n> \n> Suppose I, ZmnSCPxj, wanted to sell you an American Call Option\u00a0\u00a0for\n> 1 Widget (WJT) on the WJT blockchain.\n> We would then do the below ritual:\n> \n> 1.\u00a0\u00a0You provide me a hash of some secret preimage that only you know.\n> 2.\u00a0\u00a0You make an HTLC on the Bitcoin blockchain.\n> \u00a0\u00a0\u00a0\u00a0The value of this HTLC is `P`, the hash is the hash you gave\n> above, and the timelock is `E` + 1 day.\n> 3.\u00a0\u00a0I make an HTLC on the WJT blockchain.\n> \u00a0\u00a0\u00a0\u00a0The value of this HTLC is 1, the hash is the hash you gave, and\n> the timelock is `E`.\n> \n> On or before `E`, you can claim the WJT on the WJT blockchain by\n> providing a transaction that reveals the preimage.\n> Since the preimage is now revealed, I can then claim the Bitcoins of\n> price `P` on the Bitcoin blockchain.\n> Alternately, you can simply not exercise this right, and at time `E`\n> I would then reclaim my WJT, and at time `E` + 1 day you would\n> reclaim your bitcoins.\n> \n> Of course, I want to *sell* this contract to you, so you would have\n> to pay me some bitcoins before we set up the above.\n> A multi-stage construction of transactions that go through HTLC-like\n> constructs can be done on both blockchains to ensure that the above\n> contracts appear on both chains only if the payment for the actual\n> contract (i.e. the \"premium\") is done, and to enforce that both\n> contracts appear if the premium is paid, but that is beyond the scope\n> of *this* writeup, which will focus on how Lightning Network HTLCs\n> can form the above construction without any premium being paid.\n> \n> HTLCs For Routing\n> =================\n> \n> HTLCs can be used to enforce trades across different cryptocurrency\n> systems.\n> This property is used to allow routing of payments across different\n> channels.\n> Each channel is its own cryptocurrency system.\n> \n> Suppose I, ZmnSCPxj, am an intermediate node on Lightning, and I\n> wanted to sell you my service of facilitating payments on Lightning.\n> Suppose you want to pay to somebody, who, for the sake of\n> convenience, we shall randomly call YAIjbOJA.\n> As it happens, I have a channel with you, and a channel with\n> YAIjbOJa.\n> \n> You need to pay YAIjbOJA `P` bitcoins.\n> We then perform the below ritual:\n> \n> 1.\u00a0\u00a0YAIjbOJA provides you a hash, whose preimage only YAIjbOJA knows.\n> 2.\u00a0\u00a0On your channel with me, you set up an HTLC.\n> \u00a0\u00a0\u00a0\u00a0The value is `P`+1 bitcoin (the 1 being my fee), the hash is the\n> hash you were given, and the timelock is 2 days from now.\n> 3.\u00a0\u00a0On my channel with YAIjbOJA, I set up an HTLC.\n> \u00a0\u00a0\u00a0\u00a0The value is `P`, the hash is the same hash as above, and the\n> timelock is 1 day from now.\n> \n> (in reality, the timelocks are parameterized and selected by the\n> payer (you), and LN nodes will impose some \"reasonable\" limits on the\n> timelocks; but the first HTLCs set up must have longer timelocks than\n> the later HTLCs)\n> \n> Afterward, YAIjbOJA may claim, or may not claim, the money in the\n> HTLC by releasing (or not releasing) the hash to me.\n> If YAIjbOJA claims the money, then I can take the hash and claim the\n> money, plus fee, from you.\n> If not, then this is a payment failure and I will then cancel the\n> HTLC you offered using standard Lightning Network primitives.\n> \n> In general, we expect that YAIjbOJA wants to have the money because\n> every randomly-generated imaginary entity likes money.\n> Thus, in the case of payments, YAIjbOJA has a strong incentive to\n> claim the money without waiting for the timelock to expire or nearly\n> expire.\n> We can see that in practice, on the current Lightning Network, HTLCs\n> are often very transient and will be quickly claimed, despite having\n> long timelocks.\n> \n> This speed may mislead us into thinking that such convenience may be\n> possible across different assets.\n> \n> Cross-Asset Lightning Nodes Offer Premium-Free American Call Options\n> ====================================================================\n> \n> Suppose that Lightning Network supports multiple assets.\n> Each channel has a single asset.\n> Some nodes will advertise themselves as providing exchange\n> capability, taking one asset on one channel and exchanging it for\n> another asset on a different channel.\n> \n> Suppose I advertise myself as such an exchange.\n> Suppose you want to pay to YAIjbOJA for 1 WJT, but have no WJT on\n> hand to pay YAIjbOJA, only bitcoins.\n> As it happens, I have a bitcoin channel with you and a WJT channel\n> with YAIjbOJA.\n> I advertise myself as exchanging `P` bitcoins for 1 WJT as of the\n> current time.\n> \n> Further suppose that in reality, YAIjbOJA is *you*, random Internet\n> person reading my thoughts.\n> \n> You, your fake persona YAIjbOJA, and me, then perform the following\n> ritual:\n> \n> 1.\u00a0\u00a0YAIjbOJA (really you) provides you with a hash whose preimage\n> only YAIjbOJA (actually you) know. (i.e. you just make it up)\n> 2.\u00a0\u00a0On the bitcoin channel with me, you set up an HTLC.\n> \u00a0\u00a0\u00a0\u00a0The value is `P`+1 bitcoin (the 1 being my fee), the hash is the\n> hash that \"YAIjbOJA\" gave you (i.e. you really just made it up), and\n> the timelock is 2 days from now.\n> 3.\u00a0\u00a0On the WJT channel with YAIjbOJA (really you), I set up an HTLC.\n> \u00a0\u00a0\u00a0\u00a0The value is 1 WJT, the hash is the hash you gave me, and the\n> timelock is 1 day from now.\n> \n> The above is now the same as the setup for an American Call Option\n> with expiration of 1 day from now.\n> Further, within certain limits, you can set up the expiration of the\n> American Call Option to be longer or shorter.\n> Thus, I have inadvertently given you an American Call Option, for *no\n> premium* (completely gratis), when my only intent was to facilitate\n> cross-currency Lightning Network payments.\n> \n> Suppose that the price of 1 WJT rises far above the price of `P`+1\n> bitcoins before the expiration (1 day from now).\n> In such a case, \"YAIjbOJA\" (really you) will then release the hash\n> and acquire the 1 WJT.\n> You then close this channel and claim the WJT onchain, then sell it\n> immediately to earn more than the `P`+1 bitcoins you paid.\n> Alternatively, presumably I would have a new exchange rate I would be\n> willing to exchange WJT for, and you can just send the WJT with the\n> new exchange rate immediately over the Lightning Network.\n> \n> Suppose that the price of WJT does not rise.\n> Since this is an option and *not* a future, \"YAIjbOJA\" (really you)\n> will simply claim that the payment errored somewhere and cancel the\n> HTLCs.\n> Since even payment errors are not unwrappable and are onion-wrapped,\n> I cannot determine whether the payment really errored, or you were\n> just setting up an American Call Option that you have now decided not\n> to exercise.\n> \n> Premium-free American Call Options Are Risk-free Earning Pumps\n> ==============================================================\n> \n> Traditionally, options are analyzed assuming that the option itself\n> has a price, the premium.\n> This premium is the risk of the user of the option.\n> If the user of the option does not exercise the option before the\n> expiration, then the premium is a pure loss of the user.\n> \n> However, the above setup does not involve any payment when the option\n> is not exercised.\n> Payment failures are \"free\" (gratis) on the Lightning Network.\n> However, payment failures are also the non-exercised branch of the\n> American Call Option that can be set up on a cross-currency on-\n> Lightning exchange.\n> \n> Because the American Call Option is premium-free, even if the\n> expiration is very near, rational entities will still construct such\n> options.\n> Extreme volatility may occur in short time frames, especially in the\n> realm of digital assets.\n> \n> Thus, it is strongly likely that, if cross-asset exchange nodes on\n> Lightning Network exist, they will be exploited to create risk-free\n> American Call Options.\n> They will find that significant liquidity will be tied up in such\n> American Call Options, and find that they will lose funds especially\n> at times of volatility.\n> \n> We can try to mitigate this, but the solutions below all have\n> significant drawbacks.\n> \n> 1.\u00a0\u00a0We could force that setting up the HTLCs requires payment.\n> \u00a0\u00a0\u00a0\u00a0This forces the above American Call Options to have a premium.\n> \u00a0\u00a0\u00a0\u00a0The effect, however, is that routing failure is not free.\n> \u00a0\u00a0\u00a0\u00a0The current Lightning Network works despite not everyone\n> publishing the balances of channels, precisely because routing\n> failure is free.\n> \u00a0\u00a0\u00a0\u00a0We only need to have one route succeed in order to actually\n> successfully pay to the payee.\n> \u00a0\u00a0\u00a0\u00a0With non-free routing failure, we cannot try many routes until\n> one succeeds.\n> \u00a0\u00a0\u00a0\u00a0* Suppose we limited this only to cross-asset exchanges.\n> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0It would still require accurate knowledge of channel balances.\n> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0This is because if a payment fails on a hop *after* the\n> exchange, the payer still loses money from that attempt to the\n> exchange node.\n> 2.\u00a0\u00a0Exchange nodes could increase their fees.\n> \u00a0\u00a0\u00a0\u00a0This would create a wider \"spread\" of buying and selling assets.\n> \u00a0\u00a0\u00a0\u00a0This spread would increase friction in crossing assets.\n> \u00a0\u00a0\u00a0\u00a0Also, this would only reduce risk; if the exchange rate is\n> volatile enough, then the option could still be exercised for\n> riskless earnings.\n> \u00a0\u00a0\u00a0\u00a0Rational entities will still tie up most of the liquidity on the\n> exchange on riskless American Call Options; even if the exchange rate\n> is very stable, they lose nothing.\n> 3.\u00a0\u00a0Exchange nodes could limit the timelock of cross-asset swaps.\n> \u00a0\u00a0\u00a0\u00a0This would increase friction in crossing assets, since a timelock\n> limit also imposes a limit to the route length.\n> \u00a0\u00a0\u00a0\u00a0If one asset is much stronger than the other, then the weaker\n> asset will find its part of the Lightning Network to be strongly\n> centralized around the exchanges between the two assets.\n> \u00a0\u00a0\u00a0\u00a0Payees of the weaker asset will strongly prefer to be at most one\n> hop away from exchanges in order to viably receive payments from\n> payers who are using the stronger asset.\n> \u00a0\u00a0\u00a0\u00a0Again, rational entities will also still tie up most of the\n> liquidity on the exchange on riskless American Call Options; again,\n> even if the exchange rate is very stable in short time frames, they\n> lose nothing anyway.\n> \n> Conclusion\n> ==========\n> \n> HTLCs allow creation of American Call Options.\n> The same HTLCs are used in Lightning Network to route across\n> channels.\n> If using a single asset, there is no issue related to time.\n> Regardless of the value of bitcoin relative to any other asset, in\n> the future, 1 BTC is 1 BTC.\n> \n> However, across assets, the ability of HTLCs to create American Call\n> Options becomes troublesome.\n> These can then be exploited to earn money from exercise of the\n> option.\n> Further, because Lightning UX would be degraded otherwise, payment\n> failures are free (gratis), leading to the American Call Options also\n> being free of premium.\n> This means that creating such options would be riskless, allowing\n> potential earnings upon any strong volatility of exchange rates.\n> \n> This implies that a multi-asset Lightning Network may not be\n> economically viable.\n> Instead, Lightning Network would strongly prefer having a single\n> asset across the network.\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-12-28T09:14:45",
                "message_text_only": "Good morning CJP,\n\n\n>\n> I think we've already addressed this issue before:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/0012\n> 92.html\n>\n> and especially this proposal of me:\n> https://bitonic.nl/public/slowdown_prevention.pdf\n>\n> It's not completely trustless, but I tend to see trustlessness in a\n> very pragmatic sense anyway. Trust creates a risk, but if the\n> alternative trustless system is very impractical, and the risk is small\n> enough, the benefits might simply be worth the risks. Note that this is\n> a completely subjective trade-off, so it is only acceptable on an\n> individual, voluntary basis.\n\nThank you very much your information!\nIt seems to me \"trust\" is a five-letter word, so I am very hesitant to use it.\n\nI have only skimmed the paper thus far, so...\n\n1.  It seems to me that there is still friction here.\n    RM, being a trusted third party, may very well charge as much as the market will bear. https://nakamotoinstitute.org/trusted-third-parties/\n    This seems to me to imply that OM (i.e. exchange nodes) will be unable to extract any sizable fee, i.e. any fees that the market would be willing to pay to exchange between assets will be taken by RM as rent, and not by the OM who actually makes the market exist in the first place.\n\nI worry this friction may be too much, so I am hesitant to support this, especially as trusted third parties have not behaved well historically, as per Szabo.\n\nHowever, if we can somehow make RM punishable for breaches in timing attacks, or some similar mechanism, then it may become workable.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "CJP",
                "date": "2018-12-29T14:19:51",
                "message_text_only": "> 1.\u00a0\u00a0It seems to me that there is still friction here.\n> \u00a0\u00a0\u00a0\u00a0RM, being a trusted third party, may very well charge as much as\n> the market will bear. https://nakamotoinstitute.org/trusted-third-par\n> ties/\n> \u00a0\u00a0\u00a0\u00a0This seems to me to imply that OM (i.e. exchange nodes) will be\n> unable to extract any sizable fee, i.e. any fees that the market\n> would be willing to pay to exchange between assets will be taken by\n> RM as rent, and not by the OM who actually makes the market exist in\n> the first place.\n\nYou may be right about the fees, but that doesn't necessarily make it\nan unattractive proposition for the OM party.\n\nWhen looking at different alternatives by sorting them in a\nbetter/worse fashion rather than a perfect/imperfect fashion, I see\nthis:\n\n* No exchange: unattractive, because there is significant demand for\nthis.\n* Regular Lightning-based or other HTLC-like atomic swap: unattractive,\nbecause of the exploitable \"American Call Option\" nature (as we both\ndescribed). May only function with a very high spread, compensating for\nOM's risk.\n* Regular, centralized exchanges: current situation. Third party is\ntrusted with holding funds and executing trade orders.\n* My proposal: third party is trusted with executing transactions\nproperly (not performing the delay attack).\n* Trustless exchange: holy grail, but I don't know how to do that.\n\nSo I don't claim my proposal is perfect, but I'd like to argue it is\nthe best known system because it's an improvement over the current\nsituation where most people use centralized exchanges, at least in\nterms of trust required(*). To compare the two:\n\nI'd like to compare the RM role in my proposal to that of a centralized\nexchange. Both need to be trusted to some degree, and since trust\ndoesn't scale very well (you can't keep track of thousands of parties),\nboth are probably a natural oligopoly market. As you wrote, these are\nthe parties that are capable of extracting the majority of transaction\nfees. Still, as centralized exchanges show, people are prepared to\ntrade this way, so apparently it's still an attractive market for both\noffer-makers and -takers.\n\nI think the market for RM services in my proposal is more competitive\n(and therefore has lower fees) than regular, centralized exchanges,\nbecause:\n* trust requirements are lower, so people are more likely to trust a\nsmall, unknown company offering RM services. People using smaller\nparties = more parties in the market = lower fees.\n* OMs can easily offer the same funds for use with different RM\nparties. This is not possible with regular exchanges(**): if you\ndeposit funds on one exchange, you can't also deposit them on another\nexchange, so you have to commit your funds to a single exchange.\n\nFinally, I think the attack RMs can perform on trading parties is an\norder of magnitude smaller than the attack a regular exchange can\nperform by stealing deposited funds: a RM can only steal the *exchange\nrate change* of funds offered for trade, not the full value.\n\nNow, if an RM can be punished, it would be even better. I was thinking\nin the direction of collecting proof of misbehavior, which can then\nhelp make the RM lose its (lucrative!) business, but I doubt this is\npossible.\n\nCJP\n\n(*) not necessarily in latency: the low latency of centralized\nexchanges can be hard to match, even on Lightning.\n\n(**) as long as you can't go short"
            }
        ],
        "thread_summary": {
            "title": "An Argument For Single-Asset Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "CJP",
                "Will Yager",
                "James Asefa",
                "Tamas Blummer",
                "Alexander Leishman"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 90142
        }
    }
]