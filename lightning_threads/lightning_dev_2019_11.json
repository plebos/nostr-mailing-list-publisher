[
    {
        "title": "[Lightning-dev] Increasing fee defaults to 5000+500 for a healthier network?",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-11-04T04:38:39",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n> Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n>> Defaults don't necessarily indicate higher/lower reliability. Issuing a\n>> single CLI command to raise/lower the fees on one's node doesn't magically\n>> make the owner of said node a _better_ routing node operator.\n>\n> No, but those who put effort into their node presumably have more\n> reliable nodes, and this is a signal of that.\n>\n> Anyone have data on channel reliability that they can correlate with\n> channel fees?\n\nActually, since lnd sends out a disable update for nodes which are\noffline for > 20 minutes, we can simply look at the current gossip:\n\nhalf-channels online: 45157\n        percentage using 1000/1 fees: 56%\nhalf-channels offline: 10225\n        percentage using 1000/1 fees: 51%\n\nSo my assumption seems completely wrong here; if there's any\ncorrelation, it's negative.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Increasing fee defaults to 5000+500 for a healthier network?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 909
        }
    },
    {
        "title": "[Lightning-dev] asynchronous Lightning network payments",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-04T07:31:56",
                "message_text_only": "Good morning Konstantin and yas,\n\nIndeed, yas is quite correct: the money is still locked, and all that this proposal adds is to limit the funds locked by having S be a direct peer of the payer.\nIn the case proposed by Konstantin, this is simply locked between both A and S only, but it *must* be locked, or else timing shenanigans can be performed to defraud S.\n\n\nA proposal, is to add some sort of `please_poll` flag TLV to Trampoline onions, where if `please_poll` is enabled for a Trampoline node, it will perform the above-mentioned polling of once every 6 blocks.\nThat way, any node that supports Trampoline *and* `please_poll` can work as an S (or Rod) for a possibly-offline next step.\n\nAlternatively, Trampoline implementations might actually just implement the polling behavior automatically without a `please_poll` flag; this might be viable especially if the Trampoline is given a substantial fee and time budget anyway.\n\n\nThe only thing needed is for Trampoline to allow prepending of onions, then even the payee gets privacy from the payer.\n\n\nRegards,\nZmnSCPxj\n\n> [Resending in Plain Text. Sorry for the spam]\n> Hello Konstantin,\n>\n> In asynchronous payments we want to be sure that there are only two states:\n>\n> 1.  Before B received the payment.\n> 2.  After B received the payment.\n>     In state 1), we want A to still have the control of the amount, and at\n>     the same time we want to let B decide (until a certain timeout) to\n>     receive the payment. In this state, S can only help B to be paid, or\n>     cancel the whole transfer, but in this case, A cannot lose the amount.\n>     In state 2), we want to be sure that no money is lost by S (and\n>     consequently that the amount in A wallet is decremented by amt).\n>     As ZmnSCPxj wrote in\n>     https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002260.html\n>     (as I understand the last sentences), there is no way to do that without\n>     locking the amount.\n>\n>     In order to increase the privacy, we are improving the specification to\n>     be be able to use several Rod nodes: a list of nodes chosen by the payer\n>     and another list by the payee.\n>     The Rod nodes are supposed to be almost always online, so standard https\n>     can be used to communicate with them and between them.\n>     --yas\n>\n>     On 29/10/2019 22:46, Konstantin Ketterer wrote:\n>\n>\n> > Problem\n> >\n> > --------\n> >\n> > Currently, both parties have to be online at the same time to send/\n> > receive money. This can be avoided by using something like the\n> > Lightning Rod Protocol by Breez\n> > (https://github.com/breez/LightningRod). However, funds have to be\n> > locked up longer than usual. We can do better than that.\n> >\n> > Solution\n> >\n> > ---------\n> >\n> > The payer A pre-signs a transaction handing over money to their local\n> > channel partner S and sends the transaction to the payee B in an end\n> > to end encrypted communication channel. B can then sell the signature\n> > for the transaction to S using pay-for-signature made possible by\n> > payment points and scalars.\n> > (https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002077.html)\n> > We will be using eltoo because we don't have to worry about toxic\n> > channel states.\n> > A and S are online, A and S have a channel\n> >\n> > 1.  A contacts S: they commit and exchange the R (= k*G) part of the\n> >     Schnorr Signature for the update and settlement transaction\n> >\n> > 2.  A and S sign the settlement transaction increasing the balance\n> >     between them by amt + fee in favor of S and exchange the signatures\n> >\n> > 3.  A signs the corresponding update transaction but does not give it so S\n> > 4.  A sends the update transaction to B using an end to end encrypted\n> >     asynchronous communication channel\n> >\n> >\n> > A can go offline\n> > B comes online\n> >\n> > 4.  Decrypts the update transaction and sells the signature s to S for amt\n> >\n> > When A comes back online S gives A the invoice (with the payment point\n> > s*G) signed by B, the corresponding scalar s (the signature from A for\n> > the update transaction) and signature from S for the update\n> > transaction. They can now proceed as normal.\n> > In addition to enabling asynchronous payments, this outsources the\n> > routing to S.\n> >\n> > ### Potential issues\n> >\n> > #### Privacy\n> >\n> > S currently knows both the sender and the receiver of the payment. If\n> > we split the payment from S to B into two payments between S and a\n> > public routing node P and P and B by still using the same scalar +\n> > payment point, S now only knows the sender and P only knows the\n> > receiver. To further increase privacy we can split the payment\n> > multiple times but all nodes involved must support this feature.\n> >\n> > #### Locked up capital\n> >\n> > While B hasn't yet claimed its money, the funds in the channel between\n> > A and S are essentially locked up. However, A and S could simply\n> > overwrite the payment (new update + settlement transaction), then A\n> > could send multiple payments with the remaining balance and before\n> > going offline A would do the procedure again. If A has sufficient\n> > inbound capacity in other channels it can also re-balance its channel\n> > A-S so that the outbound capacity - (amt + fees) in this channel is\n> > zero and then do the procedure.\n> >\n> > #### Communication channel\n> >\n> > Obviously, the communication channel must be end to end encrypted\n> > otherwise this is highly insecure. Hopefully, we will have a sort of\n> > decentralized paid mail server system which is compatible across all\n> > LN wallets and part of BOLT.\n> >\n> > #### Proof of payment\n> >\n> > The invoice by B with the payment point s*G and s are not sufficient\n> > as a PoP because S can simply give A the invoice and A already knows s.\n> >\n> > the other way around\n> >\n> > ---------------------\n> >\n> > We can also do it in a way that A can instantly send B (who is\n> > offline) money but now A is in charge of enforcing the channel state\n> > if S cheats. Because it has more issues like who pays the transaction\n> > fees if S cheats and because I believe Lightning is generally not\n> > designed for people who are offline for a long time I prefer the first\n> > one. But here is the other one:\n> > B and S are online, B and S have a channel\n> >\n> > 1.  B and S sign a new settlement transaction increasing balance in\n> >     favor of B by amt\n> >\n> > 2.  B signs the corresponding update transaction, encrypts it and sends\n> >     it together with the settlement transaction to A\n> >\n> >\n> > B can go offline\n> > A comes online\n> >\n> > 3.  A decrypts the transactions, A pays S to sign the update\n> >     transaction which makes this new channel state valid/ enforceable\n> >\n> > 4.  now A essentially acts like a watchtower while B is offline\n> >\n> > Conclusion\n> >\n> > -----------\n> >\n> > This enables truly asynchronous Lightning network payments and is yet\n> > another reason to move to payment points and scalars.\n> > Regards\n> > Konstantin Ketterer\n> > Github: https://github.com/ko-redtruck/async-payments-ln\n> >\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-04T10:04:21",
                "message_text_only": "Good Morning ZmnSCPxj,\n\nThe problem with polling is that the payee can be online between two \nattempts and offline when the trampoline node polls.\nWe need a way for the payee to notify the trampoline node when online. \nThis is another reason to implement sooner than later messaging in LN.\nMeantime, other communication mechanisms need to be used.\nThanks,\n--yas\n\nOn 04/11/2019 09:31, ZmnSCPxj wrote:\n> Good morning Konstantin and yas,\n>\n> Indeed, yas is quite correct: the money is still locked, and all that this proposal adds is to limit the funds locked by having S be a direct peer of the payer.\n> In the case proposed by Konstantin, this is simply locked between both A and S only, but it *must* be locked, or else timing shenanigans can be performed to defraud S.\n>\n>\n> A proposal, is to add some sort of `please_poll` flag TLV to Trampoline onions, where if `please_poll` is enabled for a Trampoline node, it will perform the above-mentioned polling of once every 6 blocks.\n> That way, any node that supports Trampoline *and* `please_poll` can work as an S (or Rod) for a possibly-offline next step.\n>\n> Alternatively, Trampoline implementations might actually just implement the polling behavior automatically without a `please_poll` flag; this might be viable especially if the Trampoline is given a substantial fee and time budget anyway.\n>\n>\n> The only thing needed is for Trampoline to allow prepending of onions, then even the payee gets privacy from the payer.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n>> [Resending in Plain Text. Sorry for the spam]\n>> Hello Konstantin,\n>>\n>> In asynchronous payments we want to be sure that there are only two states:\n>>\n>> 1.  Before B received the payment.\n>> 2.  After B received the payment.\n>>      In state 1), we want A to still have the control of the amount, and at\n>>      the same time we want to let B decide (until a certain timeout) to\n>>      receive the payment. In this state, S can only help B to be paid, or\n>>      cancel the whole transfer, but in this case, A cannot lose the amount.\n>>      In state 2), we want to be sure that no money is lost by S (and\n>>      consequently that the amount in A wallet is decremented by amt).\n>>      As ZmnSCPxj wrote in\n>>      https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002260.html\n>>      (as I understand the last sentences), there is no way to do that without\n>>      locking the amount.\n>>\n>>      In order to increase the privacy, we are improving the specification to\n>>      be be able to use several Rod nodes: a list of nodes chosen by the payer\n>>      and another list by the payee.\n>>      The Rod nodes are supposed to be almost always online, so standard https\n>>      can be used to communicate with them and between them.\n>>      --yas\n>>\n>>      On 29/10/2019 22:46, Konstantin Ketterer wrote:\n>>\n>>\n>>> Problem\n>>>\n>>> --------\n>>>\n>>> Currently, both parties have to be online at the same time to send/\n>>> receive money. This can be avoided by using something like the\n>>> Lightning Rod Protocol by Breez\n>>> (https://github.com/breez/LightningRod). However, funds have to be\n>>> locked up longer than usual. We can do better than that.\n>>>\n>>> Solution\n>>>\n>>> ---------\n>>>\n>>> The payer A pre-signs a transaction handing over money to their local\n>>> channel partner S and sends the transaction to the payee B in an end\n>>> to end encrypted communication channel. B can then sell the signature\n>>> for the transaction to S using pay-for-signature made possible by\n>>> payment points and scalars.\n>>> (https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002077.html)\n>>> We will be using eltoo because we don't have to worry about toxic\n>>> channel states.\n>>> A and S are online, A and S have a channel\n>>>\n>>> 1.  A contacts S: they commit and exchange the R (= k*G) part of the\n>>>      Schnorr Signature for the update and settlement transaction\n>>>\n>>> 2.  A and S sign the settlement transaction increasing the balance\n>>>      between them by amt + fee in favor of S and exchange the signatures\n>>>\n>>> 3.  A signs the corresponding update transaction but does not give it so S\n>>> 4.  A sends the update transaction to B using an end to end encrypted\n>>>      asynchronous communication channel\n>>>\n>>>\n>>> A can go offline\n>>> B comes online\n>>>\n>>> 4.  Decrypts the update transaction and sells the signature s to S for amt\n>>>\n>>> When A comes back online S gives A the invoice (with the payment point\n>>> s*G) signed by B, the corresponding scalar s (the signature from A for\n>>> the update transaction) and signature from S for the update\n>>> transaction. They can now proceed as normal.\n>>> In addition to enabling asynchronous payments, this outsources the\n>>> routing to S.\n>>>\n>>> ### Potential issues\n>>>\n>>> #### Privacy\n>>>\n>>> S currently knows both the sender and the receiver of the payment. If\n>>> we split the payment from S to B into two payments between S and a\n>>> public routing node P and P and B by still using the same scalar +\n>>> payment point, S now only knows the sender and P only knows the\n>>> receiver. To further increase privacy we can split the payment\n>>> multiple times but all nodes involved must support this feature.\n>>>\n>>> #### Locked up capital\n>>>\n>>> While B hasn't yet claimed its money, the funds in the channel between\n>>> A and S are essentially locked up. However, A and S could simply\n>>> overwrite the payment (new update + settlement transaction), then A\n>>> could send multiple payments with the remaining balance and before\n>>> going offline A would do the procedure again. If A has sufficient\n>>> inbound capacity in other channels it can also re-balance its channel\n>>> A-S so that the outbound capacity - (amt + fees) in this channel is\n>>> zero and then do the procedure.\n>>>\n>>> #### Communication channel\n>>>\n>>> Obviously, the communication channel must be end to end encrypted\n>>> otherwise this is highly insecure. Hopefully, we will have a sort of\n>>> decentralized paid mail server system which is compatible across all\n>>> LN wallets and part of BOLT.\n>>>\n>>> #### Proof of payment\n>>>\n>>> The invoice by B with the payment point s*G and s are not sufficient\n>>> as a PoP because S can simply give A the invoice and A already knows s.\n>>>\n>>> the other way around\n>>>\n>>> ---------------------\n>>>\n>>> We can also do it in a way that A can instantly send B (who is\n>>> offline) money but now A is in charge of enforcing the channel state\n>>> if S cheats. Because it has more issues like who pays the transaction\n>>> fees if S cheats and because I believe Lightning is generally not\n>>> designed for people who are offline for a long time I prefer the first\n>>> one. But here is the other one:\n>>> B and S are online, B and S have a channel\n>>>\n>>> 1.  B and S sign a new settlement transaction increasing balance in\n>>>      favor of B by amt\n>>>\n>>> 2.  B signs the corresponding update transaction, encrypts it and sends\n>>>      it together with the settlement transaction to A\n>>>\n>>>\n>>> B can go offline\n>>> A comes online\n>>>\n>>> 3.  A decrypts the transactions, A pays S to sign the update\n>>>      transaction which makes this new channel state valid/ enforceable\n>>>\n>>> 4.  now A essentially acts like a watchtower while B is offline\n>>>\n>>> Conclusion\n>>>\n>>> -----------\n>>>\n>>> This enables truly asynchronous Lightning network payments and is yet\n>>> another reason to move to payment points and scalars.\n>>> Regards\n>>> Konstantin Ketterer\n>>> Github: https://github.com/ko-redtruck/async-payments-ln\n>>>\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "asynchronous Lightning network payments",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Yaacov Akiba Slama",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 15221
        }
    },
    {
        "title": "[Lightning-dev] [PATCH] First draft of option_simplfied_commitment",
        "thread_messages": [
            {
                "author": "David A. Harding",
                "date": "2019-11-04T22:41:57",
                "message_text_only": "On Thu, Oct 31, 2019 at 10:47:56AM +1030, Rusty Russell wrote:\n> If we need two anchor outputs, and want the other to turn into an\n> anyone-can-spend after it's mined, it's possible by gratuitously\n> mentioning the other key in the script, I think:\n\nWhy not reuse each party's funding_pubkey, i.e. the key that the party\nis signing for in the commitment transaction and which is already being\nrevealed in the commitment transaction's input witness script?\n\n-Dave"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-06T00:48:25",
                "message_text_only": "Joost Jager <joost.jager at gmail.com> writes:\n>>\n>> > * Add `to_remote_delay OP_CHECKSEQUENCEVERIFY OP_DROP` to the `to_remote`\n>> > output. `to_remote_delay` is the csv delay that the remote party accepted\n>> > in the funding flow for their outputs. This not only ensures that the\n>> > carve-out works as intended, but also removes the incentive to game the\n>> > other party into force-closing. If desired, both parties can still agree\n>> =\n>> to\n>> > have different `to_self_delay` values.\n>>\n>> I think we should unify to_self_delay if we're doing this.  Otherwise\n>> the game returns.\n>\n> The game returns, but both parties will be aware of the game they are\n> playing. They agreed to their peer's to_self_delay up front. (This is\n> different from the current situation where both peers are forced to accept\n> a remote_to_self_delay of 0.) With validation on the open/accept_channel\n> message, a node can still enforce both to_self_delays to be equal. We could\n> simplify this to a single to_self_delay that is proposed by the initiator,\n> but what was the original reason to allow distinct values?\n\nBecause I didn't fight hard enough for simplicity :(\n\nThere is no \"negotiation\" on opening; it's accept or error.  That leads\nto a situation where every implementation MUST accept what every\nimplementation offers.\n\nThe unification proposal was to use the max of the two settings.  That's\nfair; if you want me to suffer a 2 week delay, you should too.\n\n>> Agreed, this doesn't really work.  We actually needed a bitcoin rule\n>> that allowed a single anyone-can-spend output.  Seems like we didn't get\n>> that.\n>\n> With the mempool acceptance carve-out in bitcoind 0.19, we indeed won't be\n> able to safely produce a single OP_TRUE output for anyone to spend. An\n> attacker could attach low fee child transactions, reach the limits and\n> block further fee bumping.\n\nIndeed :(\n\n>> This is horribly spammy.  At the moment we see ~ one unilateral close\n>> every 3 blocks.  Hopefully that will reduce, but there'll always be\n>> some.\n>\n> It seems there isn't another way to do the anchor outputs given the mempool\n> limitations that exist? Each party needs to have their own anchor,\n> protected by a key. Otherwise it would open up these attack scenarios where\n> an attacker blocks the commitment tx confirmation until htlcs time out.\n> Even with the script OP_DEPTH OP_IF <pubkey> OP_CHECKSIG OP_ELSE 10 OP_CSV\n> OP_ENDIF, the \"anyones\" don't know the pubkey and still can't sweep after\n> 10 blocks.\n\nI think you're right, but I don't *like* it...\n\n>> * Within each version of the commitment transaction, both anchors always\n>> > have equal values and are paid for by the initiator.\n>>\n>> Who pays if they can't afford it?  What if they push_msat everything to\n>> the other side?\n>\n> Similar to how it currently works. There should never be a commitment\n> transaction in which the initiator cannot pay the fee.\n\nUnfortunately, this is not correct (in theory).\n\nWe can always get into a case where fees are insufficient (simultanous\nHTLC adds), but it's unusual.  We used to specify that the non-funder\nwould pay the remaining fee, but we dropped this in favor of allow\nunilateral close if this ever happened.\n\n> With anchor outputs\n> there should never be a commitment tx in which the initiator cannot pay the\n> fee and the anchors.\n\nThere can be, but I think we can simply modify this so you have to pay\nthe anchors *first* before fees.\n\n> Also currently you cannot push everything to the other\n> side with push_msat. The initiator still needs to have enough balance to\n> pay for the on-chain costs (miner fee and anchors).\n\nThis is true; I forgot we fixed that, sorry.  push_msat is a red herring.\n\n>> The value of the\n>> > anchors is the dust limit that was negotiated in the `open_channel` or\n>> > `accept_channel` message of the party that publishes the transaction.\n>>\n>> Now initiator has to care about the other side's dust limit, which is\n>> bad.  And as accepter I now want this much higher, since I get those\n>> funds instantly.  I don't think we gain anything by making this\n>> configurable at all; just pick a number and be done.\n>>\n>> Somewhere between 1000 and 10,000 sat is a good idea.\n>>\n>\n> Yes, it is free money. Therefore we need to validate the dust limit in the\n> funding flow. Check whether it is reasonable. That should also be done in\n> the current implementation. Otherwise your peer can set a really high dust\n> limit that lets your htlc disappear on-chain (although that is only free\n> money for the miner).\n\nTrue, and spec should note this BTW!  I've added an issue.\n\nhttps://github.com/lightningnetwork/lightning-rfc/issues/696\n\n> If we hard-code a constant, we won't be able to adapt to changes of\n> `dustRelayFee` in the bitcoin network. And we'd also need to deal with a\n> peer picking a value higher than that constant for its regular funding flow\n> dust limit parameter.\n\nNote that we can't adapt to dustRelayFee *today*, since we can't change\nit after funding (another thing we probably need to fix).\n\nIf we really want to make it adjustable, could we make each side pay for\nits own; if you can't afford it, you don't get one?  There's no point\nthe funder paying for a fundee-anchor if the fundee has no skin in the\ngame.\n\nThat reduces the pressure somewhat, I think?\n\n> Interesting. I wasn't aware of the brute-force method that watchtowers\n> could potentially use. I wanted to bring up the removal of key rotation\n> just in case everyone would agree we don't need it anymore. It isn't\n> required for the anchor outputs, but it would have been one (future)\n> commitment format less. But it seems we do need it.\n\nI hate it, too.  The original design was *so* much simpler :(\n\n> In the light of this forgotten insight, is there a reason why the anchor\n> output would need key rotation? Having no rotation makes it easier to let\n> those anchors go straight into the wallet, which may mitigate the dust utxo\n> problem a bit. At least then they can be easily coin-selected for any\n> on-chain spent, if the market fees are low enough.\n\nOr what about we rotate the anchors and nothing else, which (assuming we\nmake it anyone-can-spend-after-N-blocks) reduces the amount of onchain\nspam if someone completely loses their keys?\n\nThat's a bigger change, but maybe it's worth it?\n\nCheers!\nRusty."
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-07T14:33:00",
                "message_text_only": ">\n> > We could\n> > simplify this to a single to_self_delay that is proposed by the\n> initiator,\n> > but what was the original reason to allow distinct values?\n>\n> Because I didn't fight hard enough for simplicity :(\n>\n\nBut the people you were fighting with, what reason did they have? Just\nflexibility in general, or was there an actual use case? Maybe these people\nare reading this email and can comment?\n\nThere is no \"negotiation\" on opening; it's accept or error.  That leads\n> to a situation where every implementation MUST accept what every\n> implementation offers.\n>\n\nAgreed that the verb negotiate is a bit misleading. Although the\nopen/accept sequence could be repeated several times to make it more of a\nnegotiation.\n\n\n> The unification proposal was to use the max of the two settings.  That's\n> fair; if you want me to suffer a 2 week delay, you should too.\n>\n\nYes, we could do that as part of this new commitment format. Make that an\nimplicit consequence of `option_anchor_outputs` (or whatever its name will\nbe). The semantics need to change anyway, because we want that CSV lock on\nevery output.\n\n\n> >> * Within each version of the commitment transaction, both anchors always\n> >> > have equal values and are paid for by the initiator.\n> >>\n> >> Who pays if they can't afford it?  What if they push_msat everything to\n> >> the other side?\n> >\n> > Similar to how it currently works. There should never be a commitment\n> > transaction in which the initiator cannot pay the fee.\n>\n> Unfortunately, this is not correct (in theory).\n>\n> We can always get into a case where fees are insufficient (simultanous\n> HTLC adds), but it's unusual.  We used to specify that the non-funder\n> would pay the remaining fee, but we dropped this in favor of allow\n> unilateral close if this ever happened.\n>\n\nSo then because unilateral close is the only way to resolve atm, it is\ncorrect also in theory that there will never be a commitment tx where the\nnon-initiator pays fees? But the point is clear, channels can get stuck.\n\n\n> > With anchor outputs\n> > there should never be a commitment tx in which the initiator cannot pay\n> the\n> > fee and the anchors.\n>\n> There can be, but I think we can simply modify this so you have to pay\n> the anchors *first* before fees.\n>\n\nThat way it seems that adding the anchors doesn't make the stuck channel\nproblem that you described above worse?\n\n\n> > If we hard-code a constant, we won't be able to adapt to changes of\n> > `dustRelayFee` in the bitcoin network. And we'd also need to deal with a\n> > peer picking a value higher than that constant for its regular funding\n> flow\n> > dust limit parameter.\n>\n> Note that we can't adapt to dustRelayFee *today*, since we can't change\n> it after funding (another thing we probably need to fix).\n>\n\nYou can't for an existing channel, but at least for a new channel you can\npick a different value. Which wouldn't be possible if we'd put a fixed\n(anchor) amount in the spec.\n\n\n> If we really want to make it adjustable, could we make each side pay for\n> its own; if you can't afford it, you don't get one?  There's no point\n> the funder paying for a fundee-anchor if the fundee has no skin in the\n> game.\n>\n> That reduces the pressure somewhat, I think?\n>\n\nIf you can't afford you don't get one, not sure about that. I could open a\nchannel, send out the total capacity an in htlc to myself via some other\nhops, force close with a very low commit fee, then pull in the htlc (one\ntime the money). The victim then needs to get the commit confirmed to claim\nthe money, but there is no anchor unfortunately. I wait for the htlc to\nexpire, then anchor down the commit tx and time out the htlc (twice the\nmoney).\n\n\n> > In the light of this forgotten insight, is there a reason why the anchor\n> > output would need key rotation? Having no rotation makes it easier to let\n> > those anchors go straight into the wallet, which may mitigate the dust\n> utxo\n> > problem a bit. At least then they can be easily coin-selected for any\n> > on-chain spent, if the market fees are low enough.\n>\n> Or what about we rotate the anchors and nothing else, which (assuming we\n> make it anyone-can-spend-after-N-blocks) reduces the amount of onchain\n> spam if someone completely loses their keys?\n>\n> That's a bigger change, but maybe it's worth it?\n>\n\nWe now have David's great proposal to reuse the funding keys for the anchor\noutput. That allows us to always let anyone spend after confirmation,\nbecause they can reconstruct the spend script. But I think this also means\nthat we cannot do rotation on the anchor keys. We need to use the funding\npubkey as is.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191107/5f5f2d36/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-12T01:06:20",
                "message_text_only": "Joost Jager <joost.jager at gmail.com> writes:\n>>\n>> > We could\n>> > simplify this to a single to_self_delay that is proposed by the\n>> initiator,\n>> > but what was the original reason to allow distinct values?\n>>\n>> Because I didn't fight hard enough for simplicity :(\n>>\n>\n> But the people you were fighting with, what reason did they have? Just\n> flexibility in general, or was there an actual use case? Maybe these people\n> are reading this email and can comment?\n\nCompromise among the committee meant adding everything to the spec if\nthere was a conceivable reason for it; the simplicity argument was less\nstrong then (maybe because we hadn't implemented it all yet!).\n\n> So then because unilateral close is the only way to resolve atm, it is\n> correct also in theory that there will never be a commitment tx where the\n> non-initiator pays fees? But the point is clear, channels can get stuck.\n\nYeah.  Generally, it doesn't happen because we insist on a reasonable\nbalance in the channel, but it's theoretically possible.\n\n>> > If we hard-code a constant, we won't be able to adapt to changes of\n>> > `dustRelayFee` in the bitcoin network. And we'd also need to deal with a\n>> > peer picking a value higher than that constant for its regular funding\n>> flow\n>> > dust limit parameter.\n>>\n>> Note that we can't adapt to dustRelayFee *today*, since we can't change\n>> it after funding (another thing we probably need to fix).\n>>\n>\n> You can't for an existing channel, but at least for a new channel you can\n> pick a different value. Which wouldn't be possible if we'd put a fixed\n> (anchor) amount in the spec.\n\nThat's not really much consolation though for the existing network.\n\nStill Matt assures me that the relay dust limit is not going to change,\nso I think we're best off cutting down our test matrix by choosing a\nvalue and putting it directly into the spec.\n\nBy my calculations, at minfee it will cost you ~94 satoshis to spend.\nDust limit is 294 for Segwit outputs (basically assuming 3x minfee).\n\nSo I'm actually happy to say \"anchor outputs are 294 satoshi\".  These\nare simply spendable, and still only $3 each if BTC is $1M.  Lower is\nbetter (as long as we stick with funder-pays), as long as they do\neventually get spent.\n\n>> If we really want to make it adjustable, could we make each side pay for\n>> its own; if you can't afford it, you don't get one?  There's no point\n>> the funder paying for a fundee-anchor if the fundee has no skin in the\n>> game.\n>>\n>> That reduces the pressure somewhat, I think?\n>>\n>\n> If you can't afford you don't get one, not sure about that. I could open a\n> channel, send out the total capacity an in htlc to myself via some other\n> hops, force close with a very low commit fee, then pull in the htlc (one\n> time the money). The victim then needs to get the commit confirmed to claim\n> the money, but there is no anchor unfortunately. I wait for the htlc to\n> expire, then anchor down the commit tx and time out the htlc (twice the\n> money).\n\nExcellent point.  And the complexity of some \"you can only use a little\nbit of capacity until I have an anchor too\" is worse, so let's stick\nwith your proposal as the simplest: funder pays for two, always.\n\n>> Or what about we rotate the anchors and nothing else, which (assuming we\n>> make it anyone-can-spend-after-N-blocks) reduces the amount of onchain\n>> spam if someone completely loses their keys?\n>>\n>> That's a bigger change, but maybe it's worth it?\n> We now have David's great proposal to reuse the funding keys for the anchor\n> output. That allows us to always let anyone spend after confirmation,\n> because they can reconstruct the spend script. But I think this also means\n> that we cannot do rotation on the anchor keys. We need to use the funding\n> pubkey as is.\n\nI missed that proposal, thanks!\n\nIt's stronger than my scheme, in that it works even if neither anchor is\nspent; which, if we keep update_fee, is a distinct possibility.  And\nmakes the script shorter (my fee calc above assume this).\n\nWe *could* tweak both anchors by the same amount, but then you'd still\nneed to see one of them to spend the other.\n\nCheers,\nRusty."
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-14T09:56:05",
                "message_text_only": ">\n> > So then because unilateral close is the only way to resolve atm, it is\n> > correct also in theory that there will never be a commitment tx where the\n> > non-initiator pays fees? But the point is clear, channels can get stuck.\n>\n> Yeah.  Generally, it doesn't happen because we insist on a reasonable\n> balance in the channel, but it's theoretically possible.\n>\n\nOk, summarizing just for clarity:\n\n- there will never be a commitment tx where the non-initiator pays fees\n- generally a unilateral close doesn't happen because we insist on a\nreasonable\nbalance in the channel\n\n\n> >> > If we hard-code a constant, we won't be able to adapt to changes of\n> >> > `dustRelayFee` in the bitcoin network. And we'd also need to deal\n> with a\n> >> > peer picking a value higher than that constant for its regular funding\n> >> flow\n> >> > dust limit parameter.\n> >>\n> >> Note that we can't adapt to dustRelayFee *today*, since we can't change\n> >> it after funding (another thing we probably need to fix).\n> >>\n> >\n> > You can't for an existing channel, but at least for a new channel you can\n> > pick a different value. Which wouldn't be possible if we'd put a fixed\n> > (anchor) amount in the spec.\n>\n> That's not really much consolation though for the existing network.\n>\n> Still Matt assures me that the relay dust limit is not going to change,\n> so I think we're best off cutting down our test matrix by choosing a\n> value and putting it directly into the spec.\n>\n> By my calculations, at minfee it will cost you ~94 satoshis to spend.\n> Dust limit is 294 for Segwit outputs (basically assuming 3x minfee).\n>\n> So I'm actually happy to say \"anchor outputs are 294 satoshi\".  These\n> are simply spendable, and still only $3 each if BTC is $1M.  Lower is\n> better (as long as we stick with funder-pays), as long as they do\n> eventually get spent.\n>\n\nLooking at https://github.com/bitcoin/bitcoin/commit/9022aa3, is\n`dustRelayFee` really never going to change? It even is a (hidden) cmd line\nparameter that can be set easily.\n\nIf the fee market would rise and stay high for an extended period of time,\nwhy wouldn't people use this flag to raise the dust relay fee? If we then\nhave our hard coded 294 sat anchors, no force close transactions can be\nbroadcast anymore. It would be risky to open new channels at that point,\nbecause they can only be coop closed.\n\nMaybe Lightning is relevant enough by that time to keep people from\ntouching `dustRelayFee`, but what if not? The fix at that point would be to\nintroduce a new commitment format, which given our process takes a long\ntime.\n\nI'd think that having at least an option to adapt to `dustRelayFee` changes\nfor new channels makes Lightning more robust. The two options that I know\nof are:\n\n- Reuse `dust_limit_satoshis` on the `open_channel`/`accept_channel`\nmessages as the anchor size. This ignores that an anchor does not need to\nbe net positive after sweeping (because it's purpose is to get the commit\ntx confirmed), while we generally do want htlcs to be net positive. It may\nhowever be not such a big deal in practice. Suppose we'd just set this to\n294 sat to get the desired anchor output value (and make it a soft\nrequirement for channel acceptance). The worst that can happen is that\nthere is a force close with one or more pending htlcs that aren't\neconomical to sweep. Which can happen anyway because this is a channel open\nparameter and it is impossible to know what is economical for the lifetime\nof the channel. Instead of burning to fees, the htlc output will sit there\nwaiting for fees to go down. It may have expired by then and either party\ncan claim it. Not perfect, but could it be good enough?\n\n- Add a new `anchor_msat` field to the opening messages. We could add to\nthe spec \"nodes MAY reject the channel if `anchor_sat` isn't 294\". At least\nthen we are not hard-coding the value in the spec.\n\nWe *could* tweak both anchors by the same amount, but then you'd still\n> need to see one of them to spend the other.\n\n\nI don't think the tweak adds anything, because there is already enough\ntweak on the other outputs? Only in the case of just a tweakless\n(`option_static_remote_key`) `to_remote` output, there will also be a\ntweakless anchor. But the same reasoning applies there as before: you won't\nsend this tx to a watchtower?\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191114/f50f4691/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-11-14T23:43:50",
                "message_text_only": "On Thu, Nov 14, 2019 at 10:56:05AM +0100, Joost Jager wrote:\n> Looking at https://github.com/bitcoin/bitcoin/commit/9022aa3, is\n> `dustRelayFee` really never going to change? It even is a (hidden) cmd line\n> parameter that can be set easily.\n> \n> If the fee market would rise and stay high for an extended period of time,\n> why wouldn't people use this flag to raise the dust relay fee? \n\nIf feerates are reliably high, then there's less need for the dust limit\nand I wouldn't expect it to be increased.\n\nThe dust limit exists to prevent people from filling the UTXO set with\nnon-economical UTXOs when feerates are low.  For example, at the current\nminimum relay fee of 1 sat/vbyte and price of $8,500 USD/BTC, the cost\nto create a zero-value[1] P2WPKH output is about 30 vbytes = 30 sat =\n$0.0025 (1/4 cent).  The current UTXO set has about 64 million entries,\nso the cost to double its size would be $160,000---a tidy sum, but\nprobably less than some people spend spreading anti-Bitcoin propaganda\non a regular basis.\n\nThe dust limit helps prevent that by making the minimum cost per created\nP2WPKH UTXO 30 sat + 294 sat = $0.0275, or about $1,760,000 per UTXO set\ndoubling.\n\nIf feerates increase, the cost of a UTXO-filling attack rises\nproportionally.  Somewhere around sustained minimum feerates of 11\nsat/vbyte, feerates alone become more expensive than the current level\nof protection provided by the dust limit at 1 sat/vbyte.\n\nAdditionally, it's worth noting that the dust limit is not\nincentive-aligned with short-term miner interests.  If there's actual\nlegitimate demand to create transactions paying reasonable feerates and\ncontaining uneconomical-to-spend outputs, then miners are going to start\naccepting those transactions no matter what policies are implemented on\nthe P2P transaction relay network.\n\nIn short, I don't expect dust limits to rise unless the BTC/fiat price\ndrops so far that UTXO-filling attacks become much more affordable than\nthey are with today's limits.  Dust limits may instead decrease (or be\nremoved), but I don't think that's a problem for anchor outputs.\n\nThat said, I think it'd be a nice thing for LN implementations to strive\nto create anchor outputs that are economical to spend and that may\nrequire using a negotiable output amount to compensate for rises in\nfeerates making small-value outputs less economical, especially if\nyou're using different anchor outputs for each channel party.\n\n-Dave\n\n[1] I believe consensus rules allow creating zero-value outputs.  If\nnot, making this a 1 sat output doesn't significantly change any\ncalculations.\n\nP.S. Perhaps see also Gregory Maxwell's take:\n\n> I suspect that if feerates hadn't tanked after the introduction of\n> segwit, implementations probably would have removed the dust limit\n> policy rules in any case: they're a kludge that compensates for fees\n> being too low to dissuade various antisocial behaviors like spamming\n> for advertising purposes or de-anonymizing users and don't serve much\n> purpose if feerates are consistently high enough to discourage these\n> attacks.\n\nSource: https://bitcoin.stackexchange.com/a/85696/21052"
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-19T13:46:23",
                "message_text_only": "Thanks for this explanation (and Matt's) of the dust limit. For me it\ndefinitely adds to a better understanding of the matter.\n\nIn short, I don't expect dust limits to rise unless the BTC/fiat price\n> drops so far that UTXO-filling attacks become much more affordable than\n> they are with today's limits.  Dust limits may instead decrease (or be\n> removed), but I don't think that's a problem for anchor outputs.\n>\n\nIf the BTC/fiat price rises and this leads to lowering the dust limit, it\ncould be beneficial to lower the anchor size too. In the current proposal,\nthe channel initiator pays for both anchors. They basically give away a\nlittle bit of money to the non-initiator via the non-initiator anchor\noutput. If those anchors have become expensive because btc is expensive, it\nwould be nice to choose a lower value (as far as permitted by the dust\nlimit).\n\n\n> That said, I think it'd be a nice thing for LN implementations to strive\n> to create anchor outputs that are economical to spend and that may\n> require using a negotiable output amount to compensate for rises in\n> feerates making small-value outputs less economical, especially if\n> you're using different anchor outputs for each channel party.\n>\n\nOn the one hand, we'd want them to be economical to not create dust. But on\nthe other hand because it is free money too, we also want them to be as\nsmall as possible (as mentioned above). I would think that an individual\nrunning a node is more concerned with their balance than the quality of the\nutxo set.\n\nSo far, the following factors/events were mentioned that could lead to\nunhappiness about a hard-coded anchor value (hopefully this is complete and\ncorrect now):\n\nA. Dust limit rises: need bigger anchors to get commitment transactions\naccepted (arguably unlikely to happen).\nB. Btc price goes up, dust limit goes down: may want smaller anchors to\nreduce amount (in fiat terms) of free money given to the non-initiator\nC. Fee rates go up: need bigger anchors to make them economical to spend\nand prevent them from filling up the utxo set.\n\nIntroducing a new parameter in the channel opening sequence that sets the\nanchor size would keep all options open. I would be comfortable with doing\nthat and knowing we won't need changes if any of the three scenarios above\nplay out.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191119/8419eb62/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-11-19T18:53:01",
                "message_text_only": "Regarding your list,\nA. Indeed, unlikely to happen.\nB. Maybe, but we\u2019re talking a 10x increase so that suddenly you\u2019re paying some extra pennies. In the scale of likelihood, and in the scale of what fees will be anyway, this doesn\u2019t matter.\nC. You still seem to have missed the point that they need to be economical *eventually *, at the mempool\u2019s lowest. That is hugely different from \u201cfees increasing\u201d. I really don\u2019t think the history here supports your position.\n\nAt a high level, you seem to be completely discounting the cost of complexity in the protocol. Lightning already has way too many values you have to negotiate with your counterparty, and the state machine is already complicated enough that three groups of talented developers failed to check key parameters during state transitions!\n\nIf at all possible, the answer should be \u201cremove more crap from the state machine\u201d, not \u201cwell, we\u2019re like 95% sure this is fine, let\u2019s just heap on the complexity\u201d. Not only does this fly in the face of any reasonable definition of \u201cgood engineering practice\u201d, but the cost to change it later is relatively low!\n\nWe\u2019re rewriting the state machine and transaction format now, let\u2019s learn from the past few years, not pretend everything is perfect.\n\nMatt\n\n> On Nov 19, 2019, at 08:47, Joost Jager <joost.jager at gmail.com> wrote:\n> \n> \ufeff\n> Thanks for this explanation (and Matt's) of the dust limit. For me it definitely adds to a better understanding of the matter.\n> \n>> In short, I don't expect dust limits to rise unless the BTC/fiat price\n>> drops so far that UTXO-filling attacks become much more affordable than\n>> they are with today's limits.  Dust limits may instead decrease (or be\n>> removed), but I don't think that's a problem for anchor outputs.\n> \n> If the BTC/fiat price rises and this leads to lowering the dust limit, it could be beneficial to lower the anchor size too. In the current proposal, the channel initiator pays for both anchors. They basically give away a little bit of money to the non-initiator via the non-initiator anchor output. If those anchors have become expensive because btc is expensive, it would be nice to choose a lower value (as far as permitted by the dust limit).\n>  \n>> That said, I think it'd be a nice thing for LN implementations to strive\n>> to create anchor outputs that are economical to spend and that may\n>> require using a negotiable output amount to compensate for rises in\n>> feerates making small-value outputs less economical, especially if\n>> you're using different anchor outputs for each channel party.\n> \n> On the one hand, we'd want them to be economical to not create dust. But on the other hand because it is free money too, we also want them to be as small as possible (as mentioned above). I would think that an individual running a node is more concerned with their balance than the quality of the utxo set.\n> \n> So far, the following factors/events were mentioned that could lead to unhappiness about a hard-coded anchor value (hopefully this is complete and correct now):\n> \n> A. Dust limit rises: need bigger anchors to get commitment transactions accepted (arguably unlikely to happen).\n> B. Btc price goes up, dust limit goes down: may want smaller anchors to reduce amount (in fiat terms) of free money given to the non-initiator\n> C. Fee rates go up: need bigger anchors to make them economical to spend and prevent them from filling up the utxo set.\n> \n> Introducing a new parameter in the channel opening sequence that sets the anchor size would keep all options open. I would be comfortable with doing that and knowing we won't need changes if any of the three scenarios above play out.\n>  \n> Joost\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191119/3483a0e2/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-11-16T05:46:26",
                "message_text_only": "\ufeffRegarding the dust relay limit, there may be a little bit of a\nmisunderstanding as to a few important details. The purpose of it (much\nlike the dust output values in the anchor outputs) is to discourage\noutputs which are not ever economically spendable, not short-term\nuneconomically spendable.\n\nThis value is, thus, *not* connected to the mempool's min relay fee\n(except for the purposes of calculating the constant, which may be part\nof the disconnect here). The min relay fee represents a short-term DoS\nlimit, and, thus, can float wildly (though, since 2017, and even in\ngeneral, we largely have not seen it go up much in absolute value at all).\n\nFurther, and, critically, there are a number of issues with *any* policy\nchange that makes several bits of the P2P network less efficient, and,\nthus, they are generally avoided where possible. These include, compact\nblock relay, feerate estimation, relay-DoS-resistance, etc.\n\nWhile none of this is to say that the dust limit will *never* change, I\nreally don't think its unreasonable to hard code it - there's no\npressure *to* change it, and if there's an additional reason not to (ie\nthat deployed software relies on that value, which other software, more\nthan lightning already does), then it almost certainly wont be.\n\nMatt\n\nOn 11/14/19 9:56 AM, Joost Jager wrote:\n>> So then because unilateral close is the only way to resolve atm, it is\n>> correct also in theory that there will never be a commitment tx\n>    where the\n>> non-initiator pays fees? But the point is clear, channels can get\n>    stuck.\n> \n>    Yeah.  Generally, it doesn't happen because we insist on a reasonable\n>    balance in the channel, but it's theoretically possible.\n> \n> \n> Ok, summarizing just for clarity:\n> \n> - there will never be a commitment tx where the non-initiator pays fees\n> - generally a unilateral close doesn't happen because we insist on a\n> reasonable\n> balance in the channel\n>  \n> \n>>>> If we hard-code a constant, we won't be able to adapt to changes of\n>>>> `dustRelayFee` in the bitcoin network. And we'd also need to\n>    deal with a\n>>>> peer picking a value higher than that constant for its regular\n>    funding\n>>> flow\n>>>> dust limit parameter.\n>>> Note that we can't adapt to dustRelayFee *today*, since we can't\n>    change\n>>> it after funding (another thing we probably need to fix).\n>> You can't for an existing channel, but at least for a new channel\n>    you can\n>> pick a different value. Which wouldn't be possible if we'd put a fixed\n>> (anchor) amount in the spec.\n> \n>    That's not really much consolation though for the existing network.\n> \n>    Still Matt assures me that the relay dust limit is not going to change,\n>    so I think we're best off cutting down our test matrix by choosing a\n>    value and putting it directly into the spec.\n> \n>    By my calculations, at minfee it will cost you ~94 satoshis to spend.\n>    Dust limit is 294 for Segwit outputs (basically assuming 3x minfee).\n> \n>    So I'm actually happy to say \"anchor outputs are 294 satoshi\".  These\n>    are simply spendable, and still only $3 each if BTC is $1M.  Lower is\n>    better (as long as we stick with funder-pays), as long as they do\n>    eventually get spent.\n> \n> \n> Looking at https://github.com/bitcoin/bitcoin/commit/9022aa3, is\n> `dustRelayFee` really never going to change? It even is a (hidden) cmd\n> line parameter that can be set easily. \n> \n> If the fee market would rise and stay high for an extended period of\n> time, why wouldn't people use this flag to raise the dust relay fee? If\n> we then have our hard coded 294 sat anchors, no force close transactions\n> can be broadcast anymore. It would be risky to open new channels at that\n> point, because they can only be coop closed.\n>  \n> Maybe Lightning is relevant enough by that time to keep people from\n> touching `dustRelayFee`, but what if not? The fix at that point would be\n> to introduce a new commitment format, which given our process takes a\n> long time.\n> \n> I'd think that having at least an option to adapt to `dustRelayFee`\n> changes for new channels makes Lightning more robust. The two options\n> that I know of are:\n> \n> - Reuse `dust_limit_satoshis` on the `open_channel`/`accept_channel`\n> messages as the anchor size. This ignores that an anchor does not need\n> to be net positive after sweeping (because it's purpose is to get the\n> commit tx confirmed), while we generally do want htlcs to be net\n> positive. It may however be not such a big deal in practice. Suppose\n> we'd just set this to 294 sat to get the desired anchor output value\n> (and make it a soft requirement for channel acceptance). The worst that\n> can happen is that there is a force close with one or more pending htlcs\n> that aren't economical to sweep. Which can happen anyway because this is\n> a channel open parameter and it is impossible to know what is economical\n> for the lifetime of the channel. Instead of burning to fees, the htlc\n> output will sit there waiting for fees to go down. It may have expired\n> by then and either party can claim it. Not perfect, but could it be good\n> enough?\n> \n> - Add a new `anchor_msat` field to the opening messages. We could add to\n> the spec \"nodes MAY reject the channel if `anchor_sat` isn't 294\". At\n> least then we are not hard-coding the value in the spec.\n> \n>    We *could* tweak both anchors by the same amount, but then you'd still\n>    need to see one of them to spend the other.\n> \n> \n> I don't think the tweak adds anything, because there is already enough\n> tweak on the other outputs? Only in the case of just a tweakless\n> (`option_static_remote_key`) `to_remote` output, there will also be a\n> tweakless anchor. But the same reasoning applies there as before: you\n> won't send this tx to a watchtower?\n> \n> Joost\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "First draft of option_simplfied_commitment",
            "categories": [
                "Lightning-dev",
                "PATCH"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "Joost Jager",
                "Matt Corallo"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 35860
        }
    },
    {
        "title": "[Lightning-dev] A proposal for up-front payments.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-11-05T02:17:56",
                "message_text_only": "Hi all,\n\n        It's been widely known that we're going to have to have up-front\npayments for msgs eventually, to avoid Type 2 spam (I think of Type 1\nlink-local, Type 2 though multiple nodes, and Type 3 liquidity-using\nspam).\n\n        Since both Offers and Joost's WhatSat are looking at sending\nmessages, it's time to float actual proposals.  I've been trying to come\nup with something for several years now, so thought I'd present the best\nI've got in the hope that others can improve on it.\n\n1. New feature bit, extended messages, etc.\n2. Adding an HTLC causes a *push* of a number of msat on\n   commitment_signed (new field), and a hash.\n3. Failing/succeeding an HTLC returns some of those msat, and a count\n   and preimage (new fields).\n\nHow many msat can you take for forwarding?  That depends on you\npresenting a series of preimages (which chain into a final hash given in\nthe HTLC add), which you get by decoding the onion.  You get to keep 50\nmsat[1] per preimage you present[2].\n\nSo, how many preimages does the user have to give to have you forward\nthe payment?  That depends.  The base rate is 16 preimages, but subtract\none for each leading 4 zero bits of the SHA256(blockhash | hmac) of the\nonion.  The blockhash is the hash of the block specified in the onion:\nreject if it's not in the last 3 blocks[3].\n\nThis simply adds some payment noise, while allowing a hashcash style\ntradeoff of sats for work.\n\nThe final node gets some variable number of preimages, which adds noise.\nIt should take all and subtract from the minimum required invoice amount\non success, or take some random number on failure.\n\nThis leaks some forward information, and makes an explicit tradeoff for\nthe sender between amount spent and privacy, but it's the best I've been\nable to come up with.\n\nThoughts?\nRusty.\n\n[1] If we assume $1 per GB, $10k per BTC and 64k messages, we get about\n    655msat per message.  Flat pricing for simplicity; we're trying to\n    prevent spam, not create a spam market.\n[2] Actually, a number and a single preimage; you can check this is\n    indeed the n'th preimage.\n[3] This reduces incentive to grind the damn things in advance, though\n    maybe that's dumb?  We can also use a shorter hash (siphash?), or\n    even truncated SHA256 (128 bits)."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-05T04:59:33",
                "message_text_only": "Good morning Rusty,\n\nIs this intended to be enforceable onchain if a channel is dropped onchain while a message is being routed?\nBy a vague sense of the description, it seems to me, it would require a complicated SCRIPT (or multiple tiny 50-msatoshi UTXOs) to enforce onchain.\n\nAlso, it is not exactly clear to me, the mechanism you are proposing in detail.\nCan you give a motivating example, for example in a route from ZmnSCPxj, through Rusty, to my imaginary friend YAIjbOJa (who is not in fact me)?\n\nRegards,\nZmnSCPxj\n\n\n> Hi all,\n>\n> It's been widely known that we're going to have to have up-front\n> payments for msgs eventually, to avoid Type 2 spam (I think of Type 1\n> link-local, Type 2 though multiple nodes, and Type 3 liquidity-using\n> spam).\n>\n> Since both Offers and Joost's WhatSat are looking at sending\n> messages, it's time to float actual proposals. I've been trying to come\n> up with something for several years now, so thought I'd present the best\n> I've got in the hope that others can improve on it.\n>\n> 1.  New feature bit, extended messages, etc.\n> 2.  Adding an HTLC causes a push of a number of msat on\n>     commitment_signed (new field), and a hash.\n>\n> 3.  Failing/succeeding an HTLC returns some of those msat, and a count\n>     and preimage (new fields).\n>\n>     How many msat can you take for forwarding? That depends on you\n>     presenting a series of preimages (which chain into a final hash given in\n>     the HTLC add), which you get by decoding the onion. You get to keep 50\n>     msat[1] per preimage you present[2].\n>\n>     So, how many preimages does the user have to give to have you forward\n>     the payment? That depends. The base rate is 16 preimages, but subtract\n>     one for each leading 4 zero bits of the SHA256(blockhash | hmac) of the\n>     onion. The blockhash is the hash of the block specified in the onion:\n>     reject if it's not in the last 3 blocks[3].\n>\n>     This simply adds some payment noise, while allowing a hashcash style\n>     tradeoff of sats for work.\n>\n>     The final node gets some variable number of preimages, which adds noise.\n>     It should take all and subtract from the minimum required invoice amount\n>     on success, or take some random number on failure.\n>\n>     This leaks some forward information, and makes an explicit tradeoff for\n>     the sender between amount spent and privacy, but it's the best I've been\n>     able to come up with.\n>\n>     Thoughts?\n>     Rusty.\n>\n>     [1] If we assume $1 per GB, $10k per BTC and 64k messages, we get about\n>     655msat per message. Flat pricing for simplicity; we're trying to\n>     prevent spam, not create a spam market.\n>     [2] Actually, a number and a single preimage; you can check this is\n>     indeed the n'th preimage.\n>     [3] This reduces incentive to grind the damn things in advance, though\n>     maybe that's dumb? We can also use a shorter hash (siphash?), or\n>     even truncated SHA256 (128 bits).\n>\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-05T09:26:45",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> Good morning Rusty,\n\nHi ZmnSCPxj!\n\n> Is this intended to be enforceable onchain if a channel is dropped onchain while a message is being routed?\n> By a vague sense of the description, it seems to me, it would require a complicated SCRIPT (or multiple tiny 50-msatoshi UTXOs) to enforce onchain.\n\nNo, it's done as a simple subtraction from direct to-local and to-remote\npayments.  Enforcement is by peer closing the channel, which you\nwouldn't do over a few msat.\n\n> Also, it is not exactly clear to me, the mechanism you are proposing in detail.\n> Can you give a motivating example, for example in a route from\n> ZmnSCPxj, through Rusty, to my imaginary friend YAIjbOJa (who is not\n> in fact me)?\n\nSure: for simplicity I'm sending a 0-value HTLC.\n\nZmnSCPxj has balance 10000msat in channel with Rusty, who has 1000msat\nin the channel with YAIjbOJa.\n\nRusty prepares a nonce, AAAAA and hashes it 25 times = ZZZZZ.\n\nZmnSCPxj prepares the onion, but adds extra fields (see below).  He then\nsends the HTLC to Rusty, but also sends ZZZZZ, and 25x50 msat (ie. those\nfields are in the update_add_htlc msg).  His balance with Rusty is now\n8750msat (ie. 25x50 to Rusty).\n\nRusty decrypts the onion, reads the prepay field: it says 14, LLLLL.\nRusty checks: the hash of the onion & block (or something) does indeed\nhave the top 8 bits clear, so the cost is in fact 16 - 8/2 == 14.  He\nthen hashes LLLLL 14 times, and yes, it's ZZZZZ as ZmnSCPxj said it\nshould be.\n\nSo Rusty takes the 14x50 as prepayment, and forwards the HTLC as\nnormal to YAIjbOJa, along with LLLLL and 11x50msat.  His balance with\nYAIjbOJa is now 450msat.\n\nYAIjbOJa decrypts the onion.  And it says 10,BBBBB.  YAIjbOJa checks\nthat hashing BBBBB 10 times does indeed give LLLLL.  Now it takes the\n11x50 msat, and fulfils the HTLC.  It replies to Rusty with 10,BBBBB\nin the update_fulfill_htlc message, returning the (implicit) 1x50msat;\nRusty's balance with YAIjbOJa is now 500msat.\n\nRusty checks that BBBBB hashed 10 times gives LLLLL.  Now it returns\n24,BBBBB to ZmnSCPxj with the update_fulfill_htlc, demonstrating to\nZmnSCPxj that he's entitled to it, and (implicity) returning 1x50msat to\nZmnSCPxj, so their balance is now 8800msat.\n\nNow let's look at attacks:\n\n1. Rusty steals the funds and doesn't return them.  ZmnSCPxj closes\n   channel, having lost 26x50msat.\n\n2, YAIjbOJa steals the funds and doesn't return them.  Rusty closes\n   the channel, having lost 11x50msat.\n\n3. ZmnSCPxj doesn't put correct preimages in, or too few, or other\n   malformation.  If it's Rusty's onion, he won't forward it and will\n   give an error.  If it's YAIjbOJa who rejects it, Rusty returns all\n   but the 14x50msat he has preimages for.\n\nObviously Rusty needs some upper limit on how much he'll pay out, to\navoid infinite exposure (say limit the total exposure to 10,000 sats).\n\nA reasonable limit for each HTLC would be 20 hops x 16 x 50msat ==\n16sat.  Even with no other limits, with 486 HTLCs in flight each way,\nthat's only 15456 satoshis.  You'll probably lament the channel closure\nmore.\n\nHope that helps!\nRusty.\n\n>> Hi all,\n>>\n>> It's been widely known that we're going to have to have up-front\n>> payments for msgs eventually, to avoid Type 2 spam (I think of Type 1\n>> link-local, Type 2 though multiple nodes, and Type 3 liquidity-using\n>> spam).\n>>\n>> Since both Offers and Joost's WhatSat are looking at sending\n>> messages, it's time to float actual proposals. I've been trying to come\n>> up with something for several years now, so thought I'd present the best\n>> I've got in the hope that others can improve on it.\n>>\n>> 1.  New feature bit, extended messages, etc.\n>> 2.  Adding an HTLC causes a push of a number of msat on\n>>     commitment_signed (new field), and a hash.\n>>\n>> 3.  Failing/succeeding an HTLC returns some of those msat, and a count\n>>     and preimage (new fields).\n>>\n>>     How many msat can you take for forwarding? That depends on you\n>>     presenting a series of preimages (which chain into a final hash given in\n>>     the HTLC add), which you get by decoding the onion. You get to keep 50\n>>     msat[1] per preimage you present[2].\n>>\n>>     So, how many preimages does the user have to give to have you forward\n>>     the payment? That depends. The base rate is 16 preimages, but subtract\n>>     one for each leading 4 zero bits of the SHA256(blockhash | hmac) of the\n>>     onion. The blockhash is the hash of the block specified in the onion:\n>>     reject if it's not in the last 3 blocks[3].\n>>\n>>     This simply adds some payment noise, while allowing a hashcash style\n>>     tradeoff of sats for work.\n>>\n>>     The final node gets some variable number of preimages, which adds noise.\n>>     It should take all and subtract from the minimum required invoice amount\n>>     on success, or take some random number on failure.\n>>\n>>     This leaks some forward information, and makes an explicit tradeoff for\n>>     the sender between amount spent and privacy, but it's the best I've been\n>>     able to come up with.\n>>\n>>     Thoughts?\n>>     Rusty.\n>>\n>>     [1] If we assume $1 per GB, $10k per BTC and 64k messages, we get about\n>>     655msat per message. Flat pricing for simplicity; we're trying to\n>>     prevent spam, not create a spam market.\n>>     [2] Actually, a number and a single preimage; you can check this is\n>>     indeed the n'th preimage.\n>>     [3] This reduces incentive to grind the damn things in advance, though\n>>     maybe that's dumb? We can also use a shorter hash (siphash?), or\n>>     even truncated SHA256 (128 bits).\n>>\n>>\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-11-05T11:24:19",
                "message_text_only": "On Tue, Nov 05, 2019 at 07:56:45PM +1030, Rusty Russell wrote:\n> Sure: for simplicity I'm sending a 0-value HTLC.\n> ZmnSCPxj has balance 10000msat in channel with Rusty, who has 1000msat\n> in the channel with YAIjbOJa.\n\nAlice, Bob and Carol sure seem simpler than Zmn YAI and Rusty...\n\n> Rusty prepares a nonce, AAAAA and hashes it 25 times = ZZZZZ.\n> ZmnSCPxj prepares the onion, but adds extra fields (see below).  \n\nIt would have made more sense to me for Alice (Zmn) to generate\nthe nonce, hash it, and prepare the onion, so that the nonce is\nrevealed to Dave (Rusty) if/when the message ever actually reaches its\ndestination. Otherwise Rusty has to send AAAAA to Zmn already so that\nZmn can prepare the onion?\n\n> He then\n> sends the HTLC to Rusty, but also sends ZZZZZ, and 25x50 msat (ie. those\n> fields are in the update_add_htlc msg).  His balance with Rusty is now\n> 8750msat (ie. 25x50 to Rusty).\n> \n> Rusty decrypts the onion, reads the prepay field: it says 14, LLLLL.\n> Rusty checks: the hash of the onion & block (or something) does indeed\n> have the top 8 bits clear, so the cost is in fact 16 - 8/2 == 14.  He\n> then hashes LLLLL 14 times, and yes, it's ZZZZZ as ZmnSCPxj said it\n> should be.\n\nI'm not sure why lucky hashing should result in a discount? You're\ngiving a linear discount for exponentially more luck in hashing which\nalso seems odd.\n\nYou've only got two nonce choices -- the initial AAAA and the depth\nthat you tell Bob and Carol to hash to as steps in the route; so the\nincentive there seems to be to do a large depth, so you might hash\nAAAA 1000 times, and figure that you'll find a leading eight 0's once\nin the first 256 entries, then another by the time you get up to 512,\nand another by the time you get to 768, which gets you discounts on\nthree intermediaries. But the cost there is that your intermediaries\ncollectively have to do the same amount of hashing you did, so it's not\nproof-of-work, because it's as hard to verify as it is to generate.\n\nI think you could just make the scheme be:\n\n  Alice sends HTLC(k,v) + 1250 msat to Bob\n  Bob unwraps the onion and forwards HTLC(k,v) + 500 msat to Carol\n  Carol unwraps the onion and forwards HTLC(k,v) + 250 msat to Dave\n  Dave redeems the HTLC, claims an extra 300 msat and refunds 200 msat to Carol\n  Carol redeems the HTLC and refunds 200 msat to Bob\n  Bob redeems the HTLC and refunds 200 msat to Alice\n\nIf there's a failure, Alice loses the 1250 msat, and someone in the\npath steals the funds. You could make the accountable by having Alice\nalso provide \"Hash(AAAA, refund=200)\" to everyone, encoding AAAA in the\nonion to Dave, and then each hop reveals AAAA and refunds 200msat to\ndemonstrate their honesty.\n\nDoes that miss anything that all the hashing achieves?\n\nI think the idea here is that you're paying tiny amounts for the\nbandwidth, which when it's successful does in fact pay for the bandwidth;\nand when it's unsuccessful results in a channel closure, which makes it\nunprofitable to cheat the system, but doesn't change the economics of\nlightning much overall because channel closures can happen anytime anyway.\nI think that approach makes sense.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-06T00:13:23",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Tue, Nov 05, 2019 at 07:56:45PM +1030, Rusty Russell wrote:\n>> Sure: for simplicity I'm sending a 0-value HTLC.\n>> ZmnSCPxj has balance 10000msat in channel with Rusty, who has 1000msat\n>> in the channel with YAIjbOJa.\n>\n> Alice, Bob and Carol sure seem simpler than Zmn YAI and Rusty...\n\nAgreed, I should not have directly answered the q.\n\n>> Rusty prepares a nonce, AAAAA and hashes it 25 times = ZZZZZ.\n>> ZmnSCPxj prepares the onion, but adds extra fields (see below).  \n>\n> It would have made more sense to me for Alice (Zmn) to generate\n> the nonce, hash it, and prepare the onion, so that the nonce is\n> revealed to Dave (Rusty) if/when the message ever actually reaches its\n> destination. Otherwise Rusty has to send AAAAA to Zmn already so that\n> Zmn can prepare the onion?\n\nThe entire point is to pay *up-front*, though, to prevent spam.\n\nBob/ZmnSCPxj doesn't prepare anything in the onion.  They get handed the\nlast hash directly: Alice is saying \"I'll pay you 50msat for each\npreimage you can give me leading to this hash\".\n\n>> He then\n>> sends the HTLC to Rusty, but also sends ZZZZZ, and 25x50 msat (ie. those\n>> fields are in the update_add_htlc msg).  His balance with Rusty is now\n>> 8750msat (ie. 25x50 to Rusty).\n>> \n>> Rusty decrypts the onion, reads the prepay field: it says 14, LLLLL.\n>> Rusty checks: the hash of the onion & block (or something) does indeed\n>> have the top 8 bits clear, so the cost is in fact 16 - 8/2 == 14.  He\n>> then hashes LLLLL 14 times, and yes, it's ZZZZZ as ZmnSCPxj said it\n>> should be.\n>\n> I'm not sure why lucky hashing should result in a discount?\n\nBecause the PoW adds noise to the amounts, otherwise the path length is\ntrivially exposed, esp in the failure case.  It's weak protection\nthough.\n\n> You're giving a linear discount for exponentially more luck in hashing\n> which also seems odd.\n\nBecause you really want some actual payment, not just PoW.  Botnets are\nreally good at PoW, less good at sending msats.  And the PoW is hard to\ncalibrate (I guessed: real numbers will be necessary)/\n\n> You've only got two nonce choices -- the initial AAAA and the depth\n> that you tell Bob and Carol to hash to as steps in the route;\n\nNo, the sphinx construction allows for grinding, that was my intent\nhere.  The prepay hashes are independent.\n\n> I think you could just make the scheme be:\n>\n>   Alice sends HTLC(k,v) + 1250 msat to Bob\n>   Bob unwraps the onion and forwards HTLC(k,v) + 500 msat to Carol\n>   Carol unwraps the onion and forwards HTLC(k,v) + 250 msat to Dave\n>   Dave redeems the HTLC, claims an extra 300 msat and refunds 200 msat to Carol\n>   Carol redeems the HTLC and refunds 200 msat to Bob\n>   Bob redeems the HTLC and refunds 200 msat to Alice\n>\n> If there's a failure, Alice loses the 1250 msat, and someone in the\n> path steals the funds.\n\nThis example confuses me.\n\nSo, you're charging 250msat per hop?  Why is Bob taking 750?  Does Carol\nnow know Dave is the last hop?\n\nDoes Alice lose everything on any routing failure?\n\nIf so, that is strong incentive for Alice to reduce path-length privacy\nby keeping payments minimal, which I was really trying to avoid.\n\n> You could make the accountable by having Alice\n> also provide \"Hash(AAAA, refund=200)\" to everyone, encoding AAAA in the\n> onion to Dave, and then each hop reveals AAAA and refunds 200msat to\n> demonstrate their honesty.\n>\n> Does that miss anything that all the hashing achieves?\n\nIt does nothing if Carol is the one who can't route.\n\n> I think the idea here is that you're paying tiny amounts for the\n> bandwidth, which when it's successful does in fact pay for the bandwidth;\n> and when it's unsuccessful results in a channel closure, which makes it\n> unprofitable to cheat the system, but doesn't change the economics of\n> lightning much overall because channel closures can happen anytime anyway.\n\nNot at all.  You can still fail to route, and still get paid.  You can't\nsteal *more* money without channel closure though.\n\n> I think that approach makes sense.\n>\n> Cheers,\n> aj\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2019-11-06T15:57:33",
                "message_text_only": "On Wed, Nov 06, 2019 at 10:43:23AM +1030, Rusty Russell wrote:\n> >> Rusty prepares a nonce, AAAAA and hashes it 25 times = ZZZZZ.\n> >> ZmnSCPxj prepares the onion, but adds extra fields (see below).  \n> > It would have made more sense to me for Alice (Zmn) to generate\n> > the nonce, hash it, and prepare the onion, so that the nonce is\n> > revealed to Dave (Rusty) if/when the message ever actually reaches its\n> > destination. Otherwise Rusty has to send AAAAA to Zmn already so that\n> > Zmn can prepare the onion?\n> The entire point is to pay *up-front*, though, to prevent spam.\n\nHmm, I'm not sure I see the point of paying upfront but not\nunconditionally -- you already commit the funds as part of the HTLC,\nand if you're refunding some of them, you kind-of have to keep them\nreserved or you risk finalising the HTLC causing a failure because you\ndon't have enough msats spare to do the refund?\n\nIf you refund on routing failure, why wouldn't a spammer just add a fake\n\"Ezekiel\" at the end of the route after Dave, so that the HTLCs always\nfail and all the fees are returned?\n\n> Bob/ZmnSCPxj doesn't prepare anything in the onion.  They get handed the\n> last hash directly: Alice is saying \"I'll pay you 50msat for each\n> preimage you can give me leading to this hash\".\n\nSo my example was Alice paying Dave via Bob and Carol (so Alice/Bob,\nBob/Carol, Carol/Dave being the individual channels).\n\nWhat you wrote to Zmn says \"Rusty decrypts the onion, reads the prepay\nfield: it says 14, LLLL.\" but Alice doesn't know anything other than\nZZZZ so can't put LLLL in the onion?\n\nAre you using Hornet so that every intermediary can communicate a nonce\nback to the source of the route? If not, \"Rusty\" generating the nonce\nseems like you're informing Rusty that you're actually the origin of the\nHTLC, and not just innocently forwarding it along; if so, it seems like\nyou have independent nonces at each step, rather than\nAAAA/BBBB/LLLL/ZZZZ in a direct chain.\n\n> > I'm not sure why lucky hashing should result in a discount?\n> Because the PoW adds noise to the amounts, otherwise the path length is\n> trivially exposed, esp in the failure case.  It's weak protection\n> though.\n\nWith a linear/exponential relationship you just get \"half the time it's\n1 unit, 25% of the time it's 2 units, 12% of the time it's 3 units\", so\nI don't think that's adding much noise?\n\n> > You've only got two nonce choices -- the initial AAAA and the depth\n> > that you tell Bob and Carol to hash to as steps in the route;\n> No, the sphinx construction allows for grinding, that was my intent\n> here.  The prepay hashes are independent.\n\nOh, because you're also xoring with the onion packet, right, I see.\n\n> > I think you could just make the scheme be:\n> >   Alice sends HTLC(k,v) + 1250 msat to Bob\n> >   Bob unwraps the onion and forwards HTLC(k,v) + 500 msat to Carol\n> >   Carol unwraps the onion and forwards HTLC(k,v) + 250 msat to Dave\n> >   Dave redeems the HTLC, claims an extra 300 msat and refunds 200 msat to Carol\n\nThe math here doesn't add up. Let's assume I meant:\n\n  Bob keeps 500 sat, forwards 750 sat\n  Carol keeps 250 sat, forwards 500 sat\n  Dave keeps 300 sat, refunds 200 sat\n\n> >   Carol redeems the HTLC and refunds 200 msat to Bob\n> >   Bob redeems the HTLC and refunds 200 msat to Alice\n> >\n> > If there's a failure, Alice loses the 1250 msat, and someone in the\n> > path steals the funds.\n> This example confuses me.\n\nWell, that makes us even at least? :)\n\n> So, you're charging 250msat per hop?  Why is Bob taking 750?  Does Carol\n> now know Dave is the last hop?\n\nNo, Alice is choosing to pay 500, 250 and 300 msat to Bob, Carol and\nDave respectively, as part of setting up the onion, and picks those\nnumbers via some magic algo trading off privacy and cost.\n\n> Does Alice lose everything on any routing failure?\n\nThat was my thought yeah; it seems weird to pay upfront but expect a\nrefund on failure -- the HTLC funds are already committed upfront and\nrefunded on failure.\n\n> If so, that is strong incentive for Alice to reduce path-length privacy\n> by keeping payments minimal, which I was really trying to avoid.\n\nAssuming v is much larger than 1250msat, and 1250 msat is much lower than\nthe cost to Bob of losing the channel with Alice, I don't think that's\na problem. 1250msat pays for 125kB of bandwdith under your assumptions\nI think?\n\n> > Does that miss anything that all the hashing achieves?\n> It does nothing if Carol is the one who can't route.\n\nIf Carol can't route, then ideally she just refunds all the money and\neveryone's happy.\n\nIf Carol tries to steal, then she can keep 750 msat instead of 250 msat.\nThis doesn't give any way for Bob to prove Carol cheated on him though;\nbut Bob could just refund the 1250 msat and write the 750 msat off as a\nloss of dealing with cheaters like Carol.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-07T04:26:51",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Wed, Nov 06, 2019 at 10:43:23AM +1030, Rusty Russell wrote:\n>> >> Rusty prepares a nonce, AAAAA and hashes it 25 times = ZZZZZ.\n>> >> ZmnSCPxj prepares the onion, but adds extra fields (see below).  \n>> > It would have made more sense to me for Alice (Zmn) to generate\n>> > the nonce, hash it, and prepare the onion, so that the nonce is\n>> > revealed to Dave (Rusty) if/when the message ever actually reaches its\n>> > destination. Otherwise Rusty has to send AAAAA to Zmn already so that\n>> > Zmn can prepare the onion?\n>> The entire point is to pay *up-front*, though, to prevent spam.\n>\n> Hmm, I'm not sure I see the point of paying upfront but not\n> unconditionally -- you already commit the funds as part of the HTLC,\n> and if you're refunding some of them, you kind-of have to keep them\n> reserved or you risk finalising the HTLC causing a failure because you\n> don't have enough msats spare to do the refund?\n\n?  These are upfront an unconditional.  I'm confused.  You pay per\nHTLC added (or, in future, to send a message).\n\nWhat part was unclear here?\n\nAlice pays X to Bob.  Bob gives X-<num-preimages> back to Alice.  Bob\ngets preimages from the onion, and from Carol etc.\n\nThis happens independent of HTLC success or failure.\n\n>> Bob/ZmnSCPxj doesn't prepare anything in the onion.  They get handed the\n>> last hash directly: Alice is saying \"I'll pay you 50msat for each\n>> preimage you can give me leading to this hash\".\n>\n> So my example was Alice paying Dave via Bob and Carol (so Alice/Bob,\n> Bob/Carol, Carol/Dave being the individual channels).\n>\n> What you wrote to Zmn says \"Rusty decrypts the onion, reads the prepay\n> field: it says 14, LLLL.\" but Alice doesn't know anything other than\n> ZZZZ so can't put LLLL in the onion?\n\nAlice created the onion.  Alice knows all the preimages, since she\ncreated the chain AAAAA....ZZZZZ.\n\n>> > I'm not sure why lucky hashing should result in a discount?\n>> Because the PoW adds noise to the amounts, otherwise the path length is\n>> trivially exposed, esp in the failure case.  It's weak protection\n>> though.\n>\n> With a linear/exponential relationship you just get \"half the time it's\n> 1 unit, 25% of the time it's 2 units, 12% of the time it's 3 units\", so\n> I don't think that's adding much noise?\n\nIt depends how much people are prepared to grind, doesn't it?\n\n>> > You've only got two nonce choices -- the initial AAAA and the depth\n>> > that you tell Bob and Carol to hash to as steps in the route;\n>> No, the sphinx construction allows for grinding, that was my intent\n>> here.  The prepay hashes are independent.\n>\n> Oh, because you're also xoring with the onion packet, right, I see.\n>\n>> > I think you could just make the scheme be:\n>> >   Alice sends HTLC(k,v) + 1250 msat to Bob\n>> >   Bob unwraps the onion and forwards HTLC(k,v) + 500 msat to Carol\n>> >   Carol unwraps the onion and forwards HTLC(k,v) + 250 msat to Dave\n>> >   Dave redeems the HTLC, claims an extra 300 msat and refunds 200 msat to Carol\n>\n> The math here doesn't add up. Let's assume I meant:\n>\n>   Bob keeps 500 sat, forwards 750 sat\n>   Carol keeps 250 sat, forwards 500 sat\n>   Dave keeps 300 sat, refunds 200 sat\n>\n>> >   Carol redeems the HTLC and refunds 200 msat to Bob\n>> >   Bob redeems the HTLC and refunds 200 msat to Alice\n>> >\n>> > If there's a failure, Alice loses the 1250 msat, and someone in the\n>> > path steals the funds.\n>> This example confuses me.\n>\n> Well, that makes us even at least? :)\n>\n>> So, you're charging 250msat per hop?  Why is Bob taking 750?  Does Carol\n>> now know Dave is the last hop?\n>\n> No, Alice is choosing to pay 500, 250 and 300 msat to Bob, Carol and\n> Dave respectively, as part of setting up the onion, and picks those\n> numbers via some magic algo trading off privacy and cost.\n\nOK.\n\n>> Does Alice lose everything on any routing failure?\n>\n> That was my thought yeah; it seems weird to pay upfront but expect a\n> refund on failure -- the HTLC funds are already committed upfront and\n> refunded on failure.\n\nAFAICT you have to overpay, since anything else is very revealing of\npath length.  Which kind of implies a refund, I think.\n\n>> If so, that is strong incentive for Alice to reduce path-length privacy\n>> by keeping payments minimal, which I was really trying to avoid.\n>\n> Assuming v is much larger than 1250msat, and 1250 msat is much lower than\n> the cost to Bob of losing the channel with Alice, I don't think that's\n> a problem. 1250msat pays for 125kB of bandwdith under your assumptions\n> I think?\n\nThat's irrelevant?  Since retries are common, it's natural for Alice to\nwant to minimize losses.  If she's going to lose everything on any\nfailure, she'll pay the minimum amount, which exposes her path length\ntrivially.\n\nThus my attempt to try to reduce the lossage. I think.\n\n>> > Does that miss anything that all the hashing achieves?\n>> It does nothing if Carol is the one who can't route.\n>\n> If Carol can't route, then ideally she just refunds all the money and\n> everyone's happy.\n\nThat tells Bob clearly that Carol failed.  If Carol claims a variable\namount, it's less obvious (though still pretty bad).\n\n> If Carol tries to steal, then she can keep 750 msat instead of 250 msat.\n> This doesn't give any way for Bob to prove Carol cheated on him though;\n> but Bob could just refund the 1250 msat and write the 750 msat off as a\n> loss of dealing with cheaters like Carol.\n\nWhat actually happens is that Carol sends a signature on a commitment\nwhich Bob does't agree with (since he expected his money back).  They go\nonchain.\n\nNow Bob is out the total he fwd to Carol, but he's probably more annoyed\nat losing the channel.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2019-11-07T11:37:35",
                "message_text_only": "On Thu, Nov 07, 2019 at 02:56:51PM +1030, Rusty Russell wrote:\n> > What you wrote to Zmn says \"Rusty decrypts the onion, reads the prepay\n> > field: it says 14, LLLL.\" but Alice doesn't know anything other than\n> > ZZZZ so can't put LLLL in the onion?\n> Alice created the onion.  Alice knows all the preimages, since she\n> created the chain AAAAA....ZZZZZ.\n\nIn your reply to Zmn, it was Rusty (Bob) preparing the nonce and creating\nthe chain AAAA...ZZZZ -- so I was lost as to what you were proposing...\n\nHere's what I now think you're saying, which I think mostly hangs\ntogether:\n\nAlice sends a HTLC with hash X and value V to Dave via Bob then Carol\n\nAlice generates a nonce AAAA, and calculates H^25(AAAA) = ZZZZ.\n\nAlice creates an onion, and sends the HTLC to Bob, revealing ZZZZ and\n6,TTTT to Bob, along with 2500 msat (25 for the hashing ops between\nAAAA and ZZZZ, and *100 for round numbers). Bob calculates \"6\" is a\nfair price.\n\nBob checks H^6(TTTT)=ZZZZ. If not, Bob refunds the 2500 msat, and fails\nthe HTLC immediately. Otherwise, Bob passes the onion on to Carol, with\n1900 msat and TTTT; Carol unwraps the onion revealing 15,EEEE. Carol\ncalcualtes \"15\" is a fair price.\n\nCarol checks H^15(EEEE)=TTTT, and fails the route if not, refunding\n1900msat to Bob. Otherwise, Carol passes the onion on to Dave, with 400\nmsat and EEEE.  Dave unwraps the onion, revealing 2,CCCC, so can claim\n200 msat as well as the HTLC amount, etc.\n\nAfter the successful route, Dave passes 2,CCCC and 200msat back to Carol,\nwho validates and continues passing things back.\n\nIf Carol instead passes, say, 3,CCCC back, then she also has to refund\n300msat to avoid Bob closing the channel, which would be fine, because\nBob can just pass that back too -- Carol's the only one losing money in\nthat case.\n\nIf Carol wants to close the channel anyway and collect the HTLC on\nchain, then Bob's situation is:\n\n   channel with Alice: +2500 msat\n   channel with Carol: -1900 msat , -fees , -HTLC funds\n\nIf Carol isn't cooperative, Bob only definitely knows TTTT, so to keep\nthe channel open with Alice, has to refund 1900msat, so:\n\n   channel with Alice:  +600 msat , +HTLC funds\n   channel with Carol: -1900 msat , -fees , -HTLC funds\n\n(or Bob could keep the 2500 msat at the cost of Alice closing the channel\ntoo:\n\n   channel with Alice: +2500 msat , -fees , +HTLC funds\n   channel with Carol: -1900 msat , -fees , -HTLC funds\n)\n\nSo Bob and either keep the channel open but is out 1300 msat because of\nCarol, or can gain 600 msat at the cost of closing the channel with\nAlice?\n\nAs far as the \"fair price\" goes, the spitballed formula is \"16 - X/4\"\nwhere X is number of zero bits in some PoW-y thing. The proposal is\nthe thing is SHA256(blockhash|revealedonion) which works, and (I think)\nmeans each step is individually grindable.\n\nI think an alternative would be to use the prepayment hashes themselves,\nso you generate the nonce AAAA as the value you'll send to Dave then\nhash it repeatedly to get BBBB..QQQQ, then check if pow(AAAA,BBBB) has\n60 leading zero bits or pow(AAAA,CCCC) has 56 leading zero bits etc.\nIf you made pow(a,b) be SHA256(a,b,shared-onion-key) I think it'd\npreserve privacy, but also mean you can't meaningfully grind unfairly\ncheap routing except for very short paths?\n\nIf you don't grind and just go by luck, the average number of hashes\nper hop is ~15.93 (if I got my maths right), so you should be able to\nestimate path length pretty accurate by dividing claimed prepaid funds by\n15.93*25msat or whatever. If everyone grinds at each level independently,\nI think you'd just subtract maybe 6 hops from that, but the maths would\nmostly stay the same?\n\nThough I think you could obfusticate that pretty well by moving\nsome of the value from the HTLC into the prepayment -- you'd risk losing\nthat extra value if the payment made it all the way to the recipient but\nthey declined the HTLC that way though.\n\n> >> Does Alice lose everything on any routing failure?\n> > That was my thought yeah; it seems weird to pay upfront but expect a\n> > refund on failure -- the HTLC funds are already committed upfront and\n> > refunded on failure.\n> AFAICT you have to overpay, since anything else is very revealing of\n> path length.  Which kind of implies a refund, I think.\n\nI guess you'd want to pay for a path length of about 20 whether the\npath is actually 17, 2, 10 or 5. But a path length of 20 is just paying\nfor bandwidth for maybe 200kB of total traffic which at $1/GB is 2% of\n1 cent, which doesn't seem that worth refunding (except for really tiny\nmicropayments, where paying for payment bandwidth might not be feasible\nat all).\n\nIf you're buying a $2 coffee and paying 500ppm in regular fees per hop\nwith 5 hops, then each routing attempt increases your fees by 4%, which\nseems pretty easy to ignore to me.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-08T02:38:04",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Thu, Nov 07, 2019 at 02:56:51PM +1030, Rusty Russell wrote:\n>> > What you wrote to Zmn says \"Rusty decrypts the onion, reads the prepay\n>> > field: it says 14, LLLL.\" but Alice doesn't know anything other than\n>> > ZZZZ so can't put LLLL in the onion?\n>> Alice created the onion.  Alice knows all the preimages, since she\n>> created the chain AAAAA....ZZZZZ.\n>\n> In your reply to Zmn, it was Rusty (Bob) preparing the nonce and creating\n> the chain AAAA...ZZZZ -- so I was lost as to what you were proposing...\n\nOops.  Don't trust that Rusty guy, let's stick with Alice.\n\n[ Snip summary, which is correct ]\n\n> As far as the \"fair price\" goes, the spitballed formula is \"16 - X/4\"\n> where X is number of zero bits in some PoW-y thing. The proposal is\n> the thing is SHA256(blockhash|revealedonion) which works, and (I think)\n> means each step is individually grindable.\n>\n> I think an alternative would be to use the prepayment hashes themselves,\n> so you generate the nonce AAAA as the value you'll send to Dave then\n> hash it repeatedly to get BBBB..QQQQ, then check if pow(AAAA,BBBB) has\n> 60 leading zero bits or pow(AAAA,CCCC) has 56 leading zero bits etc.\n> If you made pow(a,b) be SHA256(a,b,shared-onion-key) I think it'd\n> preserve privacy, but also mean you can't meaningfully grind unfairly\n> cheap routing except for very short paths?\n>\n> If you don't grind and just go by luck, the average number of hashes\n> per hop is ~15.93 (if I got my maths right), so you should be able to\n> estimate path length pretty accurate by dividing claimed prepaid funds by\n> 15.93*25msat or whatever. If everyone grinds at each level independently,\n> I think you'd just subtract maybe 6 hops from that, but the maths would\n> mostly stay the same?\n>\n> Though I think you could obfusticate that pretty well by moving\n> some of the value from the HTLC into the prepayment -- you'd risk losing\n> that extra value if the payment made it all the way to the recipient but\n> they declined the HTLC that way though.\n\nYeah, and doesn't help obscure in the in-the-middle failure case unf.\nWhich is really bad with current payment_hash since you can spot\nmultiple attempts so easily.  Hence my attempt to roll in some PoW to\nobscure the amounts.\n\nThe ideal prepay range would be wider, so you can believably have\npayments between 16 and 4 per hop, say.  But if I can grind it I'll\nnaturally restrict the range to the lower end, and if it's ungrindable\n(eg. based on nodeid and payment_hash or recent block hash) then\neveryone on the path knows what it so too.\n\nSo, hashcash here is better than nothing, but still not very good.\n\n>> >> Does Alice lose everything on any routing failure?\n>> > That was my thought yeah; it seems weird to pay upfront but expect a\n>> > refund on failure -- the HTLC funds are already committed upfront and\n>> > refunded on failure.\n>> AFAICT you have to overpay, since anything else is very revealing of\n>> path length.  Which kind of implies a refund, I think.\n>\n> I guess you'd want to pay for a path length of about 20 whether the\n> path is actually 17, 2, 10 or 5. But a path length of 20 is just paying\n> for bandwidth for maybe 200kB of total traffic which at $1/GB is 2% of\n> 1 cent, which doesn't seem that worth refunding (except for really tiny\n> micropayments, where paying for payment bandwidth might not be feasible\n> at all).\n>\n> If you're buying a $2 coffee and paying 500ppm in regular fees per hop\n> with 5 hops, then each routing attempt increases your fees by 4%, which\n> seems pretty easy to ignore to me.\n\nTrue, but ideally we'd have lots of noise even if people are trying to\nminimize fees (which, if they're sending messages rather than payments,\nthey might).\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2019-11-08T12:32:36",
                "message_text_only": "On Fri, Nov 08, 2019 at 01:08:04PM +1030, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> [ Snip summary, which is correct ]\n\nHuzzah!\n\nThis correlates all the hops in a payment when the route reaches its end\n(due to the final preimage getting propogated back for everyone to justify\nthe funds they claim). Maybe solvable by converting from hashes to ECC\nas the trapdoor function?\n\nThe refund amount propogating back also reveals the path, probably.\nCould that be obfusticated by somehow paying each intermediate node\nboth as the funds go out and come back, so the refund decreases on the\nway back?\n\nOh, can we make the amounts work like the onion, where it stays constant?\nSo:\n\n  Alice wants to pay Dave via Bob, Carol. Bob gets 700 msat, Carol gets\n  400 msat, Dave gets 300 msat, and Alice gets 100 msat refunded.\n\n  Success:\n    Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n    Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n    Carol forwards 1500 msat to Dave  (-1500, 0, 0, +1500)\n    Dave refunds 1200 msat to Carol   (-1500, 0, +1200, +300)\n    Carol refunds 800 msat to Bob     (-1500, +800, +400, +300)\n    Bob refunds 100 msat to Alice     (-1400, +700, +400, +300)\n\n  Clean routing failure at Carol/Dave:\n    Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n    Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n    Carol says Dave's not talking\n    Carol refunds 1100 msat to Bob    (-1500, +1100, +400, 0)\n    Bob refunds 400 msat to Alice     (-1100, +700, +400, 0)\n\nI think that breaks the correlation pretty well, so you just need a\ndecent way of obscuring path length?\n\nIn the uncooperative routing failure case, I wonder if using an ECC\ntrapdoor and perhaps scriptless scripts, you could make it so Carol\ndoesn't even get an updated state without revealing the preimage...\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-10T23:30:52",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Nov 08, 2019 at 01:08:04PM +1030, Rusty Russell wrote:\n>> Anthony Towns <aj at erisian.com.au> writes:\n>> [ Snip summary, which is correct ]\n>\n> Huzzah!\n>\n> This correlates all the hops in a payment when the route reaches its end\n> (due to the final preimage getting propogated back for everyone to justify\n> the funds they claim). Maybe solvable by converting from hashes to ECC\n> as the trapdoor function?\n\nI hadn't thought of this, but yes, once we've eliminated the trivial\npreimage correlation w/scriptless scripts it'd be a shame to reintroduce\nit here.\n\nWe need an accumulator with some strange properties though:\n\n1. Alice provides tokens and a base accumulator.\n2. Bob et. al can add these tokens to the accumulator.\n3. They can tell if invalid tokens have been added to the accumulator.\n4. They can tell how many tokens (alt: each token has a value and they\n   can tell the value sum) have been added.\n5. They can't tell what tokens have been added (unless they know all\n   the tokens, which is trivial).\n\nAny ideas?\n\n> The refund amount propogating back also reveals the path, probably.\n> Could that be obfusticated by somehow paying each intermediate node\n> both as the funds go out and come back, so the refund decreases on the\n> way back?\n>\n> Oh, can we make the amounts work like the onion, where it stays constant?\n> So:\n>\n>   Alice wants to pay Dave via Bob, Carol. Bob gets 700 msat, Carol gets\n>   400 msat, Dave gets 300 msat, and Alice gets 100 msat refunded.\n>\n>   Success:\n>     Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n>     Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n>     Carol forwards 1500 msat to Dave  (-1500, 0, 0, +1500)\n>     Dave refunds 1200 msat to Carol   (-1500, 0, +1200, +300)\n>     Carol refunds 800 msat to Bob     (-1500, +800, +400, +300)\n>     Bob refunds 100 msat to Alice     (-1400, +700, +400, +300)\n\nOr, on success, upfront payment is fully refunded or not refunded at all\n(since they get paid by normal fees)?  Either way, no data leak for that\ncase.\n\n>   Clean routing failure at Carol/Dave:\n>     Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n>     Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n>     Carol says Dave's not talking\n>     Carol refunds 1100 msat to Bob    (-1500, +1100, +400, 0)\n>     Bob refunds 400 msat to Alice     (-1100, +700, +400, 0)\n>\n> I think that breaks the correlation pretty well, so you just need a\n> decent way of obscuring path length?\n\nI don't see how this breaks correlation?\n\n> In the uncooperative routing failure case, I wonder if using an ECC\n> trapdoor and perhaps scriptless scripts, you could make it so Carol\n> doesn't even get an updated state without revealing the preimage...\n\nI'm not sure.  We can make it so Carol has Bob's preimage(s), etc, so\nthat the node which fails doesn't get paid.  I initially thought this\nwould just make people pair up (fake) nodes, but it's probably not worth\nit since their path would be less-selected in that case.\n\nCheers,\nRusty."
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-11-22T09:07:41",
                "message_text_only": "I think there's another alternative than upfront payments to prevent spam,\nwhich is maybe less\ncontroversial (but potentially less effective as well - to be investigated).\n\nWhy not adapt what has been done with email spam and PoW/merkle puzzles?\nThe high-level idea would be that the sender must solve a small PoW puzzle *for\neach intermediate *\n*node *and communicate the solution in the onion.\nThere are many ways we could do that (a new field in each intermediate hop,\ngrinding an HMAC\nprefix, etc) so before going into specifics I only wanted to submit the\nhigh-level idea.\nWhat's neat with this is that it's simple, doesn't leak any privacy, and\navoids having to create a\nnode reputation system.\n\nWe fight spam by forcing the sender to use some resources (instead of sats).\nMaybe this idea has already been proposed and broken, if that's the case\nI'd love to see the\ndiscussion if someone can surface it.\n\nCheers,\nBastien\n\nLe lun. 11 nov. 2019 \u00e0 00:32, Rusty Russell <rusty at rustcorp.com.au> a\n\u00e9crit :\n\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On Fri, Nov 08, 2019 at 01:08:04PM +1030, Rusty Russell wrote:\n> >> Anthony Towns <aj at erisian.com.au> writes:\n> >> [ Snip summary, which is correct ]\n> >\n> > Huzzah!\n> >\n> > This correlates all the hops in a payment when the route reaches its end\n> > (due to the final preimage getting propogated back for everyone to\n> justify\n> > the funds they claim). Maybe solvable by converting from hashes to ECC\n> > as the trapdoor function?\n>\n> I hadn't thought of this, but yes, once we've eliminated the trivial\n> preimage correlation w/scriptless scripts it'd be a shame to reintroduce\n> it here.\n>\n> We need an accumulator with some strange properties though:\n>\n> 1. Alice provides tokens and a base accumulator.\n> 2. Bob et. al can add these tokens to the accumulator.\n> 3. They can tell if invalid tokens have been added to the accumulator.\n> 4. They can tell how many tokens (alt: each token has a value and they\n>    can tell the value sum) have been added.\n> 5. They can't tell what tokens have been added (unless they know all\n>    the tokens, which is trivial).\n>\n> Any ideas?\n>\n> > The refund amount propogating back also reveals the path, probably.\n> > Could that be obfusticated by somehow paying each intermediate node\n> > both as the funds go out and come back, so the refund decreases on the\n> > way back?\n> >\n> > Oh, can we make the amounts work like the onion, where it stays constant?\n> > So:\n> >\n> >   Alice wants to pay Dave via Bob, Carol. Bob gets 700 msat, Carol gets\n> >   400 msat, Dave gets 300 msat, and Alice gets 100 msat refunded.\n> >\n> >   Success:\n> >     Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n> >     Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n> >     Carol forwards 1500 msat to Dave  (-1500, 0, 0, +1500)\n> >     Dave refunds 1200 msat to Carol   (-1500, 0, +1200, +300)\n> >     Carol refunds 800 msat to Bob     (-1500, +800, +400, +300)\n> >     Bob refunds 100 msat to Alice     (-1400, +700, +400, +300)\n>\n> Or, on success, upfront payment is fully refunded or not refunded at all\n> (since they get paid by normal fees)?  Either way, no data leak for that\n> case.\n>\n> >   Clean routing failure at Carol/Dave:\n> >     Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n> >     Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n> >     Carol says Dave's not talking\n> >     Carol refunds 1100 msat to Bob    (-1500, +1100, +400, 0)\n> >     Bob refunds 400 msat to Alice     (-1100, +700, +400, 0)\n> >\n> > I think that breaks the correlation pretty well, so you just need a\n> > decent way of obscuring path length?\n>\n> I don't see how this breaks correlation?\n>\n> > In the uncooperative routing failure case, I wonder if using an ECC\n> > trapdoor and perhaps scriptless scripts, you could make it so Carol\n> > doesn't even get an updated state without revealing the preimage...\n>\n> I'm not sure.  We can make it so Carol has Bob's preimage(s), etc, so\n> that the node which fails doesn't get paid.  I initially thought this\n> would just make people pair up (fake) nodes, but it's probably not worth\n> it since their path would be less-selected in that case.\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191122/c0045b8d/attachment.html>"
            },
            {
                "author": "Pierre",
                "date": "2019-11-22T09:31:21",
                "message_text_only": "> The high-level idea would be that the sender must solve a small PoW puzzle\n\n<insert meme: \"Yo dawg I heard you like pow systems...\" >"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-22T09:49:16",
                "message_text_only": "Good morning Bastien,\n\n> I think there's another alternative than upfront payments to prevent spam, which is maybe less\u00a0\n> controversial (but potentially less effective as well - to be investigated).\n>\n> Why not adapt what has been done with email spam and PoW/merkle puzzles?\n> The high-level idea would be that the sender must solve a small PoW puzzle for each intermediate\u00a0\n> node\u00a0and communicate the solution in the onion.\n> There are many ways we could do that (a new field in each intermediate hop, grinding an HMAC\u00a0\n> prefix, etc) so before going into specifics I only wanted to submit the high-level idea.\n> What's neat with this is that it's simple, doesn't leak any privacy, and avoids having to create a\n> node reputation system.\n>\n> We fight spam by forcing the sender to use some resources (instead of sats).\n> Maybe this idea has already been proposed and broken, if that's the case I'd love to see the\n> discussion if someone can surface it.\n\nThis imposes a cost that varies depending on how specialized your hardware is at generating proof-of-work.\n\nAt a certain point-of-view, one can argue that directly paying with millisatoshis for each hop (whether it fails to forward or not) has the same cost on the sender (replace the consumption of energy to compute proof-of-work with a payment or burning of funds instead), and at least does not prejudice against sender hardware that is not specialized at generating proof-of-work.\n\nThus I would argue that, given we already have a system that bases an economic token on top of proof-of-work, every use of proof-of-work today (other than to power Bitcoin itself, as Bitcoin cannot support itself) can instead be done by using Bitcoins to impose this economic cost.\n\nAll economic costs resolve to energy (economic tokens represent \"right-to-consume-energy\", by the simple technique of purchasing energy), thus requiring a fee is equivalent to requiring proof-of-work, incentive-wise.\nThe drawback is that proof-of-work is cheaper for specialized hardware (as well as specialized setups for getting more energy at cheaper costs).\n\nAs hardware specialization for the specific Lightning-Network-proof-of-work arises, we will find that to practically limit spam, intermediate nodes will have to increase and increase the threshold for accepting proof-of-work, as spammers are going to switch to the more-specialized hardware.\nThis leads to certain kinds of hardware (older mobile phones, older workstations, etc.) being unable to practically use the Lightning Network due to the increased proof-of-work threshold.\nEventually, services will arise where datacenters of specialized hardware are rented out to Lighning Network nodes for a fee in exchange for a proof-of-work to be used on a route --- datacenters that may very well end up becoming kingmakers capable of allowing or suppressing certain economic activities.\nThis ends up being indirect and loses a good amount of privacy.\nIt is better to simply impose *some* cost on the sender that it pays directly, than to use a mechanism that inherently leads to specialization.\n\nRegards,\nZmnSCPxj\n\n>\n> Cheers,\n> Bastien\n>\n> Le\u00a0lun. 11 nov. 2019 \u00e0\u00a000:32, Rusty Russell <rusty at rustcorp.com.au> a \u00e9crit\u00a0:\n>\n> > Anthony Towns <aj at erisian.com.au> writes:\n> > > On Fri, Nov 08, 2019 at 01:08:04PM +1030, Rusty Russell wrote:\n> > >> Anthony Towns <aj at erisian.com.au> writes:\n> > >> [ Snip summary, which is correct ]\n> > >\n> > > Huzzah!\n> > >\n> > > This correlates all the hops in a payment when the route reaches its end\n> > > (due to the final preimage getting propogated back for everyone to justify\n> > > the funds they claim). Maybe solvable by converting from hashes to ECC\n> > > as the trapdoor function?\n> >\n> > I hadn't thought of this, but yes, once we've eliminated the trivial\n> > preimage correlation w/scriptless scripts it'd be a shame to reintroduce\n> > it here.\n> >\n> > We need an accumulator with some strange properties though:\n> >\n> > 1. Alice provides tokens and a base accumulator.\n> > 2. Bob et. al can add these tokens to the accumulator.\n> > 3. They can tell if invalid tokens have been added to the accumulator.\n> > 4. They can tell how many tokens (alt: each token has a value and they\n> > \u00a0 \u00a0can tell the value sum) have been added.\n> > 5. They can't tell what tokens have been added (unless they know all\n> > \u00a0 \u00a0the tokens, which is trivial).\n> >\n> > Any ideas?\n> >\n> > > The refund amount propogating back also reveals the path, probably.\n> > > Could that be obfusticated by somehow paying each intermediate node\n> > > both as the funds go out and come back, so the refund decreases on the\n> > > way back?\n> > >\n> > > Oh, can we make the amounts work like the onion, where it stays constant?\n> > > So:\n> > >\n> > >\u00a0 \u00a0Alice wants to pay Dave via Bob, Carol. Bob gets 700 msat, Carol gets\n> > >\u00a0 \u00a0400 msat, Dave gets 300 msat, and Alice gets 100 msat refunded.\n> > >\n> > >\u00a0 \u00a0Success:\n> > >\u00a0 \u00a0 \u00a0Alice forwards 1500 msat to Bob\u00a0 \u00a0(-1500, +1500, 0, 0)\n> > >\u00a0 \u00a0 \u00a0Bob forwards 1500 msat to Carol\u00a0 \u00a0(-1500, 0, +1500, 0)\n> > >\u00a0 \u00a0 \u00a0Carol forwards 1500 msat to Dave\u00a0 (-1500, 0, 0, +1500)\n> > >\u00a0 \u00a0 \u00a0Dave refunds 1200 msat to Carol\u00a0 \u00a0(-1500, 0, +1200, +300)\n> > >\u00a0 \u00a0 \u00a0Carol refunds 800 msat to Bob\u00a0 \u00a0 \u00a0(-1500, +800, +400, +300)\n> > >\u00a0 \u00a0 \u00a0Bob refunds 100 msat to Alice\u00a0 \u00a0 \u00a0(-1400, +700, +400, +300)\n> >\n> > Or, on success, upfront payment is fully refunded or not refunded at all\n> > (since they get paid by normal fees)?\u00a0 Either way, no data leak for that\n> > case.\n> >\n> > >\u00a0 \u00a0Clean routing failure at Carol/Dave:\n> > >\u00a0 \u00a0 \u00a0Alice forwards 1500 msat to Bob\u00a0 \u00a0(-1500, +1500, 0, 0)\n> > >\u00a0 \u00a0 \u00a0Bob forwards 1500 msat to Carol\u00a0 \u00a0(-1500, 0, +1500, 0)\n> > >\u00a0 \u00a0 \u00a0Carol says Dave's not talking\n> > >\u00a0 \u00a0 \u00a0Carol refunds 1100 msat to Bob\u00a0 \u00a0 (-1500, +1100, +400, 0)\n> > >\u00a0 \u00a0 \u00a0Bob refunds 400 msat to Alice\u00a0 \u00a0 \u00a0(-1100, +700, +400, 0)\n> > >\n> > > I think that breaks the correlation pretty well, so you just need a\n> > > decent way of obscuring path length?\n> >\n> > I don't see how this breaks correlation?\n> >\n> > > In the uncooperative routing failure case, I wonder if using an ECC\n> > > trapdoor and perhaps scriptless scripts, you could make it so Carol\n> > > doesn't even get an updated state without revealing the preimage...\n> >\n> > I'm not sure.\u00a0 We can make it so Carol has Bob's preimage(s), etc, so\n> > that the node which fails doesn't get paid.\u00a0 I initially thought this\n> > would just make people pair up (fake) nodes, but it's probably not worth\n> > it since their path would be less-selected in that case.\n> >\n> > Cheers,\n> > Rusty.\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-11-22T10:11:37",
                "message_text_only": "While I agree with most of your points, I think there are subtleties to\nexplore before\ncompletely rejecting the idea.\n\nevery use of proof-of-work today (other than to power Bitcoin itself, as\n> Bitcoin cannot support itself) can instead be done by using Bitcoins to\n> impose this economic cost.\n>\n\nThat is philosophically true, but the complexity of integrating that small\nPoW into Lightning\nis much lower than the complexity of integrating **fair, un-gameable**\nupfront payments.\nAnd not all PoW is born equal: there are a lot of PoW schemes that have\ndifferent trade-offs\nthan Bitcoin mining (think ASIC-resistance such as variants of Cuckoo\nCycle).\n\nAnother key point is that creating ASICs for this PoW is fundamentally\ndifferent from creating\nASICs for mining a crypto-currency. Solving this PoW doesn't earn you any\nmoney: it merely\nallows you to spam to temporarily disrupt the network.\nSince this PoW isn't used in any consensus, we can change the spam PoW\nalgorithm anytime\nwe want, making all previous ASICs obsolete.\nSo it's not obvious to me that anyone would find it viable to invest in\ncreating such ASICs.\n\nAs hardware specialization for the specific Lightning-Network-proof-of-work\n> arises, we will find that to practically limit spam, intermediate nodes\n> will have to increase and increase the threshold for accepting\n> proof-of-work, as spammers are going to switch to the more-specialized\n> hardware.\n>\n\nThat's where I think it can be more subtle than what you describe (I may be\nwrong though as\npredicting future behavior is hard).\n\nSince I'm ruling out ASICs, we're only dealing with \"normal\" hardware\nbottlenecks (cpu/ram).\nThat means attackers are not playing at a completely different scale than\nnormal users.\nThe cost for attackers to generate an amount of spam mimicking N normal\nusers will then be\nsomewhat linear in N (to be investigated further).\nThat's exactly the same result as upfront payments, where an attacker can\nstill spam like\nhe's N users if he's ready to pay a cost linear in N.\n\nI'm slightly playing devil's advocate for the PoW proposal because I think\nit's worth exploring\nmore, even if we eventually abandon it. Maybe you're right and it won't be\nas effective to\nfight spam as upfront payments: but right now with the arguments I've seen\non this thread,\nI'm not yet convinced of that.\n\nCheers,\nBastien\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191122/32cc41a8/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-24T15:16:35",
                "message_text_only": "Good morning Bastien,\n\n> While I agree with most of your points, I think there are subtleties to explore before\n> completely rejecting the idea.\n>\n> > every use of proof-of-work today (other than to power Bitcoin itself, as Bitcoin cannot support itself) can instead be done by using Bitcoins to impose this economic cost.\n>\n> That is philosophically true, but the complexity of integrating that small PoW into Lightning\u00a0\n> is much lower than the complexity of integrating *fair, un-gameable* upfront payments.\n> And not all PoW is born equal: there are a lot of PoW schemes that have different trade-offs\n> than Bitcoin mining (think ASIC-resistance such as variants of Cuckoo Cycle).\n>\n> Another key point is that creating ASICs for this PoW is fundamentally different from creating\n> ASICs for mining a crypto-currency. Solving this PoW doesn't earn you any money: it merely\n> allows you to spam to temporarily disrupt the network.\n> Since this PoW isn't used in any consensus, we can change the spam PoW algorithm anytime\n> we want, making all previous ASICs obsolete.\n> So it's not obvious to me that anyone would find it viable to invest in creating such ASICs.\n\nhttps://github.com/libbitcoin/libbitcoin-system/wiki/Proof-of-Work-Fallacy\n\nWhile it is true that we do not need consensus at the Lightning layer, we still require that senders are compatible with intermediate nodes to the extent that they use intermediate nodes.\nThus a PoW change here would require that intermediate nodes reject older PoW (that is the entire point) while senders must be prepared to provide either the old PoW algorithm or the new one (as arbitrary intermediate nodes may not update immediately).\n\nSpecialization will arise to the extent that we design the system to allow it.\nIn this case, specialized PoW-providers will be paid in order to provide PoW that will be presented to intermediate nodes.\nFar better to just pay intermediate nodes directly and remove this additional friction.\n\n\n>\n> > As hardware specialization for the specific Lightning-Network-proof-of-work arises, we will find that to practically limit spam, intermediate nodes will have to increase and increase the threshold for accepting proof-of-work, as spammers are going to switch to the more-specialized hardware.\n>\n> That's where I think it can be more subtle than what you describe (I may be wrong though as\n> predicting future behavior is hard).\n>\n> Since I'm ruling out ASICs, we're only dealing with \"normal\" hardware bottlenecks (cpu/ram).\n> That means attackers are not playing at a completely different scale than normal users.\n\nHow many botnets does a normal user control?\n\n> The cost for attackers to generate an amount of spam mimicking N normal users will then be\n> somewhat linear in N (to be investigated further).\u00a0\n> That's exactly the same result as upfront payments, where an attacker can still spam like\n> he's N users if he's ready to pay a cost linear in N.\n\nThen just use upfront payments.\n\n\n> > requiring a fee is equivalent to requiring proof-of-work, incentive-wise.\n>\n> Not necessarily, given that\n> 1) there is a finite bitcoin supply but an eventually infinite PoW\n> supply (relevant in the unlikely case fees are burned)\n> 2) sats are transferrable, whereas PoW isn't (relevant in the case fees\n> are paid)\n\nNot actually.\nAgain, let me point out that PoW can be *bought*, that is precisely what Bitcoin blockchain layer does.\nAnd the blockchain layer PoW is bought with two things: fees and subsidies (inflation).\nThus PoW, being purchaseable, is incentive-wise equivalent to paying somebody to spend electricity (possibly with efficiencies at scale).\nJust cut the middleman.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-11-25T12:15:18",
                "message_text_only": "Hi ZmnSCPxj,\n\n>>> requiring a fee is equivalent to requiring proof-of-work, incentive-wise.\n>>\n>> Not necessarily, given that\n>> 1) there is a finite bitcoin supply but an eventually infinite PoW\n>> supply (relevant in the unlikely case fees are burned)\n>> 2) sats are transferrable, whereas PoW isn't (relevant in the case fees\n>> are paid)\n> \n> Not actually.\n> Again, let me point out that PoW can be *bought*, that is precisely what Bitcoin blockchain layer does.\n> And the blockchain layer PoW is bought with two things: fees and subsidies (inflation).\n> Thus PoW, being purchaseable, is incentive-wise equivalent to paying somebody to spend electricity (possibly with efficiencies at scale).\n> Just cut the middleman.\n\nI wasn't clear enough, sorry for that. I agree that in general PoW can\nbe bought. However if I understand this particular PoW proposal\ncorrectly, a brand-new PoW has to be created for each intermediary.\nThese PoWs cannot be reused by the intermediary for later payments (or\nfor anything else).\n\nI will now show that there exist spam-prevention schemes that differ\nonly on whether the payer gives sats or PoWs to intermediaries, such\nthat economically rational agents are incentivized to cheat in the case\nof sats but not so in the case of PoWs. This proves that fees are *not*\nequivalent to PoWs incentive-wise.\n\nIn our model, an intermediary can follow one of three possible\nstrategies (we make the assumption that other strategies are strictly\ndominated by one of the three). Each strategy results in different\nresource utilization and proceeds from fees.\n  (A) do nothing. This results in resources_A = 0 and sats_A = 0\n  (B) play honestly. resources_B < 0 (negative because they constitute\nan operating cost) and sats_B = anti_spam_fee + routing_fee\n  (C) mount a plausibly deniable attack. Here resources_C < 0 and sats_C\n= anti_spam_fee.\nWe assume that resources_C > resources_B + routing_fee (1).\n\nIn case intermediaries receive PoWs as an anti-spam measure, it is\nanti_spam_fee = 0 which means that resources_C + sats_C < 0 =\nresources_A + sats_A, therefore strategy C is strictly dominated by A.\n(The fact that A also strictly dominates B is an interesting\nobservation, but beside the point for the argument made.)\n\nOTOH, in the case of anti-spam sats, it is anti_spam_fee > 0. Therefore\nwe have resources_C + sats_C > resources_B + sats_B (using (1)) and for\na big enough anti_spam_fee, it is resources_C + sats_C > 0, therefore\nstrategy C strictly dominates both A and B.\n\nIn other words, by just changing whether we use anti-spam PoWs or fees,\nwe change the economically rational behavior.\n\nI apologize for the previous ambiguity and I hope this has made my\nargument clearer.\n\nBest,\nOrfeas\n\n-- \nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-26T08:12:08",
                "message_text_only": "Good morning Orfeas,\n\n> Hi ZmnSCPxj,\n>\n> > > > requiring a fee is equivalent to requiring proof-of-work, incentive-wise.\n> > >\n> > > Not necessarily, given that\n> > >\n> > > 1.  there is a finite bitcoin supply but an eventually infinite PoW\n> > >     supply (relevant in the unlikely case fees are burned)\n> > >\n> > > 2.  sats are transferrable, whereas PoW isn't (relevant in the case fees\n> > >     are paid)\n> > >\n> >\n> > Not actually.\n> > Again, let me point out that PoW can be bought, that is precisely what Bitcoin blockchain layer does.\n> > And the blockchain layer PoW is bought with two things: fees and subsidies (inflation).\n> > Thus PoW, being purchaseable, is incentive-wise equivalent to paying somebody to spend electricity (possibly with efficiencies at scale).\n> > Just cut the middleman.\n>\n> I wasn't clear enough, sorry for that. I agree that in general PoW can\n> be bought. However if I understand this particular PoW proposal\n> correctly, a brand-new PoW has to be created for each intermediary.\n> These PoWs cannot be reused by the intermediary for later payments (or\n> for anything else).\n>\n> I will now show that there exist spam-prevention schemes that differ\n> only on whether the payer gives sats or PoWs to intermediaries, such\n> that economically rational agents are incentivized to cheat in the case\n> of sats but not so in the case of PoWs. This proves that fees are not\n> equivalent to PoWs incentive-wise.\n>\n> In our model, an intermediary can follow one of three possible\n> strategies (we make the assumption that other strategies are strictly\n> dominated by one of the three). Each strategy results in different\n> resource utilization and proceeds from fees.\n> (A) do nothing. This results in resources_A = 0 and sats_A = 0\n> (B) play honestly. resources_B < 0 (negative because they constitute\n> an operating cost) and sats_B = anti_spam_fee + routing_fee\n> (C) mount a plausibly deniable attack. Here resources_C < 0 and sats_C\n> = anti_spam_fee.\n> We assume that resources_C > resources_B + routing_fee (1).\n>\n> In case intermediaries receive PoWs as an anti-spam measure, it is\n> anti_spam_fee = 0 which means that resources_C + sats_C < 0 =\n> resources_A + sats_A, therefore strategy C is strictly dominated by A.\n> (The fact that A also strictly dominates B is an interesting\n> observation, but beside the point for the argument made.)\n>\n> OTOH, in the case of anti-spam sats, it is anti_spam_fee > 0. Therefore\n> we have resources_C + sats_C > resources_B + sats_B (using (1)) and for\n> a big enough anti_spam_fee, it is resources_C + sats_C > 0, therefore\n>\n> strategy C strictly dominates both A and B.\n>\n> In other words, by just changing whether we use anti-spam PoWs or fees,\n> we change the economically rational behavior.\n>\n> I apologize for the previous ambiguity and I hope this has made my\n> argument clearer.\n\nThis can be made \"the same\" by any of the following methods:\n\n* Burning the up-front fees.\n* Locking the up-front fees for a time, then reverting them to the original sender.\n\nFees and PoW are equivalent.\nThe artificial difference here is that in the PoW case, the PoW cannot be reused by the intermediate node.\nThen we only need to make the up front fees also not reusable by the intermediate node, which can be done by either of the above.\nI believe the latter would be more palatable: you pay fees, part of which is just there to prove you are not spamming the network, and which will be returned to you after a few days.\nOr just provably burn the funds by sending it to a P2WSH containing `OP_RETURN \"ZmnSCPxj is not an AI\"`.\n\nThis lets us get around having to *design* a PoW, which devs have to change every few months to get around the inevitable ASIC targeting the algorithm, and just lets us reuse existing mechanisms (i.e. Bitcoin).\nThe same thing is used in spam prevention in defiads, for example -- the money backing an advertisement is locked, and this justifies the propagation of the advertisement as long as the money remains locked in the UTXO.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-11-26T11:41:50",
                "message_text_only": "Hello ZmnSCPxj,\n\n> This can be made \"the same\" by any of the following methods:\n> \n> * Burning the up-front fees.\n\nThis would impose a hard maximum of 21 * 10^6 * 10^8 global lifetime hops, and a much lower practical one. PoW OTOH doesn't impose such limits. Hence different dynamics.\n\n> * Locking the up-front fees for a time, then reverting them to the original sender.\n\nThis means that I can burst-spam today, wait until unlock, repeat. If the PoW scheme somehow enforces fresh PoWs (e.g. by needing (nonce || recent block hash) as proof), I can't do this attack.\n\n> Fees and PoW are equivalent.\n\nIf by \"equivalent\" you mean \"a drop-in replacement\", then I hope the subtle differences above and the previous discussion show that this is not the case. If by \"equivalent\" you mean (a formal version of) \"for any scheme that uses PoWs, there exists a fee-based scheme with the same incentives and large-scale dynamics\", then that's a very strong claim of which I would love to see a proof (and a formal statement).\n\nThis is not to say that I believe PoWs are the solution to spam, just that they warrant separate investigation from fees.\n\nBest,\nOrfeas\n\n-- \nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336."
            },
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-11-22T11:13:36",
                "message_text_only": "Good morning ZmnSCPxj,\n\n> requiring a fee is equivalent to requiring proof-of-work, incentive-wise.\n\nNot necessarily, given that\n1) there is a finite bitcoin supply but an eventually infinite PoW\nsupply (relevant in the unlikely case fees are burned)\n2) sats are transferrable, whereas PoW isn't (relevant in the case fees\nare paid)\n\nOn the other hand, there exists this paper with the fancy name that\nclaims using PoW for spam prevention in the context of email (the\noriginal context in which PoW was discovered) is ineffective due to the\nhigh per-message PoW required to beat spam [0]. Therefore we have to see\nwhether this paper applies to LN as well before going down that road.\n\nSpam prevention in an unauthenticated system is much more complex than\nit seems at first, because it boils down to avoiding the Sybil attack,\n(one of) the most difficult problem(s) in such systems. A (traditional)\nreputation system in essence enables authentication (eww), per-message\nPoW might be too expensive, and per-message fees seem to have incentives\nissues and are kind of misaligned with LN's aims.\n\nMaybe I've missed something, but what makes spam in LN a bigger problem\nthan it is in every other p2p network out there? Why won't traditional\nbad activity thresholds do the job?\n\nI don't think spam is something that will be completely wiped out, only\ncontained. LN should provide for many orthogonal spam prevention\nmeasures (local tunable activity thresholds, gossipable reputation\nsystems (eww), per-message fees, per-message PoW) with sensible defaults\nto allow users to experiment and choose what is best for them, but that\nmay lead to unacceptable protocol and UI complexity. What a tradeoff...\n\nBest,\nOrfeas\n\n[0] https://www.cl.cam.ac.uk/~rnc1/proofwork.pdf\n\n-- \nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-23T00:37:47",
                "message_text_only": "Bastien TEINTURIER <bastien at acinq.fr> writes:\n> I think there's another alternative than upfront payments to prevent spam,\n> which is maybe less\n> controversial (but potentially less effective as well - to be investigated).\n>\n> Why not adapt what has been done with email spam and PoW/merkle puzzles?\n\nIf we can't come up with an untracable scheme, this is what we'll have\nto do (i.e. remove the sats component).\n\nUnfortunately botnets are really good at generating these.  That was\nalways the hashcash flaw (which is why it was never actually used).\n\nUsing a dynamic level is possible, too, so it gets harder in case we're\nbeing spam attacked.\n\nCheers,\nRusty.\n\n> The high-level idea would be that the sender must solve a small PoW puzzle *for\n> each intermediate *\n> *node *and communicate the solution in the onion.\n> There are many ways we could do that (a new field in each intermediate hop,\n> grinding an HMAC\n> prefix, etc) so before going into specifics I only wanted to submit the\n> high-level idea.\n> What's neat with this is that it's simple, doesn't leak any privacy, and\n> avoids having to create a\n> node reputation system.\n>\n> We fight spam by forcing the sender to use some resources (instead of sats).\n> Maybe this idea has already been proposed and broken, if that's the case\n> I'd love to see the\n> discussion if someone can surface it.\n>\n>\n> Cheers,\n> Bastien\n>\n> Le lun. 11 nov. 2019 \u00e0 00:32, Rusty Russell <rusty at rustcorp.com.au> a\n> \u00e9crit :\n>\n>> Anthony Towns <aj at erisian.com.au> writes:\n>> > On Fri, Nov 08, 2019 at 01:08:04PM +1030, Rusty Russell wrote:\n>> >> Anthony Towns <aj at erisian.com.au> writes:\n>> >> [ Snip summary, which is correct ]\n>> >\n>> > Huzzah!\n>> >\n>> > This correlates all the hops in a payment when the route reaches its end\n>> > (due to the final preimage getting propogated back for everyone to\n>> justify\n>> > the funds they claim). Maybe solvable by converting from hashes to ECC\n>> > as the trapdoor function?\n>>\n>> I hadn't thought of this, but yes, once we've eliminated the trivial\n>> preimage correlation w/scriptless scripts it'd be a shame to reintroduce\n>> it here.\n>>\n>> We need an accumulator with some strange properties though:\n>>\n>> 1. Alice provides tokens and a base accumulator.\n>> 2. Bob et. al can add these tokens to the accumulator.\n>> 3. They can tell if invalid tokens have been added to the accumulator.\n>> 4. They can tell how many tokens (alt: each token has a value and they\n>>    can tell the value sum) have been added.\n>> 5. They can't tell what tokens have been added (unless they know all\n>>    the tokens, which is trivial).\n>>\n>> Any ideas?\n>>\n>> > The refund amount propogating back also reveals the path, probably.\n>> > Could that be obfusticated by somehow paying each intermediate node\n>> > both as the funds go out and come back, so the refund decreases on the\n>> > way back?\n>> >\n>> > Oh, can we make the amounts work like the onion, where it stays constant?\n>> > So:\n>> >\n>> >   Alice wants to pay Dave via Bob, Carol. Bob gets 700 msat, Carol gets\n>> >   400 msat, Dave gets 300 msat, and Alice gets 100 msat refunded.\n>> >\n>> >   Success:\n>> >     Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n>> >     Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n>> >     Carol forwards 1500 msat to Dave  (-1500, 0, 0, +1500)\n>> >     Dave refunds 1200 msat to Carol   (-1500, 0, +1200, +300)\n>> >     Carol refunds 800 msat to Bob     (-1500, +800, +400, +300)\n>> >     Bob refunds 100 msat to Alice     (-1400, +700, +400, +300)\n>>\n>> Or, on success, upfront payment is fully refunded or not refunded at all\n>> (since they get paid by normal fees)?  Either way, no data leak for that\n>> case.\n>>\n>> >   Clean routing failure at Carol/Dave:\n>> >     Alice forwards 1500 msat to Bob   (-1500, +1500, 0, 0)\n>> >     Bob forwards 1500 msat to Carol   (-1500, 0, +1500, 0)\n>> >     Carol says Dave's not talking\n>> >     Carol refunds 1100 msat to Bob    (-1500, +1100, +400, 0)\n>> >     Bob refunds 400 msat to Alice     (-1100, +700, +400, 0)\n>> >\n>> > I think that breaks the correlation pretty well, so you just need a\n>> > decent way of obscuring path length?\n>>\n>> I don't see how this breaks correlation?\n>>\n>> > In the uncooperative routing failure case, I wonder if using an ECC\n>> > trapdoor and perhaps scriptless scripts, you could make it so Carol\n>> > doesn't even get an updated state without revealing the preimage...\n>>\n>> I'm not sure.  We can make it so Carol has Bob's preimage(s), etc, so\n>> that the node which fails doesn't get paid.  I initially thought this\n>> would just make people pair up (fake) nodes, but it's probably not worth\n>> it since their path would be less-selected in that case.\n>>\n>> Cheers,\n>> Rusty.\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2019-11-06T00:13:05",
                "message_text_only": "Hi Rusty,\n\nAgreed w.r.t the need for prepaid HTLCS, I've been mulling over other\nalternatives for a few years now, and none of them seems to resolve the\nseries of routing related incentive issues that prepaid HTLCs would.\n\n> Since both Offers and Joost's WhatSat are looking at sending messages,\n> it's time to float actual proposals.\n\nIMO both should just be done over HORNET, so we don't need introduce a new\nset of internal protocol level messages whenever we have some new\ncontrol/signalling need. Instead, we'd have a control/signal channel (give\nme\nroutes, invoices, sign this, etc), and a payment channel (HTLCs as used\ntoday).\n\n> 2. Adding an HTLC causes a *push* of a number of msat on commitment_signed\n> (new field), and a hash.\n\nThe prepay amount should be signalled in the update add message instead.\nThis lets HTLCs carry a heterogeneous set of prepay amounts. In addition, we\nneed a new onion field as well to signal the incoming amount the node\n_should_ have received (allows them to detect deviations in the sender's\nintended route).\n\n> 3. Failing/succeeding an HTLC returns some of those msat, and a count and\n> preimage (new fields).\n\nFailing shouldn't return the prepay amount, otherwise extending long lived\nHTLCs then cancelling them at the last minute is still costless. This\ncostlessness of _adding_ an HTLC to a _remote_ commitment is IMO, the\nbiggest incentive flaw that exists today in the greater routing network.\n\n>  You get to keep 50 msat[1] per preimage you present[2].\n\nWe should avoid introducing any new constants to the protocol, as they're\ntypically dreamed up independent of any empirical lessons learned from\ndeployment.\n\nOn the topic of the prepay cost, the channel update message should be\nextended to allow nodes to signal prepay costs similar to the way we handle\nregular payment success fees. In order to eliminate a number of costless\nattacks possible today on the routing network, nodes should also be able to\nsignal a new coefficient used to _scale_ the prepay fee as a function of the\nCLTV value of the incoming HTLC. With this addition, senders need to pay to\n_add_ an HTLC to a remote commitment transaction (fixed base cost), then\nalso need to pay a variable rate that scales with the duration of the\nproposed outgoing CLTV value (senders ofc don't prepay to themselves).  Once\nwe introduce this, loop attacks and the like are no longer free to launch,\nand nodes can dynamically respond to congestion in the network by raising\ntheir prepay prices.\n\n-- Laolu\n\nOn Mon, Nov 4, 2019 at 6:25 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Hi all,\n>\n>         It's been widely known that we're going to have to have up-front\n> payments for msgs eventually, to avoid Type 2 spam (I think of Type 1\n> link-local, Type 2 though multiple nodes, and Type 3 liquidity-using\n> spam).\n>\n>         Since both Offers and Joost's WhatSat are looking at sending\n> messages, it's time to float actual proposals.  I've been trying to come\n> up with something for several years now, so thought I'd present the best\n> I've got in the hope that others can improve on it.\n>\n> 1. New feature bit, extended messages, etc.\n> 2. Adding an HTLC causes a *push* of a number of msat on\n>    commitment_signed (new field), and a hash.\n> 3. Failing/succeeding an HTLC returns some of those msat, and a count\n>    and preimage (new fields).\n>\n> How many msat can you take for forwarding?  That depends on you\n> presenting a series of preimages (which chain into a final hash given in\n> the HTLC add), which you get by decoding the onion.  You get to keep 50\n> msat[1] per preimage you present[2].\n>\n> So, how many preimages does the user have to give to have you forward\n> the payment?  That depends.  The base rate is 16 preimages, but subtract\n> one for each leading 4 zero bits of the SHA256(blockhash | hmac) of the\n> onion.  The blockhash is the hash of the block specified in the onion:\n> reject if it's not in the last 3 blocks[3].\n>\n> This simply adds some payment noise, while allowing a hashcash style\n> tradeoff of sats for work.\n>\n> The final node gets some variable number of preimages, which adds noise.\n> It should take all and subtract from the minimum required invoice amount\n> on success, or take some random number on failure.\n>\n> This leaks some forward information, and makes an explicit tradeoff for\n> the sender between amount spent and privacy, but it's the best I've been\n> able to come up with.\n>\n> Thoughts?\n> Rusty.\n>\n> [1] If we assume $1 per GB, $10k per BTC and 64k messages, we get about\n>     655msat per message.  Flat pricing for simplicity; we're trying to\n>     prevent spam, not create a spam market.\n> [2] Actually, a number and a single preimage; you can check this is\n>     indeed the n'th preimage.\n> [3] This reduces incentive to grind the damn things in advance, though\n>     maybe that's dumb?  We can also use a shorter hash (siphash?), or\n>     even truncated SHA256 (128 bits).\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191105/b461390a/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-06T02:32:29",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n> Hi Rusty,\n>\n> Agreed w.r.t the need for prepaid HTLCS, I've been mulling over other\n> alternatives for a few years now, and none of them seems to resolve the\n> series of routing related incentive issues that prepaid HTLCs would.\n>\n>> Since both Offers and Joost's WhatSat are looking at sending messages,\n>> it's time to float actual proposals.\n>\n> IMO both should just be done over HORNET, so we don't need introduce a new\n> set of internal protocol level messages whenever we have some new\n> control/signalling need. Instead, we'd have a control/signal channel (give\n> me\n> routes, invoices, sign this, etc), and a payment channel (HTLCs as used\n> today).\n\nI'm not so sure, as I don't think we're going to actually use each one\nmore than once or twice?\n\nI mean, we could stream movies through LN, but I think that's an added\nservice, which would be best done by HORNET.\n\n>> 2. Adding an HTLC causes a *push* of a number of msat on commitment_signed\n>> (new field), and a hash.\n>\n> The prepay amount should be signalled in the update add message instead.\n> This lets HTLCs carry a heterogeneous set of prepay amounts. In addition, we\n> need a new onion field as well to signal the incoming amount the node\n> _should_ have received (allows them to detect deviations in the sender's\n> intended route).\n\nSorry, brain fart: it's a new field in the update_add_htlc of course.\n\nI just, um, added that to make sure you were all reading carefully! :_\n\n>> 3. Failing/succeeding an HTLC returns some of those msat, and a count and\n>> preimage (new fields).\n>\n> Failing shouldn't return the prepay amount, otherwise extending long lived\n> HTLCs then cancelling them at the last minute is still costless. This\n> costlessness of _adding_ an HTLC to a _remote_ commitment is IMO, the\n> biggest incentive flaw that exists today in the greater routing network.\n\nNo, that's type (liquidity) 3 spam, which needs a completely different\nsolution.\n\nDefinitely needs fixing, but up-front fees don't do it (except in the\ncase where you might want to indicate you're *going* to have a long-held\nHTLC, where you'd pay additional up-front, but that's future work).\n\n>>  You get to keep 50 msat[1] per preimage you present[2].\n>\n> We should avoid introducing any new constants to the protocol, as they're\n> typically dreamed up independent of any empirical lessons learned from\n> deployment.\n\nOTOH, we should avoid creating more complex knobs for users, since the\ncomplexity of the protocol is becoming unmanagable.  I think we did this\ntoo much with v1, so instead of getting empirical data we got defaults\nwhich in practice are unspecified specifications.\n\nI like a flat value to start, since it's easy to implement and deploy.\n\n> On the topic of the prepay cost, the channel update message should be\n> extended to allow nodes to signal prepay costs similar to the way we handle\n> regular payment success fees. In order to eliminate a number of costless\n> attacks possible today on the routing network, nodes should also be able to\n> signal a new coefficient used to _scale_ the prepay fee as a function of the\n> CLTV value of the incoming HTLC.\n\n... and HTLC amount, surely?  That becomes a pretty complex tuning\nparameter.\n\nI think we should directly target type 3 spam through a separate\nmechanism (as discussed previously).  This is just to prevent quantity\nof messages.\n\n> With this addition, senders need to pay to\n> _add_ an HTLC to a remote commitment transaction (fixed base cost), then\n> also need to pay a variable rate that scales with the duration of the\n> proposed outgoing CLTV value (senders ofc don't prepay to themselves).  Once\n> we introduce this, loop attacks and the like are no longer free to launch,\n> and nodes can dynamically respond to congestion in the network by raising\n> their prepay prices.\n\nI disagree; you should signal with normal fees, not prepay.  Otherwise\nwe're increasing fees at a time that success rates are lowering, which\nmakes the incentive misalightment far more promiment :(\n\nCheers,\nRusty."
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-06T15:53:57",
                "message_text_only": "In my opinion, the prepayment should be a last resort. It does take away\nsome of the attractiveness of the Lightning Network. Especially if you need\nto make many payment attempts over long routes, the tiny prepays do add up.\nFor a $10 payment, it's probably nothing to worry about. But for\nmicro-payments this can become prohibitively expensive. And it is exactly\nthe micro-payment use case where Lightning outshines other payment systems.\nA not yet imagined micro-payment based service could even be the launchpad\nto world domination. So I think we should be very careful with interfering\nwith that potential.\n\nIsn't spam something that can also be addressed by using rate limits for\nfailures? If all relevant nodes on the network employ rate limits, they can\nisolate the spammer and diminish their disruptive abilities. If a node sees\nthat its outgoing htlc packets stack up, it can reduce the incoming flow on\nthe channels where the htlcs originate from. Large routing nodes could\nagree with their peers on service levels that define these rate limits.\n\nJoost\n\nOn Tue, Nov 5, 2019 at 3:25 AM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Hi all,\n>\n>         It's been widely known that we're going to have to have up-front\n> payments for msgs eventually, to avoid Type 2 spam (I think of Type 1\n> link-local, Type 2 though multiple nodes, and Type 3 liquidity-using\n> spam).\n>\n>         Since both Offers and Joost's WhatSat are looking at sending\n> messages, it's time to float actual proposals.  I've been trying to come\n> up with something for several years now, so thought I'd present the best\n> I've got in the hope that others can improve on it.\n>\n> 1. New feature bit, extended messages, etc.\n> 2. Adding an HTLC causes a *push* of a number of msat on\n>    commitment_signed (new field), and a hash.\n> 3. Failing/succeeding an HTLC returns some of those msat, and a count\n>    and preimage (new fields).\n>\n> How many msat can you take for forwarding?  That depends on you\n> presenting a series of preimages (which chain into a final hash given in\n> the HTLC add), which you get by decoding the onion.  You get to keep 50\n> msat[1] per preimage you present[2].\n>\n> So, how many preimages does the user have to give to have you forward\n> the payment?  That depends.  The base rate is 16 preimages, but subtract\n> one for each leading 4 zero bits of the SHA256(blockhash | hmac) of the\n> onion.  The blockhash is the hash of the block specified in the onion:\n> reject if it's not in the last 3 blocks[3].\n>\n> This simply adds some payment noise, while allowing a hashcash style\n> tradeoff of sats for work.\n>\n> The final node gets some variable number of preimages, which adds noise.\n> It should take all and subtract from the minimum required invoice amount\n> on success, or take some random number on failure.\n>\n> This leaks some forward information, and makes an explicit tradeoff for\n> the sender between amount spent and privacy, but it's the best I've been\n> able to come up with.\n>\n> Thoughts?\n> Rusty.\n>\n> [1] If we assume $1 per GB, $10k per BTC and 64k messages, we get about\n>     655msat per message.  Flat pricing for simplicity; we're trying to\n>     prevent spam, not create a spam market.\n> [2] Actually, a number and a single preimage; you can check this is\n>     indeed the n'th preimage.\n> [3] This reduces incentive to grind the damn things in advance, though\n>     maybe that's dumb?  We can also use a shorter hash (siphash?), or\n>     even truncated SHA256 (128 bits).\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191106/5bbc081f/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-07T04:30:40",
                "message_text_only": "Joost Jager <joost.jager at gmail.com> writes:\n> In my opinion, the prepayment should be a last resort. It does take away\n> some of the attractiveness of the Lightning Network. Especially if you need\n> to make many payment attempts over long routes, the tiny prepays do add up.\n> For a $10 payment, it's probably nothing to worry about. But for\n> micro-payments this can become prohibitively expensive. And it is exactly\n> the micro-payment use case where Lightning outshines other payment systems.\n> A not yet imagined micro-payment based service could even be the launchpad\n> to world domination. So I think we should be very careful with interfering\n> with that potential.\n\nI completely agree, yeah.  And maybe we'll never need it, but it's one\nof my main concerns for the network.\n\n> Isn't spam something that can also be addressed by using rate limits for\n> failures? If all relevant nodes on the network employ rate limits, they can\n> isolate the spammer and diminish their disruptive abilities.\n\nSure, once the spammer has jammed up the network, he'll be stopped.  So\nwill everyone else.  Conner had a proposal like this which didn't work,\nIIRC.\n\n> If a node sees that its outgoing htlc packets stack up, it can reduce\n> the incoming flow on the channels where the htlcs originate\n> from. Large routing nodes could agree with their peers on service\n> levels that define these rate limits.\n\nUnfortunately, if we *don't* address this, then the network will defend\nitself with the simple tactic of deanonymizing payments.\n\nAnd every other solution I've seen ends up the same way :(\n\nCheers,\nRusty."
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-07T13:37:51",
                "message_text_only": ">\n> > Isn't spam something that can also be addressed by using rate limits for\n> > failures? If all relevant nodes on the network employ rate limits, they\n> can\n> > isolate the spammer and diminish their disruptive abilities.\n>\n> Sure, once the spammer has jammed up the network, he'll be stopped.  So\n> will everyone else.  Conner had a proposal like this which didn't work,\n> IIRC.\n>\n\nDo you have ref to this proposal?\n\nImagine the following setup: a network of nodes that trust each other (as\nfar as spam is concerned) applies a 100 htlc/sec rate limit to the channels\nbetween themselves. Channels to untrusted nodes get a rate of only 1\nhtlc/sec. Assuming the spammer isn't a trusted node, they can only spam at\n1 htlc/s and won't jam up the network?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191107/f34b9e63/attachment.html>"
            },
            {
                "author": "lisa neigut",
                "date": "2019-11-07T14:35:52",
                "message_text_only": "> Imagine the following setup: a network of nodes that trust each other\n\nThe goal of this pre-payment proposal is to remove the need for trusted\nparties.\n\nOn Thu, Nov 7, 2019 at 07:38 Joost Jager <joost.jager at gmail.com> wrote:\n\n> > Isn't spam something that can also be addressed by using rate limits for\n>> > failures? If all relevant nodes on the network employ rate limits, they\n>> can\n>> > isolate the spammer and diminish their disruptive abilities.\n>>\n>> Sure, once the spammer has jammed up the network, he'll be stopped.  So\n>> will everyone else.  Conner had a proposal like this which didn't work,\n>> IIRC.\n>>\n>\n> Do you have ref to this proposal?\n>\n> Imagine the following setup: a network of nodes that trust each other (as\n> far as spam is concerned) applies a 100 htlc/sec rate limit to the channels\n> between themselves. Channels to untrusted nodes get a rate of only 1\n> htlc/sec. Assuming the spammer isn't a trusted node, they can only spam at\n> 1 htlc/s and won't jam up the network?\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191107/70d3266f/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-07T14:43:44",
                "message_text_only": "On Thu, Nov 7, 2019 at 3:36 PM lisa neigut <niftynei at gmail.com> wrote:\n\n> > Imagine the following setup: a network of nodes that trust each other\n>\n> The goal of this pre-payment proposal is to remove the need for trusted\n> parties\n>\n\nTrust isn't the right word. It is a level of service that you provide to\nyour peers. If nodes are cognizant of the fact that the level of service\nthey receive goes down if they forward spam, they will be careful on the\nincoming side. Require peers to build up a reputation before increasing the\ninbound limits that apply to the channels with them.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191107/1c401a5e/attachment-0001.html>"
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-07T14:58:29",
                "message_text_only": "On 07/11/2019 16:43, Joost Jager wrote:\n> On Thu, Nov 7, 2019 at 3:36 PM lisa neigut <niftynei at gmail.com \n> <mailto:niftynei at gmail.com>> wrote:\n>\n>     > Imagine the following setup: a network of nodes that trust each\n>     other\n>\n>     The goal of this pre-payment proposal is to remove the need for\n>     trusted parties\n>\n>\n> Trust isn't the right word. It is a level of service that you provide \n> to your peers. If nodes are cognizant of the fact that the level of \n> service they receive goes down if they forward spam, they will be \n> careful on the incoming side. Require peers to build up a reputation \n> before increasing the inbound limits that apply to the channels with them.\nWe can learn from the current situation in emails, that a system based \non reputation tends to concentrate the power in the hands of few big and \nstrong actors (gmail and co). If we have from the beginning a mechanism \nto fight against spam by paying to send message, we can perhaps have a \nreally distributed system which cannot be censured."
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-08T14:15:05",
                "message_text_only": ">\n> >     The goal of this pre-payment proposal is to remove the need for\n> >     trusted parties\n> >\n> > Trust isn't the right word. It is a level of service that you provide\n> > to your peers. If nodes are cognizant of the fact that the level of\n> > service they receive goes down if they forward spam, they will be\n> > careful on the incoming side. Require peers to build up a reputation\n> > before increasing the inbound limits that apply to the channels with\n> them.\n\nWe can learn from the current situation in emails, that a system based\n> on reputation tends to concentrate the power in the hands of few big and\n> strong actors (gmail and co). If we have from the beginning a mechanism\n> to fight against spam by paying to send message, we can perhaps have a\n> really distributed system which cannot be censured.\n>\n\nCan you elaborate on this a bit further? If you consider rate limiting to\nbe a form of censoring, then you can still censor if there is a prepay.\n\nI am not too familiar with the current state of email servers, to what\nextent power is concentrated now and how that evolution translates to\nLightning. One difference is that afaik emails don't traverse a path\nthrough multiple mail \"nodes\". Another is that inboxes of users are very\ncentralized (gmail and co).\n\nWhat does that undesired situation exactly look like in the Lightning\nNetwork if nodes would enforce rate limits based on how they rate their\ndirect peers?\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191108/26a92d3e/attachment.html>"
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-09T19:47:30",
                "message_text_only": "An HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191109/5ceee7ab/attachment.html>"
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-09T20:36:30",
                "message_text_only": "[Sorry: re-sending again in plain text]\n\nOn 08/11/2019 16:15, Joost Jager wrote:\n>\n>     >\u00a0 \u00a0 \u00a0The goal of this pre-payment proposal is to remove the need for\n>     >\u00a0 \u00a0 \u00a0trusted parties\n>     >\n>     > Trust isn't the right word. It is a level of service that you\n>     provide\n>     > to your peers. If nodes are cognizant of the fact that the level of\n>     > service they receive goes down if they forward spam, they will be\n>     > careful on the incoming side. Require peers to build up a\n>     reputation\n>     > before increasing the inbound limits that apply to the channels\n>     with them.\u00a0\n>\n>     We can learn from the current situation in emails, that a system\n>     based\n>     on reputation tends to concentrate the power in the hands of few\n>     big and\n>     strong actors (gmail and co). If we have from the beginning a\n>     mechanism\n>     to fight against spam by paying to send message, we can perhaps\n>     have a\n>     really distributed system which cannot be censured.\n>\n>\n> Can you elaborate on this a bit further? If you consider rate limiting\n> to be a form of censoring, then you can still censor if there is a prepay.\nThere are situations when lot of people need to send each other lot of\nmessages in a small period of time, in protests for instance. In this\ncase, people are ready to pay a little to communicate. It's true that\nthey can be censored even when paying for messaging, but in this case,\nit's a voluntary (and politic) decision. But when using a rate limiting\nmechanism, it's an economic decision with politic implications.\n>\n> I am not too familiar with the current state of email servers, to what\n> extent power is concentrated now and how that evolution translates to\n> Lightning.\n\nCurrently, if you install a smtp server in you home computer or in a\nserver you rent and you try to send an email to someone with an email\nfrom any big provider, it will be marked as spam, because you need to\nhave a good \"reputation\". And if you try to send so called \"marketing\"\nemails, you'll be marked as spammer even if the same emails sent by big\nproviders are not rejected. This is the effect of using any reputation\nsystem. The path from reputation to propaganda is very short.\n\n> One difference is that afaik emails don't traverse a path through\n> multiple mail \"nodes\". Another is that inboxes of users are very\n> centralized (gmail and co).\n\nI can imagine a system where people who want to use the messaging system\nbased on Lightning will have to open a channel to big nodes in order to\nbe able to reach their recipient. In this case, those big nodes can\ncensor as they want because they have access to a lot of metadata."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-08T02:45:09",
                "message_text_only": "Joost Jager <joost.jager at gmail.com> writes:\n>>\n>> > Isn't spam something that can also be addressed by using rate limits for\n>> > failures? If all relevant nodes on the network employ rate limits, they\n>> can\n>> > isolate the spammer and diminish their disruptive abilities.\n>>\n>> Sure, once the spammer has jammed up the network, he'll be stopped.  So\n>> will everyone else.  Conner had a proposal like this which didn't work,\n>> IIRC.\n>\n> Do you have ref to this proposal?\n>\n> Imagine the following setup: a network of nodes that trust each other (as\n> far as spam is concerned) applies a 100 htlc/sec rate limit to the channels\n> between themselves. Channels to untrusted nodes get a rate of only 1\n> htlc/sec. Assuming the spammer isn't a trusted node, they can only spam at\n> 1 htlc/s and won't jam up the network?\n\nDamn, I searched for it but all the obvious keywords turned up blank.\nConner CC'd in case he remembers the discussion and I'm not imagining it?\n\nAnyway, if there are 100 nodes in the network I can still open a channel\nto each one and jam it up immediately.  And that's not even assuming I\nplay nice until you trust me, then attack or get taken over.\n\nCheers,\nRusty."
            },
            {
                "author": "Joost Jager",
                "date": "2019-11-08T14:45:08",
                "message_text_only": ">\n> >> > Isn't spam something that can also be addressed by using rate limits\n> for\n> >> > failures? If all relevant nodes on the network employ rate limits,\n> they\n> >> can\n> >> > isolate the spammer and diminish their disruptive abilities.\n> >>\n> >> Sure, once the spammer has jammed up the network, he'll be stopped.  So\n> >> will everyone else.  Conner had a proposal like this which didn't work,\n> >> IIRC.\n> >\n> > Do you have ref to this proposal?\n> >\n> > Imagine the following setup: a network of nodes that trust each other (as\n> > far as spam is concerned) applies a 100 htlc/sec rate limit to the\n> channels\n> > between themselves. Channels to untrusted nodes get a rate of only 1\n> > htlc/sec. Assuming the spammer isn't a trusted node, they can only spam\n> at\n> > 1 htlc/s and won't jam up the network?\n>\n> Damn, I searched for it but all the obvious keywords turned up blank.\n> Conner CC'd in case he remembers the discussion and I'm not imagining it?\n>\n> Anyway, if there are 100 nodes in the network I can still open a channel\n> to each one and jam it up immediately.  And that's not even assuming I\n> play nice until you trust me, then attack or get taken over.\n\n\nAt least it has gotten (100 times?) more difficult. I think it is hard to\nsay upfront how good or bad this setup would work. But I agree that prepay\ndeters spam in a more fundamental way.\n\nBesides the argument that I brought up earlier of potentially killing\nmicro-payment-based use cases with prepay, there is also another concern.\nIt is nothing new, but could be interesting to look at it in the light of\nprepayments.\n\nIt is currently possible to jam a channel with very limited resources. If\nyou hold 483 htlcs on a channel, it has become unusable for up to the cltv\nlimit. Let's say for 1000 blocks. If you allow a route that ping pongs back\nand forth on the channel (let's say 8 times back and forth), you only need\nto send 60 htlcs of the minimum amount for the route to jam the channel\ncompletely. With min htlc policies of 1 sat, that will lock up only 60 sats\nof the attacker (assuming no routing fees).\n\nLet's say the wumbo channel has a capacity of 1 btc. Locking up 1 btc for\n1000 blocks (~1 week) and assuming a time value of 4% per annum, the cost\nto the routing node is: 1 * (1.04 ^ (1/52)) - 1 = 75,000 sats.\n\nHow much prepay would you need to prevent this? I don't think the 50 msat\nwould cut it.\n\nI know this is the liquidity-using class of spam, but if prepay cannot\nprevent this I think it is better to first address this class. And once\nthere is solution for that, see whether the other classes of spam are still\npossible.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191108/70b303c9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "A proposal for up-front payments.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Pierre",
                "Bastien TEINTURIER",
                "lisa neigut",
                "Joost Jager",
                "Orfeas Stefanos Thyfronitis Litos",
                "Yaacov Akiba Slama",
                "Rusty Russell",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 34,
            "total_messages_chars_count": 102477
        }
    },
    {
        "title": "[Lightning-dev] [VERY ROUGH DRAFT] BOLT 12: Offers",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-11-05T04:23:24",
                "message_text_only": "Hi all,\n\n        This took longer than I'd indicated; for that I'm sorry.\nHowever, this should give us all something to chew on.  I've started\nwith a draft \"BOLT 12\" (it might be BOLT 13 by the time it's finalized\nthough!).\n\nI've also appended indications where we touch other BOLTs:\n1. BOLT 7 gains a message/reply system, encoded like htlc onions and\n   failure messages.\n2. BOLT 11 gains a `q` field for quantity; this avoids changing the\n   description when the user requests an invoice for more than one of something\n   (since changing the description between offer and invoice requires user\n   interaction: it's the *invoice* which you are committing to).\n\nThere's definite handwaving in here; let's see if you can find it!\n\nCheers,\nRusty.\n\n# BOLT #12: Offer Protocols for Lightning Payments\n\nAn higher-level, QR-code-ready protocol for dealing with invoices over\nLightning.  There are two simple flows supported: in one, a user gets\nan offer (`lno...`) and requests an invoice over the lightning\nnetwork, obtaining one (or an error) in reply.  In the other, a user\ngets an invoice request (`lni...`), and sends the invoice over the\nlightning network, retreiving an empty reply.\n\n# Table of Contents\n\n  * [Offers](#offers)\n    * [Encoding](#encoding)\n    * [TLV Fields](#tlv-fields)\n  * [Invrequests](#invrequests)\n    * [Encoding](#encoding)\n    * [TLV Fields](#tlv-fields)\n\n# Offers\n\nOffers supply a reader with enough information to request one or more\ninvoices via the lightning network itself.\n\n## Encoding\n\nThe human-readable part of a Lightning offer is `lno`.  The data part\nconsists of three parts:\n\n1. 0 or more [TLV](01-messaging.md#type-length-value-format) encoded fields.\n2. A 32-byte nodeid[1]\n3. 64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n\n## TLV Fields\n\nThe TLV fields define how to get the invoice, and what it's for.\nEach offer has a unique `offer_idenfitier` so the offering node can\ndistinguish different invoice requests.\n\nOffers can request recurring payments of various kinds, and specify\nwhat base currency they are calculated in (the actual amount will be\nin the invoice).\n\n`additional_data` is a bitfield which indicates what information the\ninvoice requester should (odd) or must (even) supply:\n1. Bits `0/1`: include `delivery_address`\n2. Bits `2/3`: include `delivery_telephone_number`\n3. Bits `4/5`: include `voucher_code`\n4. Bits `6/7`: include `refund_proof`\n\n`refund_for` indicates an offer for a (whole or part) refund for a\nprevious invoice, as indicated by the `payment_hash`.\n\n1. tlvs: `offer`\n2. types:\n    1. type: 1 (`paths`)\n    2. data:\n        * [`u16`:`num_paths`]\n        * [`num_paths*path`:`path`]\n    1. type: 2 (`description`)\n    2. data:\n        * [`...*byte`:`description`]\n    1. type: 3 (`expiry`)\n    2. data:\n        * [`tu64`:`seconds_from_epoch`]\n    1. type: 4 (`offer_identifier`)\n    2. data:\n        * [`...*byte`:`id`]\n    1. type: 5 (`amount`)\n    2. data:\n        * [`4*byte`:`currency`]\n        * [`tu64`:`amount`]\n    1. type: 6 (`additional_data`)\n    2. data:\n\t    * [`...*byte`:`rbits`]\n    1. type: 7 (`recurrance`)\n    2. data:\n\t    * [`byte`:`time_unit`]\n\t\t* [`u32`:`period`]\n\t\t* [`tu32`:`number`]\n    1. type: 8 (`recurrance_base`)\n    2. data:\n\t\t* [`u32`:`basetime`]\n\t\t* [`tu32`:`paywindow`]\n    1. type: 9 (`quantity`)\n    2. data:\n\t\t* [`tu64`:`max`]\n    1. type: 10 (`refund_for`)\n    2. data:\n        * [`32*byte`:`payment_hash`]\n\n1. subtype: `path`\n2. data:\n   * [`u16`:`num_hops`]\n   * [`num_hops*hop`:`hops`]\n\n1. subtype: `hop`\n2. data:\n   * [`pubkey`:`nodeid`]\n   * [`short_channel_id`:`short_channel_id`]\n   * [`u16`:`flen`]\n   * [`flen*byte`:`features`]\n\n## Requirements For Offers And Invrequests\n\nA writer of an offer or an invrequest:\n  - if it is connected only by private channels:\n    - MUST include `paths` containing a path to the node.\n  - otherwise:\n    - MAY include `paths` containing a path to the node.\n  - MUST describe the item(s) being offered or purpose of invoice in `description`.\n  - MUST include `expiry` if the offer/invrequest will not be valid after some time.\n  - if it includes `expiry`:\n    - MUST set `seconds_from_epoch` to the expiry time in seconds since 1970 UTC.\n\n## Requirements For Offers\n\nA writer of an offer:\n  - MUST use a unique `offer_idenfitier` for each offer.\n  - MAY include `recurrence` to indicate offer should trigger time-spaced\n    invoices.\n  - MUST include `amount` if it includes `recurrence`.\n  - if it includes `amount`:\n    - MUST specify `currency` as the ISO 4712 or BIP-0173, padded with zero bytes if required\n\t- MUST specify `amount` to the amount expected for the invoice, as the ISO 4712 currency unit multiplied by exponent, OR the BIP-0173 minimum unit (eg. `satoshis`).\n  - if it requires specific fields in the invoice:\n    - MUST set the corresponding even bits in the `additional_data` field\n\nA reader of an offer:\n  - SHOULD gain user consent for recurring payments.\n  - SHOULD allow user to view and cancel recurring payments.\n  - SHOULD gain user consent to send `delivery_` fields.\n  - if it uses `amount` to provide the user with a cost estimate:\n\t- MUST warn user if amount of actual invoice differs significantly\n\t\tfrom that expectation.\n  - FIXME: more!\n\n## Recurrance\n\nSome offers are *periodic*, such as a subscription service or monthly\ndues, in that payment is expected to be repeated.  There are many\ndifferent flavors of repetition, consider:\n\n* Payments due on the first of every month, for 6 months.\n* Payments due on every Monday, 1pm Pacific Standard Time.\n* Payments due once a year:\n   * which must be made on January 1st, or\n   * which are only valid if started January 1st 2020, or\n   * which if paid after January 1st you (over) pay the full rate first year, or\n   * which if paid after January 1st are paid pro-rata for the first year, or\n   * which repeat from whenever you made the first payment\n\nThus, each payment has:\n1. A `time_unit` defining 0 (seconds), 1 (days), 2 (months), 3 (years).\n2. A `period`, defining how often (in `time_unit`) it has to be paid.\n3. An optional `number` of total payments to be paid.\n4. An optional `basetime`, defining when the first payment applies\n   in seconds since 1970-01-01 UTC.\n5. An optional `paywindow`, defining how many seconds into the period\n   a payment will be accepted: 0xFFFFFFFF being a special value meaning\n   \"any time during the period, but you will have to pay proportionally\n   to the remaining time in the period\".\n\nNote that the `expiry` field covers the case where an offer is no longer\nvalid after January 1st 2020.\n\n## Default Offer\n\nThe \"default offer\" of a node is a nominal offer used to send\nunsolicited payments.  It is generally not actually sent, but can be\nused by any other node as if it has been.  It has the following\nfields:\n\n* `offer_idenfitier`: zero-length\n* `d`: any\n* `n`: the node id of the recipient.\n\n## Invoice Request Encoding\n\nOnce it has an offer, the node can request an actual invoice using the\n`invoice_req` message inside `directed`'s `onion_routing_packet`.  It\nwould expect an `invoice_or_error_tlv` inside the `directed_reply`\nmessage.\n\nThis includes a `tag` it can use to identify replies, the\n`offer_idenfitier` from the offer, a `key` it can use to prove it was\nthe requester of this invoice, a `recurrence` number if this\nis a payment in a recurring series, and other codes as required.\n\nThe `refund_proof` refers to a previous invoice paid by the sender for\nthe specific case of a `refund_for` offer.  It provides proof of\npayment (the `payment_preimage` and also a signature of the\n`payment_hash` from the `key` which requested the being-refunded\ninvoice (which does *not* have to be the same as this `key`!).\n\n1. tlvs: `invoice_request_tlv`\n2. types:\n   1. type: 1 (`tag`)\n   2. data:\n      * [`...*byte`:`tag`]\n   1. type: 2 (`offer_identifier`)\n   2. data:\n      * [`...*byte`:`id`]\n   1. type: 3 (`key`)\n   2. data:\n     * [`32`:`key`]\n   1. type: 4 (`recurrence`)\n   2. data:\n     * [`tu64`:`number`]\n   1. type: 5 (`quantity`)\n   2. data:\n     * [`tu64`:`n`]\n   1. type: 6 (`delivery_address_name`)\n   2. data:\n\t * [`...*byte`:`name`]\n   1. type: 7 (`delivery_address1`)\n   2. data:\n\t * [`...*byte`:`address1`]\n   1. type: 8 (`delivery_address2`)\n   2. data:\n\t * [`...*byte`:`address2`]\n   1. type: 9 (`delivery_city`)\n   2. data:\n\t * [`...*byte`:`city`]\n   1. type: 10 (`delivery_state_province_or_region`)\n   2. data:\n\t * [`...*byte`:`state_province_or_region`]\n   1. type: 11 (`delivery_zip_or_postal_code`)\n   2. data:\n\t * [`...*byte`:`zip_or_postal_code`]\n   1. type: 12 (`delivery_country`)\n   2. data:\n\t * [`2*byte`:`country_code`]\n   1. type: 13 (`delivery_telephone_number`)\n   2. data:\n\t * [`...*byte`:`tel`]\n   1. type: 14 (`voucher_code`)\n   2. data:\n\t * [`...*byte`:`code`]\n   1. type: 15 (`refund_proof`)\n   2. data:\n      * [`32*byte`:`payment_preimage`]\n      * [`signature`:`signature`]\n\n## Requirements\n\nFIXME: many more\nSender MUST use ISO 3166 alpha-2 code for `delivery_country`.\nSender MUST set offer_identifier to match offer.\nSender MUST include `key`\n   - SHOULD use a transient unpredictable key\n   - MUST reuse key for successive recurring invoices.\nSender MUST set `recurrence` for recurring invoices.\n\nReceiver MUST check `offer_identifier`\nReceiver MUST check `delivery_` fields.\nReceiver MUST check `recurrence`.\nReceiver MUST check `amount`.\n\n1. tlvs: `invoice_or_error_tlv`\n2. types:\n   1. type: 1 (`tag`)\n   2. data:\n     * [`...*byte`:`tag`]\n   1. type: 3 (`omitted`)\n   2. data:\n\t * [`...*u64`:`omitted_fields`]\n   1. type: 4 (`invoice`)\n   2. data:\n     * [`...*byte`:`invoice`]\n   1. type: 5 (`message`)\n     * [`...*byte`:`message`]\n   1. type: 6 (`replacement`)\n   2. data:\n     * [`signature`:`signature`]\n     * [`...*byte`:`offer`]\n\nSender:\n- MUST copy `tag` from sender.\n- MUST omit fields it does not use, and place number in order in `omitted_fields`.\n- if it includes `invoice`:\n  - MUST not include `message`\n  - MUST not include `replacement`\n  - MUST [merkle fields it used](#merkle-calculation) and place that in invoice `s` field.\n- otherwise, if it includes `replacement`:\n  - MAY include `message` \n- otherwise:\n  - MUST include `message` describing the error.\n\nReceiver:\n- MUST check that `tag` matches req.\n- if `replacement`:\n  - MUST fail if `signature` does not sign `offer` with same key as original.\n  - MUST only fetch once (no double-redirects!)\n- if description or amount significantly changes, must re-ask user.\n  - SHOULD note if description simply has something appended (eg \"+ postage\").\n- within invoice:\n    - MUST check that `s` matches merkle of fields, minus `omitted`.\n\t- MUST check that no vital fields are in `omitted`.\n\t- MUST check that `d` matches `description`\n    - MUST check that `q` DNE if `quantity` DNE, otherwise is equal.\n    - Must check valid signature, etc.\n\n## Merkle Calculation\n\n1. For each `invoice_req_tlv` field in ascending `tlv` type order:\n   1. If the field was omitted, it is added to `omitted_fields`.\n   2. Otherwise, the immediate parent merkle is:\n   \n      SHA256(SHA256(`tag` | `be64-n`) | SHA256(`tlv-value`))\n\n      Where `be64-n` is a 64-bit big-endian counter starting at 0 and\n      incrementing for each leaf.\n\n   3. Order these nodes in increasing SHA256(`tag` | `be64-n`) order.\n\n2. Create additional leaves until `be64-n` is the next power of 2:\n\n      SHA256(`tag` | `be64-n`)\n\n3. Combine adjacent leaves using SHA256(leaf1 | leaf2) until none remain.\n\nBy creating adjacent leaves using the `tag` field and a counter, and\nsorting the leaves, the only significant information revealed by a\nmerkle proof on a node is the depth of tree (which implies the total\nnumber of TLV fields).\n\n# InvRequests\n\nThere are times when it makes sense to request an invoice over another\nmedium, such as HTTP or a QR code.\n\n## Encoding\n\nThe human-readable part of a Lightning invrequest is `lni`.  The data part\nconsists of three parts:\n\n1. 0 or more [TLV](01-messaging.md#type-length-value-format) encoded fields.\n2. A 32-byte nodeid[1]\n3. 64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n\n## TLV Fields\n\n1. tlvs: `invreq`\n2. types:\n    1. type: 1 (`paths`)\n    2. data:\n        * [`u16`:`num_paths`]\n        * [`num_paths*path`:`path`]\n    1. type: 2 (`description`)\n    2. data:\n        * [`...*byte`:`description`]\n    1. type: 3 (`expiry`)\n    2. data:\n        * [`tu64`:`seconds_from_epoch`]\n    1. type: 4 (`amount`)\n    2. data:\n        * [`tu64`:`millisatoshis`]\n\nThe fields `paths`, `description`, and `expiry` fields are the\nsame as those for offers; the optional `amount` field describes the\namount an invoice will be accepted for.\n\nUpon parsing and accepting an `invreq`, the node sends an\n`invoice_or_error_tlv` within an onion.  The reply is empty.\n\n## Requirements\n\nThe requirements for `paths`, `description` and `expiry` are\n[described above](#requirements-for-offers-and-invrequests). \n\nFIXME: More.\n\n[1] Assuming we go for Schnorr sigs and 32-byte pubkeys.\n----\nAddendum: BOLT #7: P2P Node and Channel Discovery and Directed Messages\n...\n# Directed Messages\n\nDirected messages allow peers to use existing connections to query for\ninvoices (see [BOLT 12](12-offer-encoding.md)).  Like gossip messages,\nthey are not associated with a particular local channel.\n\nThe `id` is a unique, transient identifier between the peers, used to\nidentify match messages and replies.\n\n## The `directed` and `directed_reply` Messages\n\n1. type: 384 (`directed`) (`option_directed_messages`)\n2. data:\n    * [`chain_hash`:`chain_hash`]\n    * [`u64`:`id`]\n    * [`1366*byte`:`onion_routing_packet`]\n\n1. type: 384 (`directed_reply`) (`option_directed_messages`)\n2. data:\n    * [`chain_hash`:`chain_hash`]\n    * [`u64`:`id`]\n    * [`u16`:`len`]\n    * [`len*byte`:`reply`]\n\n## Requirements\n\nFIXME: similar to update_add_htlc and update_fail_htlc.\nFIXME: define reasonable timeout after which you can forget if not replied?"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-05T07:39:28",
                "message_text_only": "Good morning Rusty, and list,\n\nThank you Rusty.\nBelow is a quick and dirty review; I doubt I found whatever handwaves you are using.\n\nFirst, please confirm my understanding of the message flow.\nSuppose I have a donation offer on my website and Rusty wants to donate to me.\nThen:\n\n         ZmnSCPxj                      Rusty\n            |                            |\n            +---------- `lno` ---------->+ (via non-Lightning communication channel e.g. https)\n            |                            |\n            +<---- `invoice_request` ----+ (via a normal Rusty->ZmnSCPxj payment)\n            |                            |\n            +---- `invoice_or_error` --->| (by failing the above payment and embedding in the failure blob)\n            |                            |\n            +<------- `sendpay` ---------+ (via a normal Rusty->ZmnSCPxj payment)\n\nIs it approximately correct?\n\n>\n> BOLT #12: Offer Protocols for Lightning Payments\n>\n> =================================================\n>\n> An higher-level, QR-code-ready protocol for dealing with invoices over\n> Lightning. There are two simple flows supported: in one, a user gets\n> an offer (`lno...`) and requests an invoice over the lightning\n> network, obtaining one (or an error) in reply. In the other, a user\n> gets an invoice request (`lni...`), and sends the invoice over the\n> lightning network, retreiving an empty reply.\n\nHere are completely pointless counterproposals for the offer and invoice-request HRPs:\n\n* Offers:\n  * `lnpayme`\n  * `lnbuyit`\n  * `lnforsale`\n* Invoice Requests:\n  * `lnpaying`\n  * `lnbuying`\n  * `lnshutupandtakemymoney`\n\n`lno` and `lni` feel wrong to me.\nTheir juxtaposition implies `lno` == output and `lni` == input to me, due to the use of `o` and `i`, though `lno` is where you get money in exchange for product and `lni` is the request-for-service.\n\n>\n> Table of Contents\n>\n> ==================\n>\n> -   Offers\n>     -   Encoding\n>     -   TLV Fields\n> -   Invrequests\n>     -   Encoding\n>     -   TLV Fields\n\nDefinite handwave, does not match the structure of the document *at all*.\n\n> Encoding\n>\n> ---------\n>\n> The human-readable part of a Lightning offer is`lno`. The data part\n> consists of three parts:\n>\n> 1.  0 or more TLV encoded fields.\n> 2.  A 32-byte nodeid[1]\n> 3.  64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n>\n> TLV Fields\n>\n> -----------\n>\n> The TLV fields define how to get the invoice, and what it's for.\n> Each offer has a unique `offer_idenfitier` so the offering node can\n> distinguish different invoice requests.\n>\n> Offers can request recurring payments of various kinds, and specify\n> what base currency they are calculated in (the actual amount will be\n> in the invoice).\n>\n> `additional_data` is a bitfield which indicates what information the\n> invoice requester should (odd) or must (even) supply:\n>\n> 1.  Bits `0/1`: include `delivery_address`\n> 2.  Bits `2/3`: include `delivery_telephone_number`\n> 3.  Bits `4/5`: include `voucher_code`\n> 4.  Bits `6/7`: include `refund_proof`\n>\n>     `refund_for` indicates an offer for a (whole or part) refund for a\n>     previous invoice, as indicated by the `payment_hash`.\n>\n> 5.  tlvs: `offer`\n> 6.  types:\n>     1.  type: 1 (`paths`)\n>     2.  data:\n>         -   [`u16`:`num_paths`]\n>         -   [`num_paths*path`:`path`]\n>     3.  type: 2 (`description`)\n>     4.  data:\n>         -   [`...*byte`:`description`]\n\nUTF-8?\nNull-terminated?\n\n>     5.  type: 3 (`expiry`)\n>     6.  data:\n>         -   [`tu64`:`seconds_from_epoch`]\n>     7.  type: 4 (`offer_identifier`)\n>     8.  data:\n>         -   [`...*byte`:`id`]\n>     9.  type: 5 (`amount`)\n>     10.  data:\n>         -   [`4*byte`:`currency`]\n>         -   [`tu64`:`amount`]\n>     11.  type: 6 (`additional_data`)\n>     12.  data:\n>         -   [`...*byte`:`rbits`]\n>     13.  type: 7 (`recurrance`)\n>     14.  data:\n>         -   [`byte`:`time_unit`]\n>         -   [`u32`:`period`]\n>         -   [`tu32`:`number`]\n>     15.  type: 8 (`recurrance_base`)\n>     16.  data:\n>         -   [`u32`:`basetime`]\n>         -   [`tu32`:`paywindow`]\n>     17.  type: 9 (`quantity`)\n>     18.  data:\n>         -   [`tu64`:`max`]\n>     19.  type: 10 (`refund_for`)\n>     20.  data:\n>         -   [`32*byte`:`payment_hash`]\n> 7.  subtype: `path`\n> 8.  data:\n>     -   [`u16`:`num_hops`]\n>     -   [`num_hops*hop`:`hops`]\n> 9.  subtype: `hop`\n> 10.  data:\n>     -   [`pubkey`:`nodeid`]\n>     -   [`short_channel_id`:`short_channel_id`]\n>     -   [`u16`:`flen`]\n>     -   [`flen*byte`:`features`]\n>\n> Requirements For Offers And Invrequests\n>\n> ----------------------------------------\n>\n> A writer of an offer or an invrequest:\n>\n> -   if it is connected only by private channels:\n>     -   MUST include `paths` containing a path to the node.\n> -   otherwise:\n>     -   MAY include `paths` containing a path to the node.\n> -   MUST describe the item(s) being offered or purpose of invoice in `description`.\n> -   MUST include `expiry` if the offer/invrequest will not be valid after some time.\n> -   if it includes `expiry`:\n>     -   MUST set `seconds_from_epoch` to the expiry time in seconds since 1970 UTC.\n>\n> Requirements For Offers\n>\n> ------------------------\n>\n> A writer of an offer:\n>\n> -   MUST use a unique `offer_idenfitier` for each offer.\n> -   MAY include `recurrence` to indicate offer should trigger time-spaced\n>     invoices.\n>\n> -   MUST include `amount` if it includes `recurrence`.\n> -   if it includes `amount`:\n>     -   MUST specify `currency` as the ISO 4712 or BIP-0173, padded with zero bytes if required\n\nI cannot find ISO 4712, but could find ISO 4217.\nBIP-173 does not have a list of currencies, but refers to SLIP-0173.\nSome of the listed currencies there seem to have more than 4 characters.\n\nShould I assume encoding is ASCII?\nWe will \"never\" see a non-ASCII currency code?\n\n>     -   MUST specify `amount` to the amount expected for the invoice, as the ISO 4712 currency unit multiplied by exponent, OR the BIP-0173 minimum unit (eg. `satoshis`).\n> -   if it requires specific fields in the invoice:\n>     -   MUST set the corresponding even bits in the `additional_data` field\n>\n>         A reader of an offer:\n>\n> -   SHOULD gain user consent for recurring payments.\n> -   SHOULD allow user to view and cancel recurring payments.\n> -   SHOULD gain user consent to send `delivery_` fields.\n> -   if it uses `amount` to provide the user with a cost estimate:\n>     -   MUST warn user if amount of actual invoice differs significantly\n>         from that expectation.\n>\n> -   FIXME: more!\n>\n> Recurrance\n>\n> -----------\n>\n> Some offers areperiodic, such as a subscription service or monthly\n> dues, in that payment is expected to be repeated. There are many\n> different flavors of repetition, consider:\n>\n> -   Payments due on the first of every month, for 6 months.\n> -   Payments due on every Monday, 1pm Pacific Standard Time.\n> -   Payments due once a year:\n>     -   which must be made on January 1st, or\n>     -   which are only valid if started January 1st 2020, or\n>     -   which if paid after January 1st you (over) pay the full rate first year, or\n>     -   which if paid after January 1st are paid pro-rata for the first year, or\n>     -   which repeat from whenever you made the first payment\n>\n>         Thus, each payment has:\n>\n>\n> 1.  A `time_unit` defining 0 (seconds), 1 (days), 2 (months), 3 (years).\n> 2.  A `period`, defining how often (in `time_unit`) it has to be paid.\n> 3.  An optional `number` of total payments to be paid.\n> 4.  An optional `basetime`, defining when the first payment applies\n>     in seconds since 1970-01-01 UTC.\n>\n> 5.  An optional `paywindow`, defining how many seconds into the period\n>     a payment will be accepted: 0xFFFFFFFF being a special value meaning\n>     \"any time during the period, but you will have to pay proportionally\n>     to the remaining time in the period\".\n>\n>     Note that the `expiry` field covers the case where an offer is no longer\n>     valid after January 1st 2020.\n>\n>\n> Default Offer\n>\n> --------------\n>\n> The \"default offer\" of a node is a nominal offer used to send\n> unsolicited payments. It is generally not actually sent, but can be\n> used by any other node as if it has been. It has the following\n> fields:\n>\n> -   `offer_idenfitier`: zero-length\n> -   `d`: any\n> -   `n`: the node id of the recipient.\n\nIn essence, this is an implicitly-existing offer that never expires, and which can be used by any node at any time to construct an invoice request?\n\n>\n> Invoice Request Encoding\n>\n> -------------------------\n>\n> Once it has an offer, the node can request an actual invoice using the\n> `invoice_req` message inside `directed`'s `onion_routing_packet`. It\n> would expect an `invoice_or_error_tlv` inside the `directed_reply`\n> message.\n>\n> This includes a `tag` it can use to identify replies, the\n> `offer_idenfitier` from the offer, a `key` it can use to prove it was\n> the requester of this invoice, a `recurrence` number if this\n> is a payment in a recurring series, and other codes as required.\n>\n> The `refund_proof` refers to a previous invoice paid by the sender for\n> the specific case of a `refund_for` offer. It provides proof of\n> payment (the `payment_preimage` and also a signature of the\n> `payment_hash` from the `key` which requested the being-refunded\n> invoice (which does not have to be the same as this `key`!).\n\nAn earlier requirement mentions that writers of offers or invoice request MUST have `paths` in some condition.\nThe below does not have `paths`, but there is a \"human-readable\" alternate encoding which *does* have `paths`.\nIt might be better to clarify this point.\n\n>\n> 1.  tlvs: `invoice_request_tlv`\n> 2.  types:\n>\n>     1.  type: 1 (`tag`)\n>     2.  data:\n>         -   [`...*byte`:`tag`]\n>     3.  type: 2 (`offer_identifier`)\n>     4.  data:\n>         -   [`...*byte`:`id`]\n>     5.  type: 3 (`key`)\n>     6.  data:\n>\n>     -   [`32`:`key`]\n>\n>     1.  type: 4 (`recurrence`)\n>     2.  data:\n>\n>     -   [`tu64`:`number`]\n>\n>     1.  type: 5 (`quantity`)\n>     2.  data:\n>\n>     -   [`tu64`:`n`]\n>\n>     1.  type: 6 (`delivery_address_name`)\n>     2.  data:\n>\n>     -   [`...*byte`:`name`]\n>\n>     1.  type: 7 (`delivery_address1`)\n>     2.  data:\n>\n>     -   [`...*byte`:`address1`]\n>\n>     1.  type: 8 (`delivery_address2`)\n>     2.  data:\n>\n>     -   [`...*byte`:`address2`]\n>\n>     1.  type: 9 (`delivery_city`)\n>     2.  data:\n>\n>     -   [`...*byte`:`city`]\n>\n>     1.  type: 10 (`delivery_state_province_or_region`)\n>     2.  data:\n>\n>     -   [`...*byte`:`state_province_or_region`]\n>\n>     1.  type: 11 (`delivery_zip_or_postal_code`)\n>     2.  data:\n>\n>     -   [`...*byte`:`zip_or_postal_code`]\n>\n>     1.  type: 12 (`delivery_country`)\n>     2.  data:\n>\n>     -   [`2*byte`:`country_code`]\n>\n>     1.  type: 13 (`delivery_telephone_number`)\n>     2.  data:\n>\n>     -   [`...*byte`:`tel`]\n>\n>     1.  type: 14 (`voucher_code`)\n>     2.  data:\n>\n>     -   [`...*byte`:`code`]\n>\n>     1.  type: 15 (`refund_proof`)\n>     2.  data:\n>         -   [`32*byte`:`payment_preimage`]\n>         -   [`signature`:`signature`]\n>\n> Requirements\n>\n> -------------\n>\n> FIXME: many more\n> Sender MUST use ISO 3166 alpha-2 code for `delivery_country`.\n\nWhat happens when my army of non-shiny robots rise from their crypts and start annexing entire countries to enforce global peace, prosperity, and greater world optimization?\nI suppose it would become immaterial then...\n\n>\n> Directed Messages\n>\n> ==================\n>\n> Directed messages allow peers to use existing connections to query for\n> invoices (see BOLT 12). Like gossip messages,\n> they are not associated with a particular local channel.\n>\n> The `id` is a unique, transient identifier between the peers, used to\n> identify match messages and replies.\n>\n> The `directed` and `directed_reply` Messages\n>\n> ---------------------------------------------\n>\n> 1.  type: 384 (`directed`) (`option_directed_messages`)\n> 2.  data:\n>     -   [`chain_hash`:`chain_hash`]\n>     -   [`u64`:`id`]\n>     -   [`1366*byte`:`onion_routing_packet`]\n> 3.  type: 384 (`directed_reply`) (`option_directed_messages`)\n> 4.  data:\n>     -   [`chain_hash`:`chain_hash`]\n>     -   [`u64`:`id`]\n>     -   [`u16`:`len`]\n>     -   [`len*byte`:`reply`]\n\nThis new `directed` message will be the mechanism for sending invoice requests and receiving invoice request responses?\nWhat incentive is there for a forwarding node to actually forward a `directed` message?\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-08T02:55:17",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> First, please confirm my understanding of the message flow.\n> Suppose I have a donation offer on my website and Rusty wants to donate to me.\n> Then:\n>\n>          ZmnSCPxj                      Rusty\n>             |                            |\n>             +---------- `lno` ---------->+ (via non-Lightning communication channel e.g. https)\n>             |                            |\n>             +<---- `invoice_request` ----+ (via a normal Rusty->ZmnSCPxj payment)\n>             |                            |\n>             +---- `invoice_or_error` --->| (by failing the above payment and embedding in the failure blob)\n>             |                            |\n>             +<------- `sendpay` ---------+ (via a normal Rusty->ZmnSCPxj payment)\n>\n> Is it approximately correct?\n\nSorry for delayed response; yes, this is correct.\n\n>> gets an invoice request (`lni...`), and sends the invoice over the\n>> lightning network, retreiving an empty reply.\n>\n> Here are completely pointless counterproposals for the offer and invoice-request HRPs:\n>\n> * Offers:\n>   * `lnpayme`\n>   * `lnbuyit`\n>   * `lnforsale`\n> * Invoice Requests:\n>   * `lnpaying`\n>   * `lnbuying`\n>   * `lnshutupandtakemymoney`\n>\n> `lno` and `lni` feel wrong to me.\n> Their juxtaposition implies `lno` == output and `lni` == input to me, due to the use of `o` and `i`, though `lno` is where you get money in exchange for product and `lni` is the request-for-service.\n\nlnx and lny?  Nobody can interpret them at all, that way :)\n>>     3.  type: 2 (`description`)\n>>     4.  data:\n>>         -   [`...*byte`:`description`]\n>\n> UTF-8?\n> Null-terminated?\n\nI was thinking UTF-8 like current field.\n\n>> -   MUST include `amount` if it includes `recurrence`.\n>> -   if it includes `amount`:\n>>     -   MUST specify `currency` as the ISO 4712 or BIP-0173, padded with zero bytes if required\n>\n> I cannot find ISO 4712, but could find ISO 4217.\n\nOops, I fixed my typo wrong.  Thanks.\n\n> BIP-173 does not have a list of currencies, but refers to SLIP-0173.\n> Some of the listed currencies there seem to have more than 4 characters.\n\nOh, I'd never seen SLIP-0173.  Cool, I increased it to 5; SLIP-0173 has\nno limit but I find it hard to care about any of them anyway.\n\n> Should I assume encoding is ASCII?\n> We will \"never\" see a non-ASCII currency code?\n\nNot really, but if you don't understand it you can't do much, ASCII or\nno.\n\n>> The \"default offer\" of a node is a nominal offer used to send\n>> unsolicited payments. It is generally not actually sent, but can be\n>> used by any other node as if it has been. It has the following\n>> fields:\n>>\n>> -   `offer_idenfitier`: zero-length\n>> -   `d`: any\n>> -   `n`: the node id of the recipient.\n>\n> In essence, this is an implicitly-existing offer that never expires, and which can be used by any node at any time to construct an invoice request?\n\nYep!\n\n>> The `refund_proof` refers to a previous invoice paid by the sender for\n>> the specific case of a `refund_for` offer. It provides proof of\n>> payment (the `payment_preimage` and also a signature of the\n>> `payment_hash` from the `key` which requested the being-refunded\n>> invoice (which does not have to be the same as this `key`!).\n>\n> An earlier requirement mentions that writers of offers or invoice request MUST have `paths` in some condition.\n> The below does not have `paths`, but there is a \"human-readable\" alternate encoding which *does* have `paths`.\n> It might be better to clarify this point.\n\nThe in-wire one doesn't have paths, since you respond by reply; you\ndon't need (and should not be able to) find the sender.\n\nThe non-wire one needs a path, since you need to initiate a reply.\n\n>> The `directed` and `directed_reply` Messages\n>>\n>> ---------------------------------------------\n>>\n>> 1.  type: 384 (`directed`) (`option_directed_messages`)\n>> 2.  data:\n>>     -   [`chain_hash`:`chain_hash`]\n>>     -   [`u64`:`id`]\n>>     -   [`1366*byte`:`onion_routing_packet`]\n>> 3.  type: 384 (`directed_reply`) (`option_directed_messages`)\n>> 4.  data:\n>>     -   [`chain_hash`:`chain_hash`]\n>>     -   [`u64`:`id`]\n>>     -   [`u16`:`len`]\n>>     -   [`len*byte`:`reply`]\n>\n> This new `directed` message will be the mechanism for sending invoice requests and receiving invoice request responses?\n\nYes.\n\n> What incentive is there for a forwarding node to actually forward a `directed` message?\n\nIt's a strong liveness indicator to the sender, so they're likely to use\nthe same path for the actual payment.\n\nCheers,\nRusty."
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-05T08:49:54",
                "message_text_only": "Hi Rusty,\n\nIt seems that there are two kind of TLV fields in your proposition:\n1) LN specific fields like `num_paths` and `payment_preimage`.\n2) \"Business\" fields like `address1` and `currency`.\nI understand the need to define and include the first category, but I \ndon't think that we need or can define the second category. These fields \nalready exists in software like crm, erp, etc.. and are well defined by \nstandard body.\nMy suggestion is to have a generic field containing well defined \nstructured and standardized data. See for instance \nhttps://en.wikipedia.org/wiki/EDIFACT and/or \nhttps://en.wikipedia.org/wiki/Universal_Business_Language.\nWhat do you think?\nPS: Sorry for crossposting here and in \nhttps://github.com/lightningnetwork/lightning-rfc/pull/694\n--yas\n\nOn 05/11/2019 06:23, Rusty Russell wrote:\n> Hi all,\n>\n>          This took longer than I'd indicated; for that I'm sorry.\n> However, this should give us all something to chew on.  I've started\n> with a draft \"BOLT 12\" (it might be BOLT 13 by the time it's finalized\n> though!).\n>\n> I've also appended indications where we touch other BOLTs:\n> 1. BOLT 7 gains a message/reply system, encoded like htlc onions and\n>     failure messages.\n> 2. BOLT 11 gains a `q` field for quantity; this avoids changing the\n>     description when the user requests an invoice for more than one of something\n>     (since changing the description between offer and invoice requires user\n>     interaction: it's the *invoice* which you are committing to).\n>\n> There's definite handwaving in here; let's see if you can find it!\n>\n> Cheers,\n> Rusty.\n>\n> # BOLT #12: Offer Protocols for Lightning Payments\n>\n> An higher-level, QR-code-ready protocol for dealing with invoices over\n> Lightning.  There are two simple flows supported: in one, a user gets\n> an offer (`lno...`) and requests an invoice over the lightning\n> network, obtaining one (or an error) in reply.  In the other, a user\n> gets an invoice request (`lni...`), and sends the invoice over the\n> lightning network, retreiving an empty reply.\n>\n> # Table of Contents\n>\n>    * [Offers](#offers)\n>      * [Encoding](#encoding)\n>      * [TLV Fields](#tlv-fields)\n>    * [Invrequests](#invrequests)\n>      * [Encoding](#encoding)\n>      * [TLV Fields](#tlv-fields)\n>\n> # Offers\n>\n> Offers supply a reader with enough information to request one or more\n> invoices via the lightning network itself.\n>\n> ## Encoding\n>\n> The human-readable part of a Lightning offer is `lno`.  The data part\n> consists of three parts:\n>\n> 1. 0 or more [TLV](01-messaging.md#type-length-value-format) encoded fields.\n> 2. A 32-byte nodeid[1]\n> 3. 64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n>\n> ## TLV Fields\n>\n> The TLV fields define how to get the invoice, and what it's for.\n> Each offer has a unique `offer_idenfitier` so the offering node can\n> distinguish different invoice requests.\n>\n> Offers can request recurring payments of various kinds, and specify\n> what base currency they are calculated in (the actual amount will be\n> in the invoice).\n>\n> `additional_data` is a bitfield which indicates what information the\n> invoice requester should (odd) or must (even) supply:\n> 1. Bits `0/1`: include `delivery_address`\n> 2. Bits `2/3`: include `delivery_telephone_number`\n> 3. Bits `4/5`: include `voucher_code`\n> 4. Bits `6/7`: include `refund_proof`\n>\n> `refund_for` indicates an offer for a (whole or part) refund for a\n> previous invoice, as indicated by the `payment_hash`.\n>\n> 1. tlvs: `offer`\n> 2. types:\n>      1. type: 1 (`paths`)\n>      2. data:\n>          * [`u16`:`num_paths`]\n>          * [`num_paths*path`:`path`]\n>      1. type: 2 (`description`)\n>      2. data:\n>          * [`...*byte`:`description`]\n>      1. type: 3 (`expiry`)\n>      2. data:\n>          * [`tu64`:`seconds_from_epoch`]\n>      1. type: 4 (`offer_identifier`)\n>      2. data:\n>          * [`...*byte`:`id`]\n>      1. type: 5 (`amount`)\n>      2. data:\n>          * [`4*byte`:`currency`]\n>          * [`tu64`:`amount`]\n>      1. type: 6 (`additional_data`)\n>      2. data:\n> \t    * [`...*byte`:`rbits`]\n>      1. type: 7 (`recurrance`)\n>      2. data:\n> \t    * [`byte`:`time_unit`]\n> \t\t* [`u32`:`period`]\n> \t\t* [`tu32`:`number`]\n>      1. type: 8 (`recurrance_base`)\n>      2. data:\n> \t\t* [`u32`:`basetime`]\n> \t\t* [`tu32`:`paywindow`]\n>      1. type: 9 (`quantity`)\n>      2. data:\n> \t\t* [`tu64`:`max`]\n>      1. type: 10 (`refund_for`)\n>      2. data:\n>          * [`32*byte`:`payment_hash`]\n>\n> 1. subtype: `path`\n> 2. data:\n>     * [`u16`:`num_hops`]\n>     * [`num_hops*hop`:`hops`]\n>\n> 1. subtype: `hop`\n> 2. data:\n>     * [`pubkey`:`nodeid`]\n>     * [`short_channel_id`:`short_channel_id`]\n>     * [`u16`:`flen`]\n>     * [`flen*byte`:`features`]\n>\n> ## Requirements For Offers And Invrequests\n>\n> A writer of an offer or an invrequest:\n>    - if it is connected only by private channels:\n>      - MUST include `paths` containing a path to the node.\n>    - otherwise:\n>      - MAY include `paths` containing a path to the node.\n>    - MUST describe the item(s) being offered or purpose of invoice in `description`.\n>    - MUST include `expiry` if the offer/invrequest will not be valid after some time.\n>    - if it includes `expiry`:\n>      - MUST set `seconds_from_epoch` to the expiry time in seconds since 1970 UTC.\n>\n> ## Requirements For Offers\n>\n> A writer of an offer:\n>    - MUST use a unique `offer_idenfitier` for each offer.\n>    - MAY include `recurrence` to indicate offer should trigger time-spaced\n>      invoices.\n>    - MUST include `amount` if it includes `recurrence`.\n>    - if it includes `amount`:\n>      - MUST specify `currency` as the ISO 4712 or BIP-0173, padded with zero bytes if required\n> \t- MUST specify `amount` to the amount expected for the invoice, as the ISO 4712 currency unit multiplied by exponent, OR the BIP-0173 minimum unit (eg. `satoshis`).\n>    - if it requires specific fields in the invoice:\n>      - MUST set the corresponding even bits in the `additional_data` field\n>\n> A reader of an offer:\n>    - SHOULD gain user consent for recurring payments.\n>    - SHOULD allow user to view and cancel recurring payments.\n>    - SHOULD gain user consent to send `delivery_` fields.\n>    - if it uses `amount` to provide the user with a cost estimate:\n> \t- MUST warn user if amount of actual invoice differs significantly\n> \t\tfrom that expectation.\n>    - FIXME: more!\n>\n> ## Recurrance\n>\n> Some offers are *periodic*, such as a subscription service or monthly\n> dues, in that payment is expected to be repeated.  There are many\n> different flavors of repetition, consider:\n>\n> * Payments due on the first of every month, for 6 months.\n> * Payments due on every Monday, 1pm Pacific Standard Time.\n> * Payments due once a year:\n>     * which must be made on January 1st, or\n>     * which are only valid if started January 1st 2020, or\n>     * which if paid after January 1st you (over) pay the full rate first year, or\n>     * which if paid after January 1st are paid pro-rata for the first year, or\n>     * which repeat from whenever you made the first payment\n>\n> Thus, each payment has:\n> 1. A `time_unit` defining 0 (seconds), 1 (days), 2 (months), 3 (years).\n> 2. A `period`, defining how often (in `time_unit`) it has to be paid.\n> 3. An optional `number` of total payments to be paid.\n> 4. An optional `basetime`, defining when the first payment applies\n>     in seconds since 1970-01-01 UTC.\n> 5. An optional `paywindow`, defining how many seconds into the period\n>     a payment will be accepted: 0xFFFFFFFF being a special value meaning\n>     \"any time during the period, but you will have to pay proportionally\n>     to the remaining time in the period\".\n>\n> Note that the `expiry` field covers the case where an offer is no longer\n> valid after January 1st 2020.\n>\n> ## Default Offer\n>\n> The \"default offer\" of a node is a nominal offer used to send\n> unsolicited payments.  It is generally not actually sent, but can be\n> used by any other node as if it has been.  It has the following\n> fields:\n>\n> * `offer_idenfitier`: zero-length\n> * `d`: any\n> * `n`: the node id of the recipient.\n>\n> ## Invoice Request Encoding\n>\n> Once it has an offer, the node can request an actual invoice using the\n> `invoice_req` message inside `directed`'s `onion_routing_packet`.  It\n> would expect an `invoice_or_error_tlv` inside the `directed_reply`\n> message.\n>\n> This includes a `tag` it can use to identify replies, the\n> `offer_idenfitier` from the offer, a `key` it can use to prove it was\n> the requester of this invoice, a `recurrence` number if this\n> is a payment in a recurring series, and other codes as required.\n>\n> The `refund_proof` refers to a previous invoice paid by the sender for\n> the specific case of a `refund_for` offer.  It provides proof of\n> payment (the `payment_preimage` and also a signature of the\n> `payment_hash` from the `key` which requested the being-refunded\n> invoice (which does *not* have to be the same as this `key`!).\n>\n> 1. tlvs: `invoice_request_tlv`\n> 2. types:\n>     1. type: 1 (`tag`)\n>     2. data:\n>        * [`...*byte`:`tag`]\n>     1. type: 2 (`offer_identifier`)\n>     2. data:\n>        * [`...*byte`:`id`]\n>     1. type: 3 (`key`)\n>     2. data:\n>       * [`32`:`key`]\n>     1. type: 4 (`recurrence`)\n>     2. data:\n>       * [`tu64`:`number`]\n>     1. type: 5 (`quantity`)\n>     2. data:\n>       * [`tu64`:`n`]\n>     1. type: 6 (`delivery_address_name`)\n>     2. data:\n> \t * [`...*byte`:`name`]\n>     1. type: 7 (`delivery_address1`)\n>     2. data:\n> \t * [`...*byte`:`address1`]\n>     1. type: 8 (`delivery_address2`)\n>     2. data:\n> \t * [`...*byte`:`address2`]\n>     1. type: 9 (`delivery_city`)\n>     2. data:\n> \t * [`...*byte`:`city`]\n>     1. type: 10 (`delivery_state_province_or_region`)\n>     2. data:\n> \t * [`...*byte`:`state_province_or_region`]\n>     1. type: 11 (`delivery_zip_or_postal_code`)\n>     2. data:\n> \t * [`...*byte`:`zip_or_postal_code`]\n>     1. type: 12 (`delivery_country`)\n>     2. data:\n> \t * [`2*byte`:`country_code`]\n>     1. type: 13 (`delivery_telephone_number`)\n>     2. data:\n> \t * [`...*byte`:`tel`]\n>     1. type: 14 (`voucher_code`)\n>     2. data:\n> \t * [`...*byte`:`code`]\n>     1. type: 15 (`refund_proof`)\n>     2. data:\n>        * [`32*byte`:`payment_preimage`]\n>        * [`signature`:`signature`]\n>\n> ## Requirements\n>\n> FIXME: many more\n> Sender MUST use ISO 3166 alpha-2 code for `delivery_country`.\n> Sender MUST set offer_identifier to match offer.\n> Sender MUST include `key`\n>     - SHOULD use a transient unpredictable key\n>     - MUST reuse key for successive recurring invoices.\n> Sender MUST set `recurrence` for recurring invoices.\n>\n> Receiver MUST check `offer_identifier`\n> Receiver MUST check `delivery_` fields.\n> Receiver MUST check `recurrence`.\n> Receiver MUST check `amount`.\n>\n> 1. tlvs: `invoice_or_error_tlv`\n> 2. types:\n>     1. type: 1 (`tag`)\n>     2. data:\n>       * [`...*byte`:`tag`]\n>     1. type: 3 (`omitted`)\n>     2. data:\n> \t * [`...*u64`:`omitted_fields`]\n>     1. type: 4 (`invoice`)\n>     2. data:\n>       * [`...*byte`:`invoice`]\n>     1. type: 5 (`message`)\n>       * [`...*byte`:`message`]\n>     1. type: 6 (`replacement`)\n>     2. data:\n>       * [`signature`:`signature`]\n>       * [`...*byte`:`offer`]\n>\n> Sender:\n> - MUST copy `tag` from sender.\n> - MUST omit fields it does not use, and place number in order in `omitted_fields`.\n> - if it includes `invoice`:\n>    - MUST not include `message`\n>    - MUST not include `replacement`\n>    - MUST [merkle fields it used](#merkle-calculation) and place that in invoice `s` field.\n> - otherwise, if it includes `replacement`:\n>    - MAY include `message`\n> - otherwise:\n>    - MUST include `message` describing the error.\n>\n> Receiver:\n> - MUST check that `tag` matches req.\n> - if `replacement`:\n>    - MUST fail if `signature` does not sign `offer` with same key as original.\n>    - MUST only fetch once (no double-redirects!)\n> - if description or amount significantly changes, must re-ask user.\n>    - SHOULD note if description simply has something appended (eg \"+ postage\").\n> - within invoice:\n>      - MUST check that `s` matches merkle of fields, minus `omitted`.\n> \t- MUST check that no vital fields are in `omitted`.\n> \t- MUST check that `d` matches `description`\n>      - MUST check that `q` DNE if `quantity` DNE, otherwise is equal.\n>      - Must check valid signature, etc.\n>\n> ## Merkle Calculation\n>\n> 1. For each `invoice_req_tlv` field in ascending `tlv` type order:\n>     1. If the field was omitted, it is added to `omitted_fields`.\n>     2. Otherwise, the immediate parent merkle is:\n>     \n>        SHA256(SHA256(`tag` | `be64-n`) | SHA256(`tlv-value`))\n>\n>        Where `be64-n` is a 64-bit big-endian counter starting at 0 and\n>        incrementing for each leaf.\n>\n>     3. Order these nodes in increasing SHA256(`tag` | `be64-n`) order.\n>\n> 2. Create additional leaves until `be64-n` is the next power of 2:\n>\n>        SHA256(`tag` | `be64-n`)\n>\n> 3. Combine adjacent leaves using SHA256(leaf1 | leaf2) until none remain.\n>\n> By creating adjacent leaves using the `tag` field and a counter, and\n> sorting the leaves, the only significant information revealed by a\n> merkle proof on a node is the depth of tree (which implies the total\n> number of TLV fields).\n>\n> # InvRequests\n>\n> There are times when it makes sense to request an invoice over another\n> medium, such as HTTP or a QR code.\n>\n> ## Encoding\n>\n> The human-readable part of a Lightning invrequest is `lni`.  The data part\n> consists of three parts:\n>\n> 1. 0 or more [TLV](01-messaging.md#type-length-value-format) encoded fields.\n> 2. A 32-byte nodeid[1]\n> 3. 64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n>\n> ## TLV Fields\n>\n> 1. tlvs: `invreq`\n> 2. types:\n>      1. type: 1 (`paths`)\n>      2. data:\n>          * [`u16`:`num_paths`]\n>          * [`num_paths*path`:`path`]\n>      1. type: 2 (`description`)\n>      2. data:\n>          * [`...*byte`:`description`]\n>      1. type: 3 (`expiry`)\n>      2. data:\n>          * [`tu64`:`seconds_from_epoch`]\n>      1. type: 4 (`amount`)\n>      2. data:\n>          * [`tu64`:`millisatoshis`]\n>\n> The fields `paths`, `description`, and `expiry` fields are the\n> same as those for offers; the optional `amount` field describes the\n> amount an invoice will be accepted for.\n>\n> Upon parsing and accepting an `invreq`, the node sends an\n> `invoice_or_error_tlv` within an onion.  The reply is empty.\n>\n> ## Requirements\n>\n> The requirements for `paths`, `description` and `expiry` are\n> [described above](#requirements-for-offers-and-invrequests).\n>\n> FIXME: More.\n>\n> [1] Assuming we go for Schnorr sigs and 32-byte pubkeys.\n> ----\n> Addendum: BOLT #7: P2P Node and Channel Discovery and Directed Messages\n> ...\n> # Directed Messages\n>\n> Directed messages allow peers to use existing connections to query for\n> invoices (see [BOLT 12](12-offer-encoding.md)).  Like gossip messages,\n> they are not associated with a particular local channel.\n>\n> The `id` is a unique, transient identifier between the peers, used to\n> identify match messages and replies.\n>\n> ## The `directed` and `directed_reply` Messages\n>\n> 1. type: 384 (`directed`) (`option_directed_messages`)\n> 2. data:\n>      * [`chain_hash`:`chain_hash`]\n>      * [`u64`:`id`]\n>      * [`1366*byte`:`onion_routing_packet`]\n>\n> 1. type: 384 (`directed_reply`) (`option_directed_messages`)\n> 2. data:\n>      * [`chain_hash`:`chain_hash`]\n>      * [`u64`:`id`]\n>      * [`u16`:`len`]\n>      * [`len*byte`:`reply`]\n>\n> ## Requirements\n>\n> FIXME: similar to update_add_htlc and update_fail_htlc.\n> FIXME: define reasonable timeout after which you can forget if not replied?\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-08T03:09:15",
                "message_text_only": "Yaacov Akiba Slama <ya at slamail.org> writes:\n> Hi Rusty,\n>\n> It seems that there are two kind of TLV fields in your proposition:\n> 1) LN specific fields like `num_paths` and `payment_preimage`.\n> 2) \"Business\" fields like `address1` and `currency`.\n> I understand the need to define and include the first category, but I \n> don't think that we need or can define the second category. These fields \n> already exists in software like crm, erp, etc.. and are well defined by \n> standard body.\n> My suggestion is to have a generic field containing well defined \n> structured and standardized data. See for instance \n> https://en.wikipedia.org/wiki/EDIFACT and/or \n> https://en.wikipedia.org/wiki/Universal_Business_Language.\n\nHi Yaacov,\n\n        I've been pondering this since reading your comment on the PR!\n\n        As a fan of standards, I am attracted to UBL (I've chaired an\nOASIS TC in the past and have great respect for them); as a fan of\nsimplicity I am not.  Forcing UBL implementation on wallet providers is\nsimply not going to happen, whatever I were to propose.\n\n\tWe also don't want duplication; what if the \"UBL field\" were to\nsay I were selling you a bridge for $1 and the description and amount\nfields actually said I was selling you a coffee for $3?\n\n\tHowever, since invoices/offers and UBL are both structures, we\nshould have an explicit mapping between the two.  What fields should\nhave their own existence in the invoice/offer and what should be in a\ngeneral UBL field is a question we have to think on further.\n\n        Anyway, you'll have to bear with me as I read this 172 page\nstandard...\n\nCheers,\nRusty.\n\n> What do you think?\n> PS: Sorry for crossposting here and in \n> https://github.com/lightningnetwork/lightning-rfc/pull/694\n> --yas\n>\n> On 05/11/2019 06:23, Rusty Russell wrote:\n>> Hi all,\n>>\n>>          This took longer than I'd indicated; for that I'm sorry.\n>> However, this should give us all something to chew on.  I've started\n>> with a draft \"BOLT 12\" (it might be BOLT 13 by the time it's finalized\n>> though!).\n>>\n>> I've also appended indications where we touch other BOLTs:\n>> 1. BOLT 7 gains a message/reply system, encoded like htlc onions and\n>>     failure messages.\n>> 2. BOLT 11 gains a `q` field for quantity; this avoids changing the\n>>     description when the user requests an invoice for more than one of something\n>>     (since changing the description between offer and invoice requires user\n>>     interaction: it's the *invoice* which you are committing to).\n>>\n>> There's definite handwaving in here; let's see if you can find it!\n>>\n>> Cheers,\n>> Rusty.\n>>\n>> # BOLT #12: Offer Protocols for Lightning Payments\n>>\n>> An higher-level, QR-code-ready protocol for dealing with invoices over\n>> Lightning.  There are two simple flows supported: in one, a user gets\n>> an offer (`lno...`) and requests an invoice over the lightning\n>> network, obtaining one (or an error) in reply.  In the other, a user\n>> gets an invoice request (`lni...`), and sends the invoice over the\n>> lightning network, retreiving an empty reply.\n>>\n>> # Table of Contents\n>>\n>>    * [Offers](#offers)\n>>      * [Encoding](#encoding)\n>>      * [TLV Fields](#tlv-fields)\n>>    * [Invrequests](#invrequests)\n>>      * [Encoding](#encoding)\n>>      * [TLV Fields](#tlv-fields)\n>>\n>> # Offers\n>>\n>> Offers supply a reader with enough information to request one or more\n>> invoices via the lightning network itself.\n>>\n>> ## Encoding\n>>\n>> The human-readable part of a Lightning offer is `lno`.  The data part\n>> consists of three parts:\n>>\n>> 1. 0 or more [TLV](01-messaging.md#type-length-value-format) encoded fields.\n>> 2. A 32-byte nodeid[1]\n>> 3. 64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n>>\n>> ## TLV Fields\n>>\n>> The TLV fields define how to get the invoice, and what it's for.\n>> Each offer has a unique `offer_idenfitier` so the offering node can\n>> distinguish different invoice requests.\n>>\n>> Offers can request recurring payments of various kinds, and specify\n>> what base currency they are calculated in (the actual amount will be\n>> in the invoice).\n>>\n>> `additional_data` is a bitfield which indicates what information the\n>> invoice requester should (odd) or must (even) supply:\n>> 1. Bits `0/1`: include `delivery_address`\n>> 2. Bits `2/3`: include `delivery_telephone_number`\n>> 3. Bits `4/5`: include `voucher_code`\n>> 4. Bits `6/7`: include `refund_proof`\n>>\n>> `refund_for` indicates an offer for a (whole or part) refund for a\n>> previous invoice, as indicated by the `payment_hash`.\n>>\n>> 1. tlvs: `offer`\n>> 2. types:\n>>      1. type: 1 (`paths`)\n>>      2. data:\n>>          * [`u16`:`num_paths`]\n>>          * [`num_paths*path`:`path`]\n>>      1. type: 2 (`description`)\n>>      2. data:\n>>          * [`...*byte`:`description`]\n>>      1. type: 3 (`expiry`)\n>>      2. data:\n>>          * [`tu64`:`seconds_from_epoch`]\n>>      1. type: 4 (`offer_identifier`)\n>>      2. data:\n>>          * [`...*byte`:`id`]\n>>      1. type: 5 (`amount`)\n>>      2. data:\n>>          * [`4*byte`:`currency`]\n>>          * [`tu64`:`amount`]\n>>      1. type: 6 (`additional_data`)\n>>      2. data:\n>> \t    * [`...*byte`:`rbits`]\n>>      1. type: 7 (`recurrance`)\n>>      2. data:\n>> \t    * [`byte`:`time_unit`]\n>> \t\t* [`u32`:`period`]\n>> \t\t* [`tu32`:`number`]\n>>      1. type: 8 (`recurrance_base`)\n>>      2. data:\n>> \t\t* [`u32`:`basetime`]\n>> \t\t* [`tu32`:`paywindow`]\n>>      1. type: 9 (`quantity`)\n>>      2. data:\n>> \t\t* [`tu64`:`max`]\n>>      1. type: 10 (`refund_for`)\n>>      2. data:\n>>          * [`32*byte`:`payment_hash`]\n>>\n>> 1. subtype: `path`\n>> 2. data:\n>>     * [`u16`:`num_hops`]\n>>     * [`num_hops*hop`:`hops`]\n>>\n>> 1. subtype: `hop`\n>> 2. data:\n>>     * [`pubkey`:`nodeid`]\n>>     * [`short_channel_id`:`short_channel_id`]\n>>     * [`u16`:`flen`]\n>>     * [`flen*byte`:`features`]\n>>\n>> ## Requirements For Offers And Invrequests\n>>\n>> A writer of an offer or an invrequest:\n>>    - if it is connected only by private channels:\n>>      - MUST include `paths` containing a path to the node.\n>>    - otherwise:\n>>      - MAY include `paths` containing a path to the node.\n>>    - MUST describe the item(s) being offered or purpose of invoice in `description`.\n>>    - MUST include `expiry` if the offer/invrequest will not be valid after some time.\n>>    - if it includes `expiry`:\n>>      - MUST set `seconds_from_epoch` to the expiry time in seconds since 1970 UTC.\n>>\n>> ## Requirements For Offers\n>>\n>> A writer of an offer:\n>>    - MUST use a unique `offer_idenfitier` for each offer.\n>>    - MAY include `recurrence` to indicate offer should trigger time-spaced\n>>      invoices.\n>>    - MUST include `amount` if it includes `recurrence`.\n>>    - if it includes `amount`:\n>>      - MUST specify `currency` as the ISO 4712 or BIP-0173, padded with zero bytes if required\n>> \t- MUST specify `amount` to the amount expected for the invoice, as the ISO 4712 currency unit multiplied by exponent, OR the BIP-0173 minimum unit (eg. `satoshis`).\n>>    - if it requires specific fields in the invoice:\n>>      - MUST set the corresponding even bits in the `additional_data` field\n>>\n>> A reader of an offer:\n>>    - SHOULD gain user consent for recurring payments.\n>>    - SHOULD allow user to view and cancel recurring payments.\n>>    - SHOULD gain user consent to send `delivery_` fields.\n>>    - if it uses `amount` to provide the user with a cost estimate:\n>> \t- MUST warn user if amount of actual invoice differs significantly\n>> \t\tfrom that expectation.\n>>    - FIXME: more!\n>>\n>> ## Recurrance\n>>\n>> Some offers are *periodic*, such as a subscription service or monthly\n>> dues, in that payment is expected to be repeated.  There are many\n>> different flavors of repetition, consider:\n>>\n>> * Payments due on the first of every month, for 6 months.\n>> * Payments due on every Monday, 1pm Pacific Standard Time.\n>> * Payments due once a year:\n>>     * which must be made on January 1st, or\n>>     * which are only valid if started January 1st 2020, or\n>>     * which if paid after January 1st you (over) pay the full rate first year, or\n>>     * which if paid after January 1st are paid pro-rata for the first year, or\n>>     * which repeat from whenever you made the first payment\n>>\n>> Thus, each payment has:\n>> 1. A `time_unit` defining 0 (seconds), 1 (days), 2 (months), 3 (years).\n>> 2. A `period`, defining how often (in `time_unit`) it has to be paid.\n>> 3. An optional `number` of total payments to be paid.\n>> 4. An optional `basetime`, defining when the first payment applies\n>>     in seconds since 1970-01-01 UTC.\n>> 5. An optional `paywindow`, defining how many seconds into the period\n>>     a payment will be accepted: 0xFFFFFFFF being a special value meaning\n>>     \"any time during the period, but you will have to pay proportionally\n>>     to the remaining time in the period\".\n>>\n>> Note that the `expiry` field covers the case where an offer is no longer\n>> valid after January 1st 2020.\n>>\n>> ## Default Offer\n>>\n>> The \"default offer\" of a node is a nominal offer used to send\n>> unsolicited payments.  It is generally not actually sent, but can be\n>> used by any other node as if it has been.  It has the following\n>> fields:\n>>\n>> * `offer_idenfitier`: zero-length\n>> * `d`: any\n>> * `n`: the node id of the recipient.\n>>\n>> ## Invoice Request Encoding\n>>\n>> Once it has an offer, the node can request an actual invoice using the\n>> `invoice_req` message inside `directed`'s `onion_routing_packet`.  It\n>> would expect an `invoice_or_error_tlv` inside the `directed_reply`\n>> message.\n>>\n>> This includes a `tag` it can use to identify replies, the\n>> `offer_idenfitier` from the offer, a `key` it can use to prove it was\n>> the requester of this invoice, a `recurrence` number if this\n>> is a payment in a recurring series, and other codes as required.\n>>\n>> The `refund_proof` refers to a previous invoice paid by the sender for\n>> the specific case of a `refund_for` offer.  It provides proof of\n>> payment (the `payment_preimage` and also a signature of the\n>> `payment_hash` from the `key` which requested the being-refunded\n>> invoice (which does *not* have to be the same as this `key`!).\n>>\n>> 1. tlvs: `invoice_request_tlv`\n>> 2. types:\n>>     1. type: 1 (`tag`)\n>>     2. data:\n>>        * [`...*byte`:`tag`]\n>>     1. type: 2 (`offer_identifier`)\n>>     2. data:\n>>        * [`...*byte`:`id`]\n>>     1. type: 3 (`key`)\n>>     2. data:\n>>       * [`32`:`key`]\n>>     1. type: 4 (`recurrence`)\n>>     2. data:\n>>       * [`tu64`:`number`]\n>>     1. type: 5 (`quantity`)\n>>     2. data:\n>>       * [`tu64`:`n`]\n>>     1. type: 6 (`delivery_address_name`)\n>>     2. data:\n>> \t * [`...*byte`:`name`]\n>>     1. type: 7 (`delivery_address1`)\n>>     2. data:\n>> \t * [`...*byte`:`address1`]\n>>     1. type: 8 (`delivery_address2`)\n>>     2. data:\n>> \t * [`...*byte`:`address2`]\n>>     1. type: 9 (`delivery_city`)\n>>     2. data:\n>> \t * [`...*byte`:`city`]\n>>     1. type: 10 (`delivery_state_province_or_region`)\n>>     2. data:\n>> \t * [`...*byte`:`state_province_or_region`]\n>>     1. type: 11 (`delivery_zip_or_postal_code`)\n>>     2. data:\n>> \t * [`...*byte`:`zip_or_postal_code`]\n>>     1. type: 12 (`delivery_country`)\n>>     2. data:\n>> \t * [`2*byte`:`country_code`]\n>>     1. type: 13 (`delivery_telephone_number`)\n>>     2. data:\n>> \t * [`...*byte`:`tel`]\n>>     1. type: 14 (`voucher_code`)\n>>     2. data:\n>> \t * [`...*byte`:`code`]\n>>     1. type: 15 (`refund_proof`)\n>>     2. data:\n>>        * [`32*byte`:`payment_preimage`]\n>>        * [`signature`:`signature`]\n>>\n>> ## Requirements\n>>\n>> FIXME: many more\n>> Sender MUST use ISO 3166 alpha-2 code for `delivery_country`.\n>> Sender MUST set offer_identifier to match offer.\n>> Sender MUST include `key`\n>>     - SHOULD use a transient unpredictable key\n>>     - MUST reuse key for successive recurring invoices.\n>> Sender MUST set `recurrence` for recurring invoices.\n>>\n>> Receiver MUST check `offer_identifier`\n>> Receiver MUST check `delivery_` fields.\n>> Receiver MUST check `recurrence`.\n>> Receiver MUST check `amount`.\n>>\n>> 1. tlvs: `invoice_or_error_tlv`\n>> 2. types:\n>>     1. type: 1 (`tag`)\n>>     2. data:\n>>       * [`...*byte`:`tag`]\n>>     1. type: 3 (`omitted`)\n>>     2. data:\n>> \t * [`...*u64`:`omitted_fields`]\n>>     1. type: 4 (`invoice`)\n>>     2. data:\n>>       * [`...*byte`:`invoice`]\n>>     1. type: 5 (`message`)\n>>       * [`...*byte`:`message`]\n>>     1. type: 6 (`replacement`)\n>>     2. data:\n>>       * [`signature`:`signature`]\n>>       * [`...*byte`:`offer`]\n>>\n>> Sender:\n>> - MUST copy `tag` from sender.\n>> - MUST omit fields it does not use, and place number in order in `omitted_fields`.\n>> - if it includes `invoice`:\n>>    - MUST not include `message`\n>>    - MUST not include `replacement`\n>>    - MUST [merkle fields it used](#merkle-calculation) and place that in invoice `s` field.\n>> - otherwise, if it includes `replacement`:\n>>    - MAY include `message`\n>> - otherwise:\n>>    - MUST include `message` describing the error.\n>>\n>> Receiver:\n>> - MUST check that `tag` matches req.\n>> - if `replacement`:\n>>    - MUST fail if `signature` does not sign `offer` with same key as original.\n>>    - MUST only fetch once (no double-redirects!)\n>> - if description or amount significantly changes, must re-ask user.\n>>    - SHOULD note if description simply has something appended (eg \"+ postage\").\n>> - within invoice:\n>>      - MUST check that `s` matches merkle of fields, minus `omitted`.\n>> \t- MUST check that no vital fields are in `omitted`.\n>> \t- MUST check that `d` matches `description`\n>>      - MUST check that `q` DNE if `quantity` DNE, otherwise is equal.\n>>      - Must check valid signature, etc.\n>>\n>> ## Merkle Calculation\n>>\n>> 1. For each `invoice_req_tlv` field in ascending `tlv` type order:\n>>     1. If the field was omitted, it is added to `omitted_fields`.\n>>     2. Otherwise, the immediate parent merkle is:\n>>     \n>>        SHA256(SHA256(`tag` | `be64-n`) | SHA256(`tlv-value`))\n>>\n>>        Where `be64-n` is a 64-bit big-endian counter starting at 0 and\n>>        incrementing for each leaf.\n>>\n>>     3. Order these nodes in increasing SHA256(`tag` | `be64-n`) order.\n>>\n>> 2. Create additional leaves until `be64-n` is the next power of 2:\n>>\n>>        SHA256(`tag` | `be64-n`)\n>>\n>> 3. Combine adjacent leaves using SHA256(leaf1 | leaf2) until none remain.\n>>\n>> By creating adjacent leaves using the `tag` field and a counter, and\n>> sorting the leaves, the only significant information revealed by a\n>> merkle proof on a node is the depth of tree (which implies the total\n>> number of TLV fields).\n>>\n>> # InvRequests\n>>\n>> There are times when it makes sense to request an invoice over another\n>> medium, such as HTTP or a QR code.\n>>\n>> ## Encoding\n>>\n>> The human-readable part of a Lightning invrequest is `lni`.  The data part\n>> consists of three parts:\n>>\n>> 1. 0 or more [TLV](01-messaging.md#type-length-value-format) encoded fields.\n>> 2. A 32-byte nodeid[1]\n>> 3. 64-byte signature of SHA256(hrp-as-utf8 | tlv | nodeid).\n>>\n>> ## TLV Fields\n>>\n>> 1. tlvs: `invreq`\n>> 2. types:\n>>      1. type: 1 (`paths`)\n>>      2. data:\n>>          * [`u16`:`num_paths`]\n>>          * [`num_paths*path`:`path`]\n>>      1. type: 2 (`description`)\n>>      2. data:\n>>          * [`...*byte`:`description`]\n>>      1. type: 3 (`expiry`)\n>>      2. data:\n>>          * [`tu64`:`seconds_from_epoch`]\n>>      1. type: 4 (`amount`)\n>>      2. data:\n>>          * [`tu64`:`millisatoshis`]\n>>\n>> The fields `paths`, `description`, and `expiry` fields are the\n>> same as those for offers; the optional `amount` field describes the\n>> amount an invoice will be accepted for.\n>>\n>> Upon parsing and accepting an `invreq`, the node sends an\n>> `invoice_or_error_tlv` within an onion.  The reply is empty.\n>>\n>> ## Requirements\n>>\n>> The requirements for `paths`, `description` and `expiry` are\n>> [described above](#requirements-for-offers-and-invrequests).\n>>\n>> FIXME: More.\n>>\n>> [1] Assuming we go for Schnorr sigs and 32-byte pubkeys.\n>> ----\n>> Addendum: BOLT #7: P2P Node and Channel Discovery and Directed Messages\n>> ...\n>> # Directed Messages\n>>\n>> Directed messages allow peers to use existing connections to query for\n>> invoices (see [BOLT 12](12-offer-encoding.md)).  Like gossip messages,\n>> they are not associated with a particular local channel.\n>>\n>> The `id` is a unique, transient identifier between the peers, used to\n>> identify match messages and replies.\n>>\n>> ## The `directed` and `directed_reply` Messages\n>>\n>> 1. type: 384 (`directed`) (`option_directed_messages`)\n>> 2. data:\n>>      * [`chain_hash`:`chain_hash`]\n>>      * [`u64`:`id`]\n>>      * [`1366*byte`:`onion_routing_packet`]\n>>\n>> 1. type: 384 (`directed_reply`) (`option_directed_messages`)\n>> 2. data:\n>>      * [`chain_hash`:`chain_hash`]\n>>      * [`u64`:`id`]\n>>      * [`u16`:`len`]\n>>      * [`len*byte`:`reply`]\n>>\n>> ## Requirements\n>>\n>> FIXME: similar to update_add_htlc and update_fail_htlc.\n>> FIXME: define reasonable timeout after which you can forget if not replied?\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-08T06:39:59",
                "message_text_only": "Hi Rusty.\n\nOn 08/11/2019 05:09, Rusty Russell wrote:\n> Hi Yaacov,\n>          I've been pondering this since reading your comment on the PR!\n>\n>          As a fan of standards, I am attracted to UBL (I've chaired an\n> OASIS TC in the past and have great respect for them); as a fan of\n> simplicity I am not.  Forcing UBL implementation on wallet providers is\n> simply not going to happen, whatever I were to propose.\n\nIn fact, using UBL in LN specification is simpler than trying to \nunderstand the semantic of each field needed by businesses. You are \nright that using such a standard put the burden into wallet providers \ninstead of LN developers, but as a wallet (breez) provider, I can say that:\n\n1) Most money transactions (currently in fiat) are between users and \ncompanies and not between two users. If we want to replace FIAT by \nbitcoin, we need to create an infrastructure which can be used by \nbusinesses. That means that LN needs to be able to be integrated easily \ninto POS systems. So, as a wallet provider who want to help the \ntransition from fiat to bitcoin, I need to be able to support standards \neven if that means that I have to implement using/parsing big and \ncomplicated standards.\n\nFor simple user to user transaction, the wallet can decide to use only a \nsubset of the fields defined by the standard.\n\n2) From a technical point of view, it seems that there are already UBL \nlibraries in java and c#. I don't think such library is hard to write in \ngo, rust.., so every wallet implementation can use them.\n\n>\n> \tWe also don't want duplication; what if the \"UBL field\" were to\n> say I were selling you a bridge for $1 and the description and amount\n> fields actually said I was selling you a coffee for $3?\n>\n> \tHowever, since invoices/offers and UBL are both structures, we\n> should have an explicit mapping between the two.  What fields should\n> have their own existence in the invoice/offer and what should be in a\n> general UBL field is a question we have to think on further.\nI agree that we don't want duplication. This is the reason, I propose to \nuse only ubl structure and add in the ln standard invoice an ubl \n\"opaque\" field which will be self-contained and only add in the \ninvoice/offer/.. the fields specific to ln.\n>          Anyway, you'll have to bear with me as I read this 172 page\n> standard...\n\nSure :-)\n\nBTW, Thanks a lot for your all your work. LN would not have been where \nit is without your push."
            },
            {
                "author": "Ross Dyson",
                "date": "2019-11-08T07:30:49",
                "message_text_only": "Hi Rusty,\n\nWe spoke in detail about this after your presentation at LNconf. I'm one of\nthe contributors to LNURL so I am a little familiar with what you're trying\nto achieve and am very grateful you're considering implementing something\nsimilar to the mainnet protocol.\n\nI can only see delivery address being a nightmare for the network or wallet\nproviders. If you take a quick look at any Shopify website right now and\ntry to buy something to be delivered you will see validation of address\ninputs before accepting payment.\n\nThis is the 'expected' UX of consumer applications in 2019. If offers were\nto not validate address inputs correctly the user will not receive the\nproduct, lose money, and have a [very] negative review of both the\nwallet-providing and the offer-providing businesses.\n\nHandling these UX expectations will require either the wallet provider or\nthe offer provider to validate the inputs before proceeding with the sale.\n\n   1. If the offer provider handles validation then the network will have\n   to accommodate potentially infinite validation attempts (big no no I assume)\n   2. If the wallet provider were to provide the UX for input validation\n   they are taking on significant workload to develop a robust address input\n   UI, but more importantly the responsibility to correctly validate. There is\n   plenty of room to screw up and create a catastrophic user experience.\n\nSo I think address validation input is only possible via 2. but I think it\nis too much workload and responsibility to expect from wallet providers.\n>From what I can see, it would not be impossible to bring delivery address\nfunctionality into offers retroactively after offers was already in prod.\nPerhaps icebox it?\n\nI am very excited for LNOs and LNIs. If we want to get offers in prod and\nbeing facilitated by wallet providers I think it would be best if it was\nstreamlined a little first.\n\nThanks for reading,\n\nRoss\n\nOn Fri, Nov 8, 2019 at 3:40 PM Yaacov Akiba Slama <ya at slamail.org> wrote:\n\n> Hi Rusty.\n>\n> On 08/11/2019 05:09, Rusty Russell wrote:\n> > Hi Yaacov,\n> >          I've been pondering this since reading your comment on the PR!\n> >\n> >          As a fan of standards, I am attracted to UBL (I've chaired an\n> > OASIS TC in the past and have great respect for them); as a fan of\n> > simplicity I am not.  Forcing UBL implementation on wallet providers is\n> > simply not going to happen, whatever I were to propose.\n>\n> In fact, using UBL in LN specification is simpler than trying to\n> understand the semantic of each field needed by businesses. You are\n> right that using such a standard put the burden into wallet providers\n> instead of LN developers, but as a wallet (breez) provider, I can say that:\n>\n> 1) Most money transactions (currently in fiat) are between users and\n> companies and not between two users. If we want to replace FIAT by\n> bitcoin, we need to create an infrastructure which can be used by\n> businesses. That means that LN needs to be able to be integrated easily\n> into POS systems. So, as a wallet provider who want to help the\n> transition from fiat to bitcoin, I need to be able to support standards\n> even if that means that I have to implement using/parsing big and\n> complicated standards.\n>\n> For simple user to user transaction, the wallet can decide to use only a\n> subset of the fields defined by the standard.\n>\n> 2) From a technical point of view, it seems that there are already UBL\n> libraries in java and c#. I don't think such library is hard to write in\n> go, rust.., so every wallet implementation can use them.\n>\n> >\n> >       We also don't want duplication; what if the \"UBL field\" were to\n> > say I were selling you a bridge for $1 and the description and amount\n> > fields actually said I was selling you a coffee for $3?\n> >\n> >       However, since invoices/offers and UBL are both structures, we\n> > should have an explicit mapping between the two.  What fields should\n> > have their own existence in the invoice/offer and what should be in a\n> > general UBL field is a question we have to think on further.\n> I agree that we don't want duplication. This is the reason, I propose to\n> use only ubl structure and add in the ln standard invoice an ubl\n> \"opaque\" field which will be self-contained and only add in the\n> invoice/offer/.. the fields specific to ln.\n> >          Anyway, you'll have to bear with me as I read this 172 page\n> > standard...\n>\n> Sure :-)\n>\n> BTW, Thanks a lot for your all your work. LN would not have been where\n> it is without your push.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191108/24dc4976/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-11T04:26:38",
                "message_text_only": "Ross Dyson <me at rossdyson.com> writes:\n> Hi Rusty,\n>\n> We spoke in detail about this after your presentation at LNconf. I'm one of\n> the contributors to LNURL so I am a little familiar with what you're trying\n> to achieve and am very grateful you're considering implementing something\n> similar to the mainnet protocol.\n>\n> I can only see delivery address being a nightmare for the network or wallet\n> providers. If you take a quick look at any Shopify website right now and\n> try to buy something to be delivered you will see validation of address\n> inputs before accepting payment.\n>\n> This is the 'expected' UX of consumer applications in 2019. If offers were\n> to not validate address inputs correctly the user will not receive the\n> product, lose money, and have a [very] negative review of both the\n> wallet-providing and the offer-providing businesses.\n>\n> Handling these UX expectations will require either the wallet provider or\n> the offer provider to validate the inputs before proceeding with the sale.\n>\n>    1. If the offer provider handles validation then the network will have\n>    to accommodate potentially infinite validation attempts (big no no I assume)\n>    2. If the wallet provider were to provide the UX for input validation\n>    they are taking on significant workload to develop a robust address input\n>    UI, but more importantly the responsibility to correctly validate. There is\n>    plenty of room to screw up and create a catastrophic user experience.\n>\n> So I think address validation input is only possible via 2. but I think it\n> is too much workload and responsibility to expect from wallet providers.\n\nThis is not the area I worry about, TBH, since every shopping website in\nexistence has implemented address input (and some form of validation).\nI'm sure it'll be primitive to start with.\n\nOf course, UBL has a standard 'AddressType' too:\n\n        http://docs.oasis-open.org/ubl/os-UBL-2.2/xsd/common/UBL-CommonAggregateComponents-2.2.xsd\n\n>>From what I can see, it would not be impossible to bring delivery address\n> functionality into offers retroactively after offers was already in prod.\n> Perhaps icebox it?\n\nQuite possibly something we can delay; most current goods are virtual\nanyway.  However, delivery address standardization would greatly improve\nthe UX for such things.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-11T04:11:03",
                "message_text_only": "Yaacov Akiba Slama <ya at slamail.org> writes:\n> Hi Rusty.\n>\n> On 08/11/2019 05:09, Rusty Russell wrote:\n>> Hi Yaacov,\n>>          I've been pondering this since reading your comment on the PR!\n>>\n>>          As a fan of standards, I am attracted to UBL (I've chaired an\n>> OASIS TC in the past and have great respect for them); as a fan of\n>> simplicity I am not.  Forcing UBL implementation on wallet providers is\n>> simply not going to happen, whatever I were to propose.\n>\n> In fact, using UBL in LN specification is simpler than trying to \n> understand the semantic of each field needed by businesses. You are \n> right that using such a standard put the burden into wallet providers \n> instead of LN developers, but as a wallet (breez) provider, I can say that:\n>\n> 1) Most money transactions (currently in fiat) are between users and \n> companies and not between two users. If we want to replace FIAT by \n> bitcoin, we need to create an infrastructure which can be used by \n> businesses. That means that LN needs to be able to be integrated easily \n> into POS systems. So, as a wallet provider who want to help the \n> transition from fiat to bitcoin, I need to be able to support standards \n> even if that means that I have to implement using/parsing big and \n> complicated standards.\n>\n> For simple user to user transaction, the wallet can decide to use only a \n> subset of the fields defined by the standard.\n>\n> 2) From a technical point of view, it seems that there are already UBL \n> libraries in java and c#. I don't think such library is hard to write in \n> go, rust.., so every wallet implementation can use them.\n\nThat is not the problem.  The problem is that our order flow is simple:\n\n        Seller: Offer\n        Buyer: Invoice Request\n        Seller: Invoice (or updated Offer)\n        Buyer/Seller: Payment & Acknowledgement (atomic)\n\n(This could, of course, fit into a larger business flow.)\n\nThe closest UBL flow seems to be:\n\n        Seller: Quotation\n        Buyer: Order\n        Seller: (Prepayment)Invoice (or updated Quotation)\n\nIt's also worth noting that, even compressed, none of the UBL examples\nfit into the 1023 byte limit of the existing invoice format:\n\n        UBL-Quotation-2.1-Example.xml: 1864 bytes (gz)\n        UBL-Order-2.1-Example.xml: 2515 bytes (gz)\n        UBL-Invoice-2.1-Example.xml: 3163 bytes (gz)\n\nIndeed, that Quotation alone requires a 32x32 QR code.\n\n>> \tHowever, since invoices/offers and UBL are both structures, we\n>> should have an explicit mapping between the two.  What fields should\n>> have their own existence in the invoice/offer and what should be in a\n>> general UBL field is a question we have to think on further.\n> I agree that we don't want duplication. This is the reason, I propose to \n> use only ubl structure and add in the ln standard invoice an ubl \n> \"opaque\" field which will be self-contained and only add in the \n> invoice/offer/.. the fields specific to ln.\n\nExcept we need to go through the UBL spec and indicate exactly what\nfields are permitted, and which are required.\n\nMany UBI fields are not amenable to machine interpretation (eg. note\nfields).  These must be either explicitly exposed to the buyer (in case\nthe seller uses them) such as shipping conditions, or explicitly\nforbidden/ignored.\n\nThis is not a small task, and required intimiate knowledge of the UBL\nspec.  It's not enough just to make something *look* like UBL.\n\nDoes anyone have expertise in this area?  Shall we form a sub-group to\ninvestigate this properly?\n\nThanks!\nRusty."
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-12T13:59:31",
                "message_text_only": "On 11/11/2019 06:11, Rusty Russell wrote:\n> 2) From a technical point of view, it seems that there are already UBL \n> libraries in java and c#. I don't think such library is hard to write in \n> go, rust.., so every wallet implementation can use them.\n> That is not the problem.  The problem is that our order flow is simple:\n>\n>         Seller: Offer\n>         Buyer: Invoice Request\n>         Seller: Invoice (or updated Offer)\n>         Buyer/Seller: Payment & Acknowledgement (atomic)\n>\n> (This could, of course, fit into a larger business flow.)\n>\n> The closest UBL flow seems to be:\n>\n>         Seller: Quotation\n>         Buyer: Order\n>         Seller: (Prepayment)Invoice (or updated Quotation)\n\nIn UBL, 2 flows are defined (Traditional and Self Billing) and from what\nI know, the right flow depends on the country and even on the industry\n(services or goods for instance). What I suggest is to superpose the\n\"strict\" LN flow (invoice then payment) to the business flow. So for\ninstance when a prepayment invoice is needed, the simplified (from UBL\npov) flow will be:\n\n\u00a0 Seller: Quotation (UBL)\n\n\u00a0 Buyer: Order (UBL)\n\n\u00a0 Seller: Prepayment Invoice (UBL)\n\n\u00a0 Seller: Invoice (LN)\n\n\u00a0 Buyer/Seller: Payment & Ack (LN)\n\n\u00a0 Buyer: Receipt (UBL)\n\n\nThe advantage of such workflow are that we don't need to add any fields\nto the current invoice structure, nor to define in the LN protocol new\nmessages like offer or invoice request, nor to intervene in the semantic\nof the business workflow and in the required/optional fields in these\nmessages.\n\n\n>\n> It's also worth noting that, even compressed, none of the UBL examples\n> fit into the 1023 byte limit of the existing invoice format:\n>\n>         UBL-Quotation-2.1-Example.xml: 1864 bytes (gz)\n>         UBL-Order-2.1-Example.xml: 2515 bytes (gz)\n>         UBL-Invoice-2.1-Example.xml: 3163 bytes (gz)\n>\n> Indeed, that Quotation alone requires a 32x32 QR code.\n>\n>>> \tHowever, since invoices/offers and UBL are both structures, we\n>>> should have an explicit mapping between the two.  What fields should\n>>> have their own existence in the invoice/offer and what should be in a\n>>> general UBL field is a question we have to think on further.\n>> I agree that we don't want duplication. This is the reason, I propose to \n>> use only ubl structure and add in the ln standard invoice an ubl \n>> \"opaque\" field which will be self-contained and only add in the \n>> invoice/offer/.. the fields specific to ln.\n> Except we need to go through the UBL spec and indicate exactly what\n> fields are permitted, and which are required.\n>\n> Many UBI fields are not amenable to machine interpretation (eg. note\n> fields).  These must be either explicitly exposed to the buyer (in case\n> the seller uses them) such as shipping conditions, or explicitly\n> forbidden/ignored.\n>\n> This is not a small task, and required intimiate knowledge of the UBL\n> spec.  It's not enough just to make something *look* like UBL.\n>\n> Does anyone have expertise in this area?  Shall we form a sub-group to\n> investigate this properly?\n>\n> Thanks!\n> Rusty.\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-13T03:44:55",
                "message_text_only": "Yaacov Akiba Slama <ya at slamail.org> writes:\n> \u00a0 Seller: Quotation (UBL)\n>\n> \u00a0 Buyer: Order (UBL)\n>\n> \u00a0 Seller: Prepayment Invoice (UBL)\n>\n> \u00a0 Seller: Invoice (LN)\n>\n> \u00a0 Buyer/Seller: Payment & Ack (LN)\n>\n> \u00a0 Buyer: Receipt (UBL)\n>\n>\n> The advantage of such workflow are that we don't need to add any fields\n> to the current invoice structure, nor to define in the LN protocol new\n> messages like offer or invoice request, nor to intervene in the semantic\n> of the business workflow and in the required/optional fields in these\n> messages.\n \nThis would be UBL treating Lightning as a dumb payment layer, which is a\nlittle like faxing email, and not a use case I'd be promoting for\nLightning.\n\nTo be clear: the full UBL spec is machine *parsable* but definitely not\ndesigned to be machine *handlable*.  This makes sense, since a machine\ncannot generally choose between quotations or interpret general contract\nterms.\n\nHowever, for the simpler (but very common!) case of an offer->purchase\nflow, we can define a subset of UBL for which this *can* be done, and a\nfurther-limited subset which must be examined by the user\n(e.g. description of goods, price details, shipping info).\n\nIn addition, the atomic nature of LN needs to be baked into the\nprotocol; in LN taking the payment *requires* a cryptographic receipt,\nand neutering this property would be horribly short-sighted.\n\nWe need to define UBL extensions for the LN fields to tie them all\ntogether (e.g. payment_hash, node_id).  We also need to define a\ntransport mechanism for these over the Lightning Network.\n\nThis is all quite possible!  But it will take time and is a signficant\namount of work: I need to be sure that others feel the same way before I\nembark on this project.\n\nCheers,\nRusty.\n\n>> It's also worth noting that, even compressed, none of the UBL examples\n>> fit into the 1023 byte limit of the existing invoice format:\n>>\n>>         UBL-Quotation-2.1-Example.xml: 1864 bytes (gz)\n>>         UBL-Order-2.1-Example.xml: 2515 bytes (gz)\n>>         UBL-Invoice-2.1-Example.xml: 3163 bytes (gz)\n>>\n>> Indeed, that Quotation alone requires a 32x32 QR code.\n>>\n>>>> \tHowever, since invoices/offers and UBL are both structures, we\n>>>> should have an explicit mapping between the two.  What fields should\n>>>> have their own existence in the invoice/offer and what should be in a\n>>>> general UBL field is a question we have to think on further.\n>>> I agree that we don't want duplication. This is the reason, I propose to \n>>> use only ubl structure and add in the ln standard invoice an ubl \n>>> \"opaque\" field which will be self-contained and only add in the \n>>> invoice/offer/.. the fields specific to ln.\n>> Except we need to go through the UBL spec and indicate exactly what\n>> fields are permitted, and which are required.\n>>\n>> Many UBI fields are not amenable to machine interpretation (eg. note\n>> fields).  These must be either explicitly exposed to the buyer (in case\n>> the seller uses them) such as shipping conditions, or explicitly\n>> forbidden/ignored.\n>>\n>> This is not a small task, and required intimiate knowledge of the UBL\n>> spec.  It's not enough just to make something *look* like UBL.\n>>\n>> Does anyone have expertise in this area?  Shall we form a sub-group to\n>> investigate this properly?\n>>\n>> Thanks!\n>> Rusty.\n>>"
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-13T21:46:49",
                "message_text_only": "On 13/11/2019 05:44, Rusty Russell wrote:\n> Yaacov Akiba Slama <ya at slamail.org> writes:\n>> \u00a0 Seller: Quotation (UBL)\n>>\n>> \u00a0 Buyer: Order (UBL)\n>>\n>> \u00a0 Seller: Prepayment Invoice (UBL)\n>>\n>> \u00a0 Seller: Invoice (LN)\n>>\n>> \u00a0 Buyer/Seller: Payment & Ack (LN)\n>>\n>> \u00a0 Seller: Receipt (UBL)\n>>\n>  \n> This would be UBL treating Lightning as a dumb payment layer, which is a\n> little like faxing email, and not a use case I'd be promoting for\n> Lightning.\n\nI don't understand the comparison. Both email an fax are way to transmit\ndata and are not related to the *content* of what is transmitted.\nConsequently email and fax are in competing as a way to transmit data.\nBut LN and UBL (as I understand them) are not in competition because:\n\n* LN is a messaging protocol (soon) and a payment protocol.\n\n* UBL is a protocol defining business interaction workflow *around*\npayments.\n\nSo we can integrate between them without intermixing the semantics of\nthe protocols but we need only to define the interaction points between\nthem.\n\nIn the previous worflow, the seller can for instance add in the LN\ninvoice H(Quotation (UBL)||Order(UBL)||Prepayment Invoice(UBL)), and use\nH(Receipt(UBL)) as preimage. With such a workflow, the UBL documents are\ncryptographically tied to the LN payment.\n\nSo the property of UBL of not being machine *handlable* is not altered\nbut the LN cryptographic properties are still used to tie the workflow.\n\nAm I missing something?\n\n--yas\n\n>\n> To be clear: the full UBL spec is machine *parsable* but definitely not\n> designed to be machine *handlable*.  This makes sense, since a machine\n> cannot generally choose between quotations or interpret general contract\n> terms.\n>\n> However, for the simpler (but very common!) case of an offer->purchase\n> flow, we can define a subset of UBL for which this *can* be done, and a\n> further-limited subset which must be examined by the user\n> (e.g. description of goods, price details, shipping info).\n>\n> In addition, the atomic nature of LN needs to be baked into the\n> protocol; in LN taking the payment *requires* a cryptographic receipt,\n> and neutering this property would be horribly short-sighted.\n>\n> We need to define UBL extensions for the LN fields to tie them all\n> together (e.g. payment_hash, node_id).  We also need to define a\n> transport mechanism for these over the Lightning Network.\n>\n> This is all quite possible!  But it will take time and is a signficant\n> amount of work: I need to be sure that others feel the same way before I\n> embark on this project.\n>\n> Cheers,\n> Rusty.\n>\n>>> It's also worth noting that, even compressed, none of the UBL examples\n>>> fit into the 1023 byte limit of the existing invoice format:\n>>>\n>>>         UBL-Quotation-2.1-Example.xml: 1864 bytes (gz)\n>>>         UBL-Order-2.1-Example.xml: 2515 bytes (gz)\n>>>         UBL-Invoice-2.1-Example.xml: 3163 bytes (gz)\n>>>\n>>> Indeed, that Quotation alone requires a 32x32 QR code.\n>>>\n>>>>> \tHowever, since invoices/offers and UBL are both structures, we\n>>>>> should have an explicit mapping between the two.  What fields should\n>>>>> have their own existence in the invoice/offer and what should be in a\n>>>>> general UBL field is a question we have to think on further.\n>>>> I agree that we don't want duplication. This is the reason, I propose to \n>>>> use only ubl structure and add in the ln standard invoice an ubl \n>>>> \"opaque\" field which will be self-contained and only add in the \n>>>> invoice/offer/.. the fields specific to ln.\n>>> Except we need to go through the UBL spec and indicate exactly what\n>>> fields are permitted, and which are required.\n>>>\n>>> Many UBI fields are not amenable to machine interpretation (eg. note\n>>> fields).  These must be either explicitly exposed to the buyer (in case\n>>> the seller uses them) such as shipping conditions, or explicitly\n>>> forbidden/ignored.\n>>>\n>>> This is not a small task, and required intimiate knowledge of the UBL\n>>> spec.  It's not enough just to make something *look* like UBL.\n>>>\n>>> Does anyone have expertise in this area?  Shall we form a sub-group to\n>>> investigate this properly?\n>>>\n>>> Thanks!\n>>> Rusty.\n>>>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-11-14T01:59:01",
                "message_text_only": "Yaacov Akiba Slama <ya at slamail.org> writes:\n> So we can integrate between them without intermixing the semantics of\n> the protocols but we need only to define the interaction points between\n> them.\n>\n> In the previous worflow, the seller can for instance add in the LN\n> invoice H(Quotation (UBL)||Order(UBL)||Prepayment Invoice(UBL)), and use\n> H(Receipt(UBL)) as preimage. With such a workflow, the UBL documents are\n> cryptographically tied to the LN payment.\n>\n> So the property of UBL of not being machine *handlable* is not altered\n> but the LN cryptographic properties are still used to tie the workflow.\n>\n> Am I missing something?\n\nSure, people can do this today: simply set your `d` field to \"UBL:\n<hash>\".\n\nBut it provide what we want from offers:\n1. Does not provide a \"static invoice\" flow.\n2. Does not provide a donation flow.\n3. Does not provide a method for wallets to do recurrence.\n4. Does not provide end-to-end over LN (i.e. no HTTP(s) requests).\n\nCheers,\nRusty."
            },
            {
                "author": "Yaacov Akiba Slama",
                "date": "2019-11-14T09:32:47",
                "message_text_only": "On 14/11/2019 03:59, Rusty Russell wrote:\n> Yaacov Akiba Slama <ya at slamail.org> writes:\n>> So we can integrate between them without intermixing the semantics of\n>> the protocols but we need only to define the interaction points between\n>> them.\n>>\n>> In the previous worflow, the seller can for instance add in the LN\n>> invoice H(Quotation (UBL)||Order(UBL)||Prepayment Invoice(UBL)), and use\n>> H(Receipt(UBL)) as preimage. With such a workflow, the UBL documents are\n>> cryptographically tied to the LN payment.\n>>\n>> So the property of UBL of not being machine *handlable* is not altered\n>> but the LN cryptographic properties are still used to tie the workflow.\n>>\n>> Am I missing something?\n> Sure, people can do this today: simply set your `d` field to \"UBL:\n> <hash>\".\nExactly. But we can add a BOLT which contains 1) references to UBL as a\nway to exchange the business information needed in the payer<->payee\ninteractions and 2) describe the process of tying the document(s) to the\npayment(s).\n> But it provide what we want from offers:\n> 1. Does not provide a \"static invoice\" flow.\n\nWhat do you mean by \"static invoice\" flow? Perhaps:\n\n* Seller -> Buyer: Invoice (UBL)\n\n* Seller -> Buyer: Invoice (LN)\n\n* Buyer & Seller: Payment + Ack (LN)\n\n* Seller -> Buyer: Receipt (UBL)\n\n\n> 2. Does not provide a donation flow.\n\n* Payer -> Payee: Order (UBL)\n\n* Payee ->Payer: Invoice (LN)\n\n* Payer & Payee: Payment + Ack (LN)\n\n* Payer -> Payer: Receipt (UBL)\n\n> 3. Does not provide a method for wallets to do recurrence.\n\nA simplified workflow can be:\n\n* Seller -> Buyer: Quotation (UBL) containing recurring information\n\n* Buyer -> Seller: Order (UBL) containing recurring information\n\nThen at every beginning/end of period (depending on the info in the\nquotation/order)\n\n* Seller -> Buyer: Invoice (UBL)\n\n* Seller -> Buyer: Invoice (LN) (d contain the hash of the invoice +\nf(previous docs))\n\n* Buyer & Seller: Payment & Ack (LN)\n\n* Seller -> Buyer: Receipt (UBL)\n\n\n> 4. Does not provide end-to-end over LN (i.e. no HTTP(s) requests).\n\nYes as soon as LN support messaging (using [1] or [2] for instance)\n\n--yas\n\n\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002275.html\n\n[2]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002294.html"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2019-11-14T02:43:03",
                "message_text_only": "> - if `replacement`:\n>   - MUST fail if `signature` does not sign `offer` with same key as original.\n>  - MUST only fetch once (no double-redirects!)\n\nThe offer can only ever be replaced once or only once every so often?\nPerhaps it can only be replaced once per invoice_request?\n\n> - if description or amount significantly changes, must re-ask user.\n\nLet's say we're talking about a 20 year monthly subscription and the\nprice rises 1% per year.\nDid the price \"significantly changed\" because it ends up adding to a\nlot in the 20 year compared to what the offer said, or it did not\nbecause the individual 1% increases are considered small?\n\"significantly changes\" sounds handwavy indeed.\n\nRegarding slip-0173, I fear this end up becoming used in practice as\nids, given that they rely on a centralized manual registry vulnerable\nto name squatting and all that.\nIt's probably nothing to worry much about, since the software can\nconfigure them locally, for example, clightning does it in\nhttps://github.com/ElementsProject/lightning/blob/master/bitcoin/chainparams.c\nAnd thus if two chains happen to end up using the same string for the\nbip173 hrp, it is the software maintainer and not who pushed to\nslip-0173 first what decides.\n\nI guess in addition to the hrp in bip173, we can add a chain_id field\nto the offer and perhaps even repeated hrp for different chains could\nbe reused within the same software. Although it is certainly something\nchain creators should try to avoid if possible.\n\nI guess this applies to bolt11 invoices too, although for the invoices\nsent through the lightning network it is redundant, since the chain_id\nis already included in all messages.\n\nOn another note, perhaps I'm wrong, but I think this lacks a way for\npeople to potentially add their own custom fields, and I foresee\npeople abusing the description field, and ending up putting json,\nprotobuf or, even worse, xml in them. Oh, there's no description field\nin invoice request, then whatever is big enough and it's not needed\nfor those specific use cases.\nI was thinking how to abuse it for my own use case as I was reading,\nand I don't think it's one covered by UBL. Perhaps it's too stupid to\never be covered there, but here we go.\n\nI'm just playing with a little protocol in which an http server (bob)\naccepts requests from users (or alices) and gives an invoice in\nresponse.\nThen after alice pays the invoice, she can submit the payment hash and\npreimage to bob to prove him that the invoice has indeed been paid so\nthat bob goes ahead and performs some \"action\", which can actually\nfail, in which case there should be a refund, which I currently don't\nhandle in any way. But whether it fails in the \"action\" or not, bob\ngives some response.\nSo far this seems pretty generic I bet many use cases follow this\npattern, with different fields for the \"request\" which will somehow\ndetermine what the \"action\" will be. Perhaps not all require the extra\nstep of actively proving the payment, since bob could detect the\npayment on his own.\nThe current bolt12 draft could be used and take care of the refund part.\n\nSo if we can somehow brainstorm all possible fields in the request\nthat can make sense for all cases, that would be great.\nThe current draft doesn't cover my case though. In my case, the\nrequest contains a bolt11 invoice that bob is supposed to pay, that is\nthe \"action\" here. But after alice pays the invoice to bob.\n\nThis probably sounds quite stupidly unnecessary (and I actually hope\nit is), but note that the invoice in the request may be for a\ndifferent chain. In that case, during \"action\", bob would need to try\nto pay that invoice using another node connected to the lightning\nnetwork of that other chain.\n\nBut the details of my concrete use case matter much. The point is,\nshould we add a bolt11 field to invoice request only for my use case?\nI don't think so, if the invoices of the 2 chains can be paid\natomically, this use case as it is would become obsolete, and then we\nwould want to remove the field from the spec again.\nAnd I bet other people will think of other fields they would like to\nadd to the invoice_request but being something too specific they will\nalso feel it doesn't belong to the specs. So we'll simply put the\nfields in the description.\nIs that intended?\n\nI'm assuming bob (the offer creator) will be able to use plugins or\nsomething to do extra or custom validations on the invoice requests.\nAnd perhaps alice could use plugins too to better handle custom errors\nfrom particular types of bobs.\nPerhaps I'm assuming too much?\nDoes that make sense to you?\n\nIf you're really curious, the code for my use case is in\nhttps://github.com/jtimon/multi-ln-demo/tree/master/py-ln-gateway but\nI already said I don't handle refunds and it doesn't even have a\ndatabase yet, so anybody using this with production chains is not\nreckless but simply stupid."
            }
        ],
        "thread_summary": {
            "title": "BOLT 12: Offers",
            "categories": [
                "Lightning-dev",
                "VERY ROUGH DRAFT"
            ],
            "authors": [
                "Jorge Tim\u00f3n",
                "Ross Dyson",
                "Yaacov Akiba Slama",
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 96051
        }
    },
    {
        "title": "[Lightning-dev] BOLT 11: add optional vendor field.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-11-05T04:33:25",
                "message_text_only": "It was pointed out to me[1] at thelightningconference.com that it's often\na legal requirement to list the vendor on a receipt.  It also makes\nperfect sense.\n\nIt can be done in the description field, but that's really supposed to\nbe a description of the *items*.  Dividing it also lets wallets have\nmuch better UX.\n\nThe spec change itself is genuinely trivial:\n\n * `v` (12): `data_length` variable.  Optional name of vendor/supplier (UTF-8).\n\nFeedback from wallets and vendors appreciatedg!\nRusty.\nPS.  Pull req at https://github.com/lightningnetwork/lightning-rfc/pull/694,\n     but I realize that can be intimidating, hence this mail.\n\n[1] I'd like to credit this properly, but I was jetlagged and having way\n    too much fun.  Please claim if this was your idea :)"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-05T07:40:34",
                "message_text_only": "Good morning Rusty,\n\nLooks OK to me.\n\nRegards,\nZmnSCPxj\n\n> It was pointed out to me[1] at thelightningconference.com that it's often\n> a legal requirement to list the vendor on a receipt. It also makes\n> perfect sense.\n>\n> It can be done in the description field, but that's really supposed to\n> be a description of the items. Dividing it also lets wallets have\n> much better UX.\n>\n> The spec change itself is genuinely trivial:\n>\n> -   `v` (12): `data_length` variable. Optional name of vendor/supplier (UTF-8).\n>\n>     Feedback from wallets and vendors appreciatedg!\n>     Rusty.\n>     PS. Pull req at https://github.com/lightningnetwork/lightning-rfc/pull/694,\n>     but I realize that can be intimidating, hence this mail.\n>\n>     [1] I'd like to credit this properly, but I was jetlagged and having way\n>     too much fun. Please claim if this was your idea :)\n>\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "BOLT 11: add optional vendor field.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1776
        }
    },
    {
        "title": "[Lightning-dev] Rendez-vous on a Trampoline",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2019-11-05T23:53:01",
                "message_text_only": "Hi t-bast,\n\n> She creates a Bolt 11 invoice containing that pre-encrypted onion.\n\nThis seem insufficient, as if the prescribed route that Alice selects fails,\nthen the sender has no further information to go off of (let's say Teddy is\noffline, but there're other pats). cdecker's rendezvous sketch using Sphinx\nyou\nlinked above also suffers from the same issue: you need some other\nbi-directional communication medium between the sender and receiver in\norder to\naccount for payment failures. Beyond that, if any failures occur in the\nlatter\nhalf of the route (the part that's opaque to the sender), then the sender\nisn't\nable to incorporate the failure information into their path finding.  As a\nresult, the payer would need to send the error back to the receiver for\ndecrypting, possibly ping-ponging several times in a payment attempt.\n\nOn the other hand, using HORNET for rendezvous routing as was originally\nintended gives the sender+receiver a communication channel they can use to\nexchange further payment information, and also a channel to use for\ndecryption\nof the opaque errors. Amongst many other things, it would also give us a\npayment-level ACK [1], which may be a key component for payment splitting\n(otherwise\nyou have no idea if _any_ shards have even arrived at the other side).\n\n\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001524.html\n\n-- Laolu\n\nOn Tue, Oct 22, 2019 at 5:02 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Good morning everyone,\n>\n> Since I'm a one-trick pony, I'd like to talk to you about...guess what?\n> Trampoline!\n> If you watched my talk at LNConf2019, I mentioned at the end that\n> Trampoline enables high AMP very easily.\n> Every Trampoline node in the route may aggregate an incoming multi-part\n> payment and then decide on how\n> to split the outgoing aggregated payment. It looks like this:\n>\n>      .-------- 1mBTC --------.    .------- 2mBTC -------.\n>     /                                    \\ /\n>     \\\n> Alice ----- 3mBTC ------> Ted ------ 4mBTC ----> Terry ----- 6mBTC ---->\n> Bob\n>    \\                                     /\n>     `------- 2mBTC ----------'\n>\n> In this example, Alice only has small-ish channels to Ted so she has to\n> split in 3 parts. Ted has good outgoing\n> capacity to Terry so he's able to split in only two parts. And Terry has a\n> big channel to Bob so he doesn't need\n> to split at all.\n> This is interesting because each intermediate Trampoline node has\n> knowledge of his local channels balances,\n> thus can make more informed decisions than Alice on how to efficiently\n> split to reach the next node.\n>\n> But it doesn't stop there. Trampoline also enables a better rendez-vous\n> routing than normal payments.\n> Christian has done most of the hard work to figure out how we could do\n> rendez-vous on top of Sphinx [1]\n> (thanks Christian!), so I won't detail that here (but I do plan on\n> submitting a detailed spec proposal with all\n> the crypto equations and nice diagrams someday, unless Christian does it\n> first).\n>\n> One of the issues with rendez-vous routing is that once Alice (the\n> recipient) has created her part of the onion,\n> she needs to communicate that to Bob (the sender). If we use a Bolt 11\n> invoice for that, it means we need to\n> put 1366 additional bytes to the invoice (plus some additional information\n> for the ephemeral key switch).\n> If the amount Alice wants to receive is big and may require multi-part,\n> Alice has to decide upfront on how to split\n> and provide multiple pre-encrypted onions (so we need 1366 bytes *per\n> partial payment*, which kinda sucks).\n>\n> But guess what? Bitcoin Trampoline fixes that*\u2122*. Instead of doing the\n> pre-encryption on a normal onion, Alice\n> would do the pre-encryption on a Trampoline onion (which is much smaller,\n> in my prototype it's 466 bytes).\n> And that allows rendez-vous routing to benefit from Trampoline's ability\n> to do multi-part at each hop.\n> Obviously since the onion is smaller, that limits the number of trampoline\n> hops that can be used, but don't\n> forget that there are additional \"normal\" hops between each Trampoline\n> node (and the final Trampoline spec\n> can choose the size of the Trampoline onion to enable a good enough\n> rendez-vous).\n>\n> Here is what it would look like. Alice chooses to rendez-vous at Terry.\n> Alice wants the payment to go through Terry\n> and Teddy so she pre-encrypts a Trampoline onion with that route:\n>\n> Alice <--- Teddy <--- Terry\n>\n> She creates a Bolt 11 invoice containing that pre-encrypted onion. Bob\n> picks up that invoice and can either reach\n> Terry directly (via a normal payment route) or via another Trampoline node\n> (Toad?). Bob finalizes the encryption of\n> the Trampoline onion and sends it onward. Bob can use multi-part and split\n> the payment however he wishes,\n> because every Trampoline node in the route will be free to aggregate and\n> re-split differently.\n> Terry is the only intermediate node to know that rendez-vous routing was\n> used. Terry doesn't learn anything about\n> Alice because the payment still needs to go through Teddy. Teddy only\n> learns that this is a Trampoline payment, so\n> he doesn't know his position in the Trampoline route (especially since he\n> doesn't know that rendez-vous was used).\n>\n> I believe this makes rendez-vous routing reasonable to implement: the\n> trade-offs aren't as strong as in the normal\n> payment case. If I missed something (maybe other issues related to the\n> current rendez-vous proposal) please let me know.\n>\n> Of course Trampoline itself also has trade-offs that in some cases may\n> impact privacy (e.g. when paying to legacy nodes\n> that don't understand the Trampoline onion). This is why Eclair is\n> currently implementing it to identify all the places where\n> it falls short, so that we can then leverage the community's amazing brain\n> power to converge on a spec that everyone is\n> happy with and that minimizes the trade-offs we need to make. Stay tuned\n> for more information and updates to the spec PR\n> once we make progress on our Trampoline experiments.\n>\n> Thank you for reading this, don't hesitate to throw ideas and/or criticize\n> this proposal.\n> Note that all the cryptographic details are left as an exercise to the\n> reader.\n>\n> Bastien\n>\n> [1]\n> https://github.com/lightningnetwork/lightning-rfc/wiki/Rendez-vous-mechanism-on-top-of-Sphinx\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191105/3f9453a1/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-11-12T13:49:00",
                "message_text_only": "Hey Laolu,\n\nLooks like HORNET is back in the game in many recent threads ;)\nHowever the recent paper shared on the tor-dev mailing list [1] mentions\nthat HORNET and\nother onion sessions might be a lot less secure than we thought...so I'd\nwait for more academic\nresults before including such a big change to the network.\n\nI totally agree with you though that current rendezvous proposals are\none-shot only.\nIf that route fails, then you can't do smart retries nor get useful routing\nfailure data.\n\nIt might be an unpopular opinion but I think that this can be addressed\noff-protocol though.\nIn most scenario I can think of, the user will still interact with a\nwebsite to scan a QR code or an API\nto get an invoice. On failure, another round of interaction to offer a\ndifferent rendezvous onion could\nhappen between the payer's app and the merchant's website. It's the same\nfor stuckless' ACK\nmessage. This message could be exchanged outside of the protocol via the\ninteraction between a\npayer's app and the merchant's website.\n\nCheers,\nBastien\n\n[1] https://arxiv.org/abs/1910.13772\n\n\nLe mer. 6 nov. 2019 \u00e0 00:53, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n\u00e9crit :\n\n> Hi t-bast,\n>\n> > She creates a Bolt 11 invoice containing that pre-encrypted onion.\n>\n> This seem insufficient, as if the prescribed route that Alice selects\n> fails,\n> then the sender has no further information to go off of (let's say Teddy is\n> offline, but there're other pats). cdecker's rendezvous sketch using\n> Sphinx you\n> linked above also suffers from the same issue: you need some other\n> bi-directional communication medium between the sender and receiver in\n> order to\n> account for payment failures. Beyond that, if any failures occur in the\n> latter\n> half of the route (the part that's opaque to the sender), then the sender\n> isn't\n> able to incorporate the failure information into their path finding.  As a\n> result, the payer would need to send the error back to the receiver for\n> decrypting, possibly ping-ponging several times in a payment attempt.\n>\n> On the other hand, using HORNET for rendezvous routing as was originally\n> intended gives the sender+receiver a communication channel they can use to\n> exchange further payment information, and also a channel to use for\n> decryption\n> of the opaque errors. Amongst many other things, it would also give us a\n> payment-level ACK [1], which may be a key component for payment splitting\n> (otherwise\n> you have no idea if _any_ shards have even arrived at the other side).\n>\n>\n> [1]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001524.html\n>\n> -- Laolu\n>\n> On Tue, Oct 22, 2019 at 5:02 AM Bastien TEINTURIER <bastien at acinq.fr>\n> wrote:\n>\n>> Good morning everyone,\n>>\n>> Since I'm a one-trick pony, I'd like to talk to you about...guess what?\n>> Trampoline!\n>> If you watched my talk at LNConf2019, I mentioned at the end that\n>> Trampoline enables high AMP very easily.\n>> Every Trampoline node in the route may aggregate an incoming multi-part\n>> payment and then decide on how\n>> to split the outgoing aggregated payment. It looks like this:\n>>\n>>      .-------- 1mBTC --------.    .------- 2mBTC -------.\n>>     /                                    \\ /\n>>     \\\n>> Alice ----- 3mBTC ------> Ted ------ 4mBTC ----> Terry ----- 6mBTC ---->\n>> Bob\n>>    \\                                     /\n>>     `------- 2mBTC ----------'\n>>\n>> In this example, Alice only has small-ish channels to Ted so she has to\n>> split in 3 parts. Ted has good outgoing\n>> capacity to Terry so he's able to split in only two parts. And Terry has\n>> a big channel to Bob so he doesn't need\n>> to split at all.\n>> This is interesting because each intermediate Trampoline node has\n>> knowledge of his local channels balances,\n>> thus can make more informed decisions than Alice on how to efficiently\n>> split to reach the next node.\n>>\n>> But it doesn't stop there. Trampoline also enables a better rendez-vous\n>> routing than normal payments.\n>> Christian has done most of the hard work to figure out how we could do\n>> rendez-vous on top of Sphinx [1]\n>> (thanks Christian!), so I won't detail that here (but I do plan on\n>> submitting a detailed spec proposal with all\n>> the crypto equations and nice diagrams someday, unless Christian does it\n>> first).\n>>\n>> One of the issues with rendez-vous routing is that once Alice (the\n>> recipient) has created her part of the onion,\n>> she needs to communicate that to Bob (the sender). If we use a Bolt 11\n>> invoice for that, it means we need to\n>> put 1366 additional bytes to the invoice (plus some additional\n>> information for the ephemeral key switch).\n>> If the amount Alice wants to receive is big and may require multi-part,\n>> Alice has to decide upfront on how to split\n>> and provide multiple pre-encrypted onions (so we need 1366 bytes *per\n>> partial payment*, which kinda sucks).\n>>\n>> But guess what? Bitcoin Trampoline fixes that*\u2122*. Instead of doing the\n>> pre-encryption on a normal onion, Alice\n>> would do the pre-encryption on a Trampoline onion (which is much smaller,\n>> in my prototype it's 466 bytes).\n>> And that allows rendez-vous routing to benefit from Trampoline's ability\n>> to do multi-part at each hop.\n>> Obviously since the onion is smaller, that limits the number of\n>> trampoline hops that can be used, but don't\n>> forget that there are additional \"normal\" hops between each Trampoline\n>> node (and the final Trampoline spec\n>> can choose the size of the Trampoline onion to enable a good enough\n>> rendez-vous).\n>>\n>> Here is what it would look like. Alice chooses to rendez-vous at Terry.\n>> Alice wants the payment to go through Terry\n>> and Teddy so she pre-encrypts a Trampoline onion with that route:\n>>\n>> Alice <--- Teddy <--- Terry\n>>\n>> She creates a Bolt 11 invoice containing that pre-encrypted onion. Bob\n>> picks up that invoice and can either reach\n>> Terry directly (via a normal payment route) or via another Trampoline\n>> node (Toad?). Bob finalizes the encryption of\n>> the Trampoline onion and sends it onward. Bob can use multi-part and\n>> split the payment however he wishes,\n>> because every Trampoline node in the route will be free to aggregate and\n>> re-split differently.\n>> Terry is the only intermediate node to know that rendez-vous routing was\n>> used. Terry doesn't learn anything about\n>> Alice because the payment still needs to go through Teddy. Teddy only\n>> learns that this is a Trampoline payment, so\n>> he doesn't know his position in the Trampoline route (especially since he\n>> doesn't know that rendez-vous was used).\n>>\n>> I believe this makes rendez-vous routing reasonable to implement: the\n>> trade-offs aren't as strong as in the normal\n>> payment case. If I missed something (maybe other issues related to the\n>> current rendez-vous proposal) please let me know.\n>>\n>> Of course Trampoline itself also has trade-offs that in some cases may\n>> impact privacy (e.g. when paying to legacy nodes\n>> that don't understand the Trampoline onion). This is why Eclair is\n>> currently implementing it to identify all the places where\n>> it falls short, so that we can then leverage the community's amazing\n>> brain power to converge on a spec that everyone is\n>> happy with and that minimizes the trade-offs we need to make. Stay tuned\n>> for more information and updates to the spec PR\n>> once we make progress on our Trampoline experiments.\n>>\n>> Thank you for reading this, don't hesitate to throw ideas and/or\n>> criticize this proposal.\n>> Note that all the cryptographic details are left as an exercise to the\n>> reader.\n>>\n>> Bastien\n>>\n>> [1]\n>> https://github.com/lightningnetwork/lightning-rfc/wiki/Rendez-vous-mechanism-on-top-of-Sphinx\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191112/001769b3/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-11-12T13:42:12",
                "message_text_only": "Hi Antoine,\n\nThis delegation trades hardware requirements against privacy leaks\n> and higher fees. And we also have now to re-design privacy mechanism\n> to constitue an anonymous network on top of the network one. Rendez-vous\n> is one of them, multipe-trampoline hops another one.\n>\n\nI'm not sure I understand this correctly. The goal of trampoline is to do\nmulti-trampoline hops\nright from the beginning (when we include it in the spec). In that case I\nbelieve we can make\nsure we offer the same privacy as we have today.\n\nThat's said, current trampoline proposal which enables legacy payee doxing\n> without\n> any opt-in from its side is a bit gross.\n>\n\nI totally agree and I think that's something that we will fix once we start\nbrainstorming for\nspec inclusion, with more eyes on the proposal.\n\nOverall I agree with your concerns and this is why we want more feedback on\nthe proposal.\nWe think that providing a first implementation is a good step towards\ngetting people onboard\nand improving it.\n\nI also think that we're over-estimating the privacy currently offered by\nthe network (against\npowerful adversaries). You mention doing MPP path intersection to expose\nsenders, but while\nthe network has low usage, people can be de-anonymized much more easily\nwith simple\nstatistical analysis (via cltv and amounts).\n\nBut I'm confident that privacy features can be added incrementally, such as\nthe random_scid\nwork and rendezvous.\n\nCheers,\nBastien\n\nLe lun. 28 oct. 2019 \u00e0 03:02, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Hi,\n>\n> Design reason of trampoline routing was to avoid lite nodes having\n> to store the whole network graph and compute long-hop route. Trick\n> lays in getting away from source-base routing, which has the nice\n> property to hide hop position along the payment route (if we forget\n> payment hash correleation), by enabling a mechanism for route\n> computation delegation.\n>\n> This delegation trades hardware requirements against privacy leaks\n> and higher fees. And we also have now to re-design privacy mechanism\n> to constitue an anonymous network on top of the network one. Rendez-vous\n> is one of them, multipe-trampoline hops another one. We may want also to\n> be inspired by I2P and its concept of outbound/inbound tunnels, like payer\n> concatenating a second trampoline onion to the rendez-vous onion acquired\n> from\n> the payee. Trick are known but hard and complex to get right in practice.\n>\n> That's said, current trampoline proposal which enables legacy payee doxing\n> without\n> any opt-in from its side is a bit gross. Yes rendez-vous routing by\n> receiver solves\n> it (beyond being cool in itself)! but stucks on the same requirement to\n> update payee nodes.\n> If so, implementing trampoline routing on receiver could be easier and let\n> it hide behind the\n> feature flag.\n>\n> If Eclair go forward with trampoline, are you going to enforce that\n> trampoline\n> routing is only done with payee flagging support ?\n>\n> That's a slowdown but if not people are going to be upset learning that a\n> chunk of their\n> incoming payment is potentially logged by some intermediate node.\n>\n> Also, I'm a bit worried too on how AMP is going to interact with\n> trampoline routing.\n> Depend on topology, but a naive implementation only using public channels\n> and one-hop\n> trampoline node would let the trampoline learn who is the payer by doing\n> intersection\n> of the multiple payment paths.\n>\n> Long-term we may be pleased to have this flexible tools to enable\n> wide-scale\n> networking without assessing huge routing tables for everyone but I think\n> we\n> should be really careful on how we design and deploy this stuff to avoid\n> another\n> false promise of privacy like we have known on the base layer, e.g\n> bloom-filters.\n>\n> Antoine\n>\n> Le ven. 25 oct. 2019 \u00e0 03:20, Corn\u00e9 Plooy via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Cool: non-source rendez-vous routing. Getting closer to 2013 Amiko Pay,\n>> with the added experience of 2019 Lightning with Sphinx routing and AMP.\n>>\n>> https://cornwarecjp.github.io/amiko-pay/doc/amiko_draft_2.pdf\n>>\n>> (esp. section 2.1.3)\n>>\n>> Please forgive the use of the term \"Ripple\". 2013 was a different time.\n>>\n>>\n>> CJP\n>>\n>>\n>> On 22-10-19 14:01, Bastien TEINTURIER wrote:\n>> > Good morning everyone,\n>> >\n>> > Since I'm a one-trick pony, I'd like to talk to you about...guess\n>> > what? Trampoline!\n>> > If you watched my talk at LNConf2019, I mentioned at the end that\n>> > Trampoline enables high AMP very easily.\n>> > Every Trampoline node in the route may aggregate an incoming\n>> > multi-part payment and then decide on how\n>> > to split the outgoing aggregated payment. It looks like this:\n>> >\n>> >      .-------- 1mBTC --------.    .------- 2mBTC -------.\n>> >     /                                    \\ /\n>> >         \\\n>> > Alice ----- 3mBTC ------> Ted ------ 4mBTC ----> Terry ----- 6mBTC\n>> > ----> Bob\n>> >    \\                                     /\n>> >     `------- 2mBTC ----------'\n>> >\n>> > In this example, Alice only has small-ish channels to Ted so she has\n>> > to split in 3 parts. Ted has good outgoing\n>> > capacity to Terry so he's able to split in only two parts. And Terry\n>> > has a big channel to Bob so he doesn't need\n>> > to split at all.\n>> > This is interesting because each intermediate Trampoline node has\n>> > knowledge of his local channels balances,\n>> > thus can make more informed decisions than Alice on how to efficiently\n>> > split to reach the next node.\n>> >\n>> > But it doesn't stop there. Trampoline also enables a better\n>> > rendez-vous routing than normal payments.\n>> > Christian has done most of the hard work to figure out how we could do\n>> > rendez-vous on top of Sphinx [1]\n>> > (thanks Christian!), so I won't detail that here (but I do plan on\n>> > submitting a detailed spec proposal with all\n>> > the crypto equations and nice diagrams someday, unless Christian does\n>> > it first).\n>> >\n>> > One of the issues with rendez-vous routing is that once Alice (the\n>> > recipient) has created her part of the onion,\n>> > she needs to communicate that to Bob (the sender). If we use a Bolt 11\n>> > invoice for that, it means we need to\n>> > put 1366 additional bytes to the invoice (plus some additional\n>> > information for the ephemeral key switch).\n>> > If the amount Alice wants to receive is big and may require\n>> > multi-part, Alice has to decide upfront on how to split\n>> > and provide multiple pre-encrypted onions (so we need 1366 bytes /per\n>> > partial payment/, which kinda sucks).\n>> >\n>> > But guess what? Bitcoin Trampoline fixes that*\u2122*. Instead of doing the\n>> > pre-encryption on a normal onion, Alice\n>> > would do the pre-encryption on a Trampoline onion (which is much\n>> > smaller, in my prototype it's 466 bytes).\n>> > And that allows rendez-vous routing to benefit from\n>> > Trampoline's ability to do multi-part at each hop.\n>> > Obviously since the onion is smaller, that limits the number of\n>> > trampoline hops that can be used, but don't\n>> > forget that there are additional \"normal\" hops between each Trampoline\n>> > node (and the final Trampoline spec\n>> > can choose the size of the Trampoline onion to enable a good enough\n>> > rendez-vous).\n>> >\n>> > Here is what it would look like. Alice chooses to rendez-vous at\n>> > Terry. Alice wants the payment to go through Terry\n>> > and Teddy so she pre-encrypts a Trampoline onion with that route:\n>> >\n>> > Alice <--- Teddy <--- Terry\n>> >\n>> > She creates a Bolt 11 invoice containing that pre-encrypted onion. Bob\n>> > picks up that invoice and can either reach\n>> > Terry directly (via a normal payment route) or via another Trampoline\n>> > node (Toad?). Bob finalizes the encryption of\n>> > the Trampoline onion and sends it onward. Bob can use multi-part and\n>> > split the payment however he wishes,\n>> > because every Trampoline node in the route will be free to aggregate\n>> > and re-split differently.\n>> > Terry is the only intermediate node to know that rendez-vous routing\n>> > was used. Terry doesn't learn anything about\n>> > Alice because the payment still needs to go through Teddy. Teddy only\n>> > learns that this is a Trampoline payment, so\n>> > he doesn't know his position in the Trampoline route (especially since\n>> > he doesn't know that rendez-vous was used).\n>> >\n>> > I believe this makes rendez-vous routing reasonable to implement: the\n>> > trade-offs aren't as strong as in the normal\n>> > payment case. If I missed something (maybe other issues related to the\n>> > current rendez-vous proposal) please let me know.\n>> >\n>> > Of course Trampoline itself also has trade-offs that in some cases may\n>> > impact privacy (e.g. when paying to legacy nodes\n>> > that don't understand the Trampoline onion). This is why Eclair is\n>> > currently implementing it to identify all the places where\n>> > it falls short, so that we can then leverage the community's amazing\n>> > brain power to converge on a spec that everyone is\n>> > happy with and that minimizes the trade-offs we need to make. Stay\n>> > tuned for more information and updates to the spec PR\n>> > once we make progress on our Trampoline experiments.\n>> >\n>> > Thank you for reading this, don't hesitate to throw ideas and/or\n>> > criticize this proposal.\n>> > Note that all the cryptographic details are left as an exercise to the\n>> > reader.\n>> >\n>> > Bastien\n>> >\n>> > [1]\n>> https://github.com/lightningnetwork/lightning-rfc/wiki/Rendez-vous-mechanism-on-top-of-Sphinx\n>> >\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191112/cb39fa0b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Rendez-vous on a Trampoline",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Olaoluwa Osuntokun"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 25185
        }
    },
    {
        "title": "[Lightning-dev] Potential Minor Sphinx Privacy Leak and Patch",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2019-11-06T02:37:10",
                "message_text_only": "Hi y'all,\n\nA new paper analyzing the security of the Sphinx mix-net packet format [1]\n(and also HORNET) has recently caught my attention. The paper is rather long\nand very theory heavy, but the TL;DR is this:\n\n    * The OG Sphinx paper proved various aspects of its security using a\n      model for onion routing originally put forth by Camenisch and\n      Lysyanskaya [2].\n    * This new paper discovered that certain security notions put forth in\n      [2] weren't actually practically achievable by real-world onion\nrouting\n      implementations (in this case Onion-Correctnes), or weren't entirely\n      correct or additive.  New stronger security notions are put forth in\n      response, along with extensions to the original Sphinx mix-net packet\n      format that achieve these notions.\n    * A flaw they discovered in the original Sphinx paper [3], can allow an\n      exit node to deduce a lower bound of the length of the path used to\n      reach it. The issue is that the original paper constructs the\n      _starting packet_ (what the exit hop will receive) by adding extra\n      padding zeroes after the destination and identifier (we've more or\n      less revamped this with our new onion format, but it still stands).\n      An adversarial exit node can then locate the first set bit after the\n      identifier (our payload in this case), then use that to compute the\n      lower bound.\n     * One of the (?) reference Sphinx implementations recognizes that this\n       was/is an issue in the paper and implements the mitigation [4].\n     * The fix on our end is easy: we need to replace those zero bytes with\n       random bytes when constructing the starting packet.\n\nI've created a PR to lnd's lightning-onion PR implementing this mitigation\n[5].  As this changes the starting packet format, we also need to either\nupdate the test vectors or we can keep them as is, and note that we use\nzeroes so the test vectors are fully deterministic. My PR to the spec\npatching the privacy leak leaves the test vectors untouched as is [6].\n\nWith all that said, IMO we have larger existing privacy leaks just due to\nour unique application of the packet format. As an example, a receiver can\nuse the CLTV of the final HTLC to deduce bounds on the path length as we\nhave a restricted topology and CLTV values for public channels are all\nknown. Another leak is our usage of the variable length onion payloads which\na node can use to ascertain path length since they space they consume counts\ntowards the max hop count of 20-something.\n\nIn any case, we can patch this with just a few lines of code (fill out with\nrandom bytes) at _senders_, and don't need any intermediate nodes to update.\nThe new and old packet construction algos are compatible as packet\n_processing_ isn't changing, instead just the starting set of bytes are.\n\nAs always, please double-check by interpretation of the paper, as it's\npossible I'm missing something. If my interpretation stands, then it's a\nrelatively minor privacy leak, and an easy low-hanging fruit that can be\npatched without wide-spread network coordination.\n\n-- Laolu\n\n[1]: https://arxiv.org/abs/1910.13772\n[2]: https://www.iacr.org/cryptodb/archive/2005/CRYPTO/1091/1091.pdf\n[3]: https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf\n[4]:\nhttps://github.com/UCL-InfoSec/sphinx/blob/c05b7034eaffd8f98454e0619b0b1548a9fa0f42/SphinxClient.py#L67\n[5]: https://github.com/lightningnetwork/lightning-onion/pull/40\n[6]: https://github.com/lightningnetwork/lightning-rfc/pull/697\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191105/e776780f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Potential Minor Sphinx Privacy Leak and Patch",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3697
        }
    },
    {
        "title": "[Lightning-dev] HORNET via Circular Self-payment Routing in a Decorrelation Payment Points+Scalar Lightning Network",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-07T10:57:25",
                "message_text_only": "Introduction\n============\n\n[HORNET](https://www.scion-architecture.net/pdf/2015-HORNET.pdf) is a mix network that uses a very secure (and computationally expensive) onion routing to establish sessions.\nThen, once the session is established, it uses a simpler onion routing system, whose security is then dependent on the session-establishment security, but which is computationally simpler on all forwarding nodes.\n\nThere are vague plans to implement some form of HORNET on Lightning, in order to allow e.g. an on-Lightning return path for Stuckless ACK, or communications method for Lightning Offers.\n\nThe Sphinx construction is an onion-routing construction used by HORNET in its session-establishment phase.\nIncidentally, Lightning itself uses the Sphinx construction as the basis for its [payment forwarding specifications](https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md).\n\n[Payment Decorrelation](https://eprint.iacr.org/2018/472.pdf) prevents two cooperating, but distant, intermediate nodes from correlating that forwards going through them are actually the same single payment.\nThis prevents both the \"wormhole\" attack (where they \"shortcut\" the intervening nodes and steal the fees from them) as well as preventing easy monitoring of payments.\nPayment decorrelation requires payment points and scalars to be implemented on the network.\n\nHORNET Session Establishment and Operation\n==========================================\n\n* WARNING: I do not understand the HORNET paper.\n  Thus, mistakes may appear below.\n  The below is not the complete HORNET paper as well, thus a simplification.\n\nIn HORNET, communications between participants must first be packaged into abstractions called \"sessions\".\nThus there are two major phases:\n\n* Setup Phase (Session establishment)\n* Data Transmission Phase\n\nHORNET allows the \"sender\" (the one who initiates the session) maximum privacy.\nThe \"receiver\" (the one contacted in establishing the session) is generally known by the sender as a particular node on the network.\nWith some additional construction, the receiver itself could be hidden from the sender behind another node.\nFor now, I will focus on the HORNET variant with sender anonymity, and leave the sender-receiver anonymity variant as an exercise to the reader.\n\nSetup Phase\n-----------\n\nDuring setup, the sender creates two paths, the \"forward\" path and the \"return\" path.\nThe forward path is from the sender to the receiver, and the receiver path is from the receiver to the sender.\nIdeally, the two paths will have little or no shared nodes between them.\n\nThe sender onion-encrpyts the return path, then puts it into a packet for the receiver.\nThen the packet is onion-encrypted via the forward path.\n\nOn establishment, the sender sends to the first hop of the forward path, which unwraps the onion until it reaches the receiver.\nEach hop also provides a \"forwarding segment\", which is encrypted and forwarded as the onion route is unwrapped.\n(Basically, onion routing means that we \"shift\" the data by one hop; instead of loading zeros into the shifted data, the forwarding node shifts in its forwarding segment)\nThe forwarding segment is a secret that is then used to derive a shared secret with the sender later.\n\nWhen it reaches the receiver, the receiver remembers the existence of the session, then starts unwrapping the return-path onion.\nAgain, it just \"shifts in\" all the forward-path forwarding segments, shifts in its own forwarding segment, and then the nodes along the return path also shift in their own forwarding segments.\n\nWhen the return-path onion arrives at the sender, the sender can decrypt the onion-routed forwarding segments.\nThen, it generates shared secrets with each forwarding node along the path.\n\nThe forward path allows the sender to send messages to the receiver, while the return path allows the receiver to reply to the sender.\n\nData Phase\n----------\n\nThe data phase uses a similar onion-like construction, where each node in the forwarding / return path performs some operation on the packet, then forwards it to the next node until it reaches the receiver / sender.\n\nUsing the shared keys, there are two operations:\n\n* Add layer\n* Remove layer\n\nBoth operations take a key (shared between the sender and the intermediate node), an initialization vector (a nonce), and a packet of data.\nThe operation returns a modified initialization vector\n\nWhen the sender wants to send a message to the receiver:\n\n* The sender starts with the receiver shared secret, and performs \"add layer\" operations in reverse along the forward path from destination to source.\n* It sends out the encrypted packet and the initialization vector to the first intermediate node.\n* Each intermediate node performs \"remove layer\" and forwards the packet and the initialization vector to the next intermediate node.\n* On reaching the receiver, it performs a final \"remove layer\" and extracts the plaintext.\n\nWhen the receiver wants to reply to the sender:\n\n* The receiver performs an \"add layer\" to its plaintext message with a fresh initalization vector.\n* It sends out the encrypted packet and initialization vector to the first intermediate node on the return path.\n* Each intermediate node performs \"add layer\" and forwards the packet and the initialization vector to the next intermediate node.\n* On reaching the sender, it performs \"remove layer\" starting from the last intermediate node and until it reaches the destination node, and extracts the plaintext.\n\nPayment Decorrelation\n=====================\n\nIn payment decorrelation, when an incoming PTLC is received by a forwarding node, the onion packet for that hop also includes a scalar.\nThe forwarding node then multiplies the scalar by the generator, adds it to the incoming point, then creates an outgoing PTLC with the summed point, also forwarding the rest of the onion.\n\nThe onion packet for the payee then includes the sum of all the scalars for all the forwarding nodes, plus another scalar from the payer (to obfuscate whether there are 0 or more forwarding nodes).\nNote that the payee only sees the sum of the scalars.\n\nIn order for the payee to claim the incoming PTLC, it knows its own payment scalar (the proof-of-payment that is revealed to the payer) and adds the given sum.\nThis results in a scalar that can be used to claim the incoming PTLC.\nThen, each forwarding node, on seeing its outgoing PTLC being claimed by revelation of a scalar, subtracts its hop scalar from the outgoing PTLC-revealed scalar, which is the scalar it can use to claim the funds for its own incoming PTLC.\nThis reaches the payer, who subtracts its own scalar in order to acquire the original proof-of-payment scalar, which it can keep as proof of payment, or use in higher-level protocols.\n\nForwarding nodes thus need to somehow have a mapping, from its outgoing PTLC, to a tuple of the hop scalar and the incoming PTLC.\n\nHORNET by Circular Self-Payment\n===============================\n\n* WARNING: This diverges from HORNET as presented in the paper, thus novel cryptography, thus unsafe.\n\nOne might observe, the below crucial parts of HORNET session setup phase:\n\n* The sender must somehow have a shared secret with each intermediate hop.\n* There must be a path from the sender to the receiver, and a path from the receiver to the sender.\n\nWe can make the below observations:\n\n* The hop scalar in path decorrelation is a secret known by each hop, as well as the payer.\n* If we concatenate the HORNET forward path with the return path, we get a circular path that starts where it ends.\n\nThus:\n\n* The single circular path is the entire HORNET session.\n* If we make payer/payee the sender, then the hop scalars provided at each intermediate node is a shared secret between the sender (== payer == payee) and the individual forwarding node, which is what we wanted in the first place during HORNET session setup anyway.\n\nPart of HORNET is to reduce the load on intermediate nodes by resupplying the forwarding segment at each message, so that it is the sender and receiver which needs to remember the existence of the session.\nHowever, the mechanism we need to build for payment decorrelation requires that each forwarding node have a mapping from outgoing PTLC to tuple of hop scalar and incoming PTLC anyway.\nWe simply **ab**use this existing mapping to reduce the data that needs to be sent during the data transmission phase for each packet.\n\nCircular Routing Session Setup\n------------------------------\n\nTo set up our HORNET session, our sender does the following.\n\n* Generates a path from the receiver to itself.\n  * This is actually the *forward* path.\n* Generates a path from itself to the receiver.\n  * This is actually the *return* path.\n* Generates an ordinary payment onion of the concatenation of both paths.\n  * For the onion hop of the receiver, it adds a special TLV that means \"I want to establish a HORNET session with you\".\n    Other intermediate nodes do not get this TLV.\n  * Each hop also must be given a fresh random scalar, which also serves as the shared secret (symmetrical key) between that node and the sender.\n* Sends out the payment onion.\n\nNote that the direction of payment is the *opposite* of the direction of HORNET message flow.\nFor example, if we created a payment path ZmnSCPxj -> Rusty -> YAijbOJA -> ZmnSCPxj, with YAijbOJA as the receiver, then the messages flow in the opposite direction, ZmnSCPxj <- Rusty <- YAijbOJA <- ZmnSCPxj.\nThis is because nodes are keeping a mapping from all outgoing PTLCs to incoming PTLCs and the hop scalar, thus easy access to the hop scalar (and next hop) is available from the *outgoing* direction.\n\nData Transmission\n-----------------\n\nNow that the sender has established a HORNET session, we can transmit messages inside this session.\n\nAs mentioned above, typically, there are separate \"add layer\" and \"remove layer\" encryption operations.\nWe can use a stream cipher, XORed with the plaintext.\nThis gives the following properties:\n\n* \"Add layer\" and \"remove layer\" are the same operation due to XOR.\n* Encryption is commutative.\n* WARNING: This diverges from HORNET as presented in the paper, thus novel cryptography, thus unsafe.\n\nWe can use the existing [ChaCha20](https://tools.ietf.org/html/rfc7539) stream cipher, which is already used in Lightning for the existing payment onion.\nThis provides a 96-bit (12 byte) initialization vector.\n\nThe sender then takes its plaintext message and encrypts it as so:\n\n* Generates an HMAC for the message.\n* Generates a fresh random initialization vector.\n* For each node starting from the last intermediate node to the receiver:\n  * Generates the stream cipher for the initialization vector and the shared key (hop scalar) for that node.\n  * XORs it with the message.\n  * Transmutes the initialization vector (e.g. SHA256 it then truncate to the size of the initialization vector).\n    * Transmuting this is necessary to preserve the decorrelation property.\n    * Transmuting may require also mixing in the hop scalar.\n* Remembers the final state of the initialization vector (as it is needed in order to decrypt the response).\n* Sends the message to the last intermediate node:\n  * HMAC (32 bytes)\n  * Initialization vector (12 bytes) - the original one, not the one that has been transmuted multiple times.\n  * Reference to the PTLC, currently we use (in `update_*_htlc`:\n    * Channel ID (32 bytes)\n    * PTLC index (8 bytes)\n  * The message.\n\nThe above header is \"only\" 84 bytes, and is not repeated for each node.\n\nIntermediate nodes, on receiving the HORNET message, then do:\n\n* Look up the outgoing PTLC to find the hop scalar and the incoming PTLC.\n  * The incoming PTLC includes a reference to the channel, which (should) include a reference to the node with which it formed that channel, thus automatically implies the next hop.\n* Generates the stream cipher for the initialization vector and the hop scalar.\n* XORs it with the message.\n* Transmutes the initialization vector.\n* Forwards to the next node.\n  * The same HMAC.\n  * The transmuted initialization vector.\n  * A reference to the mapped *incoming* PTLC.\n  * The message that has been unwrapped/wrapped once by this node.\n\nThe destination, on receiving the HORNET message, performs the same action as the above but does *not* forward the message.\nInstead, it verifies the HMAC, then reads the plaintext.\n\nOn responding, the destination:\n\n* Generates an HMAC for the message.\n* Generates the stream cipher for the initialization vector and the hope scalar.\n* XORs it wit hthe message.\n* Transmutes the initialization vector.\n* Forwards to the next node.\n\nOnce the response reaches the sender, it:\n\n* Recovers the initialization vector at the destination, which it computed before and stored.\n* For each node starting from the receiver to the first intermediate node:\n  * Generates the stream cipher for the initialization vector and the shared key (hop scalar) for that node.\n  * XORs it with the message.\n  * Transmutes the initialization vector.\n* Verifies the HMAC.\n* Reads the plaintext.\n\nNote that forwarding nodes behave the same regardless if they are on the forward path or the return path.\n\nWhy Lock My Funds???\n====================\n\nWe might wonder if locking up funds on the network in order to establish a HORNET session would be desirable.\n\nThis can be made costly on the sender, discouraging overuse of the HORNET system and preventing people from streaming anime over Lightning.\n\nA forwarding node might decide to throttle HORNET messages according to the following measure\n\n    incoming_ptlc_value - outgoing_ptlc_value\n\nThis is the \"fee\" --- except it will end up not getting paid, because the sender is using a circular self-payment and can simply fail the payment, preventing all fees from being paid.\n\nHowever, for **HORNET**, nodes might advertise an alternative (and much higher) \"fee\" rate.\nThis limits the number of bytes that can be consumed in HORNET messages.\n\nFor example, suppose all nodes on the network require N BTC for its (non-)\"fee\" to send a single HORNET message, after which the node will refuse all forwarding attempts.\nIn order to send a single request-response on a circular route with M nodes, the sender has to lock M * N BTC in its first outgoing channel (assuming a negligible self-payment value).\n\nThis fund could have been used by the sender in order to get more money on the network by providing liquidity, but the sender now has to lock it.\nThus, it is suffering an opportunity cost, proportional to M * N, in keeping its money locked.\nIntermediate nodes can enforce this by subsequently not immediately failing the incoming PTLC depending on whether HORNET messages were sent or not.\nThis enforces that the sender has to lock its funds for a long time period in order to utilize the HORNET mechanism, reducing its liquidity.\n\nThe longer the circular route, the larger M is, and the larger M * N.\nSince the longer M is, the more global bandwidth is spent on sending a single HORNET message (every additional node adds more total Internet bandwidth being used on HORNET messages), this is in fact a quite fair cost to impose on the sender."
            }
        ],
        "thread_summary": {
            "title": "HORNET via Circular Self-payment Routing in a Decorrelation Payment Points+Scalar Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 15171
        }
    },
    {
        "title": "[Lightning-dev] Data Lightning Atomic Swap (DLAS-down, DLAS-up)",
        "thread_messages": [
            {
                "author": "Takaya Imai",
                "date": "2019-11-09T04:31:11",
                "message_text_only": "Hi all,\n\nI propose Data Lightning Atomic Swap.\nAnyone already have the same idea?\n\n\n[Abstract]\nThis proposal is a way to swap data and lightning payment atomically.\nIt has two patterns, one is for a payer to swap data-download with\nlightning payment to a payee (DLAS-down), the other is for a payer to swap\ndata-upload with lightning payment to a payee (DLAS-up).\n\nThe data is embedded to preimage so sending and receiving the data need\nlightning payment at the same time.\n\n---------\n\n[Motivation]\nAtomic Swaps among crypto currencies has various ways to implement\n(on-chain to on-chain[1], on-chain to of-chain(Submarine Swap[2])). And\nAtomic Swaps between data and crypto currencies are also proposed as a part\nof TumbleBit mechanism[3], Storm mechanism[4] and so on.\n\nRecently Joost Jager proposed Instant messages with lightning onion\nrouting, whatsat[5], which use recent sphinx payload change[6]. This is\nvery awesome but not atomic with lightning payment.\n\nAtomic lightning mechanism for data is useful in use cases below.\n\n---------\n\n[Pros & Cons]\n\n* DLAS-down\n** Pros\n*** Atomic data download exchange with lightning payment\n** Cons\n*** It needs better mechanism to expand data size\n\n* DLAS-up\n** Pros\n*** Atomic data upload exchange with lightning payment\n** Cons\n*** OG AMP[7] is needed to implement\n\n---------\n\n[What I describe]\n* A way to swap data with lightning payment atomically.\n\n---------\n\n[What I do not describe]\n* A way to detect that data is correct or not, namely zero knowledge proof\nprocess.\n\nFor example, probabilistic checkable proof like TumbleBit[3] proposed.\nJust message as data is no problem because no need to check the message is\ncorrect or not.\n\n* A way in case that different preimages are used in a payment route like\nMulti-hop locks.\n\n---------\n\n[Specification]\n\nLightning Network(LN) has a mechanism about preimage like a brief image\nbelow.\n\nPayer                             Mediators                            Payee\n=================================================================================\n\nPreimage\nPreimage Hash  <--------------------- invoice ------------------------\n Preimage Hash\nPreimage Hash  ---------------->   Preimage Hash -------------------->\n Preimage Hash\nPreimage       <\u2014-------------\u2014-   Preimage      <--------------------\n Preimage\n\nAs you know, preimage Payer gets can be a proof of payment because Payer\ncan not get it if the payment is executed correctly.\n\n\n\n1, Data download <->  lightning (DLAS-down)\n\n\nPayer sends lightning payment and receives data from Payee atomically.\n\n\nPayer                             Mediators                            Payee\n=================================================================================\nPayer Channel Pubkey <----------------------------------------------->\nPayee Channel Pubkey\n\n\n data(256bit, padded)\n\n enc_key = (Payee Channel Secret Key * Payer Channel Pubkey).x  (256bit)\nenc_key = (Payer Channel Secret Key * Payee Channel Pubkey).x  (256bit)\n\n enc_data = data XOR enc_key\nsha256(enc_data) <--------------------- invoice ----------------------\nsha256(enc_data)\nsha256(enc_data) ----------------> sha256(enc_data) ----------------->\nsha256(enc_data)\nenc_data         <---------------- enc_data <-------------------------\nenc_data\ndata = enc_data XOR enc_key\n\n\n* The size of data is restricted to 256 bits. Identically, it should be\nextended to larger data and the data should be transferred in several\npayment paths like DLAS-up.\n* Channel Pubkey is only one for one channel and the data can be decrypted\nif enc_key is leaked. So enc_key should be generated newly every time by a\nway like hash chain but the protocol image above is just example for\nsimplicity.\n* .x means X axis value of points on Elliptic Curve.\n* If data is less than 256 bits, then 0x00 is padded (I am not sure which\nof big endian and little endian is better).\n\n\n\n2, Data upload <->  lightning (DLAS-down)\n\nPayer sends data and lightning payment from Payee atomically.\nThis is like OG AMP(Atomic Multi-path Payment)[7] system.\n\nPayer                             Mediators                            Payee\n=================================================================================\ndata(512bit, padded)\n\nshare1(256bit)\nshare2(256bit)\n\nbase_s = share1 XOR share2\ndata1(256bit) ||  data2(256bit) = data(512bit)\nXOR_d1 = data1 XOR base_s\nXOR_d2 = data2 XOR base_s\nPreImg1 = sha256(base_s || data || 1)\nPreImg2 = sha256(base_s || data || 2)\n\nsha256(PreImg1), XOR_d1, share1 -> sha256(PreImg1), XOR_d1, share1  ->\nsha256(PreImg1), XOR_d1, share1\nsha256(PreImg2), XOR_d2, share2 -> sha256(PreImg2), XOR_d2, share2  ->\nsha256(PreImg2), XOR_d2, share1\n\n                                                                       base\ns = share1 XOR share2\n                                                                       data\n= (XOR_d1 XOR base_s) || (XOR_d2 XOR base_s)\n\n PreImg1 = sha256(base_s || data || 1)\n\n PreImg2 = sha256(base_s || data || 2)\n\nPreImg1    <-------------------    PreImg1    <---------------------\nPreImg1\nPreImg2    <-------------------    PreImg2    <---------------------\nPreImg2\n\n\n* This protocol example has 512 bits data and they are transferred in two\npaths. However, it can transfer larger data in several payment paths like\n[5].\n* || means string concatenation.\n* If data is less than 512 bits, then 0x00 is padded(I am not sure which of\nbig endian and little endian is better).\n\n\n---------\n\n\n[Use Cases]\n\n1, Lightning Network ecosystem\n\n* Hosting Incentives like Acai Protocol\n** Watchtower Hosting incentive, Backup Hosting incentive\n*** Commitment tx data sending to Data Host(DLAS-up)\n**** Commitment tx data is embedded in preimage so that Payer can not send\nthe data without remittance\n*** Channel backup data receiving from Data Host(DLAS-down)\n**** Channel backup data is embedded in preimage so that Payer can not\nreceive the data without remittance\n\n2, Crypto currency Problems\n\n* Distributed secret key sharing (just come up with an idea though)\n** As a key backup, one of secret key shares is distributed with\nencryption(DLAS-up) to some nodes, which nodes receive lightning payment as\nkey managing fee. And the nodes send a proof for managing the key as\nresponse of bloom filter periodically, and exchange encrypted secret key\nshare with lightning payment to asset holder(DLAS-down).\n** For example 2 out of 3 multi signature key sharing, asset holder puts\nthe first key, the custodial has the second key, and the third key at the\nlightning distribution nodes. Asset holders usually spend assets using\ntheir key and the key on Distributed Nodes.\n\n\n3, Problems so far\n\n* Prevention email spam and DDoS attack with large data\n** Payer can not send email or data without remittance(DLAS-up)\n** Payer can not receive reply-email without remittance(DLAS-down)\n\n* Incentive of receiving advertisements on browser or desktop/mobile app\n** Payer can not send advertisements without remittance(DLAS-up)\n\n* Bounty for code bug fixes based on cryptographic proofs or secret\ncomputations\n** (DLAS-down)\n\n\n\n[References]\n\n[1] https://bitcointalk.org/index.php?topic=321228\n[2] https://twitter.com/roasbeef/status/964608261830750208\n[3] https://eprint.iacr.org/2016/575\n[4] https://github.com/storm-org/storm-spec\n[5] https://twitter.com/joostjgr/status/1190714028626251779\n[6] https://github.com/lightningnetwork/lightning-rfc/pull/619\n[7]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html\n\n\ndocument on github:\nhttps://github.com/takaya-imai/data_lightning_atomic_swap\n\nBest regards,\nTakaya Imai\nEmail: takaya.imai at frontier-ptnrs.com, takaya.imai at unitedbitcoiners.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191109/5f1ce573/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-12T00:13:41",
                "message_text_only": "Good morning Imai-san,\n\nI believe for the download case this is superior: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002035.html\nThis has no restriction on the size of the data.\n\nFor the upload case, it seems for either OG AMP or with payment points + scalars and payment decorrelation, the summed blinding factor (i.e. the data sent in response to ACK in Stuckless) can be used to send data to the payee, by using an encryption key as well.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Data Lightning Atomic Swap (DLAS-down, DLAS-up)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Takaya Imai",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 8314
        }
    },
    {
        "title": "[Lightning-dev] Payment points without 2p-ECDSA or Schnorr",
        "thread_messages": [
            {
                "author": "uSEkaCIO",
                "date": "2019-11-11T08:12:46",
                "message_text_only": "Hi list,\n\nIt is generally believed that in order to do \"payment points\" we need either the two party multisignature scheme 2p-ECDSA or 2p-Schnorr.\n\nI think we can do it without them.\n\nTL;DR Just use 2-of-2 OP_CHECKMULTISIG and do a single signer ECDSA adaptor signature on one of the keys.\n\nBackground\n---------------\nThere are many nice features that could be enabled by using \"payment points\" instead of hashes as the core lock mechanism for lightning as discussed in the threads below. The consensus from these threads seems to be that it is best to wait for BIP-Schnorr/Taporoot to hit (which could be years away) than to try and implement and specify a 2p-ECDSA protocol (which I think is very wise).\n\nMarch'17:\u00a0 Andrew demonstrates scripltess lightning:\u00a0\u00a0https://lists.launchpad.net/mimblewimble/msg00086.html\nApr'18:\u00a0 Pedro shows you can do it for ECDSA:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html\u00a0\nNov'18: Long discussion on the impact of scriptless scripts:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001489.html\nOct'19: ZmnSCPxj shares thoughts on the choice between 2p-ECDSA and waiting for Schnorr:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002211.html\n\nThe core idea I will present is that the 2pECDSA adaptor signature Pedro and Aniket introduced can be applied to\u00a0single signer ECDSA and OP_CHECKMULTISIG can fill the gap.\n\nPayment points today, without 2p-ECDSA, Hip hip Hoorayy!\n--------------------------------------------------------\n\nHere's how to create the core discrete log based lock required to do payment points without a proper multisignature scheme. Let's say Alice wants to give Bob 1 BTC if he can reveal y, the discrete log of Y to her.\n\n1. Alice tells Bob about her public key A, her 1 BTC input and her refund address\n2. Bob tells Alice about his public key B and his redeem address\n3. They both can calculate the txid of the fund transaction which spends Alice's inputs to an OP_CHECKMULTISIG 2-of-2 with A B as the keys\n4. Bob also sends to Alice a signature under B on a refund transaction spending the OP_CMS output to her refund address\n5. Alice sends an adaptor signature under A with \"auxiliary point\" Y on the redeem transaction which spends the OP_CMS output to Bob's redeem address\n6. Bob completes the adaptor signature under A with y and makes his own signature on the redeem tx under B and broadcasts it.\n7. Alice sees the redeem tx and her completed signature and extracts y from it.\n\nNote that Y or y never go on-chain, all anyone sees is a plain 2-of-2 OP_CMS.\n\nSingle Signer ECDSA adaptor signatures\n--------------------------------------\n\nFor the completeness of this post I'll show my version of the single signer ECDSA adaptor algorithms (please verify). This is just a single signer protocol translated from Pedro and Aniket's original work. The only semi-exotic thing is the DLEQ proof. A description of the interactive protocol can be found in https://cs.nyu.edu/courses/spring07/G22.3220-001/lec3.pdf (and can be made non-interactive by Fiat-Shamir transform).\n\n// Sign such that y = DLOG(Y) is needed to complete signature\nAdaptorSign((x,X),Y,m):\n1. Choose k randomly, R' = k*G\n2. R = k*Y;\n4. proof = DLEQ_prove((G,R'),(Y, R))\n5. s' = k\u207b\u00b9(H(m) + x_coord(R)x)\n6. return (R, R', s', proof)\n\n// Verify Adaptor signature is correct for the given message and keys\nAdaptorVerify(X, Y, m , (R, R', s', proof))\n1. DLEQ_verify((G,R'),(Y, R))\n2. return x_coord(R') == x_coord(s'\u207b\u00b9(H(m) * G + x_coord(R) * X))\n\n// Complete the adaptor with the secret\nAdaptorComplete(y, (R, R', s', proof))\ns = s'y\u207b\u00b9\nreturn (x_coord(R),s)\n\n// Extract y from the completed adaptor\nAdaptorExtract(s',s, Y)\ny' = s\u207b\u00b9s'\nreturn y' * G == -Y ? -y : y; // Deal with ECDSA malleability\n\nSecurity\n--------\nI am doing a security analysis on this scheme in a paper that will be in review soon (which is why I am posting this anonymously). Unlike in 2pECDSA case, the DLEQ NIZK proof is the only proof required. However, there is one flaw in scheme that I should warn about: from the ECDSA adaptor signature you can calculate the Diffie-Hellman key between the signer's key X and the auxiliary point Y e.g x*Y = y*X (to see this start with s'*R and go from there). Therefore care should be taken when composing this with any scheme that relies on the Computational Diffie-Hellman assumption. In practice, I don't know of any proposal that would be affected by this. Keep in mind that X and Y are usually both transient keys and so learning a DDH keys doesn't help an attacker at all.\n\nDiscussion\n----------\n\nUsing this scheme I think it's possible to do anything you can do with 2p-ECSA/Schnorr scriptless scripts except that instead of a normal p2pkh/public key output you have a 2-of-2 OP_CMS P2WSH output. Aside from this the scheme has some nice advantages:\n\n\n1. The key exchange protocol is far simpler than 2pECDSA and simpler even than 2pSchnorr. This makes it a natural step up in complexity from the current HTLCs towards Schnorr (2pECDSA is like 5 steps up in complexity and then 3 down towards Schnorr).\n2. Because of its simplicity it is much easier to specify -- A single BOLT spec could cover the key generation, transaction structure and signing without too much pain (actually trying to write and review the spec for 2pECDSA would take far longer)\n3. The actual transaction structure can be moved towards the ideal Schnorr based endpoint (i.e. almost completely scriptless except for OP_CMS) or you could even keep the transaction structure the same as it is today and just replace the pre-image spending path in script with OP_CMS\n\nI think this is practical but there are still a number of ways you could go about it so I'd be interested to hear your thoughts. Any feedback on this would be greatly appreciated :)\n\nCheers,\n\nuSEkaCIO"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-11T14:01:59",
                "message_text_only": "Good morning uSEkaCIO,\n\nThis is certainly interesting, though I lack the mathematical background to double-check this.\n\nI believe ajtowns has a SCRIPT useable today that enables payment points as well, using 3 `OP_CODESEPARATOR`s.\nThis was rejected in the Adelaide meeting in 2018, I believe partly because `OP_CODESEPARATOR` is difficult enough to understand by itself, and having a SCRIPT that used 3 of them was an even bigger difficulty.\nAnother is that it required three different signatures in the witness as well, if my memory serves correctly.\n\nRegards,\nZmnSCPXj\n\n\n> Hi list,\n>\n> It is generally believed that in order to do \"payment points\" we need either the two party multisignature scheme 2p-ECDSA or 2p-Schnorr.\n>\n> I think we can do it without them.\n>\n> TL;DR Just use 2-of-2 OP_CHECKMULTISIG and do a single signer ECDSA adaptor signature on one of the keys.\n>\n> Background\n>\n> --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n>\n> There are many nice features that could be enabled by using \"payment points\" instead of hashes as the core lock mechanism for lightning as discussed in the threads below. The consensus from these threads seems to be that it is best to wait for BIP-Schnorr/Taporoot to hit (which could be years away) than to try and implement and specify a 2p-ECDSA protocol (which I think is very wise).\n>\n> March'17:\u00a0 Andrew demonstrates scripltess lightning:\u00a0\u00a0https://lists.launchpad.net/mimblewimble/msg00086.html\n> Apr'18:\u00a0 Pedro shows you can do it for ECDSA:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html\u00a0\n> Nov'18: Long discussion on the impact of scriptless scripts:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001489.html\n> Oct'19: ZmnSCPxj shares thoughts on the choice between 2p-ECDSA and waiting for Schnorr:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002211.html\n>\n> The core idea I will present is that the 2pECDSA adaptor signature Pedro and Aniket introduced can be applied to\u00a0single signer ECDSA and OP_CHECKMULTISIG can fill the gap.\n>\n> Payment points today, without 2p-ECDSA, Hip hip Hoorayy!\n>\n> ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n>\n> Here's how to create the core discrete log based lock required to do payment points without a proper multisignature scheme. Let's say Alice wants to give Bob 1 BTC if he can reveal y, the discrete log of Y to her.\n>\n> 1.  Alice tells Bob about her public key A, her 1 BTC input and her refund address\n> 2.  Bob tells Alice about his public key B and his redeem address\n> 3.  They both can calculate the txid of the fund transaction which spends Alice's inputs to an OP_CHECKMULTISIG 2-of-2 with A B as the keys\n> 4.  Bob also sends to Alice a signature under B on a refund transaction spending the OP_CMS output to her refund address\n> 5.  Alice sends an adaptor signature under A with \"auxiliary point\" Y on the redeem transaction which spends the OP_CMS output to Bob's redeem address\n> 6.  Bob completes the adaptor signature under A with y and makes his own signature on the redeem tx under B and broadcasts it.\n> 7.  Alice sees the redeem tx and her completed signature and extracts y from it.\n>\n>     Note that Y or y never go on-chain, all anyone sees is a plain 2-of-2 OP_CMS.\n>\n>     Single Signer ECDSA adaptor signatures\n>\n>\n> For the completeness of this post I'll show my version of the single signer ECDSA adaptor algorithms (please verify). This is just a single signer protocol translated from Pedro and Aniket's original work. The only semi-exotic thing is the DLEQ proof. A description of the interactive protocol can be found inhttps://cs.nyu.edu/courses/spring07/G22.3220-001/lec3.pdf (and can be made non-interactive by Fiat-Shamir transform).\n>\n> // Sign such that y = DLOG(Y) is needed to complete signature\n> AdaptorSign((x,X),Y,m):\n>\n> 1.  Choose k randomly, R' = k*G\n> 2.  R = k*Y;\n> 3.  proof = DLEQ_prove((G,R'),(Y, R))\n> 4.  s' = k\u207b\u00b9(H(m) + x_coord(R)x)\n> 5.  return (R, R', s', proof)\n>\n>     // Verify Adaptor signature is correct for the given message and keys\n>     AdaptorVerify(X, Y, m , (R, R', s', proof))\n>\n> 6.  DLEQ_verify((G,R'),(Y, R))\n> 7.  return x_coord(R') == x_coord(s'\u207b\u00b9(H(m) * G + x_coord(R) * X))\n>\n>     // Complete the adaptor with the secret\n>     AdaptorComplete(y, (R, R', s', proof))\n>     s = s'y\u207b\u00b9\n>     return (x_coord(R),s)\n>\n>     // Extract y from the completed adaptor\n>     AdaptorExtract(s',s, Y)\n>     y' = s\u207b\u00b9s'\n>     return y' * G == -Y ? -y : y; // Deal with ECDSA malleability\n>\n>     Security\n>\n>\n> I am doing a security analysis on this scheme in a paper that will be in review soon (which is why I am posting this anonymously). Unlike in 2pECDSA case, the DLEQ NIZK proof is the only proof required. However, there is one flaw in scheme that I should warn about: from the ECDSA adaptor signature you can calculate the Diffie-Hellman key between the signer's key X and the auxiliary point Y e.g xY = yX (to see this start with s'*R and go from there). Therefore care should be taken when composing this with any scheme that relies on the Computational Diffie-Hellman assumption. In practice, I don't know of any proposal that would be affected by this. Keep in mind that X and Y are usually both transient keys and so learning a DDH keys doesn't help an attacker at all.\n>\n> Discussion\n>\n> -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n>\n> Using this scheme I think it's possible to do anything you can do with 2p-ECSA/Schnorr scriptless scripts except that instead of a normal p2pkh/public key output you have a 2-of-2 OP_CMS P2WSH output. Aside from this the scheme has some nice advantages:\n>\n> 1.  The key exchange protocol is far simpler than 2pECDSA and simpler even than 2pSchnorr. This makes it a natural step up in complexity from the current HTLCs towards Schnorr (2pECDSA is like 5 steps up in complexity and then 3 down towards Schnorr).\n> 2.  Because of its simplicity it is much easier to specify -- A single BOLT spec could cover the key generation, transaction structure and signing without too much pain (actually trying to write and review the spec for 2pECDSA would take far longer)\n> 3.  The actual transaction structure can be moved towards the ideal Schnorr based endpoint (i.e. almost completely scriptless except for OP_CMS) or you could even keep the transaction structure the same as it is today and just replace the pre-image spending path in script with OP_CMS\n>\n>     I think this is practical but there are still a number of ways you could go about it so I'd be interested to hear your thoughts. Any feedback on this would be greatly appreciated :)\n>\n>     Cheers,\n>\n>     uSEkaCIO\n>\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "uSEkaCIO",
                "date": "2019-11-12T07:32:11",
                "message_text_only": "Hi Lisa and ZmnSCPxj,\n\nLisa,\n\n>\u202aDoes the \u201cadditive blinding\u201d scheme andrew lays out here[1] work for this scheme, or is that only a property of Schnorr sigs? (i.e. are disparate Y\u2019s additive across sigs?)\u202c\n\nYep I think that anything that works with a single joint Schnorr public key can be transformed into the single-signer-ECDSA+OP_CMS form I laid out. Everything works exactly the same except that you have OP_CMS and do single signer adaptor signature rather than a joint adaptor signature.\n\nZmnSCPxj,\n\n>\u00a0I believe ajtowns has a SCRIPT useable today that enables payment points as well, using 3 `OP_CODESEPARATOR`s. This was rejected in the Adelaide meeting in 2018, I believe partly because `OP_CODESEPARATOR` is difficult enough to understand by itself, and having a SCRIPT that used 3 of them was an even bigger difficulty. Another is that it required three different signatures in the witness as well, if my memory serves correctly.\n\nAhh so that's what was meant by \"script magic\" in those threads. I thought it meant adding a new opcode. I found references\u00a0[1,2]\u00a0which discuss the idea. This is very clever. I had never seen OP_CODESEPARATOR usefully before. It looks like it actually requires six signatures in total (3 OP_CMS). The other downside is it would let you identify the payment point from the transaction.\n\nAside from not revealing the payment point on-chain, my proposal also has the advantage of taking less witness data than the current spec without adding much complexity. Though how much will depend on how you do revocation. One simple thing that could work would be for Alice to simply reveal the private key for her public key in the OP_CMS to Bob (and for Bob to reveal B on his side). In other words on Alice's state she has a OP_CMS(A,B) output and on Bob's state he has OP_CMS(A',B') output. To revoke her state Alice reveals the private key for A to Bob and to revoke on Bob's side Bob reveals the private key for B'.\n\nCheers,\n\nUSEkaCIO\n\n[1] https://bitcoin.stackexchange.com/questions/85936/bitcoin-scripts-that-force-disclosure-of-the-private-key\n[2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000344.html\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, 12 November 2019 01:01, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning uSEkaCIO,\n>\n> This is certainly interesting, though I lack the mathematical background to double-check this.\n>\n> I believe ajtowns has a SCRIPT useable today that enables payment points as well, using 3 `OP_CODESEPARATOR`s.\n> This was rejected in the Adelaide meeting in 2018, I believe partly because `OP_CODESEPARATOR` is difficult enough to understand by itself, and having a SCRIPT that used 3 of them was an even bigger difficulty.\n> Another is that it required three different signatures in the witness as well, if my memory serves correctly.\n>\n> Regards,\n> ZmnSCPXj\n>\n> > Hi list,\n> > It is generally believed that in order to do \"payment points\" we need either the two party multisignature scheme 2p-ECDSA or 2p-Schnorr.\n> > I think we can do it without them.\n> > TL;DR Just use 2-of-2 OP_CHECKMULTISIG and do a single signer ECDSA adaptor signature on one of the keys.\n> > Background\n> >\n> > There are many nice features that could be enabled by using \"payment points\" instead of hashes as the core lock mechanism for lightning as discussed in the threads below. The consensus from these threads seems to be that it is best to wait for BIP-Schnorr/Taporoot to hit (which could be years away) than to try and implement and specify a 2p-ECDSA protocol (which I think is very wise).\n> > March'17:\u00a0 Andrew demonstrates scripltess lightning:\u00a0\u00a0https://lists.launchpad.net/mimblewimble/msg00086.html\n> > Apr'18:\u00a0 Pedro shows you can do it for ECDSA:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html\u00a0\n> > Nov'18: Long discussion on the impact of scriptless scripts:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001489.html\n> > Oct'19: ZmnSCPxj shares thoughts on the choice between 2p-ECDSA and waiting for Schnorr:\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002211.html\n> > The core idea I will present is that the 2pECDSA adaptor signature Pedro and Aniket introduced can be applied to\u00a0single signer ECDSA and OP_CHECKMULTISIG can fill the gap.\n> > Payment points today, without 2p-ECDSA, Hip hip Hoorayy!\n> >\n> > Here's how to create the core discrete log based lock required to do payment points without a proper multisignature scheme. Let's say Alice wants to give Bob 1 BTC if he can reveal y, the discrete log of Y to her.\n> >\n> > 1.  Alice tells Bob about her public key A, her 1 BTC input and her refund address\n> >\n> > 2.  Bob tells Alice about his public key B and his redeem address\n> >\n> > 3.  They both can calculate the txid of the fund transaction which spends Alice's inputs to an OP_CHECKMULTISIG 2-of-2 with A B as the keys\n> >\n> > 4.  Bob also sends to Alice a signature under B on a refund transaction spending the OP_CMS output to her refund address\n> >\n> > 5.  Alice sends an adaptor signature under A with \"auxiliary point\" Y on the redeem transaction which spends the OP_CMS output to Bob's redeem address\n> >\n> > 6.  Bob completes the adaptor signature under A with y and makes his own signature on the redeem tx under B and broadcasts it.\n> >\n> > 7.  Alice sees the redeem tx and her completed signature and extracts y from it.\n> >     Note that Y or y never go on-chain, all anyone sees is a plain 2-of-2 OP_CMS.\n> >     Single Signer ECDSA adaptor signatures\n> >\n> >\n> > For the completeness of this post I'll show my version of the single signer ECDSA adaptor algorithms (please verify). This is just a single signer protocol translated from Pedro and Aniket's original work. The only semi-exotic thing is the DLEQ proof. A description of the interactive protocol can be found inhttps://cs.nyu.edu/courses/spring07/G22.3220-001/lec3.pdf (and can be made non-interactive by Fiat-Shamir transform).\n> > // Sign such that y = DLOG(Y) is needed to complete signature\n> > AdaptorSign((x,X),Y,m):\n> >\n> > 1.  Choose k randomly, R' = k*G\n> >\n> > 2.  R = k*Y;\n> >\n> > 3.  proof = DLEQ_prove((G,R'),(Y, R))\n> >\n> > 4.  s' = k\u207b\u00b9(H(m) + x_coord(R)x)\n> >\n> > 5.  return (R, R', s', proof)\n> >     // Verify Adaptor signature is correct for the given message and keys\n> >     AdaptorVerify(X, Y, m , (R, R', s', proof))\n> >\n> > 6.  DLEQ_verify((G,R'),(Y, R))\n> >\n> > 7.  return x_coord(R') == x_coord(s'\u207b\u00b9(H(m) * G + x_coord(R) * X))\n> >     // Complete the adaptor with the secret\n> >     AdaptorComplete(y, (R, R', s', proof))\n> >     s = s'y\u207b\u00b9\n> >     return (x_coord(R),s)\n> >     // Extract y from the completed adaptor\n> >     AdaptorExtract(s',s, Y)\n> >     y' = s\u207b\u00b9s'\n> >     return y' * G == -Y ? -y : y; // Deal with ECDSA malleability\n> >     Security\n> >\n> >\n> > I am doing a security analysis on this scheme in a paper that will be in review soon (which is why I am posting this anonymously). Unlike in 2pECDSA case, the DLEQ NIZK proof is the only proof required. However, there is one flaw in scheme that I should warn about: from the ECDSA adaptor signature you can calculate the Diffie-Hellman key between the signer's key X and the auxiliary point Y e.g xY = yX (to see this start with s'*R and go from there). Therefore care should be taken when composing this with any scheme that relies on the Computational Diffie-Hellman assumption. In practice, I don't know of any proposal that would be affected by this. Keep in mind that X and Y are usually both transient keys and so learning a DDH keys doesn't help an attacker at all.\n> > Discussion\n> >\n> > Using this scheme I think it's possible to do anything you can do with 2p-ECSA/Schnorr scriptless scripts except that instead of a normal p2pkh/public key output you have a 2-of-2 OP_CMS P2WSH output. Aside from this the scheme has some nice advantages:\n> >\n> > 1.  The key exchange protocol is far simpler than 2pECDSA and simpler even than 2pSchnorr. This makes it a natural step up in complexity from the current HTLCs towards Schnorr (2pECDSA is like 5 steps up in complexity and then 3 down towards Schnorr).\n> >\n> > 2.  Because of its simplicity it is much easier to specify -- A single BOLT spec could cover the key generation, transaction structure and signing without too much pain (actually trying to write and review the spec for 2pECDSA would take far longer)\n> >\n> > 3.  The actual transaction structure can be moved towards the ideal Schnorr based endpoint (i.e. almost completely scriptless except for OP_CMS) or you could even keep the transaction structure the same as it is today and just replace the pre-image spending path in script with OP_CMS\n> >     I think this is practical but there are still a number of ways you could go about it so I'd be interested to hear your thoughts. Any feedback on this would be greatly appreciated :)\n> >     Cheers,\n> >     uSEkaCIO\n> >\n> >\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Payment points without 2p-ECDSA or Schnorr",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "uSEkaCIO",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 23959
        }
    },
    {
        "title": "[Lightning-dev] Doubt regarding payment channel capacity",
        "thread_messages": [
            {
                "author": "Subhra Mazumdar",
                "date": "2019-11-14T17:07:57",
                "message_text_only": "Hello everyone,\n       My doubt might be silly and apologies for the same. Suppose in a\npayment channel network say 2 parties B and C are malicious, controlled by\nsame adversary. They had initially opened a channel of 1 BTC. But suppose\nthey get 3 transaction request will flow value of 0.4 BTC each. After 1st 2\ntransaction, B and C has capacity of 0.2 BTC. But  what if BC reports an\nincorrect residual balance thereby accepting the 3rd transaction. Who will\nkeep track of this capacity violation since no one is keeping track of this\nresidual value ? If this case is true, then parties might resort to such a\nstrategy opening a low value channel but still accepting multiple\ntransactions where the total payment value of all transaction exceeds\nchannel capacity. Please correct me if I am wrong.\n\n-- \nYours sincerely,\nSubhra Mazumdar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191114/6fd53121/attachment.html>"
            },
            {
                "author": "fiatjaf",
                "date": "2019-11-14T17:42:02",
                "message_text_only": "Hello,\n\nWhat happens between two peers is no business of others. They can do what\nyou said if they're cooperating, and many other dirty tricks. And that's\nnot a problem at all for other nodes.\n\nThe only thing they can't do for not is advertise a channel without telling\nothers where it was funded on the chain, but that's just for antispam\nreasons (as other nodes must keep track of all announced channels) as far\nas I know.\n\nOn Thursday, November 14, 2019, Subhra Mazumdar <\nsubhra.mazumdar1993 at gmail.com> wrote:\n> Hello everyone,\n>        My doubt might be silly and apologies for the same. Suppose in a\npayment channel network say 2 parties B and C are malicious, controlled by\nsame adversary. They had initially opened a channel of 1 BTC. But suppose\nthey get 3 transaction request will flow value of 0.4 BTC each. After 1st 2\ntransaction, B and C has capacity of 0.2 BTC. But  what if BC reports an\nincorrect residual balance thereby accepting the 3rd transaction. Who will\nkeep track of this capacity violation since no one is keeping track of this\nresidual value ? If this case is true, then parties might resort to such a\nstrategy opening a low value channel but still accepting multiple\ntransactions where the total payment value of all transaction exceeds\nchannel capacity. Please correct me if I am wrong.\n>\n> --\n> Yours sincerely,\n> Subhra Mazumdar.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191114/2ebb3c12/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-16T03:43:58",
                "message_text_only": "Good morning list,\n\nSome hundred or so blocks ago, lightning-dev emails were being undelivered.\nIt seems okay now.\n\nThere was a long discussion I had with Subhra at the time, unfortunately it ended up being off-list due to the mailing list being down.\nIn any case, I believe it would be of interest, and thus below is the emails involved.\n\nRegards.\nZmnSCPxj\n\n> Good morning Subhra,\n>\n> > Hello,\n> > \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Thanks a lot for the detailed explanation. It justifies why this attack may not sustain quite long in the network.\u00a0Another question regarding routing then. It is assumed that when channels are probed for routing, it will be checked whether there is enough balance in the channel to route the payment or not. But the only view which one has of the channel is the initial capacity of the channel and not the balance of the channel at that moment. What if the pair of nodes in a channel are byzantine and reports a wrong value of residual balance ? Consider the previous example where B and C may have locked some amount between them say 1 BTC but B and C are part of one collective controlled by an adversary. What if BC gets routing request for 20 transaction, each having payment value of 0.1 BTC ? Again the case may be that T_i channel with B (i \\in [1,20]), each channel T_i,B having capacity of 0.3 BTC and C has channel with D_i (i \\in 1 to 20), each having channel capacity of 0.3 BTC. So now in this case it doesn't matter what balance BC has, it just goes on reporting a balance of 0.1 BTC to accept all routing request till lifetime of the channel, but in reality it is not locking any fund at all. So is this possible where a wrong information of channel's balance is reported ?\n>\n> You strongly misunderstand.\n>\n> Neither B nor C can misreport the funds in the channel, for the following very simple reason:\n>\n> -   There is no facility to actually remotely report the channel balance.\n>\n>     Thus this is still not a problem.\n>\n>     Nobody else particularly cares what the exact balance is on the B<->C channel (because if they were econmically-separate entities and had a good amount of traffic with the network, then the exact balance would have changed by the time you receive the information anyway, so why bother asking?).\n>\n>\n> Everybody else only cares whether it is possible to route via the B<->C channel or not.\n> That is all that is reported: whether an HTLC of amount X can be routed right now, or not.\n> In your case, it would mean that B and C would always report that it can be routed right now, but so?\n> It just means increased payment reliability on the rest of the network (and reflects the truth as well: B and C are the same entity anyway, thus the reliability of the B<->C channel is equivalent to the reliability of the B C aggregate).\n>\n> There is no way for B and C to somehow promote this into an attack on the network.\n>\n> Fundamentally speaking, if B and C are the same economic entity, then the B<->C channel (which has to be backed by some UTXO, else it cannot be announced on Lightning) is no different from that single economic entity keeping some funds on a hot online wallets.\n>\n> If an entity keeping some funds in a hot wallet has no effect on the Lightning Network, then the existence of the B<->C channel also has no effect on the Lightning Network.\n> Economically speaking, if you are going to put funds in a hot wallet anyway, on a computer you are obligated to keep online 144 blocks a day, 2016 blocks a difficulty adjustment, then you might as well put those funds in a real, externally-earning channel on the Lightning Network, but I made that argument already anyway.\n>\n> Regards,\n> ZmnSCPxj\n>\n> > On Fri, Nov 15, 2019 at 12:46 PM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> >\n> > > Good morning Subhra,\n> > >\n> > > > So that means its not a problem if the cluster size increases from B->C to B->C->X->Y->Z ? I mean we still get a successful payment but is not at the cost of A locking greater processing fee for the intermediate node B,C,X,Y and Z even though they are one single entity ? Unnecessarily there is an increase in the path length, plus in this way B can spawn several such dummy nodes in order to gain processing fee. Sorry if I am not getting it correctly but as you have pointed out if there is a single node Q between A and D then obviously that will be preferred. But what if there is no alternate route available to A in order to reach D and A->B->C->D is the only option ?\n> > >\n> > > Yes, it is not a problem at all.\n> > > It is helpful to remember that the channels B<->C, C<->X, X<->Y, and Y<->Z require being backed on the blockchain, and requires money to be allocated for it.\n> > > This money could have been used elsewhere on the network to serve as shortcuts between other nodes, not just to artificially lengthen the path between A and D.\n> > > Thus, this represents an opportunity cost on the aggregate B C X Y Z nodes.\n> > > Let us compare between two universes:\n> > >\n> > > -   B C X Y Z make a path between A and D only.\n> > > -   B makes a path between A and D.\n> > >     \u00a0 C makes a path between a different pair of nodes.\n> > >     \u00a0 X makes a path between yet another pair.\n> > >     \u00a0 Y makes a path between yet another pair again.\n> > >     \u00a0 Z makes a path between yet yet another pair again again.\n> > >\n> > >\n> > > It is far more likely that the aggregate B C X Y Z will earn more, and more consistently, in the second universe, than in the first.\n> > >\n> > > -   The first universe will only net B C X Y Z some money if A and D pay each other.\n> > >     \u00a0 The second universe will net B C X Y Z some money if any of the pairs pay each other.\n> > >     \u00a0 This leads to a more consistent earnings overall (this is the same argument that pushes miners towards pools).\n> > >\n> > > -   The second universe has B C X Y Z be the shortest path between many pairs of nodes.\n> > >     \u00a0 This makes it more likely that they will be selected in payments between them.\n> > >     \u00a0 This leads to increased earnings overall in the second universe.\n> > >\n> > >\n> > > Thus, anyone who is foolish enough to create such a chain of nodes would, in the long run, lose out on earnings than if they just had multiple nodes creating shortest paths between as many nodes as they can afford to make.\n> > > In short, this is economically irrational behavior.\n> > > Always remember that if the fees between A and D become too onerous, then A and D might decide that the onchain fee to open a direct channel between them would be amortized cheaper than paying the long chain of nodes between them, immediately destroying the ability of the B C X Y Z aggregate to earn funds.\n> > > So this is not a problem.\n> > > Economic rationality will lead to such behavior being selected against, and such attacks will be routed around.\n> > > Indeed, my proposal for `getroutequick` bases the expected `O(log n)` routing behavior on the observation that such long chains must be made artificially and cannot survive for long, thus the shortest-path tree will be approximately balanced and the height of the tree will be `O(log n)` for all layouts of the network, even as the network size `n` grows..\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > > On Fri, Nov 15, 2019 at 9:36 AM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> > > >\n> > > > > Good morning Subhra and fiatjaf,\n> > > > > This is fine, and not in fact a problem.\n> > > > > B and C might be separate entities \"on paper\", but econmically, they are still just a single entity.\n> > > > > What matters is that the aggregate B and C cannot steal from someone who is not part of the collective.\n> > > > > And that is maintained simply by other nodes requiring that the channels between B and them, and C and them, have the correct balance.\n> > > > > In short, a network A <-> B <-> C <-> D and a network A <-> Q <-> D, where B and C are \"really\" the same entity (they are cooperating with each other very closely), are indistinguishable from each other.\n> > > > > Now of course the B<->C option means that A and D will now have to pay more fees to traverse that subnetwork, but that also means greater scope for an independent Q to undercut B<->C by just running a single node and connecting between A and D directly.\n> > > > > i.e. This is not a problem.\n> > > > > The funds locked in channel B <-> C remain owned by the aggregate B and C, and onchain will just be exactly the capacity they put in there in aggregate.\n> > > > > And this cannot be used to outright steal from other nodes.\n> > > > > Even routing cannot be stolen, since payers will prefer a single node Q over the aggregate nodes B<->C, and Q does not need to maintain some funds locked in a B<->C channel, thus Q has the advantage here.\n> > > > > Regards,\n> > > > > ZmnSCPxj\n> > > > >\n> > > > > > Hello,\n> > > > > > What happens between two peers is no business of others. They can do what you said if they're cooperating, and many other dirty tricks. And that's not a problem at all for other nodes.\n> > > > > > The only thing they can't do for not is advertise a channel without telling others where it was funded on the chain, but that's just for antispam reasons (as other nodes must keep track of all announced channels) as far as I know.\n> > > > > > On Thursday, November 14, 2019, Subhra Mazumdar subhra.mazumdar1993 at gmail.com wrote:\n> > > > > >\n> > > > > > > Hello everyone,\n> > > > > > > \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 My doubt might be silly and apologies for the same. Suppose in a payment channel network say 2 parties B and C are malicious, controlled by same adversary. They had initially opened a channel of 1 BTC. But suppose they get 3 transaction request will flow value of 0.4 BTC each. After 1st 2 transaction, B and C has capacity of 0.2 BTC. But\u00a0 what if BC reports an incorrect residual balance thereby accepting the 3rd transaction. Who will keep track of this capacity violation since no one is keeping track of this residual value ? If this case is true, then parties might resort to such a strategy opening a low value channel but still accepting multiple transactions where the total payment value of all transaction exceeds channel capacity. Please correct me if I am wrong.\n> > > > > > > --\n> > > > > > > Yours sincerely,\n> > > > > > > Subhra Mazumdar.\n> > > >\n> > > > --\n> > > > Yours sincerely,\n> > > > Subhra Mazumdar.\n> >\n> > --\n> > Yours sincerely,\n> > Subhra Mazumdar."
            }
        ],
        "thread_summary": {
            "title": "Doubt regarding payment channel capacity",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "fiatjaf",
                "Subhra Mazumdar",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12945
        }
    },
    {
        "title": "[Lightning-dev] Lightning-dev down",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-16T03:41:32",
                "message_text_only": "Good morning list,\n\nA hundred to two hundred blocks ago, it seems the list was down, and messages to the list were not deliverable.\nThis email also doubles as a test on whether the list is still down today.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bryan Bishop",
                "date": "2019-11-16T13:41:59",
                "message_text_only": "ZmnSCPxj,\n\nOn Fri, Nov 15, 2019 at 9:41 PM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> A hundred to two hundred blocks ago, it seems the list was down, and\n> messages to the list were not deliverable.\n> This email also doubles as a test on whether the list is still down today.\n>\n\nThe mailing lists are in the process of being migrated to a new server.\nMore information will follow soon.\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191116/06e09e1c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning-dev down",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 904
        }
    },
    {
        "title": "[Lightning-dev] eltoo towers and implications for settlement key derivation",
        "thread_messages": [
            {
                "author": "Conner Fromknecht",
                "date": "2019-11-26T23:41:14",
                "message_text_only": "Hi all,\n\nI recently revisited the eltoo paper and noticed some things related\nwatchtowers that might affect channel construction.\n\nDue to NOINPUT, any update transaction _can_ spend from any other, so\nin theory the tower only needs the most recent update txn to resolve\nany dispute.\n\nIn order to spend, however, the tower must also produce a witness\nscript which when hashed matches the witness program of the input. To\nensure settlement txns can only spend from exactly one update txn,\neach update txn uses unique keys for the settlement clause, meaning\nthat each state has a _unique_ witness program.\n\nNaively then a tower could store settlement keys for all states,\npermitting it to reconstruct arbitrary witness scripts for any given\nsequence of confirmed update txns.\n\nSo far, the only work around I\u2019ve come up with to avoid this is to\ngive the tower an extended parent pubkey for each party, and then\nderive non-hardened settlement keys on demand given the state numbers\nthat get confirmed. It's not the most satisfactory solution though,\nsince leaking one hot settlement key now compromises all sibling\nsettlement keys.\n\nSpending the unique witness programs is mentioned somewhat in section\n4.1.4, which refers to deriving keys via state numbers, but to me it\nreads mostly from the PoV of the counterparties and not a third-party\nservice. Is requiring non-hardened keys a known consequence of the\nconstruction? Are there any alternative approaches folks are aware of?\n\nCheers,\nConner"
            }
        ],
        "thread_summary": {
            "title": "eltoo towers and implications for settlement key derivation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Conner Fromknecht"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1490
        }
    },
    {
        "title": "[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol",
        "thread_messages": [
            {
                "author": "Sergi Delgado Segura",
                "date": "2019-11-27T20:20:21",
                "message_text_only": "Hi all,\n\nPatrick McCorry and I have been working on putting together a BOLT draft\nfor WatchTowers. So far we've seen a couple of implementation of\nWatchTowers in the wild (lnd and Electrum) based on Tadge's Monitor\napproach and we are also working on our own one. While all are similar,\nthey differ in some points that may make then non interoperable, so it felt\nright time to put some effort and try to standardise this. We've borrowed\nideas from all implementations as well as from the original approach and\nadded some additional bits to extended with different quality of service.\nThe draft is still rough on the edges and have several open discussion\ntopics at the very end (#FIXME section).\n\nBest,\n\n# WatchTower protocol specification (BOLT DRAFT)\n\n## Overview\n\nAll off-chain protocols assume the user remains online and synchronised\nwith the network. To alleviate this assumption, customers can hire a third\nparty watching service (a.k.a WatchTower) to watch the blockchain and\nrespond to channel breaches on their behalf.\n\nAt a high level, the client sends an encrypted justice transaction\nalongside a transaction locator to the WatchTower. Both the encryption key\nand the transaction locator are derived from the breach transaction id,\nmeaning that the WatchTower will be able to decrypt the justice transaction\nonly after the corresponding breach is seen on the blockchain. Therefore,\nthe WatchTower does not learn any information about the client's channel\nunless there is a channel breach (channel-privacy).\n\nDue to replace-by-revocation Lightning channels, the client should send\ndata to the WatchTower for every new update in the channel, otherwise the\nWatchTower may not be able to respond to specific breaches.\n\nFinally, optional QoS can be offered by the WatchTower to provide stronger\nguarantees to the client, such as a signed receipt for every new job. The\nrationale for the receipt is to build an _accountable_ WatchTower as the\ncustomer can later use it as publicly verifiable evidence if the WatchTower\nfails to protect them.\n\nThe scope of this document includes:\n\n- A protocol for client/server communication.\n- How to build appointments for the WatchTower, including key/locator\nderivation and data encryption.\n- A format for the signed receipt.\n\nThe scope of this bolt does not include:\n\n - A payment protocol between the customer and WatchTower.\n - WatchTower server discovery.\n\nFor the rest of this document we will refer to the WatchTower as server,\nand the user/Lightning node as client.\n\n## Table of Contents\n* [WatchTower discovery](#watchtower-discovery)\n* [WatchTower services](#watchtower-discovery)\n* [Basic Service](#basic-service)\n* [Quality of Service](#quality-of-service)\n* [Sending and receiving appointments](#sending-and-receiving-appointments)\n  * [The `appointment` message](#the-appointment-message)\n  * [The `appointment_accepted` message](#the-appointment_accepted-message)\n  * [The `appointment_rejected` message](#the-appointment_rejected-message)\n* [Quality of Service data](#quality-of-service-data)\n* [`accountability`](#accountability)\n* [Transaction Locator and Encryption\nKey](#transaction-locator-and-encryption-key)\n* [Encryption Algorithms and\nParameters](#encryption-algorithms-and-parameters)\n* [Payment Modes](#payment-modes)\n* [No compression of justice\ntransaction](#no-compression-of-justice-transaction)\n\n## WatchTower discovery\n\nWe have not defined how a client can find a list of servers to hire yet. We\nassume the client has found a server and the server is offering a watching\nservice. The service can either be the basic service or an accountable\nquality of service. To deal with pre-payments (when necessary), the client\nmay have an authentication token that the server can verify when accepting\nthe job (e.g. a blinded token).\n\n## WatchTower services\n\n### Basic Service\nThe customer can hire the WatchTower to watch for breaches on the\nblockchain and relay a justice transaction on their behalf. The customer\nreceives an acknowledgement when the WatchTower has accepted the job, but\nthe hiring protocol does not guarantee the transaction inclusion.\n\n### Quality of Service\nQuality of Service (`qos`) builds on top of the basic service provided by a\ntower and it's optionally provided. Different kinds of QoS can be offered\nby the tower.\n\nFor now we are defining a single type of `qos`: `accountability`.\n\n#### `accountability`\n\nA WatchTower provides a signed receipt to the customer. This is considered\nreputational accountability as the customer has publicly verifiable\ncryptographic evidence the WatchTower was hired. The receipt can be used to\nprove the WatchTower did not relay the justice transaction on their behalf\nand/or request a refund.\n\n## Sending and receiving appointments\n\nOnce the client is aware of the services provided by the server, the former\ncan start sending appointments to the latter.\n\n+-------+                                    +-------+\n|   A   |--(1)---      appointment      ---->|   B   |\n|       |<-(2)---   accepted/rejected   -----|       |\n+-------+                                    +-------+\n\n- where node A is 'client' and node B is 'server'\n\n### The `appointment` message\n\nThis message contains all the information regarding the appointment that\nthe client wants to arrange with the server.\n\n1. type: ? (`appointment`)\n2. data:\n   * [`16*byte`:`locator`]\n   * [`u64 `:`start_block`]\n   * [`u64 `:`end_block`]\n   * [`u16`: `encrypted_blob_len`\n   * [`encrypted_blob_len*byte`:`encrypted_blob`]\n   * [`u16`:`cipher`]\n   * [`u16`: `auth_token_len`]\n   * [`auth_token_len*byte`: `auth_token`]\n   * [`u16`: `qos_len`]\n   * [`qos_len*byte`: `qos_data`]\n\n#### Requirements\n\nThe client:\n\n* MUST set `locator` as specified in [Transaction Locator and Encryption\nKey](#transaction-locator-and-encryption-key).\n* MUST set `start_block` to the current chain tip height.\n* MUST set `end_block` to the block height at which he requests the server\nto stop watching for breaches.\n* MUST set `encrypted_blob` to the encryption of the `justice_transaction`\nas specified in [Transaction Locator and Encryption\nKey](#transaction-locator-and-encryption-key).\n* MUST set `cipher` to the cipher used to create the `encrypted_blob`.\n* MAY send an empty `auth_token` field.\n* MUST set `auth_token_len` to the length of `auth_token`.\n* MAY send an empty `qos_data` field.\n* if `qos_data` is not empty:\n*  MUST set `qos_data` according to [Quality of Service\ndata](#quality-of-service-data).\n* MUST set `qos_len` equal to the length of `qos_data`.\n\nThe server:\n\n* MUST reject the appointment if:\n* Authentication is required and `auth_token` is not provided.\n* Authentication is required and `auth_token` is invalid.\n* `locator` is not a `16-byte` value.\n* `start_block` is further than one block behind the current chain tip.\n* `start_block` is further than one block ahead the current chain tip.\n* `encrypted_blob` has unreasonable size.\n* `cipher` is not among the ones he implements.\n\n* SHOULD reject the appointment if`end_block` is too far away in the future.\n\n* MUST:\n* truncate the remainder of the package to `qos_len`.\n* process `qos_data` according to [Quality of Service\ndata](#quality-of-service-data) if `qos_len` is not 0.\n\n* MAY accept the appointment otherwise.\n\n#### Rationale\n\nWe define appointment as the way that the WatchTower is hired / requested\nby a client to do it's watching services.\n\nWatchTowers may offer their services for free (`altruistic`) or they may\nrequire a payment when accepting the job (`non-altruistic`). We have\ndefined `auth_token` as an authentication mechanism between the client and\nserver, so the client can prove they are entitled to the service. The\ntokens are not required to be linked to any kind of identity (e.g. blinded\ntokens), but their sole purpose is to confirm the client has already paid\nfor the service.\n\nThe transaction `locator` can be deterministically computed by both the\nclient and the server. Locators of wrong size are therefore invalid.\n\n`start_block` can be either one block ahead or behind the tower tip due to\nnetwork delays. A tower must not accept appointments arbitrarily ahead or\nbehind the current tip since it could increase DoS vectors. A `start_block`\nlong behind would force the tower to rescan block data for those\nappointments instead of watching block by block. On the other hand, a\n`start_time` long ahead would imply storing information way before it being\nneeded.\n\nRegarding the `end_block`, too far away is a subjective concept. The\nfurther away a tower accepts appointment ends, the higher the potential\nstorage requirements may be, and the easier, and cheaper, it my be to\nperform DoS.\n\nThe `encrypted_blob` should have been encrypted using `cipher`. Block\nciphers have a size multiple of the block length, which depends on the key\nsize. Therefore the `encrypted_blob` have to be at least as big as:\n\n`cipher_block_size * ceil(minimum_viable_transaction_size /\ncipher_block_size)`\n\nand at most as big as:\n\n`cipher_block_size * ceil(maximum_viable_transaction_size /\ncipher_block_size`)\n\n`minimum_viable_transaction_size` and `maximum_viable_transaction_size`\nrefer to the minimum/maximum size required to create a valid transaction.\nAccepting `encrypted_blob` outside those boundaries will increase DoS\nattacks on the server.\n\nThe client should have learn about the `ciphers` implemented by the\nWatchTower and the `qos` that the tower is offering during the peer\ndiscovery.\n\nA tower must not accept appointments using a cipher it does not implement,\notherwise the decryption of the `encrypted_blob` will not be possible.\n\n`qos` is optional and can include multiple services.\n\n### The `appointment_accepted` message\n\nThis message contains information about the acceptance of an appointment by\nthe WatchTower.\n\n1. type: ? (`appointment_accepted `)\n2. data:\n   * [`16*byte `:`locator`]\n   * [`u16`: `qos_len`]\n* [`qos_len*byte`: `qos_data`]\n\nThe server:\n\n* MUST receive `appointment` before sending an `appointment_accepted`\nmessage.\n* MUST set the `locator` to match the one received in `appointment`.\n* if `qos_data` was requested in `appointment`:\n*  MUST set `qos_data` according to [Quality of Service\ndata](#quality-of-service-data).\n* MUST set `qos_len` equal to the length of `qos_data`.\n\nThe client:\n\n* MUST fail the connection  if `locator` does not match any of locators the\npreviously sent to the server:\n\n* if `qos` was requested in `appointment`:\n* MUST fail the connection if `qos_len` is 0.\n* MUST process `qos_data` according to [Quality of Service\ndata](#quality-of-service-data).\n\n### The `appointment_rejected` message\n\nThis message contains information about the rejection of an appointment by\nthe WatchTower.\n\n1. type: ? (`appointment_rejected `)\n2. data:\n   * [`16*byte `:`locator`]\n   * [`u16`: `rcode`]\n   * [`u16`: `reason_len`\n   * [`reason_len*byte`: `reason`]\n\nThe server:\n\n* MUST receive `appointment` before sending an `appointment_rejected`\nmessage.\n* MUST set the `locator` to match the one received in `appointment`.\n* MUST set `rcode` to the rejection code.\n* MAY set and empty `reason` field.\n* MUST set `reason_len` to length of `reason`.\n\n#### Rationale\n\nThe `appointment_rejected` message follows the approach taken by the\n`error` message defined in [BOLT#1](\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message):\nerror codes are mandatory, whereas reasons are optional and implementation\ndependant.\n\n## Quality of Service data\n\n`qos_data` is a list where each field specifies they type and associated\ndata of the offered/requested `qos`. The format is defined as follows:\n\n* [`u16`: `qos_type`]\n* [`u16`: `data_len`]\n* [`data_len*byte`: `data`]\n\nSo far, only `accountability` is defined.\n\n### `accountability`\n\nThe accountability `qos` defines a pair `qos_data` blobs, associated to a\npair of messages: The first one is `customer_evidence` and it is provided\nby the `client` in the `appointment` message. The second one is\n`tower_evidence`, and is provided by the WatchTower in the\n`appointment_accepted` message.\n\n#### `customer_evidence`\n\nThe format for the `customer_evidence` is defined as follows:\n\n1. type: ? (`customer_evidence`)\n2. data:\n* [`u64 `:`dispute_delta`]\n* [`u64`: `transaction_size`]\n* [`u64`: `transaction_fee`]\n\nIf `accountability` is being requested, the client:\n\n* MUST set `dispute_delta` to the CLTV value specified in the\n`commitment_transaction`.\n* MUST set `transaction_size` to the size of the serialized\n`justice_transaction`, in bytes.\n* MUST set `transaction_fee` to the fee set in the `justice_transaction`,\nin satoshis.\n* MUST set the `customer_signature_algorithm` to one of the signature\nalgorithms supported by the tower.\n* MUST set `customer_signature` to the signature of the appointment using\n`op_customer_signature_algorithm`.\n* MUST set `customer_public_key` to the public key that matches the private\nkey used to create `op_customer_signature`.\n\nIf `accountability` is being offered, the server:\n\n* MUST compute the `customer_signature` verification using\n`customer_public_key`.\n* SHOULD compute the `fee_rate` set in the `justice_tx` using\n`transaction_size` and `transaction_fee`.\n\n* MUST reject the appointment if:\n* Any of the fields is missing.\n* `transaction_size` is unreasonable.\n* `customer_signature_algorithm` does not match any of the supported\nsigning algorithms.\n* `customer_signature` cannot be verified using `customer_public_key`.\n\n* SHOULD reject the appointment if:\n* `dispute_delta` is too small.\n* `fee_rate` is too low.\n\nIf `accountability` is NOT being offered:\n\n* The server MUST reject the appointment.\n\nOtherwise:\n\n* The server SHOULD accept the appointment.\n\n#### Rationale\n\nThe concept of too small for `dispute_delta` is subjective. The\n`dispute_delta` defines the time (in blocks) that the tower has in order to\nrespond after a breach is seen. The smaller the value, the more the server\nrisks to fail the appointment.\n\n`transaction_size` and `transaction_fee` help the WatchTower to decide on\nthe likelihood of an appointment being fulfilled. Appointments with\n`fee_rate` too low may be rejected by the WatchTower. While a customer can\nalways fake this values, it should break ToS between the client and the\nserver and, therefore, release the WatchTower of any liability.\n\nBy accepting the request, the tower is offering a reputationally\naccountable watching service. If `accountability` is not offered, then the\ntower will not accept appointments requesting for it.\n\nAs well, the WatchTower must check the transaction details before deciding\nwhether it will accept it. If the decrypted justice transaction does not\nsatisfy the job details (e.g. too low fee), then the tower is not obliged\nto fulfil the appointment.\n\n#### `tower_evidence`\n\nThe format for the `tower_evidence` is defined as follows:\n\n1. type: ? (`tower_evidence`)\n2. data:\n* [`u16 `:`receipt_len`]\n* [`receipt_len*byte `: `receipt`]\n* [`u16`: `wt_signature_algorithm`]\n* [`u16`: `wt_signature_len`\n* [`wt_signature_len*byte`: `wt_signature`]\n* [`u16`: `wt_public_key_len`]\n* [`wt_public_key_len*byte`: `wt_public_key`]\n\nThe server:\n\n* MUST set `receipt` to a receipt built according to\n[Receipt-Format](#receipt-format).\n* MUST set `wt_signature_algorithm` to one of the signature algorithms he\nhas announced.\n* MUST set `wt_signature` to the signature of the appointment using\n`wt_signature_algorithm`.\n* MUST set `wt_public_key` to the public key that matches the private key\nused to create `wt_signature`.\n\nThe client:\n\n* MUST compute the `wt_signature` verification using `wt_public_key`.\n\n* MUST fail the connection if:\n* Any of the fields is missing.\n* `receipt` does not matches the format specified at\n[Receipt-Format](#receipt-format)\n* `receipt` fields do not match the ones sent in the `appointment` message.\n* `wt_signature_algorithm` does not match any of the ones offered by the\nserver.\n* `wt_signature` cannot be verified using `wt_public_key`.\n\n#### Receipt Format\n\nThe server MUST create the receipt containing the following information:\n\ntxlocator\nstart_block\nend_block\ndispute_delta\nencrypted_blob\ntransaction_size\ntransaction_fee\ncipher\ncustomer_signature\nwt_public_key\n\n\n#### Rationale\n\nWe assume the client has a well-known public key for the WatchTower.\n\nThe receipt contains, mainly, the information provided by the user. The\nWatchTower will need to sign the receipt to provide evidence of agreement.\n\nThe `customer_signature` is included in the receipt to link both the client\nrequest and the server response. Otherwise, the tower could sign a receipt\nwith different data that the one sent by the user, and the user would have\nno way to prove whether that's true or not. By signing the customer\nsignature there the tower creates evidence of what the user sent, since the\ntower cannot forge the client's signature.\n\n#### Receipt serialization and signature\n\n[FIXME: TBD]\n\n## Transaction Locator and Encryption Key\n\nImplementations MUST compute the `locator`, `encryption_key` and\n`encryption_iv` from the commitment transaction as defined below:\n\n- `locator`: first half of the commitment transaction id\n(`commitment_txid(0,16]`)\n- `master_key`: Hash of the second half of the commitment transaction id\n(`SHA256(commitment_txid(16,32])`)\n- `encryption_key`: first half of the master key (`master_key(0,16]`)\n- `encryption_iv`: second half of the master key (`master_key(16,32]`)\n\n\nThe server relies on both the encryption key and iv to decrypt the justice\ntransaction. Furthermore, the transaction locator helps the WatchTower\nidentify a breach transaction on the blockchain.\n\n## Encryption Algorithms and Parameters\n\nAll clients and servers MUST use one of the following encryption\nalgorithms:\n\n- ChaCha20 (https://tools.ietf.org/html/rfc7539)\n- AES-GCM-256 (https://tools.ietf.org/html/rfc5288)\n\nSample code (python) for the client to prepare the `encrypted_blob`:\n\nfrom hashlib import sha256\nfrom binascii import hexlify\n\ndef encrypt(justice_tx, commitment_txid):\n   # master_key = SHA256(commitment_txid(16, 32])\n   master_key = sha256(commitment_txid[16:]).digest()\n\n   # The 16 MSB of the master key will serve as the AES-GCM-256 secret key.\nThe 16 LSB will serve as the IV.\n   sk = master_key[:16]\n   nonce = master_key[16:]\n\n   # Encrypt the data\n   aesgcm = AESGCM(sk)\n   encrypted_blob = aesgcm.encrypt(nonce=iv, data=tx, associated_data=None)\n   encrypted_blob = hexlify(encrypted_blob).decode()\n\n   return encrypted_blob\n\n## Payment modes\n\nAlthough this BOLT does not enforce any specific payment method to be\nadopted, it is worth mentioning the three most common ones:\n\n**On-chain bounty**. An additional output is created in the justice\ntransaction that will reward the WatchTower.\n\n**Micropayments**. A small payment is sent to the WatchTower for every new\njob (e.g. over the lightning network)\n\n**Subscription**. WatchTower is periodically rewarded / paid for their\nservice to the customer. (e.g. over the lightning network or fiat\nsubscription).\n\nBoth micropayments and subscriptions are favourable for a WatchTower. The\non-chain bounty approach is not ideal for a watching network, it lets the\ncustomer hire many WatchTowers (O(N) storage for each tower) and only one\nWatchTower will be rewarded upon collecting the bounty. On top of that, the\nonchain bounty allows a network-wise DoS attack for free.\n\n## No compression of justice transaction\n\nThe storage requirements for a WatchTower can be reduced (linearly) by\nimplementing [shachain](\nhttps://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt),\ntherefore storing the parts required to build the transaction and the\ncorresponding signing key instead of the full transaction. For now, we have\ndecided to keep the hiring protocol simple. Storage is relatively cheap and\nwe can revisit this standard if it becomes a problem.\n\n## FIXMES\n\n- Define a proper tower discovery.\n- Define authentication mechanism (macaroons maybe?).\n- None of the message types have been defined (they have been left with ?).\n- Define receipt serialization format.\n- `qos_type` can be defined by ranges, in the same way that error messages\nare. In that way a range of values can belong to a specific `qos`.\n- Define an optional way of doing batch appointments / appointments in\nbulk? That would break appointment unlinkability but would ease the data\nmanagement for the tower.\n- The `customer_signature` could be optional if the client does not care\nthat much about the worst case. Dicuss whether that makes sense.\n- Discuss whether to extend it with shachain.\n\n\nThe document can also be found here:\nhttps://github.com/PISAresearch/pisa/blob/master/13-watchtower-API.md\n\n-- \nSergi.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191127/2215f4f5/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-11-29T05:43:32",
                "message_text_only": "Thanks for working on this, a bunch of interesting ideas!\n\nI think it could be noted in the motivation, that's having an interoperable\nwatchtower protocol is really cool, because every watchtower you add is\na liveness reliability increase (modulo privacy loss), specially if these\nwatchtowers are from different implementations in case of a vuln affecting\nbreach\nmonitoring code of your LN node.\n\nSome generic remarks, you should define another TCP port than the LN one of\n9735\nbecause this is client-server relationship and you want to avoid leak of\np2p\nmessages to your watchtower.\n\nMessages should also use the TLV format, will remove a lot *_len field and\neach\nQoS could be a tlv_record in `appointment`.\n\nFor the init protocol, I was considering the following scheme.\n\n\n                        init\n                ---------------------->\n\n                        version\n                <----------------------\n       Alice                                 Bob\n                    payment protocol\n                ----------------------->\n                         ...\n\n                    appointment hiring\n                ----------------------->\n                         ...\n\n                    appointment firing\n                ----------------------->\n\nThe `init` message would contain a method to establish a secure connection\nbetween client and server. Watchtower shouldn't learn LN pubkey of client\nas it may be a conflict of interest and be leveraged to build more\nsophisticated\nattacks. So client should implement identity contingement properly and use\nthe `init` message to start a Noise session or something like BIP324.\n\nAfter secure connection establishement, `version` would be the reply with\na features field, wider than only QoS like also the payment protocol\nsupported,\nand maybe an invoice for the payment protocol preferred. In a future,\nfeatures may\nextend beyond channel watching, like timing out client HTLC or\nsynchronization\nserver for multi-party channels...\n\nClient would then execute the one or multiple steps of the payment protocol.\nThis one may be complex, i.e include parameters negotiation like update\nrate-limiting, feerate for encrypted blob, storage throttling after time X,\n...\nI do think this kind of parameters belong there compare to\n`appointment_hiring`,\nas they may cover watching operations of one or more channels and secondly\nthey\nare DoS protections, and payment scheme and DoS are going to be really tied\nin watchtowers protocol.\n\nThen `appointment_hiring` with QoS and their parameters, is there reasons\nfor\nnot having them being stable for the lifetime of client-server interaction ?\n\nFinally, some `appointment_firing` to let the client cut its subscription\nand\nauthorize the server to clean storage.\n\n\n> * `start_block` is further than one block behind the current chain tip.\n> * `start_block` is further than one block ahead the current chain tip.\n\nIs a 3 block window enough if the client is a mobile which a lot of latency\nand weak\nprocessing compare to a watchtower's competitive full-node ? I think it's\nonly\na block issuance edge case but maybe could be easier if client set\nstart_block to\ncurrent_seen_block_height+6 and server would reject if height already past..\n\n> minimum_viable_transaction_size and maximum_viable_transaction_size refer\nto the minimum/maximum size required to create a valid transaction.\n\nCouldn't these limits be implictly MAX_STANDARD_TX_WEIGHT and\nMAX_STANDARD_TX_NONWITNESS_SIZE, current mempool policy limits ?\n\nAlso, nothing is specified on disconnection/reconnection, you want to be\nsure than\nwatchtower as ACK every justice tx sent as every one of them maybe\ncritical. A client\ndoesn't want to assume is channel is covered and finally not due to its\nnetwork\nconnection being rotten.\n\n\n> * MUST set `dispute_delta` to the CLTV value specified in the\n> `commitment_transaction`.\n\nWhat's a dispute delta ? You mean the justice-CSV locktime encumbering\noutputs ?\nGiven this one is fixed at channel opening, it should be fixed also for the\nchannel\nhiring lifetime. And server should announce a min_dispute_delta at QoS\n`accountability`\nannouncement.\n\n> * MUST set `transaction_size` to the size of the serialized\n> `justice_transaction`, in bytes.\n\nI would remove the transaction size, given that all outputs are\nstandardized in LN, that would\nbe a leak on how much payment traffic is going through the client without\nany channel breach.\n\n> * MUST set `transaction_fee` to the fee set in the `justice_transaction`,\n> in satoshis.\n\nGenerally, the idea to provide justice tx with pre-signed fees to a\nwatchtower and expect\nthis one to do is job reliably somewhere in the future seem a weak\nassumption... Every watchtower\nfollowing this protocol should handle dynamic fees, that's should be a\nbasic service not even\na QoS. It may through CPFP (but won't be reliable until package relay( or\nRBF'ing the justice\ntx through usage of SIGHASH_ANYONECANPAY, no need interactivity with the\nuser at broadcast,\nbut you may need a populated input mempool.\n\n> While a customer can always fake this values, it should break ToS between\nthe client and the\nserver and, therefore, release the WatchTower of any liability\n\nI can imagine with machine-readable proofs a bot fetching proofs servers,\nverifying them\non the blockchain and scoring in consequence watchtowers. Good marks could\nbe done via\nsome tagging of justice tx (like setting nLocktime in the past to some\nvalue). You would\nnegotiate a different tag for everyone of your watchtower. Removing feerate\nfrom the equation\nwould simplify scoring as now you don't have to guess if mempool was\ncongestionned or not for\nthe client-provided fee.\n\n> On top of that, the onchain bounty allows a network-wise DoS attack for\nfree.\n\nA good point of the onchain bounty is the user doesn't pay for inefficient\nwatchtower or\nsuppleous watchtower. But seems hard to implement DoS-wise and at the same\ntime keep the\nrequirement of pseudonymous clients. Nevertheless a note maybe said on a LN\nnode implementing\nsome kind of anyone-can-spend on top of its txn and let the vigilant crowd\nbid with fees\nand confirm your punishment, that's would be the \"watchtowerless watchtower\nprotocol\" :p\n\n> That would break appointment unlinkability but would ease the data\n> management for the tower.\n\nUnlinkability should be far higher in the BOLT design decisions, I think\npeople may don't\ncare about unlinkability in case of all watchtowers servers are running\nunder same\norganization but they are interested by some building blocks of this spec\nlike tracking ACK\nor fees management delegation. So we may have multiple formats for the\ntransaction\nlocator/encryption and one of them being the empty one ?\n\n> The `customer_signature` could be optional if the client does not care\n> that much about the worst case. Dicuss whether that makes sense.\n\nI think you're right it can be skipped as client has provided a signed\njustice\ntx as an implicit commitment ?\n\nOkay that's a lot and it's really IMO, I do think that's important to have\na flexible protocol\nwith a lot of room for further privacy/efficiency/services upgrades and\ncircumvent non-seen now\ncomplexity. If watchtowers are economically/sociably viable it maybe a\nlayer of its own!\n\nLe mer. 27 nov. 2019 \u00e0 15:20, Sergi Delgado Segura <\nsergi.delgado.s at gmail.com> a \u00e9crit :\n\n> Hi all,\n>\n> Patrick McCorry and I have been working on putting together a BOLT draft\n> for WatchTowers. So far we've seen a couple of implementation of\n> WatchTowers in the wild (lnd and Electrum) based on Tadge's Monitor\n> approach and we are also working on our own one. While all are similar,\n> they differ in some points that may make then non interoperable, so it felt\n> right time to put some effort and try to standardise this. We've borrowed\n> ideas from all implementations as well as from the original approach and\n> added some additional bits to extended with different quality of service.\n> The draft is still rough on the edges and have several open discussion\n> topics at the very end (#FIXME section).\n>\n> Best,\n>\n> # WatchTower protocol specification (BOLT DRAFT)\n>\n> ## Overview\n>\n> All off-chain protocols assume the user remains online and synchronised\n> with the network. To alleviate this assumption, customers can hire a third\n> party watching service (a.k.a WatchTower) to watch the blockchain and\n> respond to channel breaches on their behalf.\n>\n> At a high level, the client sends an encrypted justice transaction\n> alongside a transaction locator to the WatchTower. Both the encryption key\n> and the transaction locator are derived from the breach transaction id,\n> meaning that the WatchTower will be able to decrypt the justice transaction\n> only after the corresponding breach is seen on the blockchain. Therefore,\n> the WatchTower does not learn any information about the client's channel\n> unless there is a channel breach (channel-privacy).\n>\n> Due to replace-by-revocation Lightning channels, the client should send\n> data to the WatchTower for every new update in the channel, otherwise the\n> WatchTower may not be able to respond to specific breaches.\n>\n> Finally, optional QoS can be offered by the WatchTower to provide stronger\n> guarantees to the client, such as a signed receipt for every new job. The\n> rationale for the receipt is to build an _accountable_ WatchTower as the\n> customer can later use it as publicly verifiable evidence if the WatchTower\n> fails to protect them.\n>\n> The scope of this document includes:\n>\n> - A protocol for client/server communication.\n> - How to build appointments for the WatchTower, including key/locator\n> derivation and data encryption.\n> - A format for the signed receipt.\n>\n> The scope of this bolt does not include:\n>\n>  - A payment protocol between the customer and WatchTower.\n>  - WatchTower server discovery.\n>\n> For the rest of this document we will refer to the WatchTower as server,\n> and the user/Lightning node as client.\n>\n> ## Table of Contents\n> * [WatchTower discovery](#watchtower-discovery)\n> * [WatchTower services](#watchtower-discovery)\n> * [Basic Service](#basic-service)\n> * [Quality of Service](#quality-of-service)\n> * [Sending and receiving appointments](#sending-and-receiving-appointments)\n>   * [The `appointment` message](#the-appointment-message)\n>   * [The `appointment_accepted` message](#the-appointment_accepted-message)\n>   * [The `appointment_rejected` message](#the-appointment_rejected-message)\n> * [Quality of Service data](#quality-of-service-data)\n> * [`accountability`](#accountability)\n> * [Transaction Locator and Encryption\n> Key](#transaction-locator-and-encryption-key)\n> * [Encryption Algorithms and\n> Parameters](#encryption-algorithms-and-parameters)\n> * [Payment Modes](#payment-modes)\n> * [No compression of justice\n> transaction](#no-compression-of-justice-transaction)\n>\n> ## WatchTower discovery\n>\n> We have not defined how a client can find a list of servers to hire yet.\n> We assume the client has found a server and the server is offering a\n> watching service. The service can either be the basic service or an\n> accountable quality of service. To deal with pre-payments (when necessary),\n> the client may have an authentication token that the server can verify when\n> accepting the job (e.g. a blinded token).\n>\n> ## WatchTower services\n>\n> ### Basic Service\n> The customer can hire the WatchTower to watch for breaches on the\n> blockchain and relay a justice transaction on their behalf. The customer\n> receives an acknowledgement when the WatchTower has accepted the job, but\n> the hiring protocol does not guarantee the transaction inclusion.\n>\n> ### Quality of Service\n> Quality of Service (`qos`) builds on top of the basic service provided by\n> a tower and it's optionally provided. Different kinds of QoS can be offered\n> by the tower.\n>\n> For now we are defining a single type of `qos`: `accountability`.\n>\n> #### `accountability`\n>\n> A WatchTower provides a signed receipt to the customer. This is considered\n> reputational accountability as the customer has publicly verifiable\n> cryptographic evidence the WatchTower was hired. The receipt can be used to\n> prove the WatchTower did not relay the justice transaction on their behalf\n> and/or request a refund.\n>\n> ## Sending and receiving appointments\n>\n> Once the client is aware of the services provided by the server, the\n> former can start sending appointments to the latter.\n>\n> +-------+                                    +-------+\n> |   A   |--(1)---      appointment      ---->|   B   |\n> |       |<-(2)---   accepted/rejected   -----|       |\n> +-------+                                    +-------+\n>\n> - where node A is 'client' and node B is 'server'\n>\n> ### The `appointment` message\n>\n> This message contains all the information regarding the appointment that\n> the client wants to arrange with the server.\n>\n> 1. type: ? (`appointment`)\n> 2. data:\n>    * [`16*byte`:`locator`]\n>    * [`u64 `:`start_block`]\n>    * [`u64 `:`end_block`]\n>    * [`u16`: `encrypted_blob_len`\n>    * [`encrypted_blob_len*byte`:`encrypted_blob`]\n>    * [`u16`:`cipher`]\n>    * [`u16`: `auth_token_len`]\n>    * [`auth_token_len*byte`: `auth_token`]\n>    * [`u16`: `qos_len`]\n>    * [`qos_len*byte`: `qos_data`]\n>\n> #### Requirements\n>\n> The client:\n>\n> * MUST set `locator` as specified in [Transaction Locator and Encryption\n> Key](#transaction-locator-and-encryption-key).\n> * MUST set `start_block` to the current chain tip height.\n> * MUST set `end_block` to the block height at which he requests the server\n> to stop watching for breaches.\n> * MUST set `encrypted_blob` to the encryption of the `justice_transaction`\n> as specified in [Transaction Locator and Encryption\n> Key](#transaction-locator-and-encryption-key).\n> * MUST set `cipher` to the cipher used to create the `encrypted_blob`.\n> * MAY send an empty `auth_token` field.\n> * MUST set `auth_token_len` to the length of `auth_token`.\n> * MAY send an empty `qos_data` field.\n> * if `qos_data` is not empty:\n> *  MUST set `qos_data` according to [Quality of Service\n> data](#quality-of-service-data).\n> * MUST set `qos_len` equal to the length of `qos_data`.\n>\n> The server:\n>\n> * MUST reject the appointment if:\n> * Authentication is required and `auth_token` is not provided.\n> * Authentication is required and `auth_token` is invalid.\n> * `locator` is not a `16-byte` value.\n> * `start_block` is further than one block behind the current chain tip.\n> * `start_block` is further than one block ahead the current chain tip.\n> * `encrypted_blob` has unreasonable size.\n> * `cipher` is not among the ones he implements.\n>\n> * SHOULD reject the appointment if`end_block` is too far away in the\n> future.\n>\n> * MUST:\n> * truncate the remainder of the package to `qos_len`.\n> * process `qos_data` according to [Quality of Service\n> data](#quality-of-service-data) if `qos_len` is not 0.\n>\n> * MAY accept the appointment otherwise.\n>\n> #### Rationale\n>\n> We define appointment as the way that the WatchTower is hired / requested\n> by a client to do it's watching services.\n>\n> WatchTowers may offer their services for free (`altruistic`) or they may\n> require a payment when accepting the job (`non-altruistic`). We have\n> defined `auth_token` as an authentication mechanism between the client and\n> server, so the client can prove they are entitled to the service. The\n> tokens are not required to be linked to any kind of identity (e.g. blinded\n> tokens), but their sole purpose is to confirm the client has already paid\n> for the service.\n>\n> The transaction `locator` can be deterministically computed by both the\n> client and the server. Locators of wrong size are therefore invalid.\n>\n> `start_block` can be either one block ahead or behind the tower tip due to\n> network delays. A tower must not accept appointments arbitrarily ahead or\n> behind the current tip since it could increase DoS vectors. A `start_block`\n> long behind would force the tower to rescan block data for those\n> appointments instead of watching block by block. On the other hand, a\n> `start_time` long ahead would imply storing information way before it being\n> needed.\n>\n> Regarding the `end_block`, too far away is a subjective concept. The\n> further away a tower accepts appointment ends, the higher the potential\n> storage requirements may be, and the easier, and cheaper, it my be to\n> perform DoS.\n>\n> The `encrypted_blob` should have been encrypted using `cipher`. Block\n> ciphers have a size multiple of the block length, which depends on the key\n> size. Therefore the `encrypted_blob` have to be at least as big as:\n>\n> `cipher_block_size * ceil(minimum_viable_transaction_size /\n> cipher_block_size)`\n>\n> and at most as big as:\n>\n> `cipher_block_size * ceil(maximum_viable_transaction_size /\n> cipher_block_size`)\n>\n> `minimum_viable_transaction_size` and `maximum_viable_transaction_size`\n> refer to the minimum/maximum size required to create a valid transaction.\n> Accepting `encrypted_blob` outside those boundaries will increase DoS\n> attacks on the server.\n>\n> The client should have learn about the `ciphers` implemented by the\n> WatchTower and the `qos` that the tower is offering during the peer\n> discovery.\n>\n> A tower must not accept appointments using a cipher it does not implement,\n> otherwise the decryption of the `encrypted_blob` will not be possible.\n>\n> `qos` is optional and can include multiple services.\n>\n> ### The `appointment_accepted` message\n>\n> This message contains information about the acceptance of an appointment\n> by the WatchTower.\n>\n> 1. type: ? (`appointment_accepted `)\n> 2. data:\n>    * [`16*byte `:`locator`]\n>    * [`u16`: `qos_len`]\n> * [`qos_len*byte`: `qos_data`]\n>\n> The server:\n>\n> * MUST receive `appointment` before sending an `appointment_accepted`\n> message.\n> * MUST set the `locator` to match the one received in `appointment`.\n> * if `qos_data` was requested in `appointment`:\n> *  MUST set `qos_data` according to [Quality of Service\n> data](#quality-of-service-data).\n> * MUST set `qos_len` equal to the length of `qos_data`.\n>\n> The client:\n>\n> * MUST fail the connection  if `locator` does not match any of locators\n> the previously sent to the server:\n>\n> * if `qos` was requested in `appointment`:\n> * MUST fail the connection if `qos_len` is 0.\n> * MUST process `qos_data` according to [Quality of Service\n> data](#quality-of-service-data).\n>\n> ### The `appointment_rejected` message\n>\n> This message contains information about the rejection of an appointment by\n> the WatchTower.\n>\n> 1. type: ? (`appointment_rejected `)\n> 2. data:\n>    * [`16*byte `:`locator`]\n>    * [`u16`: `rcode`]\n>    * [`u16`: `reason_len`\n>    * [`reason_len*byte`: `reason`]\n>\n> The server:\n>\n> * MUST receive `appointment` before sending an `appointment_rejected`\n> message.\n> * MUST set the `locator` to match the one received in `appointment`.\n> * MUST set `rcode` to the rejection code.\n> * MAY set and empty `reason` field.\n> * MUST set `reason_len` to length of `reason`.\n>\n> #### Rationale\n>\n> The `appointment_rejected` message follows the approach taken by the\n> `error` message defined in [BOLT#1](\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message):\n> error codes are mandatory, whereas reasons are optional and implementation\n> dependant.\n>\n> ## Quality of Service data\n>\n> `qos_data` is a list where each field specifies they type and associated\n> data of the offered/requested `qos`. The format is defined as follows:\n>\n> * [`u16`: `qos_type`]\n> * [`u16`: `data_len`]\n> * [`data_len*byte`: `data`]\n>\n> So far, only `accountability` is defined.\n>\n> ### `accountability`\n>\n> The accountability `qos` defines a pair `qos_data` blobs, associated to a\n> pair of messages: The first one is `customer_evidence` and it is provided\n> by the `client` in the `appointment` message. The second one is\n> `tower_evidence`, and is provided by the WatchTower in the\n> `appointment_accepted` message.\n>\n> #### `customer_evidence`\n>\n> The format for the `customer_evidence` is defined as follows:\n>\n> 1. type: ? (`customer_evidence`)\n> 2. data:\n> * [`u64 `:`dispute_delta`]\n> * [`u64`: `transaction_size`]\n> * [`u64`: `transaction_fee`]\n>\n> If `accountability` is being requested, the client:\n>\n> * MUST set `dispute_delta` to the CLTV value specified in the\n> `commitment_transaction`.\n> * MUST set `transaction_size` to the size of the serialized\n> `justice_transaction`, in bytes.\n> * MUST set `transaction_fee` to the fee set in the `justice_transaction`,\n> in satoshis.\n> * MUST set the `customer_signature_algorithm` to one of the signature\n> algorithms supported by the tower.\n> * MUST set `customer_signature` to the signature of the appointment using\n> `op_customer_signature_algorithm`.\n> * MUST set `customer_public_key` to the public key that matches the\n> private key used to create `op_customer_signature`.\n>\n> If `accountability` is being offered, the server:\n>\n> * MUST compute the `customer_signature` verification using\n> `customer_public_key`.\n> * SHOULD compute the `fee_rate` set in the `justice_tx` using\n> `transaction_size` and `transaction_fee`.\n>\n> * MUST reject the appointment if:\n> * Any of the fields is missing.\n> * `transaction_size` is unreasonable.\n> * `customer_signature_algorithm` does not match any of the supported\n> signing algorithms.\n> * `customer_signature` cannot be verified using `customer_public_key`.\n>\n> * SHOULD reject the appointment if:\n> * `dispute_delta` is too small.\n> * `fee_rate` is too low.\n>\n> If `accountability` is NOT being offered:\n>\n> * The server MUST reject the appointment.\n>\n> Otherwise:\n>\n> * The server SHOULD accept the appointment.\n>\n> #### Rationale\n>\n> The concept of too small for `dispute_delta` is subjective. The\n> `dispute_delta` defines the time (in blocks) that the tower has in order to\n> respond after a breach is seen. The smaller the value, the more the server\n> risks to fail the appointment.\n>\n> `transaction_size` and `transaction_fee` help the WatchTower to decide on\n> the likelihood of an appointment being fulfilled. Appointments with\n> `fee_rate` too low may be rejected by the WatchTower. While a customer can\n> always fake this values, it should break ToS between the client and the\n> server and, therefore, release the WatchTower of any liability.\n>\n> By accepting the request, the tower is offering a reputationally\n> accountable watching service. If `accountability` is not offered, then the\n> tower will not accept appointments requesting for it.\n>\n> As well, the WatchTower must check the transaction details before deciding\n> whether it will accept it. If the decrypted justice transaction does not\n> satisfy the job details (e.g. too low fee), then the tower is not obliged\n> to fulfil the appointment.\n>\n> #### `tower_evidence`\n>\n> The format for the `tower_evidence` is defined as follows:\n>\n> 1. type: ? (`tower_evidence`)\n> 2. data:\n> * [`u16 `:`receipt_len`]\n> * [`receipt_len*byte `: `receipt`]\n> * [`u16`: `wt_signature_algorithm`]\n> * [`u16`: `wt_signature_len`\n> * [`wt_signature_len*byte`: `wt_signature`]\n> * [`u16`: `wt_public_key_len`]\n> * [`wt_public_key_len*byte`: `wt_public_key`]\n>\n> The server:\n>\n> * MUST set `receipt` to a receipt built according to\n> [Receipt-Format](#receipt-format).\n> * MUST set `wt_signature_algorithm` to one of the signature algorithms he\n> has announced.\n> * MUST set `wt_signature` to the signature of the appointment using\n> `wt_signature_algorithm`.\n> * MUST set `wt_public_key` to the public key that matches the private key\n> used to create `wt_signature`.\n>\n> The client:\n>\n> * MUST compute the `wt_signature` verification using `wt_public_key`.\n>\n> * MUST fail the connection if:\n> * Any of the fields is missing.\n> * `receipt` does not matches the format specified at\n> [Receipt-Format](#receipt-format)\n> * `receipt` fields do not match the ones sent in the `appointment` message.\n> * `wt_signature_algorithm` does not match any of the ones offered by the\n> server.\n> * `wt_signature` cannot be verified using `wt_public_key`.\n>\n> #### Receipt Format\n>\n> The server MUST create the receipt containing the following information:\n>\n> txlocator\n> start_block\n> end_block\n> dispute_delta\n> encrypted_blob\n> transaction_size\n> transaction_fee\n> cipher\n> customer_signature\n> wt_public_key\n>\n>\n> #### Rationale\n>\n> We assume the client has a well-known public key for the WatchTower.\n>\n> The receipt contains, mainly, the information provided by the user. The\n> WatchTower will need to sign the receipt to provide evidence of agreement.\n>\n> The `customer_signature` is included in the receipt to link both the\n> client request and the server response. Otherwise, the tower could sign a\n> receipt with different data that the one sent by the user, and the user\n> would have no way to prove whether that's true or not. By signing the\n> customer signature there the tower creates evidence of what the user sent,\n> since the tower cannot forge the client's signature.\n>\n> #### Receipt serialization and signature\n>\n> [FIXME: TBD]\n>\n> ## Transaction Locator and Encryption Key\n>\n> Implementations MUST compute the `locator`, `encryption_key` and\n> `encryption_iv` from the commitment transaction as defined below:\n>\n> - `locator`: first half of the commitment transaction id\n> (`commitment_txid(0,16]`)\n> - `master_key`: Hash of the second half of the commitment transaction id\n> (`SHA256(commitment_txid(16,32])`)\n> - `encryption_key`: first half of the master key (`master_key(0,16]`)\n> - `encryption_iv`: second half of the master key (`master_key(16,32]`)\n>\n>\n> The server relies on both the encryption key and iv to decrypt the justice\n> transaction. Furthermore, the transaction locator helps the WatchTower\n> identify a breach transaction on the blockchain.\n>\n> ## Encryption Algorithms and Parameters\n>\n> All clients and servers MUST use one of the following encryption\n> algorithms:\n>\n> - ChaCha20 (https://tools.ietf.org/html/rfc7539)\n> - AES-GCM-256 (https://tools.ietf.org/html/rfc5288)\n>\n> Sample code (python) for the client to prepare the `encrypted_blob`:\n>\n> from hashlib import sha256\n> from binascii import hexlify\n>\n> def encrypt(justice_tx, commitment_txid):\n>    # master_key = SHA256(commitment_txid(16, 32])\n>    master_key = sha256(commitment_txid[16:]).digest()\n>\n>    # The 16 MSB of the master key will serve as the AES-GCM-256 secret\n> key. The 16 LSB will serve as the IV.\n>    sk = master_key[:16]\n>    nonce = master_key[16:]\n>\n>    # Encrypt the data\n>    aesgcm = AESGCM(sk)\n>    encrypted_blob = aesgcm.encrypt(nonce=iv, data=tx, associated_data=None)\n>    encrypted_blob = hexlify(encrypted_blob).decode()\n>\n>    return encrypted_blob\n>\n> ## Payment modes\n>\n> Although this BOLT does not enforce any specific payment method to be\n> adopted, it is worth mentioning the three most common ones:\n>\n> **On-chain bounty**. An additional output is created in the justice\n> transaction that will reward the WatchTower.\n>\n> **Micropayments**. A small payment is sent to the WatchTower for every new\n> job (e.g. over the lightning network)\n>\n> **Subscription**. WatchTower is periodically rewarded / paid for their\n> service to the customer. (e.g. over the lightning network or fiat\n> subscription).\n>\n> Both micropayments and subscriptions are favourable for a WatchTower. The\n> on-chain bounty approach is not ideal for a watching network, it lets the\n> customer hire many WatchTowers (O(N) storage for each tower) and only one\n> WatchTower will be rewarded upon collecting the bounty. On top of that, the\n> onchain bounty allows a network-wise DoS attack for free.\n>\n> ## No compression of justice transaction\n>\n> The storage requirements for a WatchTower can be reduced (linearly) by\n> implementing [shachain](\n> https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt),\n> therefore storing the parts required to build the transaction and the\n> corresponding signing key instead of the full transaction. For now, we have\n> decided to keep the hiring protocol simple. Storage is relatively cheap and\n> we can revisit this standard if it becomes a problem.\n>\n> ## FIXMES\n>\n> - Define a proper tower discovery.\n> - Define authentication mechanism (macaroons maybe?).\n> - None of the message types have been defined (they have been left with ?).\n> - Define receipt serialization format.\n> - `qos_type` can be defined by ranges, in the same way that error messages\n> are. In that way a range of values can belong to a specific `qos`.\n> - Define an optional way of doing batch appointments / appointments in\n> bulk? That would break appointment unlinkability but would ease the data\n> management for the tower.\n> - The `customer_signature` could be optional if the client does not care\n> that much about the worst case. Dicuss whether that makes sense.\n> - Discuss whether to extend it with shachain.\n>\n>\n> The document can also be found here:\n> https://github.com/PISAresearch/pisa/blob/master/13-watchtower-API.md\n>\n> --\n> Sergi.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191129/cc00825d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BOLT 13(?): WatchTower protocol",
            "categories": [
                "Lightning-dev",
                "DRAFT"
            ],
            "authors": [
                "Antoine Riard",
                "Sergi Delgado Segura"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 50233
        }
    },
    {
        "title": "[Lightning-dev] Proof-of-work vs fees (was; Re:  A proposal for up-front payments)",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-11-28T03:26:55",
                "message_text_only": "Good morning Orfeas,\n\nThe thread is now off-topic, thus I changed the subject.\n\n> > This can be made \"the same\" by any of the following methods:\n> >\n> > -   Burning the up-front fees.\n>\n> This would impose a hard maximum of 21 * 10^6 * 10^8 global lifetime hops, and a much lower practical one. PoW OTOH doesn't impose such limits. Hence different dynamics.\n\nGranted, but do note that we can trivially \"move the decimal\".\nPerhaps not \"trivially\" but it is possible to do so, thus still the same overall dynamics.\n\n>\n> > -   Locking the up-front fees for a time, then reverting them to the original sender.\n>\n> This means that I can burst-spam today, wait until unlock, repeat. If the PoW scheme somehow enforces fresh PoWs (e.g. by needing (nonce || recent block hash) as proof), I can't do this attack.\n\nBut in order for PoW to actively limit spam, the PoW target must be high enough that you can burst-spam today, wait until you get your *next* passes-the-threshold PoW, repeat.\nThe difference is that PoW has more variance, but that variance itself can limit non-spam usage (in much the same way that too high an up-front locktime would also limit non-spam usage).\n\nI do not think you can get better than this, given the physics of this universe.\nMoney represents the allocation of available energy (by the simple mechanism of purchasing energy using money; the invisible hand is really the mechanism which directs energy towards the production of goods that are demanded), and PoW is a proof that somebody allocated available energy for the production of the PoW.\nI do not know what argument you would consider \"formal enough\" but that is the only argument I have, and I find it sufficient.\n\nWould this be enough?\n\nWe postulate that there is an amount of energy E, whose consumption produces a proof-of-work we can present on network, and that this required amount of consumed energy E is sufficient to deter spam.\nThe proof-of-work attesting to this energy E can be bought in a sufficiently mature market, using money, and thus this amount of energy E has some equivalent market price of money M, the spending of which is sufficient to deter spam.\nIf spending amount M was not sufficient to deter spam, or equivalently if M is too cheap to deter spam, then spammers will spend M to get E to drive proof-of-work instead of deriving their proof-of-work directly, increasing demand for energy until the market price of E becomes M' such that M' is sufficiently high enough to deter spam.\n\nOr in simpler terms: with a stable enough monetary system and market, you can buy PoW, thus PoW and fees are equivalent.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Proof-of-work vs fees (was; Re:  A proposal for up-front payments)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2630
        }
    },
    {
        "title": "[Lightning-dev] Proof-of-work vs fees",
        "thread_messages": [
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-11-28T11:53:45",
                "message_text_only": "Hi ZmnSCPxj,\n\n>>> -   Locking the up-front fees for a time, then reverting them to the original sender.\n>>\n>> This means that I can burst-spam today, wait until unlock, repeat. If the PoW scheme somehow enforces fresh PoWs (e.g. by needing (nonce || recent block hash) as proof), I can't do this attack.\n> \n> But in order for PoW to actively limit spam, the PoW target must be high enough that you can burst-spam today, wait until you get your *next* passes-the-threshold PoW, repeat.\n> The difference is that PoW has more variance, but that variance itself can limit non-spam usage (in much the same way that too high an up-front locktime would also limit non-spam usage).\n\nWe wouldn't be able to burst-spam with PoW if it was (nonce || recent block hash || recipient public key). Including the pubkey there makes sense anyway.\n\nWe can further concatenate some kind of `secret_to_get_fees` in the PoW so that P the payer can't outsource the PoW calculation to some service S without P trusting that S won't steal the fee. I.e. P can't buy the PoW.\n \n> Money represents the allocation of available energy (by the simple mechanism of purchasing energy using money; the invisible hand is really the mechanism which directs energy towards the production of goods that are demanded), and PoW is a proof that somebody allocated available energy for the production of the PoW.\n\nI think I understand now the root of our disagreement, please correct me if I'm wrong.\nYou are saying that PoWs, being a scarce resource, have a market value. In other words, we can engineer PoW in a way that it can be bought for money.\nI'm saying that PoW and fees are not blindly interchangeable as an anti-spam measure for LN. (Heck, even the various versions of PoW we devised in this thread are not interchangeable!) I'm further saying that we don't know whether every PoW-based scheme can be transformed to an equivalent fee-based scheme.\n\nIn this sense, I believe we are both right.\n\nThe argument \"there is a market price for PoW, therefore PoW and fees are equivalent, therefore we can use fees and PoW interchangeably for LN anti-spam\" is not correct though. Just s/PoW/sneakers and the reason will become obvious. (This substitution is OK because neither sneakers nor PoWs can be converted back to abstract energy and reused to produce different goods, only exchanged for other manufactured goods or money.)\n\nBest,\nOrfeas\n\n-- \nThe University of Edinburgh is a charitable body, registered in\nScotland, with registration number SC005336."
            }
        ],
        "thread_summary": {
            "title": "Proof-of-work vs fees",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Orfeas Stefanos Thyfronitis Litos"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2517
        }
    },
    {
        "title": "[Lightning-dev] A gossip network for cross-chain trampoline payments",
        "thread_messages": [
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2019-11-29T18:58:39",
                "message_text_only": "I see more people are thinking about this cross-chain lightning problem and\neven working on it, it seems.\nThat is great, let's please join forces if we can. I'm happy to help in any\nway I can.\n\nHere's an example on how I think things could work in the future, like 2 or\n3 steps after what I think cdecker is doing and\nlike 5 or 6 steps of what I'm currently doing.\nPlease, point out anything I may be missing or any alternatives I'm not\nconsidering.\n\nLet's say Alice has a lightning node configured to run on network=chain_A.\nShe wants to pay an invoice Bob gave her, but it turns out that bob has his\nlightning node configured for network=chain_B.\n\nLet's assume we already have trampoline routing as per\nhttps://github.com/lightningnetwork/lightning-rfc/pull/654\n\nIn fact, let's copy the entire example there and change some things. We\npart from:\n\n\n```text\nAlice                 TA1                  TA2 -> TB3         Bob\n  |                   ^ |                   ^      |           ^\n  |                   | |                   |      |           |\n  `---> H1 ---> H2 ---' `---> H3 ---> H4 ---'      `---> H5 ---'\n```\n\nBut here not all nodes operate in the same chain, they distribute as\nfollows:\n\nchain_A: Alice, TA1, TA2, H1, H2, H3, H4\nchain_B: Bob, TB3, H5\n\nNow the first problem we encounter, is that since TA2 and TB3 don't\noperate in the same chain, the direct payment between them can't\nhappen as described in the example for regular trampoline payments,\nfor there can't be a channel between nodes in different chains.\n\nBut what if TA2 and TB3 belonged to the same person?\nLet's call that person Carol and let's call the software that makes things\nhappen a \"Gateway\" (we can find a better name later, as with anything else).\nNote that apart from TA2 and TB3, Carol's gateway could also connect to\nother nodes operating in chain_C, chain_D and chain_E, for example.\n\n```text\n                                               Carol\nAlice                 TA1                  TA2 -*?-> TB3         Bob\n  |                   ^ |                   ^         |           ^\n  |                   | |                   |         |           |\n  `---> H1 ---> H2 ---' `---> H3 ---> H4 ---'         `---> H5 ---'\n```\n\nNow the main concern is to clarify what the \"-*?->\" nomenclature means.\n\nBut before that, shouldn't alice, when building trampoline_onion_packet,\nnotice that TB3 and Bob don't belong to chain_A?\nWe need a way for Alice to know that she can actually attempt that.\nCarol could advertise that she is managing a gateway between TA2 and TB3\n(perhaps more) in some gossip network.\nNote this network doesn't need to be part of the lightning protocol, or be\njust optional following the \"it's ok to be odd\" design.\nFew things are easier than ignoring gossip that is not of your interest, I\nthink.\n\nWe could have an update_gateway gossip message with something like:\n\n- gateway_id\n- list of node ids\n- list of signatures by those node's ids\n- signature by gateway_id\n\nThe proportional fees charged for different combinations may be different,\ntake into account that we're not only talking about fees but also prices,\nfor the asset in chain_A may not be the same as the asset in chain_B and,\neven if they are,\nthere can be some discount for the units in one of the chains for whatever\nreason.\n\nApart from a gossip message we would need some update_gateway_route,\nperhaps with:\n\n- src_chain_id\n- dest_chain_id\n- price (this can include an implicit proportional fee)\n\nI know, this is a directed graph and it potentially grows exponentially\nwith the number of chains in the same gateway.\nBut it would be worse with a graph separately by node_id rather than\nchain_id.\nI honestly don't see other way around this.\n\nAlso, I know there's the \"free option\" problem (see\nhttps://en.bitcoin.it/wiki/Atomic_swap#Financial_optionality ).\nLet's remember that at the very moment Carol's gateway software is\nprocessing \"-*?->\" some validation could be triggered\nthat concluded something along the lines:\n\"you know what? I don't like this H5 path nor any other I found for what I\nconsider a fair price at this very moment,\nso I'm going to pass and forward back to whoever initiated this payment\nan error saying I'm not ok with that price anymore, perhaps suggesting a\ndifferent one while at it.\nI will also make sure my gateway nodes are sending the right price for that\npair and direction in update_gateway_route\"\n\nWell, that's not the best way to explain it but I think it can be\nunderstood.\nEven if that's not enough, even if other people can't find better ways to\nmitigate the free option problem,\nthere are potential use cases with constant or relatively stable exchange\nrates for which this shouldn't be a problem.\nSo let's please focus on everything else except for the free option problem\nin this thread.\n\nLet's just accept that both Alice and the gateway software are using some\nformula to convert\nfrom the amt_to_forward received by TA2 to the one that TB3 is supposed to\nreceive and process.\nIf f(amt_to_forward_TA2, price_current) > f(amt_to_forward_TA2,\nprice_alice),\nTA2 may fail and send H4 an error that ultimately will get back to alice.\nWe could use amt_to_forward * price nomenclature rather than\nf(amt_to_forward, price) if you like.\nLet's just remember we need to define price's type though.\nPresumably some approximation of rational numbers that computers can handle\nreasonably well and\nwith a precision that is reasonable enough for our requirements.\n\nAnother operation that is required as part of \"-*?->\" (and that alice must\ndo) that I personally find much more troubling is the\ncalculation from amt_to_forward_TA2 to final_cltv_expiry for Bob or the\nfollowing outgoing_cltv_value if there were more trampoline nodes\ninbetween, or even more gateways and chains.\nWith the price we can calculate f(amt_to_forward_AT2, price) =\namt_to_forward_BT3 and derive the rest from there,\neven though a trampoline hop payload for TB3 is not needed since it can be\nassumed by alice to be calculated by carol's gateway\nfrom what it receives. The point is TB3 doesn't need to know or care about\nthe prices for other gateways after it.\n\nMaybe I am mistaken, but just like with the price we should just be able to\ndefine the following:\n\ng(outgoing_cltv_value_TA2, chain_time_translation) = outgoing_cltv_value_TB2\n\nSo since Alice would need to calculate g too, in reality\nupdate_gateway_route would look like:\n\n- src_chain_id\n- dest_chain_id\n- price (this can include an implicit proportional fee)\n- chain_time_translation\n\nI imagine the type for chain_time_translation to be an imaginary number.\nActually, not. I usually imagine imaginary numbers as an array with 2 real\nelements,\nbut in this case I think just 2 integers should be fine, sorry.\nWhy 2?\nWell, chains not only have different start times and current height, they\nalso potentially have different\nestimated times between blocks (ie bitcoin has 10 minutes, but other chains\nhave other settings).\nI was I assuming something like:\n\ng(outgoing_cltv_value_TA2, chain_time_translation) =\nchain_time_translation_param_1 + (outgoing_cltv_value_TA2 *\nchain_time_translation_param_2) =\noutgoing_cltv_value_TB2\n\nPlease anyone feel free to actually solve that problem before me.\nI haven't thought hard about this because if I assume unity (1 as in\nalgebra class) for both price and chain_time_translation\nI don't actually need to care about the types or the f and g operations,\nsince doing that I know f(x)=x and g(y)=y by definition if x=1 and y=1.\n\nIn any case, we know Alice (the payer) needs to calculate f and g for the\nwhole path using some inter-chain gossip. for prices and chain time\ntranslation.\n\nAs part of \"-*?->\", Each gateway also should recalculate f and g locally,\npotentially with different, more updated values of x and y and perhaps\nreturn an error.\n\nBut beyond those 2 validations \"-*?->\" is pretty much undefined.\n\nWhat I really want to define precisely in \"-*?->\" is how carol's gateway\n(CG from now on) communicates with TA2 and TB3.\n\nTA2 and TB3 have some kind of plugin or extension to talk to CG and also CG\ncan talk to them via rpc, cli or equivalent.\nWe can assume CG, TA2 and TB3 all run in the same machine or local network.\n\nWhen TA2 receives a trampoline hop for which next's hop is a node in a list\nof sibling gateway nodes configured on init or in the relevant plugin:\n\n1) TA2 gives the peeled trampoline onion to CG (including the relevant\nhmac) for it to process it and give an error back or:\n2) CG gives the processed onion to TB3, which processes it even though it\nperceives it as a loss, for it trusts any message from CG\n3) Any errors received by TB3 must be relied back to TA2 through CG, that's\n2 new messages for this mini-protocol within \"-*?->\"\n\nIf everything goes well, I think TB3 needs to communicate one more time\nwith TA2 through CG to pass the payment preimage.\nBut I'm not very sure about this part, I should re-read lightning-rfc more\ntimes.\nIf that's the case, there's 2 more messages here too (one from BT3 to TCG,\nanother from CG to TX2).\n\nI feel the best way to document this communication between CG, TA2 and TB3\nis a UML sequence diagram.\nI promise one if people want it. I just need to reinstall plantUML, but I\nwon't do that today.\n\nI hope people can find flaws on my assumptions or reasoning.\nOr perhaps just add more detail to vaguely defined ideas.\n\nAny form of feedback is welcomed.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191129/9e6c1842/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "A gossip network for cross-chain trampoline payments",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Jorge Tim\u00f3n"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 9579
        }
    }
]