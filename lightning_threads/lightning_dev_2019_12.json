[
    {
        "title": "[Lightning-dev] Proof-of-work vs fees",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-02T02:04:21",
                "message_text_only": "Good morning Orfeas,\n\n>\n> > > > -   Locking the up-front fees for a time, then reverting them to the original sender.\n> > >\n> > > This means that I can burst-spam today, wait until unlock, repeat. If the PoW scheme somehow enforces fresh PoWs (e.g. by needing (nonce || recent block hash) as proof), I can't do this attack.\n> >\n> > But in order for PoW to actively limit spam, the PoW target must be high enough that you can burst-spam today, wait until you get your next passes-the-threshold PoW, repeat.\n> > The difference is that PoW has more variance, but that variance itself can limit non-spam usage (in much the same way that too high an up-front locktime would also limit non-spam usage).\n>\n> We wouldn't be able to burst-spam with PoW if it was (nonce || recent block hash || recipient public key). Including the pubkey there makes sense anyway.\n\nI think we have differences in \"burst-spam\" definition here.\nMy definition of this is that I can spam any number of routes, until I run out of some resource (CPU processing and time for PoW, liquid funds for locked-fee).\nBut afterwards, once time passes (I have accumulated more additional PoW, or the lock on my fee expires) I will be able to spam once again.\nBoth are equivalent to me economically: locking my funds prevents me from earning with it (i.e. opportunity cost) continuously, which matches the continuous drain on my energy reserves and hardware deprecation caused by PoW.\n\n>\n> We can further concatenate some kind of `secret_to_get_fees` in the PoW so that P the payer can't outsource the PoW calculation to some service S without P trusting that S won't steal the fee. I.e. P can't buy the PoW.\n\n*For whom* is the fee?\n\nThe fee is paid to intermediate nodes by the payer --- it is already a \"sunk cost\", thus the payer will not particularly care if the intermediate nodes fail to claim the fee.\n\nFinally, if the payer knows a secret that, by itself, can be used to claim the fee paid to the intermediate node, then the intermediate node would also have to trust that the payer will not reverse the fee by such a claim.\nIf the secret is not enough that, by itself, it can be used to claim the fee, then knowledge of that secret will not allow the PoW service to steal the fee.\n\n> > Money represents the allocation of available energy (by the simple mechanism of purchasing energy using money; the invisible hand is really the mechanism which directs energy towards the production of goods that are demanded), and PoW is a proof that somebody allocated available energy for the production of the PoW.\n>\n> I think I understand now the root of our disagreement, please correct me if I'm wrong.\n> You are saying that PoWs, being a scarce resource, have a market value. In other words, we can engineer PoW in a way that it can be bought for money.\n> I'm saying that PoW and fees are not blindly interchangeable as an anti-spam measure for LN. (Heck, even the various versions of PoW we devised in this thread are not interchangeable!) I'm further saying that we don't know whether every PoW-based scheme can be transformed to an equivalent fee-based scheme.\n>\n> In this sense, I believe we are both right.\n>\n> The argument \"there is a market price for PoW, therefore PoW and fees are equivalent, therefore we can use fees and PoW interchangeably for LN anti-spam\" is not correct though. Just s/PoW/sneakers and the reason will become obvious. (This substitution is OK because neither sneakers nor PoWs can be converted back to abstract energy and reused to produce different goods, only exchanged for other manufactured goods or money.)\n\nSneakers are just another altcoin.\nIf they have any value at all, they can be resold.\n\n(I am being facetious at this point; you win this part of the argument: PoW is valued by intermediate nodes as a spam-limiting factor, but not necessarily resellable elsewhere due to being tied to a particular payment attempt)\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Proof-of-work vs fees",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3935
        }
    },
    {
        "title": "[Lightning-dev] eltoo towers and implications for settlement key derivation",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-12-02T23:53:01",
                "message_text_only": "Conner Fromknecht <conner at lightning.engineering> writes:\n> Hi all,\n>\n> I recently revisited the eltoo paper and noticed some things related\n> watchtowers that might affect channel construction.\n>\n> Due to NOINPUT, any update transaction _can_ spend from any other, so\n> in theory the tower only needs the most recent update txn to resolve\n> any dispute.\n>\n> In order to spend, however, the tower must also produce a witness\n> script which when hashed matches the witness program of the input. To\n> ensure settlement txns can only spend from exactly one update txn,\n> each update txn uses unique keys for the settlement clause, meaning\n> that each state has a _unique_ witness program.\n\nI didn't think this was the design.  The update transaction can spend\nany prior, with a fixed script, due to NOINPUT.\n\nThe settlement transaction does *not* use NOINPUT, and thus can only\nspend the matching update.\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-03T02:55:19",
                "message_text_only": "Good morning Rusty,\n\n> > Hi all,\n> > I recently revisited the eltoo paper and noticed some things related\n> > watchtowers that might affect channel construction.\n> > Due to NOINPUT, any update transaction can spend from any other, so\n> > in theory the tower only needs the most recent update txn to resolve\n> > any dispute.\n> > In order to spend, however, the tower must also produce a witness\n> > script which when hashed matches the witness program of the input. To\n> > ensure settlement txns can only spend from exactly one update txn,\n> > each update txn uses unique keys for the settlement clause, meaning\n> > that each state has a unique witness program.\n>\n> I didn't think this was the design. The update transaction can spend\n> any prior, with a fixed script, due to NOINPUT.\n>\n> The settlement transaction does not use NOINPUT, and thus can only\n> spend the matching update.\n\nMy understanding is that this is not logically possible?\nThe update transaction has no fixed txid until it commits to a particular output-to-be-spent, which is either the funding/kickoff txout, or a lower-`nLockTime` update transaction output.\nThus a settlement transaction *must* use `NOINPUT` as well, as it has no txid it can spend, if it is constrained to spend a particular update transaction.\n\nUnless I misunderstand how update transactions work, or what settlement transactions are.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Conner Fromknecht",
                "date": "2019-12-03T03:03:16",
                "message_text_only": "Good evening,\n\n> I didn't think this was the design.  The update transaction can spend any\nprior, with a fixed script, due to NOINPUT.\n\n>From my reading of the final construction, each update transaction has a\nunique script to bind settlement transactions to exactly one update.\n\n> My understanding is that this is not logically possible?\nThe update transaction has no fixed txid until it commits to a particular\noutput-to-be-spent, which is either the funding/kickoff txout, or a\nlower-`nLockTime` update transaction output.\n> Thus a settlement transaction *must* use `NOINPUT` as well, as it has no\ntxid it can spend, if it is constrained to spend a particular update\ntransaction.\n\nThis is also my understanding. Any presigned descendants of a NOINPUT txn\nmust also use NOINPUT as well. This chain must continue until a signer is\nonline to bind a txn to a confirmed input. The unique settlement keys thus\nprevent rebinding of settlement txns since NOINPUT with a shared script\nwould be too liberal.\n\nCheers,\nConner\n\nOn Mon, Dec 2, 2019 at 18:55 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Rusty,\n>\n> > > Hi all,\n> > > I recently revisited the eltoo paper and noticed some things related\n> > > watchtowers that might affect channel construction.\n> > > Due to NOINPUT, any update transaction can spend from any other, so\n> > > in theory the tower only needs the most recent update txn to resolve\n> > > any dispute.\n> > > In order to spend, however, the tower must also produce a witness\n> > > script which when hashed matches the witness program of the input. To\n> > > ensure settlement txns can only spend from exactly one update txn,\n> > > each update txn uses unique keys for the settlement clause, meaning\n> > > that each state has a unique witness program.\n> >\n> > I didn't think this was the design. The update transaction can spend\n> > any prior, with a fixed script, due to NOINPUT.\n> >\n> > The settlement transaction does not use NOINPUT, and thus can only\n> > spend the matching update.\n>\n> My understanding is that this is not logically possible?\n> The update transaction has no fixed txid until it commits to a particular\n> output-to-be-spent, which is either the funding/kickoff txout, or a\n> lower-`nLockTime` update transaction output.\n> Thus a settlement transaction *must* use `NOINPUT` as well, as it has no\n> txid it can spend, if it is constrained to spend a particular update\n> transaction.\n>\n> Unless I misunderstand how update transactions work, or what settlement\n> transactions are.\n>\n> Regards,\n> ZmnSCPxj\n>\n-- \n\u2014Sent from my Spaceship\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191202/00acdf73/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2019-12-04T13:48:20",
                "message_text_only": "That is correct, the chain of noinput/anyprevout transactions is broken\nas soon as the signers are online and can interactively bind and sign\nwithout noinput/anyprevout.\n\nConner Fromknecht <conner at lightning.engineering> writes:\n\n> Good evening,\n>\n>> I didn't think this was the design.  The update transaction can spend any\n> prior, with a fixed script, due to NOINPUT.\n>\n> From my reading of the final construction, each update transaction has a\n> unique script to bind settlement transactions to exactly one update.\n>\n>> My understanding is that this is not logically possible?\n> The update transaction has no fixed txid until it commits to a particular\n> output-to-be-spent, which is either the funding/kickoff txout, or a\n> lower-`nLockTime` update transaction output.\n>> Thus a settlement transaction *must* use `NOINPUT` as well, as it has no\n> txid it can spend, if it is constrained to spend a particular update\n> transaction.\n>\n> This is also my understanding. Any presigned descendants of a NOINPUT txn\n> must also use NOINPUT as well. This chain must continue until a signer is\n> online to bind a txn to a confirmed input. The unique settlement keys thus\n> prevent rebinding of settlement txns since NOINPUT with a shared script\n> would be too liberal.\n>\n> Cheers,\n> Conner\n>\n> On Mon, Dec 2, 2019 at 18:55 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Rusty,\n>>\n>> > > Hi all,\n>> > > I recently revisited the eltoo paper and noticed some things related\n>> > > watchtowers that might affect channel construction.\n>> > > Due to NOINPUT, any update transaction can spend from any other, so\n>> > > in theory the tower only needs the most recent update txn to resolve\n>> > > any dispute.\n>> > > In order to spend, however, the tower must also produce a witness\n>> > > script which when hashed matches the witness program of the input. To\n>> > > ensure settlement txns can only spend from exactly one update txn,\n>> > > each update txn uses unique keys for the settlement clause, meaning\n>> > > that each state has a unique witness program.\n>> >\n>> > I didn't think this was the design. The update transaction can spend\n>> > any prior, with a fixed script, due to NOINPUT.\n>> >\n>> > The settlement transaction does not use NOINPUT, and thus can only\n>> > spend the matching update.\n>>\n>> My understanding is that this is not logically possible?\n>> The update transaction has no fixed txid until it commits to a particular\n>> output-to-be-spent, which is either the funding/kickoff txout, or a\n>> lower-`nLockTime` update transaction output.\n>> Thus a settlement transaction *must* use `NOINPUT` as well, as it has no\n>> txid it can spend, if it is constrained to spend a particular update\n>> transaction.\n>>\n>> Unless I misunderstand how update transactions work, or what settlement\n>> transactions are.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n> -- \n> \u2014Sent from my Spaceship\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-12-03T04:00:10",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> Good morning Rusty,\n>\n>> > Hi all,\n>> > I recently revisited the eltoo paper and noticed some things related\n>> > watchtowers that might affect channel construction.\n>> > Due to NOINPUT, any update transaction can spend from any other, so\n>> > in theory the tower only needs the most recent update txn to resolve\n>> > any dispute.\n>> > In order to spend, however, the tower must also produce a witness\n>> > script which when hashed matches the witness program of the input. To\n>> > ensure settlement txns can only spend from exactly one update txn,\n>> > each update txn uses unique keys for the settlement clause, meaning\n>> > that each state has a unique witness program.\n>>\n>> I didn't think this was the design. The update transaction can spend\n>> any prior, with a fixed script, due to NOINPUT.\n>>\n>> The settlement transaction does not use NOINPUT, and thus can only\n>> spend the matching update.\n>\n> My understanding is that this is not logically possible?\n\nYou're right, no wonder I missed this problem :(\n\nOK, so we need to change the key(s) every time.  Can we tweak it based\non something the watchtower will know, i.e. something in the update tx\nitself?  Obviously not the output, as that would create a circular\ndependency.  Is there some taproot thing we can use to insert some\nnoise in the input?\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-03T04:43:27",
                "message_text_only": "Good morning Rusty,\n\n> ZmnSCPxj ZmnSCPxj at protonmail.com writes:\n>\n> > Good morning Rusty,\n> >\n> > > > Hi all,\n> > > > I recently revisited the eltoo paper and noticed some things related\n> > > > watchtowers that might affect channel construction.\n> > > > Due to NOINPUT, any update transaction can spend from any other, so\n> > > > in theory the tower only needs the most recent update txn to resolve\n> > > > any dispute.\n> > > > In order to spend, however, the tower must also produce a witness\n> > > > script which when hashed matches the witness program of the input. To\n> > > > ensure settlement txns can only spend from exactly one update txn,\n> > > > each update txn uses unique keys for the settlement clause, meaning\n> > > > that each state has a unique witness program.\n> > >\n> > > I didn't think this was the design. The update transaction can spend\n> > > any prior, with a fixed script, due to NOINPUT.\n> > > The settlement transaction does not use NOINPUT, and thus can only\n> > > spend the matching update.\n> >\n> > My understanding is that this is not logically possible?\n>\n> You're right, no wonder I missed this problem :(\n>\n> OK, so we need to change the key(s) every time. Can we tweak it based\n> on something the watchtower will know, i.e. something in the update tx\n> itself? Obviously not the output, as that would create a circular\n> dependency. Is there some taproot thing we can use to insert some\n> noise in the input?\n\nYou could always add a taproot branch with a `OP_RETURN <randomness>` tapscript, which can never be used (thus has no effect on the overall security), but can inject randomness to the outer taproot key.\nThis *is* secure, since bip-schnorr indicates that `e` is `h(R | P | m)`, with `P` being the pubkey itself, so that should be enough.\n\nOr why not BIP32 derivation?\nThis should be just as secure.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2019-12-04T13:53:39",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n> Good morning Rusty,\n>\n>> ZmnSCPxj ZmnSCPxj at protonmail.com writes:\n>>\n>> > Good morning Rusty,\n>> >\n>> > > > Hi all,\n>> > > > I recently revisited the eltoo paper and noticed some things related\n>> > > > watchtowers that might affect channel construction.\n>> > > > Due to NOINPUT, any update transaction can spend from any other, so\n>> > > > in theory the tower only needs the most recent update txn to resolve\n>> > > > any dispute.\n>> > > > In order to spend, however, the tower must also produce a witness\n>> > > > script which when hashed matches the witness program of the input. To\n>> > > > ensure settlement txns can only spend from exactly one update txn,\n>> > > > each update txn uses unique keys for the settlement clause, meaning\n>> > > > that each state has a unique witness program.\n>> > >\n>> > > I didn't think this was the design. The update transaction can spend\n>> > > any prior, with a fixed script, due to NOINPUT.\n>> > > The settlement transaction does not use NOINPUT, and thus can only\n>> > > spend the matching update.\n>> >\n>> > My understanding is that this is not logically possible?\n>>\n>> You're right, no wonder I missed this problem :(\n>>\n>> OK, so we need to change the key(s) every time. Can we tweak it based\n>> on something the watchtower will know, i.e. something in the update tx\n>> itself? Obviously not the output, as that would create a circular\n>> dependency. Is there some taproot thing we can use to insert some\n>> noise in the input?\n>\n> You could always add a taproot branch with a `OP_RETURN <randomness>` tapscript, which can never be used (thus has no effect on the overall security), but can inject randomness to the outer taproot key.\n> This *is* secure, since bip-schnorr indicates that `e` is `h(R | P | m)`, with `P` being the pubkey itself, so that should be enough.\n>\n> Or why not BIP32 derivation?\n> This should be just as secure.\n\nI still fail to see the issue, update_tx and settlement_tx are\nself-contained, and there is no need to recover the prevout scriptPubKey\nor any value therein. Are we talking about things built on top of eltoo?\n\nIf that's the case, we need to use noinput/anyprevout anyway, so why not\njust replicate the same logic and ship them bound correctly to the\nwatchtower?\n\nI'd also argue that it's not a watchtower's job to finalize the entire\noff-chain contract. It's main job is to watch the blockchain and react\nshould anything trigger it, while anything we build on top likely has\nabsolute locktimes (HTLCs have absolute timeouts), so it the client that\nknows when it has to check back in and settle anything that happened.\n\nCheers,\nChristian"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-12-03T07:33:25",
                "message_text_only": "On Tue, Nov 26, 2019 at 03:41:14PM -0800, Conner Fromknecht wrote:\n> I recently revisited the eltoo paper and noticed some things related\n> watchtowers that might affect channel construction.\n> In order to spend, however, the tower must also produce a witness\n> script which when hashed matches the witness program of the input. To\n> ensure settlement txns can only spend from exactly one update txn,\n> each update txn uses unique keys for the settlement clause, meaning\n> that each state has a _unique_ witness program.\n\nI don't believe that's necessary with the ANYPREVOUT design, see\n\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-May/001996.html\n\nThe design I'm thinking of use a common taproot internal key\nP=muSig(A,B) for update transactions. The tapscript paths are\n(with the chaperone sigs dropped):\n\n  Update n: [nLockTime = 500e6+n]\n    script: OP_1 CHECKSIGVERIFY [500e6+n+1] CLTV\n    witness: [ANYPREVOUTANYSCRIPT sig]\n\n  Settlement n: [nSequence = delay; nLockTime=500e6+n+1]\n    witness: [ANYPREVOUT sig]  \n\n(This relies on having the two variants of ANYPREVOUT, one of which\ncommits to the state number via commiting to the [500e6+n+1] value in\nthe update tx's script, so that you don't need unique keys to ensure\nsettlement tx n can't spend settlement tx n+k)\n\nWith this you can tell which update was posted by subtracting 500e6 from\nthe nLocktime, and use that to calculate the tapscript the update tx used,\nand the internal key is constant.\n\nThe watchtower only needs to post the update tx -- as long as the latest\nupdate is posted, the only tx that can spend it is the correct settlement,\nso you can post that whenever you're back online, even if that's weeks\nor months later, and likewise for actually claiming your funds from the\nsettlement tx's outputs.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-03T08:26:22",
                "message_text_only": "Good morning aj,\n\n\n> The watchtower only needs to post the update tx -- as long as the latest\n> update is posted, the only tx that can spend it is the correct settlement,\n> so you can post that whenever you're back online, even if that's weeks\n> or months later, and likewise for actually claiming your funds from the\n> settlement tx's outputs.\n>\n\nThis is mildly undesirable, as one of the failure modes is total loss / destruction of your Lightning node.\n\nIf the blob contains enough information to bring the update *and* the settlement *and* a transaction that spends your output of the settlement and sends it to a cold-storage address, then at least part of your funds (the ones that are not in HTLCs you could have claimed) can be placed back by the watchtower to some cold-storage address (that is controlled by different hardware from your Lightning node).\n\nThough this is arguably an edge case and it may be a worthwhile tradeoff to just have the watchtower handle up to update transaction only, especially since `SIGHASH_NOINPUT` use we propose expects to have fees paid by another output, not what is being used in the update transaction.\nThis reduces the scope of watchtowers, simplifying their implementation, increasing the chance we can deploy a watchtower network feasibly.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2019-12-04T13:46:30",
                "message_text_only": "(I wrote this a couple of days ago but forgot to send it, sorry for that)\n\nHi Conner,\n\nthanks for looking into this. I hadn't really thought too much about\nwatchtowers while writing the paper, so there might definitely be things\nI hadn't considered. I fail to see where the watchtower needs to\ngenerate the witness script if he's given the update transaction and the\nmatching settlement transaction (see deployment option 2 below).\n\nThere are a couple of deployment options for watchtowers, from simple\nforward ratchetting to fully settling watchtowers. As you correctly\npoint out if the watchtower just ratchets forward the state, all it\nneeds is the latest update transaction that is bindable to any prior\nupdate transaction and therefore the per-channel state is a single\nupdate transaction. The channel operator would then come back at a later\ntime, when the watchtower has ratchetted forward and prevented any cheat\nattempt by the counterparty and just release the latest settlement tx.\n\nThis is the model I had in mind when writing since it has constant\nper-channel state on the watchtower independent of the number of updates\nand of the size of the state (HTLCs, simple outputs, ...)  attached to\nthat settlement. This is safe since the operator knows when it has to\ncheck back in at the latest in order to settle HTLCs built on top since\nthey have absolute locktimes (this is not true if we start building\nrelative locktime things on top of eltoo channels, but let's keep it\nsimple for now).\n\nThe second deployment option is to give the watchtower the settlement\ntransaction along with the update transaction. The settlement\ntransaction is fully signed and uses noinput/anyprevout to bind to the\nupdate, so the bundle of update and settlement transactions is\nbroadcastable right away, no need to produce any scripts or\nsignatures. This ensures that we at least drop the correct state\non-chain, but comes at the cost of the watchtower learning intermediate\nstates, or at least the size of the state (number of outputs) if we\nencrypt it.\n\nA third deployment option would be to allow the watchtower the ability\nto further settle things we built on top of the base eltoo contract,\nsuch as HTLCs, but at that point we are leaking a lot of information,\nwatchtowers become very complex and we lose the flexibility of having\nclear layering.  If we are aiming for this third option indeed the\nwatchtower would also need the ability to bind the HTLC settlement or\nwhatever we build on top of eltoo, which implies they'd also use\nnoinput/anyprevout, but that's hardly an issue, as long as the binding\nis unique.\n\nCheers,\nChristian\n\nConner Fromknecht <conner at lightning.engineering> writes:\n> Hi all,\n>\n> I recently revisited the eltoo paper and noticed some things related\n> watchtowers that might affect channel construction.\n>\n> Due to NOINPUT, any update transaction _can_ spend from any other, so\n> in theory the tower only needs the most recent update txn to resolve\n> any dispute.\n>\n> In order to spend, however, the tower must also produce a witness\n> script which when hashed matches the witness program of the input. To\n> ensure settlement txns can only spend from exactly one update txn,\n> each update txn uses unique keys for the settlement clause, meaning\n> that each state has a _unique_ witness program.\n>\n> Naively then a tower could store settlement keys for all states,\n> permitting it to reconstruct arbitrary witness scripts for any given\n> sequence of confirmed update txns.\n>\n> So far, the only work around I\u2019ve come up with to avoid this is to\n> give the tower an extended parent pubkey for each party, and then\n> derive non-hardened settlement keys on demand given the state numbers\n> that get confirmed. It's not the most satisfactory solution though,\n> since leaking one hot settlement key now compromises all sibling\n> settlement keys.\n>\n> Spending the unique witness programs is mentioned somewhat in section\n> 4.1.4, which refers to deriving keys via state numbers, but to me it\n> reads mostly from the PoV of the counterparties and not a third-party\n> service. Is requiring non-hardened keys a known consequence of the\n> construction? Are there any alternative approaches folks are aware of?\n>\n> Cheers,\n> Conner\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "eltoo towers and implications for settlement key derivation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Rusty Russell",
                "Anthony Towns",
                "Christian Decker",
                "Conner Fromknecht"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 21644
        }
    },
    {
        "title": "[Lightning-dev] [DRAFT] BOLT 13(?): WatchTower protocol",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-12-03T00:26:11",
                "message_text_only": "Hi Sergi!\n\n        Great to see progress on this!  Detailed comments below.\n\nSergi Delgado Segura <sergi.delgado.s at gmail.com> writes:\n> ## Sending and receiving appointments\n>\n> Once the client is aware of the services provided by the server, the former\n> can start sending appointments to the latter.\n>\n> +-------+                                    +-------+\n> |   A   |--(1)---      appointment      ---->|   B   |\n> |       |<-(2)---   accepted/rejected   -----|       |\n> +-------+                                    +-------+\n>\n> - where node A is 'client' and node B is 'server'\n>\n> ### The `appointment` message\n>\n> This message contains all the information regarding the appointment that\n> the client wants to arrange with the server.\n>\n> 1. type: ? (`appointment`)\n> 2. data:\n>    * [`16*byte`:`locator`]\n>    * [`u64 `:`start_block`]\n>    * [`u64 `:`end_block`]\n\nu32 is sufficient for start_block, fwiw.\n\n>    * [`u16`: `encrypted_blob_len`\n>    * [`encrypted_blob_len*byte`:`encrypted_blob`]\n>    * [`u16`:`cipher`]\n>    * [`u16`: `auth_token_len`]\n>    * [`auth_token_len*byte`: `auth_token`]\n>    * [`u16`: `qos_len`]\n>    * [`qos_len*byte`: `qos_data`]\n>\n> #### Requirements\n>\n> The client:\n>\n> * MUST set `locator` as specified in [Transaction Locator and Encryption\n> Key](#transaction-locator-and-encryption-key).\n> * MUST set `start_block` to the current chain tip height.\n\nWhat is the purpose of this field?  Presumably the watcher knows the\ncurrent block number.\n\nI suggest you want this to be \"the first possible block in which the\ntransction can occur\"?\n\n> * MUST set `end_block` to the block height at which he requests the server\n> to stop watching for breaches.\n\nI don't know how you would set that.  I think you need this to be\nseparate: either as part of the payment layer (I will watch for a year),\nor an explicit \"stop watching\" message (assuming that you pay for\ncertain capacity).\n\n> * MUST set `encrypted_blob` to the encryption of the `justice_transaction`\n> as specified in [Transaction Locator and Encryption\n> Key](#transaction-locator-and-encryption-key).\n\nThe phrase used in the spec is penalty transaction, BTW.  Especially\nsince its use is generally an injustice :)\n\n> * MUST set `cipher` to the cipher used to create the `encrypted_blob`.\n\nDon't do this.  Pick a cipher already used elsewhere in the protocol.\nchacha20 is a good choice.\n\n> * MAY send an empty `auth_token` field.\n> * MUST set `auth_token_len` to the length of `auth_token`.\n\nThe latter is already written in the spec.  But these days, optional\nfields are implemented as TLV data, so perhaps use that instead.\n\n> * MAY send an empty `qos_data` field.\n> * if `qos_data` is not empty:\n> *  MUST set `qos_data` according to [Quality of Service\n> data](#quality-of-service-data).\n> * MUST set `qos_len` equal to the length of `qos_data`.\n\nI would drop the idea of \"qos\", and again use TLV data, defining\naccountability.  Others can be added later.\n\n> The server:\n>\n> * MUST reject the appointment if:\n> * Authentication is required and `auth_token` is not provided.\n> * Authentication is required and `auth_token` is invalid.\n\n> * `locator` is not a `16-byte` value.\n\nThis cannot happen, so eliminate it.\n\n> * `start_block` is further than one block behind the current chain tip.\n> * `start_block` is further than one block ahead the current chain tip.\n\nI'm still not sure what start_block is for.  It just seems to make\nthings fragile if blocks arrive quickly.\n\n> * `encrypted_blob` has unreasonable size.\n> * `cipher` is not among the ones he implements.\n>\n> * SHOULD reject the appointment if`end_block` is too far away in the future.\n\nThis is a problem, since in practice we'll have to define what that is.\n\n> * MUST:\n> * truncate the remainder of the package to `qos_len`.\n> * process `qos_data` according to [Quality of Service\n> data](#quality-of-service-data) if `qos_len` is not 0.\n>\n> * MAY accept the appointment otherwise.\n\nI would suggest:\n\n        * If it accepts the appointment:\n           * MUST send `accepted`\n        * Otherwise:\n           * MUST send `rejected`\n\n> #### Rationale\n>\n> We define appointment as the way that the WatchTower is hired / requested\n> by a client to do it's watching services.\n>\n> WatchTowers may offer their services for free (`altruistic`) or they may\n> require a payment when accepting the job (`non-altruistic`). We have\n> defined `auth_token` as an authentication mechanism between the client and\n> server, so the client can prove they are entitled to the service. The\n> tokens are not required to be linked to any kind of identity (e.g. blinded\n> tokens), but their sole purpose is to confirm the client has already paid\n> for the service.\n>\n> The transaction `locator` can be deterministically computed by both the\n> client and the server. Locators of wrong size are therefore invalid.\n>\n> `start_block` can be either one block ahead or behind the tower tip due to\n> network delays. A tower must not accept appointments arbitrarily ahead or\n> behind the current tip since it could increase DoS vectors. A `start_block`\n> long behind would force the tower to rescan block data for those\n> appointments instead of watching block by block. On the other hand, a\n> `start_time` long ahead would imply storing information way before it being\n> needed.\n\nI think the watchtower should respond with the start_time, instead, so\nthe caller knows how much work they have to do.  And perhaps the\nend_time, but to be honest I'd add that later.\n\n> `minimum_viable_transaction_size` and `maximum_viable_transaction_size`\n> refer to the minimum/maximum size required to create a valid transaction.\n> Accepting `encrypted_blob` outside those boundaries will increase DoS\n> attacks on the server.\n\nThese values need to be defined.  If the user is paying for storage, the\nwatchtower doesn't care.\n\n> ### The `appointment_accepted` message\n>\n> This message contains information about the acceptance of an appointment by\n> the WatchTower.\n>\n> 1. type: ? (`appointment_accepted `)\n> 2. data:\n>    * [`16*byte `:`locator`]\n>    * [`u16`: `qos_len`]\n> * [`qos_len*byte`: `qos_data`]\n>\n> The server:\n>\n> * MUST receive `appointment` before sending an `appointment_accepted`\n> message.\n> * MUST set the `locator` to match the one received in `appointment`.\n> * if `qos_data` was requested in `appointment`:\n> *  MUST set `qos_data` according to [Quality of Service\n> data](#quality-of-service-data).\n> * MUST set `qos_len` equal to the length of `qos_data`.\n>\n> The client:\n>\n> * MUST fail the connection  if `locator` does not match any of locators the\n> previously sent to the server:\n>\n> * if `qos` was requested in `appointment`:\n> * MUST fail the connection if `qos_len` is 0.\n> * MUST process `qos_data` according to [Quality of Service\n> data](#quality-of-service-data).\n>\n> ### The `appointment_rejected` message\n>\n> This message contains information about the rejection of an appointment by\n> the WatchTower.\n>\n> 1. type: ? (`appointment_rejected `)\n> 2. data:\n>    * [`16*byte `:`locator`]\n>    * [`u16`: `rcode`]\n>    * [`u16`: `reason_len`\n>    * [`reason_len*byte`: `reason`]\n>\n> The server:\n>\n> * MUST receive `appointment` before sending an `appointment_rejected`\n> message.\n> * MUST set the `locator` to match the one received in `appointment`.\n> * MUST set `rcode` to the rejection code.\n> * MAY set and empty `reason` field.\n> * MUST set `reason_len` to length of `reason`.\n\n`rcode` needs to be defined.  In practice, that's a very difficult\ntask.  You may just want to define transient vs permanently errors?\n\n> #### Rationale\n>\n> The `appointment_rejected` message follows the approach taken by the\n> `error` message defined in [BOLT#1](\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message):\n> error codes are mandatory, whereas reasons are optional and implementation\n> dependant.\n>\n> ## Quality of Service data\n>\n> `qos_data` is a list where each field specifies they type and associated\n> data of the offered/requested `qos`. The format is defined as follows:\n>\n> * [`u16`: `qos_type`]\n> * [`u16`: `data_len`]\n> * [`data_len*byte`: `data`]\n>\n> So far, only `accountability` is defined.\n>\n> ### `accountability`\n>\n> The accountability `qos` defines a pair `qos_data` blobs, associated to a\n> pair of messages: The first one is `customer_evidence` and it is provided\n> by the `client` in the `appointment` message. The second one is\n> `tower_evidence`, and is provided by the WatchTower in the\n> `appointment_accepted` message.\n>\n> #### `customer_evidence`\n>\n> The format for the `customer_evidence` is defined as follows:\n>\n> 1. type: ? (`customer_evidence`)\n> 2. data:\n> * [`u64 `:`dispute_delta`]\n> * [`u64`: `transaction_size`]\n> * [`u64`: `transaction_fee`]\n>\n> If `accountability` is being requested, the client:\n>\n> * MUST set `dispute_delta` to the CLTV value specified in the\n> `commitment_transaction`.\n\nI don't understand this field.  I assume you're talking about the\n`to_self_delay` the customer requested of its peer.  But I don't\nunderstand why the tower would care: isn't it just going to broadcast\nthe tx as soon as it sees the violation?\n\n> * MUST set `transaction_size` to the size of the serialized\n> `justice_transaction`, in bytes.\n> * MUST set `transaction_fee` to the fee set in the `justice_transaction`,\n> in satoshis.\n\nJust use chacha20, then the size of the transaction is well-defined.\n\nBut I don't understand why the fee matters.  Neither the watchtower nor\nthe customer knows what fee will be needed in the future: all the\nwatchtower can do is broadcast what it's given.  Unless there's some\nagreement on an output for the watchtower to CPFP (which, IMHO is best\nleft to a future extension), but the fee here still doesn't really\nmatter.\n\n> * MUST set the `customer_signature_algorithm` to one of the signature\n> algorithms supported by the tower.\n> * MUST set `customer_signature` to the signature of the appointment using\n> `op_customer_signature_algorithm`.\n> * MUST set `customer_public_key` to the public key that matches the private\n> key used to create `op_customer_signature`.\n\nThese aren't defined above (and again, don't define multiple signature\nalgorithms.\n\nYou should define here exactly what fields are signed, since this\nmessage is inside the `appointment`.  But it's not clear what purpose\nthis signature serves?\n\n> If `accountability` is being offered, the server:\n>\n> * MUST compute the `customer_signature` verification using\n> `customer_public_key`.\n> * SHOULD compute the `fee_rate` set in the `justice_tx` using\n> `transaction_size` and `transaction_fee`.\n>\n> * MUST reject the appointment if:\n> * Any of the fields is missing.\n> * `transaction_size` is unreasonable.\n> * `customer_signature_algorithm` does not match any of the supported\n> signing algorithms.\n> * `customer_signature` cannot be verified using `customer_public_key`.\n>\n> * SHOULD reject the appointment if:\n> * `dispute_delta` is too small.\n> * `fee_rate` is too low.\n>\n> If `accountability` is NOT being offered:\n>\n> * The server MUST reject the appointment.\n>\n> Otherwise:\n>\n> * The server SHOULD accept the appointment.\n>\n> #### Rationale\n>\n> The concept of too small for `dispute_delta` is subjective. The\n> `dispute_delta` defines the time (in blocks) that the tower has in order to\n> respond after a breach is seen. The smaller the value, the more the server\n> risks to fail the appointment.\n>\n> `transaction_size` and `transaction_fee` help the WatchTower to decide on\n> the likelihood of an appointment being fulfilled. Appointments with\n> `fee_rate` too low may be rejected by the WatchTower. While a customer can\n> always fake this values, it should break ToS between the client and the\n> server and, therefore, release the WatchTower of any liability.\n>\n> By accepting the request, the tower is offering a reputationally\n> accountable watching service. If `accountability` is not offered, then the\n> tower will not accept appointments requesting for it.\n>\n> As well, the WatchTower must check the transaction details before deciding\n> whether it will accept it. If the decrypted justice transaction does not\n> satisfy the job details (e.g. too low fee), then the tower is not obliged\n> to fulfil the appointment.\n>\n> #### `tower_evidence`\n>\n> The format for the `tower_evidence` is defined as follows:\n>\n> 1. type: ? (`tower_evidence`)\n> 2. data:\n> * [`u16 `:`receipt_len`]\n> * [`receipt_len*byte `: `receipt`]\n> * [`u16`: `wt_signature_algorithm`]\n> * [`u16`: `wt_signature_len`\n> * [`wt_signature_len*byte`: `wt_signature`]\n> * [`u16`: `wt_public_key_len`]\n> * [`wt_public_key_len*byte`: `wt_public_key`]\n>\n> The server:\n>\n> * MUST set `receipt` to a receipt built according to\n> [Receipt-Format](#receipt-format).\n> * MUST set `wt_signature_algorithm` to one of the signature algorithms he\n> has announced.\n> * MUST set `wt_signature` to the signature of the appointment using\n> `wt_signature_algorithm`.\n> * MUST set `wt_public_key` to the public key that matches the private key\n> used to create `wt_signature`.\n\nWhat good is a proof if the watchtower can set a random public key?\n\nPresumably you want the watchtower to sign the txlocator, start_block\nand encrypted blob with a known key.  Then you have a proof that it has\naccepted it.\n\n> The client:\n>\n> * MUST compute the `wt_signature` verification using `wt_public_key`.\n>\n> * MUST fail the connection if:\n> * Any of the fields is missing.\n> * `receipt` does not matches the format specified at\n> [Receipt-Format](#receipt-format)\n> * `receipt` fields do not match the ones sent in the `appointment` message.\n> * `wt_signature_algorithm` does not match any of the ones offered by the\n> server.\n> * `wt_signature` cannot be verified using `wt_public_key`.\n>\n> #### Receipt Format\n>\n> The server MUST create the receipt containing the following information:\n>\n> txlocator\n> start_block\n> end_block\n> dispute_delta\n> encrypted_blob\n> transaction_size\n> transaction_fee\n> cipher\n> customer_signature\n> wt_public_key\n>\n>\n> #### Rationale\n>\n> We assume the client has a well-known public key for the WatchTower.\n>\n> The receipt contains, mainly, the information provided by the user. The\n> WatchTower will need to sign the receipt to provide evidence of agreement.\n>\n> The `customer_signature` is included in the receipt to link both the client\n> request and the server response. Otherwise, the tower could sign a receipt\n> with different data that the one sent by the user, and the user would have\n> no way to prove whether that's true or not. By signing the customer\n> signature there the tower creates evidence of what the user sent, since the\n> tower cannot forge the client's signature.\n>\n> #### Receipt serialization and signature\n>\n> [FIXME: TBD]\n>\n> ## Transaction Locator and Encryption Key\n>\n> Implementations MUST compute the `locator`, `encryption_key` and\n> `encryption_iv` from the commitment transaction as defined below:\n>\n> - `locator`: first half of the commitment transaction id\n> (`commitment_txid(0,16]`)\n> - `master_key`: Hash of the second half of the commitment transaction id\n> (`SHA256(commitment_txid(16,32])`)\n> - `encryption_key`: first half of the master key (`master_key(0,16]`)\n> - `encryption_iv`: second half of the master key (`master_key(16,32]`)\n>\n>\n> The server relies on both the encryption key and iv to decrypt the justice\n> transaction. Furthermore, the transaction locator helps the WatchTower\n> identify a breach transaction on the blockchain.\n\nThe SHA256 step here is crypto cargo-culting AFAICT.  If the watchtower\ncan guess the txid, it does nothing.  If it can't, it does nothing.\n\nSetting both the IV and the key is similarly weird.  Use an IV of 0 and\nsimply use the second half of the commit txid as key.\n\n> ## Encryption Algorithms and Parameters\n>\n> All clients and servers MUST use one of the following encryption\n> algorithms:\n>\n> - ChaCha20 (https://tools.ietf.org/html/rfc7539)\n> - AES-GCM-256 (https://tools.ietf.org/html/rfc5288)\n\nThis would be the first use of AES, and you need to implement chacha20\nto speak to other peers.  Drop this.\n\n> Sample code (python) for the client to prepare the `encrypted_blob`:\n>\n> from hashlib import sha256\n> from binascii import hexlify\n>\n> def encrypt(justice_tx, commitment_txid):\n>    # master_key = SHA256(commitment_txid(16, 32])\n>    master_key = sha256(commitment_txid[16:]).digest()\n>\n>    # The 16 MSB of the master key will serve as the AES-GCM-256 secret key.\n> The 16 LSB will serve as the IV.\n>    sk = master_key[:16]\n>    nonce = master_key[16:]\n>\n>    # Encrypt the data\n>    aesgcm = AESGCM(sk)\n>    encrypted_blob = aesgcm.encrypt(nonce=iv, data=tx, associated_data=None)\n>    encrypted_blob = hexlify(encrypted_blob).decode()\n>\n>    return encrypted_blob\n\n> ## Payment modes\n>\n> Although this BOLT does not enforce any specific payment method to be\n> adopted, it is worth mentioning the three most common ones:\n>\n> **On-chain bounty**. An additional output is created in the justice\n> transaction that will reward the WatchTower.\n\nThis has the advantage of allowing (and incentivizing!) the WatchTower\nto CPFP.  However, it has to be defined (how does client know what addr\nto pay to?), so I'd leave it for later.\n\n> **Micropayments**. A small payment is sent to the WatchTower for every new\n> job (e.g. over the lightning network)\n>\n> **Subscription**. WatchTower is periodically rewarded / paid for their\n> service to the customer. (e.g. over the lightning network or fiat\n> subscription).\n>\n> Both micropayments and subscriptions are favourable for a WatchTower. The\n> on-chain bounty approach is not ideal for a watching network, it lets the\n> customer hire many WatchTowers (O(N) storage for each tower) and only one\n> WatchTower will be rewarded upon collecting the bounty. On top of that, the\n> onchain bounty allows a network-wise DoS attack for free.\n\n> ## No compression of justice transaction\n>\n> The storage requirements for a WatchTower can be reduced (linearly) by\n> implementing [shachain](\n> https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt),\n> therefore storing the parts required to build the transaction and the\n> corresponding signing key instead of the full transaction. For now, we have\n> decided to keep the hiring protocol simple. Storage is relatively cheap and\n> we can revisit this standard if it becomes a problem.\n\nAgreed.\n\nCheers,\nRusty."
            },
            {
                "author": "Sergi Delgado Segura",
                "date": "2019-12-05T16:21:10",
                "message_text_only": "Hey Antoine, thanks for the feedback.\n\nOn Fri, Nov 29, 2019 at 6:43 AM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Thanks for working on this, a bunch of interesting ideas!\n>\n> I think it could be noted in the motivation, that's having an interoperable\n> watchtower protocol is really cool, because every watchtower you add is\n> a liveness reliability increase (modulo privacy loss), specially if these\n> watchtowers are from different implementations in case of a vuln affecting\n> breach\n> monitoring code of your LN node.\n>\n> Some generic remarks, you should define another TCP port than the LN one\n> of 9735\n> because this is client-server relationship and you want to avoid leak of\n> p2p\n> messages to your watchtower.\n>\n\nWe considered that, but we're unsure about whether that would be the best\nway to go, or it would be better to add additional messages at a p2p level.\nAlso there's the option of piggybacking information using the current\nmessages, which is the approach followed by lnd at the moment IIRC.\n\n\n> Messages should also use the TLV format, will remove a lot *_len field and\n> each\n> QoS could be a tlv_record in `appointment`.\n>\n\nI'll look into the TLV format and redesign it accordingly.\n\n\n>\n> For the init protocol, I was considering the following scheme.\n>\n>\n>                         init\n>                 ---------------------->\n>\n>                         version\n>                 <----------------------\n>        Alice                                 Bob\n>                     payment protocol\n>                 ----------------------->\n>                          ...\n>\n>                     appointment hiring\n>                 ----------------------->\n>                          ...\n>\n>                     appointment firing\n>                 ----------------------->\n>\n> The `init` message would contain a method to establish a secure connection\n> between client and server. Watchtower shouldn't learn LN pubkey of client\n> as it may be a conflict of interest and be leveraged to build more\n> sophisticated\n> attacks. So client should implement identity contingement properly and use\n> the `init` message to start a Noise session or something like BIP324.\n>\n\nWe were thinking on not having any way of linking appointments from the the\nsame user. The only \"identity\" we were considering is the `auth_token`,\nthat can easily be used as a nonce. It's also possible to use the same for\nmultiple appointments, depending on the user.\n\n\n>\n> After secure connection establishement, `version` would be the reply with\n> a features field, wider than only QoS like also the payment protocol\n> supported,\n> and maybe an invoice for the payment protocol preferred. In a future,\n> features may\n> extend beyond channel watching, like timing out client HTLC or\n> synchronization\n> server for multi-party channels...\n>\n\nAgreed, we were thinking on something similar. The peer discovery has not\nbeen defined yet, but it seems reasonable for the tower to advertise the\nservices it offers on the first message. An init approach as you proposed\nseems to have the problem of how the user finds the tower. On the other\nhand, if there's a peers discovery (either trough DNS seed or something\ndifferent) the init/version steps can be simplified.\n\n\n>\n> Client would then execute the one or multiple steps of the payment\n> protocol.\n> This one may be complex, i.e include parameters negotiation like update\n> rate-limiting, feerate for encrypted blob, storage throttling after time\n> X, ...\n> I do think this kind of parameters belong there compare to\n> `appointment_hiring`,\n> as they may cover watching operations of one or more channels and secondly\n> they\n> are DoS protections, and payment scheme and DoS are going to be really tied\n> in watchtowers protocol.\n>\n\nAgreed, the user should provide proof of payment in the\n`appointment_hiring` but all the steps to accomplish that should be done\nbeforehand.\n\n\n>\n> Then `appointment_hiring` with QoS and their parameters, is there reasons\n> for\n> not having them being stable for the lifetime of client-server interaction\n> ?\n>\n\nWell, as I was saying we were thinking on avoiding having any link between\ndifferent appointments from the same user, therefore specifying it\nappointment-wise.\n\n\n>\n> Finally, some `appointment_firing` to let the client cut its subscription\n> and\n> authorize the server to clean storage.\n>\n\nThat's the reasoning behind the `end_block`, allowing the tower to clean\nthe data after a certain time.\n\n\n>\n>\n> > * `start_block` is further than one block behind the current chain tip.\n> > * `start_block` is further than one block ahead the current chain tip.\n>\n> Is a 3 block window enough if the client is a mobile which a lot of\n> latency and weak\n> processing compare to a watchtower's competitive full-node ? I think it's\n> only\n> a block issuance edge case but maybe could be easier if client set\n> start_block to\n> current_seen_block_height+6 and server would reject if height already\n> past..\n>\n\nThe 3 block window was defined as a way for the tower to learn whether the\nclient was up to date or not. Also a malicious user may try to hire a tower\nto look for something that's already resolved in the blockchain making the\ntower do \"the heavy lifting\" of parsing information from arbitrarily old\nblocks. 3 is also an arbitrary number, and can be extended. It would also\nwork for the tower to advertise it's tip and for the user to agree on that.\n\n\n>\n> > minimum_viable_transaction_size and maximum_viable_transaction_size\n> refer to the minimum/maximum size required to create a valid transaction.\n>\n> Couldn't these limits be implictly MAX_STANDARD_TX_WEIGHT and\n> MAX_STANDARD_TX_NONWITNESS_SIZE, current mempool policy limits ?\n>\n\nTrue, but those are not consensus rules (AFAIK at least) so they are\nsubjective to change. I think some sanity checks from the tower side may be\nworthy. It's also worth noting that this checks only prevent naive attacks,\nsince properly formatted blobs would pass the them.\n\n\n>\n> Also, nothing is specified on disconnection/reconnection, you want to be\n> sure than\n> watchtower as ACK every justice tx sent as every one of them maybe\n> critical. A client\n> doesn't want to assume is channel is covered and finally not due to its\n> network\n> connection being rotten.\n>\n\n\nIt may be worth having some kind of ack, but it's also worth mentioning\nthat the user may be offline (since that's one of the main use cases of the\ntowers), so sending and ack may be useful but we shouldn't rely on the\nassumption that the user will receive it.\n\n\n>\n>\n> > * MUST set `dispute_delta` to the CLTV value specified in the\n> > `commitment_transaction`.\n>\n> What's a dispute delta ? You mean the justice-CSV locktime encumbering\n> outputs ?\n> Given this one is fixed at channel opening, it should be fixed also for\n> the channel\n> hiring lifetime. And server should announce a min_dispute_delta at QoS\n> `accountability`\n> announcement.\n>\n\nYes, that's what we meant. Sorry for not using the proper naming. Same\nreasoning as before, in our proposal the tower has no clue whether two\nappointments are from the same channel or not. I guess it's worth\ndiscussing if this makes sense or if it's better to switch to an approach\nwhere they can be linked even if it leaks some information about the\nchannel usage.\n\n\n>\n> > * MUST set `transaction_size` to the size of the serialized\n> > `justice_transaction`, in bytes.\n>\n> I would remove the transaction size, given that all outputs are\n> standardized in LN, that would\n> be a leak on how much payment traffic is going through the client without\n> any channel breach.\n>\n> > * MUST set `transaction_fee` to the fee set in the `justice_transaction`,\n> > in satoshis.\n>\n> Generally, the idea to provide justice tx with pre-signed fees to a\n> watchtower and expect\n> this one to do is job reliably somewhere in the future seem a weak\n> assumption... Every watchtower\n> following this protocol should handle dynamic fees, that's should be a\n> basic service not even\n> a QoS. It may through CPFP (but won't be reliable until package relay( or\n> RBF'ing the justice\n> tx through usage of SIGHASH_ANYONECANPAY, no need interactivity with the\n> user at broadcast,\n> but you may need a populated input mempool.\n>\n\nThe original idea of both the fee and size was to allow the tower to decide\nwhether or not it would be able to relay the transaction (specially in the\ncase where the end_time is close to the current time). Thinking about it\ntrough though it seems a pretty weak assumption, since in most of the cases\nthe tower may not be able to predict future fees. I do like the idea of\nthe SIGHASH_ANYONECANPAY approach to allow the tower to bump the fees. I'll\nneed to think more about it.\n\n> While a customer can always fake this values, it should break ToS between\n> the client and the\n> server and, therefore, release the WatchTower of any liability\n>\n> I can imagine with machine-readable proofs a bot fetching proofs servers,\n> verifying them\n> on the blockchain and scoring in consequence watchtowers. Good marks could\n> be done via\n> some tagging of justice tx (like setting nLocktime in the past to some\n> value). You would\n> negotiate a different tag for everyone of your watchtower. Removing\n> feerate from the equation\n> would simplify scoring as now you don't have to guess if mempool was\n> congestionned or not for\n> the client-provided fee.\n>\n> > On top of that, the onchain bounty allows a network-wise DoS attack for\n> free.\n>\n> A good point of the onchain bounty is the user doesn't pay for inefficient\n> watchtower or\n> suppleous watchtower. But seems hard to implement DoS-wise and at the same\n> time keep the\n> requirement of pseudonymous clients. Nevertheless a note maybe said on a\n> LN node implementing\n> some kind of anyone-can-spend on top of its txn and let the vigilant crowd\n> bid with fees\n> and confirm your punishment, that's would be the \"watchtowerless\n> watchtower protocol\" :p\n>\n\nYep, we agree is not a straightforward problem to solve, so open to ideas!\n\n\n>\n> > That would break appointment unlinkability but would ease the data\n> > management for the tower.\n>\n> Unlinkability should be far higher in the BOLT design decisions, I think\n> people may don't\n> care about unlinkability in case of all watchtowers servers are running\n> under same\n> organization but they are interested by some building blocks of this spec\n> like tracking ACK\n> or fees management delegation. So we may have multiple formats for the\n> transaction\n> locator/encryption and one of them being the empty one ?\n>\n\nI don't follow you here :sweet_smile:\n\n\n>\n> > The `customer_signature` could be optional if the client does not care\n> > that much about the worst case. Dicuss whether that makes sense.\n>\n> I think you're right it can be skipped as client has provided a signed\n> justice\n> tx as an implicit commitment ?\n>\n> Okay that's a lot and it's really IMO, I do think that's important to have\n> a flexible protocol\n> with a lot of room for further privacy/efficiency/services upgrades and\n> circumvent non-seen now\n> complexity. If watchtowers are economically/sociably viable it maybe a\n> layer of its own!\n>\n\nAgreed, that's one of the reasons why some of the bits haven't been defined\nyet, since we're unsure what the community thinks about embedding this\nwithin the protocol or having something on top of it.\n\n\n>\n> Le mer. 27 nov. 2019 \u00e0 15:20, Sergi Delgado Segura <\n> sergi.delgado.s at gmail.com> a \u00e9crit :\n>\n>> Hi all,\n>>\n>> Patrick McCorry and I have been working on putting together a BOLT draft\n>> for WatchTowers. So far we've seen a couple of implementation of\n>> WatchTowers in the wild (lnd and Electrum) based on Tadge's Monitor\n>> approach and we are also working on our own one. While all are similar,\n>> they differ in some points that may make then non interoperable, so it felt\n>> right time to put some effort and try to standardise this. We've borrowed\n>> ideas from all implementations as well as from the original approach and\n>> added some additional bits to extended with different quality of service.\n>> The draft is still rough on the edges and have several open discussion\n>> topics at the very end (#FIXME section).\n>>\n>> Best,\n>>\n>> # WatchTower protocol specification (BOLT DRAFT)\n>>\n>> ## Overview\n>>\n>> All off-chain protocols assume the user remains online and synchronised\n>> with the network. To alleviate this assumption, customers can hire a third\n>> party watching service (a.k.a WatchTower) to watch the blockchain and\n>> respond to channel breaches on their behalf.\n>>\n>> At a high level, the client sends an encrypted justice transaction\n>> alongside a transaction locator to the WatchTower. Both the encryption key\n>> and the transaction locator are derived from the breach transaction id,\n>> meaning that the WatchTower will be able to decrypt the justice transaction\n>> only after the corresponding breach is seen on the blockchain. Therefore,\n>> the WatchTower does not learn any information about the client's channel\n>> unless there is a channel breach (channel-privacy).\n>>\n>> Due to replace-by-revocation Lightning channels, the client should send\n>> data to the WatchTower for every new update in the channel, otherwise the\n>> WatchTower may not be able to respond to specific breaches.\n>>\n>> Finally, optional QoS can be offered by the WatchTower to provide\n>> stronger guarantees to the client, such as a signed receipt for every new\n>> job. The rationale for the receipt is to build an _accountable_ WatchTower\n>> as the customer can later use it as publicly verifiable evidence if the\n>> WatchTower fails to protect them.\n>>\n>> The scope of this document includes:\n>>\n>> - A protocol for client/server communication.\n>> - How to build appointments for the WatchTower, including key/locator\n>> derivation and data encryption.\n>> - A format for the signed receipt.\n>>\n>> The scope of this bolt does not include:\n>>\n>>  - A payment protocol between the customer and WatchTower.\n>>  - WatchTower server discovery.\n>>\n>> For the rest of this document we will refer to the WatchTower as server,\n>> and the user/Lightning node as client.\n>>\n>> ## Table of Contents\n>> * [WatchTower discovery](#watchtower-discovery)\n>> * [WatchTower services](#watchtower-discovery)\n>> * [Basic Service](#basic-service)\n>> * [Quality of Service](#quality-of-service)\n>> * [Sending and receiving\n>> appointments](#sending-and-receiving-appointments)\n>>   * [The `appointment` message](#the-appointment-message)\n>>   * [The `appointment_accepted`\n>> message](#the-appointment_accepted-message)\n>>   * [The `appointment_rejected`\n>> message](#the-appointment_rejected-message)\n>> * [Quality of Service data](#quality-of-service-data)\n>> * [`accountability`](#accountability)\n>> * [Transaction Locator and Encryption\n>> Key](#transaction-locator-and-encryption-key)\n>> * [Encryption Algorithms and\n>> Parameters](#encryption-algorithms-and-parameters)\n>> * [Payment Modes](#payment-modes)\n>> * [No compression of justice\n>> transaction](#no-compression-of-justice-transaction)\n>>\n>> ## WatchTower discovery\n>>\n>> We have not defined how a client can find a list of servers to hire yet.\n>> We assume the client has found a server and the server is offering a\n>> watching service. The service can either be the basic service or an\n>> accountable quality of service. To deal with pre-payments (when necessary),\n>> the client may have an authentication token that the server can verify when\n>> accepting the job (e.g. a blinded token).\n>>\n>> ## WatchTower services\n>>\n>> ### Basic Service\n>> The customer can hire the WatchTower to watch for breaches on the\n>> blockchain and relay a justice transaction on their behalf. The customer\n>> receives an acknowledgement when the WatchTower has accepted the job, but\n>> the hiring protocol does not guarantee the transaction inclusion.\n>>\n>> ### Quality of Service\n>> Quality of Service (`qos`) builds on top of the basic service provided by\n>> a tower and it's optionally provided. Different kinds of QoS can be offered\n>> by the tower.\n>>\n>> For now we are defining a single type of `qos`: `accountability`.\n>>\n>> #### `accountability`\n>>\n>> A WatchTower provides a signed receipt to the customer. This is\n>> considered reputational accountability as the customer has publicly\n>> verifiable cryptographic evidence the WatchTower was hired. The receipt can\n>> be used to prove the WatchTower did not relay the justice transaction on\n>> their behalf and/or request a refund.\n>>\n>> ## Sending and receiving appointments\n>>\n>> Once the client is aware of the services provided by the server, the\n>> former can start sending appointments to the latter.\n>>\n>> +-------+                                    +-------+\n>> |   A   |--(1)---      appointment      ---->|   B   |\n>> |       |<-(2)---   accepted/rejected   -----|       |\n>> +-------+                                    +-------+\n>>\n>> - where node A is 'client' and node B is 'server'\n>>\n>> ### The `appointment` message\n>>\n>> This message contains all the information regarding the appointment that\n>> the client wants to arrange with the server.\n>>\n>> 1. type: ? (`appointment`)\n>> 2. data:\n>>    * [`16*byte`:`locator`]\n>>    * [`u64 `:`start_block`]\n>>    * [`u64 `:`end_block`]\n>>    * [`u16`: `encrypted_blob_len`\n>>    * [`encrypted_blob_len*byte`:`encrypted_blob`]\n>>    * [`u16`:`cipher`]\n>>    * [`u16`: `auth_token_len`]\n>>    * [`auth_token_len*byte`: `auth_token`]\n>>    * [`u16`: `qos_len`]\n>>    * [`qos_len*byte`: `qos_data`]\n>>\n>> #### Requirements\n>>\n>> The client:\n>>\n>> * MUST set `locator` as specified in [Transaction Locator and Encryption\n>> Key](#transaction-locator-and-encryption-key).\n>> * MUST set `start_block` to the current chain tip height.\n>> * MUST set `end_block` to the block height at which he requests the\n>> server to stop watching for breaches.\n>> * MUST set `encrypted_blob` to the encryption of the\n>> `justice_transaction` as specified in [Transaction Locator and Encryption\n>> Key](#transaction-locator-and-encryption-key).\n>> * MUST set `cipher` to the cipher used to create the `encrypted_blob`.\n>> * MAY send an empty `auth_token` field.\n>> * MUST set `auth_token_len` to the length of `auth_token`.\n>> * MAY send an empty `qos_data` field.\n>> * if `qos_data` is not empty:\n>> *  MUST set `qos_data` according to [Quality of Service\n>> data](#quality-of-service-data).\n>> * MUST set `qos_len` equal to the length of `qos_data`.\n>>\n>> The server:\n>>\n>> * MUST reject the appointment if:\n>> * Authentication is required and `auth_token` is not provided.\n>> * Authentication is required and `auth_token` is invalid.\n>> * `locator` is not a `16-byte` value.\n>> * `start_block` is further than one block behind the current chain tip.\n>> * `start_block` is further than one block ahead the current chain tip.\n>> * `encrypted_blob` has unreasonable size.\n>> * `cipher` is not among the ones he implements.\n>>\n>> * SHOULD reject the appointment if`end_block` is too far away in the\n>> future.\n>>\n>> * MUST:\n>> * truncate the remainder of the package to `qos_len`.\n>> * process `qos_data` according to [Quality of Service\n>> data](#quality-of-service-data) if `qos_len` is not 0.\n>>\n>> * MAY accept the appointment otherwise.\n>>\n>> #### Rationale\n>>\n>> We define appointment as the way that the WatchTower is hired / requested\n>> by a client to do it's watching services.\n>>\n>> WatchTowers may offer their services for free (`altruistic`) or they may\n>> require a payment when accepting the job (`non-altruistic`). We have\n>> defined `auth_token` as an authentication mechanism between the client and\n>> server, so the client can prove they are entitled to the service. The\n>> tokens are not required to be linked to any kind of identity (e.g. blinded\n>> tokens), but their sole purpose is to confirm the client has already paid\n>> for the service.\n>>\n>> The transaction `locator` can be deterministically computed by both the\n>> client and the server. Locators of wrong size are therefore invalid.\n>>\n>> `start_block` can be either one block ahead or behind the tower tip due\n>> to network delays. A tower must not accept appointments arbitrarily ahead\n>> or behind the current tip since it could increase DoS vectors. A\n>> `start_block` long behind would force the tower to rescan block data for\n>> those appointments instead of watching block by block. On the other hand, a\n>> `start_time` long ahead would imply storing information way before it being\n>> needed.\n>>\n>> Regarding the `end_block`, too far away is a subjective concept. The\n>> further away a tower accepts appointment ends, the higher the potential\n>> storage requirements may be, and the easier, and cheaper, it my be to\n>> perform DoS.\n>>\n>> The `encrypted_blob` should have been encrypted using `cipher`. Block\n>> ciphers have a size multiple of the block length, which depends on the key\n>> size. Therefore the `encrypted_blob` have to be at least as big as:\n>>\n>> `cipher_block_size * ceil(minimum_viable_transaction_size /\n>> cipher_block_size)`\n>>\n>> and at most as big as:\n>>\n>> `cipher_block_size * ceil(maximum_viable_transaction_size /\n>> cipher_block_size`)\n>>\n>> `minimum_viable_transaction_size` and `maximum_viable_transaction_size`\n>> refer to the minimum/maximum size required to create a valid transaction.\n>> Accepting `encrypted_blob` outside those boundaries will increase DoS\n>> attacks on the server.\n>>\n>> The client should have learn about the `ciphers` implemented by the\n>> WatchTower and the `qos` that the tower is offering during the peer\n>> discovery.\n>>\n>> A tower must not accept appointments using a cipher it does not\n>> implement, otherwise the decryption of the `encrypted_blob` will not be\n>> possible.\n>>\n>> `qos` is optional and can include multiple services.\n>>\n>> ### The `appointment_accepted` message\n>>\n>> This message contains information about the acceptance of an appointment\n>> by the WatchTower.\n>>\n>> 1. type: ? (`appointment_accepted `)\n>> 2. data:\n>>    * [`16*byte `:`locator`]\n>>    * [`u16`: `qos_len`]\n>> * [`qos_len*byte`: `qos_data`]\n>>\n>> The server:\n>>\n>> * MUST receive `appointment` before sending an `appointment_accepted`\n>> message.\n>> * MUST set the `locator` to match the one received in `appointment`.\n>> * if `qos_data` was requested in `appointment`:\n>> *  MUST set `qos_data` according to [Quality of Service\n>> data](#quality-of-service-data).\n>> * MUST set `qos_len` equal to the length of `qos_data`.\n>>\n>> The client:\n>>\n>> * MUST fail the connection  if `locator` does not match any of locators\n>> the previously sent to the server:\n>>\n>> * if `qos` was requested in `appointment`:\n>> * MUST fail the connection if `qos_len` is 0.\n>> * MUST process `qos_data` according to [Quality of Service\n>> data](#quality-of-service-data).\n>>\n>> ### The `appointment_rejected` message\n>>\n>> This message contains information about the rejection of an appointment\n>> by the WatchTower.\n>>\n>> 1. type: ? (`appointment_rejected `)\n>> 2. data:\n>>    * [`16*byte `:`locator`]\n>>    * [`u16`: `rcode`]\n>>    * [`u16`: `reason_len`\n>>    * [`reason_len*byte`: `reason`]\n>>\n>> The server:\n>>\n>> * MUST receive `appointment` before sending an `appointment_rejected`\n>> message.\n>> * MUST set the `locator` to match the one received in `appointment`.\n>> * MUST set `rcode` to the rejection code.\n>> * MAY set and empty `reason` field.\n>> * MUST set `reason_len` to length of `reason`.\n>>\n>> #### Rationale\n>>\n>> The `appointment_rejected` message follows the approach taken by the\n>> `error` message defined in [BOLT#1](\n>> https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message):\n>> error codes are mandatory, whereas reasons are optional and implementation\n>> dependant.\n>>\n>> ## Quality of Service data\n>>\n>> `qos_data` is a list where each field specifies they type and associated\n>> data of the offered/requested `qos`. The format is defined as follows:\n>>\n>> * [`u16`: `qos_type`]\n>> * [`u16`: `data_len`]\n>> * [`data_len*byte`: `data`]\n>>\n>> So far, only `accountability` is defined.\n>>\n>> ### `accountability`\n>>\n>> The accountability `qos` defines a pair `qos_data` blobs, associated to a\n>> pair of messages: The first one is `customer_evidence` and it is provided\n>> by the `client` in the `appointment` message. The second one is\n>> `tower_evidence`, and is provided by the WatchTower in the\n>> `appointment_accepted` message.\n>>\n>> #### `customer_evidence`\n>>\n>> The format for the `customer_evidence` is defined as follows:\n>>\n>> 1. type: ? (`customer_evidence`)\n>> 2. data:\n>> * [`u64 `:`dispute_delta`]\n>> * [`u64`: `transaction_size`]\n>> * [`u64`: `transaction_fee`]\n>>\n>> If `accountability` is being requested, the client:\n>>\n>> * MUST set `dispute_delta` to the CLTV value specified in the\n>> `commitment_transaction`.\n>> * MUST set `transaction_size` to the size of the serialized\n>> `justice_transaction`, in bytes.\n>> * MUST set `transaction_fee` to the fee set in the `justice_transaction`,\n>> in satoshis.\n>> * MUST set the `customer_signature_algorithm` to one of the signature\n>> algorithms supported by the tower.\n>> * MUST set `customer_signature` to the signature of the appointment using\n>> `op_customer_signature_algorithm`.\n>> * MUST set `customer_public_key` to the public key that matches the\n>> private key used to create `op_customer_signature`.\n>>\n>> If `accountability` is being offered, the server:\n>>\n>> * MUST compute the `customer_signature` verification using\n>> `customer_public_key`.\n>> * SHOULD compute the `fee_rate` set in the `justice_tx` using\n>> `transaction_size` and `transaction_fee`.\n>>\n>> * MUST reject the appointment if:\n>> * Any of the fields is missing.\n>> * `transaction_size` is unreasonable.\n>> * `customer_signature_algorithm` does not match any of the supported\n>> signing algorithms.\n>> * `customer_signature` cannot be verified using `customer_public_key`.\n>>\n>> * SHOULD reject the appointment if:\n>> * `dispute_delta` is too small.\n>> * `fee_rate` is too low.\n>>\n>> If `accountability` is NOT being offered:\n>>\n>> * The server MUST reject the appointment.\n>>\n>> Otherwise:\n>>\n>> * The server SHOULD accept the appointment.\n>>\n>> #### Rationale\n>>\n>> The concept of too small for `dispute_delta` is subjective. The\n>> `dispute_delta` defines the time (in blocks) that the tower has in order to\n>> respond after a breach is seen. The smaller the value, the more the server\n>> risks to fail the appointment.\n>>\n>> `transaction_size` and `transaction_fee` help the WatchTower to decide on\n>> the likelihood of an appointment being fulfilled. Appointments with\n>> `fee_rate` too low may be rejected by the WatchTower. While a customer can\n>> always fake this values, it should break ToS between the client and the\n>> server and, therefore, release the WatchTower of any liability.\n>>\n>> By accepting the request, the tower is offering a reputationally\n>> accountable watching service. If `accountability` is not offered, then the\n>> tower will not accept appointments requesting for it.\n>>\n>> As well, the WatchTower must check the transaction details before\n>> deciding whether it will accept it. If the decrypted justice transaction\n>> does not satisfy the job details (e.g. too low fee), then the tower is not\n>> obliged to fulfil the appointment.\n>>\n>> #### `tower_evidence`\n>>\n>> The format for the `tower_evidence` is defined as follows:\n>>\n>> 1. type: ? (`tower_evidence`)\n>> 2. data:\n>> * [`u16 `:`receipt_len`]\n>> * [`receipt_len*byte `: `receipt`]\n>> * [`u16`: `wt_signature_algorithm`]\n>> * [`u16`: `wt_signature_len`\n>> * [`wt_signature_len*byte`: `wt_signature`]\n>> * [`u16`: `wt_public_key_len`]\n>> * [`wt_public_key_len*byte`: `wt_public_key`]\n>>\n>> The server:\n>>\n>> * MUST set `receipt` to a receipt built according to\n>> [Receipt-Format](#receipt-format).\n>> * MUST set `wt_signature_algorithm` to one of the signature algorithms he\n>> has announced.\n>> * MUST set `wt_signature` to the signature of the appointment using\n>> `wt_signature_algorithm`.\n>> * MUST set `wt_public_key` to the public key that matches the private key\n>> used to create `wt_signature`.\n>>\n>> The client:\n>>\n>> * MUST compute the `wt_signature` verification using `wt_public_key`.\n>>\n>> * MUST fail the connection if:\n>> * Any of the fields is missing.\n>> * `receipt` does not matches the format specified at\n>> [Receipt-Format](#receipt-format)\n>> * `receipt` fields do not match the ones sent in the `appointment`\n>> message.\n>> * `wt_signature_algorithm` does not match any of the ones offered by the\n>> server.\n>> * `wt_signature` cannot be verified using `wt_public_key`.\n>>\n>> #### Receipt Format\n>>\n>> The server MUST create the receipt containing the following information:\n>>\n>> txlocator\n>> start_block\n>> end_block\n>> dispute_delta\n>> encrypted_blob\n>> transaction_size\n>> transaction_fee\n>> cipher\n>> customer_signature\n>> wt_public_key\n>>\n>>\n>> #### Rationale\n>>\n>> We assume the client has a well-known public key for the WatchTower.\n>>\n>> The receipt contains, mainly, the information provided by the user. The\n>> WatchTower will need to sign the receipt to provide evidence of agreement.\n>>\n>> The `customer_signature` is included in the receipt to link both the\n>> client request and the server response. Otherwise, the tower could sign a\n>> receipt with different data that the one sent by the user, and the user\n>> would have no way to prove whether that's true or not. By signing the\n>> customer signature there the tower creates evidence of what the user sent,\n>> since the tower cannot forge the client's signature.\n>>\n>> #### Receipt serialization and signature\n>>\n>> [FIXME: TBD]\n>>\n>> ## Transaction Locator and Encryption Key\n>>\n>> Implementations MUST compute the `locator`, `encryption_key` and\n>> `encryption_iv` from the commitment transaction as defined below:\n>>\n>> - `locator`: first half of the commitment transaction id\n>> (`commitment_txid(0,16]`)\n>> - `master_key`: Hash of the second half of the commitment transaction id\n>> (`SHA256(commitment_txid(16,32])`)\n>> - `encryption_key`: first half of the master key (`master_key(0,16]`)\n>> - `encryption_iv`: second half of the master key (`master_key(16,32]`)\n>>\n>>\n>> The server relies on both the encryption key and iv to decrypt the\n>> justice transaction. Furthermore, the transaction locator helps the\n>> WatchTower identify a breach transaction on the blockchain.\n>>\n>> ## Encryption Algorithms and Parameters\n>>\n>> All clients and servers MUST use one of the following encryption\n>> algorithms:\n>>\n>> - ChaCha20 (https://tools.ietf.org/html/rfc7539)\n>> - AES-GCM-256 (https://tools.ietf.org/html/rfc5288)\n>>\n>> Sample code (python) for the client to prepare the `encrypted_blob`:\n>>\n>> from hashlib import sha256\n>> from binascii import hexlify\n>>\n>> def encrypt(justice_tx, commitment_txid):\n>>    # master_key = SHA256(commitment_txid(16, 32])\n>>    master_key = sha256(commitment_txid[16:]).digest()\n>>\n>>    # The 16 MSB of the master key will serve as the AES-GCM-256 secret\n>> key. The 16 LSB will serve as the IV.\n>>    sk = master_key[:16]\n>>    nonce = master_key[16:]\n>>\n>>    # Encrypt the data\n>>    aesgcm = AESGCM(sk)\n>>    encrypted_blob = aesgcm.encrypt(nonce=iv, data=tx,\n>> associated_data=None)\n>>    encrypted_blob = hexlify(encrypted_blob).decode()\n>>\n>>    return encrypted_blob\n>>\n>> ## Payment modes\n>>\n>> Although this BOLT does not enforce any specific payment method to be\n>> adopted, it is worth mentioning the three most common ones:\n>>\n>> **On-chain bounty**. An additional output is created in the justice\n>> transaction that will reward the WatchTower.\n>>\n>> **Micropayments**. A small payment is sent to the WatchTower for every\n>> new job (e.g. over the lightning network)\n>>\n>> **Subscription**. WatchTower is periodically rewarded / paid for their\n>> service to the customer. (e.g. over the lightning network or fiat\n>> subscription).\n>>\n>> Both micropayments and subscriptions are favourable for a WatchTower. The\n>> on-chain bounty approach is not ideal for a watching network, it lets the\n>> customer hire many WatchTowers (O(N) storage for each tower) and only one\n>> WatchTower will be rewarded upon collecting the bounty. On top of that, the\n>> onchain bounty allows a network-wise DoS attack for free.\n>>\n>> ## No compression of justice transaction\n>>\n>> The storage requirements for a WatchTower can be reduced (linearly) by\n>> implementing [shachain](\n>> https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt),\n>> therefore storing the parts required to build the transaction and the\n>> corresponding signing key instead of the full transaction. For now, we have\n>> decided to keep the hiring protocol simple. Storage is relatively cheap and\n>> we can revisit this standard if it becomes a problem.\n>>\n>> ## FIXMES\n>>\n>> - Define a proper tower discovery.\n>> - Define authentication mechanism (macaroons maybe?).\n>> - None of the message types have been defined (they have been left with\n>> ?).\n>> - Define receipt serialization format.\n>> - `qos_type` can be defined by ranges, in the same way that error\n>> messages are. In that way a range of values can belong to a specific `qos`.\n>> - Define an optional way of doing batch appointments / appointments in\n>> bulk? That would break appointment unlinkability but would ease the data\n>> management for the tower.\n>> - The `customer_signature` could be optional if the client does not care\n>> that much about the worst case. Dicuss whether that makes sense.\n>> - Discuss whether to extend it with shachain.\n>>\n>>\n>> The document can also be found here:\n>> https://github.com/PISAresearch/pisa/blob/master/13-watchtower-API.md\n>>\n>> --\n>> Sergi.\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n\n-- \nSergi.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191205/ca448e0e/attachment-0001.html>"
            },
            {
                "author": "Sergi Delgado Segura",
                "date": "2019-12-05T16:46:23",
                "message_text_only": "Hi Rusty, thanks for the feedback!\n\nOn Tue, Dec 3, 2019 at 1:26 AM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Hi Sergi!\n>\n>         Great to see progress on this!  Detailed comments below.\n>\n> Sergi Delgado Segura <sergi.delgado.s at gmail.com> writes:\n> > ## Sending and receiving appointments\n> >\n> > Once the client is aware of the services provided by the server, the\n> former\n> > can start sending appointments to the latter.\n> >\n> > +-------+                                    +-------+\n> > |   A   |--(1)---      appointment      ---->|   B   |\n> > |       |<-(2)---   accepted/rejected   -----|       |\n> > +-------+                                    +-------+\n> >\n> > - where node A is 'client' and node B is 'server'\n> >\n> > ### The `appointment` message\n> >\n> > This message contains all the information regarding the appointment that\n> > the client wants to arrange with the server.\n> >\n> > 1. type: ? (`appointment`)\n> > 2. data:\n> >    * [`16*byte`:`locator`]\n> >    * [`u64 `:`start_block`]\n> >    * [`u64 `:`end_block`]\n>\n> u32 is sufficient for start_block, fwiw.\n>\n\nOK\n\n\n>\n> >    * [`u16`: `encrypted_blob_len`\n> >    * [`encrypted_blob_len*byte`:`encrypted_blob`]\n> >    * [`u16`:`cipher`]\n> >    * [`u16`: `auth_token_len`]\n> >    * [`auth_token_len*byte`: `auth_token`]\n> >    * [`u16`: `qos_len`]\n> >    * [`qos_len*byte`: `qos_data`]\n> >\n> > #### Requirements\n> >\n> > The client:\n> >\n> > * MUST set `locator` as specified in [Transaction Locator and Encryption\n> > Key](#transaction-locator-and-encryption-key).\n> > * MUST set `start_block` to the current chain tip height.\n>\n> What is the purpose of this field?  Presumably the watcher knows the\n> current block number.\n>\n> I suggest you want this to be \"the first possible block in which the\n> transction can occur\"?\n>\n\nIndeed\n\n\n>\n> > * MUST set `end_block` to the block height at which he requests the\n> server\n> > to stop watching for breaches.\n>\n> I don't know how you would set that.  I think you need this to be\n> separate: either as part of the payment layer (I will watch for a year),\n> or an explicit \"stop watching\" message (assuming that you pay for\n> certain capacity).\n>\n\nI think it makes sense to do it in the payment layer. A \"stop watching\"\ncommand seems tricky though, how would you price it properly? It seems that\nthe user could be able to game it, specially if the \"bounty\" approach.\n\n\n>\n> > * MUST set `encrypted_blob` to the encryption of the\n> `justice_transaction`\n> > as specified in [Transaction Locator and Encryption\n> > Key](#transaction-locator-and-encryption-key).\n>\n> The phrase used in the spec is penalty transaction, BTW.  Especially\n> since its use is generally an injustice :)\n>\n\nSorry about that >.<\n\n\n>\n> > * MUST set `cipher` to the cipher used to create the `encrypted_blob`.\n>\n> Don't do this.  Pick a cipher already used elsewhere in the protocol.\n> chacha20 is a good choice.\n>\n\nOk, We were thinking on having a certain level of configuration to avoid\nbroken things in the future. It makes the protocol\nunnecessarily complicated though, so we'll change it to chacha20 only.\n\n\n>\n> > * MAY send an empty `auth_token` field.\n> > * MUST set `auth_token_len` to the length of `auth_token`.\n>\n> The latter is already written in the spec.  But these days, optional\n> fields are implemented as TLV data, so perhaps use that instead.\n\n\n> > * MAY send an empty `qos_data` field.\n> > * if `qos_data` is not empty:\n> > *  MUST set `qos_data` according to [Quality of Service\n> > data](#quality-of-service-data).\n> > * MUST set `qos_len` equal to the length of `qos_data`.\n>\n> I would drop the idea of \"qos\", and again use TLV data, defining\n> accountability.  Others can be added later.\n>\n\nOK, I'll give it a look.\n\n\n>\n> > The server:\n> >\n> > * MUST reject the appointment if:\n> > * Authentication is required and `auth_token` is not provided.\n> > * Authentication is required and `auth_token` is invalid.\n>\n> > * `locator` is not a `16-byte` value.\n>\n> This cannot happen, so eliminate it.\n>\n\nNoted\n\n\n>\n> > * `start_block` is further than one block behind the current chain tip.\n> > * `start_block` is further than one block ahead the current chain tip.\n>\n> I'm still not sure what start_block is for.  It just seems to make\n> things fragile if blocks arrive quickly.\n>\n\nThe rationale is to prevent users to ask the tower to look for passed\nevents.\n\n\n>\n> > * `encrypted_blob` has unreasonable size.\n> > * `cipher` is not among the ones he implements.\n> >\n> > * SHOULD reject the appointment if`end_block` is too far away in the\n> future.\n>\n> This is a problem, since in practice we'll have to define what that is.\n>\n\nAgreed. As mentioned before it seems reasonable to do it during hiring.\nOpen to other ideas too though.\n\n\n>\n> > * MUST:\n> > * truncate the remainder of the package to `qos_len`.\n> > * process `qos_data` according to [Quality of Service\n> > data](#quality-of-service-data) if `qos_len` is not 0.\n> >\n> > * MAY accept the appointment otherwise.\n>\n> I would suggest:\n>\n>         * If it accepts the appointment:\n>            * MUST send `accepted`\n>         * Otherwise:\n>            * MUST send `rejected`\n>\n\nOK\n\n\n>\n> > #### Rationale\n> >\n> > We define appointment as the way that the WatchTower is hired / requested\n> > by a client to do it's watching services.\n> >\n> > WatchTowers may offer their services for free (`altruistic`) or they may\n> > require a payment when accepting the job (`non-altruistic`). We have\n> > defined `auth_token` as an authentication mechanism between the client\n> and\n> > server, so the client can prove they are entitled to the service. The\n> > tokens are not required to be linked to any kind of identity (e.g.\n> blinded\n> > tokens), but their sole purpose is to confirm the client has already paid\n> > for the service.\n> >\n> > The transaction `locator` can be deterministically computed by both the\n> > client and the server. Locators of wrong size are therefore invalid.\n> >\n> > `start_block` can be either one block ahead or behind the tower tip due\n> to\n> > network delays. A tower must not accept appointments arbitrarily ahead or\n> > behind the current tip since it could increase DoS vectors. A\n> `start_block`\n> > long behind would force the tower to rescan block data for those\n> > appointments instead of watching block by block. On the other hand, a\n> > `start_time` long ahead would imply storing information way before it\n> being\n> > needed.\n>\n> I think the watchtower should respond with the start_time, instead, so\n> the caller knows how much work they have to do.  And perhaps the\n> end_time, but to be honest I'd add that later.\n>\n\nThis looks like a good solution for the start time. That way the user knows\nwhat the tower considers \"current time\". There could also be a default end\ntime that is picked if the tower and the user haven't agreed on something\nelse during the payment (or whatever we end up choosing).\n\n\n> `minimum_viable_transaction_size` and `maximum_viable_transaction_size`\n> > refer to the minimum/maximum size required to create a valid transaction.\n> > Accepting `encrypted_blob` outside those boundaries will increase DoS\n> > attacks on the server.\n>\n> These values need to be defined.  If the user is paying for storage, the\n> watchtower doesn't care.\n>\n\nAgreed, it depends on the mode of operation from the tower though. For\nexample, a bounty approach should care about this since some sizes may be\nimpossible for a transaction to be relayed. On the other hand, if the user\nis paying for a certain amount of storage beforehand the tower may not care.\n\n\n> ### The `appointment_accepted` message\n> >\n> > This message contains information about the acceptance of an appointment\n> by\n> > the WatchTower.\n> >\n> > 1. type: ? (`appointment_accepted `)\n> > 2. data:\n> >    * [`16*byte `:`locator`]\n> >    * [`u16`: `qos_len`]\n> > * [`qos_len*byte`: `qos_data`]\n> >\n> > The server:\n> >\n> > * MUST receive `appointment` before sending an `appointment_accepted`\n> > message.\n> > * MUST set the `locator` to match the one received in `appointment`.\n> > * if `qos_data` was requested in `appointment`:\n> > *  MUST set `qos_data` according to [Quality of Service\n> > data](#quality-of-service-data).\n> > * MUST set `qos_len` equal to the length of `qos_data`.\n> >\n> > The client:\n> >\n> > * MUST fail the connection  if `locator` does not match any of locators\n> the\n> > previously sent to the server:\n> >\n> > * if `qos` was requested in `appointment`:\n> > * MUST fail the connection if `qos_len` is 0.\n> > * MUST process `qos_data` according to [Quality of Service\n> > data](#quality-of-service-data).\n> >\n> > ### The `appointment_rejected` message\n> >\n> > This message contains information about the rejection of an appointment\n> by\n> > the WatchTower.\n> >\n> > 1. type: ? (`appointment_rejected `)\n> > 2. data:\n> >    * [`16*byte `:`locator`]\n> >    * [`u16`: `rcode`]\n> >    * [`u16`: `reason_len`\n> >    * [`reason_len*byte`: `reason`]\n> >\n> > The server:\n> >\n> > * MUST receive `appointment` before sending an `appointment_rejected`\n> > message.\n> > * MUST set the `locator` to match the one received in `appointment`.\n> > * MUST set `rcode` to the rejection code.\n> > * MAY set and empty `reason` field.\n> > * MUST set `reason_len` to length of `reason`.\n>\n> `rcode` needs to be defined.  In practice, that's a very difficult\n> task.  You may just want to define transient vs permanently errors?\n>\n\nCan you elaborate on this? I'm not used to error definition at this level\nso I could use some help.\n\n\n>\n> > #### Rationale\n> >\n> > The `appointment_rejected` message follows the approach taken by the\n> > `error` message defined in [BOLT#1](\n> >\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message\n> ):\n> > error codes are mandatory, whereas reasons are optional and\n> implementation\n> > dependant.\n> >\n> > ## Quality of Service data\n> >\n> > `qos_data` is a list where each field specifies they type and associated\n> > data of the offered/requested `qos`. The format is defined as follows:\n> >\n> > * [`u16`: `qos_type`]\n> > * [`u16`: `data_len`]\n> > * [`data_len*byte`: `data`]\n> >\n> > So far, only `accountability` is defined.\n> >\n> > ### `accountability`\n> >\n> > The accountability `qos` defines a pair `qos_data` blobs, associated to a\n> > pair of messages: The first one is `customer_evidence` and it is provided\n> > by the `client` in the `appointment` message. The second one is\n> > `tower_evidence`, and is provided by the WatchTower in the\n> > `appointment_accepted` message.\n> >\n> > #### `customer_evidence`\n> >\n> > The format for the `customer_evidence` is defined as follows:\n> >\n> > 1. type: ? (`customer_evidence`)\n> > 2. data:\n> > * [`u64 `:`dispute_delta`]\n> > * [`u64`: `transaction_size`]\n> > * [`u64`: `transaction_fee`]\n> >\n> > If `accountability` is being requested, the client:\n> >\n> > * MUST set `dispute_delta` to the CLTV value specified in the\n> > `commitment_transaction`.\n>\n> I don't understand this field.  I assume you're talking about the\n> `to_self_delay` the customer requested of its peer.  But I don't\n> understand why the tower would care: isn't it just going to broadcast\n> the tx as soon as it sees the violation?\n>\n\nYes it is, but depending on the approach followed it may be useful. For\ninstance, if the tower has a dedicated output to top up the fee it may be\nworth knowing beforehand what's the to_self_delay so the tower can have a\nbetter strategy (not overpaying fees). The tower will learn that once\ndecrypted, so it may not be necessary at this level.\n\n\n> * MUST set `transaction_size` to the size of the serialized\n> > `justice_transaction`, in bytes.\n> > * MUST set `transaction_fee` to the fee set in the `justice_transaction`,\n> > in satoshis.\n>\n> Just use chacha20, then the size of the transaction is well-defined.\n>\n> But I don't understand why the fee matters.  Neither the watchtower nor\n> the customer knows what fee will be needed in the future: all the\n> watchtower can do is broadcast what it's given.  Unless there's some\n> agreement on an output for the watchtower to CPFP (which, IMHO is best\n> left to a future extension), but the fee here still doesn't really\n> matter.\n>\n\nNoted, I'll think about how to fit it in an extension.\n\n\n> > * MUST set the `customer_signature_algorithm` to one of the signature\n> > algorithms supported by the tower.\n> > * MUST set `customer_signature` to the signature of the appointment using\n> > `op_customer_signature_algorithm`.\n> > * MUST set `customer_public_key` to the public key that matches the\n> private\n> > key used to create `op_customer_signature`.\n>\n> These aren't defined above (and again, don't define multiple signature\n> algorithms.\n>\n\nNoted. I'll simplify it to use chacha20 throughout the BOLT.\n\n\n> You should define here exactly what fields are signed, since this\n> message is inside the `appointment`.  But it's not clear what purpose\n> this signature serves?\n>\n\nThe signature is to provide an explicit agreement between the user and the\ntower (part of the accountability extension). The client side may not be\nnecessary (as Antoine was mentioning) since the user is already providing a\nsigned transaction, so that could do. I'll review that.\n\n\n> > If `accountability` is being offered, the server:\n> >\n> > * MUST compute the `customer_signature` verification using\n> > `customer_public_key`.\n> > * SHOULD compute the `fee_rate` set in the `justice_tx` using\n> > `transaction_size` and `transaction_fee`.\n> >\n> > * MUST reject the appointment if:\n> > * Any of the fields is missing.\n> > * `transaction_size` is unreasonable.\n> > * `customer_signature_algorithm` does not match any of the supported\n> > signing algorithms.\n> > * `customer_signature` cannot be verified using `customer_public_key`.\n> >\n> > * SHOULD reject the appointment if:\n> > * `dispute_delta` is too small.\n> > * `fee_rate` is too low.\n> >\n> > If `accountability` is NOT being offered:\n> >\n> > * The server MUST reject the appointment.\n> >\n> > Otherwise:\n> >\n> > * The server SHOULD accept the appointment.\n> >\n> > #### Rationale\n> >\n> > The concept of too small for `dispute_delta` is subjective. The\n> > `dispute_delta` defines the time (in blocks) that the tower has in order\n> to\n> > respond after a breach is seen. The smaller the value, the more the\n> server\n> > risks to fail the appointment.\n> >\n> > `transaction_size` and `transaction_fee` help the WatchTower to decide on\n> > the likelihood of an appointment being fulfilled. Appointments with\n> > `fee_rate` too low may be rejected by the WatchTower. While a customer\n> can\n> > always fake this values, it should break ToS between the client and the\n> > server and, therefore, release the WatchTower of any liability.\n> >\n> > By accepting the request, the tower is offering a reputationally\n> > accountable watching service. If `accountability` is not offered, then\n> the\n> > tower will not accept appointments requesting for it.\n> >\n> > As well, the WatchTower must check the transaction details before\n> deciding\n> > whether it will accept it. If the decrypted justice transaction does not\n> > satisfy the job details (e.g. too low fee), then the tower is not obliged\n> > to fulfil the appointment.\n> >\n> > #### `tower_evidence`\n> >\n> > The format for the `tower_evidence` is defined as follows:\n> >\n> > 1. type: ? (`tower_evidence`)\n> > 2. data:\n> > * [`u16 `:`receipt_len`]\n> > * [`receipt_len*byte `: `receipt`]\n> > * [`u16`: `wt_signature_algorithm`]\n> > * [`u16`: `wt_signature_len`\n> > * [`wt_signature_len*byte`: `wt_signature`]\n> > * [`u16`: `wt_public_key_len`]\n> > * [`wt_public_key_len*byte`: `wt_public_key`]\n> >\n> > The server:\n> >\n> > * MUST set `receipt` to a receipt built according to\n> > [Receipt-Format](#receipt-format).\n> > * MUST set `wt_signature_algorithm` to one of the signature algorithms he\n> > has announced.\n> > * MUST set `wt_signature` to the signature of the appointment using\n> > `wt_signature_algorithm`.\n> > * MUST set `wt_public_key` to the public key that matches the private key\n> > used to create `wt_signature`.\n>\n> What good is a proof if the watchtower can set a random public key?\n>\n> Presumably you want the watchtower to sign the txlocator, start_block\n> and encrypted blob with a known key.  Then you have a proof that it has\n> accepted it.\n>\n\nTrue, but the tower could have long-lasting and well known public keys. If\nthat's the case the key won't be required there.\n\n\n>\n> > The client:\n> >\n> > * MUST compute the `wt_signature` verification using `wt_public_key`.\n> >\n> > * MUST fail the connection if:\n> > * Any of the fields is missing.\n> > * `receipt` does not matches the format specified at\n> > [Receipt-Format](#receipt-format)\n> > * `receipt` fields do not match the ones sent in the `appointment`\n> message.\n> > * `wt_signature_algorithm` does not match any of the ones offered by the\n> > server.\n> > * `wt_signature` cannot be verified using `wt_public_key`.\n> >\n> > #### Receipt Format\n> >\n> > The server MUST create the receipt containing the following information:\n> >\n> > txlocator\n> > start_block\n> > end_block\n> > dispute_delta\n> > encrypted_blob\n> > transaction_size\n> > transaction_fee\n> > cipher\n> > customer_signature\n> > wt_public_key\n> >\n> >\n> > #### Rationale\n> >\n> > We assume the client has a well-known public key for the WatchTower.\n> >\n> > The receipt contains, mainly, the information provided by the user. The\n> > WatchTower will need to sign the receipt to provide evidence of\n> agreement.\n> >\n> > The `customer_signature` is included in the receipt to link both the\n> client\n> > request and the server response. Otherwise, the tower could sign a\n> receipt\n> > with different data that the one sent by the user, and the user would\n> have\n> > no way to prove whether that's true or not. By signing the customer\n> > signature there the tower creates evidence of what the user sent, since\n> the\n> > tower cannot forge the client's signature.\n> >\n> > #### Receipt serialization and signature\n> >\n> > [FIXME: TBD]\n> >\n> > ## Transaction Locator and Encryption Key\n> >\n> > Implementations MUST compute the `locator`, `encryption_key` and\n> > `encryption_iv` from the commitment transaction as defined below:\n> >\n> > - `locator`: first half of the commitment transaction id\n> > (`commitment_txid(0,16]`)\n> > - `master_key`: Hash of the second half of the commitment transaction id\n> > (`SHA256(commitment_txid(16,32])`)\n> > - `encryption_key`: first half of the master key (`master_key(0,16]`)\n> > - `encryption_iv`: second half of the master key (`master_key(16,32]`)\n> >\n> >\n> > The server relies on both the encryption key and iv to decrypt the\n> justice\n> > transaction. Furthermore, the transaction locator helps the WatchTower\n> > identify a breach transaction on the blockchain.\n>\n> The SHA256 step here is crypto cargo-culting AFAICT.  If the watchtower\n> can guess the txid, it does nothing.  If it can't, it does nothing.\n>\n> Setting both the IV and the key is similarly weird.  Use an IV of 0 and\n> simply use the second half of the commit txid as key.\n>\n\nI actually realised that the proposed sizes are wrong from this comment\n(they come from defining it with AES-GCM-128 originally). chacha20 needs\n32-byte keys, so we'll need to do something like:\n\nlocator = commitment_txid(0,16]\nkey = sha256(commitment_txid)\niv = 0 (12-byte)\n\nSince we're not using the second half of the txid we could define the\nlocator to be the txid, but having half reduces the storage requirements of\nthe tower. I think it's worth discussing this.\n\n\n> > ## Encryption Algorithms and Parameters\n> >\n> > All clients and servers MUST use one of the following encryption\n> > algorithms:\n> >\n> > - ChaCha20 (https://tools.ietf.org/html/rfc7539)\n> > - AES-GCM-256 (https://tools.ietf.org/html/rfc5288)\n>\n> This would be the first use of AES, and you need to implement chacha20\n> to speak to other peers.  Drop this.\n>\n\nDone.\n\n\n>\n> > Sample code (python) for the client to prepare the `encrypted_blob`:\n> >\n> > from hashlib import sha256\n> > from binascii import hexlify\n> >\n> > def encrypt(justice_tx, commitment_txid):\n> >    # master_key = SHA256(commitment_txid(16, 32])\n> >    master_key = sha256(commitment_txid[16:]).digest()\n> >\n> >    # The 16 MSB of the master key will serve as the AES-GCM-256 secret\n> key.\n> > The 16 LSB will serve as the IV.\n> >    sk = master_key[:16]\n> >    nonce = master_key[16:]\n> >\n> >    # Encrypt the data\n> >    aesgcm = AESGCM(sk)\n> >    encrypted_blob = aesgcm.encrypt(nonce=iv, data=tx,\n> associated_data=None)\n> >    encrypted_blob = hexlify(encrypted_blob).decode()\n> >\n> >    return encrypted_blob\n>\n> > ## Payment modes\n> >\n> > Although this BOLT does not enforce any specific payment method to be\n> > adopted, it is worth mentioning the three most common ones:\n> >\n> > **On-chain bounty**. An additional output is created in the justice\n> > transaction that will reward the WatchTower.\n>\n> This has the advantage of allowing (and incentivizing!) the WatchTower\n> to CPFP.  However, it has to be defined (how does client know what addr\n> to pay to?), so I'd leave it for later.\n>\n\nAgreed.\n\n\n>\n> > **Micropayments**. A small payment is sent to the WatchTower for every\n> new\n> > job (e.g. over the lightning network)\n> >\n> > **Subscription**. WatchTower is periodically rewarded / paid for their\n> > service to the customer. (e.g. over the lightning network or fiat\n> > subscription).\n> >\n> > Both micropayments and subscriptions are favourable for a WatchTower. The\n> > on-chain bounty approach is not ideal for a watching network, it lets the\n> > customer hire many WatchTowers (O(N) storage for each tower) and only one\n> > WatchTower will be rewarded upon collecting the bounty. On top of that,\n> the\n> > onchain bounty allows a network-wise DoS attack for free.\n>\n> > ## No compression of justice transaction\n> >\n> > The storage requirements for a WatchTower can be reduced (linearly) by\n> > implementing [shachain](\n> >\n> https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt\n> ),\n> > therefore storing the parts required to build the transaction and the\n> > corresponding signing key instead of the full transaction. For now, we\n> have\n> > decided to keep the hiring protocol simple. Storage is relatively cheap\n> and\n> > we can revisit this standard if it becomes a problem.\n>\n> Agreed.\n>\n> Cheers,\n> Rusty.\n>\n\n\n-- \nSergi.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191205/13928de1/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BOLT 13(?): WatchTower protocol",
            "categories": [
                "Lightning-dev",
                "DRAFT"
            ],
            "authors": [
                "Rusty Russell",
                "Sergi Delgado Segura"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 75025
        }
    },
    {
        "title": "[Lightning-dev] Time-Dilation Attacks on Offchain Protocols",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2019-12-09T18:04:07",
                "message_text_only": "Time-Dilation Attacks on Offchain Protocols\n===================================\n\nLightning works on reversing the double-spend problem to a private\nstate between parties instead of being a public issue verified by every\nnetwork peer. The security model is based on revocation of previous\nstates and in case of broadcast of any of them, being aware of it to\ngenerate justice transactions to claim misbehaving peer onchain outputs\nbefore contest period expiration. This period is driven by the blockchain\nwhich is here the system clock.\n\nEclipse attacks's end-goal is to monopolize a victim's incoming and\noutgoing connections, by this way isolating a node from the rest of its\npeers in the network. A successful Eclipse attacks lets the attacker\nfilter the victim's view of the blockchain, i.e he controls transactions\nand blocks announcements [0].\n\nEvery LN node must be tied to a bitcoin full-node or light-client to\nverify independently channels opening/closing, HTLCs expiration and\nprevious/latest state broadcast. To operate securely, the view of the\nblockchain must be up-to-date with the one shared with the rest of the\nnetwork. By considering Eclipse attacks on the base layer, this assumption\ncan be broken.\n\nFirst scenario : Targeting the CSV security delay\n--------------------------------------------------------------\n\nAlice and Mallory are LN peers with a channel opened at state N. They\nuse a CSV of 144 blocks as a security parameter for contestation period.\nMallory is able to identify Alice full-node and start to eclipse it.\nWhen done, it keeps announcing blocks to Alice node but delaying them by\n2min. Given a variance of 10min, after 6 blocks, Mallory will have a\nheight ahead of Alice of 1, after 24 blocks, a lead of 4, after 144,\na lead of 24, after 1008, a lead of 168.\n\nAfter maintaining the eclipse for a week, Mallory will have more than a\nday of height advance on Alice view of blockchain. The difference being\nsuperior at the CSV timelock, Mallory can broadcast a previous\ncommitment transaction at state N - 10 with a balance far more favorable\nthan the legit one at height H, the synchronized height with the rest\nof the network.\n\nAt revoked commitment transaction broadcast, Alice is slow down at\nheight H - 168. At H+144, Mallory can unlock its funds out of the\ncommitment transaction outputs and by so closing the contestation period\nwhile Alice is still stuck at H-24. When Alice learn about revoked\nbroadcast at H, it's already too late. Mallory may have stopped the\nEclipse attack after H+144, or he may pursue the attack on Alice because\nof targeting multiple of her channels in parallel.\n\nSecond scenario : Targeting the per-hop CLTV-delta\n-------------------------------------------------------------------\n\nAlice, Bob and Caroll are LN peers with channel Alice-Bob and Bob-Caroll.\nBob enforce a cltv_delta of 12 blocks on incoming HTLCs. Alice and Caroll\nare both malicious and start to eclipse Alice full-node until they gain a\nlead of 15 blocks on Alice.\n\nAt height N, Alice route a payment E to Caroll through Bob with a base\ndelta of 24 blocks. On channel AB, HTLC will expire at height H+24, on\nchannel BC, it will expire at height H+12 while Alice ticking herself\nat height H-15.\n\nWhen real-network blockchain height reaches H+24, Caroll provides\npreimage P to Bob and following protocol rules she gets a new\ncommitment transaction with balance increased of HTLC E. At same time,\nAlice broadcast unilaterally commitment transaction for AB and claim\nback HTLC E with a HTLC-timeout transaction as its nLockTime is already\nfinal. Bob wrongly clocking at height H+9, HTLC on channel BC won't have\nbeen timeout by him and provided preimage is now useless as HTLC as\nalready claimed back on mainnet blockchain.\n\nAttack difficulty\n-------------------\n\nFollowing Eclipse attack paper publication, multiple counter-measures\nhave been implemented [1], [2]. Even if it's far harder, this kind of\nattacks may still be possible for an off-path attacker. Including recent\nchanges, research should be done to ascertain it. Beyond, it still\nwidely feasible for attackers controlling key infrastructure between\nthe victim and the network [3]. A simple Tier 3 ISP doing deep packet\ninspection and delaying your blocks may be able to practice this class\nof attacks.\n\nThe case of LN nodes using light clients, like BIP157 or Electrum, as a\nbackend should be specially considered. Given the low number of servers\nproviding these services today it should be trivial for an attacker to run\nswarm of them and from then control blockchain view of this class of LN\nnodes.\n\nAnother difficulty of the attack, is to map the LN node to its full-node.\nThis can range from being trivial if both run in clear with same ipv4\naddress. It would be interesting to scan both networks and see how many\nnodes pair are in this case. Learning the mapping can still be doable if\nthey are using an anonymous network like Tor with same exit node base on\nmessage timing.\n\nFurther inter-layer mapping techniques could be developped like funding\ntransaction broadcast and seeing its propagation on the base layer. Or\nknowledge of onchain utxo graph leaked by addressed reused to fund\nchannels.\n\nOn the LN-side, depending of the scenario, cost of the attack ranges\nbetween opening one or two channels and paying the related onchain fees.\nThat being said, an attacker can also target victim-initiated channels\nand costs would be reduced only to operating LN nodes.\n\nOnchain counter-measures\n-----------------------------------\n\nWarnings could be triggered by full-node when the block issuance rate\nbecomes weird but first it's hard to dissociate weirdness from edges of\nblock variance and secondly the algo being public it should be easy for\nan attacker to stay under the radar by choosing the right announcement\ndelay.\n\nRaising alarms based on nTime of block headers being to far in the past\ncompare to local clock wouldn't make sense due to IBD.\n\nA practical solution would be to have multiple bitcoin full-nodes\nwith multi-homing and doing reconciliation of blockchain views every\nN hour/minute. This kind of method, already deployed by some bitcoin\ninfrastructures, would raise attack difficulty for off-path attackers\nbut wouldn't counter in-path attackers. Nevertheless, it would already\nbe a good step, the issue is the current absent of implementing this\nin open-source software for hobbyists.\n\nA defense in depth would require to have multiple data links, like\nreceiving headers from space/radio or tunneling through\nsome other protocols [4].\n\nEven learning discrepancies between your local view of the blockchain\nand the mainnet one, the right move to do isn't clear as an automatic\nsystem may be triggered by false positives to halt operation of your LN\nnode, a human intervention to double-check may seem preferable. And\nit's really likely the attacker control you ability of transactions\non the base layer. BIP324 may help there.\n\nOffchain counter-measures\n-----------------------------------\n\nSome LN errors messages may be triggered at abnormal rate like\n`expiry_too_soon`  due to victim using a HTLC base in the past and may\nbe used to guess oddities.\n\nA measure orthogonal to running multiple bitcoin full-nodes should be\nto have multiples watchtowers running their own blocks provider (full-node\nor light clients). Assuming attacker don't control your connection to them,\nif at least one of them isn't eclipsed, it should be able to time-out HTLC/\njustice revoked transaction efficiently.\n\nAnother option would be to use the control plane as a safety mechanism.\nWhen a LN node learns a channel_announcement to far in the future it\nwould ask to this LN node, few next headers through this communication\nchannel and connect these headers to its full-node. Based on this\ninformation, full-node may trigger alarms more accurately. This mechanism\nwould work assuming one of your gossiping LN node is honest. It may ask\nfor fine-tuning to avoid there too false-positives but it seems an\ninteresting topic of research to use L2 information to correct L1 blockchain\nview and even further to use L2 communications channels as an emergency\ntransaction broadcast.\n\n\nFurther research could be lead to investigate attacks combining eclipsing\nvictim\nview of both layer, that's said the LN one may seem harder to take on as\nnodes\nhave persistent identities.\n\nEclipse attacks were already known to be very bad, offchain protocols\nrelying on time for their security model make them worst at it lower the bar\nto exploit them from being a miner to being party to an offchain contract.\n\n\nAfter talking with LN implementations teams, they don't think funds are at\nrisks,\ngiven than light clients have low-value channels right now and it's not\nworthy the\nattack setup, but they acknowledge the issue on the long term for\nprocessing nodes.\n\n\nThanks to Gleb Naumenko for fruitful discussions/review.\n\nCheers\n\n[0] https://eprint.iacr.org/2015/263.pdf\n\n[1] https://github.com/bitcoin/bitcoin/pull/9037\n\n[2] https://github.com/bitcoin/bitcoin/pull/8282\n\n[3] https://erebus-attack.comp.nus.edu.sg/\n\n[4] https://github.com/bitcoin/bitcoin/pull/16834\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191209/cd6947dc/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-12-10T02:05:31",
                "message_text_only": "Nice writeup!\n\nIn further in-person discussions today, it was noted that the key\nlast-resort fallback Bitcoin Core has to week out peers in case of an\nEclipse Attack does not protect from this style of attack. While it is\nonly of limited concern for most Bitcoin Core users, it very much may\nexpose lightning nodes to theft.\n\nMore importantly, while Bitcoin Core has some protections against\ngeneric sybil-based Eclipse attacks, they are far from sufficient in a\nmodel like Lightning where much more is at stake from simple no-hashrate\nEclipse attacks.\n\nThe proposed countermeasure here of \"raising alarms\" in case the\nbest-block nTime field is too far behind is compelling in a\nSPV-assumption world, though it is far from sufficient if the time delay\nis small (eg for lightning HTLC delays or if the to_self_delay is\ngratuitously insecure, eg under 144).\n\nSadly, however, \"raising alarms\" is not sufficient to protect users, as\ncountermeasures likely need to be taken automatically for any kind of\ncompelling security.\n\nI'd encourage Lightning node authors and operators to ensure they have\nmultiple, redundant, trusted methods of receiving Bitcoin block data in\na timely fashion. To shill my own bags, of late I've been thinking about\nsuch systems and expose services to fetch header/BIP157 filter data over\nDNS [1, 2], header data over arbitrary radio interfaces [3] and full\nblock data over HTTP. Finally, there is also a parallel P2P\nimplementation which attempts to make different tradeoffs from the\nexisting Bitcoin Core P2P implementation and is much more aggressive\nabout seeking additional connections if there is evidence of headers\nwhich are better than our current chain at [5], relying on some of the\nother mechanisms to seek header data.\n\nNote that the Bitcoin Core-based work here also includes what I hope can\nbe used as an arbitrary easy-to-write-additional-block-fetch-methods\nframework.\n\n[1] https://github.com/bitcoin/bitcoin/pull/16834\n[2] https://twitter.com/TheBlueMatt/status/1200585905163112449\n[3]\nhttps://github.com/TheBlueMatt/bitcoin/commit/2019-10-rusty-all-da-stuff%5E1\nyou should be able to pick up headers in the 915 MHz band over LoRa with\nthis patch in the New York City area already :)\n[4] https://github.com/bitcoin/bitcoin/pull/16762\n[5] https://github.com/bitcoin/bitcoin/pull/17376\n\nMatt\n\nOn 12/9/19 6:04 PM, Antoine Riard wrote:\n> Time-Dilation Attacks on Offchain Protocols\n> ===================================\n> \n> Lightning works on reversing the double-spend problem to a private\n> state between parties instead of being a public issue verified by every\n> network peer. The security model is based on revocation of previous\n> states and in case of broadcast of any of them, being aware of it to\n> generate justice transactions to claim misbehaving peer onchain outputs\n> before contest period expiration. This period is driven by the blockchain\n> which is here the system clock.\n> \n> Eclipse attacks's end-goal is to monopolize a victim's incoming and\n> outgoing connections, by this way isolating a node from the rest of its\n> peers in the network. A successful Eclipse attacks lets the attacker\n> filter the victim's view of the blockchain, i.e he controls transactions\n> and blocks announcements [0].\n> \n> Every LN node must be tied to a bitcoin full-node or light-client to\n> verify independently channels opening/closing, HTLCs expiration and\n> previous/latest state broadcast. To operate securely, the view of the\n> blockchain must be up-to-date with the one shared with the rest of the\n> network. By considering Eclipse attacks on the base layer, this assumption\n> can be broken.\n> \n> First scenario : Targeting the CSV security delay\n> --------------------------------------------------------------\n> \n> Alice and Mallory are LN peers with a channel opened at state N. They\n> use a CSV of 144 blocks as a security parameter for contestation period.\n> Mallory is able to identify Alice full-node and start to eclipse it.\n> When done, it keeps announcing blocks to Alice node but delaying them by\n> 2min. Given a variance of 10min, after 6 blocks, Mallory will have a\n> height ahead of Alice of 1, after 24 blocks, a lead of 4, after 144,\n> a lead of 24, after 1008, a lead of 168.\n> \n> After maintaining the eclipse for a week, Mallory will have more than a\n> day of height advance on Alice view of blockchain. The difference being\n> superior at the CSV timelock, Mallory can broadcast a previous\n> commitment transaction at state N - 10 with a balance far more favorable\n> than the legit one at height H, the synchronized height with the rest\n> of the network.\n> \n> At revoked commitment transaction broadcast, Alice is slow down at\n> height H - 168. At H+144, Mallory can unlock its funds out of the\n> commitment transaction outputs and by so closing the contestation period\n> while Alice is still stuck at H-24. When Alice learn about revoked\n> broadcast at H, it's already too late. Mallory may have stopped the\n> Eclipse attack after H+144, or he may pursue the attack on Alice because\n> of targeting multiple of her channels in parallel.\n> \n> Second scenario : Targeting the per-hop CLTV-delta\n> -------------------------------------------------------------------\n> \n> Alice, Bob and Caroll are LN peers with channel Alice-Bob and Bob-Caroll.\n> Bob enforce a cltv_delta of 12 blocks on incoming HTLCs. Alice and Caroll\n> are both malicious and start to eclipse Alice full-node until they gain a\n> lead of 15 blocks on Alice.\n> \n> At height N, Alice route a payment E to Caroll through Bob with a base\n> delta of 24 blocks. On channel AB, HTLC will expire at height H+24, on\n> channel BC, it will expire at height H+12 while Alice ticking herself\n> at height H-15.\n> \n> When real-network blockchain height reaches H+24, Caroll provides\n> preimage P to Bob and following protocol rules she gets a new\n> commitment transaction with balance increased of HTLC E. At same time,\n> Alice broadcast unilaterally commitment transaction for AB and claim\n> back HTLC E with a HTLC-timeout transaction as its nLockTime is already\n> final. Bob wrongly clocking at height H+9, HTLC on channel BC won't have\n> been timeout by him and provided preimage is now useless as HTLC as\n> already claimed back on mainnet blockchain.\n> \n> Attack difficulty\n> -------------------\n> \n> Following Eclipse attack paper publication, multiple counter-measures\n> have been implemented [1], [2]. Even if it's far harder, this kind of\n> attacks may still be possible for an off-path attacker. Including recent\n> changes, research should be done to ascertain it. Beyond, it still\n> widely feasible for attackers controlling key infrastructure between\n> the victim and the network [3]. A simple Tier 3 ISP doing deep packet\n> inspection and delaying your blocks may be able to practice this class\n> of attacks.\n> \n> The case of LN nodes using light clients, like BIP157 or Electrum, as a\n> backend should be specially considered. Given the low number of servers\n> providing these services today it should be trivial for an attacker to run\n> swarm of them and from then control blockchain view of this class of LN\n> nodes.\n> \n> Another difficulty of the attack, is to map the LN node to its full-node.\n> This can range from being trivial if both run in clear with same ipv4\n> address. It would be interesting to scan both networks and see how many\n> nodes pair are in this case. Learning the mapping can still be doable if\n> they are using an anonymous network like Tor with same exit node base on\n> message timing.\n> \n> Further inter-layer mapping techniques could be developped like funding\n> transaction broadcast and seeing its propagation on the base layer. Or\n> knowledge of onchain utxo graph leaked by addressed reused to fund\n> channels.\n> \n> On the LN-side, depending of the scenario, cost of the attack ranges\n> between opening one or two channels and paying the related onchain fees.\n> That being said, an attacker can also target victim-initiated channels\n> and costs would be reduced only to operating LN nodes.\n> \n> Onchain counter-measures\n> -----------------------------------\n> \n> Warnings could be triggered by full-node when the block issuance rate\n> becomes weird but first it's hard to dissociate weirdness from edges of\n> block variance and secondly the algo being public it should be easy for\n> an attacker to stay under the radar by choosing the right announcement\n> delay.\n> \n> Raising alarms based on nTime of block headers being to far in the past\n> compare to local clock wouldn't make sense due to IBD.\n> \n> A practical solution would be to have multiple bitcoin full-nodes\n> with multi-homing and doing reconciliation of blockchain views every\n> N hour/minute. This kind of method, already deployed by some bitcoin\n> infrastructures, would raise attack difficulty for off-path attackers\n> but wouldn't counter in-path attackers. Nevertheless, it would already\n> be a good step, the issue is the current absent of implementing this\n> in open-source software for hobbyists.\n> \n> A defense in depth would require to have multiple data links, like\n> receiving headers from space/radio or tunneling through\n> some other protocols [4].\n> \n> Even learning discrepancies between your local view of the blockchain\n> and the mainnet one, the right move to do isn't clear as an automatic\n> system may be triggered by false positives to halt operation of your LN\n> node, a human intervention to double-check may seem preferable. And\n> it's really likely the attacker control you ability of transactions\n> on the base layer. BIP324 may help there.\n> \n> Offchain counter-measures\n> -----------------------------------\n> \n> Some LN errors messages may be triggered at abnormal rate like\n> `expiry_too_soon` \u00a0due to victim using a HTLC base in the past and may\n> be used to guess oddities.\n> \n> A measure orthogonal to running multiple bitcoin full-nodes should be\n> to have multiples watchtowers running their own blocks provider (full-node\n> or light clients). Assuming attacker don't control your connection to them,\n> if at least one of them isn't eclipsed, it should be able to time-out HTLC/\n> justice revoked transaction efficiently.\n> \n> Another option would be to use the control plane as a safety mechanism.\n> When a LN node learns a channel_announcement to far in the future it\n> would ask to this LN node, few next headers through this communication\n> channel and connect these headers to its full-node. Based on this\n> information, full-node may trigger alarms more accurately. This mechanism\n> would work assuming one of your gossiping LN node is honest. It may ask\n> for fine-tuning to avoid there too false-positives but it seems an\n> interesting topic of research to use L2 information to correct L1 blockchain\n> view and even further to use L2 communications channels as an emergency\n> transaction broadcast.\n> \n> \n> Further research could be lead to investigate attacks combining\n> eclipsing victim\n> view of both layer, that's said the LN one may seem harder to take on as\n> nodes\n> have persistent identities.\n> \n> Eclipse attacks were already known to be very bad, offchain protocols\n> relying on time for their security model make them worst at it lower the bar\n> to exploit them from being a miner to being party to an offchain contract.\n> \n> \n> After talking with LN implementations teams, they don't think funds are\n> at risks,\n> given than light clients have low-value channels right now and it's not\n> worthy the\n> attack setup, but they acknowledge the issue on the long term for\n> processing nodes.\n> \n> \n> Thanks to Gleb Naumenko for fruitful discussions/review.\n> \n> Cheers\n> \n> [0] https://eprint.iacr.org/2015/263.pdf\n> \n> [1] https://github.com/bitcoin/bitcoin/pull/9037\n> \n> [2] https://github.com/bitcoin/bitcoin/pull/8282\n> \n> [3] https://erebus-attack.comp.nus.edu.sg/\n> \n> [4] https://github.com/bitcoin/bitcoin/pull/16834\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-10T10:35:58",
                "message_text_only": "Good morning all,\n\n> Nice writeup!\n\nI agree.\n\n\n> I'd encourage Lightning node authors and operators to ensure they have\n> multiple, redundant, trusted methods of receiving Bitcoin block data in\n> a timely fashion.\n\nI believe there was some discussion before, possibly in Adelaide 2018, where we consider to also deliver header data over the LN wire protocol.\nThis is useful if and only if the Bitcoin fullnode we use is differently eclisable from the Lightning node we use, e.g. the Bitcoin fullnode is openly on an IPv4 address while the Lightning node is on a Tor hidden service.\n\n> > Some LN errors messages may be triggered at abnormal rate like\n> > `expiry_too_soon` \u00a0due to victim using a HTLC base in the past and may\n> > be used to guess oddities.\n\nA node might engage in background probing of payments that definitely will fail, and thereby get such information that way.\n\nLet us consider the case where Alice is a victim of such an eclipse attack, and is only connected to nodes (Bitcoin and Lightning) controlled by Mallory.\nAlice makes a outgoing probe, and as all its peers are controlled by Mallory, its first hop goes through Mallory and then goes to Bob and Charlie (who will fail the payment).\nBob may notice that the CLTV is too near the future and thus fail with `expiry_too_soon`.\n\nHowever, against this, Mallory can simply directly fail payments.\nIt would have to fail all payments that were not forwarded via Alice (i.e. if there is no Mallory1->Alice forward with similar value and timing as the Alice->Mallory2 forward, Mallory2 will fail the payment) immediately.\nThis allows Mallory to sidestep such protections.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2019-12-14T18:54:19",
                "message_text_only": "On Mon, Dec 09, 2019 at 01:04:07PM -0500, Antoine Riard wrote:\n> Time-Dilation Attacks on Offchain Protocols\n> ===================================\n\nWhat is the advantage of these sophisticated attacks over the eclipse\nattacker simply not relaying the honest user's commitment or penality\ntransactions to miners?\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191214/6842ef3a/attachment.sig>"
            },
            {
                "author": "Orfeas Stefanos Thyfronitis Litos",
                "date": "2019-12-15T00:06:27",
                "message_text_only": "I guess the sophisticated attacks try to trick the victim into believing that no attack is underway, but I may be wrong.\n\nOrfeas\n\nOn 14 December 2019 19:54:19 CET, \"David A. Harding\" <dave at dtrt.org> wrote:\n>On Mon, Dec 09, 2019 at 01:04:07PM -0500, Antoine Riard wrote:\n>> Time-Dilation Attacks on Offchain Protocols\n>> ===================================\n>\n>What is the advantage of these sophisticated attacks over the eclipse\n>attacker simply not relaying the honest user's commitment or penality\n>transactions to miners?\n>\n>-Dave\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191215/88771e6b/attachment.html>\n-------------- next part --------------\nAn embedded and charset-unspecified text was scrubbed...\nName: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191215/88771e6b/attachment.ksh>"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-12-16T07:17:31",
                "message_text_only": "> The proposed countermeasure here of \"raising alarms\" in case the\n> best-block nTime field is too far behind is compelling in a\n> SPV-assumption world, though it is far from sufficient if the time delay\n> is small\n\nNo that simple without interfering with IBD. While IBDing, alarms should be\noff to avoid raising false positives so attacker\nwho succeeds to eclipse you before you synced to top won't raise it. And\nyour validation software needs to remember than\nyou're out of IBD to avoid being pinned back in the past, fallback to IBD\nand disable alarms.\n\n> This is useful if and only if the Bitcoin fullnode we use is differently\neclisable from the Lightning node we use, e.g. the Bitcoin fullnode is\nopenly on an IPv4 address while the Lightning node is on a Tor hidden\nservice.\n\nI don't consider than your Lightning node is eclipsed. It needs further\nresearch but IMO it's harder to eclipse without\ndetection on LN due to node pubkeys. And given than connectivity is cheaper\nthan base layer (no per-peer inventories to maintain)\nif we have such header protocol, you should open connections to well-known\nLN pubkeys. Even if you assume an infrastructure attacker,\ngiven encrypted transport, it's hard to drop 80-bytes headers without\ntampering others messages and so being easily detected.\n\nNow how are you sure than LN pubkeys you get are the ones you intended to\nconnect to ? That's an authenticity problem and not\nsure than copy-pasting from LN search engines is the best practice..\n\n> I guess the sophisticated attacks try to trick the victim into believing\nthat no attack is underway, but I may be wrong.\n\nYes, a basic eclipse attack where you halt blocks update would be easily\ndetectable. Eclipsing by discarding\ncommitment/penalty txn still let CLTV/CSV time for the victim to react and\nyou can't be sure than victim\ndoesn't have a fallback way to broadcast tx. If well executed, attacks\ndescribed stay stealth\nuntil it's too late to react. I think for analysis we should split\ndetection from reaction, even if in practice we\nuse same communication channel for both.\n\n\n\nLe sam. 14 d\u00e9c. 2019 \u00e0 19:07, Orfeas Stefanos Thyfronitis Litos <\no.thyfronitis at ed.ac.uk> a \u00e9crit :\n\n> I guess the sophisticated attacks try to trick the victim into believing\n> that no attack is underway, but I may be wrong.\n>\n> Orfeas\n>\n> On 14 December 2019 19:54:19 CET, \"David A. Harding\" <dave at dtrt.org>\n> wrote:\n>>\n>> On Mon, Dec 09, 2019 at 01:04:07PM -0500, Antoine Riard wrote:\n>>\n>>> Time-Dilation Attacks on Offchain Protocols\n>>> ------------------------------\n>>>\n>>\n>> What is the advantage of these sophisticated attacks over the eclipse\n>> attacker simply not relaying the honest user's commitment or penality\n>> transactions to miners?\n>>\n>> -Dave\n>>\n>> The University of Edinburgh is a charitable body, registered in\n> Scotland, with registration number SC005336.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191216/fba721c5/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-12-16T09:10:18",
                "message_text_only": "On Mon, Dec 16, 2019 at 02:17:31AM -0500, Antoine Riard wrote:\n> If well executed, attacks described stay stealth until it's too late\n> to react.  \n\nI suspect the attacks you described are pretty easy to detect (assuming\nblock relay is significantly delayed) by simply comparing the time of\nthe latest block header to real time.  If the difference is too large,\nthen an emergency action should be taken.[1]\n\nYou mention IBD as confounding this strategy, but I don't think that's\nthe case.  Compare the normal case to the pathological case:\n\n- Normal: when Alice is requesting blocks from honest nodes because\n  she's far behind, those nodes are telling her their current block\n  height and are promptly serving any blocks she requests.\n\n- Pathological: when Alice is requesting blocks from a eclipse attacker,\n  those dishonest nodes are telling her she's already at the chain tip\n  even though the latest block they serve her has a header timestamp\n  that's hours or days old.  (Alternatively, they're reporting the\n  latest block height but refusing to serve her blocks/headers past a\n  certain point in the past.)\n\nIt seems pretty easy to me to detect the difference between the normal\ncase (Alice's chaintip is old but she's still successfully downloading\nblocks) and the pathological case (Alice's chaintip is old and she's\nunable to obtain more recent blocks).\n\nA possibly optimal attack strategy would be to combine\ncommitment/penalty transaction censorship with plausible block delays.\nTo a point, transaction censorship just looks a failure to pay a\nsufficient feerate---so a node will probably fee bump a\ncommitment/penalty transaction a few times before it starts to panic.\nAlso to a point, a delay of up to several hours[2] just looks like\nregular stochastic block production.  By using both deceits in the same\nattack to the maximum possible degree without triggering an alarm, an\nattacker can maximum their chance of stealing funds.\n\n-Dave\n\n[1] There is an interesting case where a large miner or cartel of miners\n    could deliberately trigger a false positive of block delay\n    protection by manipulating Median Time Past (MTP) to allow them to\n    set their header nTime fields to values from hours or days ago.  I\n    don't believe the fix for the time warp proposed in the consensus\n    cleanup soft fork fixes this, since it only directly affects the\n    first block in a new difficulty period (preventing difficulty gaming\n    but not header time gaming).  This problem is partly mitigated by\n    miners keeping MTP far in the past being unable to claim fees from\n    recent time locked transactions (see BIP113), though I'm not sure\n    how many transactions are actually using nLockTime-as-a-time (LN and\n    anti-fee sniping use it as a height).\n\n[2] If we suddenly lose half of Bitcoin's hashrate so that the average\n    time between blocks is 20 minutes, there's a once-in-a-century\n    chance of a block taking more than 310 minutes to produce:\n\n        1 / (exp(-310/20) * 144 * 365)\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191216/a987f10e/attachment.sig>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-12-16T15:29:28",
                "message_text_only": "Right, I kinda agree here in the sense that there are things that very\nsignificantly help mitigate the issue, but a) I'm not aware of any\nclients implementing it (and the equivalent mitigations in Bitcoin Core\nare targeted at a different class of issue, and are not sufficient\nhere), and b) its somewhat unclear what the \"emergency action\" would be.\nEven if you implement detection, figuring out how to do a fallback is\nnontrivial, especially if you are concerned with user privacy.\n\nMatt\n\nOn 12/16/19 9:10 AM, David A. Harding wrote:\n> On Mon, Dec 16, 2019 at 02:17:31AM -0500, Antoine Riard wrote:\n>> If well executed, attacks described stay stealth until it's too late\n>> to react.  \n> \n> I suspect the attacks you described are pretty easy to detect (assuming\n> block relay is significantly delayed) by simply comparing the time of\n> the latest block header to real time.  If the difference is too large,\n> then an emergency action should be taken.[1]\n> \n> You mention IBD as confounding this strategy, but I don't think that's\n> the case.  Compare the normal case to the pathological case:\n> \n> - Normal: when Alice is requesting blocks from honest nodes because\n>   she's far behind, those nodes are telling her their current block\n>   height and are promptly serving any blocks she requests.\n> \n> - Pathological: when Alice is requesting blocks from a eclipse attacker,\n>   those dishonest nodes are telling her she's already at the chain tip\n>   even though the latest block they serve her has a header timestamp\n>   that's hours or days old.  (Alternatively, they're reporting the\n>   latest block height but refusing to serve her blocks/headers past a\n>   certain point in the past.)\n> \n> It seems pretty easy to me to detect the difference between the normal\n> case (Alice's chaintip is old but she's still successfully downloading\n> blocks) and the pathological case (Alice's chaintip is old and she's\n> unable to obtain more recent blocks).\n> \n> A possibly optimal attack strategy would be to combine\n> commitment/penalty transaction censorship with plausible block delays.\n> To a point, transaction censorship just looks a failure to pay a\n> sufficient feerate---so a node will probably fee bump a\n> commitment/penalty transaction a few times before it starts to panic.\n> Also to a point, a delay of up to several hours[2] just looks like\n> regular stochastic block production.  By using both deceits in the same\n> attack to the maximum possible degree without triggering an alarm, an\n> attacker can maximum their chance of stealing funds.\n> \n> -Dave\n> \n> [1] There is an interesting case where a large miner or cartel of miners\n>     could deliberately trigger a false positive of block delay\n>     protection by manipulating Median Time Past (MTP) to allow them to\n>     set their header nTime fields to values from hours or days ago.  I\n>     don't believe the fix for the time warp proposed in the consensus\n>     cleanup soft fork fixes this, since it only directly affects the\n>     first block in a new difficulty period (preventing difficulty gaming\n>     but not header time gaming).  This problem is partly mitigated by\n>     miners keeping MTP far in the past being unable to claim fees from\n>     recent time locked transactions (see BIP113), though I'm not sure\n>     how many transactions are actually using nLockTime-as-a-time (LN and\n>     anti-fee sniping use it as a height).\n> \n> [2] If we suddenly lose half of Bitcoin's hashrate so that the average\n>     time between blocks is 20 minutes, there's a once-in-a-century\n>     chance of a block taking more than 310 minutes to produce:\n> \n>         1 / (exp(-310/20) * 144 * 365)\n> \n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-12-16T20:12:12",
                "message_text_only": "> It seems pretty easy to me to detect the difference between the normal\n> case (Alice's chaintip is old but she's still successfully downloading>\n> blocks) and the pathological case (Alice's chaintip is old and she's\n> unable to obtain more recent blocks).\n\nI think if alarm is implemented at the validation level it's not going to\nbe reliable due to IBD. While connecting and validating headers, it's okay\nto\nprocess headers timestamp that's hours or days old. Current\nIsInitialBlockDownload\nlogic returns false if tip is less than a day old. By slowing blocks\nannouncement I\ncould pin you indefinitely in IBD and alarms are not going to be triggered.\nThe issue\nbeing than the comparison point can be manipulated by the attacker.\n\nNow, if alarm is implemented at the net_processing level, I think that's\nsomething like\nCheckForStaleTipAndEvictPeers is doable but tricky. If you're past\nheaders-sync from one\npeer and best block header announced by a peer is too way in the past,\ndisconnect it. Still,\nyou can't be sure because maybe this node was buggy or its connection was\nfaulty, so you need to\nrepeat this few times and if all these peers announce block in the past\nthere something is wrong\nand raise an alarm. But it seems hard to have detection without doing\nactive peer rotation and this\nmay have bad side effects on connectivity..\n\nYou want a reliable detection mechanism because if it's cheaply triggered\nyou now have DoS attack\nvectors on the LN layer, like delaying blocks knowing it's going to trigger\nalarm and than a LN processing\nnode will close its channels.  You want scoping the issue beyond \"something\nis wrong\" (and like you mention\nthere is also the edge case of a legit several hours delay) that's why\nfetching headers thanks to some\nredundant communication channel seems to me better.\n\n> To a point, transaction censorship just looks a failure to pay a\n> sufficient feerate---so a node will probably fee bump a\n> commitment/penalty transaction a few times before it starts to panic.\n\nI don't do the assumption of hashrate-attackers but yes that's interesting\nthan you may combine\nwith some mempool tricks to optimize the attack.\n\nAntoine\n\nLe lun. 16 d\u00e9c. 2019 \u00e0 10:29, Matt Corallo <lf-lists at mattcorallo.com> a\n\u00e9crit :\n\n> Right, I kinda agree here in the sense that there are things that very\n> significantly help mitigate the issue, but a) I'm not aware of any\n> clients implementing it (and the equivalent mitigations in Bitcoin Core\n> are targeted at a different class of issue, and are not sufficient\n> here), and b) its somewhat unclear what the \"emergency action\" would be.\n> Even if you implement detection, figuring out how to do a fallback is\n> nontrivial, especially if you are concerned with user privacy.\n>\n> Matt\n>\n> On 12/16/19 9:10 AM, David A. Harding wrote:\n> > On Mon, Dec 16, 2019 at 02:17:31AM -0500, Antoine Riard wrote:\n> >> If well executed, attacks described stay stealth until it's too late\n> >> to react.\n> >\n> > I suspect the attacks you described are pretty easy to detect (assuming\n> > block relay is significantly delayed) by simply comparing the time of\n> > the latest block header to real time.  If the difference is too large,\n> > then an emergency action should be taken.[1]\n> >\n> > You mention IBD as confounding this strategy, but I don't think that's\n> > the case.  Compare the normal case to the pathological case:\n> >\n> > - Normal: when Alice is requesting blocks from honest nodes because\n> >   she's far behind, those nodes are telling her their current block\n> >   height and are promptly serving any blocks she requests.\n> >\n> > - Pathological: when Alice is requesting blocks from a eclipse attacker,\n> >   those dishonest nodes are telling her she's already at the chain tip\n> >   even though the latest block they serve her has a header timestamp\n> >   that's hours or days old.  (Alternatively, they're reporting the\n> >   latest block height but refusing to serve her blocks/headers past a\n> >   certain point in the past.)\n> >\n> > It seems pretty easy to me to detect the difference between the normal\n> > case (Alice's chaintip is old but she's still successfully downloading\n> > blocks) and the pathological case (Alice's chaintip is old and she's\n> > unable to obtain more recent blocks).\n> >\n> > A possibly optimal attack strategy would be to combine\n> > commitment/penalty transaction censorship with plausible block delays.\n> > To a point, transaction censorship just looks a failure to pay a\n> > sufficient feerate---so a node will probably fee bump a\n> > commitment/penalty transaction a few times before it starts to panic.\n> > Also to a point, a delay of up to several hours[2] just looks like\n> > regular stochastic block production.  By using both deceits in the same\n> > attack to the maximum possible degree without triggering an alarm, an\n> > attacker can maximum their chance of stealing funds.\n> >\n> > -Dave\n> >\n> > [1] There is an interesting case where a large miner or cartel of miners\n> >     could deliberately trigger a false positive of block delay\n> >     protection by manipulating Median Time Past (MTP) to allow them to\n> >     set their header nTime fields to values from hours or days ago.  I\n> >     don't believe the fix for the time warp proposed in the consensus\n> >     cleanup soft fork fixes this, since it only directly affects the\n> >     first block in a new difficulty period (preventing difficulty gaming\n> >     but not header time gaming).  This problem is partly mitigated by\n> >     miners keeping MTP far in the past being unable to claim fees from\n> >     recent time locked transactions (see BIP113), though I'm not sure\n> >     how many transactions are actually using nLockTime-as-a-time (LN and\n> >     anti-fee sniping use it as a height).\n> >\n> > [2] If we suddenly lose half of Bitcoin's hashrate so that the average\n> >     time between blocks is 20 minutes, there's a once-in-a-century\n> >     chance of a block taking more than 310 minutes to produce:\n> >\n> >         1 / (exp(-310/20) * 144 * 365)\n> >\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191216/db2fc00a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Time-Dilation Attacks on Offchain Protocols",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Matt Corallo",
                "Orfeas Stefanos Thyfronitis Litos",
                "Antoine Riard",
                "David A. Harding"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 41255
        }
    },
    {
        "title": "[Lightning-dev] Lightning in a Taproot future",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-15T15:43:07",
                "message_text_only": "Good morning list,\n\nI would like to initiate some discussion on how Lightning could be updated to take advantage of the upcoming taproot update to the base layer.\n\nFor now, I am assuming the continued use of the existing Poon-Dryja update mechanism.\nDecker-Russell-Osuntokun requires `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`, and its details seem less settled for now than taproot details.\n\n* [ ] We could update the current Poon-Dryja mechanism to use Schnorr signatures.\n* [ ] Or we could just keep the current Poon-Dryja mechanism with SegWit v0 only, and only update to Schnorr / SegWit v1 when we can implement Decker-Russell-Osuntokun.\n  * This brings up the question as to whether we will allow Poon-Dryja to host pointlocked-timelocked contracts (i.e. the Scriptless Script replacement of HTLCs that uses payment points+scalars).\n    * [ ] We could constrain Poon-Dryja channels to only HTLCs.\n      * This might be simpler for implementations: implementations could have a completely new module that implements Decker-Russell-Osuntokun with HTLCs and PTLCs, and not touch existing modules for Poon-Dryja with HTLCs only.\n      * We could \"retire\" Poon-Dryja constructions at some point and only add new features to Decker-Russell-Osuntokun channels.\n    * [ ] We could allow hosting PTLCs as well on Poon-Dryja channels, as nothing in the base layer prevents a transaction from providing both SegWit v0 and SegWit v1 outputs anyway.\n\nPoon-Dryja with Schnorr\n-----------------------\n\nIf we decide to update the current Poon-Dryja mechanism to use Schnorr, there are some wrinkles:\n\n* [ ] We could just drop-in replace the signing algorithm with Schnorr.\n  * We would define a NUMS point to be used as Taproot internal key, and use a single tapscript that is simply the current script template.\n  * This is arguably not really taking advantage of the Schnorr and Taproot features, however.\n* [ ] Or we could use some sort of MuSig between the two channel participants.\n\nThe latter option is probably what we want to use, as it potentially allows a channel close to be indistinguishable from an ordinary SegWit v1 spend of a UTXO.\nEven for channels that have been published via gossip, it moves the onus of storing historical data about historically-published channels from base layer fullnodes to nodes that want to surveill the network.\n\n### Digression: 2-of-2 is Obviously Lightning\n\nExisting 2-of-2 outputs have a very high probability of being Lightning Network channels.\nThus, someone who wishes to surveill the Lightning Network can simply query any archive fullnode for historical 2-of-2 outputs and have a good chance that those are Lightning Network channels.\n\nConsider the adage: Never go to sea with two chronometers; take one or three.\nhttps://en.wikipedia.org/wiki/Dual_modular_redundancy\nThis implies that ordinary HODL usage of transaction outputs will either use 1-of-1, or 2-of-3.\n\nOffchain techniques, on the other hand, are only safe (trustless) if they are n-of-n, and are only usefully multi-participant if n > 1.\nhttps://zmnscpxj.github.io/offchain/safety.html\nThus any n-of-n is likely to be an offchain protocol, with the most likely being the most widespread offchain protocol, Lightning Network.\n\nThus, the hyperbole \"2-of-2 is Obviously Lightning\".\n\nHowever, we can \"hide\" 2-of-2 in a 2-of-3, which can be done by generating a third point from a NUMS point plus a random tweak generated by both participants.\nBetter yet, MuSig allows hiding any n-of-n among 1-of-1; we expect 1-of-1 use to dominate in the foreseeable future, thus MuSig usage maximizes our anonymity set.\n\n### End Digression\n\nA potential issue with MuSig is the increased number of communication rounds needed to generate signatures.\n\nIn the current Poon-Dryja setup we have, in order to completely sign the commitment transaction held by one participant, we only require sending a completed signature from the remote participant via `commitment_signed`.\nThen the local participant issues a `revoke_and_ack` to reassure the remote side that the previous commitment it held is now revoked.\nThus, the signing itself requires only 0.5 round trips.\n\nMuSig requires three rounds to complete the signing protocol.\nSince Poon-Dryja only require the complete set of signatures for any particular commitment transaction to be owned by only one participant (i.e. Poon-Dryja commitment transactions are asymmetrical), MuSig only requires 2.5 round trips to sign a Poon-Dryja commitment.\n\nReducing the round trips is desirable when considering latency, which affects the experienced speed of forwarding, as well as the backwards propagation of failures (but not of successful payments).\nCurrently, latency on the network is known to be very low, but I observe that most Lightning Network participants today have excellent Internet connectivity, which might not be true in the foreseeable future.\n\nWe can reduce the round trips to 1.5 per commitment, except for the initial commitment transaction, by sending the `R` precommitments (the first phase of MuSig) of the *next* signing session while sending the `s` for the *current* signing session.\n\nFinally, we can consider to reduce the use of MuSig via various techniques.\nOne technique is the use of fast forwards: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001986.html\n\nThe other involves using Taproot.\nThe taproot internal pubkey is the MuSig of both participants, but we also add an explicit 2-of-2 as a tapscript (or hide the 2-of-2 in a 2-of-3), i.e. `<A> OP_CHECKSIGVERIFY <B> OP_CHECKSIG` in a tapscript.\nThis allows commitment transactions to use the tapscript path and have separate signatures for both participants.\nThen, mutual close uses the MuSig keypath spend.\nThis reduces the changes relative to the current Poon-Dryja implementation: we can continue to use `commitment_signed` messages (or equivalent new ones for Taproot-based Poon-Dryja channels), and only the mutual close ritual needs to be modified to use MuSig.\n\nThus the options are below, but ***please do not select an option yet***, because further sections greatly affect the tradeoffs of the options below.\n\n* [ ] Latency is not an issue (even in the foreseeable future), just use the 2.5 round trips for MuSig and MuSig-sign every commitment.\n* [ ] Pre-send the `R` commitments with the previous `s`.\n  * This increases the needed storage requirements of both nodes, and possibly complexity of node software, but reduces the round trips to 1.5.\n  * This usage may need to have larger bounds than what may be naively expected, if we decide to use Multi-`R` composable MuSig (see later section).\n  * Even *without* this option, at the minimum we still need to store `R` commitments and `R`, at least in memory, until we complete the MuSig ritual.\n* [ ] Use fast-forwards.\n  * This removes the latency of commitment transaction signing from the forwarding and failure-reporting paths.\n    * *Improved* forwarding and failure-reporting latency compared to today (revocation and signature not needed for forwarding/failure-reporting).\n  * Latency is still high for commitment transaction signing, but this is less of an issue as it is no longer in the forwarding/failure-reporting path.\n* [ ] Explicit 2-of-2 for commitment, MuSig for mutual close.\n  * No degradation in latency compared to today (0.5 round trips for signature, additional 1 round trip for signalling and revocation).\n  * No improvement (or degradation) of privacy for unilateral closes compared to today, but improved privacy for mutual closes.\n    * An argument *for* this option is that unilateral closes (commitment transactions) have special scripts on their outputs anyway, thus still leak their privacy, but see later sections for how Taproot may help reduce the uniqueness of those outputs, thus *not* taking this option may still improve privacy for unilateral closes.\n\nComposable MuSig\n----------------\n\nAs I describe here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017493.html\n\nIn that write-up, I mention the use-case of nodelets.\nAnother use-case is for redundant hardware signers: https://lists.ozlabs.org/pipermail/c-lightning/2019-December/000172.html\n\nWe have the option of allowing for a composable MuSig, probably my multi-`R` proposal, where each participant may send one or more `R` commitments and subsequent `R`s.\n\n* [ ] Not use composable MuSig of any kind, at least for now.\n  * Possibly we could defer the use of a composable MuSig when a better composable MuSig (with security proofs) has been derived.\n* [ ] Use Multi-`R` composable MuSig.\n  * We need to probably impose some limit on the number of `R` commitments that can be sent: _____ `R`s maximum.\n\nThe latter option above affects the previous choice regarding whether to pre-send `R` commitments with the previous `s` sending, as this increases the maximal storage requirement for the pre-sent `R` commitment(s).\n\nPointlocked Timelocked Contracts\n--------------------------------\n\nI would have preferred to keep this in a separate discussion thread, however the exact details of PTLCs may affect our decision on how to sign commitment transactions.\n\nPTLCs are necessary to switch the Lightning Network to payment point+scalar, and indeed one can argue that the entire point of enabling Schnorr and Taproot at the base layer is to allow us to use payment point+scalar at the Lightning layer.\n\nFirst, I will discuss how to create a certain kind of PTLCs, which I call \"purely scriptless\" PTLCs.\nIn particular, I would like to point out that we *actually* use in current Poon-Dryja Lightning Network channels is *revocable* HTLCs, thus we need to have *revocable* PTLCs to replace them.\n\n* First, we must have a sender A, who is buying a secret scalar, and knows the point equivalent to that scalar.\n* Second, we have a receiver B, who knows this secret scalar (or can somehow learn this secret scalar).\n* A and B agree on the specifications of the PTLC: the point, the future absolute timelock, the value.\n* A creates (but *does not* sign or broadcast) a transaction that pays to a MuSig of A and B and shares the txid and output number with the relevant MuSig output.\n* A and B create a backout transaction.\n  * This backout has an `nLockTime` equal to the agreed absolute timelock.\n  * It spends the above MuSig output (this input must enable `nLockTime`, e.g. by setting `nSequence` to `0xFFFFFFFE`).\n  * It creates an output that is solely controlled by A.\n* A and B perform a MuSig ritual to sign the backout transaction.\n* A now signs and broadcast the first transaction, the one that has an output that represents the PTLC.\n* A and B wait for the above transaction to confirm deeply.\n  This completes the setup phase for the PTLC.\n* After this point, if the agreed-upon locktime is reached, A broadcasts the backout transaction and aborts the ritual.\n* A and B create a claim transaction.\n  * This has an `nLockTime` of 0, or a present or past blockheight, or disabled `nLockTime`.\n  * This spends the above MuSig output.\n  * This creates an output that is solely controlled by B.\n* A and B generate an adaptor signature for the claim transaction, which reveals the agreed scalar.\n  * This is almost entirely a MuSig ritual, except at `s` exchange, B provides `t + r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` first, then demands `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, A) * a` from A, then reveals `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` (or the completed signature, by publishing onchain), revealing the secret scalar `t` to A.\n* A is able to learn the secret scalar from the above adaptor signature followed by the full signature, completing the ritual.\n\nNote that the above ritual is \"purely scriptless\".\nIt is possible to take advantage of taproot to create a tapscript equivalent to `<agreed locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <A> OP_CHECKSIG`.\nThis removes the need to perform a MuSig ritual to sign a backout transaction: A can generate the backout transaction all by itself.\nThis use is not purely scriptless, as the timelocked branch is controlled by a tapscript that is hidden in the pointlocked branch, meaning that taking the timelocked branch reveals the contract.\n\nThe tradeoff is that if we use \"purely scriptless\" PTLCs:\n\n* If we have purely scriptless PTLCs, then even the timelock branch is potentially indistinguishable from ordinary spends.\n  * We should note that Bitcoin Core itself already uses the current blockheight plus 1 for `nLockTime` when spending, instead of a 0 or disabled `nLockTime`.\n  * If the above habit were more widespread (i.e. if all wallets implemented the use of a current `nLockTime` for ordinary onchain spends) then the timelock branch has an anonymity set equal to all Schnorr keypath spends, as the `nLockTime` is always used anyway.\n  * Other kinds of offchain protocols may also utilize this technique, slightly increasing the anonymity set as well.\n    Thus, the use of the current blockheight plus 1 for `nLockTime` should be recommended for improved privacy in Bitcoin anyway.\n* However, purely scriptless PTLCs require a complete MuSig ritual (2.5 to 3 round trips!) to sign the timelocked branch (the initial backout transaction); this increases the latency of adding new PTLCs.\n  * Of note is that in the case of Lightning, we may need to add a new PTLC while another PTLC is *still* in-flight; on the new commitment transaction, we need to redo the MuSig rituals to create new backouts and new adaptor signtures for each PTLC.\n    * This can be amortized such that we redo all the rituals for all existing PTLCs in parallel.\n      * The use of multi-`R` composable MuSig greatly increases the storage requirements as well!\n  * Further, the privacy gained in the timelock path is degraded or lost when we consider revocable PTLCs and revocable outputs.\n  * It is not clear to me as fo now if the MuSig ritual for the backout transaction must complete in full before the MuSig ritual for the claim transaction (the pointlocked branch, which includes sharing an adaptor signature during `s` exchange).\n    * If we can do these two rituals in parallel, this reduces the latency disadvantage of the purely scriptless PTLC to just 1 round trip compared to the tapscripted timelock branch PTLC.\n    * Possibly the adaptor signature ritual could stop until B provides the adaptor signature, then full `s` exchange is deferred to after the PTLC 2-of-2 is instantiated onchain/reified in a commitment transaction.\n\nThus our options are the below, but again, you should defer deciding on the best option until you understand about revocable PTLCs.\n\n* [ ] We can use a purely scriptless PTLC construction.\n  * Better privacy, but increased latency.\n* [ ] We can use a tapscripted timelock branch and a keypath pointlocked branch for the PTLC.\n  * Lower latency, but possibly reduced privacy advantage in the timelock branch (privacy advantage still exists in the pointlocked branch, which we hope is more common anyway).\n\nRevocable Outputs and PTLCs\n---------------------------\n\nPoon-Dryja mechanism is based on revocation of contracts instantiated from previous states.\nThus, all outputs of Poon-Dryja must be made revocable.\n\nAt a high-enough level, this only requires the addition of a `(revocation_secret && remote_secret) || (CSV && L)` to the top-level logic (`L`) of a contract.\nOf course, the details have the devil.\n\nNow, in Poon-Dryja, each side of the channel has its own commitment transaction.\nThus, contracts on the commitment transaction refer to a \"local side\" and a \"remote side\".\nThe \"local side\" is whoever is holding the completely-signed commitment transaction, while the \"remote side\" is the other side.\n\nRevocable outputs always have a CSV-requirement before the output can be spent by whoever \"should\" own the output, according to the contract details.\nThe revocation secret is known by the local side, and then when a *new* commitment transaction has been signed, the revocation secret is given by the local side to the remote side, allowing all outputs to be spent directly by the remote side if an old, revoked commitment transaction is published onchain.\n\nThere are many ways to implement revocable outputs.\nThe core idea of revocable outputs, however, is that there must exist some relative-locktime branch on each output that goes to the local side.\nThis relative-locktime branch can be implemented as \"purely scriptless\" by using a 2-of-2 of both the local and remote sides, with a relative-locktime `nSequence`, using the same technique as described in the previous section.\n\nHowever, unlike the absolute-locktime `nLockTime` for the timelock branches of PTLCs, ***there is no current wallet software that uses activated-relative-locktime `nSequence` for ordinary spends***.\nThus, any use of the relative-locktime branch does *not* have a privacy advantage under purely scriptless.\n\nThus the tradeoffs here are different, and definitely in favor of the tapscripted-relative-locktime technique.\n\n* There is no current wallet software that uses relative locktimes.\n  * Bitcoin Core uses absolute locktimes with the current blockheight plus 1, and we can hide the use of absolute locktimes by imitating this Bitcoin Core behavior.\n  * Any use of relative locktimes is a strong signal of some kind of complicated offchain updateable mechanism.\n    We can note as well that Decker-Russell-Osuntokun also uses relative locktimes.\n* The relative-locktime branch in revocable outputs is the **desirable** case, because taking the relative locktime means that the commitment transaction published *was not* a revoked transaction (i.e. it was the latest transaction version).\n  * Thus, it would be nice if this had good privacy.\n  * However, this *cannot* have good privacy since there is no current common use of activated relative locktimes for ordinary spends.\n\nThe latter point above also biases us towards rejecting purely-scriptless in the *previous* section, in particular:\n\n* The absolute-locktime branch in the PTLC is the **undesirable** case, where the payee B somehow stops responding to A.\n  * In particular, propagating failure backwards is done by simply deleting PTLCs, thus the absolute-locktime branch does not come into play during payment failure.\n  * Thus, the privacy increase of hiding absolute-locktime branches is minor, and the privacy breach of revocable outputs (i.e. it leaks the use of relative-locktime, and nearly all uses of relative locktime will be offchain updateable cryptocurrency mechanisms, such as Poon-Dryja or Decker-Russell-Osuntokun) is arguably much larger than the privacy increase of purely-scriptless absolute-locktime.\n\nOf particular not is that if a PTLC is instantiated on the commitment transaction of the payer A, then the absolute-locktime backout transaction must *not* pay to A only, but instead pays to a *revocable output* that will eventually pay to A after the relative locktime.\nThus, the privacy boost of the purely-scriptless backout transaction would be lost by the later revelation of the use of a relative locktime after the revocable output is reclaimed by A.\nAgain, that use of relative locktime (whether enforced by script, or by scriptless use of a 2-of-2 that is spent with an activated relative-locktime `nSequence`) is a strong indicator of the use of Poon-Dryja or Decker-Russell-Osuntokun or even Decker-Wattenhofer mechanisms, and the logic is that since Lightning Network is the most widespread offchain mechanism, it probably indicates the use of LN.\n\nThus the decision in the previous section is affected by this reality that we in fact need *revocable* PTLCs, not plain PTLCs, thus the advantage of purely-scriptless backout transactions in the previous section is reduced by the need to make outputs revocable.\n\nThus:\n\n* Revocable outputs require a relative-timelock branch.\n* That branch is the **desirable** branch, i.e. the latest commitment transaction is the one that got published and thus is *not* revoked.\n  * We thus expect this relative-timelock branch to be the *common* branch.\n* No wallet uses relative-timelock for ordinary spends, unlike abolute-locktime where Bitcoin Core always uses absolute-locktime `nLockTime` for ordinary spends.\n  * Thus, using purely scriptless for the relative-timelock branch of revocable outputs does not in fact hide that we are doing something special.\n\nConclusion\n----------\n\nOthers may find further issues or alternative options for the above points.\nFurther discussion may be warranted before we actually select particular options to implement and evaluate in alpha software.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-12-16T01:27:59",
                "message_text_only": "Given the timeline for soft forks to activate on Bitcoin, I don't know\nwhy we'd be super conservative about using new features of the Bitcoin\nconsensus rules. I think obviously we'd want to rush as fast as we can\ninto adding real cross-hop privacy to lightning payments, given both the\nnumber of awkward edge cases it introduces into the protocol, and the\nmassive privacy leak.\n\nChanging the underlying commitment transaction structure *could* come\nlater, as it is, indeed, lower priority (and then the rule would be\n\"taproot outputs are always lightning\" for some time anyway), but, if\nyou're changing things kinda why not.\n\nOf course once you get privacy across routing hops, the importance of\nprivacy-preserving routing algorithm work and fixing some other privacy\nholes is probably more important, so I could be dissuaded.\n\nMatt\n\nOn 12/15/19 3:43 PM, ZmnSCPxj via Lightning-dev wrote:\n> Good morning list,\n> \n> I would like to initiate some discussion on how Lightning could be updated to take advantage of the upcoming taproot update to the base layer.\n> \n> For now, I am assuming the continued use of the existing Poon-Dryja update mechanism.\n> Decker-Russell-Osuntokun requires `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`, and its details seem less settled for now than taproot details.\n> \n> * [ ] We could update the current Poon-Dryja mechanism to use Schnorr signatures.\n> * [ ] Or we could just keep the current Poon-Dryja mechanism with SegWit v0 only, and only update to Schnorr / SegWit v1 when we can implement Decker-Russell-Osuntokun.\n>   * This brings up the question as to whether we will allow Poon-Dryja to host pointlocked-timelocked contracts (i.e. the Scriptless Script replacement of HTLCs that uses payment points+scalars).\n>     * [ ] We could constrain Poon-Dryja channels to only HTLCs.\n>       * This might be simpler for implementations: implementations could have a completely new module that implements Decker-Russell-Osuntokun with HTLCs and PTLCs, and not touch existing modules for Poon-Dryja with HTLCs only.\n>       * We could \"retire\" Poon-Dryja constructions at some point and only add new features to Decker-Russell-Osuntokun channels.\n>     * [ ] We could allow hosting PTLCs as well on Poon-Dryja channels, as nothing in the base layer prevents a transaction from providing both SegWit v0 and SegWit v1 outputs anyway.\n> \n> Poon-Dryja with Schnorr\n> -----------------------\n> \n> If we decide to update the current Poon-Dryja mechanism to use Schnorr, there are some wrinkles:\n> \n> * [ ] We could just drop-in replace the signing algorithm with Schnorr.\n>   * We would define a NUMS point to be used as Taproot internal key, and use a single tapscript that is simply the current script template.\n>   * This is arguably not really taking advantage of the Schnorr and Taproot features, however.\n> * [ ] Or we could use some sort of MuSig between the two channel participants.\n> \n> The latter option is probably what we want to use, as it potentially allows a channel close to be indistinguishable from an ordinary SegWit v1 spend of a UTXO.\n> Even for channels that have been published via gossip, it moves the onus of storing historical data about historically-published channels from base layer fullnodes to nodes that want to surveill the network.\n> \n> ### Digression: 2-of-2 is Obviously Lightning\n> \n> Existing 2-of-2 outputs have a very high probability of being Lightning Network channels.\n> Thus, someone who wishes to surveill the Lightning Network can simply query any archive fullnode for historical 2-of-2 outputs and have a good chance that those are Lightning Network channels.\n> \n> Consider the adage: Never go to sea with two chronometers; take one or three.\n> https://en.wikipedia.org/wiki/Dual_modular_redundancy\n> This implies that ordinary HODL usage of transaction outputs will either use 1-of-1, or 2-of-3.\n> \n> Offchain techniques, on the other hand, are only safe (trustless) if they are n-of-n, and are only usefully multi-participant if n > 1.\n> https://zmnscpxj.github.io/offchain/safety.html\n> Thus any n-of-n is likely to be an offchain protocol, with the most likely being the most widespread offchain protocol, Lightning Network.\n> \n> Thus, the hyperbole \"2-of-2 is Obviously Lightning\".\n> \n> However, we can \"hide\" 2-of-2 in a 2-of-3, which can be done by generating a third point from a NUMS point plus a random tweak generated by both participants.\n> Better yet, MuSig allows hiding any n-of-n among 1-of-1; we expect 1-of-1 use to dominate in the foreseeable future, thus MuSig usage maximizes our anonymity set.\n> \n> ### End Digression\n> \n> A potential issue with MuSig is the increased number of communication rounds needed to generate signatures.\n> \n> In the current Poon-Dryja setup we have, in order to completely sign the commitment transaction held by one participant, we only require sending a completed signature from the remote participant via `commitment_signed`.\n> Then the local participant issues a `revoke_and_ack` to reassure the remote side that the previous commitment it held is now revoked.\n> Thus, the signing itself requires only 0.5 round trips.\n> \n> MuSig requires three rounds to complete the signing protocol.\n> Since Poon-Dryja only require the complete set of signatures for any particular commitment transaction to be owned by only one participant (i.e. Poon-Dryja commitment transactions are asymmetrical), MuSig only requires 2.5 round trips to sign a Poon-Dryja commitment.\n> \n> Reducing the round trips is desirable when considering latency, which affects the experienced speed of forwarding, as well as the backwards propagation of failures (but not of successful payments).\n> Currently, latency on the network is known to be very low, but I observe that most Lightning Network participants today have excellent Internet connectivity, which might not be true in the foreseeable future.\n> \n> We can reduce the round trips to 1.5 per commitment, except for the initial commitment transaction, by sending the `R` precommitments (the first phase of MuSig) of the *next* signing session while sending the `s` for the *current* signing session.\n> \n> Finally, we can consider to reduce the use of MuSig via various techniques.\n> One technique is the use of fast forwards: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001986.html\n> \n> The other involves using Taproot.\n> The taproot internal pubkey is the MuSig of both participants, but we also add an explicit 2-of-2 as a tapscript (or hide the 2-of-2 in a 2-of-3), i.e. `<A> OP_CHECKSIGVERIFY <B> OP_CHECKSIG` in a tapscript.\n> This allows commitment transactions to use the tapscript path and have separate signatures for both participants.\n> Then, mutual close uses the MuSig keypath spend.\n> This reduces the changes relative to the current Poon-Dryja implementation: we can continue to use `commitment_signed` messages (or equivalent new ones for Taproot-based Poon-Dryja channels), and only the mutual close ritual needs to be modified to use MuSig.\n> \n> Thus the options are below, but ***please do not select an option yet***, because further sections greatly affect the tradeoffs of the options below.\n> \n> * [ ] Latency is not an issue (even in the foreseeable future), just use the 2.5 round trips for MuSig and MuSig-sign every commitment.\n> * [ ] Pre-send the `R` commitments with the previous `s`.\n>   * This increases the needed storage requirements of both nodes, and possibly complexity of node software, but reduces the round trips to 1.5.\n>   * This usage may need to have larger bounds than what may be naively expected, if we decide to use Multi-`R` composable MuSig (see later section).\n>   * Even *without* this option, at the minimum we still need to store `R` commitments and `R`, at least in memory, until we complete the MuSig ritual.\n> * [ ] Use fast-forwards.\n>   * This removes the latency of commitment transaction signing from the forwarding and failure-reporting paths.\n>     * *Improved* forwarding and failure-reporting latency compared to today (revocation and signature not needed for forwarding/failure-reporting).\n>   * Latency is still high for commitment transaction signing, but this is less of an issue as it is no longer in the forwarding/failure-reporting path.\n> * [ ] Explicit 2-of-2 for commitment, MuSig for mutual close.\n>   * No degradation in latency compared to today (0.5 round trips for signature, additional 1 round trip for signalling and revocation).\n>   * No improvement (or degradation) of privacy for unilateral closes compared to today, but improved privacy for mutual closes.\n>     * An argument *for* this option is that unilateral closes (commitment transactions) have special scripts on their outputs anyway, thus still leak their privacy, but see later sections for how Taproot may help reduce the uniqueness of those outputs, thus *not* taking this option may still improve privacy for unilateral closes.\n> \n> Composable MuSig\n> ----------------\n> \n> As I describe here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017493.html\n> \n> In that write-up, I mention the use-case of nodelets.\n> Another use-case is for redundant hardware signers: https://lists.ozlabs.org/pipermail/c-lightning/2019-December/000172.html\n> \n> We have the option of allowing for a composable MuSig, probably my multi-`R` proposal, where each participant may send one or more `R` commitments and subsequent `R`s.\n> \n> * [ ] Not use composable MuSig of any kind, at least for now.\n>   * Possibly we could defer the use of a composable MuSig when a better composable MuSig (with security proofs) has been derived.\n> * [ ] Use Multi-`R` composable MuSig.\n>   * We need to probably impose some limit on the number of `R` commitments that can be sent: _____ `R`s maximum.\n> \n> The latter option above affects the previous choice regarding whether to pre-send `R` commitments with the previous `s` sending, as this increases the maximal storage requirement for the pre-sent `R` commitment(s).\n> \n> Pointlocked Timelocked Contracts\n> --------------------------------\n> \n> I would have preferred to keep this in a separate discussion thread, however the exact details of PTLCs may affect our decision on how to sign commitment transactions.\n> \n> PTLCs are necessary to switch the Lightning Network to payment point+scalar, and indeed one can argue that the entire point of enabling Schnorr and Taproot at the base layer is to allow us to use payment point+scalar at the Lightning layer.\n> \n> First, I will discuss how to create a certain kind of PTLCs, which I call \"purely scriptless\" PTLCs.\n> In particular, I would like to point out that we *actually* use in current Poon-Dryja Lightning Network channels is *revocable* HTLCs, thus we need to have *revocable* PTLCs to replace them.\n> \n> * First, we must have a sender A, who is buying a secret scalar, and knows the point equivalent to that scalar.\n> * Second, we have a receiver B, who knows this secret scalar (or can somehow learn this secret scalar).\n> * A and B agree on the specifications of the PTLC: the point, the future absolute timelock, the value.\n> * A creates (but *does not* sign or broadcast) a transaction that pays to a MuSig of A and B and shares the txid and output number with the relevant MuSig output.\n> * A and B create a backout transaction.\n>   * This backout has an `nLockTime` equal to the agreed absolute timelock.\n>   * It spends the above MuSig output (this input must enable `nLockTime`, e.g. by setting `nSequence` to `0xFFFFFFFE`).\n>   * It creates an output that is solely controlled by A.\n> * A and B perform a MuSig ritual to sign the backout transaction.\n> * A now signs and broadcast the first transaction, the one that has an output that represents the PTLC.\n> * A and B wait for the above transaction to confirm deeply.\n>   This completes the setup phase for the PTLC.\n> * After this point, if the agreed-upon locktime is reached, A broadcasts the backout transaction and aborts the ritual.\n> * A and B create a claim transaction.\n>   * This has an `nLockTime` of 0, or a present or past blockheight, or disabled `nLockTime`.\n>   * This spends the above MuSig output.\n>   * This creates an output that is solely controlled by B.\n> * A and B generate an adaptor signature for the claim transaction, which reveals the agreed scalar.\n>   * This is almost entirely a MuSig ritual, except at `s` exchange, B provides `t + r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` first, then demands `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, A) * a` from A, then reveals `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` (or the completed signature, by publishing onchain), revealing the secret scalar `t` to A.\n> * A is able to learn the secret scalar from the above adaptor signature followed by the full signature, completing the ritual.\n> \n> Note that the above ritual is \"purely scriptless\".\n> It is possible to take advantage of taproot to create a tapscript equivalent to `<agreed locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <A> OP_CHECKSIG`.\n> This removes the need to perform a MuSig ritual to sign a backout transaction: A can generate the backout transaction all by itself.\n> This use is not purely scriptless, as the timelocked branch is controlled by a tapscript that is hidden in the pointlocked branch, meaning that taking the timelocked branch reveals the contract.\n> \n> The tradeoff is that if we use \"purely scriptless\" PTLCs:\n> \n> * If we have purely scriptless PTLCs, then even the timelock branch is potentially indistinguishable from ordinary spends.\n>   * We should note that Bitcoin Core itself already uses the current blockheight plus 1 for `nLockTime` when spending, instead of a 0 or disabled `nLockTime`.\n>   * If the above habit were more widespread (i.e. if all wallets implemented the use of a current `nLockTime` for ordinary onchain spends) then the timelock branch has an anonymity set equal to all Schnorr keypath spends, as the `nLockTime` is always used anyway.\n>   * Other kinds of offchain protocols may also utilize this technique, slightly increasing the anonymity set as well.\n>     Thus, the use of the current blockheight plus 1 for `nLockTime` should be recommended for improved privacy in Bitcoin anyway.\n> * However, purely scriptless PTLCs require a complete MuSig ritual (2.5 to 3 round trips!) to sign the timelocked branch (the initial backout transaction); this increases the latency of adding new PTLCs.\n>   * Of note is that in the case of Lightning, we may need to add a new PTLC while another PTLC is *still* in-flight; on the new commitment transaction, we need to redo the MuSig rituals to create new backouts and new adaptor signtures for each PTLC.\n>     * This can be amortized such that we redo all the rituals for all existing PTLCs in parallel.\n>       * The use of multi-`R` composable MuSig greatly increases the storage requirements as well!\n>   * Further, the privacy gained in the timelock path is degraded or lost when we consider revocable PTLCs and revocable outputs.\n>   * It is not clear to me as fo now if the MuSig ritual for the backout transaction must complete in full before the MuSig ritual for the claim transaction (the pointlocked branch, which includes sharing an adaptor signature during `s` exchange).\n>     * If we can do these two rituals in parallel, this reduces the latency disadvantage of the purely scriptless PTLC to just 1 round trip compared to the tapscripted timelock branch PTLC.\n>     * Possibly the adaptor signature ritual could stop until B provides the adaptor signature, then full `s` exchange is deferred to after the PTLC 2-of-2 is instantiated onchain/reified in a commitment transaction.\n> \n> Thus our options are the below, but again, you should defer deciding on the best option until you understand about revocable PTLCs.\n> \n> * [ ] We can use a purely scriptless PTLC construction.\n>   * Better privacy, but increased latency.\n> * [ ] We can use a tapscripted timelock branch and a keypath pointlocked branch for the PTLC.\n>   * Lower latency, but possibly reduced privacy advantage in the timelock branch (privacy advantage still exists in the pointlocked branch, which we hope is more common anyway).\n> \n> Revocable Outputs and PTLCs\n> ---------------------------\n> \n> Poon-Dryja mechanism is based on revocation of contracts instantiated from previous states.\n> Thus, all outputs of Poon-Dryja must be made revocable.\n> \n> At a high-enough level, this only requires the addition of a `(revocation_secret && remote_secret) || (CSV && L)` to the top-level logic (`L`) of a contract.\n> Of course, the details have the devil.\n> \n> Now, in Poon-Dryja, each side of the channel has its own commitment transaction.\n> Thus, contracts on the commitment transaction refer to a \"local side\" and a \"remote side\".\n> The \"local side\" is whoever is holding the completely-signed commitment transaction, while the \"remote side\" is the other side.\n> \n> Revocable outputs always have a CSV-requirement before the output can be spent by whoever \"should\" own the output, according to the contract details.\n> The revocation secret is known by the local side, and then when a *new* commitment transaction has been signed, the revocation secret is given by the local side to the remote side, allowing all outputs to be spent directly by the remote side if an old, revoked commitment transaction is published onchain.\n> \n> There are many ways to implement revocable outputs.\n> The core idea of revocable outputs, however, is that there must exist some relative-locktime branch on each output that goes to the local side.\n> This relative-locktime branch can be implemented as \"purely scriptless\" by using a 2-of-2 of both the local and remote sides, with a relative-locktime `nSequence`, using the same technique as described in the previous section.\n> \n> However, unlike the absolute-locktime `nLockTime` for the timelock branches of PTLCs, ***there is no current wallet software that uses activated-relative-locktime `nSequence` for ordinary spends***.\n> Thus, any use of the relative-locktime branch does *not* have a privacy advantage under purely scriptless.\n> \n> Thus the tradeoffs here are different, and definitely in favor of the tapscripted-relative-locktime technique.\n> \n> * There is no current wallet software that uses relative locktimes.\n>   * Bitcoin Core uses absolute locktimes with the current blockheight plus 1, and we can hide the use of absolute locktimes by imitating this Bitcoin Core behavior.\n>   * Any use of relative locktimes is a strong signal of some kind of complicated offchain updateable mechanism.\n>     We can note as well that Decker-Russell-Osuntokun also uses relative locktimes.\n> * The relative-locktime branch in revocable outputs is the **desirable** case, because taking the relative locktime means that the commitment transaction published *was not* a revoked transaction (i.e. it was the latest transaction version).\n>   * Thus, it would be nice if this had good privacy.\n>   * However, this *cannot* have good privacy since there is no current common use of activated relative locktimes for ordinary spends.\n> \n> The latter point above also biases us towards rejecting purely-scriptless in the *previous* section, in particular:\n> \n> * The absolute-locktime branch in the PTLC is the **undesirable** case, where the payee B somehow stops responding to A.\n>   * In particular, propagating failure backwards is done by simply deleting PTLCs, thus the absolute-locktime branch does not come into play during payment failure.\n>   * Thus, the privacy increase of hiding absolute-locktime branches is minor, and the privacy breach of revocable outputs (i.e. it leaks the use of relative-locktime, and nearly all uses of relative locktime will be offchain updateable cryptocurrency mechanisms, such as Poon-Dryja or Decker-Russell-Osuntokun) is arguably much larger than the privacy increase of purely-scriptless absolute-locktime.\n> \n> Of particular not is that if a PTLC is instantiated on the commitment transaction of the payer A, then the absolute-locktime backout transaction must *not* pay to A only, but instead pays to a *revocable output* that will eventually pay to A after the relative locktime.\n> Thus, the privacy boost of the purely-scriptless backout transaction would be lost by the later revelation of the use of a relative locktime after the revocable output is reclaimed by A.\n> Again, that use of relative locktime (whether enforced by script, or by scriptless use of a 2-of-2 that is spent with an activated relative-locktime `nSequence`) is a strong indicator of the use of Poon-Dryja or Decker-Russell-Osuntokun or even Decker-Wattenhofer mechanisms, and the logic is that since Lightning Network is the most widespread offchain mechanism, it probably indicates the use of LN.\n> \n> Thus the decision in the previous section is affected by this reality that we in fact need *revocable* PTLCs, not plain PTLCs, thus the advantage of purely-scriptless backout transactions in the previous section is reduced by the need to make outputs revocable.\n> \n> Thus:\n> \n> * Revocable outputs require a relative-timelock branch.\n> * That branch is the **desirable** branch, i.e. the latest commitment transaction is the one that got published and thus is *not* revoked.\n>   * We thus expect this relative-timelock branch to be the *common* branch.\n> * No wallet uses relative-timelock for ordinary spends, unlike abolute-locktime where Bitcoin Core always uses absolute-locktime `nLockTime` for ordinary spends.\n>   * Thus, using purely scriptless for the relative-timelock branch of revocable outputs does not in fact hide that we are doing something special.\n> \n> Conclusion\n> ----------\n> \n> Others may find further issues or alternative options for the above points.\n> Further discussion may be warranted before we actually select particular options to implement and evaluate in alpha software.\n> \n> Regards,\n> ZmnSCPxj\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-12-17T14:02:29",
                "message_text_only": "On Sun, Dec 15, 2019 at 03:43:07PM +0000, ZmnSCPxj via Lightning-dev wrote:\n> For now, I am assuming the continued use of the existing Poon-Dryja update mechanism.\n> Decker-Russell-Osuntokun requires `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`, and its details seem less settled for now than taproot details.\n\nSupporting PTLCs instead of HTLCs is a global upgrade in that you need\nall nodes along your payment path to support it; moving from Poon-Dryja\nto Decker-Russell-Osuntokun is only relevant to individual peers. So I\nthink it makes sense to do PTLCs first if the required features aren't\nboth enabled at the same time.\n\n> Poon-Dryja with Schnorr\n> -----------------------\n\nI think MuSig between the two pairs is always superior to a NUMS point\nfor the taproot internal key; you definitely want to calculate a point\nrather than use a constant, or you're giving away that it's lightning,\nand if you're calculating you might as well calculate something that can\nbe used for a cooperative key path spend if you ever want to.\n\n> A potential issue with MuSig is the increased number of communication rounds needed to generate signatures.\n\nI think you can reduce this via an alternative script path. In\nparticular, if you want a script that the other guy can spend if they\nreveal the discrete log of point X, with musig you do:\n\n   P = H(H(A,B),1)*A + H(H(A,B),2)*B\n   [exchange H(RA),H(RB),RA,RB]\n\n   [send X]\n\n   sb = rb + H(RA+RB+X,P,m)*H(H(A,B),2)*b\n\n   [wait for sb]\n\n   sa = ra + H(RA+RB+X,P,m)*H(H(A,B),1)*a\n\n   [store RA+RB+X, sa+sb, supply sa, watch for sig]\n\n   sig = (RA+RB+X, sa+sb+x)\n\nSo the 1.5 round trips are \"I want to do a PTLC for X\", \"okay here's\nsb\", \"great, here's sa\".\n\nBut with taproot you can have a script path as well, so you could have a\nscript:\n\n   A CHECKSIGVERIFY B CHECKSIG\n\nand supply a partial signature:\n\n   R+X,s,X where s = r + H(R+X,A,m)*a\n\nto allow them to satisfy \"A CHECKSIGVERIFY\" if they know the discrete\nlog of X, and of course they can sign with B at any time. This is only\nhalf a round trip, and can be done at the same time as sending the \"I\nwant to do a PTLC for X\" message to setup the (ultimately cheaper) MuSig\nspend. It's an extra signature on the sender's side and an extra verification \non the receiver's side, but I think it works out fine.\n\n> Pointlocked Timelocked Contracts\n> --------------------------------\n> First, I will discuss how to create a certain kind of PTLCs, which I call \"purely scriptless\" PTLCs.\n> In particular, I would like to point out that we *actually* use in current Poon-Dryja Lightning Network channels is *revocable* HTLCs, thus we need to have *revocable* PTLCs to replace them.\n> * First, we must have a sender A, who is buying a secret scalar, and knows the point equivalent to that scalar.\n> * Second, we have a receiver B, who knows this secret scalar (or can somehow learn this secret scalar).\n> * A and B agree on the specifications of the PTLC: the point, the future absolute timelock, the value.\n> * A creates (but *does not* sign or broadcast) a transaction that pays to a MuSig of A and B and shares the txid and output number with the relevant MuSig output.\n> * A and B create a backout transaction.\n>   * This backout has an `nLockTime` equal to the agreed absolute timelock.\n>   * It spends the above MuSig output (this input must enable `nLockTime`, e.g. by setting `nSequence` to `0xFFFFFFFE`).\n>   * It creates an output that is solely controlled by A.\n> * A and B perform a MuSig ritual to sign the backout transaction.\n> * A now signs and broadcast the first transaction, the one that has an output that represents the PTLC.\n> * A and B wait for the above transaction to confirm deeply.\n>   This completes the setup phase for the PTLC.\n> * After this point, if the agreed-upon locktime is reached, A broadcasts the backout transaction and aborts the ritual.\n> * A and B create a claim transaction.\n>   * This has an `nLockTime` of 0, or a present or past blockheight, or disabled `nLockTime`.\n>   * This spends the above MuSig output.\n>   * This creates an output that is solely controlled by B.\n> * A and B generate an adaptor signature for the claim transaction, which reveals the agreed scalar.\n>   * This is almost entirely a MuSig ritual, except at `s` exchange, B provides `t + r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` first, then demands `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, A) * a` from A, then reveals `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` (or the completed signature, by publishing onchain), revealing the secret scalar `t` to A.\n> * A is able to learn the secret scalar from the above adaptor signature followed by the full signature, completing the ritual.\n\n(I think it makes more sense to provide \"r + H(R+T, P, m)*b\" instead of\n\"r+t + H(R,P,m)*b\" -- you might not know \"t\" at the point you need to\nstart the signature exchange)\n\nI think the setup can be similar to BOLT-3:\n\n  Funding TX output:  MuSig(A,B)\n\n  Commitment Tx Held by A:\n    - locktime: obscured commitment number\n    - input: funding tx\n    - outputs:\n        balance A\n\tbalance B\n\tPTLC paying to A\n\tPTLC paying to B\n        [etc]\n\nbalance B can pay directly to B\n\nbalance A pays to MuSig(Rn,B) -- where Rn is the revocation key for the\nnth commitment, and A holds a presigned tx by B with relative locktime\nset, paying the funds to A.\n\nPTLCs also pay to MuSig(Rn,B) -- \n\nfor the one paying to A, A holds a tx\npartially presigned by B that needs the point's discrete log added to x\nwith relative timelock; for the one paying to B, A holds a presigned tx\nby B that has absolute locktime set and pays to MuSig(Rn,B) for which\nA has another presigned tx by B that has relative locktime set.\n\nHTLC's also pay to MuSig(Rn,B) but they're tweaked by a script -- if\nthey're paying to B, A just holds the same timelocked presigned tx's as\nfor PTLCs; if they're paying to A, A will use a \"HASH160 X EQUALVERIFY\nA CHECKSIGVERIFY delay CSV\" script path instead.\n\nB has a similar commitment Tx; and A holds pre-signed tx's for the\nPTLC's there, except without the relative timelock txs.\n\nThis adds up to B needing to provide A with signatures for:\n\n  the funding tx\n  A's balance\n  each PTLC/HTLC paying/refunding to A from A's commitment and the sub tx for each of those\n  each PTLC/HTLC paying/refunding to B from B's commitment\n\nand each of those signatures need to be updated every commitment update.\n\nNote that you need to receive all the partial signatures to spend the\ncommitment tx before you provide your partial signature over the funding\ntx to authorise the commitment tx. So yet more rounds of communication.\n\nI think this approach would let you upgrade existing channels to support\nPTLCs without closing/reopening, though.\n\n\n\nI think you could do something eltoo-ish to simplify watchtowers:\n\n    Funding TX output: MuSig(A,B)\n\n    Commitment Tx Held by A:\n      - locktime: obscured commitment number\n      - inputs: funding tx\n      - outputs: MuSig(Rn,B)\n\n    Settlement Tx Held by A:\n      - nsequence: to_self_delay\n      - input: commitment tx held by A\n      - outputs:\n         balance A\n\t balance B\n\t PTLC paying to A\n\t PTLC paying to B\n\n    Secondary Settlement Tx Held by B:\n      - no abs/relative locktime\n      - input: commitment tx held by A\n      - outputs:\n         balance A\n\t balance B\n\t PTLC paying to A\n\t PTLC paying to B\n\nin which case once the commitment is revoked, B only needs to do a single\nsignature of MuSig(Rn,B) to claim all the funds if A publishes the\nold commitment, without having to worry about any HTLC/PTLC info? The\nsettlement tx can be a bit simplified I think too. Maybe the edge case\nwhen the absolute locktime is close to the relative locktime makes this\npainful, though I think it would make eltoo painful then too? Not sure\nif I'm missing something here. \n\n(Note that this gives symmetric delays: if A unilaterally closes the\nchannel by publishing the commitment tx, and B wants their funds, B can\neither immediately claim all the funds via the revocation secret if A\nwas cheating, or has to publish the settlement tx first, at which point\nA can get all A's funds immediately as well)\n\n> Revocable Outputs and PTLCs\n> ---------------------------\n> * No wallet uses relative-timelock for ordinary spends, unlike abolute-locktime where Bitcoin Core always uses absolute-locktime `nLockTime` for ordinary spends.\n\nI think the fact lightning relative timelocks will be \"round\" numbers,\nand the timelocked tx will be published as soon as possible will make\nit relatively easy to distinguish them from other spends anyway. Doing\nit scriptlessly is cheaper on chain though.\n\nAnyway, my picks are:\n\n - [x] Poon-Dryja PTLCs prior to eltoo\n - [x] scriptless revocation via MuSig(Rn,B) internal keys\n - [x] support HTLCs via taproot\n - [x] (optionally) allow use of script paths to minimise round trip\n       delay\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-17T15:05:17",
                "message_text_only": "Good morning,\n\n> On Sun, Dec 15, 2019 at 03:43:07PM +0000, ZmnSCPxj via Lightning-dev wrote:\n>\n> > For now, I am assuming the continued use of the existing Poon-Dryja update mechanism.\n> > Decker-Russell-Osuntokun requires `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`, and its details seem less settled for now than taproot details.\n>\n> Supporting PTLCs instead of HTLCs is a global upgrade in that you need\n> all nodes along your payment path to support it; moving from Poon-Dryja\n> to Decker-Russell-Osuntokun is only relevant to individual peers. So I\n> think it makes sense to do PTLCs first if the required features aren't\n> both enabled at the same time.\n\nIndeed.\nThe question is then do we upgrade Poon-Dryja to *at least* use a MuSig on mutual close (for the privacy boost of mutual closes), or do we just keep Poon-Dryja as is now, and add PTLCs from them.\n\n>\n> > Poon-Dryja with Schnorr\n> >\n> > ------------------------\n>\n> I think MuSig between the two pairs is always superior to a NUMS point\n> for the taproot internal key; you definitely want to calculate a point\n> rather than use a constant, or you're giving away that it's lightning,\n> and if you're calculating you might as well calculate something that can\n> be used for a cooperative key path spend if you ever want to.\n\nI am uncertain why a NUMS point would be used here, except if you wanted to simulate an explicit 2-of-3 from your explicit 2-of-2, which while interesting is really a foolish idea and I will now lurk forever (for some definition of \"forever\") because of ever suggesting it.\n\n>\n> > A potential issue with MuSig is the increased number of communication rounds needed to generate signatures.\n>\n> I think you can reduce this via an alternative script path. In\n> particular, if you want a script that the other guy can spend if they\n> reveal the discrete log of point X, with musig you do:\n\nNot quite the correct section?\nThis section is discussing the Poon-Dryja updateable mechanism, not the PTLCs, and it is the the \"PTLC\" which requires discrete log of a point.\n\nBut in any case....\n\n>\n> P = H(H(A,B),1)*A + H(H(A,B),2)*B\n> [exchange H(RA),H(RB),RA,RB]\n>\n> [send X]\n>\n> sb = rb + H(RA+RB+X,P,m)*H(H(A,B),2)*b\n>\n> [wait for sb]\n>\n> sa = ra + H(RA+RB+X,P,m)*H(H(A,B),1)*a\n>\n> [store RA+RB+X, sa+sb, supply sa, watch for sig]\n>\n> sig = (RA+RB+X, sa+sb+x)\n>\n> So the 1.5 round trips are \"I want to do a PTLC for X\", \"okay here's\n> sb\", \"great, here's sa\".\n>\n> But with taproot you can have a script path as well, so you could have a\n> script:\n>\n> A CHECKSIGVERIFY B CHECKSIG\n>\n> and supply a partial signature:\n>\n> R+X,s,X where s = r + H(R+X,A,m)*a\n>\n> to allow them to satisfy \"A CHECKSIGVERIFY\" if they know the discrete\n> log of X, and of course they can sign with B at any time. This is only\n> half a round trip, and can be done at the same time as sending the \"I\n> want to do a PTLC for X\" message to setup the (ultimately cheaper) MuSig\n> spend. It's an extra signature on the sender's side and an extra verification\n> on the receiver's side, but I think it works out fine.\n\nAh, so I suppose you are saying that it is possible to create an adaptor signature for what is effectively a 1-of-1 Schnorr pubkey, and that can implement the pointlocked branch?\n\nJust to be clear, in the above:\n\n* A is the payer (and wants to pay if and only if it can learn the payment).\n* B is the payee (and knows the secret).\n\nSo A gives a pointlock condition to the payee by providing an adaptor signature for its pubkey A, which cannot be used to validate, but B can simply add the secret `x` that is the discrete log of `X`.\nAnd since A knows the above adaptor signature which it generated, once the completed signature for A is given by B, A can simply subtract it with the stored adaptor signature to learn the secret.\n\nHowever, we still need a branch for the timelock, and if the output is revocable, some more additional conditions and/or scripts need to be made.\nWe could use the same script for a revocable timelocked transaction going back to A, but A would have to get the signature from B for this revocable timelocked transaction *before* it hands over the adaptor signature (else B can just keep the adaptor signature forever and not claim the funds until its own convenience, possibly beyond the time that the scalar is useful).\nThis may mean adding one more round trip.\n\n>\n> > Pointlocked Timelocked Contracts\n> >\n> > ---------------------------------\n> >\n> > First, I will discuss how to create a certain kind of PTLCs, which I call \"purely scriptless\" PTLCs.\n> > In particular, I would like to point out that we actually use in current Poon-Dryja Lightning Network channels is revocable HTLCs, thus we need to have revocable PTLCs to replace them.\n> >\n> > -   First, we must have a sender A, who is buying a secret scalar, and knows the point equivalent to that scalar.\n> > -   Second, we have a receiver B, who knows this secret scalar (or can somehow learn this secret scalar).\n> > -   A and B agree on the specifications of the PTLC: the point, the future absolute timelock, the value.\n> > -   A creates (but does not sign or broadcast) a transaction that pays to a MuSig of A and B and shares the txid and output number with the relevant MuSig output.\n> > -   A and B create a backout transaction.\n> >     -   This backout has an `nLockTime` equal to the agreed absolute timelock.\n> >     -   It spends the above MuSig output (this input must enable `nLockTime`, e.g. by setting `nSequence` to `0xFFFFFFFE`).\n> >     -   It creates an output that is solely controlled by A.\n> > -   A and B perform a MuSig ritual to sign the backout transaction.\n> > -   A now signs and broadcast the first transaction, the one that has an output that represents the PTLC.\n> > -   A and B wait for the above transaction to confirm deeply.\n> >     This completes the setup phase for the PTLC.\n> >\n> > -   After this point, if the agreed-upon locktime is reached, A broadcasts the backout transaction and aborts the ritual.\n> > -   A and B create a claim transaction.\n> >     -   This has an `nLockTime` of 0, or a present or past blockheight, or disabled `nLockTime`.\n> >     -   This spends the above MuSig output.\n> >     -   This creates an output that is solely controlled by B.\n> > -   A and B generate an adaptor signature for the claim transaction, which reveals the agreed scalar.\n> >     -   This is almost entirely a MuSig ritual, except at `s` exchange, B provides `t + r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` first, then demands `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, A) * a` from A, then reveals `r + h(R | MuSig(A,B) | m) * MuSigTweak(A, B, B) * b` (or the completed signature, by publishing onchain), revealing the secret scalar `t` to A.\n> > -   A is able to learn the secret scalar from the above adaptor signature followed by the full signature, completing the ritual.\n>\n> (I think it makes more sense to provide \"r + H(R+T, P, m)*b\" instead of\n> \"r+t + H(R,P,m)*b\" -- you might not know \"t\" at the point you need to\n> start the signature exchange)\n\nAh, so basically the signature that appears onchain would be `(R + T, r + t + h(R + T | P | m) * p)`?\n\n>\n> I think the setup can be similar to BOLT-3:\n>\n> Funding TX output: MuSig(A,B)\n>\n> Commitment Tx Held by A:\n> - locktime: obscured commitment number\n> - input: funding tx\n> - outputs:\n> balance A\n> balance B\n> PTLC paying to A\n> PTLC paying to B\n> [etc]\n\nJust to be clear, \"PTLC paying to A\" means the pointlock branch pays to A, the timelock branch pays to B, right?\n\n>\n> balance B can pay directly to B\n>\n> balance A pays to MuSig(Rn,B) -- where Rn is the revocation key for the\n> nth commitment, and A holds a presigned tx by B with relative locktime\n> set, paying the funds to A.\n>\n> PTLCs also pay to MuSig(Rn,B) --\n>\n> for the one paying to A, A holds a tx\n> partially presigned by B that needs the point's discrete log added to x\n> with relative timelock; for the one paying to B, A holds a presigned tx\n> by B that has absolute locktime set and pays to MuSig(Rn,B) for which\n> A has another presigned tx by B that has relative locktime set.\n>\n> HTLC's also pay to MuSig(Rn,B) but they're tweaked by a script -- if\n> they're paying to B, A just holds the same timelocked presigned tx's as\n> for PTLCs; if they're paying to A, A will use a \"HASH160 X EQUALVERIFY\n> A CHECKSIGVERIFY delay CSV\" script path instead.\n>\n> B has a similar commitment Tx; and A holds pre-signed tx's for the\n> PTLC's there, except without the relative timelock txs.\n>\n> This adds up to B needing to provide A with signatures for:\n>\n> the funding tx\n> A's balance\n> each PTLC/HTLC paying/refunding to A from A's commitment and the sub tx for each of those\n> each PTLC/HTLC paying/refunding to B from B's commitment\n>\n> and each of those signatures need to be updated every commitment update.\n>\n> Note that you need to receive all the partial signatures to spend the\n> commitment tx before you provide your partial signature over the funding\n> tx to authorise the commitment tx. So yet more rounds of communication.\n\nYes, this looks like it needs some more fleshing out.\n\n>\n> I think this approach would let you upgrade existing channels to support\n> PTLCs without closing/reopening, though.\n\nI believe so as well, as of course the base layer allows transactions to have a mix of SegWit v0 (HTLCs) and SegWit v1 (PTLCs) outputs.\n\n>\n> I think you could do something eltoo-ish to simplify watchtowers:\n>\n> Funding TX output: MuSig(A,B)\n>\n> Commitment Tx Held by A:\n> - locktime: obscured commitment number\n> - inputs: funding tx\n> - outputs: MuSig(Rn,B)\n>\n> Settlement Tx Held by A:\n> - nsequence: to_self_delay\n> - input: commitment tx held by A\n> - outputs:\n> balance A\n> balance B\n> PTLC paying to A\n> PTLC paying to B\n>\n> Secondary Settlement Tx Held by B:\n> - no abs/relative locktime\n> - input: commitment tx held by A\n> - outputs:\n> balance A\n> balance B\n> PTLC paying to A\n> PTLC paying to B\n>\n> in which case once the commitment is revoked, B only needs to do a single\n> signature of MuSig(Rn,B) to claim all the funds if A publishes the\n> old commitment, without having to worry about any HTLC/PTLC info? The\n> settlement tx can be a bit simplified I think too. Maybe the edge case\n> when the absolute locktime is close to the relative locktime makes this\n> painful, though I think it would make eltoo painful then too? Not sure\n> if I'm missing something here.\n\nIndeed, having the relative locktime affect the absolute locktime is a pain, and I hope to have moved away from pathfinding before Decker-Russell-Osuntokun arrives and makes it a headache to find paths.\nThe issue is that the relative locktime for Decker-Russell-Osuntokun must be combined over each step of the route via the \"max\" function instead of the \"`+`\" function, and all existing pathfinding algos assume costs are combined via \"`+`\".\nI suppose this is doable by annotating each node with the current max-csv, and if the node under evaluation has a higher csv  requirement than the max-csv of the node it is arriving from, treat that edge as having a higher cost, but bleah.\n\n>\n> (Note that this gives symmetric delays: if A unilaterally closes the\n> channel by publishing the commitment tx, and B wants their funds, B can\n> either immediately claim all the funds via the revocation secret if A\n> was cheating, or has to publish the settlement tx first, at which point\n> A can get all A's funds immediately as well)\n>\n> > Revocable Outputs and PTLCs\n> >\n> > ----------------------------\n> >\n> > -   No wallet uses relative-timelock for ordinary spends, unlike abolute-locktime where Bitcoin Core always uses absolute-locktime `nLockTime` for ordinary spends.\n>\n> I think the fact lightning relative timelocks will be \"round\" numbers,\n> and the timelocked tx will be published as soon as possible will make\n> it relatively easy to distinguish them from other spends anyway. Doing\n> it scriptlessly is cheaper on chain though.\n>\n> Anyway, my picks are:\n>\n> -   [x] Poon-Dryja PTLCs prior to eltoo\n> -   [x] scriptless revocation via MuSig(Rn,B) internal keys\n> -   [x] support HTLCs via taproot\n> -   [x] (optionally) allow use of script paths to minimise round trip\n>     delay\n>\n>     Cheers,\n>     aj\n>\n\nThank you for your considered opinion as well as the new adaptor constructions.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-12-18T03:51:56",
                "message_text_only": "Hi ZmnSCPxj and Aj,\n\nThanks for starting this discussion ZmnSCPxj. Although transactions with\nrelative lock times are easily distinguishable today, couldn't this\nsituation be improved? Even just a few wallets changing their behaviour to\nset relative time locks on normal payments would weaken the heuristic. From\na design perspective it feels like leaving the improvement vector open\nwould be better.\n\nAj's model of scriptless lightning is more or less what I had in my mind\n(but with much better detail). On the question of \"script based payment\npoints\" or \"fully scriptless\": Why not just do both?\n\nSince the tapscript version is faster to the \"irrevocably committed\" state,\nyou first do that so you can forward the payment as fast as possible. Now\nthat both parties have a commitment tx with a tapscript PTLC, they can (in\nno hurry) sign the scriptless spending transactions from the PTLC output. I\nthink once they have signatures on their scriptless PTLC transactions they\ncan forget all the tapscript data (to minimize the data they have to store\nper commitment tx).\n\n> But with taproot you can have a script path as well, so you could have a\n> script:\n\n>    A CHECKSIGVERIFY B CHECKSIG\n\n> and supply a partial signature:\n\n>    R+X,s,X where s = r + H(R+X,A,m)*a\n\n> to allow them to satisfy \"A CHECKSIGVERIFY\" if they know the discrete\n> log of X, and of course they can sign with B at any time. This is only\n> half a round trip, and can be done at the same time as sending the \"I\n> want to do a PTLC for X\" message to setup the (ultimately cheaper) MuSig\n> spend. It's an extra signature on the sender's side and an extra\nverification\n> on the receiver's side, but I think it works out fine.\n\nThis is exactly how I thought the \"script based payment point\" would work\nwhere you just replace the hashing with an CHECKSIG and an adaptor sig.\nLike Z, I don't see how you can get away with just that though. I think you\nneed to do a full tapscript PTLC and revocation (1.5 round trips) before\nyou can forward a payment.\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191218/b966b7d5/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning in a Taproot future",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Anthony Towns",
                "Matt Corallo",
                "Lloyd Fournier"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 66263
        }
    },
    {
        "title": "[Lightning-dev] Pay-to-Open and UX improvements",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-12-17T08:34:07",
                "message_text_only": "Good morning list,\n\nAs everyone who has ever used a Lightning wallet is well aware, the\nonboarding process could be\nmade smoother. With Phoenix [1], we've been experimenting with pay-to-open\n[2].\n\nThat works well in practice and provides a great UX for newcomers, but it\nrequires temporary trust\nbetween the user and our node (until the funding tx confirms).\n\nThat trust relationship appears in two places:\n\na. The user releases the preimage, then we fund the channel [2]\nb. The user trusts that we won't double-spend the funding transaction\n\nWe currently need (a) because we can't ensure that the user will reveal the\npreimage once we've\nfunded the channel.\n\nIt's (somewhat) easy to fix that once Bitcoin supports Schnorr.\nLet's assume that we're using PTLCs (where the secret is a private key) and\nMuSig for channel\nfunding transactions.\nWhen Alice receives a PTLC to forward to Bob, if she doesn't have a channel\nto Bob and Bob supports\npay-to-open, she can initiate a tweaked channel opening flow. She can use\ntlv extensions in the\n`open_channel` message to tell Bob that this channel is linked to a PTLC\nwith point `X=x*G`.\nBob will tweak the MuSig nonce with `X` and provide Alice with a partial\nsignature for that nonce.\nWhen Bob then provides the adaptor signature to finalize the funding\ntransaction, it reveals `x` to\nAlice who can now fulfill the PTLC downstream.\n\nNote that in this simple version, Alice knows the nonce tweak beforehand.\nThis may (or may not,\nthat will need to be investigated thoroughly) be a security issue.\nEven if it turns out to be an issue, I'm pretty sure we can find a secure\nprotocol that will allow\nthis atomicity (let's just add another round of communication, that's\nusually how we fix broken\ncryptographic protocols).\n\nI'm more concerned about fixing (b). As long as the funding transaction is\nunconfirmed, there's a\nrisk of double-spending by the funder. I'm shamelessly trying to use this\nmailing list's brainpower\nto figure out possible solutions for that. Does someone have ideas that\ncould help? Can we setup\nthe incentives so that it's never rational for the funder to double-spend?\n\nCheers,\nBastien\n\n[1] https://phoenix.acinq.co/\n[2] https://medium.com/@ACINQ/phoenix-part-2-pay-to-open-4a8a482dd4d\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191217/9529e2b6/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-17T09:31:56",
                "message_text_only": "Good morning t-bast,\n\n> Good morning list,\n>\n> As everyone who has ever used a Lightning wallet is well aware, the onboarding process could be\n> made smoother. With Phoenix [1], we've been experimenting with pay-to-open [2].\n>\n> That works well in practice and provides a great UX for newcomers, but it requires temporary trust\n> between the user and our node (until the funding tx confirms).\n>\n> That trust relationship appears in two places:\n>\n> a. The user releases the preimage, then we fund the channel [2]\n> b. The user trusts that we won't double-spend the funding transaction\n>\n> We currently need (a) because we can't ensure that the user will reveal the preimage once we've\n> funded the channel.\n>\n> It's (somewhat) easy to fix that once Bitcoin supports Schnorr.\n> Let's assume that we're using PTLCs (where the secret is a private key) and MuSig for channel\n> funding transactions.\n> When Alice receives a PTLC to forward to Bob, if she doesn't have a channel to Bob and Bob supports\n> pay-to-open, she can initiate a tweaked channel opening flow. She can use tlv extensions in the\n> `open_channel` message to tell Bob that this channel is linked to a PTLC with point `X=x*G`.\n> Bob will tweak the MuSig nonce with `X` and provide Alice with a partial signature for that nonce.\n> When Bob then provides the adaptor signature to finalize the funding transaction, it reveals `x` to\n> Alice who can now fulfill the PTLC downstream.\n>\n> Note that in this simple version, Alice knows the nonce tweak beforehand. This may (or may not,\n> that will need to be investigated thoroughly) be a security issue.\n> Even if it turns out to be an issue, I'm pretty sure we can find a secure protocol that will allow\n> this atomicity (let's just add another round of communication, that's usually how we fix broken\n> cryptographic protocols).\n\nThis can be assured today with HTLC-like constructions, similar to what we use in HTLC-success / HTLC-timeout in BOLT 3.\n\nChannel opening *instead* goes this way:\n\n* Alice receives a payment request to Bob with a specific payment hash.\n* Alice creates a transaction from its onchain funds, paying out to an HTLC-like construction with logic `(hash_preimage && A && B) || (timelock && A)`.\n  * Call this the pre-funding transaction.\n  * Alice does **not** sign and broadcast this *yet*!\n  * The timelock could reuse the same timelock as indicated in the final hop to the incoming payment.\n* Alice gives the txid of the pre-funding to Bob.\n* Alice and Bob create a transaction that spends the above output to the logic `A && B`.\n  * Call this the funding transaction.\n* Alice and Bob create commitment transactions spending the above funding transaction as per usual flow, and exchange signatures, completing up to `funding_signed`.\n  * Have it `push_msat` the payment amount to Bob minus the fee to open.\n* Alice and Bob exchange signatures for funding transaction, spending using the hashlock branch of the pre-funding transaction HTLC.\n* Alice signs and broadcasts the pre-funding transaction.\n* Once the pre-funding is sufficiently confirmed as per Bob security parameter, Bob then broadcasts the funding transaction.\n  * To do so, Bob has to add the preimage to the witness stack in order to make-valid the funding transaction.\n* Alice sees the preimage from the broadcasted funding transaction and can now continue claiming the incoming HTLC.\n\n>\n> I'm more concerned about fixing (b). As long as the funding transaction is unconfirmed, there's a\n> risk of double-spending by the funder. I'm shamelessly trying to use this mailing list's brainpower\n> to figure out possible solutions for that. Does someone have ideas that could help? Can we setup\n> the incentives so that it's never rational for the funder to double-spend?\n\nAbove procedure probably fixes this as well?\nIt sets things up so that the funder cannot double-spend the funds that will eventually get into the channel after it is capable of receiving the preimage.\nFunder can double-spend, but then is unable to learn the preimage and cannot steal the payment (and is indistinguishable from any other payment failure).\n\nThe above procedure makes Alice vulnerable to Bob aborting after the pre-funding is confirmed, thus onchain fees are paid by Alice to pay for the pre-funding and the timelock branch.\nThis can be fixed by forcing Bob to provide funds to the pre-funding, which get returned to the channel on Bob side, and having the timelock branch be `(A && B && timelock)` and pre-signing a backout that returns the funds back to Alice and Bob, with Bob paying all onchain fee, but I believe the desired use-case here is when Bob has absolutely 0 millisatoshi...?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-12-17T10:23:14",
                "message_text_only": "Hi ZmnSCPxj,\n\nThanks for your response.\n\n* Once the pre-funding is sufficiently confirmed as per Bob security\n> parameter\n>\n\nThis is the part I'm trying to avoid. If we're ok with waiting for\nconfirmation, then it's easy to do indeed (and let's just wait for the\nfunding tx to confirm, I believe we don't even need that pre-funding step).\nBut if we have to wait for confirmations we're hodling the incoming HTLC\nfor a few blocks, which I'd like to avoid.\n\nDo you have a smart construction that would allow us to build safely on\nthat unconfirmed transaction?\nIs there maybe a smart trick that would allow us the pay-to-open server to\nprovably lock some UTXO in advance to prevent\nitself from double-spending them?\n\nCheers,\nBastien\n\n\n\nLe mar. 17 d\u00e9c. 2019 \u00e0 10:31, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n>\n> Good morning t-bast,\n>\n> > Good morning list,\n> >\n> > As everyone who has ever used a Lightning wallet is well aware, the\n> onboarding process could be\n> > made smoother. With Phoenix [1], we've been experimenting with\n> pay-to-open [2].\n> >\n> > That works well in practice and provides a great UX for newcomers, but\n> it requires temporary trust\n> > between the user and our node (until the funding tx confirms).\n> >\n> > That trust relationship appears in two places:\n> >\n> > a. The user releases the preimage, then we fund the channel [2]\n> > b. The user trusts that we won't double-spend the funding transaction\n> >\n> > We currently need (a) because we can't ensure that the user will reveal\n> the preimage once we've\n> > funded the channel.\n> >\n> > It's (somewhat) easy to fix that once Bitcoin supports Schnorr.\n> > Let's assume that we're using PTLCs (where the secret is a private key)\n> and MuSig for channel\n> > funding transactions.\n> > When Alice receives a PTLC to forward to Bob, if she doesn't have a\n> channel to Bob and Bob supports\n> > pay-to-open, she can initiate a tweaked channel opening flow. She can\n> use tlv extensions in the\n> > `open_channel` message to tell Bob that this channel is linked to a PTLC\n> with point `X=x*G`.\n> > Bob will tweak the MuSig nonce with `X` and provide Alice with a partial\n> signature for that nonce.\n> > When Bob then provides the adaptor signature to finalize the funding\n> transaction, it reveals `x` to\n> > Alice who can now fulfill the PTLC downstream.\n> >\n> > Note that in this simple version, Alice knows the nonce tweak\n> beforehand. This may (or may not,\n> > that will need to be investigated thoroughly) be a security issue.\n> > Even if it turns out to be an issue, I'm pretty sure we can find a\n> secure protocol that will allow\n> > this atomicity (let's just add another round of communication, that's\n> usually how we fix broken\n> > cryptographic protocols).\n>\n> This can be assured today with HTLC-like constructions, similar to what we\n> use in HTLC-success / HTLC-timeout in BOLT 3.\n>\n> Channel opening *instead* goes this way:\n>\n> * Alice receives a payment request to Bob with a specific payment hash.\n> * Alice creates a transaction from its onchain funds, paying out to an\n> HTLC-like construction with logic `(hash_preimage && A && B) || (timelock\n> && A)`.\n>   * Call this the pre-funding transaction.\n>   * Alice does **not** sign and broadcast this *yet*!\n>   * The timelock could reuse the same timelock as indicated in the final\n> hop to the incoming payment.\n> * Alice gives the txid of the pre-funding to Bob.\n> * Alice and Bob create a transaction that spends the above output to the\n> logic `A && B`.\n>   * Call this the funding transaction.\n> * Alice and Bob create commitment transactions spending the above funding\n> transaction as per usual flow, and exchange signatures, completing up to\n> `funding_signed`.\n>   * Have it `push_msat` the payment amount to Bob minus the fee to open.\n> * Alice and Bob exchange signatures for funding transaction, spending\n> using the hashlock branch of the pre-funding transaction HTLC.\n> * Alice signs and broadcasts the pre-funding transaction.\n> * Once the pre-funding is sufficiently confirmed as per Bob security\n> parameter, Bob then broadcasts the funding transaction.\n>   * To do so, Bob has to add the preimage to the witness stack in order to\n> make-valid the funding transaction.\n> * Alice sees the preimage from the broadcasted funding transaction and can\n> now continue claiming the incoming HTLC.\n>\n> >\n> > I'm more concerned about fixing (b). As long as the funding transaction\n> is unconfirmed, there's a\n> > risk of double-spending by the funder. I'm shamelessly trying to use\n> this mailing list's brainpower\n> > to figure out possible solutions for that. Does someone have ideas that\n> could help? Can we setup\n> > the incentives so that it's never rational for the funder to\n> double-spend?\n>\n> Above procedure probably fixes this as well?\n> It sets things up so that the funder cannot double-spend the funds that\n> will eventually get into the channel after it is capable of receiving the\n> preimage.\n> Funder can double-spend, but then is unable to learn the preimage and\n> cannot steal the payment (and is indistinguishable from any other payment\n> failure).\n>\n> The above procedure makes Alice vulnerable to Bob aborting after the\n> pre-funding is confirmed, thus onchain fees are paid by Alice to pay for\n> the pre-funding and the timelock branch.\n> This can be fixed by forcing Bob to provide funds to the pre-funding,\n> which get returned to the channel on Bob side, and having the timelock\n> branch be `(A && B && timelock)` and pre-signing a backout that returns the\n> funds back to Alice and Bob, with Bob paying all onchain fee, but I believe\n> the desired use-case here is when Bob has absolutely 0 millisatoshi...?\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191217/91c9c1b1/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-17T12:51:18",
                "message_text_only": "Good morning t-bast,\n\n>\n> Thanks for your response.\n>\n> > * Once the pre-funding is sufficiently confirmed as per Bob security parameter\n>\n> This is the part I'm trying to avoid. If we're ok with waiting for confirmation, then it's easy to do indeed (and let's just wait for the\n> funding tx to confirm, I believe we don't even need that pre-funding step).\n> But if we have to wait for confirmations we're hodling\u00a0the incoming HTLC for a\u00a0few blocks, which I'd like to avoid.\n>\n> Do you have a smart construction that would allow us to build safely on that unconfirmed transaction?\n> Is there maybe a smart trick that would allow us the pay-to-open server to provably lock some UTXO in advance to prevent\n> itself from double-spending them?\n\nUnconfirmed transactions are only safe / trustless if they cannot be replaced.\nhttps://zmnscpxj.github.io/offchain/safety.html\n\nIn offchain techniques, we ensure that pre-agreed offchain transactions cannot be replaced by requiring that all participants agree (n-of-n).\nWith an n-of-n, replacement transactions are only possible if you cooperate in the attempt to steal from you, and thus no different from you voluntarily donating your funds to them anyway.\n\nSo you need to pre-prepare some already-confirmed UTXOs that are 2-of-2 between you and the client.\nOf course, such 2-of-2 would *already* be channels themselves.\n\nConversely, if you *do* find a solution to this problem, then that can be made an anchor / funding transaction output for a channel, and we would implement it directly into Lightning to remove the channel-opening confirmation delay.\n\nGiven that there has been a lot of thinking regarding channel mechanisms, from the original broken Satoshi `nSequence` to Spilman to modern mechanisms like Decker-Wattenhofer, Poon-Dryja, and Decker-Russell-Osuntokun, all of which are still vulnerable to double-spending if you do not confirm the funding transaction deeply, it seems to me unlikely that such a technology could be derived.\n\nWith current known cryptographic mechanisms, even if you consider that maybe you could pre-confirm some UTXOs that you can then subsequently allocate to clients immediately while ensuring that those UTXOs can only be spent in cooperation with the client, you need to somehow learn some public key before a client generates a private key for it, without knowing the private key yourself (or somehow be able to demonstrate that you can no longer access the private key).\nAnd if the client already gives you a pubkey, that is basically just you opening channels to them as soon as they arrive, and requires confirmation anyway.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2019-12-17T14:43:46",
                "message_text_only": "On Tue, Dec 17, 2019 at 09:34:07AM +0100, Bastien TEINTURIER wrote:\n> With Phoenix [1], we've been experimenting with pay-to-open [2].\n>\n> That works well in practice and provides a great UX for newcomers, but\n> it requires temporary trust between the user and our node (until the\n> funding tx confirms).\n> \n> That trust relationship appears in two places:\n> [...]\n> b. The user trusts that we won't double-spend the funding transaction\n> [...] \n> I'm more concerned about fixing (b). As long as the funding\n> transaction is unconfirmed, there's a risk of double-spending by the\n> funder. \n\nThe typical proposed solution for this type of problem is a single-show\nsignature[1], a signature that will reveal the private key used to\ncreate it if it's combined with another signature from the same private\nkey.  In other words, if you sign two different spends of the same UTXO,\nsomeone who see both spends will be able to redirect all of that UTXO's\nvalue to themselves.  In that case, your change output becomes a form of\nfidelity bond---you get to keep it if you act honestly; otherwise,\nsomeone else gets it (most likely whoever mines the next block).\n\nI'm not aware of any way to currently force single-show signatures in\nBitcoin, so this is pretty theoretical.  Also, single-show signatures\nadd a lot of fragility to any setup and make useful features like RBF\nfee bumping unavailable.\n\nAs a less complete but more practical solution, you might want to\nconsider a signing federation.  This doesn't change the need for trust,\nbut it does allow spreading that trust around.  E.g. if spending your\nfunds requires three signatures each from one of five different\nrespected companies helping pioneer LN (perhaps all in different legal\njurisdictions), that might help mitigate user concerns about double\nspending.  Besides the extra communicating and signing, your existing\nworkflow wouldn't need to change. \n\n-Dave\n\n[1] Here's some math for single show signatures in ECDSA:\n\n        https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-December/007038.html\n\n    Probably a more practical way to enforce single-show in Bitcoin\n    would be something like OP_CHECKSIGFROMSTACK, e.g. as implemented in\n    Elements:\n\n        https://elementsproject.org/features/opcodes\n\n    Maybe SIGHASH_NOINPUT/SIGHASH_ANYPREVOUT could also be used to\n    enforce single-show with the right script?  I'm not so sure about\n    that.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191217/dcd8987d/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-17T15:14:50",
                "message_text_only": "Good morning David, t-bast, and all,\n\n\n> I'm not aware of any way to currently force single-show signatures in\n> Bitcoin, so this is pretty theoretical. Also, single-show signatures\n> add a lot of fragility to any setup and make useful features like RBF\n> fee bumping unavailable.\n\nWith `OP_CAT`, we can enforce that a particular `R` is used, which allows to implement single-show signatures.\n\n    # Assuming signatures are the concatenation of (R,s)\n    <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n\nThe above would then feed `s` only on the witness stack.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-12-17T16:01:01",
                "message_text_only": "Thanks a lot David for the suggestion and pointers, that's a really\ninteresting solution.\nI will dive into that in-depth, it could be very useful for many layer-2\nconstructions.\n\nThanks ZmnSCPxj as well for the quick feedback and the `OP_CAT`\nconstruction,\na lot of cool tricks coming up once (if?) we have such tools in the future\n;)\n\nLe mar. 17 d\u00e9c. 2019 \u00e0 16:14, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning David, t-bast, and all,\n>\n>\n> > I'm not aware of any way to currently force single-show signatures in\n> > Bitcoin, so this is pretty theoretical. Also, single-show signatures\n> > add a lot of fragility to any setup and make useful features like RBF\n> > fee bumping unavailable.\n>\n> With `OP_CAT`, we can enforce that a particular `R` is used, which allows\n> to implement single-show signatures.\n>\n>     # Assuming signatures are the concatenation of (R,s)\n>     <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n>\n> The above would then feed `s` only on the witness stack.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191217/b717706a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-17T16:27:00",
                "message_text_only": "Good morning t-bast,\n\nFurther, we can enforce that RBF is signalled for every spend of the output by:\n\n    <0> OP_CHECKSEQUENCEVERIFY OP_DROP <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n\nRequiring that RBF is signalled gives a little more assurance.\nSuppose ACINQ becomes evil and double-spends the output.\nThe transaction that is posted in the mempool must be marked by RBF due to the `OP_CHECKSEQUENCEVERIFY` opcode, since `nSequence` also doubles as RBF opt-in.\nThen anyone who notices the double-spend can RBF the double-spending transaction to themselves rather than ACINQ.\nThis also further publishes ACINQ private key, until the winning transaction has an `OP_RETURN` output that pays the entire value as fees and nobody can RBF it further.\n\nThis is a minor increase in the assurability of the construction, by making any output that is double-spent directly revocable in favor of the miners.\nAgain, it requires `OP_CAT`, which is a very dangerous opcode, allowing such powerful constructions.\n\nRegards,\nZmnSCPxj\n\n\n> Thanks a lot David for the suggestion and pointers, that's a really interesting solution.\n> I will dive into that in-depth, it could be very useful for many layer-2 constructions.\n>\n> Thanks ZmnSCPxj as well for the quick feedback and the `OP_CAT` construction,\n> a lot of cool tricks\u00a0coming up once (if?) we have such tools in the future ;)\n>\n> Le\u00a0mar. 17 d\u00e9c. 2019 \u00e0\u00a016:14, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit\u00a0:\n>\n> > Good morning David, t-bast, and all,\n> >\n> > > I'm not aware of any way to currently force single-show signatures in\n> > > Bitcoin, so this is pretty theoretical. Also, single-show signatures\n> > > add a lot of fragility to any setup and make useful features like RBF\n> > > fee bumping unavailable.\n> >\n> > With `OP_CAT`, we can enforce that a particular `R` is used, which allows to implement single-show signatures.\n> >\n> > \u00a0 \u00a0 # Assuming signatures are the concatenation of (R,s)\n> > \u00a0 \u00a0 <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n> >\n> > The above would then feed `s` only on the witness stack.\n> >\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Ethan Heilman",
                "date": "2019-12-17T21:07:24",
                "message_text_only": ">From where I'm sitting the fact that OP_CAT allows people to build\nmore powerful constructions in Bitcoin without introducing additional\ncomplexity at the consensus layer is a positive not a negative. Using\nOP_CAT or OP_SUBSTRING to enforce ECDSA nonce reuse is a very powerful\nprotocol tool for enforcing fairness in layer two protocols.\n\nOn Tue, Dec 17, 2019 at 11:27 AM ZmnSCPxj via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> Good morning t-bast,\n>\n> Further, we can enforce that RBF is signalled for every spend of the output by:\n>\n>     <0> OP_CHECKSEQUENCEVERIFY OP_DROP <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n>\n> Requiring that RBF is signalled gives a little more assurance.\n> Suppose ACINQ becomes evil and double-spends the output.\n> The transaction that is posted in the mempool must be marked by RBF due to the `OP_CHECKSEQUENCEVERIFY` opcode, since `nSequence` also doubles as RBF opt-in.\n> Then anyone who notices the double-spend can RBF the double-spending transaction to themselves rather than ACINQ.\n> This also further publishes ACINQ private key, until the winning transaction has an `OP_RETURN` output that pays the entire value as fees and nobody can RBF it further.\n>\n> This is a minor increase in the assurability of the construction, by making any output that is double-spent directly revocable in favor of the miners.\n> Again, it requires `OP_CAT`, which is a very dangerous opcode, allowing such powerful constructions.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> > Thanks a lot David for the suggestion and pointers, that's a really interesting solution.\n> > I will dive into that in-depth, it could be very useful for many layer-2 constructions.\n> >\n> > Thanks ZmnSCPxj as well for the quick feedback and the `OP_CAT` construction,\n> > a lot of cool tricks coming up once (if?) we have such tools in the future ;)\n> >\n> > Le mar. 17 d\u00e9c. 2019 \u00e0 16:14, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n> >\n> > > Good morning David, t-bast, and all,\n> > >\n> > > > I'm not aware of any way to currently force single-show signatures in\n> > > > Bitcoin, so this is pretty theoretical. Also, single-show signatures\n> > > > add a lot of fragility to any setup and make useful features like RBF\n> > > > fee bumping unavailable.\n> > >\n> > > With `OP_CAT`, we can enforce that a particular `R` is used, which allows to implement single-show signatures.\n> > >\n> > >     # Assuming signatures are the concatenation of (R,s)\n> > >     <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n> > >\n> > > The above would then feed `s` only on the witness stack.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Antoine Riard",
                "date": "2019-12-18T04:49:35",
                "message_text_only": "Hi Bastien,\n\nThe use case you're describing strikes me as similar to a slashing protocol\nfor a LN node and a watchtower, i.e punishing\na lazy watchtower for not broadcasting a penalty tx on remote revoked\nstate. In both case you want \"if A don't do X\nunlock some funds for B\".\n\nHere a rough slashing protocol I've sketched out to someone else off-list,\nit may work for you use case if you replace the penalty tx\nby the funding transaction as a way for the trusted channel funder to clear\nhis liability. Though you will need onchain interactivity\nbefore the fact but you may be able to reuse slashing outpoint for multiple\nchannel funding.\n\nSlashing Protocol\n----------------------\n\nAlice and Bob lock fund in channel outpoint X. They issue commitment tx N.\nWill the accountable watchtower locks fund\nin a 2-of-2 slashing outpoint Y with Bob the client.\n\nWhen Alice and Bob update channels to N', Bob and Will use some output from\ncommitment N (like upcoming anchor output)\nto create an accountable tx M. M is paying to Bob after timelock+Bob sig or\nis paying to transaction success_penalty P\nwith Will sig + Bob sig. Success_penalty P will have 2 inputs, one from M\nand from J the justice tx than Bob has given\nto Will. J is spending Alice's revoked commitment N.\n\nSo this slashing protocol should avoid Bob making false claim, because you\nneed a revoked broadcast to enable the claim\nand at same time we use a justice tx output as a proof than Will have done\nits monitoring+punishment job. Will shouldn't\nlearn commitment balance if there is no channel breach and Alice and Bob\nwouldn't be able to collude against Will, if\nwatchtower have a penalty tx on Alice non-revoked commitment tx, that's her\nconcern.\n\nSo topology would be:\n\n                                                       to_Bob\n                                                     /\n          X  <---------- N   <--------- J\n                                ^                   ^\n                                   \\                   \\\n            Y <---------------  M  <---------- P - to_Will\n                                       \\\n                                        to_Bob\n\n\nMain idea of the protocol is to use transactions topology of a first\ncontract as proofs for a subsidiary contract.\n\nI'm quite sure it's insecure, just quick ideas, any thoughts ?\n\n(but would be really cool to have one accountable protocol to both\nwatchtower and pay-to-open use cases to save\nengineering costs)\n\nCheers,\n\nAntoine\n\n\nLe mar. 17 d\u00e9c. 2019 \u00e0 16:08, Ethan Heilman <eth3rs at gmail.com> a \u00e9crit :\n\n> From where I'm sitting the fact that OP_CAT allows people to build\n> more powerful constructions in Bitcoin without introducing additional\n> complexity at the consensus layer is a positive not a negative. Using\n> OP_CAT or OP_SUBSTRING to enforce ECDSA nonce reuse is a very powerful\n> protocol tool for enforcing fairness in layer two protocols.\n>\n> On Tue, Dec 17, 2019 at 11:27 AM ZmnSCPxj via Lightning-dev\n> <lightning-dev at lists.linuxfoundation.org> wrote:\n> >\n> > Good morning t-bast,\n> >\n> > Further, we can enforce that RBF is signalled for every spend of the\n> output by:\n> >\n> >     <0> OP_CHECKSEQUENCEVERIFY OP_DROP <R> OP_SWAP OP_CAT <ACINQ>\n> OP_CHECKSIG\n> >\n> > Requiring that RBF is signalled gives a little more assurance.\n> > Suppose ACINQ becomes evil and double-spends the output.\n> > The transaction that is posted in the mempool must be marked by RBF due\n> to the `OP_CHECKSEQUENCEVERIFY` opcode, since `nSequence` also doubles as\n> RBF opt-in.\n> > Then anyone who notices the double-spend can RBF the double-spending\n> transaction to themselves rather than ACINQ.\n> > This also further publishes ACINQ private key, until the winning\n> transaction has an `OP_RETURN` output that pays the entire value as fees\n> and nobody can RBF it further.\n> >\n> > This is a minor increase in the assurability of the construction, by\n> making any output that is double-spent directly revocable in favor of the\n> miners.\n> > Again, it requires `OP_CAT`, which is a very dangerous opcode, allowing\n> such powerful constructions.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> >\n> > > Thanks a lot David for the suggestion and pointers, that's a really\n> interesting solution.\n> > > I will dive into that in-depth, it could be very useful for many\n> layer-2 constructions.\n> > >\n> > > Thanks ZmnSCPxj as well for the quick feedback and the `OP_CAT`\n> construction,\n> > > a lot of cool tricks coming up once (if?) we have such tools in the\n> future ;)\n> > >\n> > > Le mar. 17 d\u00e9c. 2019 \u00e0 16:14, ZmnSCPxj <ZmnSCPxj at protonmail.com> a\n> \u00e9crit :\n> > >\n> > > > Good morning David, t-bast, and all,\n> > > >\n> > > > > I'm not aware of any way to currently force single-show signatures\n> in\n> > > > > Bitcoin, so this is pretty theoretical. Also, single-show\n> signatures\n> > > > > add a lot of fragility to any setup and make useful features like\n> RBF\n> > > > > fee bumping unavailable.\n> > > >\n> > > > With `OP_CAT`, we can enforce that a particular `R` is used, which\n> allows to implement single-show signatures.\n> > > >\n> > > >     # Assuming signatures are the concatenation of (R,s)\n> > > >     <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n> > > >\n> > > > The above would then feed `s` only on the witness stack.\n> > > >\n> > > > Regards,\n> > > > ZmnSCPxj\n> >\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191217/52ad7f11/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-12-18T10:14:38",
                "message_text_only": "Good morning list,\n\nThanks again for all the good suggestions, this is awesome.\nDavid and ZmnSCPxj's proposals got me thinking (and I still need to dive\ninto\nAntoine's suggestion as well), and I may have found a very interesting\nconstruction. It's either great or completely dumb. I hope you can help me\nfigure out which of the two it's going to be.\n\nThe core idea is to modify Tapscript's `OP_CHECKSIG`. Instead of reading the\nsignature as a single 64-bytes stack argument, let's add a small change to\nread\nthe signature as two 32-bytes stack arguments: `R` first then `s`.\nSince Taproot already makes changes to this opcode, adding this small change\nseems to be quite simple and harmless (and this is the right time to propose\nsuch a change as we're still in the Taproot review process).\n\nThis effectively lets us leverage nonce reuse as a feature to prevent double\nspending once a signature has been shared off-chain.\n\nLet's set the scene for this usecase. We have a service provider Patrick\nthat\nwants to offer layer 2 services. Patrick prepares some of his UTXOs to have\nthe\nfollowing spending condition:\n\n* A provably unspendable key-path spend\n* A script-path spend with the following script (and only that script):\nOP_SWAP OP_DUP <R> OP_EQUALVERIFY OP_SWAP <P> OP_CHECKSIG\n* Notes:\n* The script could be more fancy (maybe we want to use hash(R) instead of R\ndirectly) but you get the idea\n* The OP_SWAP are needed because the spending stack will be <P> <R> <s>\n* P is of course different for every UTXO\n\nThis means that Patrick is committing to the nonce he'll be using to spend\nthat\noutput.\n\nNow comes our friend Alice. Patrick wants to open a channel to Alice and\nwants\nto start using this channel without waiting for on-chain confirmation.\nAlice and Patrick build the funding transaction as usual; once Alice sees\nthe\ntransaction in the mempool, she can verify that the inputs have the right\nformat.\nNow Alice can be sure that Patrick will not double-spend the funding\ntransaction's inputs: if he does, he will be signing a different message\nwith\nthe same nonce. That would allow Alice to extract the private key for `P`\nand\nspend the UTXO to herself. She has nothing to lose there because it's\nPatrick's\nUTXO so she has an incentive to use much higher fees than Patrick.\n\nIt seems to me that this construction can be generalized for many off-chain\nprotocols that don't want to wait for confirmation. I may be overly\noptimistic,\nbut I think this could enable a whole lot of new use-cases and remove many\npain points in Lightning.\n\nThis is only a first draft, and there are things that can be improved. Let's\nlist what comes to mind (you will probably identify other issues):\n\n* Patrick can't use RBF on transactions that spend this kind of UTXO\nbecause it\nwould reveal his private key: that's probably ok in practice (we can add an\noutput for CPFP instead like we're doing for anchor outputs [1])\n* These UTXOs are easy to recognize on-chain once spent, which may indicate\nthat this is spent for an off-chain protocol\n* It would be great to have a way to allow key-path spend, but revoke this\ncapability once the script has been revealed (off-chain): that would allow\nPatrick to encumber all his UTXOs with such a script and only use it when\nneeded for an off-chain scenario (and use normal key-path spend otherwise)\n\nPlease let me know if this is completely broken, completely dumb or worth\nsharing to the bitcoin-dev mailing list to consider including this\n`OP_CHECKSIG`\nchange in the Taproot soft-fork.\n\nCheers,\nBastien\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/688\n\nLe mer. 18 d\u00e9c. 2019 \u00e0 05:49, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n>\n> Hi Bastien,\n>\n> The use case you're describing strikes me as similar to a slashing\nprotocol for a LN node and a watchtower, i.e punishing\n> a lazy watchtower for not broadcasting a penalty tx on remote revoked\nstate. In both case you want \"if A don't do X\n> unlock some funds for B\".\n>\n> Here a rough slashing protocol I've sketched out to someone else\noff-list, it may work for you use case if you replace the penalty tx\n> by the funding transaction as a way for the trusted channel funder to\nclear his liability. Though you will need onchain interactivity\n> before the fact but you may be able to reuse slashing outpoint for\nmultiple channel funding.\n>\n> Slashing Protocol\n> ----------------------\n>\n> Alice and Bob lock fund in channel outpoint X. They issue commitment tx\nN.  Will the accountable watchtower locks fund\n> in a 2-of-2 slashing outpoint Y with Bob the client.\n>\n> When Alice and Bob update channels to N', Bob and Will use some output\nfrom commitment N (like upcoming anchor output)\n> to create an accountable tx M. M is paying to Bob after timelock+Bob sig\nor is paying to transaction success_penalty P\n> with Will sig + Bob sig. Success_penalty P will have 2 inputs, one from M\nand from J the justice tx than Bob has given\n> to Will. J is spending Alice's revoked commitment N.\n>\n> So this slashing protocol should avoid Bob making false claim, because\nyou need a revoked broadcast to enable the claim\n> and at same time we use a justice tx output as a proof than Will have\ndone its monitoring+punishment job. Will shouldn't\n> learn commitment balance if there is no channel breach and Alice and Bob\nwouldn't be able to collude against Will, if\n> watchtower have a penalty tx on Alice non-revoked commitment tx, that's\nher concern.\n>\n> So topology would be:\n>\n>                                                        to_Bob\n>                                                      /\n>           X  <---------- N   <--------- J\n>                                 ^                   ^\n>                                    \\                   \\\n>             Y <---------------  M  <---------- P - to_Will\n>                                        \\\n>                                         to_Bob\n>\n>\n> Main idea of the protocol is to use transactions topology of a first\ncontract as proofs for a subsidiary contract.\n>\n> I'm quite sure it's insecure, just quick ideas, any thoughts ?\n>\n> (but would be really cool to have one accountable protocol to both\nwatchtower and pay-to-open use cases to save\n> engineering costs)\n>\n> Cheers,\n>\n> Antoine\n>\n>\n> Le mar. 17 d\u00e9c. 2019 \u00e0 16:08, Ethan Heilman <eth3rs at gmail.com> a \u00e9crit :\n>>\n>> From where I'm sitting the fact that OP_CAT allows people to build\n>> more powerful constructions in Bitcoin without introducing additional\n>> complexity at the consensus layer is a positive not a negative. Using\n>> OP_CAT or OP_SUBSTRING to enforce ECDSA nonce reuse is a very powerful\n>> protocol tool for enforcing fairness in layer two protocols.\n>>\n>> On Tue, Dec 17, 2019 at 11:27 AM ZmnSCPxj via Lightning-dev\n>> <lightning-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> > Good morning t-bast,\n>> >\n>> > Further, we can enforce that RBF is signalled for every spend of the\noutput by:\n>> >\n>> >     <0> OP_CHECKSEQUENCEVERIFY OP_DROP <R> OP_SWAP OP_CAT <ACINQ>\nOP_CHECKSIG\n>> >\n>> > Requiring that RBF is signalled gives a little more assurance.\n>> > Suppose ACINQ becomes evil and double-spends the output.\n>> > The transaction that is posted in the mempool must be marked by RBF\ndue to the `OP_CHECKSEQUENCEVERIFY` opcode, since `nSequence` also doubles\nas RBF opt-in.\n>> > Then anyone who notices the double-spend can RBF the double-spending\ntransaction to themselves rather than ACINQ.\n>> > This also further publishes ACINQ private key, until the winning\ntransaction has an `OP_RETURN` output that pays the entire value as fees\nand nobody can RBF it further.\n>> >\n>> > This is a minor increase in the assurability of the construction, by\nmaking any output that is double-spent directly revocable in favor of the\nminers.\n>> > Again, it requires `OP_CAT`, which is a very dangerous opcode,\nallowing such powerful constructions.\n>> >\n>> > Regards,\n>> > ZmnSCPxj\n>> >\n>> >\n>> > > Thanks a lot David for the suggestion and pointers, that's a really\ninteresting solution.\n>> > > I will dive into that in-depth, it could be very useful for many\nlayer-2 constructions.\n>> > >\n>> > > Thanks ZmnSCPxj as well for the quick feedback and the `OP_CAT`\nconstruction,\n>> > > a lot of cool tricks coming up once (if?) we have such tools in the\nfuture ;)\n>> > >\n>> > > Le mar. 17 d\u00e9c. 2019 \u00e0 16:14, ZmnSCPxj <ZmnSCPxj at protonmail.com> a\n\u00e9crit :\n>> > >\n>> > > > Good morning David, t-bast, and all,\n>> > > >\n>> > > > > I'm not aware of any way to currently force single-show\nsignatures in\n>> > > > > Bitcoin, so this is pretty theoretical. Also, single-show\nsignatures\n>> > > > > add a lot of fragility to any setup and make useful features\nlike RBF\n>> > > > > fee bumping unavailable.\n>> > > >\n>> > > > With `OP_CAT`, we can enforce that a particular `R` is used, which\nallows to implement single-show signatures.\n>> > > >\n>> > > >     # Assuming signatures are the concatenation of (R,s)\n>> > > >     <R> OP_SWAP OP_CAT <ACINQ> OP_CHECKSIG\n>> > > >\n>> > > > The above would then feed `s` only on the witness stack.\n>> > > >\n>> > > > Regards,\n>> > > > ZmnSCPxj\n>> >\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191218/723025ac/attachment-0001.html>"
            },
            {
                "author": "Ethan Heilman",
                "date": "2019-12-18T14:35:39",
                "message_text_only": ">\n> Responding below\n\nThe core idea is to modify Tapscript's `OP_CHECKSIG`. Instead of reading the\n> signature as a single 64-bytes stack argument, let's add a small change to\n> read\n> the signature as two 32-bytes stack arguments: `R` first then `s`.\n> Since Taproot already makes changes to this opcode, adding this small\n> change\n> seems to be quite simple and harmless (and this is the right time to\n> propose\n> such a change as we're still in the Taproot review process).\n>\n\nI  very much in favor of a mechanism to enable outputs to enforce ECDSA\nnonce reuse.\n\nHowever I would argue against changing the behavior of OP_CHECKSIG. Subtly\nchanging the stack behavior of perhaps the most widely used and complex OP\ncode in Bitcoin is likely to result in bugs in systems that create and sign\ntransactions. Additionally making this new behavior only activate based on\ncontext is even more likely to cause problems.\n\nIt would likely be safer to have this as a new OP code, say\nOP_CHECKSPLITSIG.\n\nAlternatively we could try to get OP_CAT approved. It is a very simple OP\ncode, which is easy to explain, generally useful and allows this feature\nplus allows many other critical features.\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191218/e7a5abd2/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-12-18T15:14:24",
                "message_text_only": "Thanks Ethan, I agree on that.\n\nLet me also share additional feedback I received on #bitcoin-wizards from\ngmaxwell [1]:\n\n* Changing the behavior of OP_CHECKSIG is a no-go because using two stack\narguments\n  instead of one increases the witness size\n* This is better done as a new opcode as you suggest\n* OP_CAT and friends were intentionally left out of Taproot (too general,\nneeds more analysis)\n* But this OP_CHECKSPLITSIG is very constrained so may be ok?\n* It does NOT protect against a finney attack [2]: protocols leveraging\nthat would need to take\n  such attacks into account in the incentive analysis\n* It only protects against a double-spend if you disallow Patrick\nfrom \"emptying\" this UTXO via\n  Lightning before double-spending\n\nI still believe there are good use-cases for this for off-chain protocols,\nso I'll keep fleshing it out.\nI am interested in more feedback about the scheme, potential other attack\nvectors, potential other\nuse-cases, anything you may find relevant to the discussion.\n\nCheers,\nBastien\n\n[1] https://freenode.irclog.whitequark.org/bitcoin-wizards/2019-12-18\n[2] https://bitcoin.stackexchange.com/questions/4942/what-is-a-finney-attack\n\n\nLe mer. 18 d\u00e9c. 2019 \u00e0 15:35, Ethan Heilman <eth3rs at gmail.com> a \u00e9crit :\n\n> Responding below\n>\n> The core idea is to modify Tapscript's `OP_CHECKSIG`. Instead of reading\n>> the\n>> signature as a single 64-bytes stack argument, let's add a small change\n>> to read\n>> the signature as two 32-bytes stack arguments: `R` first then `s`.\n>> Since Taproot already makes changes to this opcode, adding this small\n>> change\n>> seems to be quite simple and harmless (and this is the right time to\n>> propose\n>> such a change as we're still in the Taproot review process).\n>>\n>\n> I  very much in favor of a mechanism to enable outputs to enforce ECDSA\n> nonce reuse.\n>\n> However I would argue against changing the behavior of OP_CHECKSIG. Subtly\n> changing the stack behavior of perhaps the most widely used and complex OP\n> code in Bitcoin is likely to result in bugs in systems that create and sign\n> transactions. Additionally making this new behavior only activate based on\n> context is even more likely to cause problems.\n>\n> It would likely be safer to have this as a new OP code, say\n> OP_CHECKSPLITSIG.\n>\n> Alternatively we could try to get OP_CAT approved. It is a very simple OP\n> code, which is easy to explain, generally useful and allows this feature\n> plus allows many other critical features.\n>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191218/f50736d9/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-19T03:22:18",
                "message_text_only": "Good morning t-bast,\n\n> * A script-path spend with the following script (and only that script):\n> OP_SWAP OP_DUP <R> OP_EQUALVERIFY OP_SWAP <P> OP_CHECKSIG\n\nWhy not this:\n\n    <R> OP_SWAP OP_CHECKSPLITSIG\n\n?\n\nSince `R` is constrained to be fixed anyway, why repeat `R` twice, once in the script and once in the witness stack?\n\nAlso, would we want to support non-`SIGHASH_ALL` sighashes?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-19T06:24:15",
                "message_text_only": "Good morning t-bast,\n\n> > -   A script-path spend with the following script (and only that script):\n> >     OP_SWAP OP_DUP <R> OP_EQUALVERIFY OP_SWAP <P> OP_CHECKSIG\n> >\n>\n> Why not this:\n>\n> <R> OP_SWAP OP_CHECKSPLITSIG\n>\n> ?\n>\n> Since `R` is constrained to be fixed anyway, why repeat `R` twice, once in the script and once in the witness stack?\n\nFor that matter, since we are far more likely to have a constant `R` than a constant `s` maybe you should instead propose that `OP_CHECKSPLITSIG` be given `<s> <R> <P> OP_CHECKSPLITSIG`, so that a fixed-`R` single-show signature is just `<R> <P> OP_CHECKSPLITSIG`.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-12-19T08:29:45",
                "message_text_only": "Good points, these are good optimisations if we propose such a new opcode!\nI'm still pondering whether this will be useful enough or if finney attacks\ncompletely ruin all use-cases...\n\nLe jeu. 19 d\u00e9c. 2019 \u00e0 07:24, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning t-bast,\n>\n> > > -   A script-path spend with the following script (and only that\n> script):\n> > >     OP_SWAP OP_DUP <R> OP_EQUALVERIFY OP_SWAP <P> OP_CHECKSIG\n> > >\n> >\n> > Why not this:\n> >\n> > <R> OP_SWAP OP_CHECKSPLITSIG\n> >\n> > ?\n> >\n> > Since `R` is constrained to be fixed anyway, why repeat `R` twice, once\n> in the script and once in the witness stack?\n>\n> For that matter, since we are far more likely to have a constant `R` than\n> a constant `s` maybe you should instead propose that `OP_CHECKSPLITSIG` be\n> given `<s> <R> <P> OP_CHECKSPLITSIG`, so that a fixed-`R` single-show\n> signature is just `<R> <P> OP_CHECKSPLITSIG`.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191219/ed279223/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-19T10:00:09",
                "message_text_only": "Good morning t-bast,\n\n> Good points, these are good optimisations if we propose such a new opcode!\n> I'm still pondering whether this will be useful enough or if finney attacks completely ruin all use-cases...\n\nIt does indeed seem to ruin all use-cases, and even my suggestion to enforce RBF will not help against the Finney attack specifically, as the second signature broadcasted is the one that is already in a block.\n\nFurther, if the amount in the single-show-signature UTXO being double-spent is greater than the expected block reward, then it may encourage competing miners to instead mine an alternate block at that blockheight instead of building on the block made by the Finney attacker.\nThis is because they already know the privkey for that UTXO and can instead immediately redirect it to an address they control, and earn more from that block that replaces the Finney attacker block rather than builds on top of it.\nAll miners will then compete on that block and the Finney attack is promoted from an attack on a single target to an attack on the entire Bitcoin ecosystem, for much justice and laughter.\nThus, `OP_CAT` is too powerful and must not be enabled!!!\nOh no.\n\nRegards,\nZmnSCPxj\n\n\n>\n> Le\u00a0jeu. 19 d\u00e9c. 2019 \u00e0\u00a007:24, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit\u00a0:\n>\n> > Good morning t-bast,\n> >\n> > > > -\u00a0 \u00a0A script-path spend with the following script (and only that script):\n> > > >\u00a0 \u00a0 \u00a0OP_SWAP OP_DUP <R> OP_EQUALVERIFY OP_SWAP <P> OP_CHECKSIG\n> > > >\n> > >\n> > > Why not this:\n> > >\n> > > <R> OP_SWAP OP_CHECKSPLITSIG\n> > >\n> > > ?\n> > >\n> > > Since `R` is constrained to be fixed anyway, why repeat `R` twice, once in the script and once in the witness stack?\n> >\n> > For that matter, since we are far more likely to have a constant `R` than a constant `s` maybe you should instead propose that `OP_CHECKSPLITSIG` be given `<s> <R> <P> OP_CHECKSPLITSIG`, so that a fixed-`R` single-show signature is just `<R> <P> OP_CHECKSPLITSIG`.\n> >\n> > Regards,\n> > ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Pay-to-Open and UX improvements",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Antoine Riard",
                "David A. Harding",
                "Bastien TEINTURIER",
                "Ethan Heilman"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 48961
        }
    },
    {
        "title": "[Lightning-dev] Faking LN transactions to road block chain analysis? Does it make any sense?",
        "thread_messages": [
            {
                "author": "Piotr W\u0142odarek",
                "date": "2019-12-20T15:22:17",
                "message_text_only": "We do know for a fact that chain analysis software stops tracing\nbackwards when found a compliant exchange address (good), gambling site\naddress (bad), etc.\n\nTheoretically, LN channel closure transaction should stop chain analysis\nsoftware from analysing the chain further, as it is an exit gateway from\nanother world, correct?\n\nNot saying this is already implemented by surveillance companies but one\nwould expect that in the future.\n\nIf so, we could envision faking LN like transactions to road block the\nanalysis.\n\nThat would entail: 1) channel funding tx, 2) reasonable delay, 3)\nchannel closure tx with amount split (and not merged) so it looks natural.\n\nAdvantages over using the actual LN I believe are obvious: no liquidity\nproblem, no data exchange with LN public nodes, simplicity, etc.\n\nObviously, this assumes LN usage itself is not blacklisted by\nsurveillance companies.\n\nDoes it make sense?\n\nOr am I missing something?\n\n-- \nqertoip"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-20T15:58:47",
                "message_text_only": "Good morning Piotr,\n\n> We do know for a fact that chain analysis software stops tracing\n> backwards when found a compliant exchange address (good), gambling site\n> address (bad), etc.\n>\n> Theoretically, LN channel closure transaction should stop chain analysis\n> software from analysing the chain further, as it is an exit gateway from\n> another world, correct?\n>\n> Not saying this is already implemented by surveillance companies but one\n> would expect that in the future.\n>\n> If so, we could envision faking LN like transactions to road block the\n> analysis.\n>\n> That would entail: 1) channel funding tx, 2) reasonable delay, 3)\n> channel closure tx with amount split (and not merged) so it looks natural.\n>\n> Advantages over using the actual LN I believe are obvious: no liquidity\n> problem, no data exchange with LN public nodes, simplicity, etc.\n>\n> Obviously, this assumes LN usage itself is not blacklisted by\n> surveillance companies.\n>\n> Does it make sense?\n>\n> Or am I missing something?\n\nCurrent Lightning Network mutual closes are spends of 2-of-2 outputs.\nGiven that most people will use either 1-of-1 or 2-of-3 (\"never go to sea with two chronometers, take one or three\"), they stand out and it is reasonable to assume that any 2-of-2 will be Lightning.\n\nNow while this can be a \"blockage\" of some sort, we can observe as well that the upcoming BIP-Schnorr will allow the use of MuSig, which lets all n-of-n (including Lightning 2-of-2) to hide in the same anonymity set as 1-of-1.\nThis helps break this kind of analysis as well, as Lightning channel closes are now indistinguishable from simple single-owner spends that are expected to be a good part of foreseeable future.\nSome work is also being done on verifiable secret splitting, which would allow k-of-n to hide in the same anonymity set as n-of-n, thus bringing the 2-of-3 users into this as well, and becoming a serious pain to chain analysis.\nIt is this uncertainty which will force chain analysis (and offchain analysis as well, as Lightning grows) to start considering fuzzy logic (i.e. probabilistic analysis models, such as Bayesian nets).\n\nYou might also be interested in CoinSwapper as well: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002245.html\nThis somewhat inverts things, in that a method of mixing coins is possible by passing them through the Lightning Network (and it is arguable that this method of mixing will be just as efficient as onchain-only CoinSwap, though not as efficient as CoinJoin still).\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Esteban Ordano",
                "date": "2019-12-20T16:20:36",
                "message_text_only": "On Fri, Dec 20, 2019 at 12:59 PM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Current Lightning Network mutual closes are spends of 2-of-2 outputs.\n> Given that most people will use either 1-of-1 or 2-of-3 (\"never go to sea\n> with two chronometers, take one or three\"), they stand out and it is\n> reasonable to assume that any 2-of-2 will be Lightning.\n>\n\nInteresting... alternatively, one could explore modifying the current\n2-of-2 closing outputs to make them undistinguishable from 2-of-3 outputs\nby negotiating a random third public key with a nonexistent private key\n(like XORing random values provided by each channel participant).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191220/d1e75785/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-20T16:39:56",
                "message_text_only": "Good morning Esteban,\n\n> On Fri, Dec 20, 2019 at 12:59 PM ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> > Current Lightning Network mutual closes are spends of 2-of-2 outputs.\n> > Given that most people will use either 1-of-1 or 2-of-3 (\"never go to sea with two chronometers, take one or three\"), they stand out and it is reasonable to assume that any 2-of-2 will be Lightning.\n>\n> Interesting... alternatively, one could explore modifying the current 2-of-2 closing outputs to make them undistinguishable from 2-of-3 outputs by negotiating a random third public key with a\u00a0nonexistent\u00a0private key (like XORing random values provided by each channel participant).\n\nIt has the drawback of requiring three public keys in the resulting revealed SCRIPT rather than two.\nFurther, *hopefully* the incoming BIP-Schnorr, with *hopefully* upcoming improvements in the verifiable secret splitting thing, will allow \"normal\" MuSig 2-of-2 to be indistinguishable from 2-of-3 as well.\n\nIt would be best to have a standardized NUMS point, then have both participants add their own one-time points to that point, precommitting hashes of those points first, then providing the points, then generating the sum of standard NUMS plus their random points.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Esteban Ordano",
                "date": "2019-12-20T17:01:50",
                "message_text_only": "Indeed, please excuse the brevity of my proposed mechanism and my basic\ncryptographic toolkit. Thank you for building on it!\n\nThe additional cost in the closing transaction would be an interesting\ntrade-off for the privacy it provides. It could be negotiated on channel\nopening alongside the fee structure. I brought it up because it would be\ninteresting to discuss this privacy improvement because it can be\nimplemented today, and phased out when viable.\n\nI am worried that it might open the door for an entropy exhaustion attack\non negotiation, yet that might be easy to prevent.\n\nE\n\nOn Fri, 20 Dec 2019 at 13:40 ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Esteban,\n>\n> > On Fri, Dec 20, 2019 at 12:59 PM ZmnSCPxj via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Current Lightning Network mutual closes are spends of 2-of-2 outputs.\n> > > Given that most people will use either 1-of-1 or 2-of-3 (\"never go to\n> sea with two chronometers, take one or three\"), they stand out and it is\n> reasonable to assume that any 2-of-2 will be Lightning.\n> >\n> > Interesting... alternatively, one could explore modifying the current\n> 2-of-2 closing outputs to make them undistinguishable from 2-of-3 outputs\n> by negotiating a random third public key with a nonexistent private key\n> (like XORing random values provided by each channel participant).\n>\n> It has the drawback of requiring three public keys in the resulting\n> revealed SCRIPT rather than two.\n> Further, *hopefully* the incoming BIP-Schnorr, with *hopefully* upcoming\n> improvements in the verifiable secret splitting thing, will allow \"normal\"\n> MuSig 2-of-2 to be indistinguishable from 2-of-3 as well.\n>\n> It would be best to have a standardized NUMS point, then have both\n> participants add their own one-time points to that point, precommitting\n> hashes of those points first, then providing the points, then generating\n> the sum of standard NUMS plus their random points.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191220/b0589629/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Faking LN transactions to road block chain analysis? Does it make any sense?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Esteban Ordano",
                "Piotr W\u0142odarek"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 7828
        }
    },
    {
        "title": "[Lightning-dev] Research on proactive fee free channel rebalancing in the friend of a friend network / and roadmap for a protocol extension",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-12-23T10:21:45",
                "message_text_only": "Dear fellow Lightning Developers,\n\ntoday my research paper (together with Mariusz Nowostawski) \"*Imbalance\nmeasure and proactive channel rebalancing algorithm for the Lightning\nNetwork*\" was published on arxiv: https://arxiv.org/abs/1912.09555 The\nLaTeX project as well as the code for the experiments (simulation and\nevaluation) are open source (however not too well documented yet) at:\nhttps://github.com/renepickhardt/Imbalance-measure-and-proactive-channel-rebalancing-algorithm-for-the-Lightning-Network\nI am open for questions, feedback, discussions and in particular critical\nremarks. Let me just state that I was quite surprised about the positive\nimpact of implementing such a rebalancing protocol in particular since in\nits current form it seems to protect the privacy of nodes (more research\nwould be needed to be sure that the privacy is really protected).\n\n# From the abstract:\n\n*We further show that the success rate of a single unit payment increases\nfrom 11.2% on the imbalanced network to 98.3% in the balanced network.\nSimilarly, the median possible payment size across all pairs of\nparticipants increases from 0 to 0.5 mBTC for initial routing attempts on\nthe cheapest possible path. We provide an empirical evidence that routing\nfees should be dropped for proactive rebalancing operations. Executing 4\ndifferent strategies for selecting rebalancing cycles lead to similar\nresults indicating that a collaborative approach within the friend of a\nfriend network might be preferable from a practical point of view*\n\n# Some thoughts and context:\n\nAlready in my proposal of JIT Routing\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-March/001891.html\nI suggested to allow for fee free rebalancing and do the rebalancing\noperations in the friend of a friend network. With this research I tested\nboth assumptions and - unless someone points out methodological errors in\nmy evaluation - we now have strong evidence that this in deed makes a lot\nof sense. I think it is in particular interesting that 0.5 mBTC can be\nrouted successfully on first attempt in 50% of the cases. I guess using\nthis together with Multi part / path payments as discussed in the future\nwork section of the paper might be the way to go for the lightning network.\nI envision that while payments along several paths are routed and settled\nnodes could already rebalance their channels in particular if we introduce\nthe redundancy to multi part / path payments as suggested in the Boomerang\nPaper https://arxiv.org/abs/1910.01834 by Vivek Bagaria, Joachim Neu and\nDavid Tse.\n\n# Roadmap for BOLT 14 (Fee free Rebalancing Transport):\n\nIf no strong objections exist I would try to extend the BOLTs with the\nfollowing to be able to implement the rebalancing algorithm across the\nnetwork (as with JIT routing nodes can already opt to implement the\nalgorithm for themselves but this is probably not to useful from an\neconomic point of view).\n\n* BOLT 07: a new gossip query and reply `query_want_rebalance_channel_ids`\n/ `reply_want_rebalance_channel_ids` to ask channel partners on which of\ntheir channels they want inbound / outbound liquidity. The query could\nalready include an optional offer how much the node initiating the\nrebalancing operation is willing to offer while the reply could have an\noptional offer field stating how much they nodes are willing to rebalance\n(as the paper shows nodes might not have consensus about the amount and the\nalgorithm currently works by agreeing on the lowest value). Of course this\nextension needs some protection against probing attacks to protect the\nprivacy of nodes.\n* BOLT 14: (Fee Free Rebalancing Transport) While it seems tempting to\nReuse BOLT04 with a different realm that omits fees for the rebalancing\ncycles (which nodes would have to accept then) this seems impossible as the\nonions are not public and nodes could not verify that this is really a\nrebalancing operation and not a payment which tries to \"steel\" fees. While\nwe might be able to extend BOLT 02 with a new message that transports a\n\"rebalancing\" onion together with the keys for every envelop so that\neveryone can verify that in fact this fee free onion is a rebalancing cycle\nit seems plausible to have an open tansport for fee free rebalancing to\nstart with. We could also make it a feature flag and allow nodes to signal\nif they support fee free rebalancing. I guess for backwards compatebility\nthis should be done in any case.\n* One problem / attack vector with circular fee free payments that I see is\nthat if Alice wants to pay David she could initiate a rebalancing onion: A\n--> B --> C --> D --> A with the paymenthash that David has created in an\ninvoice. David would just not set up the final HTLC from him to Alice as he\nwanted to receive money from Alice. As far as I see this attack would only\nbe possible if Alice and David have a channel which they could have used\nfor the payment right away. Not using that channel is effectively a\nrebalancing operation which is exactly why we allow such a protocol. This\nmeans that the channel between Alice and David has to be public to allow\nfor a fee free operation. Otherwhise I could always claim to have a private\nchannel if I wanted to pay someone without fees.\nStill this allows two people who have a public channel to spam out HTLCs\nwhich settle at no cost. However - according to my research - nodes along\nthe cycle only participate if that was beneficial for them. Also since\nthese rebalancing cycles are open and transparent they could be blocked if\nnodes feel they are being abused.\n\nWhile the extension of BOLT 07 seems rather simple and straight forward.\nBOLT 14 (I like the fact, that it is actually 4 + 10 ) might be more\ncontroversial. Especially for that I would love to have some feedback\nbefore I start to spec this out.\n\nHave good Christmas time everyone!\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20191223/595b5f67/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-23T10:56:29",
                "message_text_only": "Good morning Rene,\n\nWhat no JIT-routing?\n\n\n> # Roadmap for BOLT 14 (Fee free Rebalancing Transport):\n>\n> If no strong objections exist I would try to extend the BOLTs with the following to be able to implement the rebalancing algorithm across the network (as with JIT routing nodes can already opt to implement the algorithm for themselves but this is probably not to useful from an economic point of view).\n>\n> * BOLT 07: a new gossip query and reply `query_want_rebalance_channel_ids` / `reply_want_rebalance_channel_ids` to ask channel partners on which of their channels they want inbound / outbound liquidity. The query could already include an optional offer how much the node initiating the rebalancing operation is willing to offer while the reply could have an optional offer field stating how much they nodes are willing to rebalance (as the paper shows nodes might not have consensus about the amount and the algorithm currently works by agreeing on the lowest value). Of course this extension needs some protection against probing attacks to protect the privacy of nodes.\n> * BOLT 14: (Fee Free Rebalancing Transport) While it seems tempting to Reuse BOLT04 with a different realm that omits fees for the rebalancing cycles (which nodes would have to accept then) this seems impossible as the onions are not public and nodes could not verify that this is really a rebalancing operation and not a payment which tries to \"steel\" fees. While we might be able to extend BOLT 02 with a new message that transports a \"rebalancing\" onion together with the keys for every envelop so that everyone can verify that in fact this fee free onion is a rebalancing cycle it seems plausible to have an open tansport for fee free rebalancing to start with. We could also make it a feature flag and allow nodes to signal if they support fee free rebalancing. I guess for backwards compatebility this should be done in any case.\n> * One problem / attack vector with circular fee free payments that I see is that if Alice wants to pay David she could initiate a rebalancing onion: A --> B --> C --> D --> A with the paymenthash that David has created in an invoice. David would just not set up the final HTLC from him to Alice as he wanted to receive money from Alice. As far as I see this attack would only be possible if Alice and David have a channel which they could have used for the payment right away. Not using that channel is effectively a rebalancing operation which is exactly why we allow such a protocol. This means that the channel between Alice and David has to be public to allow for a fee free operation. Otherwhise I could always claim to have a private channel if I wanted to pay someone without fees.\n> Still this allows two people who have a public channel to spam out HTLCs which settle at no cost. However - according to my research - nodes along the cycle only participate if that was beneficial for them. Also since these rebalancing cycles are open and transparent they could be blocked if nodes feel they are being abused.\n>\n> While the extension of BOLT 07 seems rather simple and straight forward. BOLT 14 (I like the fact, that it is actually 4 + 10 ) might be more controversial. Especially for that I would love to have some feedback before I start to spec this out.\n\nDefinitely.\nIn particular I am wary of making the rebalance different from payments.\nWe should consider always that there will be nodes whose only purpose in life is to monitor the activities of other people.\n\nThe fact that current rebalances are indistinguishable (or at least hard to distinguish) from normal payments is helpful for privacy: it makes it harder for surveillors, since they have to filter out rebalance attempts from actual real payments.\nSplitting out rebalances from payments breaks this privacy advantage.\n\nI suggest rather that:\n\n* Add a local-scope broadcast \"I provisionally allow routing via this channel-direction without fees; this offer is valid up to blockheight B\".\n  * Add a secret in this broadcast (\"here is the claimcode: ZmnSCPxj\").\n* Hide rebalances in the current onion format; just do not decrement the outgoing value from the incoming value (i.e. 0 fee).\n  * Add the secret in the broadcast in a new even TLV.\n\nI think it is not necessary for a node to directly know if an HTLC to be forwarded is a \"real\" payment or a \"rebalance\".\nIn particular:\n\n* The node will only offer a fee-free rebalance if its own channel is imbalanced in that direction.\n* It does not matter if the payment is \"real\" or \"rebalance\": it will change the channel to be balanced anyway, which is already a win.\n* Regardless of whether the payment is \"real\" or \"rebalance\", if the payment will not cause the channel to be balanced (for example, somebody else managed to already balance that channel, *or* the payment is too big and causes the channel to be imbalanced in the reverse direction instead), then the node should reject the payment anyway if the fee is 0.\n\nThus, I suggest instead:\n\n* Define a new message for local broadcast of channels that would be nice to balance.\n* Add a new TLV for onions that includes a secret from the previous message.\n* Add a new onion failure code that includes a proposed amount.\n  * The sender MUST NOT send this failure code if the onion entry for that node does not contain the previous TLV.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Research on proactive fee free channel rebalancing in the friend of a friend network / and roadmap for a protocol extension",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Ren\u00e9 Pickhardt"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 11439
        }
    },
    {
        "title": "[Lightning-dev] On Path Privacy",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-26T03:03:13",
                "message_text_only": "Privacy Loss Models\n===================\n\nShortest Path Heuristic\n-----------------------\n\nFirst, let us presuppose a network connected as below:\n\n\n        B --- C\n       /       \\\n      /         \\\n     A           D\n      \\         /\n       \\       /\n        F --- E\n\nNow, let us suppose that some evil surveillor insinuates itself into the network:\n\n        B --- C\n       / \\   / \\\n      /   \\ /   \\\n     A --- S --- D\n      \\   / \\   /\n       \\ /   \\ /\n        F --- E\n\nThe strategy of the surveillor is thus the below:\n\n* It makes itself more central to the network by creating large numbers of channels, especially to distant nodes.\n* It lowers its channel fees relative to the other nodes, making its channels attractive to pathfinders that consider channel fees.\n* It uses the \"shortest path heuristic\".\n  That is:\n  * Suppose in the given example, S receives a forward via the B-S channel, to the S-D channel.\n  * Then it knows the payer is B and the payee is D.\n\nMore precisely, the \"shortest path heuristic\" simply means performing the below precomputation:\n\n* Take the entire routemap.\n* Create a mapping of the tuple of an incoming channel and an outgoing channel (of the surveillor node), to a set of pairs of payers and payees.\n* For each possible payer in all nodes:\n  * For each each possible payee in all nodes:\n    * Take the shortest path from payer to payee.\n    * If the surveillor node is in that path, determine the incoming channel and outgoing channel, then add the payer and payee to the corresponding entry in the mapping.\n\nThen, whenever the surveillor node has to perform a forward, it only needs to look up the incoming channel and outgoing channel in the mapping.\nThis results in a set of possible payer/payee pairs.\n\nThis analysis becomes more powerful when the surveillor has acquired forwarding logs from multiple nodes on the network.\nIf a payment is determined to have passed through multiple nodes, whose forwarding logs the surveillor has acquired, then the surveillor can simply perform the above precomputation for each node, then take the intersection of the sets in each mapping entry.\n\nMuch of the privacy loss is effectively due to forwarding nodes being able to create \"reverse\" routing tables.\nThat is, instead of a routing table that inputs a source and destination and outputs a (set of) likely direction(s) to send packets to, a reverse routing table inputs a direction from sent and to sent and outputs a (set of) likely source(s)/destination(s).\n\nUnremovable Forwarding Data\n---------------------------\n\nAs we know, switching Lightning from HTLCs to PTLCs (i.e. from payment hash + preimage to payment point + scalar) enables many new features, including the so-called \"path decorrelation\".\nThe theory is that by changing the payment point at each hop, multiple coordinating surveillor nodes will be unable to determine if the same payment passed through them.\n\nHowever, this is not sufficient, as the data below cannot be removed or hidden:\n\n* The sidereal time at which `update_add_htlc` messages are sent\n  * This can be used to determine if two forwards are possibly on the same payment path.\n  * Worse, the sidereal time between the outgoing `update_add_htlc` and the `update_fail_htlc` /  `update_fulfill_htlc` response can be measured to help characterize the distance, in nodes, to the payee.\n  * We cannot change or mask this time, unless we are willing to add random, potentially-large latencies to forwards, which we do not want to do since the entire point of Lightning Network is fast payments.\n* The value being transmitted cannot be hidden from the forwarding node.\n  * While we know how to send homomorphically encrypted values that can be summed up, the forwarding node has to know the value of its own channels, and would know how much a forward changes its own channel values in order to determine if it has enough capacity on a channel to actually offer the outgoing HTLC.\n* The timelock of the payment cannot be hidden from the forwarding node.\n  * The forwarding node is liable for the timelock of any HTLCs it offers, and it has to know about the exact timelock in order to force a channel onchain when any HTLCs pending on it have a timelock that is expiring very soon.\n\nThe above data helps two cooperating surveilling nodes to determine if two forwards on their nodes belong to the same logical payment, even if path decorrelation masks the payment point along the entire path:\n\n* The two nodes can determine:\n  * How long a shortest-path payment takes to reach from one to the other.\n  * How much fees the shortest path between them costs.\n  * How much CLTV-delta the shortest path between them costs.\n\nBy deriving the above data, two nodes can have a very good guess of which forwards passing through them are likely to belong to the same payment, which helps them triangulate better the payer and payee, especially given the shortest path heuristic.\nThus, even *with* path decorrelation, two cooperating surveilling nodes can still correlate forwards across them (they just will not be able to execute a wormhole attack).\n\nNow, of note is that the the timelock is particularly leaky in terms of privacy.\nThe timelock gives an upper bound on the distance of the forwarding node to the ultimate payee.\nIn combination with another privacy loss, this can allow a forwarding node to precisely identify the ultimate payee of a payment.\n\nBoth value and timelock can be randomized somewhat by use of \"shadow routes\", as implemented in C-Lightning.\nHowever, the current C-Lightning implementation only inserts shadow routes at the end of the route; it should also insert shadow routes at random points in the route, and mildly overpay fees along the way (not just give extra value+cltv-delta to the last node), to reduce the ability of multiple cooperating surveillors to determine if their forwards are the same payment.\n\nREDACTED SECTION\n----------------\n\nREDACTED TEXT.\n\nNon-Solutions to Privacy Loss\n=============================\n\nUnpublished Channels Delenda Est\n--------------------------------\n\nUnpublished channels are becoming popular for some reason, and even section 4.1 of [this paper](https://arxiv.org/pdf/1909.02717) gives it as a solution for improving privacy without sacrificing utility.\n\nUnfortunately for that paper, this is wrong, and unpublished channels must be destroyed.\n\nUnpublished channels do not improve privacy, but instead move the privacy risks from shared to concentrated on specific nodes, which become targets for surveillors.\nFurther, because it moves risk to fewer high-value targets (a symptom of centralization), it violates [Risk Sharing Principle](https://github.com/libbitcoin/libbitcoin-system/wiki/Risk-Sharing-Principle).\n\nAs I noted [here](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002241.html), the Axiom of Terminus means that I can have the heuristic:\n\n* If I receive a forwarding request:\n  * If the incoming channel is unpublished, the node on the other end is the payer.\n  * If the outgoing channel is unpublished, the node on the other end is the payee.\n\nThis gives very precise information about who the payer and payee is, and is not fixable by e.g. shadow routing or [REDACTED TEXT].\n\nNow, of course the above heuristic is only doable by primarily-forwarding nodes with a mix of unpublished and published channels, and only to nodes that use the unpublished channels.\nOtherwise, independent third parties cannot even know about nodes that *only* use unpublished channels, so that should be good, right?\n\nUnfortunately:\n\n* Payers have pretty good privacy otherwise: the (unremovable) timelock is a hint to the distance to the payee, not payer, and the payer could always claim that it received the payment via other published channels.\n  * Thus, ***the fact that with unpublished channels some nodes can now identify the payer precisely is a major privacy loss for payers***.\n* Those nodes with a mix of unpublished channels and published channels become major targets for surveillance.\n  * They may be tempted by the dark side to defray their operating costs by actively selling the payment information they have acquired.\n  * Their backups and persistent storage can be hacked and copies of forwarding logs acquired, even if they are strongly committed to privacy for their clients.\n  * Competitors who *do* sell their payment information can outcompete them, undercutting their fees (which also has the effect that payments are more likely to be routed to them due to the lower fees, increasing their ability to surveill further).\n* The existence of unpublished channels is still attested on the blockchain, and onchain analysis can give hints on which unpublished users ended up making channels with specific published nodes.\n  * Lightning is practically the only use of 2-of-2 P2WSH, since most HODL usages will be either 1-of-1 or 2-of-3 (\"never take two chronometers to sea: take one or three\").\n  * Since current Bitcoin requires revealing a 2-of-2 script in P2WSH, even mutual closes of unpublished channels are visible publicly on the blockchain anyway, and subsequent use of that money can be traceable to specific servers.\n    * Taproot fixes this.\n    * CoinJoin fixes this.\n\nIf all channels were published, then this spreads out the information that forwarding nodes can keep.\nSurveillors capable of stealing forwarding logs of nodes will need to gather the forwarding nodes of large numbers of nodes.\nThis is risk sharing: privacy-leaking information is spread out and no single node is a particularly juicy target for acquisition of control.\n\nNote that nodes can publish themselves without publishing their IP addresses; thus they can at least hide their locations at the IP layer while revealing their locations at the Lightning layer.\nNodes can also use Tor, at the cost of increased latency with the rest of the network, which behooves us to design our protocol to minimize bandwidth and turnaroud.\n\nRefusal to Log\n--------------\n\nNow, a forwarding node operator may not necessarily be an evil surveillor, and may even have a desire to be (seen as) good.\nSuch a node operator might, as protection against hacks, and protection against evil surveillors who might hack their node and snoop their data, refuse to maintain a log of forwards.\n\nLet us presuppose that there exists some magic spell, that ensures that a node operator is in fact performing (or not performing) some promised act (or disavowed act).\nI will now show that, even if such a spell could exist, a node operator cannot promise to not keep a log of forwards, at least with the current HTLCs being sent via Poon-Dryja channels.\n\nFirst:\n\n* Poon-Dryja requires transaction revocation.\n* Transaction revocation requires that nodes be able to recognize old state and revoke them.\n* Revoking a transaction means spending it using a special revocation branch of a special modified script.\n* Special scripts in Bitcoin must be encoded in P2SH/P2WSH.\n* To spend a P2SH/P2WSH, we need to show the whole encoded script, even those branches that are not taken.\n* Thus, to spend a revocable HTLC output, a node has to store the hash and timelock, even if it is taking the revocation path.\n  * While HTLCs currently used have yet another transaction (HTLC-timeout or HTLC-success) to actually claim the funds, both the HTLC and the claim transactions have to be revocable, else an attacker might publish an old state that has all channel funds in HTLCs.\n    If the victim is unable to publish the HTLC script in order to spend (and revoke) the plain HTLC output without an HTLC-timeout or HTLC-success transaction being published, then the attacker can simply refuse to publish the HTLC-timeout/HTLC-success and the victim still loses access to the funds (though the attacker will still not be able to claim it, the attacker might just want to make the victim lose funds).\n    Thus, every node must be able to publish the HTLC script in order to revoke it (even without the attacker publishing HTLC-success/HTCL-timeout), which means it has to keep every old state hash and timelock.\n\nThen, secondly:\n\n* The hashes used in forwarding have to be the same in both the incoming HTLC and the outgoing HTLC.\n\nThus:\n\n* Nodes have to keep all hashes and timelocks for all HTLCs of all older channel states of all channels, otherwise they are insecure.\n* Third parties acquiring the above data from nodes can correlate forwards by checking for HTLCs that exist in two channels.\n  * Indeed, because HTLC scripts are different based on whether it is the local or the remote side that offered them, third parties can determine as well which HTLC is incoming and which it outgoing.\n  * Further, the stored timelock gives an upper bound on the time an HTLC was created, giving hints on timing of a payment as well.\n* Therefore all current secure nodes are required to store data that is enough to derive a log of forwards.\n\nOf course, this is not so dire.\nIn the (close?) future, improvements to base layer will allow nodes to elide enough information from its stored data, so that a log of forwards can no longer be derived:\n\n* Schnorr means we can use pointlocked timelocked contracts with payment decorrelation, thus allowing breaking of the link between incoming and outgoing PTLCs even in the data stored by nodes.\n  * Once an outgoing PTLC has been claimed and we have determined the incoming PTLC, we can delete the delta between the two contracts from persistent storage, thus preventing from linking incoming from outgoing PTLCs.\n* Taproot means we can put the revocation branch of revocable HTLCs in a separate tapleaf.\n  * Thus, nodes can store only the Merkle path to the revocation script, and thus no longer store the hash and timelock for all HTLCs on all older states.\n* `SIGHASH_NOINPUT` means we can implement Decker-Russell-Osuntokun.\n  * Thus, honest nodes no longer need to store data from previous states of the channel.\n\nAgainst the above, however, I must remind:\n\n* We still need to create a magic spell that allows third parties to actually believe, without tr\\*st, the promises of node operators that they will not store a plain log of forwards of their node, and that they will not modify the available open-source software to do so and run their locally-modified versions.\n* Even if the above magic spell were created, at ***some*** point in the past the node knew an incoming HTLC/PTLC and its link to an outgoing HTLC/PTLC.\n  * Lower layers beneath the node software may betray the above magic spell nevertheless:\n    * \"Deleted\" data might be implemented by a database layer by simply marking some record as unused, and then reuse of that record might take a long time, meaning that old data may still exist in \"deleted\" records.\n    * The filesystem layer might implement recovery logs or other techniques where \"overwritten\" data is kept, as a simple function of reliability, and that data may remain validly readable outside the filesystem (i.e. deleted data might not be overwritten).\n    * The spinning rust / floating gate lower layers may, even with data overwritten, retain transient inductive / capacitive charge that can be read by specialized equipment, or may not overwrite data from sectors / blocks marked bad and then remapped elsewhere.\n  * In short, we cannot \"refuse to log\": we have to write the link between an outgoing HTLC/PTLC to an incoming HTLC/PTLC somewhere persistent *first* (in case our node gets randomly shut down while a forward is not yet claimed), wait for the outgoing HTLC/PTLC to be claimed, and *then* delete it later.\n    And \"delete\" is not necessarily an operation that is possible in the presence of attackers that want to retain your data.\n\nPossible Solutions\n==================\n\nAvoiding Shortest Path\n----------------------\n\nThe shortest path heuristic is key in analyzing payments on the Lightning network.\nThus, breaking this heuristic is important.\n\n* One way is to `permuteroute` the shortest-path.\n  * For reference, `permuteroute` is described here: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-August/002095.html\n    * Briefly: It is an algorithm where you input an existing route, plus a \"breakage\" (a channel or node that is failing) on that route.\n      The algorithm then makes a short-range pathfinding to heal the break, or fails if it takes too long for it to find a way to heal the break.\n  * Start with a shortest path via normal shortest-path pathfinding algorithms, then randomly select one intermediate node on that path and treat it as a \"breakage\" with `permuteroute`.\n    * If that succeeds, try it a few more times until it fails or you are satisfied with the additional path length, then just use the latest randomized path.\n* Add random tweaks to your channel traversal costs.\n  * This is done currently by the C-Lightning route randomization feature, but note that it is currently set to up to a +/-5% tweak.\n    * [This paper](https://arxiv.org/pdf/1909.06890) evaluates the C-Lightning route randomization as well.\n      It suggest adding random tweaks to the costs of entire routes instead, though it may not be easy for normal pathfinding algorithms to implement this.\n* Rusty Russell Random Route Ralgorithm.\n  * Alluded to in [SLP134](https://stephanlivera.com/episode/134/).\n  * In a private email, Rusty recounted the random routing routine; roughly reworded:\n    * Start with a Dijkstra starting from the payer node and completing over the entire routemap.\n      * Store the distance from each node to the payer.\n      * This step can be precomputed, rather than performed each time we need a path.\n    * Then the algorithm proper:\n      * Start at the destination. payee node.\n      * Toss a biased coin (bias controlled by how much you want to overpay fees):\n        * If it is heads, pick a channel at random and extend the route to it.\n        * If it is tails, find which channel goes to the node with lowest-distance-to-payer and extend the route to it.\n      * Keep doing the above until we reach the payer node.\n    * Then apply shadow routing afterwards.\n  * Note that the above algorithm is roughly similar to the Greedy Best First Search with precomputed distance heuristic (a.k.a. `getroutequick`, which I presented in LNConf 2019).\n    * The only difference is that there is a random coin toss between selecting a random channel and going towards the source node, where `getroutequick` just goes towards the source node.\n    * We can approximate the Rusty Russell Random Routing Ralgorithm by applying a random tweak to the distance heuristic in a Greedy Best First Search!\n  * The algorithm as described has a chance of creating small loops, which should be avoided.\n    * Small loops that curl (i.e. pass multiple times) through a surveillor node are equivalent to a payment passing through multiple surveillor-controlled nodes, and can be identified even post-payment-decorrelation as being the same payment.\n      * Thus you end up paying for routing through the loop, but do not gain much privacy from that extra payment because now you are giving more accurate data to a specific node (where the payment curled through).\n    * A proper Greedy Best First Search avoids loops due to marking nodes as they are visited, so I think basing the algorithm around Greedy Best First Search plus random tweak on the heuristic is better.\n* Usage discounting.\n  * When a base pathfinder returns a path, increment a \"usedness\" counter on each node on that path.\n  * On future pathfinding calls, consider those nodes to have higher than normal cost, according to their usedness.\n    * Of note is that pathfinding algorithms do NOT actually need a single numeric cost.\n      * Instead, they need a mathematical group and group operation, with an additional \"comparison\" operation to determine which of two group elements is smaller.\n      * Integer costs are a group with a comparison operation.\n      * Instead of integer cost, we can have a pair of `(usedness, fee)`.\n        * Add each tuple element separately, e.g. `(usedness_a, fee_a) + (usedness_b, fee_b) = (usedness_a + usedness_b, fee_a + fee_b)`.\n        * To compare, e.g. `(usedness_a, fee_a) < (usedness_b, fee_b)`, we first compare by `usedness`, then if they are equal, compare `fee`.\n  * This gives good diversity over multiple calls of the pathfinder, which is useful for:\n    * Multipath, since we want each candidate path to have different nodes as much as possible, without completely discounting those nodes in case of bottlenecks in the network.\n    * Ensures your payment data is distributed to multiple nodes rather than reusing the same nodes again and again, improving Risk Sharing since your data is spread out over more nodes.\n  * The `usedness` needs to persist across node restarts.\n\nDirect Path Exemption\n---------------------\n\nAs mentioned above, avoiding the shortest path breaks the shortest path heuristic, adding uncertainty to analyses and thus improving privacy.\n\nHowever, we should note an important exception to avoiding the shortest path:\n\n* If the shortest path is a single hop, directly from the payer to the payee without intervening nodes, then we should prefer that path rather than avoid it.\n\nThe reason why we have this exception is that ***not telling any other nodes gives us the best privacy***.\nThis is achievable only by having direct channels with a payee, thus it ***does not scale***, since it would not be practical to have direct channels between every payer and payee.\nHowever, if we find that the payment is to a direct peer, taking this exception should be a massive, low-hanging privacy win.\n\nThis brings up the following observation:\n\n* In order to avoid the shortest path, we may need to add more nodes to the path we use.\n  * By adding more nodes to the path we use, we increase the number of nodes that know our payment, increasing our chances of informing some surveillor.\n\nExtended Shadow Routing\n-----------------------\n\nAnother apropos observation is that having more nodes on a path reduces the reliability of payments along the path.\nEvery node on that path is a possible failure point in forwarding.\n\nWorse, paths that are longer in terms of hops are more likely to have the below failure mode:\n\n* A forwarding node is able to accept and irrevocably forward an HTLC.\n* Before the outgoing HTLC can be claimed offchain, the forwarding node shuts down.\n* The payment is now \"stuck\" until the incoming HTLC of the node reaches timeout.\n\nBasically, if a forwarding node fails between the time it forwards the HTLC and the time the next node is able to claim it, payments get stuck for durations that can be counted in entire blocks.\nAs path length increases, this failure mode becomes more likely:\n\n* There are more possible nodes to fail.\n* The time between when a node is able to forward and the next node is able to claim becomes longer, making it more likely that an individual node fails during this time.\n\nOf course, taking the shortest path in terms of node hops is precisely what reverse routing tables can break.\nThis is the core of the observation that privacy and usability are apparently at odds with one another.\n\nReverse routing tables cannot precisely identify the payer and payee.\nHowever, the timelock, as well as the time it takes for an HTLC to be forwarded and then claimed, can give hints as to the distance between the forwarding node and the payee.\nWe cannot do anything about the sidereal time at which events occur, but we *can* do something about timelocks, i.e. shadow routing as already implemented in C-Lightning.\n\nA secondary concern is that, after path decorrelation is implemented, the *delta* in value, timelock, and sidereal time between two cooperating surveilling nodes can be used to determine if two forwards on those nodes belong to the same overall payment.\nShadow routing does not help this, since it only adds timelock and value tweaks to the *end* of the path, and any *delta* between two surveilling nodes remains the same.\n\nAvoiding the shortest path has a chance that the sub-path between the two surveilling nodes is not the delta of the shortest path between them, which helps remove payment correlation in a post-decorrelation world.\nHowever, it does have the drawback that increasing the actual path length tends to increase the number of nodes along the path, reducing reliability.\n\nBy inserting shadow routes in the middle of the path instead of just the payee end, we can gain some of the above advantage of removing payment correlation in a post-decorrelation world, without having to incur the reduced reliability of actually increasing the number of hops along a path.\nThis is only useful in a post-decorrelation world, as use of HTLCs means that two cooperating surveilling nodes can determine if two forwards between them belong to the same overall payment.\n\nInserting such shadow routes basically amounts to overpaying fees and giving more timelock slack to forwarding nodes.\n\nMultipath Value Obfuscation\n---------------------------\n\nAn observation we can have is that, the difference between a fixed known value and a random value will be indistinguishable from a random value.\nThe same observation underlies adaptor signatures and payment decorrelation.\n\nThus, one way to obfuscate the unremovable data of the payment value is to always start with payments split into two subpayments.\n\n* Take a random value from 1 to the total payment minus 1 and use it on one subpayment.\n* Take the difference between the total payment amount and the above random value and use it as the other subpayment.\n\nBoth numbers will look like random values, and only together can they be used to identify the actual value.\n\nThe value obfuscation only works to obfuscate the final payee value.\nWithout \"avoiding shortest path\" or \"extended shadow route\", the value of the payment can still be used by two cooperating surveilling nodes to identify if two forwards belong to the same (sub)payment, even in a post-decorrelation world.\n\nWith HTLCs, two cooperating surveilling nodes that happen to be on separate subpayments can still identify the total payment and thereby have a guess on what is being bought."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-12-29T11:14:58",
                "message_text_only": "Good morning list,\n\n\n> Unpublished Channels Delenda Est\n> -----------------------------------\n\nFurther thoughts on this topic.\n\nIn blockchain layer, decentralization is not a value in and of itself.\nInstead, it is an instrumental goal, with the terminal values actually being Censorship Resistance and Monetary Policy Preservation.\n(i.e. the point of decentralizing is to prevent transactions from being labelled \"illegal\" and disallowed, and to prevent breaching of the pre-determined 21M limit)\n\nThus, we should consider as well that on the Lightning layer, decentralization is not a value in and of itself.\nAgain, we should consider what terminal value is actually being supported if we target decentralization in the Lightning layer.\n\nI would like to refer to the original Peter Todd hub-and-spoke model, where in a single server (hub) is used by multiple clients (spokes) to send offchain payments to one another.\nObviously this has no privacy from the single server, as the single server now knows exactly who pays and is paid for all transactions (though xref. Chaumian techniques such as TumbleBit).\n\nBy allowing multiple hubs, we get a little more privacy, as a cross-hub payment requires that multiple hubs cooperate to identify the ultimate sender and ultimate receiver of the payment.\nStill, with unpublished channels connecting \"hubs\" to \"spokes\", this allows such cooperation to be done and to properly identify every sender and receiver of every payment that goes through the cooperating parties.\n\nTo further increase privacy we truly need to destroy the separation of \"hub\" and \"spoke\".\nTo me, this is a form of decentralization, where there is no \"server\" and \"client\", but all nodes are equal peers.\n\nObviously not all nodes can be purely equal, as some nodes will have more liquidity available to them as an inherent part of the inequality of the universe.\nThe point is not to eliminate all inequality, but to reduce it to the minimum feasible, in order to promote certain properties, in this case, the valued Privacy Preservation.\nThus:\n\n* We should encourage people to at least increase the number of channels they have to the network.\n  Multipath helps with this.\n* We should discourage people from using completely unpublished channels, as this creates a (arguably not necessary) split between \"hub\" and \"spoke\".\n\nAdmittedly the goal may be too difficult in any case.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "On Path Privacy",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 28621
        }
    }
]