[
    {
        "title": "[Lightning-dev] Updated commitment design + Release thunder.network",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-06-01T06:47:33",
                "message_text_only": "Mats Jerratsch <mats at blockchain.com> writes:\n> Keep in mind though that only the revocation value is a private arrangement.\n> The dual-tx approach is backward compatible, meaning it is possible relaying payments with the old setup, with the cost of using long refund times. It is not possible to relay a payment that is optimised for dual-tx over hops that don\u2019t support it, because they would deduct their usual refund-time (often between 1-2 days per hop), leaving no room for the rest of the route.\n\nBut nodes need to publish their HTLC time subtraction anyway.  If\nthey're using dual-tx, that'll just be lower than otherwise.\n\nBTW, my prototype started by using times everywhere, but I'm switching\nto blocks.  The protobuf file supports both, but I now think that adds\ncomplexity.\n\nBlock counts are what active nodes care about, particularly when we're\ntalking about tight timings: I'm comfortable with a 6 block delay, but\nnot a 1 hour delay.\n\nAnd for larger counts, they're roughly convertible anyway (a UI problem,\nreally).\n\n> Yes when having multiple payments with different timeouts one has to keep track of when to broadcast which transaction, but this is similar to the current approach. It does make it significantly harder to transact sub-dust amounts though. For a 1 satoshi payments one would often pay >500 satoshi for claiming it on-chain.\n\nYou can't really create < 546 satoshi outputs anyway, since they'd be\nnon-standard ATM.  I currently keep those off-chain (they add to fees).\n\nA probabalistic scheme is possible, but it adds an extra round-trip (we\nboth need to generate the random number before we know what's in the tx\nto exchange signatures).\n\nAnd even then, you can decide to dump your tx onchain if it works in\nyour favour, so a probabalistic scheme is probably pointless.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Updated commitment design + Release thunder.network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1820
        }
    },
    {
        "title": "[Lightning-dev] [BOLT RFC#1] Encryption spec",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2016-06-26T11:53:11",
                "message_text_only": "Hi,\n\nI'm about to start implementing an encryption layer for Amiko Pay, and\nsince there already is a BOLT for encryption, I thought I might as well\nsee if I can use it. Now that I've read it[1], I have some questions.\n\nBut first, let me comment that, in general, I like the general design of\nthe encryption layer. It's generic and simple, making it easy to\nanalyze, which is A Good Thing.\n\nMy first question is: would it be possible / useful for a node to use\ndifferent public keys for different links? I guess it is possible: the\nnode that's establishing the connection knows what link it tries to\nconnect, so it can already send out an authenticate message. The other\nnode initially doesn't know what link the new connection belongs to,\nbut, after receiving the authenticate message, it knows, so it can\nselect its own corresponding key and reply with its own authenticate\nmessage. Then again, I'm not sure if this is very useful. Using\ndifferent keys could be good for privacy (not revealing that both links\ngo to the same node), but a node that listens for multiple links on the\nsame network location (e.g. host:port in TCP) already shows to its peers\nthat both links have a shared identity. The key used for authentication\ncould be different from keys used for other things, like routing\naddresses or output addresses of microtransaction channels, maybe linked\nin master/slave key configurations (one key signs the other). Maybe\nthere still is a deniability problem (your peer reveals data and you\nwant to say 'it wasn't me') but I'm not sure that can be solved.\n\nI was wondering to what degree communication truly looks like random\ndata, or can be distinguished from it. I guess that the very first 4\nbytes, usually being the little-endian value 33, already gives away that\nthis protocol is being used. Furthermore, timing analysis could reveal\nthe size of messages being sent, possibly revealing information about\nwhat is being done with the payload protocol inside the encryption\nlayer. Is there a way to protect against that? You might want to append\nunused data to messages to make them fixed size (or at least multiples\nof a fixed size), or random size, but that reduces bandwidth efficiency,\nand the required amount of padding depends on the payload protocol.\n\nHow is the authenticate message distinguished from other messages? I\ndon't see something like a message type ID. Is it simply that the first\nmessage in a session is ALWAYS an authenticate message, and other\nmessages are NEVER an authenticate message?\n\nRight now, the description of session_sig in the authenticate message\nsays: \"session_sig is the signature of the SHA256 of SHA256 of the\nreceivers node_id, using the secret key corresponding to the sender's\nnode_id\". I am not sure how that is useful. More importantly, I don't\nunderstand what stops someone from performing a MITM attack. Shouldn't\nyou include something like a signature of your sessionpubkey, signed\nwith your node_id key?\n\nAssuming that a MITM attacker can guess the boundaries of messages, what\nstops him/her from duplicating messages, or removing messages? Is a\ncertain state preserved between encryption/authentication of different\nmessages?\n\nWhat is the meaning of the ack field in the authenticate message? The\nnumber of non-authenticate messages before an authenticate message *in a\nsession* is always zero, isn't it? I see it's the number of messages\n*received and processed*. Since, to my knowledge, data streams in both\ndirections are asynchronous, that could be a non-deterministic value,\nright? What should a receiving node check about the ack value? If it\ncan't check anything, then what is the use of the value? Is this about\nmessage re-transmission across multiple sessions? In that case, please\nthink about wrap-around behavior. I'm not sure a 64-bit counter will\never wrap around, but we should make sure the first time it happens\nwon't be \"in the field\".\n\nthanks,\nCJP\n\n[1]\nhttps://github.com/rustyrussell/lightning-rfc/blob/master/bolts/01-encryption.md"
            },
            {
                "author": "Peter Todd",
                "date": "2016-06-26T22:27:20",
                "message_text_only": "On Sun, Jun 26, 2016 at 01:53:11PM +0200, CJP wrote:\n\nFYI, have you seen the work being done by Jonas Schnelli for Bitcoin on P at P\nlayer encryption?\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki\n\nHe's using a subset of the encryption scheme OpenSSH uses, which means he gets\nthe benefit of all the review that's been done for OpenSSH. If you use it, you\nget that benefit, as well as review from the Bitcoin Core team.\n\n> Hi,\n> \n> I'm about to start implementing an encryption layer for Amiko Pay, and\n> since there already is a BOLT for encryption, I thought I might as well\n> see if I can use it. Now that I've read it[1], I have some questions.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160626/9f455383/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-06-28T01:41:05",
                "message_text_only": "Peter Todd <pete at petertodd.org> writes:\n> On Sun, Jun 26, 2016 at 01:53:11PM +0200, CJP wrote:\n>\n> FYI, have you seen the work being done by Jonas Schnelli for Bitcoin on P at P\n> layer encryption?\n>\n> https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki\n>\n> He's using a subset of the encryption scheme OpenSSH uses, which means he gets\n> the benefit of all the review that's been done for OpenSSH. If you use it, you\n> get that benefit, as well as review from the Bitcoin Core team.\n\nYes, this draft predates that work, but it would be nicer.\n\nThey're pretty similar, let's see if we can make them closer.  Our\nneeds are slightly different: there's no \"unencrypted\" comms we need\nto bootstrap, and we want peer authentication always.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2016-06-28T02:43:09",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n> Hi,\n>\n> I'm about to start implementing an encryption layer for Amiko Pay, and\n> since there already is a BOLT for encryption, I thought I might as well\n> see if I can use it. Now that I've read it[1], I have some questions.\n\nGood!\n\n> But first, let me comment that, in general, I like the general design of\n> the encryption layer. It's generic and simple, making it easy to\n> analyze, which is A Good Thing.\n>\n> My first question is: would it be possible / useful for a node to use\n> different public keys for different links? I guess it is possible: the\n> node that's establishing the connection knows what link it tries to\n> connect, so it can already send out an authenticate message. The other\n> node initially doesn't know what link the new connection belongs to,\n> but, after receiving the authenticate message, it knows, so it can\n> select its own corresponding key and reply with its own authenticate\n> message. Then again, I'm not sure if this is very useful. Using\n> different keys could be good for privacy (not revealing that both links\n> go to the same node), but a node that listens for multiple links on the\n> same network location (e.g. host:port in TCP) already shows to its peers\n> that both links have a shared identity. The key used for authentication\n> could be different from keys used for other things, like routing\n> addresses or output addresses of microtransaction channels, maybe linked\n> in master/slave key configurations (one key signs the other). Maybe\n> there still is a deniability problem (your peer reveals data and you\n> want to say 'it wasn't me') but I'm not sure that can be solved.\n\nOne can imagine a front end cache which points to different backends\ndepending on who the incoming connection is for.  (The classic http\nmultihost problem).\n\nThis is one reason packets are extensible, if we turn out to want this\nin future.\n\n> I was wondering to what degree communication truly looks like random\n> data, or can be distinguished from it. I guess that the very first 4\n> bytes, usually being the little-endian value 33, already gives away that\n> this protocol is being used. Furthermore, timing analysis could reveal\n> the size of messages being sent, possibly revealing information about\n> what is being done with the payload protocol inside the encryption\n> layer. Is there a way to protect against that? You might want to append\n> unused data to messages to make them fixed size (or at least multiples\n> of a fixed size), or random size, but that reduces bandwidth efficiency,\n> and the required amount of padding depends on the payload protocol.\n\nThe lengths (after that first packet) are encrypted.  We can add ping\nand pong messages for dummies later if we want to, but solving traffic\nanalysis is not really a priority for now (AFAICT a bottomless well).\n\n> How is the authenticate message distinguished from other messages? I\n> don't see something like a message type ID. Is it simply that the first\n> message in a session is ALWAYS an authenticate message, and other\n> messages are NEVER an authenticate message?\n\nIt's a protobuf, like all messages.  We should probably mention that :)\n\n> Right now, the description of session_sig in the authenticate message\n> says: \"session_sig is the signature of the SHA256 of SHA256 of the\n> receivers node_id, using the secret key corresponding to the sender's\n> node_id\". I am not sure how that is useful. More importantly, I don't\n> understand what stops someone from performing a MITM attack. Shouldn't\n> you include something like a signature of your sessionpubkey, signed\n> with your node_id key?\n\nYes :(  It should sign the sessionpubkey of course.  I'll fix...\n\n> Assuming that a MITM attacker can guess the boundaries of messages, what\n> stops him/her from duplicating messages, or removing messages? Is a\n> certain state preserved between encryption/authentication of different\n> messages?\n\nThe nonce increments:\n\n Nonces are 64-bit little-endian numbers, which MUST begin at 0 and\n MUST be incremented after each encryption (ie. twice per message), such\n that headers are encrypted with even nonces and the message bodies\n encrypted with odd nonces.\n\n> What is the meaning of the ack field in the authenticate message? The\n> number of non-authenticate messages before an authenticate message *in a\n> session* is always zero, isn't it?\n\nIt's to resume existing sessions.  It's underspecified because I had not\nimplemented that (and my protocol test uses the count of commitments\nreceived, which turns out to be superior).\n\n> I see it's the number of messages\n> *received and processed*. Since, to my knowledge, data streams in both\n> directions are asynchronous, that could be a non-deterministic value,\n> right? What should a receiving node check about the ack value? If it\n> can't check anything, then what is the use of the value? Is this about\n> message re-transmission across multiple sessions? In that case, please\n> think about wrap-around behavior. I'm not sure a 64-bit counter will\n> ever wrap around, but we should make sure the first time it happens\n> won't be \"in the field\".\n\n64 bit counters won't wrap during my watch :)\n\nThanks,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Encryption spec",
            "categories": [
                "Lightning-dev",
                "BOLT RFC#1"
            ],
            "authors": [
                "Rusty Russell",
                "Peter Todd",
                "CJP"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 10963
        }
    }
]