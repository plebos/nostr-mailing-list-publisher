[
    {
        "title": "[Lightning-dev] Single channel on mobile clients",
        "thread_messages": [
            {
                "author": "Anton Kumaigorodskiy",
                "date": "2016-11-01T11:53:12",
                "message_text_only": "In general you are definitely right, having a single channel has it's drawbacks: relying on a single peer indeed makes a single point of failure and a possibility of earning some funds just by keeping an app running is attractive (although how large these fees will be is an open question, an anticipation is they will be extremely low, maybe won't even cover a channel opening costs for a long time if you're not a specialized relay node with a high throughput?). But I'm afraid there will be a lot of annoying details and edge cases:\n\n\n> I don't see a direct connection between UX and the fact that there are\n> multiple channels\n\nI'd argue if there are many channels on a phone which can relay 3rd party payments then user has to be made conscious of the following:\n\n- app should run at all times or else we risk the following scenario to happen: user opens an app, sends it to a background, while hanging in there it starts relaying another HTLC and system kills it in a few seconds or the battery foes down or system crashes (does happen rather often on Android). The next day user opens it and finds out a channel has been unilaterally closed because of HTLC expiration.\n\n- how many channels should be opened and what the fee per channel should be?\n- how many funds can be relayed at max? (to not interfere with user's payments as you have suggested)\n\nThese are a kind of questions a lot of users would not want to be asked, as a wallet developer I've had a fair amount of conversation with end users and I can confidently say most of them don't want to know how things specifically work, they just want an app to do it's job and get out of their way (which is totally fine but should be taken into account as we develop end user apps).\n\n\n> Combining multiple channels is trivial, and only the two endpoints\n> need to know how to do it\n\nAfter giving it some thought I see this is trivial, but also there seems to be an asymmetry: payee, when asked for payment, can generate multiple routes (and then an app can wait for all the requests to be fulfilled before it shows payment as \"done\" or we can have a notion of \"partial payment\" which becomes \"fully paid\" in the end), but payer, once received a single route, can't pay if no channel's capacity is sufficient. Payer has to somehow communicate beforehand that he needs multiple routes for a given sum which breaks simple scenarios like QR scanning.\n\n\n> The underlying connections do not actually have to\n> show up in the UX interface at all\n\nLet's assume we abstract all the underlying mechanics away: wallet automatically creates multiple channels and they are not displayed; user only sees a total balance across all channels. Let's also assume user can \"refill a balance\" which is done by opening an additional channel.\n\nNow here's a bad situation: Bob/Alice have a 2/15 SAT channel and Bob wants to conduct a 10 SAT transaction. He knows he has 2 SAT so he \"refills\" his \"account\" with 9 SAT and indeed sees 11 SAT as his new balance. He then scans Carol's QR and gets a single 10 SAT route but he can't pay because he only has 9 SAT and 2 SAT channels.\n\nPossible \"fixes\" are:\n1. Don't hide multiple balances, user have to understand that a balance is in fact multidimensional which alone may be too much for a lot a of people.\n2. Bilaterally close existing channels before creating new ones and recombine their balances which is no better than a single channel re-anchoring as described here: https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-May/000535.html\n\n\n> So if you find it easier to build the app assuming a single\n> channel, then that's perfectly fine\n\nThanks, I really do. Single channel does not solve all of these issues but at least makes them obvious to user: the balance is truly one-dimensional, no 3rd party HTLC can break channel if wallet is closed at a wrong time, etc. On the other hand, I do tend to make up problems sometimes and I'd be glad if I'm wrong about all of this.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161101/dc9e5dd7/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2016-11-06T18:00:26",
                "message_text_only": "On Tue, Nov 01, 2016 at 11:53:12AM +0000, Anton Kumaigorodskiy wrote:\n> In general you are definitely right, having a single channel has it's drawbacks: relying on a single peer indeed makes a single point of failure and a possibility of earning some funds just by keeping an app running is attractive (although how large these fees will be is an open question, an anticipation is they will be extremely low, maybe won't even cover a channel opening costs for a long time if you're not a specialized relay node with a high throughput?). But I'm afraid there will be a lot of annoying details and edge cases:\n\nYes, I see that there are quite a few things to nail down before a\nmobile user will want to participate in forwarding transfers. Opening\nmultiple channels is beneficial even without forwarding, for the\nsimple argument of fault tolerance. In addition it also increases\nprivacy since now a single node does not see all your transfer amount,\nand they can't be certain the payments actually originate from that\nuser. Having a wallet simply open a single channel by default would\nleak all its user's transfer amounts, making profiling very simple.\n\n> > I don't see a direct connection between UX and the fact that there are\n> > multiple channels\n> \n> I'd argue if there are many channels on a phone which can relay 3rd party payments then user has to be made conscious of the following:\n> \n> - app should run at all times or else we risk the following scenario to happen: user opens an app, sends it to a background, while hanging in there it starts relaying another HTLC and system kills it in a few seconds or the battery foes down or system crashes (does happen rather often on Android). The next day user opens it and finds out a channel has been unilaterally closed because of HTLC expiration.\n\nThat is indeed a major problem, and we'd need to handle this\ngracefully, maybe re-establishing channels that were settled ahead of\ntime. I agree that it should be as transparent as possible for the\nend-user.\n\n> - how many channels should be opened and what the fee per channel should be?\n> - how many funds can be relayed at max? (to not interfere with user's payments as you have suggested)\n> \n> These are a kind of questions a lot of users would not want to be asked, as a wallet developer I've had a fair amount of conversation with end users and I can confidently say most of them don't want to know how things specifically work, they just want an app to do it's job and get out of their way (which is totally fine but should be taken into account as we develop end user apps).\n\nAll of these are good questions, and to be honest I don't know the\nanswer, we can but speculate at this point. I do hope however that I\nbrought up a few points that help wallet implementors not dismiss\nmaintaining multiple channels right away.\n\n> > Combining multiple channels is trivial, and only the two endpoints\n> > need to know how to do it\n> \n> After giving it some thought I see this is trivial, but also there seems to be an asymmetry: payee, when asked for payment, can generate multiple routes (and then an app can wait for all the requests to be fulfilled before it shows payment as \"done\" or we can have a notion of \"partial payment\" which becomes \"fully paid\" in the end), but payer, once received a single route, can't pay if no channel's capacity is sufficient. Payer has to somehow communicate beforehand that he needs multiple routes for a given sum which breaks simple scenarios like QR scanning.\n\nWell, that is something we need to deal with anyway, capacity may be\ninsufficient at any point along the path(s) from the sender to the\nrecipient. The recipient can signal that it would accept multipath\ntransfers, and the client can decide whether to perform a multipath\npayment, that's not a big problem. But the client may construct a\nroute that has insufficient capacity at some point, this is true for\nboth the singlepath as well as the multipath transfer. At this point\nwe can only try again with a different path, but the retry logic is\nstill not worked out completely at this point.\n\n> > The underlying connections do not actually have to\n> > show up in the UX interface at all\n> \n> Let's assume we abstract all the underlying mechanics away: wallet automatically creates multiple channels and they are not displayed; user only sees a total balance across all channels. Let's also assume user can \"refill a balance\" which is done by opening an additional channel.\n> \n> Now here's a bad situation: Bob/Alice have a 2/15 SAT channel and Bob wants to conduct a 10 SAT transaction. He knows he has 2 SAT so he \"refills\" his \"account\" with 9 SAT and indeed sees 11 SAT as his new balance. He then scans Carol's QR and gets a single 10 SAT route but he can't pay because he only has 9 SAT and 2 SAT channels.\n> \n> Possible \"fixes\" are:\n> 1. Don't hide multiple balances, user have to understand that a balance is in fact multidimensional which alone may be too much for a lot a of people.\n> 2. Bilaterally close existing channels before creating new ones and recombine their balances which is no better than a single channel re-anchoring as described here: https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-May/000535.html\n\nYeah, that is a bit confusing. I think we can probably adopt the\nBitcoin model of having an available balance and an unconfirmed\nbalance (across all channels, not per channel). That way we signal\nthat Bob has 2 SAT available and he'll have to wait should he want to\ntransfer more than that. We have a mechanism that would allow splicing\nin new funds into a channel, so that we don't actually need multiple\nchannels between two endpoints. Funds from the old channel are still\navailable during this splicing, unlike the re-anchoring. That may\nsimplify the design a bit, since it makes channels unique per\nendpoint-tuple.\n\n> > So if you find it easier to build the app assuming a single\n> > channel, then that's perfectly fine\n> \n> Thanks, I really do. Single channel does not solve all of these issues but at least makes them obvious to user: the balance is truly one-dimensional, no 3rd party HTLC can break channel if wallet is closed at a wrong time, etc. On the other hand, I do tend to make up problems sometimes and I'd be glad if I'm wrong about all of this.\n\nNo, I think the points you raised are very interesting and real :-)\n\nLuckily I think that adding multiple channel support later, should we\nrealize that it is necessary, would be too hard, so let's start with\nthe simple system, and add features as we go along :-)\n\nCheers,\nChristian\n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anton Kumaigorodskiy",
                "date": "2016-11-07T19:58:54",
                "message_text_only": "> The recipient can signal that it would accept multipath\n> transfers, and the client can decide whether to perform a multipath\n> payment\n> At this point\n> we can only try again with a different path, but the retry logic is\n> still not worked out completely at this point.\n\nWhat if there was a special protocol for payment requests so that payer\nand payee could properly negotiate a number of routes and other details?\n\nFor example, a payee's QR code could contain not H(R)+routing but a server\naddress and other details sufficient for a payer to establish a connection\nwith payee's device, then ask for H(R)+routing, then re-ask again if it needs\nmore routes and again later if payment fails half-way. This seems appropriate\nsince both devices have to be online anyway to carry out the payment and there\ncan be many such maintenance servers, each coffee shop may have it's own.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161107/c6adf8af/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-11-07T22:19:48",
                "message_text_only": "Anton Kumaigorodskiy <anton.kumaigorodskiy at outlook.com> writes:\n>> The recipient can signal that it would accept multipath\n>> transfers, and the client can decide whether to perform a multipath\n>> payment\n>> At this point\n>> we can only try again with a different path, but the retry logic is\n>> still not worked out completely at this point.\n>\n> What if there was a special protocol for payment requests so that payer\n> and payee could properly negotiate a number of routes and other details?\n>\n> For example, a payee's QR code could contain not H(R)+routing but a server\n> address and other details sufficient for a payer to establish a connection\n> with payee's device, then ask for H(R)+routing, then re-ask again if it needs\n> more routes and again later if payment fails half-way. This seems appropriate\n> since both devices have to be online anyway to carry out the payment and there\n> can be many such maintenance servers, each coffee shop may have it's own.\n\nI prefer the QR code offering one or more routes from rendevous points,\nand the payer using some other method to find them (not more\ncommunication with the payee).\n\nGiven two paths to the payee A (D->C->B->A and G->F->E->A), client could\nstart by trying to reach the endpoints D or G, then try C, F, B, E\nbefore failing.\n\nOf course, if payment failure is common, then this may still be\ninsufficient.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Single channel on mobile clients",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anton Kumaigorodskiy",
                "Christian Decker"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 13384
        }
    },
    {
        "title": "[Lightning-dev] Analysis: alternative DoS prevention concept",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2016-11-10T23:11:54",
                "message_text_only": "Hi,\n\nThe problem\n===========\n\nOne major vulnerability of the Lightning network is that, if someone\nwants to perform a DoS attack on the network, that possible for the\nattacker by sending many large transactions to himself, over a long\nroute, and letting them time out (never reveal the payment pre-image).\nNobody (including the attacker) gains or loses any funds, but a lot of\nfunds get locked up, and the total cost of lost opportunity to innocent\nnodes is a lot higher than that of the attacker.\n\nIn Milan, we came to a solution for this DoS mode, where nodes require\neither a fast commit or roll-back within a short amount of time (say 30\nseconds), or a proof that another channel was closed. This increases the\ncost for the attacker with the cost of closing a channel (I'm not sure\nif it actually decreases the cost for honest nodes: a channel close is\nno proof that the pre-image won't be revealed, so the funds probably\nhave to stay locked up until the time-out anyway).\n\nI disliked this approach right from the moment it was proposed: it\nforces nodes to reveal, in certain situations, their channel state, to\nremote nodes, in a format that has to be understandable to those remote\nnodes. This basically limits the freedom in channel design to a design\nspace that can be understood by all nodes in the network. Any design\noutside that space requires all other nodes to upgrade; such an upgrade\nwould be very hard to deploy. Instead of being an individual decision\nbetween two peers, channel design now becomes a collective network\ndecision.\n\nThis interferes with my vision, presented in Montreal, of a\nheterogeneous network. Some examples of things that will become\nimpossible, or very difficult to accomplish:\n* Transparent routing between side chains: nodes that don't know about a\ncertain side chain can't verify a channel close on that side chain.\n* Trust-free de-centralized exchange between different block chains:\ndifferent block chains, so same story.\n* Trust-free de-centralized exchange of different assets on the same\nblock chain (e.g. colored coins): other nodes might reject this if they\ndon't understand the amount locked in the HTLC.\n* Channel design upgrade: we're probably first going to deploy Rusty's\nchannel design; I suppose some variation of the Poon/Dryja design will\nhave benefits over Rusty's design, once Bitcoin is ready for it. I\nexpect there will probably be other channel design upgrades in the\nfuture.\n\nProposed solution\n=================\n\nAs an alternative to the protection mechanism discussed in Milan, I\nexplored the possibility to let the payer of the transaction pay (a part\nof) the transaction fees at the start of the transaction (when locking\nfunds into HTLCs), such that, even in case of a roll-back, intermediate\nnodes would receive transaction fees. This could accomplish two goals:\n* compensate intermediate nodes for the damage inflicted on them by a\nDoS attack\n* put these costs onto the DoS attacker, thereby making the attack\nunattractive.\n\nTwo variations are explored: one where the in-advance fee is constant,\nand one where it depends on the time it takes for the transaction to\nroll back. The consequences for the intermediate node incentives in all\nsteps of the transaction are evaluated.\n\nResults\n=======\n\nhttps://cornwarecjp.github.io/amiko-pay/doc/lightning-incentives.ods\n\nThe spreadsheet is based on a rough estimate of what Lightning market\nconditions can look like.\n\nThe initial conclusion was optimistic: it is indeed possible to add such\nfees, up to a certain amount, without disturbing the incentives.\nHowever:\n* Given the assumptions in the spreadsheet, these fees can not be made\nhigh enough to fully compensate the intermediate nodes.\n* Since these fees are much smaller than the time value of the locked up\nmoney for a single node, they do not significantly impact an attacker\nwho is already prepared to bear these costs for his own node.\n* Since there is an upper limit to the size of the total fee, and the\ntotal fee increases with the length of the route, this solution does not\nscale well with the length of the route.\n* Even if it would work (with different parameters), having a security\nsolution that depends so much on market conditions is probably a bad\nidea, if we aren't really sure about these market conditions.\n\n\nConclusions / discussion\n========================\n\nAlthough I'd really like to see alternative ways to address this DoS\nmode, I don't see how this solution could help. So, sorry, it's a\nnegative result.\n\nThe only alternative I see so far is that peer relationships become\nsomewhat trusted, so that peers (implicitly) trust each other not to\nexpose each other to large numbers of long-duration transactions. It's\nnot clear though how nodes can live up to that expectation, especially\nwhen onion routing removes all information on the origin of\ntransactions.\n\nTo add a positive note: the way how the spreadsheet is set up might be\nof interest to you. Maybe you'd like to do some exploration of\nincentives for yourself in the future. The spreadsheet adds some insight\nin the orders of magnitude we could expect for certain parameters\n(although, ultimately, it will be up to the market to decide these). For\ninstance:\n* I expect both the occupation rate of channels and the fee rate of\nnodes to be pretty low, and still investing your funds in channels is\nquite profitable. This is because transactions tend to be pretty fast,\nso their fees add up pretty quickly when doing that over the course of a\nyear.\n* The time value of money lost to transactions that block all the way to\ntheir HTLC time-out is pretty huge compared to the tx fees. This is\nbecause HTLC time-out is typically a very long time compared to typical\nsuccessful transaction durations: in order to avoid DoS->theft\nescalation, intermediate nodes have to have a significant time-out\nincrement, so they can handle e.g. a local internet outage. This might\nbe different with Tadge's channel watching delegation though.\n\nIf you think I did anything wrong, or if you have any suggestions, let\nme know.\n\n- CJP"
            },
            {
                "author": "David A. Harding",
                "date": "2016-11-11T12:19:07",
                "message_text_only": "On Fri, Nov 11, 2016 at 12:11:54AM +0100, CJP wrote:\n> [...] possible for the attacker by sending many large transactions to\n> himself, over a long route, and letting them time out [...] a lot of\n> funds get locked up, and the total cost of lost opportunity to\n> innocent nodes is a lot higher than that of the attacker.\n>\n> [...] a solution for this DoS mode [is] where nodes require either a\n> fast commit or roll-back within a short amount of time (say 30\n> seconds), or a proof that another channel was closed\n>\n> [...] This basically limits the freedom in channel design to a design\n> space that can be understood by all nodes in the network.\n\n> Instead of being an individual decision between two peers, channel\n> design now becomes a collective network decision.  This interferes\n> with my vision, presented in Montreal, of a heterogeneous network. \n\nI'm trying to reason about this, and I may have made a mistake, but I\ndon't think this DoS mitigation proposal requires a homogeneous network\nbecause the only person from which you need to receive a (1) commit, (2)\nroll-back, or (3) channel close proof is your direct peer---so as long\nas your direct peer knows how to read the channel close proofs you\nprovide them, you can use any style channel close proofs you want.\n\nSo if we have Alice routing through Bob,\n\n    Alice -> Bob -> ?\n\nAlice has to understand whatever proofs Bob gives her.  But if Zed\nroutes through Alice (who routes through Bob),\n\n    Zed -> Alice -> Bob -> ?\n\nThen Zed doesn't need to understand Bob's proofs; he only needs to\nunderstand Alice's proofs, which could be for a different network or\nnetwork protocol than what Bob's using.\n\nTo be more specific, I'll work your examples below.\n\n> Some examples of things that will become impossible, or very difficult\n> to accomplish:\n> * Transparent routing between side chains: nodes that don't know about a\n> certain side chain can't verify a channel close on that side chain.\n> * Trust-free de-centralized exchange between different block chains:\n> different block chains, so same story.\n\nLet's imagine the following route:\n\n    [......bitcoin....] | [FooChain]\n                        |\n    Zed -> Alice -> Bob | Bob -> ?\n\n1. Zed tells Alice that he only knows about Bitcoin, and routes the\n   payment through her.\n\n2. Alice tells Bob that she knows about Bitcoin as well as FooChain, and\n   routes the payment through him.\n\n3. Bob has channels open both on Bitcoin and FooChain, and he routes the\n   payment to one of his peers on FooChain.\n\nIf,\n\n  a: Bob's peer tarpits the payment, Bob can close his FooChain channel\n     and show the proof to Alice (who knows about FooChain and can\n     understand the transaction).\n\n  Or,\n\n  b: Bob tarpits the the payment, Alice can close her Bitcoin channel to\n     Bob and show the proof to Zed (who doesn't need to know anything about\n     FooChain).\n\n  Or,\n\n  c: If Alice tarpits the payment, Zed can close his channel to Alice.\n\nSo, in this case, we have individual negotiation between peers about what\nblockchains they support, providing for heterogeneity among client\nimplementations.\n\n> * Trust-free de-centralized exchange of different assets on the same\n> block chain (e.g. colored coins): other nodes might reject this if they\n> don't understand the amount locked in the HTLC.\n\nI think this is the same story as above except instead of having assets\non both Bitcoin and FooChain, Bob has both satoshis and another\nblockchain asset (\"footoshis\").\n\n    [.....satoshis....] | [footoshis]\n                        |\n    Zed -> Alice -> Bob | Bob -> ?\n\n> * Channel design upgrade: we're probably first going to deploy Rusty's\n> channel design; I suppose some variation of the Poon/Dryja design will\n> have benefits over Rusty's design, once Bitcoin is ready for it. I\n> expect there will probably be other channel design upgrades in the\n> future.\n\nPeers can declare what protocol designs/versions they support, with any\npeer needing to match the version only among its peers, not among the\nwhole route (provided compatible hashlock mechanisms are used, which\nwould be a constraint on upgrading in any case).\n\n    Zed ->  Alice  -> Bob -> ?\n    [v1]   [v1,v2]    [v2]\n\nFor example, Zed may only understand protocol version 1 (v1), while\nAlice understand both v1 and v2, and Bob only understands v2.\n\n-Dave"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-11-14T04:08:27",
                "message_text_only": "\"David A. Harding\" <dave at dtrt.org> writes:\n> On Fri, Nov 11, 2016 at 12:11:54AM +0100, CJP wrote:\n>> [...] possible for the attacker by sending many large transactions to\n>> himself, over a long route, and letting them time out [...] a lot of\n>> funds get locked up, and the total cost of lost opportunity to\n>> innocent nodes is a lot higher than that of the attacker.\n>>\n>> [...] a solution for this DoS mode [is] where nodes require either a\n>> fast commit or roll-back within a short amount of time (say 30\n>> seconds), or a proof that another channel was closed\n>>\n>> [...] This basically limits the freedom in channel design to a design\n>> space that can be understood by all nodes in the network.\n>\n>> Instead of being an individual decision between two peers, channel\n>> design now becomes a collective network decision.  This interferes\n>> with my vision, presented in Montreal, of a heterogeneous network. \n>\n> I'm trying to reason about this, and I may have made a mistake, but I\n> don't think this DoS mitigation proposal requires a homogeneous network\n> because the only person from which you need to receive a (1) commit, (2)\n> roll-back, or (3) channel close proof is your direct peer---so as long\n> as your direct peer knows how to read the channel close proofs you\n> provide them, you can use any style channel close proofs you want.\n\nUnfortunately, the proposal is to route the information back, to prove\nsomebody was punished for the delay.\n\nThat *is* fairly incompatible with crossing networks, since the risk is\nnow borne by the node doing the crossing (and its neighbor).  Alice will\nalways have to close with Bob in your example.\n\nPerhaps Bob will simply charge an exchange premium for this risk, but\nI feel sorry for Alice; it seems to increase risk overall to the\nnetwork since the attacker does not have to close her own channels now.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Analysis: alternative DoS prevention concept",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "CJP"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12271
        }
    },
    {
        "title": "[Lightning-dev] BIP status updates & BIP 2 activation",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-11-30T10:20:30",
                "message_text_only": "To conclude discussion on BIP 2, I have opened a pull request to implement it \nand mark it active. Note this implies activation and implementation of BIP 123 \nas well: https://github.com/bitcoin/bips/pull/478\n\nI plan to merge this on December 14th. If there are any hard objections to \nthis change, please bring it up on the bitcoin-dev mailing list before then. \nFurther reviews of the implementation are welcome in the meantime. Please \nrefrain from requesting further changes to the BIPs themselves unless it is a \nblocker/show-stopper or trivial (not changing the meaning).\n\nIn the process of implementing BIP 2, I came across a number of BIPs which \nmanaged to get into the repository without a proper license. Authors of any of \nthese BIPs should open a pull request adding the necessary Copyright section \nand License header(s). (If there are other contributors to the document in the \nBIP git logs, I will try to reach out to them to get permission. If you have \naccepted contributions from anyone not documented in git as an Author, please \nmention this in the PR explicitly.)\n\nThese BIPs need a license:\n 001  BIP Purpose and Guidelines\n 010  Multi-Sig Transaction Distribution\n 011  M-of-N Standard Transactions\n 012  OP_EVAL\n 013  Address Format for pay-to-script-hash\n 014  Protocol Version and User Agent\n 015  Aliases\n 016  Pay to Script Hash\n 021  URI Scheme\n 030  Duplicate transactions\n 031  Pong message\n 032  Hierarchical Deterministic Wallets\n 033  Stratized Nodes\n 034  Block v2, Height in Coinbase\n 035  mempool message\n 039  Mnemonic code for generating deterministic keys\n 043  Purpose Field for Deterministic Wallets\n 044  Multi-Account Hierarchy for Deterministic Wallets\n 045  Structure for Deterministic P2SH Multisignature Wallets\n 047  Reusable Payment Codes for Hierarchical Deterministic Wallets\n 061  Reject P2P message\n 062  Dealing with malleability\n 064  getutxo message\n 066  Strict DER signatures\n 067  Deterministic Pay-to-script-hash multi-signature addresses through\n          public key sorting\n 068  Relative lock-time using consensus-enforced sequence numbers\n 070  Payment Protocol\n 071  Payment Protocol MIME types\n 072  bitcoin: uri extensions for Payment Protocol\n 073  Use \"Accept\" header for response type negotiation with Payment Request\n          URLs\n 075  Out of Band Address Exchange using Payment Protocol Encryption\n 101  Increase maximum block size\n 102  Block size increase to 2MB\n 103  Block size following technological growth\n 106  Dynamically Controlled Bitcoin Block Size Max Cap\n 120  Proof of Payment\n 121  Proof of Payment URI scheme\n 123  BIP Classification\n\nThanks,\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "BIP status updates & BIP 2 activation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2641
        }
    }
]