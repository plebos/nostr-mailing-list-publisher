[
    {
        "title": "[Lightning-dev] [Pre-BIP] Fee Accounts",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2022-01-01T20:04:00",
                "message_text_only": "Happy new years devs,\n\nI figured I would share some thoughts for conceptual review that have been\nbouncing around my head as an opportunity to clean up the fee paying\nsemantics in bitcoin \"for good\". The design space is very wide on the\napproach I'll share, so below is just a sketch of how it could work which\nI'm sure could be improved greatly.\n\nTransaction fees are an integral part of bitcoin.\n\nHowever, due to quirks of Bitcoin's transaction design, fees are a part of\nthe transactions that they occur in.\n\nWhile this works in a \"Bitcoin 1.0\" world, where all transactions are\nsimple on-chain transfers, real world use of Bitcoin requires support for\nthings like Fee Bumping stuck transactions, DoS resistant Payment Channels,\nand other long lived Smart Contracts that can't predict future fee rates.\nHaving the fees paid in band makes writing these contracts much more\ndifficult as you can't merely express the logic you want for the\ntransaction, but also the fees.\n\nPreviously, I proposed a special type of transaction called a \"Sponsor\"\nwhich has some special consensus + mempool rules to allow arbitrarily\nappending fees to a transaction to bump it up in the mempool.\n\nAs an alternative, we could establish an account system in Bitcoin as an\n\"extension block\".\n\n*Here's how it might work:*\n\n1. Define a special anyone can spend output type that is a \"fee account\"\n(e.g. segwit V2). Such outputs have a redeeming key and an amount\nassociated with them, but are overall anyone can spend.\n2. All deposits to these outputs get stored in a separate UTXO database for\nfee accounts\n3. Fee accounts can sign only two kinds of transaction: A: a fee amount and\na TXID (or Outpoint?); B: a withdraw amount, a fee, and an address\n4. These transactions are committed in an extension block merkle tree.\nWhile the actual signature must cover the TXID/Outpoint, the committed data\nneed only cover the index in the block of the transaction. The public key\nfor account lookup can be recovered from the message + signature.\n5. In any block, any of the fee account deposits can be: released into fees\nif there is a corresponding tx; consolidated together to reduce the number\nof utxos (this can be just an OP_TRUE no metadata needed); or released into\nfees *and paid back* into the requested withdrawal key (encumbering a 100\nblock timeout). Signatures must be unique in a block.\n6. Mempool logic is updated to allow attaching of account fee spends to\ntransactions, the mempool can restrict that an account is not allowed more\nspend more than it's balance.\n\n*But aren't accounts \"bad\"?*\n\nYes, accounts are bad. But these accounts are not bad, because any funds\nwithdrawn from the fee extension are fundamentally locked for 100 blocks as\na coinbase output, so there should be no issues with any series of reorgs.\nFurther, since there is no \"rich state\" for these accounts, the state\nupdates can always be applied in a conflict-free way in any order.\n\n\n*Improving the privacy of this design:*\n\nThis design could likely be modified to implement something like\nTornado.cash or something else so that the fee account paying can be\nunlinked from the transaction being paid for, improving privacy at the\nexpense of being a bit more expensive.\n\nOther operations could be added to allow a trustless mixing to be done by\nminers automatically where groups of accounts with similar values are\ntrustlessly  split into a common denominator and change, and keys are\nderived via a verifiable stealth address like protocol (so fee balances can\nbe discovered by tracing the updates posted). These updates could also be\nproduced by individuals rather than miners, and miners could simply honor\nthem with better privacy. While a miner generating an update would be able\nto deanonymize their mixes, if you have your account mixed several times by\nindependent miners that could potentially add sufficient privacy.\n\nThe LN can also be used with PTLCs to, in theory, have another individual\npaid to sponsor a transaction on your behalf only if they reveal a valid\nsig from their fee paying account, although under this model it's hard to\nensure that the owner doesn't pay a fee and then 'cancel' by withdrawing\nthe rest. However, this could be partly solved by using reputable fee\naccounts (reputation could be measured somewhat decentralized-ly by\nlongevity of the account and transactions paid for historically).\n\n*Scalability*\n\nThis design is fundamentally 'decent' for scalability because adding fees\nto a transaction does not require adding inputs or outputs and does not\nrequire tracking substantial amounts of new state.\n\nPaying someone else to pay for you via the LN also helps make this more\nefficient if the withdrawal issues can be fixed.\n\n*Lightning:*\n\nThis type of design works really well for channels because the addition of\nfees to e.g. a channel state does not require any sort of pre-planning\n(e.g. anchors) or transaction flexibility (SIGHASH flags). This sort of\ndesign is naturally immune to pinning issues since you could offer to pay a\nfee for any TXID and the number of fee adding offers does not need to be\nrestricted in the same way the descendant transactions would need to be.\n\n*Without a fork?*\n\nThis type of design could be done as a federated network that bribes miners\n-- potentially even retroactively after a block is formed. That might be\nsufficient to prove the concept works before a consensus upgrade is\ndeployed, but such an approach does mean there is a centralizing layer\ninterfering with normal mining.\n\n\nHappy new year!!\n\nJeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220101/4cd5c38b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fee Accounts",
            "categories": [
                "Lightning-dev",
                "Pre-BIP"
            ],
            "authors": [
                "Jeremy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5806
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] [Pre-BIP] Fee Accounts",
        "thread_messages": [
            {
                "author": "Billy Tetrud",
                "date": "2022-01-18T16:12:36",
                "message_text_only": "Do you have any back-of-the-napkin math on quantifying how much this would\nimprove the situation vs existing methods (eg cpfp)?\n\n\n\nOn Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Happy new years devs,\n>\n> I figured I would share some thoughts for conceptual review that have been\n> bouncing around my head as an opportunity to clean up the fee paying\n> semantics in bitcoin \"for good\". The design space is very wide on the\n> approach I'll share, so below is just a sketch of how it could work which\n> I'm sure could be improved greatly.\n>\n> Transaction fees are an integral part of bitcoin.\n>\n> However, due to quirks of Bitcoin's transaction design, fees are a part of\n> the transactions that they occur in.\n>\n> While this works in a \"Bitcoin 1.0\" world, where all transactions are\n> simple on-chain transfers, real world use of Bitcoin requires support for\n> things like Fee Bumping stuck transactions, DoS resistant Payment Channels,\n> and other long lived Smart Contracts that can't predict future fee rates.\n> Having the fees paid in band makes writing these contracts much more\n> difficult as you can't merely express the logic you want for the\n> transaction, but also the fees.\n>\n> Previously, I proposed a special type of transaction called a \"Sponsor\"\n> which has some special consensus + mempool rules to allow arbitrarily\n> appending fees to a transaction to bump it up in the mempool.\n>\n> As an alternative, we could establish an account system in Bitcoin as an\n> \"extension block\".\n>\n> *Here's how it might work:*\n>\n> 1. Define a special anyone can spend output type that is a \"fee account\"\n> (e.g. segwit V2). Such outputs have a redeeming key and an amount\n> associated with them, but are overall anyone can spend.\n> 2. All deposits to these outputs get stored in a separate UTXO database\n> for fee accounts\n> 3. Fee accounts can sign only two kinds of transaction: A: a fee amount\n> and a TXID (or Outpoint?); B: a withdraw amount, a fee, and an address\n> 4. These transactions are committed in an extension block merkle tree.\n> While the actual signature must cover the TXID/Outpoint, the committed data\n> need only cover the index in the block of the transaction. The public key\n> for account lookup can be recovered from the message + signature.\n> 5. In any block, any of the fee account deposits can be: released into\n> fees if there is a corresponding tx; consolidated together to reduce the\n> number of utxos (this can be just an OP_TRUE no metadata needed); or\n> released into fees *and paid back* into the requested withdrawal key\n> (encumbering a 100 block timeout). Signatures must be unique in a block.\n> 6. Mempool logic is updated to allow attaching of account fee spends to\n> transactions, the mempool can restrict that an account is not allowed more\n> spend more than it's balance.\n>\n> *But aren't accounts \"bad\"?*\n>\n> Yes, accounts are bad. But these accounts are not bad, because any funds\n> withdrawn from the fee extension are fundamentally locked for 100 blocks as\n> a coinbase output, so there should be no issues with any series of reorgs.\n> Further, since there is no \"rich state\" for these accounts, the state\n> updates can always be applied in a conflict-free way in any order.\n>\n>\n> *Improving the privacy of this design:*\n>\n> This design could likely be modified to implement something like\n> Tornado.cash or something else so that the fee account paying can be\n> unlinked from the transaction being paid for, improving privacy at the\n> expense of being a bit more expensive.\n>\n> Other operations could be added to allow a trustless mixing to be done by\n> miners automatically where groups of accounts with similar values are\n> trustlessly  split into a common denominator and change, and keys are\n> derived via a verifiable stealth address like protocol (so fee balances can\n> be discovered by tracing the updates posted). These updates could also be\n> produced by individuals rather than miners, and miners could simply honor\n> them with better privacy. While a miner generating an update would be able\n> to deanonymize their mixes, if you have your account mixed several times by\n> independent miners that could potentially add sufficient privacy.\n>\n> The LN can also be used with PTLCs to, in theory, have another individual\n> paid to sponsor a transaction on your behalf only if they reveal a valid\n> sig from their fee paying account, although under this model it's hard to\n> ensure that the owner doesn't pay a fee and then 'cancel' by withdrawing\n> the rest. However, this could be partly solved by using reputable fee\n> accounts (reputation could be measured somewhat decentralized-ly by\n> longevity of the account and transactions paid for historically).\n>\n> *Scalability*\n>\n> This design is fundamentally 'decent' for scalability because adding fees\n> to a transaction does not require adding inputs or outputs and does not\n> require tracking substantial amounts of new state.\n>\n> Paying someone else to pay for you via the LN also helps make this more\n> efficient if the withdrawal issues can be fixed.\n>\n> *Lightning:*\n>\n> This type of design works really well for channels because the addition of\n> fees to e.g. a channel state does not require any sort of pre-planning\n> (e.g. anchors) or transaction flexibility (SIGHASH flags). This sort of\n> design is naturally immune to pinning issues since you could offer to pay a\n> fee for any TXID and the number of fee adding offers does not need to be\n> restricted in the same way the descendant transactions would need to be.\n>\n> *Without a fork?*\n>\n> This type of design could be done as a federated network that bribes\n> miners -- potentially even retroactively after a block is formed. That\n> might be sufficient to prove the concept works before a consensus upgrade\n> is deployed, but such an approach does mean there is a centralizing layer\n> interfering with normal mining.\n>\n>\n> Happy new year!!\n>\n> Jeremy\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220118/655b3d36/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2022-01-18T17:43:07",
                "message_text_only": "Can you clarify what you mean by \"improve the situation\"?\n\nThere's a potential mild bytes savings, but the bigger deal is that the API\nshould be much less vulnerable to pinning issues, fix dust leakage for\neltoo like protocols, and just generally allow protocol designs to be fully\nabstracted from paying fees. You can't easily mathematically quantify API\nimprovements like that.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com> wrote:\n\n> Do you have any back-of-the-napkin math on quantifying how much this would\n> improve the situation vs existing methods (eg cpfp)?\n>\n>\n>\n> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Happy new years devs,\n>>\n>> I figured I would share some thoughts for conceptual review that have\n>> been bouncing around my head as an opportunity to clean up the fee paying\n>> semantics in bitcoin \"for good\". The design space is very wide on the\n>> approach I'll share, so below is just a sketch of how it could work which\n>> I'm sure could be improved greatly.\n>>\n>> Transaction fees are an integral part of bitcoin.\n>>\n>> However, due to quirks of Bitcoin's transaction design, fees are a part\n>> of the transactions that they occur in.\n>>\n>> While this works in a \"Bitcoin 1.0\" world, where all transactions are\n>> simple on-chain transfers, real world use of Bitcoin requires support for\n>> things like Fee Bumping stuck transactions, DoS resistant Payment Channels,\n>> and other long lived Smart Contracts that can't predict future fee rates.\n>> Having the fees paid in band makes writing these contracts much more\n>> difficult as you can't merely express the logic you want for the\n>> transaction, but also the fees.\n>>\n>> Previously, I proposed a special type of transaction called a \"Sponsor\"\n>> which has some special consensus + mempool rules to allow arbitrarily\n>> appending fees to a transaction to bump it up in the mempool.\n>>\n>> As an alternative, we could establish an account system in Bitcoin as an\n>> \"extension block\".\n>>\n>> *Here's how it might work:*\n>>\n>> 1. Define a special anyone can spend output type that is a \"fee account\"\n>> (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>> associated with them, but are overall anyone can spend.\n>> 2. All deposits to these outputs get stored in a separate UTXO database\n>> for fee accounts\n>> 3. Fee accounts can sign only two kinds of transaction: A: a fee amount\n>> and a TXID (or Outpoint?); B: a withdraw amount, a fee, and an address\n>> 4. These transactions are committed in an extension block merkle tree.\n>> While the actual signature must cover the TXID/Outpoint, the committed data\n>> need only cover the index in the block of the transaction. The public key\n>> for account lookup can be recovered from the message + signature.\n>> 5. In any block, any of the fee account deposits can be: released into\n>> fees if there is a corresponding tx; consolidated together to reduce the\n>> number of utxos (this can be just an OP_TRUE no metadata needed); or\n>> released into fees *and paid back* into the requested withdrawal key\n>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>> 6. Mempool logic is updated to allow attaching of account fee spends to\n>> transactions, the mempool can restrict that an account is not allowed more\n>> spend more than it's balance.\n>>\n>> *But aren't accounts \"bad\"?*\n>>\n>> Yes, accounts are bad. But these accounts are not bad, because any funds\n>> withdrawn from the fee extension are fundamentally locked for 100 blocks as\n>> a coinbase output, so there should be no issues with any series of reorgs.\n>> Further, since there is no \"rich state\" for these accounts, the state\n>> updates can always be applied in a conflict-free way in any order.\n>>\n>>\n>> *Improving the privacy of this design:*\n>>\n>> This design could likely be modified to implement something like\n>> Tornado.cash or something else so that the fee account paying can be\n>> unlinked from the transaction being paid for, improving privacy at the\n>> expense of being a bit more expensive.\n>>\n>> Other operations could be added to allow a trustless mixing to be done by\n>> miners automatically where groups of accounts with similar values are\n>> trustlessly  split into a common denominator and change, and keys are\n>> derived via a verifiable stealth address like protocol (so fee balances can\n>> be discovered by tracing the updates posted). These updates could also be\n>> produced by individuals rather than miners, and miners could simply honor\n>> them with better privacy. While a miner generating an update would be able\n>> to deanonymize their mixes, if you have your account mixed several times by\n>> independent miners that could potentially add sufficient privacy.\n>>\n>> The LN can also be used with PTLCs to, in theory, have another individual\n>> paid to sponsor a transaction on your behalf only if they reveal a valid\n>> sig from their fee paying account, although under this model it's hard to\n>> ensure that the owner doesn't pay a fee and then 'cancel' by withdrawing\n>> the rest. However, this could be partly solved by using reputable fee\n>> accounts (reputation could be measured somewhat decentralized-ly by\n>> longevity of the account and transactions paid for historically).\n>>\n>> *Scalability*\n>>\n>> This design is fundamentally 'decent' for scalability because adding fees\n>> to a transaction does not require adding inputs or outputs and does not\n>> require tracking substantial amounts of new state.\n>>\n>> Paying someone else to pay for you via the LN also helps make this more\n>> efficient if the withdrawal issues can be fixed.\n>>\n>> *Lightning:*\n>>\n>> This type of design works really well for channels because the addition\n>> of fees to e.g. a channel state does not require any sort of pre-planning\n>> (e.g. anchors) or transaction flexibility (SIGHASH flags). This sort of\n>> design is naturally immune to pinning issues since you could offer to pay a\n>> fee for any TXID and the number of fee adding offers does not need to be\n>> restricted in the same way the descendant transactions would need to be.\n>>\n>> *Without a fork?*\n>>\n>> This type of design could be done as a federated network that bribes\n>> miners -- potentially even retroactively after a block is formed. That\n>> might be sufficient to prove the concept works before a consensus upgrade\n>> is deployed, but such an approach does mean there is a centralizing layer\n>> interfering with normal mining.\n>>\n>>\n>> Happy new year!!\n>>\n>> Jeremy\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220118/d8324802/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-01-19T02:37:39",
                "message_text_only": "I see, its not primarily to make it cheaper to append fees, but also allows\nappending fees in cases that aren't possible now. Is that right? I can\ncertainly see the benefit of a more general way to add a fee to any\ntransaction, regardless of whether you're related to that transaction or\nnot.\n\nHow would you compare the pros and cons of your account-based approach to\nsomething like a new sighash flag? Eg a sighash flag that says \"I'm signing\nthis transaction, but the signature is only valid if mined in the same\nblock as transaction X (or maybe transactions LIST)\". This could be named\nSIGHASH_EXTERNAL. Doing this would be a lot more similar to other bitcoin\ntransactions, and no special account would need to be created. Any\ntransaction could specify this. At least that's the first thought I would\nhave in designing a way to arbitrarily bump fees. Have you compared your\nsolution to something more familiar like that?\n\nOn Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n\n> Can you clarify what you mean by \"improve the situation\"?\n>\n> There's a potential mild bytes savings, but the bigger deal is that the\n> API should be much less vulnerable to pinning issues, fix dust leakage for\n> eltoo like protocols, and just generally allow protocol designs to be fully\n> abstracted from paying fees. You can't easily mathematically quantify API\n> improvements like that.\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n> wrote:\n>\n>> Do you have any back-of-the-napkin math on quantifying how much this\n>> would improve the situation vs existing methods (eg cpfp)?\n>>\n>>\n>>\n>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Happy new years devs,\n>>>\n>>> I figured I would share some thoughts for conceptual review that have\n>>> been bouncing around my head as an opportunity to clean up the fee paying\n>>> semantics in bitcoin \"for good\". The design space is very wide on the\n>>> approach I'll share, so below is just a sketch of how it could work which\n>>> I'm sure could be improved greatly.\n>>>\n>>> Transaction fees are an integral part of bitcoin.\n>>>\n>>> However, due to quirks of Bitcoin's transaction design, fees are a part\n>>> of the transactions that they occur in.\n>>>\n>>> While this works in a \"Bitcoin 1.0\" world, where all transactions are\n>>> simple on-chain transfers, real world use of Bitcoin requires support for\n>>> things like Fee Bumping stuck transactions, DoS resistant Payment Channels,\n>>> and other long lived Smart Contracts that can't predict future fee rates.\n>>> Having the fees paid in band makes writing these contracts much more\n>>> difficult as you can't merely express the logic you want for the\n>>> transaction, but also the fees.\n>>>\n>>> Previously, I proposed a special type of transaction called a \"Sponsor\"\n>>> which has some special consensus + mempool rules to allow arbitrarily\n>>> appending fees to a transaction to bump it up in the mempool.\n>>>\n>>> As an alternative, we could establish an account system in Bitcoin as an\n>>> \"extension block\".\n>>>\n>>> *Here's how it might work:*\n>>>\n>>> 1. Define a special anyone can spend output type that is a \"fee account\"\n>>> (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>> associated with them, but are overall anyone can spend.\n>>> 2. All deposits to these outputs get stored in a separate UTXO database\n>>> for fee accounts\n>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee amount\n>>> and a TXID (or Outpoint?); B: a withdraw amount, a fee, and an address\n>>> 4. These transactions are committed in an extension block merkle tree.\n>>> While the actual signature must cover the TXID/Outpoint, the committed data\n>>> need only cover the index in the block of the transaction. The public key\n>>> for account lookup can be recovered from the message + signature.\n>>> 5. In any block, any of the fee account deposits can be: released into\n>>> fees if there is a corresponding tx; consolidated together to reduce the\n>>> number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>> released into fees *and paid back* into the requested withdrawal key\n>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>> 6. Mempool logic is updated to allow attaching of account fee spends to\n>>> transactions, the mempool can restrict that an account is not allowed more\n>>> spend more than it's balance.\n>>>\n>>> *But aren't accounts \"bad\"?*\n>>>\n>>> Yes, accounts are bad. But these accounts are not bad, because any funds\n>>> withdrawn from the fee extension are fundamentally locked for 100 blocks as\n>>> a coinbase output, so there should be no issues with any series of reorgs.\n>>> Further, since there is no \"rich state\" for these accounts, the state\n>>> updates can always be applied in a conflict-free way in any order.\n>>>\n>>>\n>>> *Improving the privacy of this design:*\n>>>\n>>> This design could likely be modified to implement something like\n>>> Tornado.cash or something else so that the fee account paying can be\n>>> unlinked from the transaction being paid for, improving privacy at the\n>>> expense of being a bit more expensive.\n>>>\n>>> Other operations could be added to allow a trustless mixing to be done\n>>> by miners automatically where groups of accounts with similar values are\n>>> trustlessly  split into a common denominator and change, and keys are\n>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>> be discovered by tracing the updates posted). These updates could also be\n>>> produced by individuals rather than miners, and miners could simply honor\n>>> them with better privacy. While a miner generating an update would be able\n>>> to deanonymize their mixes, if you have your account mixed several times by\n>>> independent miners that could potentially add sufficient privacy.\n>>>\n>>> The LN can also be used with PTLCs to, in theory, have another\n>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>> a valid sig from their fee paying account, although under this model it's\n>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>> withdrawing the rest. However, this could be partly solved by using\n>>> reputable fee accounts (reputation could be measured somewhat\n>>> decentralized-ly by longevity of the account and transactions paid for\n>>> historically).\n>>>\n>>> *Scalability*\n>>>\n>>> This design is fundamentally 'decent' for scalability because adding\n>>> fees to a transaction does not require adding inputs or outputs and does\n>>> not require tracking substantial amounts of new state.\n>>>\n>>> Paying someone else to pay for you via the LN also helps make this more\n>>> efficient if the withdrawal issues can be fixed.\n>>>\n>>> *Lightning:*\n>>>\n>>> This type of design works really well for channels because the addition\n>>> of fees to e.g. a channel state does not require any sort of pre-planning\n>>> (e.g. anchors) or transaction flexibility (SIGHASH flags). This sort of\n>>> design is naturally immune to pinning issues since you could offer to pay a\n>>> fee for any TXID and the number of fee adding offers does not need to be\n>>> restricted in the same way the descendant transactions would need to be.\n>>>\n>>> *Without a fork?*\n>>>\n>>> This type of design could be done as a federated network that bribes\n>>> miners -- potentially even retroactively after a block is formed. That\n>>> might be sufficient to prove the concept works before a consensus upgrade\n>>> is deployed, but such an approach does mean there is a centralizing layer\n>>> interfering with normal mining.\n>>>\n>>>\n>>> Happy new year!!\n>>>\n>>> Jeremy\n>>>\n>>> --\n>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>> <https://twitter.com/JeremyRubin>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220118/3c72c1c7/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2022-01-19T02:51:42",
                "message_text_only": "The issue with sighash flags is that because you make transactions third\nparty malleable it becomes possible to bundle and unbundle transactions.\n\nThis means there are circumstances where an attacker could e.g. see your\ntxn, and then add a lot of junk change/inputs + 25 descendants and strongly\nanchor your transaction to the bottom of the mempool.\n\nbecause of rbf rules requiring more fee and feerate, this means you have to\nbump across the whole package and that can get really messy.\n\nmore generally speaking, you could imagine a future where mempools track\nmany alternative things that might want to be in a transaction.\n\nsuppose there are N inputs each with a weight and an amount of fee being\nadded and the sighash flags let me pick any subset of them. However, for a\ntxn to be standard it must be < 100k bytes and for it to be consensus <\n1mb. Now it is possible you have to solve a knapsack problem in order to\nrationally bundle this transaction out of all possibilities.\n\nThis problem can get even thornier, suppose that the inputs I'm adding\nthemselves are the outputs of another txn in the mempool, now i have to\ntrack and propagate the feerates of that child back up to the parent txn\nand track all these dependencies.\n\nperhaps with very careful engineering these issues can be tamed. however it\nseems with sponsors or fee accounts, by separating the pays-for from the\nparticipates-in concerns we can greatly simplify it to something like:\ncompute effective feerate for a txn, including all sponsors that pay more\nthan the feerate of the base txn. Mine that txn and it's subsidies using\nthe normal algo. If you run out of space, all subsidies are same-sized so\njust take the ones that pay the highest amount up until the added marginal\nfeerate is less than the next eligible txn.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Tue, Jan 18, 2022 at 6:38 PM Billy Tetrud <billy.tetrud at gmail.com> wrote:\n\n> I see, its not primarily to make it cheaper to append fees, but also\n> allows appending fees in cases that aren't possible now. Is that right? I\n> can certainly see the benefit of a more general way to add a fee to any\n> transaction, regardless of whether you're related to that transaction or\n> not.\n>\n> How would you compare the pros and cons of your account-based approach to\n> something like a new sighash flag? Eg a sighash flag that says \"I'm signing\n> this transaction, but the signature is only valid if mined in the same\n> block as transaction X (or maybe transactions LIST)\". This could be named\n> SIGHASH_EXTERNAL. Doing this would be a lot more similar to other bitcoin\n> transactions, and no special account would need to be created. Any\n> transaction could specify this. At least that's the first thought I would\n> have in designing a way to arbitrarily bump fees. Have you compared your\n> solution to something more familiar like that?\n>\n> On Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n>\n>> Can you clarify what you mean by \"improve the situation\"?\n>>\n>> There's a potential mild bytes savings, but the bigger deal is that the\n>> API should be much less vulnerable to pinning issues, fix dust leakage for\n>> eltoo like protocols, and just generally allow protocol designs to be fully\n>> abstracted from paying fees. You can't easily mathematically quantify API\n>> improvements like that.\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>>\n>>\n>> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n>> wrote:\n>>\n>>> Do you have any back-of-the-napkin math on quantifying how much this\n>>> would improve the situation vs existing methods (eg cpfp)?\n>>>\n>>>\n>>>\n>>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Happy new years devs,\n>>>>\n>>>> I figured I would share some thoughts for conceptual review that have\n>>>> been bouncing around my head as an opportunity to clean up the fee paying\n>>>> semantics in bitcoin \"for good\". The design space is very wide on the\n>>>> approach I'll share, so below is just a sketch of how it could work which\n>>>> I'm sure could be improved greatly.\n>>>>\n>>>> Transaction fees are an integral part of bitcoin.\n>>>>\n>>>> However, due to quirks of Bitcoin's transaction design, fees are a part\n>>>> of the transactions that they occur in.\n>>>>\n>>>> While this works in a \"Bitcoin 1.0\" world, where all transactions are\n>>>> simple on-chain transfers, real world use of Bitcoin requires support for\n>>>> things like Fee Bumping stuck transactions, DoS resistant Payment Channels,\n>>>> and other long lived Smart Contracts that can't predict future fee rates.\n>>>> Having the fees paid in band makes writing these contracts much more\n>>>> difficult as you can't merely express the logic you want for the\n>>>> transaction, but also the fees.\n>>>>\n>>>> Previously, I proposed a special type of transaction called a \"Sponsor\"\n>>>> which has some special consensus + mempool rules to allow arbitrarily\n>>>> appending fees to a transaction to bump it up in the mempool.\n>>>>\n>>>> As an alternative, we could establish an account system in Bitcoin as\n>>>> an \"extension block\".\n>>>>\n>>>> *Here's how it might work:*\n>>>>\n>>>> 1. Define a special anyone can spend output type that is a \"fee\n>>>> account\" (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>>> associated with them, but are overall anyone can spend.\n>>>> 2. All deposits to these outputs get stored in a separate UTXO database\n>>>> for fee accounts\n>>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee amount\n>>>> and a TXID (or Outpoint?); B: a withdraw amount, a fee, and an address\n>>>> 4. These transactions are committed in an extension block merkle tree.\n>>>> While the actual signature must cover the TXID/Outpoint, the committed data\n>>>> need only cover the index in the block of the transaction. The public key\n>>>> for account lookup can be recovered from the message + signature.\n>>>> 5. In any block, any of the fee account deposits can be: released into\n>>>> fees if there is a corresponding tx; consolidated together to reduce the\n>>>> number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>>> released into fees *and paid back* into the requested withdrawal key\n>>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>>> 6. Mempool logic is updated to allow attaching of account fee spends to\n>>>> transactions, the mempool can restrict that an account is not allowed more\n>>>> spend more than it's balance.\n>>>>\n>>>> *But aren't accounts \"bad\"?*\n>>>>\n>>>> Yes, accounts are bad. But these accounts are not bad, because any\n>>>> funds withdrawn from the fee extension are fundamentally locked for 100\n>>>> blocks as a coinbase output, so there should be no issues with any series\n>>>> of reorgs. Further, since there is no \"rich state\" for these accounts, the\n>>>> state updates can always be applied in a conflict-free way in any order.\n>>>>\n>>>>\n>>>> *Improving the privacy of this design:*\n>>>>\n>>>> This design could likely be modified to implement something like\n>>>> Tornado.cash or something else so that the fee account paying can be\n>>>> unlinked from the transaction being paid for, improving privacy at the\n>>>> expense of being a bit more expensive.\n>>>>\n>>>> Other operations could be added to allow a trustless mixing to be done\n>>>> by miners automatically where groups of accounts with similar values are\n>>>> trustlessly  split into a common denominator and change, and keys are\n>>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>>> be discovered by tracing the updates posted). These updates could also be\n>>>> produced by individuals rather than miners, and miners could simply honor\n>>>> them with better privacy. While a miner generating an update would be able\n>>>> to deanonymize their mixes, if you have your account mixed several times by\n>>>> independent miners that could potentially add sufficient privacy.\n>>>>\n>>>> The LN can also be used with PTLCs to, in theory, have another\n>>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>>> a valid sig from their fee paying account, although under this model it's\n>>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>>> withdrawing the rest. However, this could be partly solved by using\n>>>> reputable fee accounts (reputation could be measured somewhat\n>>>> decentralized-ly by longevity of the account and transactions paid for\n>>>> historically).\n>>>>\n>>>> *Scalability*\n>>>>\n>>>> This design is fundamentally 'decent' for scalability because adding\n>>>> fees to a transaction does not require adding inputs or outputs and does\n>>>> not require tracking substantial amounts of new state.\n>>>>\n>>>> Paying someone else to pay for you via the LN also helps make this more\n>>>> efficient if the withdrawal issues can be fixed.\n>>>>\n>>>> *Lightning:*\n>>>>\n>>>> This type of design works really well for channels because the addition\n>>>> of fees to e.g. a channel state does not require any sort of pre-planning\n>>>> (e.g. anchors) or transaction flexibility (SIGHASH flags). This sort of\n>>>> design is naturally immune to pinning issues since you could offer to pay a\n>>>> fee for any TXID and the number of fee adding offers does not need to be\n>>>> restricted in the same way the descendant transactions would need to be.\n>>>>\n>>>> *Without a fork?*\n>>>>\n>>>> This type of design could be done as a federated network that bribes\n>>>> miners -- potentially even retroactively after a block is formed. That\n>>>> might be sufficient to prove the concept works before a consensus upgrade\n>>>> is deployed, but such an approach does mean there is a centralizing layer\n>>>> interfering with normal mining.\n>>>>\n>>>>\n>>>> Happy new year!!\n>>>>\n>>>> Jeremy\n>>>>\n>>>> --\n>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>> <https://twitter.com/JeremyRubin>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220118/bde037b2/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-01-19T04:53:21",
                "message_text_only": ">  because you make transactions third party malleable it becomes possible\nto bundle and unbundle transactions.\n\nWhat I was suggesting doesn't make it possible to malleate someone else's\ntransaction. I guess maybe my proposal of using a sighash flag might have\nbeen unclear. Imagine it as a script opcode that just says \"this\ntransaction must be mined with this other transaction\" - the only\ndifference being that you can use any output with any encumberance as an\ninput for fee bumping. It doesn't prevent the original transaction from\nbeing mined on its own. So adding junk inputs would be no more of a problem\nthan dust attacks already are. It would be used exactly like cpfp, except\nit doesn't spend the parent.\n\nI don't think what I was suggesting is as different from your proposal. All\nthe problems of fee revenue optimization and feerate rules that you\nmentioned seem like they'd also exist for your proposal, or for cpfp. Let\nme know if I should clarify further.\n\nOn Tue, Jan 18, 2022 at 8:51 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> The issue with sighash flags is that because you make transactions third\n> party malleable it becomes possible to bundle and unbundle transactions.\n>\n> This means there are circumstances where an attacker could e.g. see your\n> txn, and then add a lot of junk change/inputs + 25 descendants and strongly\n> anchor your transaction to the bottom of the mempool.\n>\n> because of rbf rules requiring more fee and feerate, this means you have\n> to bump across the whole package and that can get really messy.\n>\n> more generally speaking, you could imagine a future where mempools track\n> many alternative things that might want to be in a transaction.\n>\n> suppose there are N inputs each with a weight and an amount of fee being\n> added and the sighash flags let me pick any subset of them. However, for a\n> txn to be standard it must be < 100k bytes and for it to be consensus <\n> 1mb. Now it is possible you have to solve a knapsack problem in order to\n> rationally bundle this transaction out of all possibilities.\n>\n> This problem can get even thornier, suppose that the inputs I'm adding\n> themselves are the outputs of another txn in the mempool, now i have to\n> track and propagate the feerates of that child back up to the parent txn\n> and track all these dependencies.\n>\n> perhaps with very careful engineering these issues can be tamed. however\n> it seems with sponsors or fee accounts, by separating the pays-for from the\n> participates-in concerns we can greatly simplify it to something like:\n> compute effective feerate for a txn, including all sponsors that pay more\n> than the feerate of the base txn. Mine that txn and it's subsidies using\n> the normal algo. If you run out of space, all subsidies are same-sized so\n> just take the ones that pay the highest amount up until the added marginal\n> feerate is less than the next eligible txn.\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Tue, Jan 18, 2022 at 6:38 PM Billy Tetrud <billy.tetrud at gmail.com>\n> wrote:\n>\n>> I see, its not primarily to make it cheaper to append fees, but also\n>> allows appending fees in cases that aren't possible now. Is that right? I\n>> can certainly see the benefit of a more general way to add a fee to any\n>> transaction, regardless of whether you're related to that transaction or\n>> not.\n>>\n>> How would you compare the pros and cons of your account-based approach to\n>> something like a new sighash flag? Eg a sighash flag that says \"I'm signing\n>> this transaction, but the signature is only valid if mined in the same\n>> block as transaction X (or maybe transactions LIST)\". This could be named\n>> SIGHASH_EXTERNAL. Doing this would be a lot more similar to other bitcoin\n>> transactions, and no special account would need to be created. Any\n>> transaction could specify this. At least that's the first thought I would\n>> have in designing a way to arbitrarily bump fees. Have you compared your\n>> solution to something more familiar like that?\n>>\n>> On Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n>>\n>>> Can you clarify what you mean by \"improve the situation\"?\n>>>\n>>> There's a potential mild bytes savings, but the bigger deal is that the\n>>> API should be much less vulnerable to pinning issues, fix dust leakage for\n>>> eltoo like protocols, and just generally allow protocol designs to be fully\n>>> abstracted from paying fees. You can't easily mathematically quantify API\n>>> improvements like that.\n>>> --\n>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>> <https://twitter.com/JeremyRubin>\n>>>\n>>>\n>>> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n>>> wrote:\n>>>\n>>>> Do you have any back-of-the-napkin math on quantifying how much this\n>>>> would improve the situation vs existing methods (eg cpfp)?\n>>>>\n>>>>\n>>>>\n>>>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> Happy new years devs,\n>>>>>\n>>>>> I figured I would share some thoughts for conceptual review that have\n>>>>> been bouncing around my head as an opportunity to clean up the fee paying\n>>>>> semantics in bitcoin \"for good\". The design space is very wide on the\n>>>>> approach I'll share, so below is just a sketch of how it could work which\n>>>>> I'm sure could be improved greatly.\n>>>>>\n>>>>> Transaction fees are an integral part of bitcoin.\n>>>>>\n>>>>> However, due to quirks of Bitcoin's transaction design, fees are a\n>>>>> part of the transactions that they occur in.\n>>>>>\n>>>>> While this works in a \"Bitcoin 1.0\" world, where all transactions are\n>>>>> simple on-chain transfers, real world use of Bitcoin requires support for\n>>>>> things like Fee Bumping stuck transactions, DoS resistant Payment Channels,\n>>>>> and other long lived Smart Contracts that can't predict future fee rates.\n>>>>> Having the fees paid in band makes writing these contracts much more\n>>>>> difficult as you can't merely express the logic you want for the\n>>>>> transaction, but also the fees.\n>>>>>\n>>>>> Previously, I proposed a special type of transaction called a\n>>>>> \"Sponsor\" which has some special consensus + mempool rules to allow\n>>>>> arbitrarily appending fees to a transaction to bump it up in the mempool.\n>>>>>\n>>>>> As an alternative, we could establish an account system in Bitcoin as\n>>>>> an \"extension block\".\n>>>>>\n>>>>> *Here's how it might work:*\n>>>>>\n>>>>> 1. Define a special anyone can spend output type that is a \"fee\n>>>>> account\" (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>>>> associated with them, but are overall anyone can spend.\n>>>>> 2. All deposits to these outputs get stored in a separate UTXO\n>>>>> database for fee accounts\n>>>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee\n>>>>> amount and a TXID (or Outpoint?); B: a withdraw amount, a fee, and\n>>>>> an address\n>>>>> 4. These transactions are committed in an extension block merkle tree.\n>>>>> While the actual signature must cover the TXID/Outpoint, the committed data\n>>>>> need only cover the index in the block of the transaction. The public key\n>>>>> for account lookup can be recovered from the message + signature.\n>>>>> 5. In any block, any of the fee account deposits can be: released into\n>>>>> fees if there is a corresponding tx; consolidated together to reduce the\n>>>>> number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>>>> released into fees *and paid back* into the requested withdrawal key\n>>>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>>>> 6. Mempool logic is updated to allow attaching of account fee spends\n>>>>> to transactions, the mempool can restrict that an account is not allowed\n>>>>> more spend more than it's balance.\n>>>>>\n>>>>> *But aren't accounts \"bad\"?*\n>>>>>\n>>>>> Yes, accounts are bad. But these accounts are not bad, because any\n>>>>> funds withdrawn from the fee extension are fundamentally locked for 100\n>>>>> blocks as a coinbase output, so there should be no issues with any series\n>>>>> of reorgs. Further, since there is no \"rich state\" for these accounts, the\n>>>>> state updates can always be applied in a conflict-free way in any order.\n>>>>>\n>>>>>\n>>>>> *Improving the privacy of this design:*\n>>>>>\n>>>>> This design could likely be modified to implement something like\n>>>>> Tornado.cash or something else so that the fee account paying can be\n>>>>> unlinked from the transaction being paid for, improving privacy at the\n>>>>> expense of being a bit more expensive.\n>>>>>\n>>>>> Other operations could be added to allow a trustless mixing to be done\n>>>>> by miners automatically where groups of accounts with similar values are\n>>>>> trustlessly  split into a common denominator and change, and keys are\n>>>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>>>> be discovered by tracing the updates posted). These updates could also be\n>>>>> produced by individuals rather than miners, and miners could simply honor\n>>>>> them with better privacy. While a miner generating an update would be able\n>>>>> to deanonymize their mixes, if you have your account mixed several times by\n>>>>> independent miners that could potentially add sufficient privacy.\n>>>>>\n>>>>> The LN can also be used with PTLCs to, in theory, have another\n>>>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>>>> a valid sig from their fee paying account, although under this model it's\n>>>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>>>> withdrawing the rest. However, this could be partly solved by using\n>>>>> reputable fee accounts (reputation could be measured somewhat\n>>>>> decentralized-ly by longevity of the account and transactions paid for\n>>>>> historically).\n>>>>>\n>>>>> *Scalability*\n>>>>>\n>>>>> This design is fundamentally 'decent' for scalability because adding\n>>>>> fees to a transaction does not require adding inputs or outputs and does\n>>>>> not require tracking substantial amounts of new state.\n>>>>>\n>>>>> Paying someone else to pay for you via the LN also helps make this\n>>>>> more efficient if the withdrawal issues can be fixed.\n>>>>>\n>>>>> *Lightning:*\n>>>>>\n>>>>> This type of design works really well for channels because the\n>>>>> addition of fees to e.g. a channel state does not require any sort of\n>>>>> pre-planning (e.g. anchors) or transaction flexibility (SIGHASH flags).\n>>>>> This sort of design is naturally immune to pinning issues since you could\n>>>>> offer to pay a fee for any TXID and the number of fee adding offers does\n>>>>> not need to be restricted in the same way the descendant transactions would\n>>>>> need to be.\n>>>>>\n>>>>> *Without a fork?*\n>>>>>\n>>>>> This type of design could be done as a federated network that bribes\n>>>>> miners -- potentially even retroactively after a block is formed. That\n>>>>> might be sufficient to prove the concept works before a consensus upgrade\n>>>>> is deployed, but such an approach does mean there is a centralizing layer\n>>>>> interfering with normal mining.\n>>>>>\n>>>>>\n>>>>> Happy new year!!\n>>>>>\n>>>>> Jeremy\n>>>>>\n>>>>> --\n>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>> <https://twitter.com/JeremyRubin>\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220118/59a75bc9/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2022-01-19T07:32:36",
                "message_text_only": "Ah my bad i misread what you were saying as being about SIGHASH_BUNDLE like\nproposals.\n\nFor what you're discussing, I previously proposed\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\nwhich is similar.\n\nThe benefit of the OP_VER output is that SIGHASH_EXTERNAL has the issue\nthat unless you're binding a WTXID (which is maybe too specific?) then you\ncan have fee bumping cycles. Doing OP_VER output w/ TXID guarantees that\nyou are acyclic.\n\nThe difference between a fee account and this approach basically boils down\nto the impact on e.g. reorg stability, where the deposit/withdraw mechanism\nis a bit more \"robust\" for reorderings in reorgs than the in-band\ntransaction approach, although they are very similar.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Tue, Jan 18, 2022 at 8:53 PM Billy Tetrud <billy.tetrud at gmail.com> wrote:\n\n> >  because you make transactions third party malleable it becomes\n> possible to bundle and unbundle transactions.\n>\n> What I was suggesting doesn't make it possible to malleate someone else's\n> transaction. I guess maybe my proposal of using a sighash flag might have\n> been unclear. Imagine it as a script opcode that just says \"this\n> transaction must be mined with this other transaction\" - the only\n> difference being that you can use any output with any encumberance as an\n> input for fee bumping. It doesn't prevent the original transaction from\n> being mined on its own. So adding junk inputs would be no more of a problem\n> than dust attacks already are. It would be used exactly like cpfp, except\n> it doesn't spend the parent.\n>\n> I don't think what I was suggesting is as different from your proposal.\n> All the problems of fee revenue optimization and feerate rules that you\n> mentioned seem like they'd also exist for your proposal, or for cpfp. Let\n> me know if I should clarify further.\n>\n> On Tue, Jan 18, 2022 at 8:51 PM Jeremy <jlrubin at mit.edu> wrote:\n>\n>> The issue with sighash flags is that because you make transactions third\n>> party malleable it becomes possible to bundle and unbundle transactions.\n>>\n>> This means there are circumstances where an attacker could e.g. see your\n>> txn, and then add a lot of junk change/inputs + 25 descendants and strongly\n>> anchor your transaction to the bottom of the mempool.\n>>\n>> because of rbf rules requiring more fee and feerate, this means you have\n>> to bump across the whole package and that can get really messy.\n>>\n>> more generally speaking, you could imagine a future where mempools track\n>> many alternative things that might want to be in a transaction.\n>>\n>> suppose there are N inputs each with a weight and an amount of fee being\n>> added and the sighash flags let me pick any subset of them. However, for a\n>> txn to be standard it must be < 100k bytes and for it to be consensus <\n>> 1mb. Now it is possible you have to solve a knapsack problem in order to\n>> rationally bundle this transaction out of all possibilities.\n>>\n>> This problem can get even thornier, suppose that the inputs I'm adding\n>> themselves are the outputs of another txn in the mempool, now i have to\n>> track and propagate the feerates of that child back up to the parent txn\n>> and track all these dependencies.\n>>\n>> perhaps with very careful engineering these issues can be tamed. however\n>> it seems with sponsors or fee accounts, by separating the pays-for from the\n>> participates-in concerns we can greatly simplify it to something like:\n>> compute effective feerate for a txn, including all sponsors that pay more\n>> than the feerate of the base txn. Mine that txn and it's subsidies using\n>> the normal algo. If you run out of space, all subsidies are same-sized so\n>> just take the ones that pay the highest amount up until the added marginal\n>> feerate is less than the next eligible txn.\n>>\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>>\n>>\n>> On Tue, Jan 18, 2022 at 6:38 PM Billy Tetrud <billy.tetrud at gmail.com>\n>> wrote:\n>>\n>>> I see, its not primarily to make it cheaper to append fees, but also\n>>> allows appending fees in cases that aren't possible now. Is that right? I\n>>> can certainly see the benefit of a more general way to add a fee to any\n>>> transaction, regardless of whether you're related to that transaction or\n>>> not.\n>>>\n>>> How would you compare the pros and cons of your account-based approach\n>>> to something like a new sighash flag? Eg a sighash flag that says \"I'm\n>>> signing this transaction, but the signature is only valid if mined in the\n>>> same block as transaction X (or maybe transactions LIST)\". This could be\n>>> named SIGHASH_EXTERNAL. Doing this would be a lot more similar to other\n>>> bitcoin transactions, and no special account would need to be created. Any\n>>> transaction could specify this. At least that's the first thought I would\n>>> have in designing a way to arbitrarily bump fees. Have you compared your\n>>> solution to something more familiar like that?\n>>>\n>>> On Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n>>>\n>>>> Can you clarify what you mean by \"improve the situation\"?\n>>>>\n>>>> There's a potential mild bytes savings, but the bigger deal is that the\n>>>> API should be much less vulnerable to pinning issues, fix dust leakage for\n>>>> eltoo like protocols, and just generally allow protocol designs to be fully\n>>>> abstracted from paying fees. You can't easily mathematically quantify API\n>>>> improvements like that.\n>>>> --\n>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>> <https://twitter.com/JeremyRubin>\n>>>>\n>>>>\n>>>> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n>>>> wrote:\n>>>>\n>>>>> Do you have any back-of-the-napkin math on quantifying how much this\n>>>>> would improve the situation vs existing methods (eg cpfp)?\n>>>>>\n>>>>>\n>>>>>\n>>>>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>\n>>>>>> Happy new years devs,\n>>>>>>\n>>>>>> I figured I would share some thoughts for conceptual review that have\n>>>>>> been bouncing around my head as an opportunity to clean up the fee paying\n>>>>>> semantics in bitcoin \"for good\". The design space is very wide on the\n>>>>>> approach I'll share, so below is just a sketch of how it could work which\n>>>>>> I'm sure could be improved greatly.\n>>>>>>\n>>>>>> Transaction fees are an integral part of bitcoin.\n>>>>>>\n>>>>>> However, due to quirks of Bitcoin's transaction design, fees are a\n>>>>>> part of the transactions that they occur in.\n>>>>>>\n>>>>>> While this works in a \"Bitcoin 1.0\" world, where all transactions are\n>>>>>> simple on-chain transfers, real world use of Bitcoin requires support for\n>>>>>> things like Fee Bumping stuck transactions, DoS resistant Payment Channels,\n>>>>>> and other long lived Smart Contracts that can't predict future fee rates.\n>>>>>> Having the fees paid in band makes writing these contracts much more\n>>>>>> difficult as you can't merely express the logic you want for the\n>>>>>> transaction, but also the fees.\n>>>>>>\n>>>>>> Previously, I proposed a special type of transaction called a\n>>>>>> \"Sponsor\" which has some special consensus + mempool rules to allow\n>>>>>> arbitrarily appending fees to a transaction to bump it up in the mempool.\n>>>>>>\n>>>>>> As an alternative, we could establish an account system in Bitcoin as\n>>>>>> an \"extension block\".\n>>>>>>\n>>>>>> *Here's how it might work:*\n>>>>>>\n>>>>>> 1. Define a special anyone can spend output type that is a \"fee\n>>>>>> account\" (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>>>>> associated with them, but are overall anyone can spend.\n>>>>>> 2. All deposits to these outputs get stored in a separate UTXO\n>>>>>> database for fee accounts\n>>>>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee\n>>>>>> amount and a TXID (or Outpoint?); B: a withdraw amount, a fee, and\n>>>>>> an address\n>>>>>> 4. These transactions are committed in an extension block merkle\n>>>>>> tree. While the actual signature must cover the TXID/Outpoint, the\n>>>>>> committed data need only cover the index in the block of the transaction.\n>>>>>> The public key for account lookup can be recovered from the message +\n>>>>>> signature.\n>>>>>> 5. In any block, any of the fee account deposits can be: released\n>>>>>> into fees if there is a corresponding tx; consolidated together to reduce\n>>>>>> the number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>>>>> released into fees *and paid back* into the requested withdrawal key\n>>>>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>>>>> 6. Mempool logic is updated to allow attaching of account fee spends\n>>>>>> to transactions, the mempool can restrict that an account is not allowed\n>>>>>> more spend more than it's balance.\n>>>>>>\n>>>>>> *But aren't accounts \"bad\"?*\n>>>>>>\n>>>>>> Yes, accounts are bad. But these accounts are not bad, because any\n>>>>>> funds withdrawn from the fee extension are fundamentally locked for 100\n>>>>>> blocks as a coinbase output, so there should be no issues with any series\n>>>>>> of reorgs. Further, since there is no \"rich state\" for these accounts, the\n>>>>>> state updates can always be applied in a conflict-free way in any order.\n>>>>>>\n>>>>>>\n>>>>>> *Improving the privacy of this design:*\n>>>>>>\n>>>>>> This design could likely be modified to implement something like\n>>>>>> Tornado.cash or something else so that the fee account paying can be\n>>>>>> unlinked from the transaction being paid for, improving privacy at the\n>>>>>> expense of being a bit more expensive.\n>>>>>>\n>>>>>> Other operations could be added to allow a trustless mixing to be\n>>>>>> done by miners automatically where groups of accounts with similar values\n>>>>>> are trustlessly  split into a common denominator and change, and keys are\n>>>>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>>>>> be discovered by tracing the updates posted). These updates could also be\n>>>>>> produced by individuals rather than miners, and miners could simply honor\n>>>>>> them with better privacy. While a miner generating an update would be able\n>>>>>> to deanonymize their mixes, if you have your account mixed several times by\n>>>>>> independent miners that could potentially add sufficient privacy.\n>>>>>>\n>>>>>> The LN can also be used with PTLCs to, in theory, have another\n>>>>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>>>>> a valid sig from their fee paying account, although under this model it's\n>>>>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>>>>> withdrawing the rest. However, this could be partly solved by using\n>>>>>> reputable fee accounts (reputation could be measured somewhat\n>>>>>> decentralized-ly by longevity of the account and transactions paid for\n>>>>>> historically).\n>>>>>>\n>>>>>> *Scalability*\n>>>>>>\n>>>>>> This design is fundamentally 'decent' for scalability because adding\n>>>>>> fees to a transaction does not require adding inputs or outputs and does\n>>>>>> not require tracking substantial amounts of new state.\n>>>>>>\n>>>>>> Paying someone else to pay for you via the LN also helps make this\n>>>>>> more efficient if the withdrawal issues can be fixed.\n>>>>>>\n>>>>>> *Lightning:*\n>>>>>>\n>>>>>> This type of design works really well for channels because the\n>>>>>> addition of fees to e.g. a channel state does not require any sort of\n>>>>>> pre-planning (e.g. anchors) or transaction flexibility (SIGHASH flags).\n>>>>>> This sort of design is naturally immune to pinning issues since you could\n>>>>>> offer to pay a fee for any TXID and the number of fee adding offers does\n>>>>>> not need to be restricted in the same way the descendant transactions would\n>>>>>> need to be.\n>>>>>>\n>>>>>> *Without a fork?*\n>>>>>>\n>>>>>> This type of design could be done as a federated network that bribes\n>>>>>> miners -- potentially even retroactively after a block is formed. That\n>>>>>> might be sufficient to prove the concept works before a consensus upgrade\n>>>>>> is deployed, but such an approach does mean there is a centralizing layer\n>>>>>> interfering with normal mining.\n>>>>>>\n>>>>>>\n>>>>>> Happy new year!!\n>>>>>>\n>>>>>> Jeremy\n>>>>>>\n>>>>>> --\n>>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>>> <https://twitter.com/JeremyRubin>\n>>>>>> _______________________________________________\n>>>>>> bitcoin-dev mailing list\n>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>\n>>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220118/862ed586/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-01-19T16:51:48",
                "message_text_only": "Hmm, I don't know anything about  SIGHASH_BUNDLE. The only references\nonline I can find are just mentions (mostly from you). What is\nSIGHASH_BUNDLE?\n\n> unless you're binding a WTXID\n\nThat could work, but it would exclude cases where you have a transaction\nthat has already been partially signed and someone wants to, say, only sign\nthat transaction if some 3rd party signs a transaction paying part of the\nfee for it. Kind of a niche use case, but it would be nice to support it if\npossible. If the transaction hasn't been signed at all yet, a new\ntransaction can just be created that includes the prospective fee-payer,\nand if the transaction is fully signed then it has a WTXID to use.\n\n> then you can have fee bumping cycles\n\nWhat kind of cycles do you mean? You're saying these cycles would make it\nless robust to reorgs?\n\n> OP_VER\n\nI assume you mean something other than pushing the version onto the stack\n<https://bitcoin.stackexchange.com/questions/97258/given-op-ver-was-never-used-is-disabled-and-not-considered-useful-can-its-meani>?\nIs that related to your fee account idea?\n\n\nOn Wed, Jan 19, 2022 at 1:32 AM Jeremy <jlrubin at mit.edu> wrote:\n\n> Ah my bad i misread what you were saying as being about SIGHASH_BUNDLE\n> like proposals.\n>\n> For what you're discussing, I previously proposed\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n> which is similar.\n>\n> The benefit of the OP_VER output is that SIGHASH_EXTERNAL has the issue\n> that unless you're binding a WTXID (which is maybe too specific?) then you\n> can have fee bumping cycles. Doing OP_VER output w/ TXID guarantees that\n> you are acyclic.\n>\n> The difference between a fee account and this approach basically boils\n> down to the impact on e.g. reorg stability, where the deposit/withdraw\n> mechanism is a bit more \"robust\" for reorderings in reorgs than the in-band\n> transaction approach, although they are very similar.\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Tue, Jan 18, 2022 at 8:53 PM Billy Tetrud <billy.tetrud at gmail.com>\n> wrote:\n>\n>> >  because you make transactions third party malleable it becomes\n>> possible to bundle and unbundle transactions.\n>>\n>> What I was suggesting doesn't make it possible to malleate someone else's\n>> transaction. I guess maybe my proposal of using a sighash flag might\n>> have been unclear. Imagine it as a script opcode that just says \"this\n>> transaction must be mined with this other transaction\" - the only\n>> difference being that you can use any output with any encumberance as an\n>> input for fee bumping. It doesn't prevent the original transaction from\n>> being mined on its own. So adding junk inputs would be no more of a problem\n>> than dust attacks already are. It would be used exactly like cpfp, except\n>> it doesn't spend the parent.\n>>\n>> I don't think what I was suggesting is as different from your proposal.\n>> All the problems of fee revenue optimization and feerate rules that you\n>> mentioned seem like they'd also exist for your proposal, or for cpfp. Let\n>> me know if I should clarify further.\n>>\n>> On Tue, Jan 18, 2022 at 8:51 PM Jeremy <jlrubin at mit.edu> wrote:\n>>\n>>> The issue with sighash flags is that because you make transactions third\n>>> party malleable it becomes possible to bundle and unbundle transactions.\n>>>\n>>> This means there are circumstances where an attacker could e.g. see your\n>>> txn, and then add a lot of junk change/inputs + 25 descendants and strongly\n>>> anchor your transaction to the bottom of the mempool.\n>>>\n>>> because of rbf rules requiring more fee and feerate, this means you have\n>>> to bump across the whole package and that can get really messy.\n>>>\n>>> more generally speaking, you could imagine a future where mempools track\n>>> many alternative things that might want to be in a transaction.\n>>>\n>>> suppose there are N inputs each with a weight and an amount of fee being\n>>> added and the sighash flags let me pick any subset of them. However, for a\n>>> txn to be standard it must be < 100k bytes and for it to be consensus <\n>>> 1mb. Now it is possible you have to solve a knapsack problem in order to\n>>> rationally bundle this transaction out of all possibilities.\n>>>\n>>> This problem can get even thornier, suppose that the inputs I'm adding\n>>> themselves are the outputs of another txn in the mempool, now i have to\n>>> track and propagate the feerates of that child back up to the parent txn\n>>> and track all these dependencies.\n>>>\n>>> perhaps with very careful engineering these issues can be tamed. however\n>>> it seems with sponsors or fee accounts, by separating the pays-for from the\n>>> participates-in concerns we can greatly simplify it to something like:\n>>> compute effective feerate for a txn, including all sponsors that pay more\n>>> than the feerate of the base txn. Mine that txn and it's subsidies using\n>>> the normal algo. If you run out of space, all subsidies are same-sized so\n>>> just take the ones that pay the highest amount up until the added marginal\n>>> feerate is less than the next eligible txn.\n>>>\n>>>\n>>> --\n>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>> <https://twitter.com/JeremyRubin>\n>>>\n>>>\n>>> On Tue, Jan 18, 2022 at 6:38 PM Billy Tetrud <billy.tetrud at gmail.com>\n>>> wrote:\n>>>\n>>>> I see, its not primarily to make it cheaper to append fees, but also\n>>>> allows appending fees in cases that aren't possible now. Is that right? I\n>>>> can certainly see the benefit of a more general way to add a fee to any\n>>>> transaction, regardless of whether you're related to that transaction or\n>>>> not.\n>>>>\n>>>> How would you compare the pros and cons of your account-based approach\n>>>> to something like a new sighash flag? Eg a sighash flag that says \"I'm\n>>>> signing this transaction, but the signature is only valid if mined in the\n>>>> same block as transaction X (or maybe transactions LIST)\". This could be\n>>>> named SIGHASH_EXTERNAL. Doing this would be a lot more similar to other\n>>>> bitcoin transactions, and no special account would need to be created. Any\n>>>> transaction could specify this. At least that's the first thought I would\n>>>> have in designing a way to arbitrarily bump fees. Have you compared your\n>>>> solution to something more familiar like that?\n>>>>\n>>>> On Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n>>>>\n>>>>> Can you clarify what you mean by \"improve the situation\"?\n>>>>>\n>>>>> There's a potential mild bytes savings, but the bigger deal is that\n>>>>> the API should be much less vulnerable to pinning issues, fix dust leakage\n>>>>> for eltoo like protocols, and just generally allow protocol designs to be\n>>>>> fully abstracted from paying fees. You can't easily mathematically\n>>>>> quantify API improvements like that.\n>>>>> --\n>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>> <https://twitter.com/JeremyRubin>\n>>>>>\n>>>>>\n>>>>> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n>>>>> wrote:\n>>>>>\n>>>>>> Do you have any back-of-the-napkin math on quantifying how much this\n>>>>>> would improve the situation vs existing methods (eg cpfp)?\n>>>>>>\n>>>>>>\n>>>>>>\n>>>>>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>>\n>>>>>>> Happy new years devs,\n>>>>>>>\n>>>>>>> I figured I would share some thoughts for conceptual review that\n>>>>>>> have been bouncing around my head as an opportunity to clean up the fee\n>>>>>>> paying semantics in bitcoin \"for good\". The design space is very wide on\n>>>>>>> the approach I'll share, so below is just a sketch of how it could work\n>>>>>>> which I'm sure could be improved greatly.\n>>>>>>>\n>>>>>>> Transaction fees are an integral part of bitcoin.\n>>>>>>>\n>>>>>>> However, due to quirks of Bitcoin's transaction design, fees are a\n>>>>>>> part of the transactions that they occur in.\n>>>>>>>\n>>>>>>> While this works in a \"Bitcoin 1.0\" world, where all transactions\n>>>>>>> are simple on-chain transfers, real world use of Bitcoin requires support\n>>>>>>> for things like Fee Bumping stuck transactions, DoS resistant Payment\n>>>>>>> Channels, and other long lived Smart Contracts that can't predict future\n>>>>>>> fee rates. Having the fees paid in band makes writing these contracts much\n>>>>>>> more difficult as you can't merely express the logic you want for the\n>>>>>>> transaction, but also the fees.\n>>>>>>>\n>>>>>>> Previously, I proposed a special type of transaction called a\n>>>>>>> \"Sponsor\" which has some special consensus + mempool rules to allow\n>>>>>>> arbitrarily appending fees to a transaction to bump it up in the mempool.\n>>>>>>>\n>>>>>>> As an alternative, we could establish an account system in Bitcoin\n>>>>>>> as an \"extension block\".\n>>>>>>>\n>>>>>>> *Here's how it might work:*\n>>>>>>>\n>>>>>>> 1. Define a special anyone can spend output type that is a \"fee\n>>>>>>> account\" (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>>>>>> associated with them, but are overall anyone can spend.\n>>>>>>> 2. All deposits to these outputs get stored in a separate UTXO\n>>>>>>> database for fee accounts\n>>>>>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee\n>>>>>>> amount and a TXID (or Outpoint?); B: a withdraw amount, a fee, and\n>>>>>>> an address\n>>>>>>> 4. These transactions are committed in an extension block merkle\n>>>>>>> tree. While the actual signature must cover the TXID/Outpoint, the\n>>>>>>> committed data need only cover the index in the block of the transaction.\n>>>>>>> The public key for account lookup can be recovered from the message +\n>>>>>>> signature.\n>>>>>>> 5. In any block, any of the fee account deposits can be: released\n>>>>>>> into fees if there is a corresponding tx; consolidated together to reduce\n>>>>>>> the number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>>>>>> released into fees *and paid back* into the requested withdrawal key\n>>>>>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>>>>>> 6. Mempool logic is updated to allow attaching of account fee spends\n>>>>>>> to transactions, the mempool can restrict that an account is not allowed\n>>>>>>> more spend more than it's balance.\n>>>>>>>\n>>>>>>> *But aren't accounts \"bad\"?*\n>>>>>>>\n>>>>>>> Yes, accounts are bad. But these accounts are not bad, because any\n>>>>>>> funds withdrawn from the fee extension are fundamentally locked for 100\n>>>>>>> blocks as a coinbase output, so there should be no issues with any series\n>>>>>>> of reorgs. Further, since there is no \"rich state\" for these accounts, the\n>>>>>>> state updates can always be applied in a conflict-free way in any order.\n>>>>>>>\n>>>>>>>\n>>>>>>> *Improving the privacy of this design:*\n>>>>>>>\n>>>>>>> This design could likely be modified to implement something like\n>>>>>>> Tornado.cash or something else so that the fee account paying can be\n>>>>>>> unlinked from the transaction being paid for, improving privacy at the\n>>>>>>> expense of being a bit more expensive.\n>>>>>>>\n>>>>>>> Other operations could be added to allow a trustless mixing to be\n>>>>>>> done by miners automatically where groups of accounts with similar values\n>>>>>>> are trustlessly  split into a common denominator and change, and keys are\n>>>>>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>>>>>> be discovered by tracing the updates posted). These updates could also be\n>>>>>>> produced by individuals rather than miners, and miners could simply honor\n>>>>>>> them with better privacy. While a miner generating an update would be able\n>>>>>>> to deanonymize their mixes, if you have your account mixed several times by\n>>>>>>> independent miners that could potentially add sufficient privacy.\n>>>>>>>\n>>>>>>> The LN can also be used with PTLCs to, in theory, have another\n>>>>>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>>>>>> a valid sig from their fee paying account, although under this model it's\n>>>>>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>>>>>> withdrawing the rest. However, this could be partly solved by using\n>>>>>>> reputable fee accounts (reputation could be measured somewhat\n>>>>>>> decentralized-ly by longevity of the account and transactions paid for\n>>>>>>> historically).\n>>>>>>>\n>>>>>>> *Scalability*\n>>>>>>>\n>>>>>>> This design is fundamentally 'decent' for scalability because adding\n>>>>>>> fees to a transaction does not require adding inputs or outputs and does\n>>>>>>> not require tracking substantial amounts of new state.\n>>>>>>>\n>>>>>>> Paying someone else to pay for you via the LN also helps make this\n>>>>>>> more efficient if the withdrawal issues can be fixed.\n>>>>>>>\n>>>>>>> *Lightning:*\n>>>>>>>\n>>>>>>> This type of design works really well for channels because the\n>>>>>>> addition of fees to e.g. a channel state does not require any sort of\n>>>>>>> pre-planning (e.g. anchors) or transaction flexibility (SIGHASH flags).\n>>>>>>> This sort of design is naturally immune to pinning issues since you could\n>>>>>>> offer to pay a fee for any TXID and the number of fee adding offers does\n>>>>>>> not need to be restricted in the same way the descendant transactions would\n>>>>>>> need to be.\n>>>>>>>\n>>>>>>> *Without a fork?*\n>>>>>>>\n>>>>>>> This type of design could be done as a federated network that bribes\n>>>>>>> miners -- potentially even retroactively after a block is formed. That\n>>>>>>> might be sufficient to prove the concept works before a consensus upgrade\n>>>>>>> is deployed, but such an approach does mean there is a centralizing layer\n>>>>>>> interfering with normal mining.\n>>>>>>>\n>>>>>>>\n>>>>>>> Happy new year!!\n>>>>>>>\n>>>>>>> Jeremy\n>>>>>>>\n>>>>>>> --\n>>>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>>>> <https://twitter.com/JeremyRubin>\n>>>>>>> _______________________________________________\n>>>>>>> bitcoin-dev mailing list\n>>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>>\n>>>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220119/c587953e/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2022-01-19T20:08:23",
                "message_text_only": "SIGHASH_BUNDLE\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-April/015862.html\n\nBy cycles I meant that if you commit to the sponsors by TXID from the\nwitness, you could \"sponsor yourself\" directly or through a cycle involving\n> 1 txn.\n\nWith OP_VER I was talking about the proposal I linked here\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\nwhich used OP_VER to indicate a txn sponsoring txn. Because the OP_VER is\nin the output space, and uses TXIDs, it is cycle-free.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Wed, Jan 19, 2022 at 8:52 AM Billy Tetrud <billy.tetrud at gmail.com> wrote:\n\n> Hmm, I don't know anything about  SIGHASH_BUNDLE. The only references\n> online I can find are just mentions (mostly from you). What is\n> SIGHASH_BUNDLE?\n>\n> > unless you're binding a WTXID\n>\n> That could work, but it would exclude cases where you have a transaction\n> that has already been partially signed and someone wants to, say, only sign\n> that transaction if some 3rd party signs a transaction paying part of the\n> fee for it. Kind of a niche use case, but it would be nice to support it if\n> possible. If the transaction hasn't been signed at all yet, a new\n> transaction can just be created that includes the prospective fee-payer,\n> and if the transaction is fully signed then it has a WTXID to use.\n>\n> > then you can have fee bumping cycles\n>\n> What kind of cycles do you mean? You're saying these cycles would make it\n> less robust to reorgs?\n>\n> > OP_VER\n>\n> I assume you mean something other than pushing the version onto the stack\n> <https://bitcoin.stackexchange.com/questions/97258/given-op-ver-was-never-used-is-disabled-and-not-considered-useful-can-its-meani>?\n> Is that related to your fee account idea?\n>\n>\n> On Wed, Jan 19, 2022 at 1:32 AM Jeremy <jlrubin at mit.edu> wrote:\n>\n>> Ah my bad i misread what you were saying as being about SIGHASH_BUNDLE\n>> like proposals.\n>>\n>> For what you're discussing, I previously proposed\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n>> which is similar.\n>>\n>> The benefit of the OP_VER output is that SIGHASH_EXTERNAL has the issue\n>> that unless you're binding a WTXID (which is maybe too specific?) then you\n>> can have fee bumping cycles. Doing OP_VER output w/ TXID guarantees that\n>> you are acyclic.\n>>\n>> The difference between a fee account and this approach basically boils\n>> down to the impact on e.g. reorg stability, where the deposit/withdraw\n>> mechanism is a bit more \"robust\" for reorderings in reorgs than the in-band\n>> transaction approach, although they are very similar.\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>>\n>>\n>> On Tue, Jan 18, 2022 at 8:53 PM Billy Tetrud <billy.tetrud at gmail.com>\n>> wrote:\n>>\n>>> >  because you make transactions third party malleable it becomes\n>>> possible to bundle and unbundle transactions.\n>>>\n>>> What I was suggesting doesn't make it possible to malleate someone\n>>> else's transaction. I guess maybe my proposal of using a sighash flag\n>>> might have been unclear. Imagine it as a script opcode that just says \"this\n>>> transaction must be mined with this other transaction\" - the only\n>>> difference being that you can use any output with any encumberance as an\n>>> input for fee bumping. It doesn't prevent the original transaction from\n>>> being mined on its own. So adding junk inputs would be no more of a problem\n>>> than dust attacks already are. It would be used exactly like cpfp, except\n>>> it doesn't spend the parent.\n>>>\n>>> I don't think what I was suggesting is as different from your proposal.\n>>> All the problems of fee revenue optimization and feerate rules that you\n>>> mentioned seem like they'd also exist for your proposal, or for cpfp. Let\n>>> me know if I should clarify further.\n>>>\n>>> On Tue, Jan 18, 2022 at 8:51 PM Jeremy <jlrubin at mit.edu> wrote:\n>>>\n>>>> The issue with sighash flags is that because you make transactions\n>>>> third party malleable it becomes possible to bundle and unbundle\n>>>> transactions.\n>>>>\n>>>> This means there are circumstances where an attacker could e.g. see\n>>>> your txn, and then add a lot of junk change/inputs + 25 descendants and\n>>>> strongly anchor your transaction to the bottom of the mempool.\n>>>>\n>>>> because of rbf rules requiring more fee and feerate, this means you\n>>>> have to bump across the whole package and that can get really messy.\n>>>>\n>>>> more generally speaking, you could imagine a future where mempools\n>>>> track many alternative things that might want to be in a transaction.\n>>>>\n>>>> suppose there are N inputs each with a weight and an amount of fee\n>>>> being added and the sighash flags let me pick any subset of them. However,\n>>>> for a txn to be standard it must be < 100k bytes and for it to be consensus\n>>>> < 1mb. Now it is possible you have to solve a knapsack problem in order to\n>>>> rationally bundle this transaction out of all possibilities.\n>>>>\n>>>> This problem can get even thornier, suppose that the inputs I'm adding\n>>>> themselves are the outputs of another txn in the mempool, now i have to\n>>>> track and propagate the feerates of that child back up to the parent txn\n>>>> and track all these dependencies.\n>>>>\n>>>> perhaps with very careful engineering these issues can be tamed.\n>>>> however it seems with sponsors or fee accounts, by separating the pays-for\n>>>> from the participates-in concerns we can greatly simplify it to something\n>>>> like: compute effective feerate for a txn, including all sponsors that pay\n>>>> more than the feerate of the base txn. Mine that txn and it's subsidies\n>>>> using the normal algo. If you run out of space, all subsidies are\n>>>> same-sized so just take the ones that pay the highest amount up until the\n>>>> added marginal feerate is less than the next eligible txn.\n>>>>\n>>>>\n>>>> --\n>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>> <https://twitter.com/JeremyRubin>\n>>>>\n>>>>\n>>>> On Tue, Jan 18, 2022 at 6:38 PM Billy Tetrud <billy.tetrud at gmail.com>\n>>>> wrote:\n>>>>\n>>>>> I see, its not primarily to make it cheaper to append fees, but also\n>>>>> allows appending fees in cases that aren't possible now. Is that right? I\n>>>>> can certainly see the benefit of a more general way to add a fee to any\n>>>>> transaction, regardless of whether you're related to that transaction or\n>>>>> not.\n>>>>>\n>>>>> How would you compare the pros and cons of your account-based approach\n>>>>> to something like a new sighash flag? Eg a sighash flag that says \"I'm\n>>>>> signing this transaction, but the signature is only valid if mined in the\n>>>>> same block as transaction X (or maybe transactions LIST)\". This could be\n>>>>> named SIGHASH_EXTERNAL. Doing this would be a lot more similar to other\n>>>>> bitcoin transactions, and no special account would need to be created. Any\n>>>>> transaction could specify this. At least that's the first thought I would\n>>>>> have in designing a way to arbitrarily bump fees. Have you compared your\n>>>>> solution to something more familiar like that?\n>>>>>\n>>>>> On Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n>>>>>\n>>>>>> Can you clarify what you mean by \"improve the situation\"?\n>>>>>>\n>>>>>> There's a potential mild bytes savings, but the bigger deal is that\n>>>>>> the API should be much less vulnerable to pinning issues, fix dust leakage\n>>>>>> for eltoo like protocols, and just generally allow protocol designs to be\n>>>>>> fully abstracted from paying fees. You can't easily mathematically\n>>>>>> quantify API improvements like that.\n>>>>>> --\n>>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>>> <https://twitter.com/JeremyRubin>\n>>>>>>\n>>>>>>\n>>>>>> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n>>>>>> wrote:\n>>>>>>\n>>>>>>> Do you have any back-of-the-napkin math on quantifying how much this\n>>>>>>> would improve the situation vs existing methods (eg cpfp)?\n>>>>>>>\n>>>>>>>\n>>>>>>>\n>>>>>>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>>>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>>>\n>>>>>>>> Happy new years devs,\n>>>>>>>>\n>>>>>>>> I figured I would share some thoughts for conceptual review that\n>>>>>>>> have been bouncing around my head as an opportunity to clean up the fee\n>>>>>>>> paying semantics in bitcoin \"for good\". The design space is very wide on\n>>>>>>>> the approach I'll share, so below is just a sketch of how it could work\n>>>>>>>> which I'm sure could be improved greatly.\n>>>>>>>>\n>>>>>>>> Transaction fees are an integral part of bitcoin.\n>>>>>>>>\n>>>>>>>> However, due to quirks of Bitcoin's transaction design, fees are a\n>>>>>>>> part of the transactions that they occur in.\n>>>>>>>>\n>>>>>>>> While this works in a \"Bitcoin 1.0\" world, where all transactions\n>>>>>>>> are simple on-chain transfers, real world use of Bitcoin requires support\n>>>>>>>> for things like Fee Bumping stuck transactions, DoS resistant Payment\n>>>>>>>> Channels, and other long lived Smart Contracts that can't predict future\n>>>>>>>> fee rates. Having the fees paid in band makes writing these contracts much\n>>>>>>>> more difficult as you can't merely express the logic you want for the\n>>>>>>>> transaction, but also the fees.\n>>>>>>>>\n>>>>>>>> Previously, I proposed a special type of transaction called a\n>>>>>>>> \"Sponsor\" which has some special consensus + mempool rules to allow\n>>>>>>>> arbitrarily appending fees to a transaction to bump it up in the mempool.\n>>>>>>>>\n>>>>>>>> As an alternative, we could establish an account system in Bitcoin\n>>>>>>>> as an \"extension block\".\n>>>>>>>>\n>>>>>>>> *Here's how it might work:*\n>>>>>>>>\n>>>>>>>> 1. Define a special anyone can spend output type that is a \"fee\n>>>>>>>> account\" (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>>>>>>> associated with them, but are overall anyone can spend.\n>>>>>>>> 2. All deposits to these outputs get stored in a separate UTXO\n>>>>>>>> database for fee accounts\n>>>>>>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee\n>>>>>>>> amount and a TXID (or Outpoint?); B: a withdraw amount, a fee, and\n>>>>>>>> an address\n>>>>>>>> 4. These transactions are committed in an extension block merkle\n>>>>>>>> tree. While the actual signature must cover the TXID/Outpoint, the\n>>>>>>>> committed data need only cover the index in the block of the transaction.\n>>>>>>>> The public key for account lookup can be recovered from the message +\n>>>>>>>> signature.\n>>>>>>>> 5. In any block, any of the fee account deposits can be: released\n>>>>>>>> into fees if there is a corresponding tx; consolidated together to reduce\n>>>>>>>> the number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>>>>>>> released into fees *and paid back* into the requested withdrawal key\n>>>>>>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>>>>>>> 6. Mempool logic is updated to allow attaching of account fee\n>>>>>>>> spends to transactions, the mempool can restrict that an account is not\n>>>>>>>> allowed more spend more than it's balance.\n>>>>>>>>\n>>>>>>>> *But aren't accounts \"bad\"?*\n>>>>>>>>\n>>>>>>>> Yes, accounts are bad. But these accounts are not bad, because any\n>>>>>>>> funds withdrawn from the fee extension are fundamentally locked for 100\n>>>>>>>> blocks as a coinbase output, so there should be no issues with any series\n>>>>>>>> of reorgs. Further, since there is no \"rich state\" for these accounts, the\n>>>>>>>> state updates can always be applied in a conflict-free way in any order.\n>>>>>>>>\n>>>>>>>>\n>>>>>>>> *Improving the privacy of this design:*\n>>>>>>>>\n>>>>>>>> This design could likely be modified to implement something like\n>>>>>>>> Tornado.cash or something else so that the fee account paying can be\n>>>>>>>> unlinked from the transaction being paid for, improving privacy at the\n>>>>>>>> expense of being a bit more expensive.\n>>>>>>>>\n>>>>>>>> Other operations could be added to allow a trustless mixing to be\n>>>>>>>> done by miners automatically where groups of accounts with similar values\n>>>>>>>> are trustlessly  split into a common denominator and change, and keys are\n>>>>>>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>>>>>>> be discovered by tracing the updates posted). These updates could also be\n>>>>>>>> produced by individuals rather than miners, and miners could simply honor\n>>>>>>>> them with better privacy. While a miner generating an update would be able\n>>>>>>>> to deanonymize their mixes, if you have your account mixed several times by\n>>>>>>>> independent miners that could potentially add sufficient privacy.\n>>>>>>>>\n>>>>>>>> The LN can also be used with PTLCs to, in theory, have another\n>>>>>>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>>>>>>> a valid sig from their fee paying account, although under this model it's\n>>>>>>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>>>>>>> withdrawing the rest. However, this could be partly solved by using\n>>>>>>>> reputable fee accounts (reputation could be measured somewhat\n>>>>>>>> decentralized-ly by longevity of the account and transactions paid for\n>>>>>>>> historically).\n>>>>>>>>\n>>>>>>>> *Scalability*\n>>>>>>>>\n>>>>>>>> This design is fundamentally 'decent' for scalability because\n>>>>>>>> adding fees to a transaction does not require adding inputs or outputs and\n>>>>>>>> does not require tracking substantial amounts of new state.\n>>>>>>>>\n>>>>>>>> Paying someone else to pay for you via the LN also helps make this\n>>>>>>>> more efficient if the withdrawal issues can be fixed.\n>>>>>>>>\n>>>>>>>> *Lightning:*\n>>>>>>>>\n>>>>>>>> This type of design works really well for channels because the\n>>>>>>>> addition of fees to e.g. a channel state does not require any sort of\n>>>>>>>> pre-planning (e.g. anchors) or transaction flexibility (SIGHASH flags).\n>>>>>>>> This sort of design is naturally immune to pinning issues since you could\n>>>>>>>> offer to pay a fee for any TXID and the number of fee adding offers does\n>>>>>>>> not need to be restricted in the same way the descendant transactions would\n>>>>>>>> need to be.\n>>>>>>>>\n>>>>>>>> *Without a fork?*\n>>>>>>>>\n>>>>>>>> This type of design could be done as a federated network that\n>>>>>>>> bribes miners -- potentially even retroactively after a block is formed.\n>>>>>>>> That might be sufficient to prove the concept works before a consensus\n>>>>>>>> upgrade is deployed, but such an approach does mean there is a centralizing\n>>>>>>>> layer interfering with normal mining.\n>>>>>>>>\n>>>>>>>>\n>>>>>>>> Happy new year!!\n>>>>>>>>\n>>>>>>>> Jeremy\n>>>>>>>>\n>>>>>>>> --\n>>>>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>>>>> <https://twitter.com/JeremyRubin>\n>>>>>>>> _______________________________________________\n>>>>>>>> bitcoin-dev mailing list\n>>>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>>>\n>>>>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220119/3457bd53/attachment-0001.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-01-20T05:23:12",
                "message_text_only": "Thanks for the info.\n\n> you could \"sponsor yourself\" directly or through a cycle involving > 1\ntxn.\n\nAh I see, because the sighash flags aren't used to create the TXID. I don't\nreally see the problem with cycles tho. Could a cycle cause problems for\nanyone? Seems like it would be a harmless waste of bytes. The\nfee-sponsoring OP_VER looks good too tho.\n\nOn Wed, Jan 19, 2022 at 2:08 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> SIGHASH_BUNDLE\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-April/015862.html\n>\n> By cycles I meant that if you commit to the sponsors by TXID from the\n> witness, you could \"sponsor yourself\" directly or through a cycle involving\n> > 1 txn.\n>\n> With OP_VER I was talking about the proposal I linked here\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n> which used OP_VER to indicate a txn sponsoring txn. Because the OP_VER is\n> in the output space, and uses TXIDs, it is cycle-free.\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Wed, Jan 19, 2022 at 8:52 AM Billy Tetrud <billy.tetrud at gmail.com>\n> wrote:\n>\n>> Hmm, I don't know anything about  SIGHASH_BUNDLE. The only references\n>> online I can find are just mentions (mostly from you). What is\n>> SIGHASH_BUNDLE?\n>>\n>> > unless you're binding a WTXID\n>>\n>> That could work, but it would exclude cases where you have a transaction\n>> that has already been partially signed and someone wants to, say, only sign\n>> that transaction if some 3rd party signs a transaction paying part of the\n>> fee for it. Kind of a niche use case, but it would be nice to support it if\n>> possible. If the transaction hasn't been signed at all yet, a new\n>> transaction can just be created that includes the prospective fee-payer,\n>> and if the transaction is fully signed then it has a WTXID to use.\n>>\n>> > then you can have fee bumping cycles\n>>\n>> What kind of cycles do you mean? You're saying these cycles would make it\n>> less robust to reorgs?\n>>\n>> > OP_VER\n>>\n>> I assume you mean something other than pushing the version onto the stack\n>> <https://bitcoin.stackexchange.com/questions/97258/given-op-ver-was-never-used-is-disabled-and-not-considered-useful-can-its-meani>?\n>> Is that related to your fee account idea?\n>>\n>>\n>> On Wed, Jan 19, 2022 at 1:32 AM Jeremy <jlrubin at mit.edu> wrote:\n>>\n>>> Ah my bad i misread what you were saying as being about SIGHASH_BUNDLE\n>>> like proposals.\n>>>\n>>> For what you're discussing, I previously proposed\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n>>> which is similar.\n>>>\n>>> The benefit of the OP_VER output is that SIGHASH_EXTERNAL has the issue\n>>> that unless you're binding a WTXID (which is maybe too specific?) then you\n>>> can have fee bumping cycles. Doing OP_VER output w/ TXID guarantees that\n>>> you are acyclic.\n>>>\n>>> The difference between a fee account and this approach basically boils\n>>> down to the impact on e.g. reorg stability, where the deposit/withdraw\n>>> mechanism is a bit more \"robust\" for reorderings in reorgs than the in-band\n>>> transaction approach, although they are very similar.\n>>>\n>>> --\n>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>> <https://twitter.com/JeremyRubin>\n>>>\n>>>\n>>> On Tue, Jan 18, 2022 at 8:53 PM Billy Tetrud <billy.tetrud at gmail.com>\n>>> wrote:\n>>>\n>>>> >  because you make transactions third party malleable it becomes\n>>>> possible to bundle and unbundle transactions.\n>>>>\n>>>> What I was suggesting doesn't make it possible to malleate someone\n>>>> else's transaction. I guess maybe my proposal of using a sighash flag\n>>>> might have been unclear. Imagine it as a script opcode that just says \"this\n>>>> transaction must be mined with this other transaction\" - the only\n>>>> difference being that you can use any output with any encumberance as an\n>>>> input for fee bumping. It doesn't prevent the original transaction from\n>>>> being mined on its own. So adding junk inputs would be no more of a problem\n>>>> than dust attacks already are. It would be used exactly like cpfp, except\n>>>> it doesn't spend the parent.\n>>>>\n>>>> I don't think what I was suggesting is as different from your proposal.\n>>>> All the problems of fee revenue optimization and feerate rules that you\n>>>> mentioned seem like they'd also exist for your proposal, or for cpfp. Let\n>>>> me know if I should clarify further.\n>>>>\n>>>> On Tue, Jan 18, 2022 at 8:51 PM Jeremy <jlrubin at mit.edu> wrote:\n>>>>\n>>>>> The issue with sighash flags is that because you make transactions\n>>>>> third party malleable it becomes possible to bundle and unbundle\n>>>>> transactions.\n>>>>>\n>>>>> This means there are circumstances where an attacker could e.g. see\n>>>>> your txn, and then add a lot of junk change/inputs + 25 descendants and\n>>>>> strongly anchor your transaction to the bottom of the mempool.\n>>>>>\n>>>>> because of rbf rules requiring more fee and feerate, this means you\n>>>>> have to bump across the whole package and that can get really messy.\n>>>>>\n>>>>> more generally speaking, you could imagine a future where mempools\n>>>>> track many alternative things that might want to be in a transaction.\n>>>>>\n>>>>> suppose there are N inputs each with a weight and an amount of fee\n>>>>> being added and the sighash flags let me pick any subset of them. However,\n>>>>> for a txn to be standard it must be < 100k bytes and for it to be consensus\n>>>>> < 1mb. Now it is possible you have to solve a knapsack problem in order to\n>>>>> rationally bundle this transaction out of all possibilities.\n>>>>>\n>>>>> This problem can get even thornier, suppose that the inputs I'm adding\n>>>>> themselves are the outputs of another txn in the mempool, now i have to\n>>>>> track and propagate the feerates of that child back up to the parent txn\n>>>>> and track all these dependencies.\n>>>>>\n>>>>> perhaps with very careful engineering these issues can be tamed.\n>>>>> however it seems with sponsors or fee accounts, by separating the pays-for\n>>>>> from the participates-in concerns we can greatly simplify it to something\n>>>>> like: compute effective feerate for a txn, including all sponsors that pay\n>>>>> more than the feerate of the base txn. Mine that txn and it's subsidies\n>>>>> using the normal algo. If you run out of space, all subsidies are\n>>>>> same-sized so just take the ones that pay the highest amount up until the\n>>>>> added marginal feerate is less than the next eligible txn.\n>>>>>\n>>>>>\n>>>>> --\n>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>> <https://twitter.com/JeremyRubin>\n>>>>>\n>>>>>\n>>>>> On Tue, Jan 18, 2022 at 6:38 PM Billy Tetrud <billy.tetrud at gmail.com>\n>>>>> wrote:\n>>>>>\n>>>>>> I see, its not primarily to make it cheaper to append fees, but also\n>>>>>> allows appending fees in cases that aren't possible now. Is that right? I\n>>>>>> can certainly see the benefit of a more general way to add a fee to any\n>>>>>> transaction, regardless of whether you're related to that transaction or\n>>>>>> not.\n>>>>>>\n>>>>>> How would you compare the pros and cons of your account-based\n>>>>>> approach to something like a new sighash flag? Eg a sighash flag that says\n>>>>>> \"I'm signing this transaction, but the signature is only valid if mined in\n>>>>>> the same block as transaction X (or maybe transactions LIST)\". This could\n>>>>>> be named SIGHASH_EXTERNAL. Doing this would be a lot more similar to other\n>>>>>> bitcoin transactions, and no special account would need to be created. Any\n>>>>>> transaction could specify this. At least that's the first thought I would\n>>>>>> have in designing a way to arbitrarily bump fees. Have you compared your\n>>>>>> solution to something more familiar like that?\n>>>>>>\n>>>>>> On Tue, Jan 18, 2022 at 11:43 AM Jeremy <jlrubin at mit.edu> wrote:\n>>>>>>\n>>>>>>> Can you clarify what you mean by \"improve the situation\"?\n>>>>>>>\n>>>>>>> There's a potential mild bytes savings, but the bigger deal is that\n>>>>>>> the API should be much less vulnerable to pinning issues, fix dust leakage\n>>>>>>> for eltoo like protocols, and just generally allow protocol designs to be\n>>>>>>> fully abstracted from paying fees. You can't easily mathematically\n>>>>>>> quantify API improvements like that.\n>>>>>>> --\n>>>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>>>> <https://twitter.com/JeremyRubin>\n>>>>>>>\n>>>>>>>\n>>>>>>> On Tue, Jan 18, 2022 at 8:13 AM Billy Tetrud <billy.tetrud at gmail.com>\n>>>>>>> wrote:\n>>>>>>>\n>>>>>>>> Do you have any back-of-the-napkin math on quantifying how much\n>>>>>>>> this would improve the situation vs existing methods (eg cpfp)?\n>>>>>>>>\n>>>>>>>>\n>>>>>>>>\n>>>>>>>> On Sat, Jan 1, 2022 at 2:04 PM Jeremy via bitcoin-dev <\n>>>>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>>>>\n>>>>>>>>> Happy new years devs,\n>>>>>>>>>\n>>>>>>>>> I figured I would share some thoughts for conceptual review that\n>>>>>>>>> have been bouncing around my head as an opportunity to clean up the fee\n>>>>>>>>> paying semantics in bitcoin \"for good\". The design space is very wide on\n>>>>>>>>> the approach I'll share, so below is just a sketch of how it could work\n>>>>>>>>> which I'm sure could be improved greatly.\n>>>>>>>>>\n>>>>>>>>> Transaction fees are an integral part of bitcoin.\n>>>>>>>>>\n>>>>>>>>> However, due to quirks of Bitcoin's transaction design, fees are a\n>>>>>>>>> part of the transactions that they occur in.\n>>>>>>>>>\n>>>>>>>>> While this works in a \"Bitcoin 1.0\" world, where all transactions\n>>>>>>>>> are simple on-chain transfers, real world use of Bitcoin requires support\n>>>>>>>>> for things like Fee Bumping stuck transactions, DoS resistant Payment\n>>>>>>>>> Channels, and other long lived Smart Contracts that can't predict future\n>>>>>>>>> fee rates. Having the fees paid in band makes writing these contracts much\n>>>>>>>>> more difficult as you can't merely express the logic you want for the\n>>>>>>>>> transaction, but also the fees.\n>>>>>>>>>\n>>>>>>>>> Previously, I proposed a special type of transaction called a\n>>>>>>>>> \"Sponsor\" which has some special consensus + mempool rules to allow\n>>>>>>>>> arbitrarily appending fees to a transaction to bump it up in the mempool.\n>>>>>>>>>\n>>>>>>>>> As an alternative, we could establish an account system in Bitcoin\n>>>>>>>>> as an \"extension block\".\n>>>>>>>>>\n>>>>>>>>> *Here's how it might work:*\n>>>>>>>>>\n>>>>>>>>> 1. Define a special anyone can spend output type that is a \"fee\n>>>>>>>>> account\" (e.g. segwit V2). Such outputs have a redeeming key and an amount\n>>>>>>>>> associated with them, but are overall anyone can spend.\n>>>>>>>>> 2. All deposits to these outputs get stored in a separate UTXO\n>>>>>>>>> database for fee accounts\n>>>>>>>>> 3. Fee accounts can sign only two kinds of transaction: A: a fee\n>>>>>>>>> amount and a TXID (or Outpoint?); B: a withdraw amount, a fee, and\n>>>>>>>>> an address\n>>>>>>>>> 4. These transactions are committed in an extension block merkle\n>>>>>>>>> tree. While the actual signature must cover the TXID/Outpoint, the\n>>>>>>>>> committed data need only cover the index in the block of the transaction.\n>>>>>>>>> The public key for account lookup can be recovered from the message +\n>>>>>>>>> signature.\n>>>>>>>>> 5. In any block, any of the fee account deposits can be: released\n>>>>>>>>> into fees if there is a corresponding tx; consolidated together to reduce\n>>>>>>>>> the number of utxos (this can be just an OP_TRUE no metadata needed); or\n>>>>>>>>> released into fees *and paid back* into the requested withdrawal key\n>>>>>>>>> (encumbering a 100 block timeout). Signatures must be unique in a block.\n>>>>>>>>> 6. Mempool logic is updated to allow attaching of account fee\n>>>>>>>>> spends to transactions, the mempool can restrict that an account is not\n>>>>>>>>> allowed more spend more than it's balance.\n>>>>>>>>>\n>>>>>>>>> *But aren't accounts \"bad\"?*\n>>>>>>>>>\n>>>>>>>>> Yes, accounts are bad. But these accounts are not bad, because any\n>>>>>>>>> funds withdrawn from the fee extension are fundamentally locked for 100\n>>>>>>>>> blocks as a coinbase output, so there should be no issues with any series\n>>>>>>>>> of reorgs. Further, since there is no \"rich state\" for these accounts, the\n>>>>>>>>> state updates can always be applied in a conflict-free way in any order.\n>>>>>>>>>\n>>>>>>>>>\n>>>>>>>>> *Improving the privacy of this design:*\n>>>>>>>>>\n>>>>>>>>> This design could likely be modified to implement something like\n>>>>>>>>> Tornado.cash or something else so that the fee account paying can be\n>>>>>>>>> unlinked from the transaction being paid for, improving privacy at the\n>>>>>>>>> expense of being a bit more expensive.\n>>>>>>>>>\n>>>>>>>>> Other operations could be added to allow a trustless mixing to be\n>>>>>>>>> done by miners automatically where groups of accounts with similar values\n>>>>>>>>> are trustlessly  split into a common denominator and change, and keys are\n>>>>>>>>> derived via a verifiable stealth address like protocol (so fee balances can\n>>>>>>>>> be discovered by tracing the updates posted). These updates could also be\n>>>>>>>>> produced by individuals rather than miners, and miners could simply honor\n>>>>>>>>> them with better privacy. While a miner generating an update would be able\n>>>>>>>>> to deanonymize their mixes, if you have your account mixed several times by\n>>>>>>>>> independent miners that could potentially add sufficient privacy.\n>>>>>>>>>\n>>>>>>>>> The LN can also be used with PTLCs to, in theory, have another\n>>>>>>>>> individual paid to sponsor a transaction on your behalf only if they reveal\n>>>>>>>>> a valid sig from their fee paying account, although under this model it's\n>>>>>>>>> hard to ensure that the owner doesn't pay a fee and then 'cancel' by\n>>>>>>>>> withdrawing the rest. However, this could be partly solved by using\n>>>>>>>>> reputable fee accounts (reputation could be measured somewhat\n>>>>>>>>> decentralized-ly by longevity of the account and transactions paid for\n>>>>>>>>> historically).\n>>>>>>>>>\n>>>>>>>>> *Scalability*\n>>>>>>>>>\n>>>>>>>>> This design is fundamentally 'decent' for scalability because\n>>>>>>>>> adding fees to a transaction does not require adding inputs or outputs and\n>>>>>>>>> does not require tracking substantial amounts of new state.\n>>>>>>>>>\n>>>>>>>>> Paying someone else to pay for you via the LN also helps make this\n>>>>>>>>> more efficient if the withdrawal issues can be fixed.\n>>>>>>>>>\n>>>>>>>>> *Lightning:*\n>>>>>>>>>\n>>>>>>>>> This type of design works really well for channels because the\n>>>>>>>>> addition of fees to e.g. a channel state does not require any sort of\n>>>>>>>>> pre-planning (e.g. anchors) or transaction flexibility (SIGHASH flags).\n>>>>>>>>> This sort of design is naturally immune to pinning issues since you could\n>>>>>>>>> offer to pay a fee for any TXID and the number of fee adding offers does\n>>>>>>>>> not need to be restricted in the same way the descendant transactions would\n>>>>>>>>> need to be.\n>>>>>>>>>\n>>>>>>>>> *Without a fork?*\n>>>>>>>>>\n>>>>>>>>> This type of design could be done as a federated network that\n>>>>>>>>> bribes miners -- potentially even retroactively after a block is formed.\n>>>>>>>>> That might be sufficient to prove the concept works before a consensus\n>>>>>>>>> upgrade is deployed, but such an approach does mean there is a centralizing\n>>>>>>>>> layer interfering with normal mining.\n>>>>>>>>>\n>>>>>>>>>\n>>>>>>>>> Happy new year!!\n>>>>>>>>>\n>>>>>>>>> Jeremy\n>>>>>>>>>\n>>>>>>>>> --\n>>>>>>>>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>>>>>>>>> <https://twitter.com/JeremyRubin>\n>>>>>>>>> _______________________________________________\n>>>>>>>>> bitcoin-dev mailing list\n>>>>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>>>>\n>>>>>>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220119/1724e2e9/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fee Accounts",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev",
                "Pre-BIP"
            ],
            "authors": [
                "Billy Tetrud",
                "Jeremy"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 102592
        }
    },
    {
        "title": "[Lightning-dev] Claiming the 1BTC Strike/HRF \"Stable Channel\" bounty",
        "thread_messages": [
            {
                "author": "Chris Stewart",
                "date": "2022-01-12T00:53:57",
                "message_text_only": "Hi Lightning Devs!\n\nRecently Strike and HRF posted 3 bitcoin bounties for features they want to\nsee implemented in bitcoin. The second one is \"Stable Channels\".\n\nThis requires pegging your bitcoin to a fixed amount of USD value inside of\nyour lightning channel. This can be accomplished with Discreet Log\nContracts inside your lightning channel. We've written about it here:\n\nhttps://suredbits.com/how-to-claim-the-1btc-stable-channel-bounty-from-hrf-and-strike/\n\nThere are some limitations to the blog post (updating the channel state\ninvalidates the DLC funding txid), but this should get you started (when\nAPO?!)\n\nDon't hesitate to reach out if you have questions on the financial\nengineering/DLC side of things.\n\n-Chris\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220111/04ae342b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Claiming the 1BTC Strike/HRF \"Stable Channel\" bounty",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Chris Stewart"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 908
        }
    },
    {
        "title": "[Lightning-dev] Lightning RPC",
        "thread_messages": [
            {
                "author": "William Casarin",
                "date": "2022-01-18T15:46:45",
                "message_text_only": "Hey Christian,\n\nI noticed you are doing RPC stuff... I'm looking to do RPC over\nlightning itself. I started a C library called lnsocket[1], scrounged\nfrom clightning parts, so that I can send messages from iOS to control\nmy lightning node.\n\nI've got to the point with lnsocket where I can send TLVs to my node,\nand now I'm starting to think about what format the RPC commands should\nbe.\n\nI noticed the commando c-lightning plugin just uses the JSON-RPC\npayload, but perhaps something more compact and rpc-friendly like grpc\nwould be better... which is why this cln-grpc PR peaked my curiosity.\n\nI think the end goal of an RPC bolt would be super powerful, so that\nlnsocket could talk to any lightning node, but that could be further\ndown the line. Choosing the right data format seemed like an important\nstep in that direction. Would love to hear your thoughts on this!\n\nI've cc'd clightning/lightning-dev as well to see if anyone else is\nworking on this or thinking about this stuff right now.\n\nCheers,\nWill\n\n[1] http://git.jb55.com/lnsocket\n\nOn Tue, Jan 18, 2022 at 06:01:46AM -0800, Christian Decker wrote:\n>This is the final PR in the cln-* series. It uses all the primitives we\n>built in the previous 3 PRs and uses them to expose the JSON-RPC over\n>grpc, with mTLS authentication builtin. You can view, comment on, or\n>merge this pull request online at:\n>\n>  https://github.com/ElementsProject/lightning/pull/5013\n>\n>-- Commit Summary --\n>\n>  * cln-grpc-plugin: Add scaffolding for the cln-grpc-plugin\n>  * make: Add a hook for us to depend on generated files for tests\n>  * make: Generate grpc bindings if we want to test with rust enabled"
            },
            {
                "author": "Christian Decker",
                "date": "2022-01-19T10:58:40",
                "message_text_only": "Hi Will,\n\n> I noticed you are doing RPC stuff... I'm looking to do RPC over\n> lightning itself. I started a C library called lnsocket[1], scrounged\n> from clightning parts, so that I can send messages from iOS to control\n> my lightning node.\n\nSounds interesting, and similar to commando's goals. Rusty also has a\nsummer of bitcoin project attempting to expose a websocket directly to\nbrowsers in order to provide another way to communicate with your node,\nand of course there's commando.\n\n> I've got to the point with lnsocket where I can send TLVs to my node,\n> and now I'm starting to think about what format the RPC commands should\n> be.\n>\n> I noticed the commando c-lightning plugin just uses the JSON-RPC\n> payload, but perhaps something more compact and rpc-friendly like grpc\n> would be better... which is why this cln-grpc PR peaked my curiosity.\n\nYep, JSON-RPC is rather bad with binary data, and doesn't have any\nconcept of streaming. I personally like grpc because it ticks a lot of\nboxes: secure transport over TLS, mutual authentication via mTLS,\npossibility to add metadata to calls (technically prohibited by the\nJSON-RPC spec) which can help us use macaroons/runes in future,\nstreaming support and compact binary format.\n\nHaving an IDL to describe the interface is also rather nice, even though\nfor cln-grpc we actually generate that from the JSON-RPC schemas, so\nit's a bit less expressive than .proto files.\n\n> I think the end goal of an RPC bolt would be super powerful, so that\n> lnsocket could talk to any lightning node, but that could be further\n> down the line. Choosing the right data format seemed like an important\n> step in that direction. Would love to hear your thoughts on this!\n\nI agree. Exchanging the transport layer underneath grpc doesn't change\nsemantics, but does unlock a number of potential use-cases. I think\neither the JSON-RPC or grpc can serve as a basis for a common RPC\ndefinition that can have any number of bindings, since we generate\nconversion code to/from JSON-RPC and grpc we can transparently map them\nback and forth.\n\n> I've cc'd clightning/lightning-dev as well to see if anyone else is\n> working on this or thinking about this stuff right now.\n\nDefinitely open to suggestions, comments and criticism: the cln-grpc [1]\ncrate is rather new, and will see a number of rebases and fixups, but\nshould be reviewable as is. The cln-plugin [2] crate is a bit less\nwell-fleshed-out, but has the core functionality needed for\ncln-grpc-plugin which was the goal of this first exploration. The\ncln-rpc [4] crate is also missing many RPC commands, but that's just\ngrunt work that I plan to tackle separately :-)\n\nCheers,\nChristian\n\n[1] https://github.com/ElementsProject/lightning/pull/5011\n[2] https://github.com/ElementsProject/lightning/pull/5012\n[3] https://github.com/ElementsProject/lightning/pull/5013\n[4] https://github.com/ElementsProject/lightning/pull/5010"
            },
            {
                "author": "Rusty Russell",
                "date": "2022-01-24T03:24:49",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n>> I noticed the commando c-lightning plugin just uses the JSON-RPC\n>> payload, but perhaps something more compact and rpc-friendly like grpc\n>> would be better... which is why this cln-grpc PR peaked my curiosity.\n>\n> Yep, JSON-RPC is rather bad with binary data, and doesn't have any\n> concept of streaming. I personally like grpc because it ticks a lot of\n> boxes: secure transport over TLS, mutual authentication via mTLS,\n> possibility to add metadata to calls (technically prohibited by the\n> JSON-RPC spec) which can help us use macaroons/runes in future,\n> streaming support and compact binary format.\n\nThe rest is true, but spec doesn't disallow extra fields that I can\nfind?\n\n> Having an IDL to describe the interface is also rather nice, even though\n> for cln-grpc we actually generate that from the JSON-RPC schemas, so\n> it's a bit less expressive than .proto files.\n>\n>> I think the end goal of an RPC bolt would be super powerful, so that\n>> lnsocket could talk to any lightning node, but that could be further\n>> down the line. Choosing the right data format seemed like an important\n>> step in that direction. Would love to hear your thoughts on this!\n>\n> I agree. Exchanging the transport layer underneath grpc doesn't change\n> semantics, but does unlock a number of potential use-cases. I think\n> either the JSON-RPC or grpc can serve as a basis for a common RPC\n> definition that can have any number of bindings, since we generate\n> conversion code to/from JSON-RPC and grpc we can transparently map them\n> back and forth.\n\nYeah, I don't think we'll end up with a control standard.  But I've been\npleasantly surprised before: certainly a common subset would be nice!\n\nCheers!\nRusty."
            },
            {
                "author": "William Casarin",
                "date": "2022-01-24T15:33:32",
                "message_text_only": "On Mon, Jan 24, 2022 at 01:54:49PM +1030, Rusty Russell wrote:\n>Christian Decker <decker.christian at gmail.com> writes:\n>>William Casarin <jb55 at jb55.com> writes:\n>>> I think the end goal of an RPC bolt [blip] would be super powerful,\n>>> so that lnsocket could talk to any lightning node, but that could be\n>>> further down the line. Choosing the right data format seemed like an\n>>> important step in that direction. Would love to hear your thoughts\n>>> on this!\n>>\n>> I agree. Exchanging the transport layer underneath grpc doesn't change\n>> semantics, but does unlock a number of potential use-cases. I think\n>> either the JSON-RPC or grpc can serve as a basis for a common RPC\n>> definition that can have any number of bindings, since we generate\n>> conversion code to/from JSON-RPC and grpc we can transparently map them\n>> back and forth.\n>\n>Yeah, I don't think we'll end up with a control standard.  But I've been\n>pleasantly surprised before: certainly a common subset would be nice!\n\nI ended up just using json+commando for my prototype[1]. I'm not going\nto overengineer anything yet. If there's a way write plugins for the\nother implementations I could start hacking away at a common control\nsubset, since I do eventually want an iOS app that controls all node\nimplementations. I will try to get something working across multiple\nimplementations before writing up a spec.\n\nCheers,\nWill\n\n[1] http://git.jb55.com/lnsocket/file/rpc.c.html"
            }
        ],
        "thread_summary": {
            "title": "Lightning RPC",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Christian Decker",
                "William Casarin"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7763
        }
    },
    {
        "title": "[Lightning-dev] Remove Description From Bolt11 Invoices",
        "thread_messages": [
            {
                "author": "armdxxi",
                "date": "2022-01-31T04:59:53",
                "message_text_only": "All,\n\nIn light of recent AOPP concerns[0] where custodial users have to sign a message from an address to prove that it is theirs when withdrawing from highly regulated exchanges, I thought it was important to bring up that this is happening in the Lightning space as well.\n\nThe tagged field d provides both payers and payees with a description of what the transaction is for. When a Lightning Node creates a BOLT11 invoice with a description, this is signed. The signature verification process validates that it came from a specific node and that it is unaltered.\n\nThe problem is that this is being exploited by bad actors in the regulated space. Unsuspecting users are going along with it not knowing the repercussions.\n\nKYC Node Verification\n\nCompanies like Bottlepay[1] are forcing some users to verify their node by creating a specialized invoice. They ask the user to put PII in the description and give the signed invoice to the service. Afterwards, a database of KYC'd users and their nodes may be stored and shared with 3rd parties, regulators, and governments.\n\nGiven that the Lightning Network is a reputation-based system without an easy way to handle rotations, this has lasting effects if this practice were to scale out to all providers. At least with AOPP, one may spin up a new on-chain address with ease and attempt to mitigate linkage via coinjoin.\n\nThis alone is enough to recommend wallet devs to remove the ability for users to unknowingly sign statements with their node. Just like with the widespread removal of AOPP from hardware/software wallets, exchanges may stop expecting that users are capable of handing over this information with ease.\n\nPayment Reason Aggregation\n\nOn the payment receiver side, a user may add a description for their reference later on. In an ideal world, only the payer and payee are the ones that know the reason for the payment. However, given the current reliance on custodians today, these 3rd parties can see and store this information.\n\nA good thread[2] highlights some of these concerns. If exchanges are relaying invoices to chain analytic companies[3], this can be pretty revealing in aggregation.\n\nWhat they'd know solely on processing Bolt11 invoice data:\n\n-  Which internal UserID is paying\n-  Which Lightning Node is receiving a payment\n-  Amount\n-  Payment Reason\n\nThis information collected in bulk will allow them to map out risk scores across the network. These risk scores will lead to censorship problems. Additionally, they may share suspected node owners and their known transactions with malicious parties.\n\nThe onus is on the receiver to not create invoices that reveal personal information. But how is a user supposed to know that it could end up being collected by 3rd party analytic aggregators? In the end, users may just want to tag the invoice and store it internally for their reference. Even custodial wallet developers don't realize the repercussions to invoice descriptions[4].\n\nGiven this, one suggestion I have is to clearly communicate that the information users put in invoices can be verified by 3rd parties. Ideally wallet devs should remove description completely.\n\nDescription Hash\n\nUsing the tagged field description hash h instead of description d might help but there are a few problems.\n\nFor one, there's a transport problem that's not handled by the BOLT11 specification. From the spec: the transport mechanism for the description in that case is transport specific and not defined here.\n\nA payer's wallet client needs to be able to receive two values from the payee now. Both the invoice with the description hash and the description text itself. This could happen via QR code in the typical flow today, but the problem is that information is still parsed by the payer's wallet.\n\nSo if the payer's wallet is a custodian, the custodian is still capable of knowing and relaying both Bolt11 Invoice and the unhashed description. The benefit is that they may choose not to collect this description information. Though it still leaves the door open for bad actors.\n\nFurther, a salt would need to be added to descriptions for common payment reasons to not be guessed.\n\nIn the end, description hash is better than description, but there are UX considerations that may not solve the problem. My suggestion is to save the description to the wallet database instead of putting it in the invoice. Payers should be provided with a similar description text box that may be saved in their database. This gives both users the ability to conceal the real reason even if their wallet is a custodian.\n\nSummary\n\nThere's enough exploitation currently happening with Bolt11 invoices that we should be concerned about this. My recommendation is to remove the ability for users to shoot themselves in the foot. This can happen at the application layer today by removing descriptions from wallets. The lack of description support will help hinder the ability for mass surveillance in the Lightning space.\n\nRegards,\narmdxxi\n\nLinks:\n[0] https://bitcoinmagazine.com/technical/bitcoin-aopp-and-the-swiss-travel-rule\n[1] https://web.archive.org/web/20210616100214/https://help.bottlepay.com/en/articles/5303125-why-and-how-do-i-verify-my-node\n[2] https://twitter.com/niftynei/status/1479154453777465344\n[3] https://blog.chainalysis.com/reports/lightning-network-support/\n[4] https://twitter.com/MattAhlborg/status/1435350678814302211\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220131/c1474c61/attachment.html>"
            },
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2022-01-31T15:10:22",
                "message_text_only": "(sorry for double message, wrong button)\n\nHi,\n\nI object to the idea that AOPP-like verification is harmful *to lightning*,\nquite contrary, it's beneficial! Also removing description creates another\nproblem: impossibility to prove payment for goods or services making\narbitration hard or impossible.\n\nWhy it's beneficial?\n\nSuppose there's a dissident in a dictatorship country wanting to buy banned\ngoods. He pays using LN. There are two possibilities:\n0. exchange doesn't enforce description\n1. exchange does enforce description\n\nLet's look at case 0:\nThe dissident, who happens to not be that knowledgeable about security buys\nsats at an exchange and inputs the destination invoice from whoever he pays\ndirectly into the exchange. The exchange logs this along with the identity.\nSome time later the node ID being paid for banned goods leaks (very likely\nfor public nodes) and the tyrants use this to track down dissidents. The\ndissident is screwed.\n\nCase 1:\nThe dissident withdraws to his non-custodial wallet (can't do anything\nelse) which he then uses to pay. The exchange can not possibly see where\nthe payment went from non-custodial wallet or if it was even sent away.\nRecipients don't know identities of senders so no matter what information\nleaks, it's impossible to link the payment.\n\nThe biggest real problem with the enforcement is the fact that invoices\nleak txids of private channels even though they shouldn't have to. *This*\nneeds to be fixed, really. Also node IDs could be rotated.\n\nAssuming it's fixed, \"KYC\" of a private node ID is completely meaningless.\nThe exchange can not see where the sats ultimately end up - either LN or\nchain. It's essentially equivalent to assigning meaningless random number\nto each transaction.\n\nThis assumes \"private\" channels but has a simple workaround for public\nnodes too. An operator of popular public node can just connect to self and\npretend it's some random person routing through him. It's essentially\nimpossible to prove it's not the case.\n\nNote that this whole reasoning doesn't apply to BTC chain as addresses\ndon't have such strong privacy properties but could be applied to e.g.\nMonero (maybe a bit weaker guarantee; not endorsing it).\n\nI'm not saying that we should (not) proactively support these efforts,\nsince accepting regulations is bad precedent but it could be the case here\nthat it's a good way to turn regulations against the regulators and it\ncould outweigh the cons.\n\nHope I'm clear enough. Cheers!\nMartin\n\nOn Mon, Jan 31, 2022, 06:07 armdxxi via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> All,\n>\n> In light of recent AOPP concerns[0] where custodial users have to sign a\n> message from an address to prove that it is theirs when withdrawing from\n> highly regulated exchanges, I thought it was important to bring up that\n> this is happening in the Lightning space as well.\n>\n> The tagged field d provides both payers and payees with a description of\n> what the transaction is for. When a Lightning Node creates a BOLT11 invoice\n> with a description, this is signed. The signature verification process\n> validates that it came from a specific node and that it is unaltered.\n>\n> The problem is that this is being exploited by bad actors in the regulated\n> space. Unsuspecting users are going along with it not knowing the\n> repercussions.\n> KYC Node Verification\n>\n> Companies like Bottlepay[1] are forcing some users to verify their node by\n> creating a specialized invoice. They ask the user to put PII in the\n> description and give the signed invoice to the service. Afterwards, a\n> database of KYC'd users and their nodes may be stored and shared with 3rd\n> parties, regulators, and governments.\n>\n> Given that the Lightning Network is a reputation-based system without an\n> easy way to handle rotations, this has lasting effects if this practice\n> were to scale out to all providers. At least with AOPP, one may spin up a\n> new on-chain address with ease and attempt to mitigate linkage via coinjoin.\n>\n> This alone is enough to recommend wallet devs to remove the ability for\n> users to unknowingly sign statements with their node. Just like with the\n> widespread removal of AOPP from hardware/software wallets, exchanges may\n> stop expecting that users are capable of handing over this information with\n> ease.\n> Payment Reason Aggregation\n>\n> On the payment receiver side, a user may add a description for their\n> reference later on. In an ideal world, only the payer and payee are the\n> ones that know the reason for the payment. However, given the current\n> reliance on custodians today, these 3rd parties can see and store this\n> information.\n>\n> A good thread[2] highlights some of these concerns. If exchanges are\n> relaying invoices to chain analytic companies[3], this can be pretty\n> revealing in aggregation.\n>\n> What they'd know solely on processing Bolt11 invoice data:\n>\n>    1. Which internal UserID is paying\n>    2. Which Lightning Node is receiving a payment\n>    3. Amount\n>    4. Payment Reason\n>\n> This information collected in bulk will allow them to map out risk scores\n> across the network. These risk scores will lead to censorship problems.\n> Additionally, they may share suspected node owners and their known\n> transactions with malicious parties.\n>\n> The onus is on the receiver to not create invoices that reveal personal\n> information. But how is a user supposed to know that it could end up being\n> collected by 3rd party analytic aggregators? In the end, users may just\n> want to tag the invoice and store it internally for their reference. Even\n> custodial wallet developers don't realize the repercussions to invoice\n> descriptions[4].\n>\n> Given this, one suggestion I have is to clearly communicate that the\n> information users put in invoices can be verified by 3rd parties. Ideally\n> wallet devs should remove description completely.\n> Description Hash\n>\n> Using the tagged field description hash h instead of description d might\n> help but there are a few problems.\n>\n> For one, there's a transport problem that's not handled by the BOLT11\n> specification. From the spec: the transport mechanism for the description\n> in that case is transport specific and not defined here.\n>\n> A payer's wallet client needs to be able to receive two values from the\n> payee now. Both the invoice with the description hash and the description\n> text itself. This could happen via QR code in the typical flow today, but\n> the problem is that information is still parsed by the payer's wallet.\n>\n> So if the payer's wallet is a custodian, the custodian is still capable of\n> knowing and relaying both Bolt11 Invoice and the unhashed description. The\n> benefit is that they may choose *not* to collect this description\n> information. Though it still leaves the door open for bad actors.\n>\n> Further, a salt would need to be added to descriptions for common payment\n> reasons to not be guessed.\n>\n> In the end, description hash is *better* than description, but there are\n> UX considerations that may not solve the problem. My suggestion is to save\n> the description to the wallet database instead of putting it in the\n> invoice. Payers should be provided with a similar description text box that\n> may be saved in their database. This gives both users the ability to\n> conceal the real reason even if their wallet is a custodian.\n> Summary\n>\n> There's enough exploitation currently happening with Bolt11 invoices that\n> we should be concerned about this. My recommendation is to remove the\n> ability for users to shoot themselves in the foot. This can happen at the\n> application layer today by removing descriptions from wallets. The lack of\n> description support will help hinder the ability for mass surveillance in\n> the Lightning space.\n>\n> Regards,\n> armdxxi\n>\n> Links:\n> [0]\n> https://bitcoinmagazine.com/technical/bitcoin-aopp-and-the-swiss-travel-rule\n> [1]\n> https://web.archive.org/web/20210616100214/https://help.bottlepay.com/en/articles/5303125-why-and-how-do-i-verify-my-node\n> [2] https://twitter.com/niftynei/status/1479154453777465344\n> [3] https://blog.chainalysis.com/reports/lightning-network-support/\n> [4] https://twitter.com/MattAhlborg/status/1435350678814302211\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20220131/0b4903a4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Remove Description From Bolt11 Invoices",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "armdxxi",
                "Martin Habov\u0161tiak"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 14177
        }
    }
]