[
    {
        "title": "[Lightning-dev] Witness asymmetric payment channels",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-09-01T02:53:49",
                "message_text_only": "Hi Z,\n\nThanks as usual for your thoughtful comments\n\nI agree with you that there is no improvement in complexity in the formal sense.\nI do believe it is an improvement in conceptual complexity.\nAt least, I am able to keep all the moving parts in my head at the\nsame time whereas I struggle sometimes with the current BOLT spec.\n\nUnfortunately, while thinking about the above statement I realised\nthere is worse storage complexity.\nIn order to punish a revoked commitment transaction efficiently you\nneed to extract the publication secret.\nBut in order to do that you need to keep around the encrypted\nsignature (a.k.a adaptor signature) **for that particular commitment\ntransaction**.\nThis means you have O(n) storage, unlike the present spec which has\nO(1) by deriving the previously revealed revocation secret from the\npresent one (this can't be done with adaptor signatures).\nThis doesn't seem to be addressed in the original work.\n\nYikes! This might be a fatal flaw to this proposal unless it can be addressed.\n\n> When we have \"the same\" transaction on both sides, however, we need to synchronize between the two sides.\n\nCan you elaborate on this? I think you can carry on using the same\nBOLT 2 update protocol within this channel system.\nThe txids being the same for both parties sometimes seems to be incidental.\nIt may be advantageous to use an alternative protocol that forces a\nsynchronization of the commitment transactions but I don't *think* it\nis a requirement.\nI guess you would need to sync  in Decker-Russell-Osuntokun because it\nneeds an objective ordering of commitment transactions.\nThat is seemingly not the case here though\n\nLL\n\nOn Tue, Aug 25, 2020 at 10:45 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Lloyd,\n>\n> I think this is excellent work overall.\n>\n> With that said...\n>\n>\n> > -   It is more elegant as there are half the number of possible transactions. I\n> >     expect this will follow through to reduced implementation complexity and maybe\n> >     make it easier to explain as well.\n>\n> I am not sure the complexity will be reduced all that much.\n>\n> Currently:\n>\n> * We provide a partial signature for the other side for their commitment transaction.\n> * We keep our own commitment transaction and the partial signature we receive from the other side.\n>\n> The node never has to retain the commitment transaction of the other side.\n>\n> With this setup:\n>\n> * We provide a partial signature for the other side for their asymmetric signature.\n> * We keep a copy of the shared commitment transaction and the partial signature we received for our own asymmetric signature from the other side.\n>\n> So storage complexity is still the same.\n>\n> An issue is that with asymmetric transactions, it is fairly easy to use TCP to communicate changes to the commitment txes.\n> We send a bunch of HTLC changes we want to apply to the other side commitment tx, then send a signature for those changes.\n> Since what we send applies to *their* transaction only, we do not have to consider what they sent to us, we just have to consider what we sent to them.\n> Conversely, when keeping track of what our commitment transaction is, we only have to consider what they sent to us, in order, and then when we receive a signature we know it is for the commitment transaction with all the updates the other side sent.\n>\n> (This arguably just moves the complexity higher, however: we cannot forward an HTLC until both us and the other side have revoked the transactions that do not contain it i.e. the \"irrevocably committed\" state.)\n>\n> When we have \"the same\" transaction on both sides, however, we need to synchronize between the two sides.\n> Suppose both participants want to forward HTLCs to one another.\n> Without any kind of locking, both participants could send network packets containing the HTLCs they want to add to each other, and it becomes ambiguous whether the signature they *should* send contains one, or both.\n>\n> Basically, TCP only assures a global order for *one* direction of the communications, once we have two network nodes talking simultaneously, the order in which one writes and then reads is a lot more ambiguous.\n>\n> This issue also exists for Decker-Russell-Osuntokun, incidentally.\n>\n> One way to solve this would be to have a \"token\" that is passed alternately between the participants.\n> At initial connection, they run a secure multiparty coinflip that indicates which one gets the token.\n> Then, the one that holds the token can add more HTLCs, then tell the other \"okay, now we sign\" and they exchange signatures for a new version that involves only the HTLCs from the token-holder.\n> Then the token-holder passes the token to the other side.\n>\n> If the current token-holder does not have any HTLCs it wants to send, it can wait for some time (in case it receives a request to forward), then if there are still no HTLCs, it can pass the token to the other side by sending a token-passing message.\n>\n> This solution requires a good amount of bandwidth in such token-passing messages, which can multiply with the number of channels a single node has.\n> If token-passing is not done in short time frames (sub-second) then it potentially increases the latency of forwarding, thus this represents a latency vs bandwidth tradeoff.\n>\n> There may be better solutions for this race-condition problem.\n> For example, it seems to me that we can still have different histories for both sides of the channel, i.e. different transactions on both sides, the same as in current Poon-Dryja BOLT.\n> After all, the witnesses are asymmetric anyway.\n> But that completely negates the stated goal of removing the different transactions on both sides and the hoped-for reduction in complexity, so an exercise in futility.\n>\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-09-01T20:27:15",
                "message_text_only": "> Unfortunately, while thinking about the above statement I realised\n> there is worse storage complexity.\n> In order to punish a revoked commitment transaction efficiently you\n> need to extract the publication secret.\n> But in order to do that you need to keep around the encrypted\n> signature (a.k.a adaptor signature) **for that particular commitment\n> transaction**.\n> This means you have O(n) storage, unlike the present spec which has\n> O(1) by deriving the previously revealed revocation secret from the\n> present one (this can't be done with adaptor signatures).\n> This doesn't seem to be addressed in the original work.\n>\n> Yikes! This might be a fatal flaw to this proposal unless it can be\naddressed.\n>\n\nFortunately, I am wrong. At least in the case of non-aggregated 2-of-2 you\ncan deterministically produce the encrypted signature by yourself for any\ncommitment transaction as long as you use a deterministic nonce.\nBut I think if using MuSig you would need to store each two party generated\nencrypted signature.\nSeeing as the likely way forward would be to use MuSig on an output which\nhas a taproot which hides a discrete 2-of-2 this may not be a problem.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200902/ccfda71e/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-09-10T03:56:02",
                "message_text_only": ">\n>\n> Fortunately, I am wrong. At least in the case of non-aggregated 2-of-2 you\n> can deterministically produce the encrypted signature by yourself for any\n> commitment transaction as long as you use a deterministic nonce.\n> But I think if using MuSig you would need to store each two party\n> generated encrypted signature.\n> Seeing as the likely way forward would be to use MuSig on an output which\n> has a taproot which hides a discrete 2-of-2 this may not be a problem.\n>\n\nUpon further reflection I was missing something obvious when I came to this\nconclusion. You can't produce the adaptor signature for a commitment\ntransaction deterministically without the encryption key (the other party's\npublication point).\nAs long as we have to store the other party's per-commitment publication\npoint we still need O(n) storage where n is the number of commitment\ntransactions. Sorry for the confusion.\n\nFortunately I had a bit of a breakthrough which allows us to eliminate\npublication points altogether and enables O(1) storage when 2-of-2\nmulti-signatures are instantiated with or without key aggregation (i.e.\nMuSig or OP_CHECKMULTISIG).\n\n### Eliminating Publication Points In favor of  \"revocable signatures\" (for\nOP_CHECKMULTISIG)\n\nI propose replacing the publication point with a static key that remains\nthe same with each commitment transaction.\nThe encryption key for each commitment transaction adaptor signature is (Ra\n+ A)  for Alice and (Rb + B) for Bob.\nTherefore, Alice broadcasting her commitment transaction would reveal the\ndiscrete log of Ra + A (and Bob Rb + B).\nNote that if Alice has not revealed her recvocation key (Ra) for this\ncommitment transaction she is not in trouble since her static key A is\nblinded by Ra. If she has then Bob will learn her static secret key for A.\nThe intuition here is that the revocation key acts as a blinding factor for\nthe static key in the same way a nonce blinds your secret key in a schnorr\nsignature (more on that later).\nIf you haven't revealed your revocation key then you are free to use that\nsignature. If you have revealed the revocation key then you have in effect\n\"revoked\" the signature.\n\nNow we need to make sure that if a party learns the secret key of the other\nthey can efficiently punish them so make the following changes to my\noriginal proposal:\n\nBalance output for Alice is  2-of-2(A , Rb + B)\nBalance output for Bob is   2-of-2(Ra + A, B)\n\nThe implication of the above structure is that if you broadcast a\ncommitment transaction the other party can take their balance immediately.\nIf you broadcasted a revoked commitment transaction then they can take\ntheir output and yours immediately.\n\nPTLC outputs and all subsequent transaction outputs then simplify to\n2-of-2(A,B) on every output. Yay!\nConsider a PTLC paying to Alice. The PTLC-success output can be\n2-of-2(A,B). If Alice broadcasted it and it has been revoked then Bob knows\nA and B so he can punish her.\nThe converse is true for the PTLC-timeout.\nThis elegant uniformity extends to other off-chain protocols hosted in\nthese channels e.g. DLCs\n\nSince A and B are static per channel and the secret keys for Ra and Rb can\nbe incrementally derived from subsequent values (as in the present\nlightning spec) we have O(1) communication.\nIn practice each 2-of-2(A,B) should be randomized so they don't all look\nthe same.\n\n### Revoking key aggregated schnorr signatures (for MuSig)\n\nEven with the above improvement there is still O(n) storage if using key\naggregation (MuSig) on the funding transaction output.\nKey aggregation may be desirable here since you may want to not use a\ntaproot spend to broadcast a commitment transaction.\nSince the two party adaptor signature scheme needs randomness from both\nparties, you would have to store the other party's nonce and retrieve it to\ndeterministically produce the adaptor signature so you can extract Ra + A\n(if Alice broadcasts) from the witness of the commitment transaction.\n\nFortunately, there is a natural way to revoke a key aggregated signature\nyou helped produce without using adaptor signatures at all: just reveal the\nnonce you used for it to the other party.\nThis prevents you from broadcasting it since the other party can now\nextract your secret key from it!\nExplicitly, two party signature generate two Schnorr signatures for the key\nA + B in the form:\n\nsa = ra + rb' + H(Ra + Rb' || A + B || m)(a + b)\nsb = ra' + rb + H(Ra' + Rb || A + B || m)(a + b)\n\n- (ra,rb) are the revocation secret keys,\n- (ra', rb') are typical deterministically produced[1] nonces with Ra' =\nra' * G etc.\n- (a,b) are the static secret keys\n\nOnly Alice knows sa and only Bob knows sb but they are both signatures on\nthe same commitment transaction.\nThis is the witness asymmetry in the protocol.\n\nWhen revoking the commitment transaction associated with sa Alice reveals\nra to Bob and vice versa. If Alice uses sa after that, Bob can\ndeterministically produce rb' and ra (because each revocation key can be\nderived from the last) and therefore can produce:\n\nra + rb' + H(Ra + Rb' || A + B || m)b\n\nwhich when subtracted from sa and divided by H(Ra + Rb' || A + B || m) will\nyield b (Bob's static secret key).\n\nThe advantage of witness asymmetric channels using discrete keys over\npresent lightning seems to boil down to a simpler transaction structure (in\nfavour of using more complicated cryptography).\nHowever, for key aggregation there is a measurable improvement in\ncommunication complexity: It halves the amount of interactive signatures\nthat need to be computed per payment.\nThis is because each PTLC does not need to be duplicated across the\nasymmetric state of both parties.\n\nZeeman pointed out in [2] that the number of signing rounds (which this\ndoes not improve) may be prohibitive anyway for payment applications at\nleast so it remains to be seen whether this efficiency can be utilised  for\npayment PTLCs in LN.\nThankfully, there are still advancements being made in Schnorr key\naggregated signing so the right answer to this might change over time.[3]\n\n[1] The caveats about not using deterministic nonces in MuSig can be\navoided here since we necessarily have state in LN.\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002375.html\n[3]\nhttps://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200910/db11d979/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Witness asymmetric payment channels",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Lloyd Fournier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 13695
        }
    },
    {
        "title": "[Lightning-dev] Simulating Eltoo Factories using SCU Escrows (aka SCUE'd Eltoo)",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2020-09-01T12:38:58",
                "message_text_only": "Hi Nadav,\n\nthanks for writing up this proposal. I think I can add a bit of details,\nwhich might simplify the proposal.\n\n## Ordering of updates\n\nThe way we ensure that an update tx (as the commitment txs are called in\nthe paper) can be attached only to prior updates is done by comparing\nthe state-number committed to in the prevout script with the current\ntimelock through CLTV. This functionality exists today already, and does\nnot have to be implemented by the Escrow at all: it can just sign off on\nany update transaction and the monotonicity of the sequence of updates\nis guaranteed through the script.\n\nThis should simplify the escrow considerably and allow us to disclose\nless to it.\n\n## Emulating `sighash_anyprevout`\n\nWe can emulate `sighash_anyprevout` and variants today already, if we\nknow all the transactions we'd eventually want to bind to at the time we\ncreate the transaction that'd use `anyprevout`: simply iterate through\nall the transactions it might bind to, update the transaction we're\nsigning with the prevout details of that potential binding, and sign\nit. There are two downsides to this, namely processing overhead to\ngenerate `n` signatures for `n` potential bindings, and communication\noverhead, since we're now exchanging `n` signatures, instead of a single\n`anyprevout` signature, but it can work.\n\nI think with the escrow we can defer the creation of the signature to\nthe time we need it, and externalize the anyprevout logic: at each\nupdate all parties sign a statement that they are ok with state\n`k`. Should one party become unresponsive, or broadcast an intermediate\nTX k'<k, the other party can take the statement to the escrow, which\nverifies the signature of the misbehaving party and co-signs the state\n`k`, basically taking on the role of the misbehaving party.\n\nNotice that the \"statement\" above could just be the update TX bound to\nthe funding outpoint, meaning that in the happy case we'd just be able\nto use that to collaboratively close the contract, otherwise we use the\nescrow to rebind the update to whatever happened inbetween.\n\n## Escrow collusion\n\nWhile not particularly familiar with SCU, I think the escrow might need\nto be ultimately trusted, since giving it the ability to act as\nco-signer in lieu of a subset of participants, or even sole signature\nauthority could lead to collusion between the escrow and the remainder\nof the contract participants, but I'm happy to be corrected here.\n\nWe had similar considerations while working on the original channel\nfactories paper, where we tried to come up with a scheme that'd allow a\nsubset of participants to split out an inactive participant in order to\nrecover from what would otherwise be a deadlock. We decided to drop that\npossibility due to the complexity involved and the potential for serious\ndamage if participants collude.\n\n## Fees\n\nThe way we handle fees in eltoo is simply sign the update txs with\nsighash_single, allowing us to attach fees at a later point in\ntime. This is also what we're trying to do with the LN spec at the\nmoment by externalizing the fees with the anchor outputs proposal.\n\n\nOverall I really like the idea of using an escrow to optimize the my\n\"just sign all variants\" workaround, let's see where it takes us :-)\n\nCheers,\nChristian\n\nNadav Kohen <nadav at suredbits.com> writes:\n> Hi all,\n>\n> # Simulating Eltoo / ANYPREVOUT Factories Using SCU Escrows\n>\n> In this write-up I hope to convince you that it is possible to create some\n> weak version of Eltoo channels and channel factories today without\n> SIGHASH_ANYPREVOUT (although the version using this sighash is clearly\n> superior) using ZmnSCPxj's proposal Smart Contracts Unchained (SCU) which\n> Ben Carman has cleverly given the name SCUE'd Eltoo.\n>\n> ## Introduction\n>\n> ### Eltoo / ANYPREVOUT\n>\n> Eltoo is a proposal for a new (and generally improved) way of doing\n> Lightning channels which also allows for multi-party channels (and channel\n> factories). I am by no means fluent in the going's on of eltoo and\n> anyprevout so I will link https://blockstream.com/eltoo.pdf and\n> https://bitcoinops.org/en/topics/sighash_noinput/. My understanding is that\n> at a high level, rather than using a penalty mechanism to update channel\n> states, sighash_anyprevout is used to make any old commitment transaction\n> spendable by any newer commitment transaction so that old revoked states\n> can be updated on-chain instead of relying on a punishment mechanism.\n> Benefits of this scheme include but are not limited to easier watchtower\n> implementations, static partial backups, and multi-party channels.\n>\n> ### Smart Contracts Unchained (SCU)\n>\n> I strongly recommend the reader read this write up by ZmnSCPxj before\n> continuing https://zmnscpxj.github.io/bitcoin/unchained.html\n>\n> At a high level the idea is to use a participant-chosen \"federation\" of\n> \"escrows\" which can be thought of as virtual machines which understand\n> contracts written in some language and which enforce said contracts by\n> giving users signatures of transactions that are produced by these\n> contracts. A general goal of SCU is to be trust-minimizing and as private\n> as possible. For example, escrows should not be able to see that they are\n> being used if there are no disputes, among other considerations that can be\n> made to make SCU Escrows as oblivious as possible (discussed further below).\n>\n> ## Proposal (Un-Optimized)\n>\n> At a high level, this proposal is to replace the use of ANYPREVOUT with a\n> federation of SCU Escrows which will enforce state updates by only\n> generating signatures to spend older states with newer ones.\n>\n> I will work in the general context of multi-party channels but all of this\n> works just as well in two-party (Lightning) channels.\n>\n> Say that we have N parties who wish to enter into a multi-party channel\n> (aka channel factory). Each participant has a public key P_i and together\n> they do a distributed key generation (DKG) of some kind to reach some\n> shared secret x (for example, each party contributes a commitment to a\n> random number and then that random number, MuSig style, and the sum of\n> these random numbers constitutes the shared secret). This x will be used to\n> derive a sequence of (shared) key pairs (x_k, X_k) (for example this can be\n> done by having x_k = PRNG(x, k)).\n>\n> Let State(k) be some agreed upon commitment of the channel state at update\n> k (for example, HMAC(k, kth State Tx outputs)). State(0) is a commitment to\n> 0 and the initial channel balances.\n>\n> Let Delta be some CSV timelock.\n>\n> For the sake of simplicity, let us consider the case where only a single\n> SCU escrow is used which has public key E, but note that all of the\n> following can be extended to a threshold scheme of escrows. E_k will be\n> used to denote some tweak of E by State(k) similar to the tweak described\n> in SCU.\n>\n> ### Transactions\n>\n> #### Funding Transaction\n>\n> Like all such schemes, the funding transaction is some transaction\n> containing an N-of-N multi-signature output with keys P_1, ..., P_N called\n> the funding output.\n>\n> #### Commitment Transaction\n>\n> The commitment transaction spends the funding output and has a single\n> output which has two spending conditions: Either E_k and X_k sign OR all N\n> parties sign cooperatively after Delta.\n>\n> #### State Transaction\n>\n> The state transaction spends the commitment transaction via the cooperative\n> branch and has (potentially many) outputs representing the current channel\n> state. For example there will be an output for each solvent participant in\n> this channel, as well as an output for ever contract living on this channel\n> (for instance, other smaller channels).\n>\n> #### Commitment Update Transaction\n>\n> Let k2 be some state where k2 > k.\n>\n> The commitment update transaction spends either a commitment transaction's\n> non-cooperative branch (E_k and X_k) or another commitment update\n> transaction's non-time-locked branch, and has a single output which has two\n> spending conditions: Either E_k2 and X_k2 sign OR E_k2' and X_k2' sign\n> after Delta where those are tweaked keys in some way (to avoid signatures\n> generated for one case being used in the other).\n>\n> #### State Update Transaction\n>\n> The state update transaction spends the commitment update transaction via\n> the time-locked branch and has outputs equal to those on the (k2)th state\n> transaction.\n>\n> ### Update Mechanism\n>\n> The update mechanism here is the same as would be expected for a\n> multi-party payment channel but with the added step that all parties must\n> sign the commitment State(k) before they sign State Transaction k.\n>\n> ### Settlement\n>\n> #### Cooperative (Normal Close)\n>\n> As you might expect, cooperative closure is where a transaction is\n> cooperatively constructed which directly spends the on-chain funding UTXO\n> and outputs the current State Transaction's outputs.\n>\n> #### Non-Cooperative (Force Close)\n>\n> In any case where not all parties are able or willing to sign a cooperative\n> closing transaction, any party can broadcast the most recent commitment\n> transaction, which can then be spent by anyone broadcasting the most recent\n> state transaction after Delta.\n>\n> If, at any time, any party broadcasts an old commitment transaction k < c,\n> any other party has until Delta to correct this mistake/attack. They do so\n> by going to the SCU Escrow and presenting all signatures of State(k) and of\n> State(c) which the Escrow verifies as well as verifying that k < c. Should\n> all of these things check out, the Escrow can construct a Commitment Update\n> Transaction (for (k, k2) = (k, c)) and the corresponding State Update\n> Transaction and sign both of these transactions using E. These signatures\n> (along with signatures from the shared keys X_k and X_c) can be used to\n> broadcast the commitment update transaction, and after Delta, the state\n> update transaction.\n>\n> If a commitment update transaction is broadcast for an old state c < c',\n> then any party has until Delta to correct this mistake/attack. They do so\n> by following the same exact steps as in the previous paragraph but with k\n> <- c and c <- c' and where the Commitment Update Transaction spends the\n> previous Commitment Update Transaction instead of a Commitment Transaction.\n>\n> In this way any channel participant can unilaterally update the on-chain\n> commitment transaction until the most recent state is reached after which\n> Delta will pass and a State Update Transaction with the current state will\n> be valid to broadcast.\n>\n> ## Optimizations and Open Details\n>\n> ### Multiple Escrows\n>\n> The above can be done with some user-chosen federation with some threshold\n> by replacing E above with a threshold condition using many escrow public\n> keys. Doing so with as large and diverse a federation as possible is\n> strongly encouraged as it reduces the likelihood that the federation will\n> be bribed to spend the non-time-locked branch of the commitment transaction\n> along with some channel participant directly. I believe it should\n> (hopefully) be possible to make such an attack traceable (i.e. provide\n> proof that this happened in an illegal way) so that attacked parties can\n> prove that Escrows have been malicious.\n>\n> ### Taproot\n>\n> As is mentioned in SCU, the escrow scheme is made much better (especially\n> in the multi-escrow case) by Taproot and the above scheme using SCU is\n> improved even further as all outputs are bi-conditional and these two\n> conditions can be separated into different merkle branches to increase\n> privacy and fungibility.\n>\n> ### What is given to the Escrow? (aka Blinding / ZKP)\n>\n> In the above proposal, virtually all information about the channel, as well\n> as how to find it on chain, is given to the escrow(s). This is really bad,\n> and luckily it is avoidable! In principal we want Escrows to do nothing but\n> (potentially many) random looking simple computations on random looking\n> inputs to generate random looking outputs. The algorithm given the the\n> Escrow is currently:\n>\n> Inputs =\n>\n> * output to spend (either a commitment output or a commitment update output)\n> * State(k) corresponding to that output\n> * signatures of State(k)\n> * State(c) with c > k\n> * signatures of State(c)\n> * N public keys\n> * Relevant shared public keys\n> * Delta\n>\n> Output = If any signature is invalid or c <= k, FAIL. Otherwise, generate a\n> digital signature using E with some tweak (as a function of inputs) and of\n> some hash (as a function of inputs).\n>\n> As such, I will first note that the verification part of this algorithm's\n> execution is linear time and so there must be a way to do it in Zero\n> Knowledge. Specifically I believe this should be \"as simple as\" blinding\n> all state inputs with random tweaks and blinding signatures of these states\n> in the corresponding way (this may require that the signatures given by all\n> parties during updates actually be altered in some way to make this work).\n> Furthermore I think it should be possible (at least in theory it seems\n> plausible to me) that all inputs can be hidden/blinded/tweaked and the\n> Escrow performs some computations on these random looking inputs resulting\n> in either a FAIL, or in further random looking computation using E (likely\n> requiring some ZKP inputs proving that the calling party has followed some\n> set of rules) to generate a blinded signature which can then be unblinded\n> by the caller to receive a valid digital signature usable to enforce the\n> above proposal.\n>\n> Please note that I do not have these details worked out in any meaningful\n> way (and probably won't be able to do so, would love if someone more apt in\n> this area would give this some thought!), but also that while this vastly\n> improves the privacy and security of this scheme, it isn't strictly\n> speaking a necessary optimization if you are willing to place more trust\n> and be less private with Escrows.\n>\n> ### Fees\n>\n> I have given no thought to transaction fees in the above and I'm sure there\n> are a bunch of ways to do them wrong but I'm hoping that it is possible to\n> add anchor outputs or whatever other alterations need to occur to allow fee\n> considerations to work out.\n>\n> I hope people find this proposal interesting! In theory it could be\n> implemented on today's Bitcoin (though I will not have time to work on this\n> in the foreseeable future, but would be happy to help anyone who would want\n> to try to do this)!\n>\n> Best,\n> Nadav\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-09-03T06:48:40",
                "message_text_only": "Good morning Christian, Nadav, and all,\n\n\n>\n> Escrow collusion\n>\n> -----------------\n>\n> While not particularly familiar with SCU, I think the escrow might need\n> to be ultimately trusted, since giving it the ability to act as\n> co-signer in lieu of a subset of participants, or even sole signature\n> authority could lead to collusion between the escrow and the remainder\n> of the contract participants, but I'm happy to be corrected here.\n\nThis is correct.\n\nIt should be noted that Smart Contracts Unchained is simply the logical extension of the buyer-seller-escrow 2-of-3 setup.\nWhen locking up its funds, the buyer trusts that the escrow does not collude with the seller to steal the funds without sending product.\nAnd when sending its product, the seller trusts that the escrow does not collude with the buyer to clawback the funds without returning the product.\n\nAs such, even if the number of participants increases, trust that the escrow does not perform collusion with any of the participants, must still exist.\n\nThis can be mitigated by having the escrow be a k-of-n federation.\n\nIf you have `t` trusted escrow entities, you must ensure `n - k < t`.\nFor example, if you trust only 3 escrows, then you would accept a 5-of-7 setup where 3 of the escrows are among the trusted set, and you would ensure that at most 2 of them are not involved in the signing.\nBut you would not accept 4-of-7, as all three of your trusted escrows could potentially be removed from the signing federation.\n\n\n\n>\n> We had similar considerations while working on the original channel\n> factories paper, where we tried to come up with a scheme that'd allow a\n> subset of participants to split out an inactive participant in order to\n> recover from what would otherwise be a deadlock. We decided to drop that\n> possibility due to the complexity involved and the potential for serious\n> damage if participants collude.\n\nIndeed.\n\nI would like to point out, that channel factories, as they host channels, \"degrade gracefully\".\n\nIf you have an ABC channel factory, that hosts AB, BC, and AC channels, even if C is offline, the AB channel continues to work \"seamlessly\", without any care that C is offline.\n\nThus, I contend that channel factories hosting channels is sufficient, and there is no need for a \"split out\" function as described.\n\nSubsets *already work*, at reduced capability (in the above example, the BC and AC channels no longer work, because C is offline, but AB can continue to work perfectly fine), as long as you use channel factories (where the n >= 3 mechanism holds only channels, never direct HTLCs or HODLings) instead of CoinPools/multiparticipant channels.\n\n---\n\nGiven that most of the activity will be in \"standard\" 2-of-2 Poon-Dryja channels, and the factory is just a host for channels, you do not really need a fully-featured channel factory layer.\n\nFor example, it might be acceptable to use the Decker-Wattenhofer decrementing-`nSequence` mechanism for the channel factory layer.\nThis is trustless (no need for an Smart Contracts Unchained escrow federation or a Somsen Statechains blinded federation), at the cost of having a bad locktime-to-updates-limit tradeoff.\n\nThe above is acceptable since you can update the channels independently of the factory that hosts them (that is the entire point of channels, and why they take activity offchain, they can be updated without having to update whatever hosts them, whether a blockchain or another offchain mechanism)\n(Indeed, one can take the point-of-view that the blockchain \"goes offline\" for stretches of time of around 10 minutes (i.e., the inter-block time), during which no updates to the blockchain layer are possible, and if you want to keep operating while the blockchain \"goes offline\" (i.e. miners are still solving the next block) then you can use payment channels.)\n\nThe general use of updating the factory layer would be to rebalance the channels inside it.\nBut we already *can* rebalance today, without factories, and without any activity on the layer that hosts the channels, by self-paying.\n\nThus, having a limit on the number of updates on the factory layer may be an acceptable tradeoff, since you can always prioritize rebalancing at the channels layer (i.e. Lightning already currently works with just that), and only fall back to rebalancing at the factory layer if it would not be lucrative to do the rebalancing at the channels layer, and enough of the factory participants think it is a good idea to simultaneously rebalance on the factory layer at that point.\n\nI think channel factories (which **only** host channels, and never HTLCs or HODLings, so I think \"multiparticipant channels\" is either a misnomer, or the wrong thing entirely) have the major advantage of greatly reducing the onchain footprint, and simultaneously having a decent \"graceful degradation\" (i.e. the individual channels in it continue to operate even if one of the factory participants is offline).\n\n---\n\nIn any case, if you still want to continue to use Smart Contracts Unchained, I suggest merging the escrow functionality with watchtower functionality.\n\nThis does not improve security (escrows can still collude with other channel participants) but does improve privacy and increases your anonymity set when you are not colluding with your escrows.\n\nWith this, your setup to enter into a Smart Contracts Unchained contract would be:\n\n* Agree on the contract.\n* Create a funding transaction that pays to an n-of-n of the participants.\n* Create a contract transaction that pays to a k-of-n of the escrow federation, spending the above funding transaction output.\n  * This is signed with a sign-to-contract, where the `R` commits to a hash of the contract.\n* Broadcast and sign the funding transaction.\n* Send a `(halftxid, encrypted_blob)` pair to the escrow federation.\n  * The `halftxid` is half of the `txid` of the contract transaction.\n  * The `encrypted_blob`, when decrypted, shows that it is actually a Smart Contracts Unchained contract (and not a normal Lightning watchtower blob) and contains the contract and the decommitment in the sign-to-contract.\n\nWhen the contract transaction is confirmed onchain, the escrow federation performs the normal watchtower operation of taking the full txid of the encrypted blob, and if it decodes successfully, can now open the enrypted blob and read the contract.\nIt checks that the contract matches the signature on the contract transaction, then if that matches, enforces the contract.\n\n(It seems to me a good idea to make watchtowers general enough that they can support not just Lightning, but also CoinSwap and Smart Contracts Unchained, if only for the improved anonymity set.)\n\nI am almost certain that a Smart Contract Unchained Escrowed Decker-Russell-Osuntokun channel factory can merge the watchtower and escrow functionality as well, using the above basic sketch, with additional overlay network to allow for federated escrows.\nThe issue is really the increased complexity of the `(halftxid, encrypted_blob)` scheme with Decker-Russell-Osuntokun.\n\n(To my knowledge, Decker-Russell-Osuntokun only simplifies watchtowers if the watchtower knows the funding outpoint, which is information we should really prefer the watchtower to not know unless an attack occurs; with an unknown-funding-outpoint, `(halftxid, encrypted_blob)` scheme, Decker-Russell-Osuntokun is actually more complicated, since hiding the funding outpoint prevents having a simple key for the watchtower to replace.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2020-09-22T09:38:45",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> I am almost certain that a Smart Contract Unchained Escrowed\n> Decker-Russell-Osuntokun channel factory can merge the watchtower and\n> escrow functionality as well, using the above basic sketch, with\n> additional overlay network to allow for federated escrows.  The issue\n> is really the increased complexity of the `(halftxid, encrypted_blob)`\n> scheme with Decker-Russell-Osuntokun.\n>\n> (To my knowledge, Decker-Russell-Osuntokun only simplifies watchtowers\n> if the watchtower knows the funding outpoint, which is information we\n> should really prefer the watchtower to not know unless an attack\n> occurs; with an unknown-funding-outpoint, `(halftxid, encrypted_blob)`\n> scheme, Decker-Russell-Osuntokun is actually more complicated, since\n> hiding the funding outpoint prevents having a simple key for the\n> watchtower to replace.)\n\nJust a minor comment on this: for eltoo the watchtower does not need to\nknow the funding outpoint, instead any information that'd allow a\nwatchtower to collate (encrypted) updates would be sufficient for it to\nbe able to discard earlier ones. I'm thinking in particular about the\nsession-based collation that the lnd watchtower protocol uses can be one\nsuch collation key. Alternatively we can still use the Poon-Dryja style\nencryption with the trigger transaction hash (which admittedly isn't\nvery prominently described in the eltoo paper) as the encryption\nkey. That transaction being the first step towards closing a channel\nunilaterally forces any cheating party to reveal the decryption key for\nthe update txs that'll override its actions.\n\nFurthermore, while encrypting all the reactions with the same encryption\nkey may appear to leak information, it is only the update transaction\nthat is passed to the watchtower, not the actual state (direct outputs\nand HTLCs) which is attached to the settlement transaction, kept by the\nendpoint. So all the watchtower gets from decrypting all prior update\ntransactions is a set of semantically identical 1-input-1-output update\ntransactions from which it can at most learn how many updates were\nperformed. This last leak can also be addressed by simply randomizing\nthe increment step for state numbers and not passing every state update\nto the watchtower (since the watchtower will only ever need the last one\nwe can coalesce multiple updates and flush them to the watchtower after\nsome time).\n\nCheers,\nChristian\n\n\n[1]: https://github.com/lightningnetwork/lnd/blob/master/docs/watchtower.md"
            }
        ],
        "thread_summary": {
            "title": "Simulating Eltoo Factories using SCU Escrows (aka SCUE'd Eltoo)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Christian Decker"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 24682
        }
    },
    {
        "title": "[Lightning-dev] SIGHASH_SINGLE + update_fee Considered Harmful",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2020-09-10T16:27:37",
                "message_text_only": "Hi,\n\nIn this post, I would like to expose a potential vulnerability introduced\nby the recent anchor output spec update related to the new usage of\nSIGHASH_SINGLE for HTLC transactions. This new malleability combined with\nthe currently deployed mechanism of `update_fee` is likely harmful for\nfunds safety.\n\nThis has been previously shared with deployed implementations devs, as\nanchor channels are flagged as experimental it's better to discuss and\nsolve this publicly. That said, if you're currently running experimental\nanchor channels with non-trusted parties on mainnet, you might prefer to\nclose them.\n\n# SIGHASH_SINGLE and `update_fee` (skip it if you're familiar)\n\nFirst, let's get started by a quick reminder of the data set committed by\nsignature digest algorithm of Segwit transactions (BIP 143):\n* nVersion\n* hashPrevouts\n* hashSequence\n* outpoint\n* scriptCode of the input\n* value of the output spent by this input\n* nSequence of the input\n* hashOutputs\n* nLocktime\n* sighash type of the signature\n\nAnchor output switched the sighash type from SIGHASH_ALL to SIGHASH_SINGLE\n| SIGHASH_ANYONECANPAY for HTLC signatures sent to your counterparty. Thus\nit can spend non-cooperatively its HTLC outputs on its commitment\ntransactions. I.e when Alice broadcasts her commitment transaction, every\nBob's signatures on Alice's HTLC-Success/Timeout transactions are now\nflagging the new sighash type.\n\nThus `hashPrevouts`, `hashSequence` (ANYONECANPAY) and `hashOutputs`\n(SINGLE) aren't committed anymore. SINGLE only enforces commitment to the\noutput scriptpubkey/amount at the same index that\nthe spending input. Alice is free to attach additional inputs/outputs to\nher HTLC transaction. This change is aiming to let a single-party bump the\nfeerate of 2nd-stage HTLC transactions in case of mempool-congestion,\nwithout counterparty cooperation and thus make HTLC funds safer.\n\nThe attached outputs are _not_ encumbered by a revokeable redeemscript for\na potential punishment.\n\nThat said, anchor ouput spec didn't change disable the current fee\nmechanism already covering HTLC transactions. Pre/post-anchor channels are\nnegotiating a feerate through `update_fee` exchange, initiated by the\nchannel funder. This `update_fee` can be rejected by the receiver if it's\ndeemed unreasonable compared to your local fee estimator view, but as of\ntoday implementations are pretty liberal in their acceptance, admitting a\ndivergence from a scale of 1 to no-bound at all.\n\nThis negotiated feerate (`feerate_per_kw`) is used by channel participants\nto compute effective fees which have to be deduced either from the funder\nbalance output for commitment transactions or from HTLC output value for\nHTLC transactions.\n\n# The Vulnerability : a Penalty Escape Vector\n\nBy increasing the feerate thanks to `update_fee`, a malicious party can\ninflate fees committed on HTLC input/output pairs and redirect this\ninflated fee to a single-controlled output attached to these malleable\npairs. This won't be punishable by an honest party in case of revoked state\nbroadcast and thus enable to partially escape the penalty.\n\nAs an example, Alice and Bob have a 100_000 sats channel. `feerate_per_kw`\nis 10000 sats.\n\nAt state N, Alice balance is all on her side. She announces 10 outgoing\nHTLCs of value 7000 sats.\n\nAs Commitment tx weight with 10 outputs is 2844 (post-anchor), the absolute\nfee committed is 28440 sats.\n\nAs HTLC-timeout weight is 666 (post-anchor), the absolute fee committed is\nof 6660 sat, the HTLC tx output as counter-signed by Bob is of 340 sat.\nThis absolute fee aims to pay the miner fee in case Alice needs to timeout\nHTLC onchain.\n\nHer remaining balance is 1560 sat, above both dust_limit_satoshi and the\nchannel reserve as constrained by Bob (likely 1%).\n\nAlice waits for HTLCs to expire and advances state to N+1. Then she empties\nher balance minus reserve by sending a HTLC relayed by Bob either to a\ncolluding channel on the rest of network or back to an onchain address\nthanks to a swap service.\n\nAt state N+2, Alice finalizes HTLC-timeout of state N by capturing almost\nall of the absolute fee to a new P2WPKH output only controlled by her. She\nbroadcasts the revoked commitment tx N and burns 28440 sats in commitment\nfee.\n\nHer balance of 1560 sats is punished by Bob's justice transaction.\n\nAfter confirmation and thus maturing of the CSV of 1 on her HTLC output\nAlice broadcasts her 10 HTLC-timeout sending back to her 6660 sat - 660 to\npay a low-fee. Bob punishes the 10 HTLC-timeout outputs of 340 sats.\n\nAlice gain =  99_000 (swap spend) + 66_660 (HTLCs escape) - 1560\n(commitment balance punishment) - 28440 (commitment fee) - 660*10 (HTLCs\nfees) - 340*10 (HTLCs output) = 125600 sats.\n\nAlice's gain is superior at channel value as it has been partially\ndouble-spend by bypassing the revocation punishment.\n\n# Limitations of Attacker Success\n\nA first limitation of attack success which can be point of is the fact that\npost-anchor HTLC outputs are CSV'ed by 1, which means in theory a honest\nparty can punish this output before the malicious spend them with the\nrevoked HTLC txn. In practice a malicious party can attach a branch of\ndescendants to its anchor output and that way only allowing one more\nmempool victim's transaction on the revoked commitment. The victim must\nspend all outputs at once or otherwise they're going to obstrucate each\nother at mempool acceptance.\n\nSecondly, other limitations  are the per-implementation channel policy\n`max_accepted_htlcs`, `max_htlc_value_in_flight`, `channel_reserve` and\nacceptance bound of `update_fee`. A quick look at default policies, even if\nthey vary between deploy implementations, let it think there is room to\nescape a substantial part of channel value.\n\nLastly, after the revoked commitment transaction is confirmed, both\nattacker and victim are in a feerate race to confirm either a justice\ntransaction or a malicious HTLC-timeout. As fee estimator logic of the\nvictim's implementation is a public piece of knowledge, it shouldn't be\nhard for the attacker to know the range of the first fee bid and override\nit by a bit to confirm it before the victim RBF at next block. Currently,\nnot all implementations have RBF of justice transactions.\n\nAs of today, if anchor output is deployed and given how LN implementations\nare managing fees/rebroadcast of onchain transactions, the chance of attack\nsuccess sounds high in my opinion.\n\n# Countermeasures\n\nChannel policies could be tighter, like bounded further down\n`max_accepted_htlcs` or restraining acceptance of `update_fee`. For the\nlatter, it's pretty hard as a) fee estimators diverge on mempool views b)\nan attacker can craft escape HTLC-txn in a period of high-fee and patiently\nwaits a low-fee period to launch the exploitation.\n\nJustice transactions can adopt a scorched earth approach binding their\nfeerate to the max to increase odds of winning the feerate race and thus\ndeter attackers. But this sounds like introducing a griefing attack vector.\nYour counterparty can burn more of your lawful balance in fees than you'll\npunish its revoked balance.\n\nA workable option would be to patch current anchor spec to remove\n`feerate_per_kw` appliance on 2nd-stage transactions, maybe just committing\na minimal relay fee.\n\nThoughts of further countermeasures ?\n\nI think the vulnerability described is mostly right but please point any\nmissing details.\n\nCheers,\n\nAntoine\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200910/fdc30f95/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2020-09-10T18:13:03",
                "message_text_only": "Hi Antoine,\n\nGreat findings!\n\nI think an even simpler mitigation is just for the non-initiator to _reject_\nupdate_fee proposals that are \"unreasonable\". The non-initiator can run a\n\"fee leak calculation\" to compute the worst-case leakage of fees in the\nrevocation case. This can be done to day without any significant updates to\nimplementations, and some implementations may already be doing this.\n\nOne issue is that we don't have a way to do a \"soft reject\" of an update_fee\nas is. However, depending on the implementations, it may be possible to just\nreconnect and issue a co-op close if there're no HTLCs on the commitment\ntransaction.\n\nAs you mentioned by setting proper values for max allowed htlcs, max in\nflight, reserve, etc, nodes are able to quantify this fee leak risk ahead of\ntime, and set reasonable parameters based on their security model. One issue\nis that these values are set in stone rn when the channel is opened, but\nfuture iterations of dynamic commitments may allow us to update them on the\nfly.\n\nIn the mid-term, implementations can start to phase out usage of update_fee\nby setting a minimal commitment fee when the channel is first opened, then\nrelying on CPFP to bump up the commitment and any HTLCs if needed. This\ndiscovery might very well hasten the demise of update_fee in the protocol\nall together as well.  I don't think we need to depend entirely on a\ntheoretical package relay Bitcoin p2p upgrade assuming implementations are\nwilling to make an assumption that say 20 sat/byte or w/e has a good chance\nof widespread propagation into mempools.\n\n>From the perspective of channel safety, and variations of attacks like\n\"flood & loot\", imo it's absolutely critical that nodes are able to update\nthe fees on their second-level HTLC transactions. As this is where the real\ndanger lies: if nodes aren't able to get 2nd level HTLCs in the chain in\ntime, then the incoming HTLC expiry will expire, creating a race condition\nacross both commitments which can potentially cascade.\n\nIn lnd today, anchors is still behind a build flag, but we plan to enable\nit by default for our upcoming 0.12 release. The blockers on our end were to\nadd support for towers, and add basic deadline aware bumping, both of which\nare currently on track. We'll now also look into setting clamps on the\nreceiver end to just not accept unreasonable values for the fee rate of a\ncommitment, as this ends up eating into the true HTLC values for both sides.\n\n-- Laolu\n\n\nOn Thu, Sep 10, 2020 at 9:28 AM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi,\n>\n> In this post, I would like to expose a potential vulnerability introduced\n> by the recent anchor output spec update related to the new usage of\n> SIGHASH_SINGLE for HTLC transactions. This new malleability combined with\n> the currently deployed mechanism of `update_fee` is likely harmful for\n> funds safety.\n>\n> This has been previously shared with deployed implementations devs, as\n> anchor channels are flagged as experimental it's better to discuss and\n> solve this publicly. That said, if you're currently running experimental\n> anchor channels with non-trusted parties on mainnet, you might prefer to\n> close them.\n>\n> # SIGHASH_SINGLE and `update_fee` (skip it if you're familiar)\n>\n> First, let's get started by a quick reminder of the data set committed by\n> signature digest algorithm of Segwit transactions (BIP 143):\n> * nVersion\n> * hashPrevouts\n> * hashSequence\n> * outpoint\n> * scriptCode of the input\n> * value of the output spent by this input\n> * nSequence of the input\n> * hashOutputs\n> * nLocktime\n> * sighash type of the signature\n>\n> Anchor output switched the sighash type from SIGHASH_ALL to SIGHASH_SINGLE\n> | SIGHASH_ANYONECANPAY for HTLC signatures sent to your counterparty. Thus\n> it can spend non-cooperatively its HTLC outputs on its commitment\n> transactions. I.e when Alice broadcasts her commitment transaction, every\n> Bob's signatures on Alice's HTLC-Success/Timeout transactions are now\n> flagging the new sighash type.\n>\n> Thus `hashPrevouts`, `hashSequence` (ANYONECANPAY) and `hashOutputs`\n> (SINGLE) aren't committed anymore. SINGLE only enforces commitment to the\n> output scriptpubkey/amount at the same index that\n> the spending input. Alice is free to attach additional inputs/outputs to\n> her HTLC transaction. This change is aiming to let a single-party bump the\n> feerate of 2nd-stage HTLC transactions in case of mempool-congestion,\n> without counterparty cooperation and thus make HTLC funds safer.\n>\n> The attached outputs are _not_ encumbered by a revokeable redeemscript for\n> a potential punishment.\n>\n> That said, anchor ouput spec didn't change disable the current fee\n> mechanism already covering HTLC transactions. Pre/post-anchor channels are\n> negotiating a feerate through `update_fee` exchange, initiated by the\n> channel funder. This `update_fee` can be rejected by the receiver if it's\n> deemed unreasonable compared to your local fee estimator view, but as of\n> today implementations are pretty liberal in their acceptance, admitting a\n> divergence from a scale of 1 to no-bound at all.\n>\n> This negotiated feerate (`feerate_per_kw`) is used by channel participants\n> to compute effective fees which have to be deduced either from the funder\n> balance output for commitment transactions or from HTLC output value for\n> HTLC transactions.\n>\n> # The Vulnerability : a Penalty Escape Vector\n>\n> By increasing the feerate thanks to `update_fee`, a malicious party can\n> inflate fees committed on HTLC input/output pairs and redirect this\n> inflated fee to a single-controlled output attached to these malleable\n> pairs. This won't be punishable by an honest party in case of revoked state\n> broadcast and thus enable to partially escape the penalty.\n>\n> As an example, Alice and Bob have a 100_000 sats channel. `feerate_per_kw`\n> is 10000 sats.\n>\n> At state N, Alice balance is all on her side. She announces 10 outgoing\n> HTLCs of value 7000 sats.\n>\n> As Commitment tx weight with 10 outputs is 2844 (post-anchor), the\n> absolute fee committed is 28440 sats.\n>\n> As HTLC-timeout weight is 666 (post-anchor), the absolute fee committed is\n> of 6660 sat, the HTLC tx output as counter-signed by Bob is of 340 sat.\n> This absolute fee aims to pay the miner fee in case Alice needs to timeout\n> HTLC onchain.\n>\n> Her remaining balance is 1560 sat, above both dust_limit_satoshi and the\n> channel reserve as constrained by Bob (likely 1%).\n>\n> Alice waits for HTLCs to expire and advances state to N+1. Then she\n> empties her balance minus reserve by sending a HTLC relayed by Bob either\n> to a colluding channel on the rest of network or back to an onchain address\n> thanks to a swap service.\n>\n> At state N+2, Alice finalizes HTLC-timeout of state N by capturing almost\n> all of the absolute fee to a new P2WPKH output only controlled by her. She\n> broadcasts the revoked commitment tx N and burns 28440 sats in commitment\n> fee.\n>\n> Her balance of 1560 sats is punished by Bob's justice transaction.\n>\n> After confirmation and thus maturing of the CSV of 1 on her HTLC output\n> Alice broadcasts her 10 HTLC-timeout sending back to her 6660 sat - 660 to\n> pay a low-fee. Bob punishes the 10 HTLC-timeout outputs of 340 sats.\n>\n> Alice gain =  99_000 (swap spend) + 66_660 (HTLCs escape) - 1560\n> (commitment balance punishment) - 28440 (commitment fee) - 660*10 (HTLCs\n> fees) - 340*10 (HTLCs output) = 125600 sats.\n>\n> Alice's gain is superior at channel value as it has been partially\n> double-spend by bypassing the revocation punishment.\n>\n> # Limitations of Attacker Success\n>\n> A first limitation of attack success which can be point of is the fact\n> that post-anchor HTLC outputs are CSV'ed by 1, which means in theory a\n> honest party can punish this output before the malicious spend them with\n> the revoked HTLC txn. In practice a malicious party can attach a branch of\n> descendants to its anchor output and that way only allowing one more\n> mempool victim's transaction on the revoked commitment. The victim must\n> spend all outputs at once or otherwise they're going to obstrucate each\n> other at mempool acceptance.\n>\n> Secondly, other limitations  are the per-implementation channel policy\n> `max_accepted_htlcs`, `max_htlc_value_in_flight`, `channel_reserve` and\n> acceptance bound of `update_fee`. A quick look at default policies, even if\n> they vary between deploy implementations, let it think there is room to\n> escape a substantial part of channel value.\n>\n> Lastly, after the revoked commitment transaction is confirmed, both\n> attacker and victim are in a feerate race to confirm either a justice\n> transaction or a malicious HTLC-timeout. As fee estimator logic of the\n> victim's implementation is a public piece of knowledge, it shouldn't be\n> hard for the attacker to know the range of the first fee bid and override\n> it by a bit to confirm it before the victim RBF at next block. Currently,\n> not all implementations have RBF of justice transactions.\n>\n> As of today, if anchor output is deployed and given how LN implementations\n> are managing fees/rebroadcast of onchain transactions, the chance of attack\n> success sounds high in my opinion.\n>\n> # Countermeasures\n>\n> Channel policies could be tighter, like bounded further down\n> `max_accepted_htlcs` or restraining acceptance of `update_fee`. For the\n> latter, it's pretty hard as a) fee estimators diverge on mempool views b)\n> an attacker can craft escape HTLC-txn in a period of high-fee and patiently\n> waits a low-fee period to launch the exploitation.\n>\n> Justice transactions can adopt a scorched earth approach binding their\n> feerate to the max to increase odds of winning the feerate race and thus\n> deter attackers. But this sounds like introducing a griefing attack vector.\n> Your counterparty can burn more of your lawful balance in fees than you'll\n> punish its revoked balance.\n>\n> A workable option would be to patch current anchor spec to remove\n> `feerate_per_kw` appliance on 2nd-stage transactions, maybe just committing\n> a minimal relay fee.\n>\n> Thoughts of further countermeasures ?\n>\n> I think the vulnerability described is mostly right but please point any\n> missing details.\n>\n> Cheers,\n>\n> Antoine\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200910/24240038/attachment-0001.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2020-09-11T08:15:30",
                "message_text_only": "Hi,\n\nVery good observation, most definitely not a type of attack I forseen!\n\nLuckily, it was the plan to phase out update_fee all along, in favor\nof only accepting the minimum relay fee (zero fee if/when package\nrelay is a reality). If I understand the scenario correctly, that\nshould mitigate this attack completely, as the attacker cannot impact\nthe intended miner fees on the HTLCs, and could only siphon off the\nminimal miner fee if anything at all.\n\nI would be open to patching the spec to disallow update_fee for anchor\nchannels, but maybe we can just add a warning and discourage it.\n\nJohan\n\n\nOn Thu, Sep 10, 2020 at 8:13 PM Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>\n> Hi Antoine,\n>\n> Great findings!\n>\n> I think an even simpler mitigation is just for the non-initiator to _reject_\n> update_fee proposals that are \"unreasonable\". The non-initiator can run a\n> \"fee leak calculation\" to compute the worst-case leakage of fees in the\n> revocation case. This can be done to day without any significant updates to\n> implementations, and some implementations may already be doing this.\n>\n> One issue is that we don't have a way to do a \"soft reject\" of an update_fee\n> as is. However, depending on the implementations, it may be possible to just\n> reconnect and issue a co-op close if there're no HTLCs on the commitment\n> transaction.\n>\n> As you mentioned by setting proper values for max allowed htlcs, max in\n> flight, reserve, etc, nodes are able to quantify this fee leak risk ahead of\n> time, and set reasonable parameters based on their security model. One issue\n> is that these values are set in stone rn when the channel is opened, but\n> future iterations of dynamic commitments may allow us to update them on the\n> fly.\n>\n> In the mid-term, implementations can start to phase out usage of update_fee\n> by setting a minimal commitment fee when the channel is first opened, then\n> relying on CPFP to bump up the commitment and any HTLCs if needed. This\n> discovery might very well hasten the demise of update_fee in the protocol\n> all together as well.  I don't think we need to depend entirely on a\n> theoretical package relay Bitcoin p2p upgrade assuming implementations are\n> willing to make an assumption that say 20 sat/byte or w/e has a good chance\n> of widespread propagation into mempools.\n>\n> From the perspective of channel safety, and variations of attacks like\n> \"flood & loot\", imo it's absolutely critical that nodes are able to update\n> the fees on their second-level HTLC transactions. As this is where the real\n> danger lies: if nodes aren't able to get 2nd level HTLCs in the chain in\n> time, then the incoming HTLC expiry will expire, creating a race condition\n> across both commitments which can potentially cascade.\n>\n> In lnd today, anchors is still behind a build flag, but we plan to enable\n> it by default for our upcoming 0.12 release. The blockers on our end were to\n> add support for towers, and add basic deadline aware bumping, both of which\n> are currently on track. We'll now also look into setting clamps on the\n> receiver end to just not accept unreasonable values for the fee rate of a\n> commitment, as this ends up eating into the true HTLC values for both sides.\n>\n> -- Laolu\n>\n>\n> On Thu, Sep 10, 2020 at 9:28 AM Antoine Riard <antoine.riard at gmail.com> wrote:\n>>\n>> Hi,\n>>\n>> In this post, I would like to expose a potential vulnerability introduced by the recent anchor output spec update related to the new usage of SIGHASH_SINGLE for HTLC transactions. This new malleability combined with the currently deployed mechanism of `update_fee` is likely harmful for funds safety.\n>>\n>> This has been previously shared with deployed implementations devs, as anchor channels are flagged as experimental it's better to discuss and solve this publicly. That said, if you're currently running experimental anchor channels with non-trusted parties on mainnet, you might prefer to close them.\n>>\n>> # SIGHASH_SINGLE and `update_fee` (skip it if you're familiar)\n>>\n>> First, let's get started by a quick reminder of the data set committed by signature digest algorithm of Segwit transactions (BIP 143):\n>> * nVersion\n>> * hashPrevouts\n>> * hashSequence\n>> * outpoint\n>> * scriptCode of the input\n>> * value of the output spent by this input\n>> * nSequence of the input\n>> * hashOutputs\n>> * nLocktime\n>> * sighash type of the signature\n>>\n>> Anchor output switched the sighash type from SIGHASH_ALL to SIGHASH_SINGLE | SIGHASH_ANYONECANPAY for HTLC signatures sent to your counterparty. Thus it can spend non-cooperatively its HTLC outputs on its commitment transactions. I.e when Alice broadcasts her commitment transaction, every Bob's signatures on Alice's HTLC-Success/Timeout transactions are now flagging the new sighash type.\n>>\n>> Thus `hashPrevouts`, `hashSequence` (ANYONECANPAY) and `hashOutputs` (SINGLE) aren't committed anymore. SINGLE only enforces commitment to the output scriptpubkey/amount at the same index that\n>> the spending input. Alice is free to attach additional inputs/outputs to her HTLC transaction. This change is aiming to let a single-party bump the feerate of 2nd-stage HTLC transactions in case of mempool-congestion, without counterparty cooperation and thus make HTLC funds safer.\n>>\n>> The attached outputs are _not_ encumbered by a revokeable redeemscript for a potential punishment.\n>>\n>> That said, anchor ouput spec didn't change disable the current fee mechanism already covering HTLC transactions. Pre/post-anchor channels are negotiating a feerate through `update_fee` exchange, initiated by the channel funder. This `update_fee` can be rejected by the receiver if it's deemed unreasonable compared to your local fee estimator view, but as of today implementations are pretty liberal in their acceptance, admitting a divergence from a scale of 1 to no-bound at all.\n>>\n>> This negotiated feerate (`feerate_per_kw`) is used by channel participants to compute effective fees which have to be deduced either from the funder balance output for commitment transactions or from HTLC output value for HTLC transactions.\n>>\n>> # The Vulnerability : a Penalty Escape Vector\n>>\n>> By increasing the feerate thanks to `update_fee`, a malicious party can inflate fees committed on HTLC input/output pairs and redirect this inflated fee to a single-controlled output attached to these malleable pairs. This won't be punishable by an honest party in case of revoked state broadcast and thus enable to partially escape the penalty.\n>>\n>> As an example, Alice and Bob have a 100_000 sats channel. `feerate_per_kw` is 10000 sats.\n>>\n>> At state N, Alice balance is all on her side. She announces 10 outgoing HTLCs of value 7000 sats.\n>>\n>> As Commitment tx weight with 10 outputs is 2844 (post-anchor), the absolute fee committed is 28440 sats.\n>>\n>> As HTLC-timeout weight is 666 (post-anchor), the absolute fee committed is of 6660 sat, the HTLC tx output as counter-signed by Bob is of 340 sat. This absolute fee aims to pay the miner fee in case Alice needs to timeout HTLC onchain.\n>>\n>> Her remaining balance is 1560 sat, above both dust_limit_satoshi and the channel reserve as constrained by Bob (likely 1%).\n>>\n>> Alice waits for HTLCs to expire and advances state to N+1. Then she empties her balance minus reserve by sending a HTLC relayed by Bob either to a colluding channel on the rest of network or back to an onchain address thanks to a swap service.\n>>\n>> At state N+2, Alice finalizes HTLC-timeout of state N by capturing almost all of the absolute fee to a new P2WPKH output only controlled by her. She broadcasts the revoked commitment tx N and burns 28440 sats in commitment fee.\n>>\n>> Her balance of 1560 sats is punished by Bob's justice transaction.\n>>\n>> After confirmation and thus maturing of the CSV of 1 on her HTLC output Alice broadcasts her 10 HTLC-timeout sending back to her 6660 sat - 660 to pay a low-fee. Bob punishes the 10 HTLC-timeout outputs of 340 sats.\n>>\n>> Alice gain =  99_000 (swap spend) + 66_660 (HTLCs escape) - 1560 (commitment balance punishment) - 28440 (commitment fee) - 660*10 (HTLCs fees) - 340*10 (HTLCs output) = 125600 sats.\n>>\n>> Alice's gain is superior at channel value as it has been partially double-spend by bypassing the revocation punishment.\n>>\n>> # Limitations of Attacker Success\n>>\n>> A first limitation of attack success which can be point of is the fact that post-anchor HTLC outputs are CSV'ed by 1, which means in theory a honest party can punish this output before the malicious spend them with the revoked HTLC txn. In practice a malicious party can attach a branch of descendants to its anchor output and that way only allowing one more mempool victim's transaction on the revoked commitment. The victim must spend all outputs at once or otherwise they're going to obstrucate each other at mempool acceptance.\n>>\n>> Secondly, other limitations  are the per-implementation channel policy `max_accepted_htlcs`, `max_htlc_value_in_flight`, `channel_reserve` and acceptance bound of `update_fee`. A quick look at default policies, even if they vary between deploy implementations, let it think there is room to escape a substantial part of channel value.\n>>\n>> Lastly, after the revoked commitment transaction is confirmed, both attacker and victim are in a feerate race to confirm either a justice transaction or a malicious HTLC-timeout. As fee estimator logic of the victim's implementation is a public piece of knowledge, it shouldn't be hard for the attacker to know the range of the first fee bid and override it by a bit to confirm it before the victim RBF at next block. Currently, not all implementations have RBF of justice transactions.\n>>\n>> As of today, if anchor output is deployed and given how LN implementations are managing fees/rebroadcast of onchain transactions, the chance of attack success sounds high in my opinion.\n>>\n>> # Countermeasures\n>>\n>> Channel policies could be tighter, like bounded further down `max_accepted_htlcs` or restraining acceptance of `update_fee`. For the latter, it's pretty hard as a) fee estimators diverge on mempool views b) an attacker can craft escape HTLC-txn in a period of high-fee and patiently waits a low-fee period to launch the exploitation.\n>>\n>> Justice transactions can adopt a scorched earth approach binding their feerate to the max to increase odds of winning the feerate race and thus deter attackers. But this sounds like introducing a griefing attack vector. Your counterparty can burn more of your lawful balance in fees than you'll punish its revoked balance.\n>>\n>> A workable option would be to patch current anchor spec to remove `feerate_per_kw` appliance on 2nd-stage transactions, maybe just committing a minimal relay fee.\n>>\n>> Thoughts of further countermeasures ?\n>>\n>> I think the vulnerability described is mostly right but please point any missing details.\n>>\n>> Cheers,\n>>\n>> Antoine\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-09-13T23:29:59",
                "message_text_only": "Hi Johan,\n\n> I would be open to patching the spec to disallow update_fee for anchor\n> channels, but maybe we can just add a warning and discourage it.\n\nMy initial thinking was just to restrain it for the commitment-level only.\n\nCompletely adhering to the bring-your-own-fee model for HTLC-txn sounds\nbetter as it splits more fairly fees burden between channel participants.\nThe initiator won't have to pay for the remote's HTLC-txn, especially in\nperiods of high-congestion. A participant shouldn't have to bear the cost\nof the counterparty choosing to go onchain, as it's mostly a client\nsecurity parameter (\"how many blocks it will take me to confirm ?\")  or an\neconomic decision (\"is this HTLC worthy to claim/expire ?\").\n\nOne could argue it's increasing the blockspace footprint as you will use\none more pair of input-output but if you're paying the feerate that's\nlawful usage.\n\nAntoine\n\nLe ven. 11 sept. 2020 \u00e0 04:15, Johan Tor\u00e5s Halseth <johanth at gmail.com> a\n\u00e9crit :\n\n> Hi,\n>\n> Very good observation, most definitely not a type of attack I forseen!\n>\n> Luckily, it was the plan to phase out update_fee all along, in favor\n> of only accepting the minimum relay fee (zero fee if/when package\n> relay is a reality). If I understand the scenario correctly, that\n> should mitigate this attack completely, as the attacker cannot impact\n> the intended miner fees on the HTLCs, and could only siphon off the\n> minimal miner fee if anything at all.\n>\n> I would be open to patching the spec to disallow update_fee for anchor\n> channels, but maybe we can just add a warning and discourage it.\n>\n> Johan\n>\n>\n> On Thu, Sep 10, 2020 at 8:13 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n> wrote:\n> >\n> > Hi Antoine,\n> >\n> > Great findings!\n> >\n> > I think an even simpler mitigation is just for the non-initiator to\n> _reject_\n> > update_fee proposals that are \"unreasonable\". The non-initiator can run a\n> > \"fee leak calculation\" to compute the worst-case leakage of fees in the\n> > revocation case. This can be done to day without any significant updates\n> to\n> > implementations, and some implementations may already be doing this.\n> >\n> > One issue is that we don't have a way to do a \"soft reject\" of an\n> update_fee\n> > as is. However, depending on the implementations, it may be possible to\n> just\n> > reconnect and issue a co-op close if there're no HTLCs on the commitment\n> > transaction.\n> >\n> > As you mentioned by setting proper values for max allowed htlcs, max in\n> > flight, reserve, etc, nodes are able to quantify this fee leak risk\n> ahead of\n> > time, and set reasonable parameters based on their security model. One\n> issue\n> > is that these values are set in stone rn when the channel is opened, but\n> > future iterations of dynamic commitments may allow us to update them on\n> the\n> > fly.\n> >\n> > In the mid-term, implementations can start to phase out usage of\n> update_fee\n> > by setting a minimal commitment fee when the channel is first opened,\n> then\n> > relying on CPFP to bump up the commitment and any HTLCs if needed. This\n> > discovery might very well hasten the demise of update_fee in the protocol\n> > all together as well.  I don't think we need to depend entirely on a\n> > theoretical package relay Bitcoin p2p upgrade assuming implementations\n> are\n> > willing to make an assumption that say 20 sat/byte or w/e has a good\n> chance\n> > of widespread propagation into mempools.\n> >\n> > From the perspective of channel safety, and variations of attacks like\n> > \"flood & loot\", imo it's absolutely critical that nodes are able to\n> update\n> > the fees on their second-level HTLC transactions. As this is where the\n> real\n> > danger lies: if nodes aren't able to get 2nd level HTLCs in the chain in\n> > time, then the incoming HTLC expiry will expire, creating a race\n> condition\n> > across both commitments which can potentially cascade.\n> >\n> > In lnd today, anchors is still behind a build flag, but we plan to enable\n> > it by default for our upcoming 0.12 release. The blockers on our end\n> were to\n> > add support for towers, and add basic deadline aware bumping, both of\n> which\n> > are currently on track. We'll now also look into setting clamps on the\n> > receiver end to just not accept unreasonable values for the fee rate of a\n> > commitment, as this ends up eating into the true HTLC values for both\n> sides.\n> >\n> > -- Laolu\n> >\n> >\n> > On Thu, Sep 10, 2020 at 9:28 AM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n> >>\n> >> Hi,\n> >>\n> >> In this post, I would like to expose a potential vulnerability\n> introduced by the recent anchor output spec update related to the new usage\n> of SIGHASH_SINGLE for HTLC transactions. This new malleability combined\n> with the currently deployed mechanism of `update_fee` is likely harmful for\n> funds safety.\n> >>\n> >> This has been previously shared with deployed implementations devs, as\n> anchor channels are flagged as experimental it's better to discuss and\n> solve this publicly. That said, if you're currently running experimental\n> anchor channels with non-trusted parties on mainnet, you might prefer to\n> close them.\n> >>\n> >> # SIGHASH_SINGLE and `update_fee` (skip it if you're familiar)\n> >>\n> >> First, let's get started by a quick reminder of the data set committed\n> by signature digest algorithm of Segwit transactions (BIP 143):\n> >> * nVersion\n> >> * hashPrevouts\n> >> * hashSequence\n> >> * outpoint\n> >> * scriptCode of the input\n> >> * value of the output spent by this input\n> >> * nSequence of the input\n> >> * hashOutputs\n> >> * nLocktime\n> >> * sighash type of the signature\n> >>\n> >> Anchor output switched the sighash type from SIGHASH_ALL to\n> SIGHASH_SINGLE | SIGHASH_ANYONECANPAY for HTLC signatures sent to your\n> counterparty. Thus it can spend non-cooperatively its HTLC outputs on its\n> commitment transactions. I.e when Alice broadcasts her commitment\n> transaction, every Bob's signatures on Alice's HTLC-Success/Timeout\n> transactions are now flagging the new sighash type.\n> >>\n> >> Thus `hashPrevouts`, `hashSequence` (ANYONECANPAY) and `hashOutputs`\n> (SINGLE) aren't committed anymore. SINGLE only enforces commitment to the\n> output scriptpubkey/amount at the same index that\n> >> the spending input. Alice is free to attach additional inputs/outputs\n> to her HTLC transaction. This change is aiming to let a single-party bump\n> the feerate of 2nd-stage HTLC transactions in case of mempool-congestion,\n> without counterparty cooperation and thus make HTLC funds safer.\n> >>\n> >> The attached outputs are _not_ encumbered by a revokeable redeemscript\n> for a potential punishment.\n> >>\n> >> That said, anchor ouput spec didn't change disable the current fee\n> mechanism already covering HTLC transactions. Pre/post-anchor channels are\n> negotiating a feerate through `update_fee` exchange, initiated by the\n> channel funder. This `update_fee` can be rejected by the receiver if it's\n> deemed unreasonable compared to your local fee estimator view, but as of\n> today implementations are pretty liberal in their acceptance, admitting a\n> divergence from a scale of 1 to no-bound at all.\n> >>\n> >> This negotiated feerate (`feerate_per_kw`) is used by channel\n> participants to compute effective fees which have to be deduced either from\n> the funder balance output for commitment transactions or from HTLC output\n> value for HTLC transactions.\n> >>\n> >> # The Vulnerability : a Penalty Escape Vector\n> >>\n> >> By increasing the feerate thanks to `update_fee`, a malicious party can\n> inflate fees committed on HTLC input/output pairs and redirect this\n> inflated fee to a single-controlled output attached to these malleable\n> pairs. This won't be punishable by an honest party in case of revoked state\n> broadcast and thus enable to partially escape the penalty.\n> >>\n> >> As an example, Alice and Bob have a 100_000 sats channel.\n> `feerate_per_kw` is 10000 sats.\n> >>\n> >> At state N, Alice balance is all on her side. She announces 10 outgoing\n> HTLCs of value 7000 sats.\n> >>\n> >> As Commitment tx weight with 10 outputs is 2844 (post-anchor), the\n> absolute fee committed is 28440 sats.\n> >>\n> >> As HTLC-timeout weight is 666 (post-anchor), the absolute fee committed\n> is of 6660 sat, the HTLC tx output as counter-signed by Bob is of 340 sat.\n> This absolute fee aims to pay the miner fee in case Alice needs to timeout\n> HTLC onchain.\n> >>\n> >> Her remaining balance is 1560 sat, above both dust_limit_satoshi and\n> the channel reserve as constrained by Bob (likely 1%).\n> >>\n> >> Alice waits for HTLCs to expire and advances state to N+1. Then she\n> empties her balance minus reserve by sending a HTLC relayed by Bob either\n> to a colluding channel on the rest of network or back to an onchain address\n> thanks to a swap service.\n> >>\n> >> At state N+2, Alice finalizes HTLC-timeout of state N by capturing\n> almost all of the absolute fee to a new P2WPKH output only controlled by\n> her. She broadcasts the revoked commitment tx N and burns 28440 sats in\n> commitment fee.\n> >>\n> >> Her balance of 1560 sats is punished by Bob's justice transaction.\n> >>\n> >> After confirmation and thus maturing of the CSV of 1 on her HTLC output\n> Alice broadcasts her 10 HTLC-timeout sending back to her 6660 sat - 660 to\n> pay a low-fee. Bob punishes the 10 HTLC-timeout outputs of 340 sats.\n> >>\n> >> Alice gain =  99_000 (swap spend) + 66_660 (HTLCs escape) - 1560\n> (commitment balance punishment) - 28440 (commitment fee) - 660*10 (HTLCs\n> fees) - 340*10 (HTLCs output) = 125600 sats.\n> >>\n> >> Alice's gain is superior at channel value as it has been partially\n> double-spend by bypassing the revocation punishment.\n> >>\n> >> # Limitations of Attacker Success\n> >>\n> >> A first limitation of attack success which can be point of is the fact\n> that post-anchor HTLC outputs are CSV'ed by 1, which means in theory a\n> honest party can punish this output before the malicious spend them with\n> the revoked HTLC txn. In practice a malicious party can attach a branch of\n> descendants to its anchor output and that way only allowing one more\n> mempool victim's transaction on the revoked commitment. The victim must\n> spend all outputs at once or otherwise they're going to obstrucate each\n> other at mempool acceptance.\n> >>\n> >> Secondly, other limitations  are the per-implementation channel policy\n> `max_accepted_htlcs`, `max_htlc_value_in_flight`, `channel_reserve` and\n> acceptance bound of `update_fee`. A quick look at default policies, even if\n> they vary between deploy implementations, let it think there is room to\n> escape a substantial part of channel value.\n> >>\n> >> Lastly, after the revoked commitment transaction is confirmed, both\n> attacker and victim are in a feerate race to confirm either a justice\n> transaction or a malicious HTLC-timeout. As fee estimator logic of the\n> victim's implementation is a public piece of knowledge, it shouldn't be\n> hard for the attacker to know the range of the first fee bid and override\n> it by a bit to confirm it before the victim RBF at next block. Currently,\n> not all implementations have RBF of justice transactions.\n> >>\n> >> As of today, if anchor output is deployed and given how LN\n> implementations are managing fees/rebroadcast of onchain transactions, the\n> chance of attack success sounds high in my opinion.\n> >>\n> >> # Countermeasures\n> >>\n> >> Channel policies could be tighter, like bounded further down\n> `max_accepted_htlcs` or restraining acceptance of `update_fee`. For the\n> latter, it's pretty hard as a) fee estimators diverge on mempool views b)\n> an attacker can craft escape HTLC-txn in a period of high-fee and patiently\n> waits a low-fee period to launch the exploitation.\n> >>\n> >> Justice transactions can adopt a scorched earth approach binding their\n> feerate to the max to increase odds of winning the feerate race and thus\n> deter attackers. But this sounds like introducing a griefing attack vector.\n> Your counterparty can burn more of your lawful balance in fees than you'll\n> punish its revoked balance.\n> >>\n> >> A workable option would be to patch current anchor spec to remove\n> `feerate_per_kw` appliance on 2nd-stage transactions, maybe just committing\n> a minimal relay fee.\n> >>\n> >> Thoughts of further countermeasures ?\n> >>\n> >> I think the vulnerability described is mostly right but please point\n> any missing details.\n> >>\n> >> Cheers,\n> >>\n> >> Antoine\n> >> _______________________________________________\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200913/2e345e9e/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-09-13T23:28:51",
                "message_text_only": "Hi Laolu,\n\n> I think an even simpler mitigation is just for the non-initiator to\n_reject_\n> update_fee proposals that are \"unreasonable\". The non-initiator can run a\n> \"fee leak calculation\" to compute the worst-case leakage of fees in the\n> revocation case. This can be done to day without any significant updates\nto\n> implementations, and some implementations may already be doing this.\n\nYes that is what I meant by acceptance bounds of `update_fee`. I think such\nan algorithm is likely a good short-term measure. But such `worst-case\nleakage` will function first of your other policy parameters\n(`max_accepted_htlcs`, `max_htlc_value_in_flight`) and secondly of mempool\nfluctuations.\n\nBeing constrained by the mempool isn't great as you might have to\neffectively accept a high-feerate `update_fee` which can be exploited\nagainst you in a low-congestion period.\n\n> One issue\n> is that these values are set in stone rn when the channel is opened, but\n> future iterations of dynamic commitments may allow us to update them on\nthe\n> fly.\n\nYep we should remember to layer dynamic commitments, you should be able to\nupgrade as much the channel type then refresh your channel policy,\nparameters being function of type. That way node operators will be able to\nloose them as the peer has proven being reliable and honest, e.g providing\na minimal amount of routing fees or fair uptimes.\n\n> I don't think we need to depend entirely on a\n> theoretical package relay Bitcoin p2p upgrade assuming implementations are\n> willing to make an assumption that say 20 sat/byte or w/e has a good\nchance\n> of widespread propagation into mempools.\n\nLet's not make any assumptions on near-package relay support ;)\n\nWe can get rid of `update_fee` for HTLC-txn only. And keep it for the\ncommitment transaction for now, as the vulnerability is more a limited\ngriefing concern. As I guess we're all implementing CPFP (mainly keeping\nfresh bump utxos), we can reuse this piece of logic to alternatively attach\nthem to HTLC-txn. We keep the malleability that lets you unilaterally react\nto congestion/flood & loot and remove the inflation vector.\n\nAntoine\n\nLe jeu. 10 sept. 2020 \u00e0 14:13, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n\u00e9crit :\n\n> Hi Antoine,\n>\n> Great findings!\n>\n> I think an even simpler mitigation is just for the non-initiator to\n> _reject_\n> update_fee proposals that are \"unreasonable\". The non-initiator can run a\n> \"fee leak calculation\" to compute the worst-case leakage of fees in the\n> revocation case. This can be done to day without any significant updates to\n> implementations, and some implementations may already be doing this.\n>\n> One issue is that we don't have a way to do a \"soft reject\" of an\n> update_fee\n> as is. However, depending on the implementations, it may be possible to\n> just\n> reconnect and issue a co-op close if there're no HTLCs on the commitment\n> transaction.\n>\n> As you mentioned by setting proper values for max allowed htlcs, max in\n> flight, reserve, etc, nodes are able to quantify this fee leak risk ahead\n> of\n> time, and set reasonable parameters based on their security model. One\n> issue\n> is that these values are set in stone rn when the channel is opened, but\n> future iterations of dynamic commitments may allow us to update them on the\n> fly.\n>\n> In the mid-term, implementations can start to phase out usage of update_fee\n> by setting a minimal commitment fee when the channel is first opened, then\n> relying on CPFP to bump up the commitment and any HTLCs if needed. This\n> discovery might very well hasten the demise of update_fee in the protocol\n> all together as well.  I don't think we need to depend entirely on a\n> theoretical package relay Bitcoin p2p upgrade assuming implementations are\n> willing to make an assumption that say 20 sat/byte or w/e has a good chance\n> of widespread propagation into mempools.\n>\n> From the perspective of channel safety, and variations of attacks like\n> \"flood & loot\", imo it's absolutely critical that nodes are able to update\n> the fees on their second-level HTLC transactions. As this is where the real\n> danger lies: if nodes aren't able to get 2nd level HTLCs in the chain in\n> time, then the incoming HTLC expiry will expire, creating a race condition\n> across both commitments which can potentially cascade.\n>\n> In lnd today, anchors is still behind a build flag, but we plan to enable\n> it by default for our upcoming 0.12 release. The blockers on our end were\n> to\n> add support for towers, and add basic deadline aware bumping, both of which\n> are currently on track. We'll now also look into setting clamps on the\n> receiver end to just not accept unreasonable values for the fee rate of a\n> commitment, as this ends up eating into the true HTLC values for both\n> sides.\n>\n> -- Laolu\n>\n>\n> On Thu, Sep 10, 2020 at 9:28 AM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi,\n>>\n>> In this post, I would like to expose a potential vulnerability introduced\n>> by the recent anchor output spec update related to the new usage of\n>> SIGHASH_SINGLE for HTLC transactions. This new malleability combined with\n>> the currently deployed mechanism of `update_fee` is likely harmful for\n>> funds safety.\n>>\n>> This has been previously shared with deployed implementations devs, as\n>> anchor channels are flagged as experimental it's better to discuss and\n>> solve this publicly. That said, if you're currently running experimental\n>> anchor channels with non-trusted parties on mainnet, you might prefer to\n>> close them.\n>>\n>> # SIGHASH_SINGLE and `update_fee` (skip it if you're familiar)\n>>\n>> First, let's get started by a quick reminder of the data set committed by\n>> signature digest algorithm of Segwit transactions (BIP 143):\n>> * nVersion\n>> * hashPrevouts\n>> * hashSequence\n>> * outpoint\n>> * scriptCode of the input\n>> * value of the output spent by this input\n>> * nSequence of the input\n>> * hashOutputs\n>> * nLocktime\n>> * sighash type of the signature\n>>\n>> Anchor output switched the sighash type from SIGHASH_ALL to\n>> SIGHASH_SINGLE | SIGHASH_ANYONECANPAY for HTLC signatures sent to your\n>> counterparty. Thus it can spend non-cooperatively its HTLC outputs on its\n>> commitment transactions. I.e when Alice broadcasts her commitment\n>> transaction, every Bob's signatures on Alice's HTLC-Success/Timeout\n>> transactions are now flagging the new sighash type.\n>>\n>> Thus `hashPrevouts`, `hashSequence` (ANYONECANPAY) and `hashOutputs`\n>> (SINGLE) aren't committed anymore. SINGLE only enforces commitment to the\n>> output scriptpubkey/amount at the same index that\n>> the spending input. Alice is free to attach additional inputs/outputs to\n>> her HTLC transaction. This change is aiming to let a single-party bump the\n>> feerate of 2nd-stage HTLC transactions in case of mempool-congestion,\n>> without counterparty cooperation and thus make HTLC funds safer.\n>>\n>> The attached outputs are _not_ encumbered by a revokeable redeemscript\n>> for a potential punishment.\n>>\n>> That said, anchor ouput spec didn't change disable the current fee\n>> mechanism already covering HTLC transactions. Pre/post-anchor channels are\n>> negotiating a feerate through `update_fee` exchange, initiated by the\n>> channel funder. This `update_fee` can be rejected by the receiver if it's\n>> deemed unreasonable compared to your local fee estimator view, but as of\n>> today implementations are pretty liberal in their acceptance, admitting a\n>> divergence from a scale of 1 to no-bound at all.\n>>\n>> This negotiated feerate (`feerate_per_kw`) is used by channel\n>> participants to compute effective fees which have to be deduced either from\n>> the funder balance output for commitment transactions or from HTLC output\n>> value for HTLC transactions.\n>>\n>> # The Vulnerability : a Penalty Escape Vector\n>>\n>> By increasing the feerate thanks to `update_fee`, a malicious party can\n>> inflate fees committed on HTLC input/output pairs and redirect this\n>> inflated fee to a single-controlled output attached to these malleable\n>> pairs. This won't be punishable by an honest party in case of revoked state\n>> broadcast and thus enable to partially escape the penalty.\n>>\n>> As an example, Alice and Bob have a 100_000 sats channel.\n>> `feerate_per_kw` is 10000 sats.\n>>\n>> At state N, Alice balance is all on her side. She announces 10 outgoing\n>> HTLCs of value 7000 sats.\n>>\n>> As Commitment tx weight with 10 outputs is 2844 (post-anchor), the\n>> absolute fee committed is 28440 sats.\n>>\n>> As HTLC-timeout weight is 666 (post-anchor), the absolute fee committed\n>> is of 6660 sat, the HTLC tx output as counter-signed by Bob is of 340 sat.\n>> This absolute fee aims to pay the miner fee in case Alice needs to timeout\n>> HTLC onchain.\n>>\n>> Her remaining balance is 1560 sat, above both dust_limit_satoshi and the\n>> channel reserve as constrained by Bob (likely 1%).\n>>\n>> Alice waits for HTLCs to expire and advances state to N+1. Then she\n>> empties her balance minus reserve by sending a HTLC relayed by Bob either\n>> to a colluding channel on the rest of network or back to an onchain address\n>> thanks to a swap service.\n>>\n>> At state N+2, Alice finalizes HTLC-timeout of state N by capturing almost\n>> all of the absolute fee to a new P2WPKH output only controlled by her. She\n>> broadcasts the revoked commitment tx N and burns 28440 sats in commitment\n>> fee.\n>>\n>> Her balance of 1560 sats is punished by Bob's justice transaction.\n>>\n>> After confirmation and thus maturing of the CSV of 1 on her HTLC output\n>> Alice broadcasts her 10 HTLC-timeout sending back to her 6660 sat - 660 to\n>> pay a low-fee. Bob punishes the 10 HTLC-timeout outputs of 340 sats.\n>>\n>> Alice gain =  99_000 (swap spend) + 66_660 (HTLCs escape) - 1560\n>> (commitment balance punishment) - 28440 (commitment fee) - 660*10 (HTLCs\n>> fees) - 340*10 (HTLCs output) = 125600 sats.\n>>\n>> Alice's gain is superior at channel value as it has been partially\n>> double-spend by bypassing the revocation punishment.\n>>\n>> # Limitations of Attacker Success\n>>\n>> A first limitation of attack success which can be point of is the fact\n>> that post-anchor HTLC outputs are CSV'ed by 1, which means in theory a\n>> honest party can punish this output before the malicious spend them with\n>> the revoked HTLC txn. In practice a malicious party can attach a branch of\n>> descendants to its anchor output and that way only allowing one more\n>> mempool victim's transaction on the revoked commitment. The victim must\n>> spend all outputs at once or otherwise they're going to obstrucate each\n>> other at mempool acceptance.\n>>\n>> Secondly, other limitations  are the per-implementation channel policy\n>> `max_accepted_htlcs`, `max_htlc_value_in_flight`, `channel_reserve` and\n>> acceptance bound of `update_fee`. A quick look at default policies, even if\n>> they vary between deploy implementations, let it think there is room to\n>> escape a substantial part of channel value.\n>>\n>> Lastly, after the revoked commitment transaction is confirmed, both\n>> attacker and victim are in a feerate race to confirm either a justice\n>> transaction or a malicious HTLC-timeout. As fee estimator logic of the\n>> victim's implementation is a public piece of knowledge, it shouldn't be\n>> hard for the attacker to know the range of the first fee bid and override\n>> it by a bit to confirm it before the victim RBF at next block. Currently,\n>> not all implementations have RBF of justice transactions.\n>>\n>> As of today, if anchor output is deployed and given how LN\n>> implementations are managing fees/rebroadcast of onchain transactions, the\n>> chance of attack success sounds high in my opinion.\n>>\n>> # Countermeasures\n>>\n>> Channel policies could be tighter, like bounded further down\n>> `max_accepted_htlcs` or restraining acceptance of `update_fee`. For the\n>> latter, it's pretty hard as a) fee estimators diverge on mempool views b)\n>> an attacker can craft escape HTLC-txn in a period of high-fee and patiently\n>> waits a low-fee period to launch the exploitation.\n>>\n>> Justice transactions can adopt a scorched earth approach binding their\n>> feerate to the max to increase odds of winning the feerate race and thus\n>> deter attackers. But this sounds like introducing a griefing attack vector.\n>> Your counterparty can burn more of your lawful balance in fees than you'll\n>> punish its revoked balance.\n>>\n>> A workable option would be to patch current anchor spec to remove\n>> `feerate_per_kw` appliance on 2nd-stage transactions, maybe just committing\n>> a minimal relay fee.\n>>\n>> Thoughts of further countermeasures ?\n>>\n>> I think the vulnerability described is mostly right but please point any\n>> missing details.\n>>\n>> Cheers,\n>>\n>> Antoine\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20200913/a391e6c2/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "SIGHASH_SINGLE + update_fee Considered Harmful",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun",
                "Antoine Riard",
                "Johan Tor\u00e5s Halseth"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 55590
        }
    },
    {
        "title": "[Lightning-dev] c-lightning release v0.9.1: The Antiguan BTC Maximalist Society",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2020-09-15T20:37:11",
                "message_text_only": "We're pleased to announce the 0.9.1 release of c-lightning, named by Jon\nGriffiths.\n\n\thttps://github.com/ElementsProject/lightning/releases/tag/v0.9.1\n\nThis is a significant release with major bugfixes to multi-part payments\nand various notable speedups and improvements across the board.\n\n*Did you know*: c-lightning deprecates features with 6 months warning, and\nyou can set allow-deprecated-apis=false to test?\n\nHighlights for Users\n\n* The sending of multi-part payments has seen a lot of work, covering\n  more corner cases and generally becoming much more robust.\n\n* New official plugins create commands multiwithdraw and\n  multifundchannel to easily produce a single transaction which does\n  more than one thing; these use the PSBT plumbing created for v0.9.0.\n  \n* We produce far less log spam when log-level is set to debug, so if\n  you've avoided setting that before, I recommend trying now.\n   \n* Startup checks that bitcoind is the correct version, and relays\n  transactions\n\n* Builtin plugins are now nominated as important, and you can nominate\n  others as important too. The daemon will stop if these fail.\n\n* You can now build a postgres-only installation, without sqlite3.\n\nHighlights for the Network\n\n* Our invoices now supply more than one routehint if we think you'll\n  need to use multi-part-payments.\n\n* We prune channels which are not updated in both directions every 2\n  weeks.\n\n* Our default CTLV expiry has increased to 34 blocks, or 18 if we're the\n  final node, as per updated specification recommendations\n  (https://github.com/lightningnetwork/lightning-rfc/pull/785)\n\nHighlights for Developers\n\n* PSBT APIs fleshed out with utxopsbt and locktime arguments.\n\n* Plugins can easily mark commands and options deprecated.\n\n* The new channel_state_changed notification lets plugins easily track\n  channel behavior.\n\nMore details can be found at\n\n        https://github.com/ElementsProject/lightning/blob/v0.9.1/CHANGELOG.md\n\nThanks to everyone for their contributions and bug reports; please keep\nthem coming.\n\nSince 0.9.0, we've had 391 commits commits from 15 different authors.\nA special thanks goes to the 3 first time contributors:\n\n    Matt Whitlock @whitslack\n    Sergi Delgado Segura @sr-gi\n    Moller40 @Moller40\n\nCheers,\nChristian, Rusty, ZmnSCPxj, and Lisa"
            }
        ],
        "thread_summary": {
            "title": "c-lightning release v0.9.1: The Antiguan BTC Maximalist Society",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2290
        }
    }
]