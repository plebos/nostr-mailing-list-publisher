[
    {
        "title": "[Lightning-dev] An Argument For Single-Asset Lightning Network",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2019-01-02T06:09:23",
                "message_text_only": "Happy new year lightning-dev!\n\nThis topic is my main area of research at moment so I'm really happy to see\na thread about it. In general I agree with ZmnSCPxj's analysis and\nconclusions. I'd like to add a couple of ideas to this discussion and would\ngreatly appreciate some early peer review on them :)\n\nHTLCs as American call options\n=========================\n\nI think the \"option problem\" is actually caused by protocols using HTLCs in\na naive way rather than the use of HTLCs themselves. Consider the atomic\nswap protocol described in the OP:\n\n>1.  You provide me a hash of some secret preimage that only you know.\n>2.  You make an HTLC on the Bitcoin blockchain.\n>The value of this HTLC is `P`, the hash is the hash you gave above, and\nthe timelock is `E` + 1 day.\n>3.  I make an HTLC on the WJT blockchain.\n>The value of this HTLC is 1, the hash is the hash you gave, and the\ntimelock is `E`.\n\nIf we take this protocol and draw out its abstract functionality we get:\n\n1. *Up for sale* Alice puts Asset `A` up for sale to Bob for some time\nperiod `Eb` + `Ea`\n2. *Make expiring offer* Bob makes an offer of asset `B` which expires at\ntime `Eb`\n3. *Take offer* Alice may take the offer up until time `Eb`\n\nAs has been pointed out, Alice has an \"option\" for the duration of `Eb`\n(and she didn't pay a premium). This is because Bob made her an offer he\ncannot cancel (an offer you can't cancel but has an expiration is basically\nthe definition of being short an option contract).\nIn order to remedy this, the party that makes the offer must be able to\ncancel their offer at any point after they have made it (before the\ncounterparty has taken it). This should be intuitive because it's how\ncentralised exchanges work.\n\nTherefore, the ideal abstract functionality we want is:\n\n1. *Make Offer* Alice makes an offer to Bob to trade `A` for `B`\n2. *Take Offer* Bob can take the offer (if Alice hasn't already cancelled\nit) and get `A` in exchange for `B`.\n3. *Cancel Offer* If Bob hasn't taken the offer, Alice may get back `A` by\ncancelling the offer\n\nI developed the protocol below which comes pretty close to realising this.\nLet\n- \u03b1 and \u03b2 and be two bitcoin-like blockchains\n- Alice own asset `A` on the \u03b1 blockchain and `C` on the \u03b2 blockchain\n- Bob own asset `B` on the \u03b2 blockchain\n\n1. Alice puts the HTLC for `A` on \u03b1 and waits for it to confirm (as per\nusual)\n2. Alice creates a partial \u03b2 blockchain transaction by signing one input\nand one output (using SIGHASH_SINGLE for example):\n   - The input is the asset `C`\n   - The output is a HTLC which gives `B` and `C` to herself with the\nsecret or gives them both to Bob on timeout\n  She sends this partial transaction to Bob. (This gives us the \"Make\nOffer\" functionality)\n3. If Bob wants to accept the offer, he adds asset `B` to another input of\nthe transaction and posts it to \u03b2. (This gives us \"Take Offer\"\nfunctionality)\n4. If Alice wishes to cancel the trade before Bob has confirmed this\ntransaction she double spends the `C` output and then reclaims `A` on \u03b1\nafter the timeout. (This gives us the \"Cancel Offer\" functionality)\n5. If the \"Take Offer\" transaction is confirmed on \u03b2, Alice must unlock the\nHTLC before the timeout or Bob will gain `C` AND get back `B`.\n6. Once she reveals the secret, she both gets back `C` and gains `B` on \u03b2.\n7. Bob can now take `A` on \u03b1 in the usual manner now that he has learned\nthe secret.\n\nBob is not guaranteed to get `A` after he \"takes\" the offer but he is\nguaranteed to get `A` (in exchange for `B`) or `C` (for free). Obviously,\n`C` is Alice's collateral for the trade. Bob should only take the offer if\nhe wants `A` more than `B` and if he is sure that the value of gaining `C`\nwill be greater than any loss he could experience from `B` depreciating\nrelative to `A` during the execution of the protocol.\n\nI believe this shows that HTLCs do not in cause options but rather\nuncancelable offers + uncollateralized HTLCs cause the option problem.\n\nI think this protocol works in payment channels in the case that Alice and\nBob have direct channels to each other. The issue is that if Alice decides\nshe wants to cancel at the same time Bob decides he wants to take it you\nhave to go to the blockchain to resolve the issue (which will be rather\narbitrary). CJP's idea of having a 3rd party who is trusted simply to\ncompute the outcome of a offer (cancelled or taken) in layer 2 networks\nseems like a promising direction because this would avoid on-chain\nresolution in this case.\n\nCross Asset Payments Don't Make Sense\n====================================\n\nAs ZmnSCPxj demonstrated, the idea of sending a payment in asset `A` and\nthe other party receiving it as asset `B` with some exchange node in the\nmiddle doing a conversion is unsound given what we are able to construct in\nLightning.\n\nBut this doesn't necessarily mean that Lightning has to be single asset.\nTheoretically, a single two-party channel could record multiple asset types\nwith a state transaction that has distinct outputs for different\nasset-type/party combinations. This would allow you to buy an amount of the\ndesired asset in one of your channels by simply doing a state update where\nyou lose `A` in exchange for `B` with your direct peer (no HTLCs needed).\nYou can then just send `B` normally to the receiver. This is not quite as\ngood as a cross asset payment but it could still be useful*.\n\nQuite simply, if you want to send someone asset `A` but they want to\nreceive asset `B` then just buy asset `B` with asset `A` and then send `B`\nto them!\n\n*I don't know much about non-native assets on Bitcoin and their suggested\nintegration with LN so I'm just guessing here.\n\nAll the best for 2019,\nLloyd\n\\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190102/5adacabb/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-02T12:15:48",
                "message_text_only": "Good morning Lloyd,\n\n> Therefore, the ideal abstract functionality we want is:\n>\n> 1. *Make Offer* Alice makes an offer to Bob to trade `A` for `B`\n> 2. *Take Offer* Bob can take the offer (if Alice hasn't already cancelled it) and get `A` in exchange for `B`.\n> 3. *Cancel Offer* If Bob hasn't taken the offer, Alice may get back `A` by cancelling the offer\n>\n> I developed the protocol below which comes pretty close to realising this.\n> Let\u00a0\n> - \u03b1 and \u03b2 and be two bitcoin-like blockchains\n> - Alice own asset `A` on the \u03b1 blockchain and `C` on the \u03b2 blockchain\n> - Bob own asset `B` on the \u03b2 blockchain\n>\n> 1. Alice puts the HTLC for `A` on \u03b1 and waits for it to confirm (as per usual)\n> 2. Alice creates a partial \u03b2 blockchain transaction by signing one input and one output (using SIGHASH_SINGLE for example):\n> \u00a0 \u00a0- The input is the asset `C`\n> \u00a0 \u00a0- The output is a HTLC which gives `B` and `C` to herself with the secret or gives them both to Bob on timeout\n> \u00a0 She sends this partial transaction to Bob. (This gives us the \"Make Offer\" functionality)\n> 3. If Bob wants to accept the offer, he adds asset `B` to another input of the transaction and posts it to \u03b2. (This gives us \"Take Offer\" functionality)\n> 4. If Alice wishes to cancel the trade before Bob has confirmed this transaction she double spends the `C` output and then reclaims `A` on \u03b1 after the timeout. (This gives us the \"Cancel Offer\" functionality)\n> 5. If the \"Take Offer\" transaction is confirmed on \u03b2, Alice must unlock the HTLC before the timeout or Bob will gain `C` AND get back `B`.\n> 6. Once she reveals the secret, she both gets back `C` and gains `B` on \u03b2.\n> 7. Bob can now take `A` on \u03b1 in the usual manner now that he has learned the secret.\n>\n> Bob is not guaranteed to get `A` after he \"takes\" the offer but he is guaranteed to get `A` (in exchange for `B`) or `C` (for free). Obviously, `C` is Alice's collateral for the trade. Bob should only take the offer if he wants `A` more than `B` and if he is sure that the value of gaining `C` will be greater than any loss he could experience from `B` depreciating relative to `A` during the execution of the protocol.\n>\n> I believe this shows that HTLCs do not in cause options but rather uncancelable offers + uncollateralized HTLCs cause the option problem.\u00a0\n\nI agree.\nWhen I was developing American Call Options on top of onchain HTLCs, I came up with a similar construction for ensuring that the premium is paid before the HTLCs setting up the option appear onchain.\nHowever, can such a scheme scale on-Lightning?\n\n>\n> I think this protocol works in payment channels in the case that Alice and Bob have direct channels to each other. The issue is that if Alice decides she wants to cancel at the same time Bob decides he wants to take it you have to go to the blockchain to resolve the issue (which will be rather arbitrary). CJP's idea of having a 3rd party who is trusted simply to compute the outcome of a offer (cancelled or taken) in layer 2 networks seems like a promising direction because this would avoid on-chain resolution in this case.\n>\n> Cross Asset Payments Don't Make Sense\n> ====================================\n>\n> As ZmnSCPxj demonstrated, the idea of sending a payment in asset `A` and the other party receiving it as asset `B` with some exchange node in the middle doing a conversion is unsound given what we are able to construct in Lightning.\n>\n> But this doesn't necessarily mean that Lightning has to be single asset. Theoretically, a single two-party channel could record multiple asset types with a state transaction that has distinct outputs for different asset-type/party combinations. This would allow you to buy an amount of the desired asset in one of your channels by simply doing a state update where you lose `A` in exchange for `B` with your direct peer (no HTLCs needed). You can then just send `B` normally to the receiver. This is not quite as good as a cross asset payment but it could still be useful*.\n\nIt may be possible with RGB.  However, you still need some kind of route from yourself to the payee, and the entire route from payer to payee needs to be liquid for the target asset.  If there is no viable route where all channels have the asset, then the payment cannot push through.\n\nIn addition, this cannot be a cross-blockchain asset, since channels can exist on exactly one blockchain or other cryptocurrency system.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-02T13:02:21",
                "message_text_only": "Good morning CJP,\n\n>\n> -   No exchange: unattractive, because there is significant demand for\n>     this.\n>\n> -   Regular Lightning-based or other HTLC-like atomic swap: unattractive,\n>     because of the exploitable \"American Call Option\" nature (as we both\n>     described). May only function with a very high spread, compensating for\n>     OM's risk.\n>\n> -   Regular, centralized exchanges: current situation. Third party is\n>     trusted with holding funds and executing trade orders.\n>\n> -   My proposal: third party is trusted with executing transactions\n>     properly (not performing the delay attack).\n>\n> -   Trustless exchange: holy grail, but I don't know how to do that.\n>\n>     So I don't claim my proposal is perfect, but I'd like to argue it is\n>     the best known system because it's an improvement over the current\n>     situation where most people use centralized exchanges, at least in\n>     terms of trust required(*).\n\nYou may be right.\n\nI wonder however if this is a \"small enough\" hole that leaving it is an acknowledged security vulnerability may be better than replacing it with a trusted third party.\nOne may compare with the SSH \"trust the first pubkey, verify the second onwards\" weakness, to SSL \"trust the certificate authority to say whose pubkey is whose\".\n\nOMs do have mitigations, specifically: (1) reducing the allowed forwarded CLTV distance and (2) increasing the bid-ask spread; perhaps that can be enough to enable a somewhat-multiasset network.\n\n> Now, if an RM can be punished, it would be even better. I was thinking in the direction of collecting proof of misbehavior, which can then help make the RM lose its (lucrative!) business, but I doubt this is possible.\n\nThe hop node just before the RM can provide proof that it offered an HTLC and the RM allowed the HTLC offer to be made.\nIt can provide a commitment transaction signed by itself and the RM, with that commitment transaction containing the HTLC in question.\nThis is proof that the RM *could* pull the HTLC, but did not do so quickly enough.\n\nSince RM nodes are publicly known, perhaps we can make a different routing from S to RM, one that reveals (to hop nodes) their distance to RM, but not to S.\nRM nodes provide a service to the network and we can argue that the loss of their privacy here is acceptable, as long as the payee S is still able to keep its privacy, as an acceptable cost to ensuring that RM behaves honestly.\n\nIf the just-before-last node (let us call this G or \"guard\" node) can monitor the time that RM pulls the HTLC, then it can provide proof that RM had the ability to pull the HTLC but did not do so.\nThe G cannot attack the RM, since if G then stalls after the RM releases the preimage to it, the RM can just publish the commitment transaction with the HTLC onchain, together with the release of the preimage.\nIn the onchain case, proof of RM malfeasance reduces to checking if the preimage appears onchain \"fast enough\".\nHowever, this could be attacked by stuffing blocks and increasing onchain fees, a risk whose cost the RM will pass to F and S nodes.\n\nUnder Poon-Dryja, we can do:\n\n1.  After a new commitment transaction is signed, the old commitment transaction is still publishable onchain.\n2.  The old commitment transaction only becomes unpublishable (via punishment) if it is revoked, which is done after the new commitment transaction is signed.\n3.  Thus, if G node wishes to show malfeasance by RM, it must show that it revoked the commitment transaction just before that one by publishing the new commitment transaction (containing the HTLC to RM as proof that RM could have claimed but did not) onchain instead of the old commitment transaction (since what is published onchain becomes true, that is sufficient).\n4.  The RM must defend against the claim of malfeasance by claiming the HTLC immediately, publishing the preimage.\n5.  The OM must know the channel by which the RM gets paid (and thus the identity of G and RM) in order to monitor that channel and get its input asset immediately when a malfeasance claim is responded to by the RM.\n\nUnder Decker-Russell-Osuntokun, we cannot perform the claim of malfeasance, and the RM defense, onchain.\nThis is because of the CSV in-between the update and settlement transactions, which prevents timely publication of the HTLC and the preimage claiming it onchain.\nThis is compensated for somewhat in that the signing of a new update transaction is sufficient to prevent publication (via gainsaying) of older update transactions, so we can perform the claim of malfeasance and the RM defense offchain completely.\nThe G node publishes (via some non-blockchain protocol somehow, wave hands here) the update transaction and corresponding settlement transaction with the HTLC in question as a claim-of-malfeasance.\nThe RM node defends against this by publishing (via some uncensorable method) the transaction that claims the HTLC with a preimage.\nThe need for some other uncensorable method of showing the preimage is something of a problem, however; in this, Poon-Dryja is surprisingly superior due to its placement of the CSV *after* HTLCs instead of before.\n\nWe can have a mostly Decker-Russell-Osuntokun network, with Poon-Dryja only between G and RM nodes, so that most users do not have to suffer the issues of Poon-Dryja for everyday usage.\n\nNote that since the path from S to RM is selected by RM, though, S must serve as G, and every node in-between that is honestly not a sockpuppet of RM should be prepared to shut down their channels immediately in case of slow response from the next node.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "CJP",
                "date": "2019-01-02T21:06:49",
                "message_text_only": "ZmnSCPxj schreef op wo 02-01-2019 om 13:02 [+0000]:\n> I wonder however if this is a \"small enough\" hole that leaving it is\n> an acknowledged security vulnerability may be better than replacing\n> it with a trusted third party.\n> One may compare with the SSH \"trust the first pubkey, verify the\n> second onwards\" weakness, to SSL \"trust the certificate authority to\n> say whose pubkey is whose\".\n\nSSH's problem (non-authenticated initial key exchange) is small,\nbecause there is a very small time window for an attack, and an\nattacker has to place itself in the route *and* stay in the route to\nnot be detected later.\n\nSSL's problem (trusted third parties for key authentication) is big,\nbecause each website only uses a single certificate issuer, so you need\nto trust every certificate issuer to be able to visit every website,\neven the more questionable certificate issuers; the combined security\nis as strong as the weakest certificate issuer.\n\nRoute Makers (RM) (maybe I should change that name) are not a big\nproblem, because, unlike websites, OMs and OTs are very fungible\ntowards each other, especially on popular asset pairs: it's not a big\ndeal if you lose, say, 10% of potential trading partners because you\ndon't want to use a certain RM. Also, a single attack by a RM is not\ntypically a big deal, and it is easily detectable. False positives are\npossible though (both accidental and deliberate), so you might want to\nsuspend a RM after abuse detection for a while, and then give it\nanother chance after some time.\n\n> The hop node just before the RM can provide proof that it offered an\n> HTLC and the RM allowed the HTLC offer to be made.\n> It can provide a commitment transaction signed by itself and the RM,\n> with that commitment transaction containing the HTLC in question.\n> This is proof that the RM *could* pull the HTLC, but did not do so\n> quickly enough.\n> \n> Since RM nodes are publicly known, perhaps we can make a different\n> routing from S to RM, one that reveals (to hop nodes) their distance\n> to RM, but not to S.\n> RM nodes provide a service to the network and we can argue that the\n> loss of their privacy here is acceptable, as long as the payee S is\n> still able to keep its privacy, as an acceptable cost to ensuring\n> that RM behaves honestly.\n> \n> If the just-before-last node (let us call this G or \"guard\" node) can\n> monitor the time that RM pulls the HTLC, then it can provide proof\n> that RM had the ability to pull the HTLC but did not do so.\n\nThis, and the rest of your proposal, sounds like a lot of trouble,\nwhile it hardly solves anything.\n\nRM can have its node surrounded by other nodes also controlled by\nitself. So it is possible that RM controls all nodes that can possibly\nfulfill the 'G' role, and thereby stop any evidence being generated\nagainst the RM node. If you then want to build evidence against the G\nnodes, you end up recursively involving every single Lightning node in\ntrying to solve your problem. Maybe it is possible, but I'd like not to\ndo that. I like to see the exchange function as a higher layer (layer\n3) on top of the Lightning layer, and have each layer solve its own\nproblems in a clean and elegant way. I prefer that nodes that aren't\ninvolved in exchanging assets don't need to deal with its complexities\neither.\n\nCJP"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-03T00:43:30",
                "message_text_only": "Good morning CJP,\n\n\n> This, and the rest of your proposal, sounds like a lot of trouble,\n> while it hardly solves anything.\n>\n> RM can have its node surrounded by other nodes also controlled by\n> itself. So it is possible that RM controls all nodes that can possibly\n> fulfill the 'G' role, and thereby stop any evidence being generated\n> against the RM node. If you then want to build evidence against the G\n> nodes, you end up recursively involving every single Lightning node in\n> trying to solve your problem. Maybe it is possible, but I'd like not to\n> do that. I like to see the exchange function as a higher layer (layer\n> 3) on top of the Lightning layer, and have each layer solve its own\n> problems in a clean and elegant way. I prefer that nodes that aren't\n> involved in exchanging assets don't need to deal with its complexities\n> either.\n\nWhich is why I later say:\n\n> > Note that since the path from S to RM is selected by RM, though, S must serve as G, and every node in-between that is honestly not a sockpuppet of RM should be prepared to shut down their channels immediately in case of slow response from the next node.\n\nAssuming S is a payee, it has every incentive to follow this protocol.\n\nOf course, now OM needs to know G, and thus knows S, the payee, and now has the power to censor payments.\nHeavy sigh.\n\nFurther, if S is not a payee, but is secretly a sockpuppet of F who is setting up an American Call Option, S can simply not forward to RM until much later.\nHeavy sigh.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "CJP",
                "date": "2019-01-02T21:26:43",
                "message_text_only": "Regarding this subject, I believe I should disclose that my current\nemployer, Bitonic, operates an evil, centralized, trusted exchange, and\nthat the ideas discussed in this thread may be related to concepts that\nare actually being developed by my employer.\n\nSo, am I biased? Who knows? Does it matter? Can you trust me? Maybe,\nbut I guess you shouldn't anyway. In my view, words should be\nconvincing or unconvincing regardless of who speaks them. \n\nCJP\n\n\nCJP schreef op vr 28-12-2018 om 09:27 [+0100]:\n> Hi ZmnSCPxj,\n> \n> I think we've already addressed this issue before:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/00\n> 12\n> 92.html\n> \n> and especially this proposal of me:\n> https://bitonic.nl/public/slowdown_prevention.pdf\n> \n> It's not completely trustless, but I tend to see trustlessness in a\n> very pragmatic sense anyway. Trust creates a risk, but if the\n> alternative trustless system is very impractical, and the risk is\n> small\n> enough, the benefits might simply be worth the risks. Note that this\n> is\n> a completely subjective trade-off, so it is only acceptable on an\n> individual, voluntary basis.\n> \n> CJP\n>"
            },
            {
                "author": "Lawrence Deacon",
                "date": "2019-01-03T12:07:38",
                "message_text_only": "Do cross-asset lightning nodes do not offer premium-free American call options?\n=============================================================\nI would argue that cross-asset lightning nodes do not offer premium-free American call options for the following reasons.\n\nSay I wanted to set up to purchase 1 WJT for P bitcoins at time t < T where t is the time I close the contract and T is the expiry time.\n\nIn order to set up the contract I must pay P bitcoins to the contract, incurring an opportunity cost of x_i1. Assuming we set up the contract at time t_0=0, this will be equivalent to the money I could have earned by loaning the currency at interest during the period t. \n\nI must also pay the issuer of the contract a premium x_p (in the case where I am both recipient and issuer, see further down).\n\nIf S(t) is the spot price at time t and K = S(t) - P then the payoff for me is as follows:\n\nS(t) > P:        K  - x_p  -  x_i1 \nS(t) < P:        -x_i1 - x_p\n\n\nIf x_i2 is the opportunity cost of paying 1 WJT to the contract for time t then the payoff for the other party (issuer) is as follows:\n\nS(t) > P:        -K + x_p - x_i2\t\nS(t) < P:         x_p  - x_i2\n\nIf x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n\nIn the case where I am both recipient and issuer of the contract, to get the payoff we add the above payoffs:\n\nS(t) > P:         -x_i1 - x_i2\nS(t) < P:         -x_i1 - x_i2\n\nThis is a guaranteed loss.\n\nConclusion\n========\nLightning nodes do not offer premium-free American call options because whether or not the contract and issuer are the same person, setting up a premium free American call option using a HTLC guarantees a loss for one or both parties. Even if the opportunity costs were 0, then setting up a contract with myself would have a guaranteed 0 payoff.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190103/cc6cad95/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-03T13:04:58",
                "message_text_only": "Good morning Lawrence,\n\nWhile true, on Lightning, interest earnings are ***tiny*** enough that the premium \"paid\" in this manner is minimal.\nIncrease in alternative interest earnings for Bitcoin on non-Lightning alternatives would also cut down the available liquidity on Lightning and increase Lightning fees.\n\nFurther, the current nature of cryptocurrency assets is highly speculative and large swings in exchange rates in short time frames are typical.\nThus the premium paid is minimal compared to the upside of the speculative call option.\n\nFinally, the massive problem here is that the exchange, which enables cross-asset swap, is itself obligated to lock the asset to be called in the contract.\nIn particular, the \"premium\" is ***not paid*** to the exchange node; instead, the \"premium\", such as it is, is split between both the exchange and the user of the American Call Option, and is paid as a temporary decrease in the supply of both assets to the rest of the economy.\nThe galling part is that it violates the principle of \"initiator pays\", since the exchange, which passively advertises its service, does not initiate the creation of the American Call Option yet is forced to pay for its existence by locking its own assets.\n\nGiven this, the logical consequence is that on-Lightning exchanges will increase, probably greatly, their bid/ask spreads on Lightning compared to custodial exchanges, increasing market friction on cross-asset payments on Lightning.\nThis means that rational payees may find it more lucrative to accept the more popular asset, identify a \"trustworthy\" custodial exchange, and use the lower bid/ask spread on such a trust-based exchange to get more of their desired target asset compared to being paid on Lightning.\n\nThe end result is the Lightning network primarily settling on the most popular of the assets, i.e. Bitcoin.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, January 3, 2019 8:07 PM, Lawrence Deacon <lawrence at commerceblock.com> wrote:\n\n> Do cross-asset lightning nodes do not offer premium-free American call options?\n>\n> =============================================================\n>\n> I would argue that cross-asset lightning nodes do not offer premium-free American call options for the following reasons.\n>\n> Say I wanted to set up to purchase 1 WJT for P bitcoins at time t < T where t is the time I close the contract and T is the expiry time.\n>\n> In order to set up the contract I must pay P bitcoins to the contract, incurring an opportunity cost of x_i1. Assuming we set up the contract at time t_0=0, this will be equivalent to the money I could have earned by loaning the currency at interest during the period t.\u00a0\n>\n> I must also pay the issuer of the contract a premium x_p (in the case where I am both recipient and issuer, see further down).\n>\n> If S(t) is the spot price at time t and K = S(t) - P then the payoff for me is as follows:\n>\n> S(t) > P: \u00a0 \u00a0 \u00a0 \u00a0K \u00a0- x_p \u00a0- \u00a0x_i1\u00a0\n> S(t) < P: \u00a0 \u00a0 \u00a0 \u00a0-x_i1 - x_p\n>\n> If x_i2 is the opportunity cost of paying 1 WJT to the contract for time t then the payoff for the other party (issuer) is as follows:\n>\n> S(t) > P: \u00a0 \u00a0 \u00a0 \u00a0-K + x_p - x_i2\n> S(t) < P: \u00a0 \u00a0 \u00a0 \u00a0 x_p \u00a0- x_i2\n>\n> If x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n>\n> In the case where I am both recipient and issuer of the contract, to get the payoff we add the above payoffs:\n>\n> S(t) > P: \u00a0 \u00a0 \u00a0 \u00a0 -x_i1 - x_i2\n> S(t) < P: \u00a0 \u00a0 \u00a0 \u00a0 -x_i1 - x_i2\n>\n> This is a guaranteed loss.\n>\n> Conclusion\n> ========\n> Lightning nodes do not offer premium-free American call options because whether or not the contract and issuer are the same person, setting up a premium free American call option using a HTLC guarantees a loss for one or both parties. Even if the opportunity costs were 0, then setting up a contract with myself would have a guaranteed 0 payoff."
            },
            {
                "author": "Lawrence Deacon",
                "date": "2019-01-03T13:42:44",
                "message_text_only": "Good morning,\n\n\n\n> On 3 Jan 2019, at 13:04, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Lawrence,\n> \n> While true, on Lightning, interest earnings are ***tiny*** enough that the premium \"paid\" in this manner is minimal.\n> Increase in alternative interest earnings for Bitcoin on non-Lightning alternatives would also cut down the available liquidity on Lightning and increase Lightning fees.\n\nIf the contract issuer and recipient are different people, the issuer would charge an option price or premium, x_p, which would depend on volatility. \n\nIf the issuer and recipient are the same person, they are guaranteed a loss.\n\n> \n> Further, the current nature of cryptocurrency assets is highly speculative and large swings in exchange rates in short time frames are typical.\n> Thus the premium paid is minimal compared to the upside of the speculative call option.\n\nThis would be reflected in the premium calculated by the contract issuer; x_p increases with volatility.\n\n> \n> Finally, the massive problem here is that the exchange, which enables cross-asset swap, is itself obligated to lock the asset to be called in the contract.\n> In particular, the \"premium\" is ***not paid*** to the exchange node; instead, the \"premium\", such as it is, is split between both the exchange and the user of the American Call Option, and is paid as a temporary decrease in the supply of both assets to the rest of the economy.\n> The galling part is that it violates the principle of \"initiator pays\", since the exchange, which passively advertises its service, does not initiate the creation of the American Call Option yet is forced to pay for its existence by locking its own assets.\n> \n\nThe initiator pays an opportunity cost by depositing funds into the exchange.\n\n> Given this, the logical consequence is that on-Lightning exchanges will increase, probably greatly, their bid/ask spreads on Lightning compared to custodial exchanges, increasing market friction on cross-asset payments on Lightning.\n> This means that rational payees may find it more lucrative to accept the more popular asset, identify a \"trustworthy\" custodial exchange, and use the lower bid/ask spread on such a trust-based exchange to get more of their desired target asset compared to being paid on Lightning.\n> \n> The end result is the Lightning network primarily settling on the most popular of the assets, i.e. Bitcoin.\n> \n> Regards,\n> ZmnSCPxj\n> \n> Sent with ProtonMail Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Thursday, January 3, 2019 8:07 PM, Lawrence Deacon <lawrence at commerceblock.com> wrote:\n> \n>> Do cross-asset lightning nodes do not offer premium-free American call options?\n>> \n>> =============================================================\n>> \n>> I would argue that cross-asset lightning nodes do not offer premium-free American call options for the following reasons.\n>> \n>> Say I wanted to set up to purchase 1 WJT for P bitcoins at time t < T where t is the time I close the contract and T is the expiry time.\n>> \n>> In order to set up the contract I must pay P bitcoins to the contract, incurring an opportunity cost of x_i1. Assuming we set up the contract at time t_0=0, this will be equivalent to the money I could have earned by loaning the currency at interest during the period t. \n>> \n>> I must also pay the issuer of the contract a premium x_p (in the case where I am both recipient and issuer, see further down).\n>> \n>> If S(t) is the spot price at time t and K = S(t) - P then the payoff for me is as follows:\n>> \n>> S(t) > P:        K  - x_p  -  x_i1 \n>> S(t) < P:        -x_i1 - x_p\n>> \n>> If x_i2 is the opportunity cost of paying 1 WJT to the contract for time t then the payoff for the other party (issuer) is as follows:\n>> \n>> S(t) > P:        -K + x_p - x_i2\n>> S(t) < P:         x_p  - x_i2\n>> \n>> If x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n>> \n>> In the case where I am both recipient and issuer of the contract, to get the payoff we add the above payoffs:\n>> \n>> S(t) > P:         -x_i1 - x_i2\n>> S(t) < P:         -x_i1 - x_i2\n>> \n>> This is a guaranteed loss.\n>> \n>> Conclusion\n>> ========\n>> Lightning nodes do not offer premium-free American call options because whether or not the contract and issuer are the same person, setting up a premium free American call option using a HTLC guarantees a loss for one or both parties. Even if the opportunity costs were 0, then setting up a contract with myself would have a guaranteed 0 payoff.\n> \n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-03T13:24:48",
                "message_text_only": "Good morning Lawrence,\n\nOn re-reading your argument, no, you have misunderstood massively.\n\nThe two HTLCs together form a *single* American Call Option, issued by the exchange to the initiator of the \"payment\".\n\nIt is not the initiator somehow issuing an American Call Option to itself by routing a payment to itself.\nIt is the initiator forcing the exchange to give it the equivalent of an American Call Option by routing a payment to itself.\nIn particular, the cost of locking the WJT asset is paid *by the exchange*, not the initiator of the contract.\n\n> If x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n\nThis implies that the nobody will act as an exchange (since it could be coerced into issuing an American Call Option for free), hence the argument that Lightning Network will always have a single asset.\nNote that this is one trivial way for your conclusion:\n\n>lightning nodes do not offer premium-free American call options\n\nto be true, i.e. there will be no cross-asset nodes.\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, January 3, 2019 8:07 PM, Lawrence Deacon <lawrence at commerceblock.com> wrote:\n\n> Do cross-asset lightning nodes do not offer premium-free American call options?\n>\n> =============================================================\n>\n> I would argue that cross-asset lightning nodes do not offer premium-free American call options for the following reasons.\n>\n> Say I wanted to set up to purchase 1 WJT for P bitcoins at time t < T where t is the time I close the contract and T is the expiry time.\n>\n> In order to set up the contract I must pay P bitcoins to the contract, incurring an opportunity cost of x_i1. Assuming we set up the contract at time t_0=0, this will be equivalent to the money I could have earned by loaning the currency at interest during the period t.\u00a0\n>\n> I must also pay the issuer of the contract a premium x_p (in the case where I am both recipient and issuer, see further down).\n>\n> If S(t) is the spot price at time t and K = S(t) - P then the payoff for me is as follows:\n>\n> S(t) > P: \u00a0 \u00a0 \u00a0 \u00a0K \u00a0- x_p \u00a0- \u00a0x_i1\u00a0\n> S(t) < P: \u00a0 \u00a0 \u00a0 \u00a0-x_i1 - x_p\n>\n> If x_i2 is the opportunity cost of paying 1 WJT to the contract for time t then the payoff for the other party (issuer) is as follows:\n>\n> S(t) > P: \u00a0 \u00a0 \u00a0 \u00a0-K + x_p - x_i2\n> S(t) < P: \u00a0 \u00a0 \u00a0 \u00a0 x_p \u00a0- x_i2\n>\n> If x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n>\n> In the case where I am both recipient and issuer of the contract, to get the payoff we add the above payoffs:\n>\n> S(t) > P: \u00a0 \u00a0 \u00a0 \u00a0 -x_i1 - x_i2\n> S(t) < P: \u00a0 \u00a0 \u00a0 \u00a0 -x_i1 - x_i2\n>\n> This is a guaranteed loss.\n>\n> Conclusion\n> ========\n> Lightning nodes do not offer premium-free American call options because whether or not the contract and issuer are the same person, setting up a premium free American call option using a HTLC guarantees a loss for one or both parties. Even if the opportunity costs were 0, then setting up a contract with myself would have a guaranteed 0 payoff."
            },
            {
                "author": "Lawrence Deacon",
                "date": "2019-01-03T13:51:45",
                "message_text_only": "> On 3 Jan 2019, at 13:24, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Lawrence,\n> \n> On re-reading your argument, no, you have misunderstood massively.\n> \n> The two HTLCs together form a *single* American Call Option, issued by the exchange to the initiator of the \"payment\".\n> \n> It is not the initiator somehow issuing an American Call Option to itself by routing a payment to itself.\n> It is the initiator forcing the exchange to give it the equivalent of an American Call Option by routing a payment to itself.\n> In particular, the cost of locking the WJT asset is paid *by the exchange*, not the initiator of the contract.\n> \n\nThe initiator of the contract must deposit 1 WJT into the exchange before the exchange will create the contract. Therefore the opportunity costs are borne by the initiator.\n\n>> If x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n> \n> This implies that the nobody will act as an exchange (since it could be coerced into issuing an American Call Option for free), hence the argument that Lightning Network will always have a single asset.\n> Note that this is one trivial way for your conclusion:\n> \n>> lightning nodes do not offer premium-free American call options\n> \n> to be true, i.e. there will be no cross-asset nodes.\n> Regards,\n> ZmnSCPxj\n> \n> \n> Sent with ProtonMail Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Thursday, January 3, 2019 8:07 PM, Lawrence Deacon <lawrence at commerceblock.com> wrote:\n> \n>> Do cross-asset lightning nodes do not offer premium-free American call options?\n>> \n>> =============================================================\n>> \n>> I would argue that cross-asset lightning nodes do not offer premium-free American call options for the following reasons.\n>> \n>> Say I wanted to set up to purchase 1 WJT for P bitcoins at time t < T where t is the time I close the contract and T is the expiry time.\n>> \n>> In order to set up the contract I must pay P bitcoins to the contract, incurring an opportunity cost of x_i1. Assuming we set up the contract at time t_0=0, this will be equivalent to the money I could have earned by loaning the currency at interest during the period t. \n>> \n>> I must also pay the issuer of the contract a premium x_p (in the case where I am both recipient and issuer, see further down).\n>> \n>> If S(t) is the spot price at time t and K = S(t) - P then the payoff for me is as follows:\n>> \n>> S(t) > P:        K  - x_p  -  x_i1 \n>> S(t) < P:        -x_i1 - x_p\n>> \n>> If x_i2 is the opportunity cost of paying 1 WJT to the contract for time t then the payoff for the other party (issuer) is as follows:\n>> \n>> S(t) > P:        -K + x_p - x_i2\n>> S(t) < P:         x_p  - x_i2\n>> \n>> If x_p = 0 then the issuer is guaranteed a loss. Therefore no rational contract issuer will issue an American call option for free.\n>> \n>> In the case where I am both recipient and issuer of the contract, to get the payoff we add the above payoffs:\n>> \n>> S(t) > P:         -x_i1 - x_i2\n>> S(t) < P:         -x_i1 - x_i2\n>> \n>> This is a guaranteed loss.\n>> \n>> Conclusion\n>> ========\n>> Lightning nodes do not offer premium-free American call options because whether or not the contract and issuer are the same person, setting up a premium free American call option using a HTLC guarantees a loss for one or both parties. Even if the opportunity costs were 0, then setting up a contract with myself would have a guaranteed 0 payoff.\n> \n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-04T03:38:59",
                "message_text_only": "Good morning Lawrence,\n\n> > On re-reading your argument, no, you have misunderstood massively.\n> > The two HTLCs together form a single American Call Option, issued by the exchange to the initiator of the \"payment\".\n> > It is not the initiator somehow issuing an American Call Option to itself by routing a payment to itself.\n> > It is the initiator forcing the exchange to give it the equivalent of an American Call Option by routing a payment to itself.\n> > In particular, the cost of locking the WJT asset is paid by the exchange, not the initiator of the contract.\n>\n> The initiator of the contract must deposit 1 WJT into the exchange before the exchange will create the contract. Therefore the opportunity costs are borne by the initiator.\n\nYou still have not understood.\n\nWe are discussing here a non-custodial exchange that acts as a Lightning Node on both BTC and WJT networks.\n\nSuppose I know of such a non-custodial exchange.\nI create a BTC channel to this.\nThen I create a WJT channel.\n\nIn both cases, yes, I have to lock my assets into the channels created (unless we now have dual-funded channels and I convince the exchange node to fund the WJT channel).\n\nWhat I do then is to send out via the WJT channel to any WJT-accepting merchant and get something in value equivalent to the WJT I send out.\nIt can be something as trivial as a submarine swap, where I get ***onchain WJT*** by paying my ***offchain WJT*** over Lightning.\n\n\nIn this way, the WJT in the channel is ***no longer mine***, and given a fungible WJT asset then a submarine swap means I have reacquired the WJT I put in the channel in the first place; it is now available to me onchain to dispose of as I wish.\nIf the WJT in the channel is locked up in an HTLC, ***I am not paying the opportunity costs for locking WJT***.\nIt is the exchange which pays the opportunity cost since I have already paid the WJT to the exchange for a separate \"unrelated\" payment.\n\nAfterwards, I can coerce the exchange to issue me an American Call Option by routing a BTC payment from myself to a WJT payment to myself.\nSince the CLTV will be a future time and date, I can always delay failing or accepting the incoming HTLC until just before the indicated locktime.\n\n\nAll your analysis means is precisely that nobody will rationally act as a Lightning node swap exchange, since being an exchange implicitly means you are offering American Call Options that are premium-free.\nIf there are no Lightning node swap exchanges, then cross-asset swaps over Lightning cannot be done: nobody will enable the swap.\nHence the conclusion: Lightning Network will remain single asset.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2019-01-04T21:05:05",
                "message_text_only": "On Thu, Dec 27, 2018 at 05:43:51AM +0000, ZmnSCPxj via Lightning-dev wrote:\n> We can try to mitigate this, but the solutions below all have significant drawbacks.\n\nAn alternative is to give the person making the exchange the ability to\ncancel the payment if they think the exchange rate has changed\nunfavorably for them.  I think you could do that by adding an extra\nhashlock to the HTLC that's controlled by the exchanger.  For example,\nhere's what we'd expect a cross-asset path to look like:\n\n    Alice       Bob         Charlie     Dan         Eliza\n    1.3 mBTC -> 1.3 mBTC -> 1.2 mBTC\n                            1.2 mWJT -> 1.1 mWJT -> 1.0 mWJT\n\nInstead of Alice's node just locally constructing this path and trying\nto pay it like normal, she first sends a special probe to Charlie\nrequesting a new hash for which only he knows the preimage.  With this\nhash plus the hash Alice received from Eliza, Alice sends a payment that\nrequires both hashlocks be unlocked before anyone can claim the payment.\n\n1. When this payment reaches the exchanger, Charlie, he checks that the\npayment includes a hashlock he controls before routing the payment on to\na different asset.\n\n2. When the payment reaches receiver Eliza's node, she releases her\nPreImage (PI0) back along the path.\n\n3. When Eliza's preimage reaches exchanger Charlie's node, he releases\nhis preimage (PI1) in both directions along the path and continues\nforwarding PI0 backwards.  Eventually everyone receives both preimages\nthrough the usual offchain or onchain mechanisms.\n\n    Alice       Bob         Charlie     Dan         Eliza\n    PI0    <-   PI0   <-    PI0     <-  PI0    <-   PI0 (start here)\n    PI1    <-   PI1   <-    PI1     ->  PI1    ->   PI1\n\nHowever, if the exchange rate changes too much for Charlie's comfort\nbefore both preimages have been released, Charlie can unilaterally\ndecide to cancel the payment by simply not releasing his preimage.\n\nNote that by making the payment contingent on the approval of the\nexchanger, the ability to create an underhanded call option is\ntransferred to the exchanger.  However, this may be less concerning\nbecause the exchanger can only keep this option open by refusing to\nimmediately claim the routing fees.\n\nFor example, our exchanger Charlie is being offered 0.1 mBTC to route\nthe payment (a made up number).  If he can route 100 such payments in a\nday (another made up number), he can earn 10.0 mBTC from routing.  By\ncomparison, if he delays a payment of 1.2 mBTC, he'd need to expect the\nexchange rate to change by an order of magnitude within a day to earn\nthe same amount.  In ZmnSCPxj's terminology, the option is now no longer\nfree because Charlie must decide between potential routing income and\npotential option income.  Whether or not exchangers play the option game\nwill therefore likely be based on the amount of honest routing income\nthey can earn relative to the exchange rate volatility (and also on how\ngood nodes get at tracking reliable routes).\n\nThis idea certainly complicates the current protocol (both routing and\ntransaction construction), but maybe there are simplifications\navailable.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190104/09413fd9/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-05T07:01:18",
                "message_text_only": "Good morning David,\n\nWhat happens if the exchange node only sends its preimage towards the payer and not towards the payee?\n\nIf the payer and payee do not coordinate, then it becomes possible for the exchange node to take the funds without the payee gaining the ability to claim the payment.\nThis might be used by a node to take proofs of payment without paying, by simulating the payer and exchange nodes.\nThis may be important if the proof of payment is valuable, such as, the mentioned offline Lightning vending machines, or if the preimage is the decryption key for valuable data (e.g. ransomware; now the ransomware author may find it is scammed off their potential earnings).\n\nRegards,\nZmnSCPxj\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, January 5, 2019 5:05 AM, David A. Harding <dave at dtrt.org> wrote:\n\n> On Thu, Dec 27, 2018 at 05:43:51AM +0000, ZmnSCPxj via Lightning-dev wrote:\n>\n> > We can try to mitigate this, but the solutions below all have significant drawbacks.\n>\n> An alternative is to give the person making the exchange the ability to\n> cancel the payment if they think the exchange rate has changed\n> unfavorably for them. I think you could do that by adding an extra\n> hashlock to the HTLC that's controlled by the exchanger. For example,\n> here's what we'd expect a cross-asset path to look like:\n>\n> Alice Bob Charlie Dan Eliza\n> 1.3 mBTC -> 1.3 mBTC -> 1.2 mBTC\n>\n>                             1.2 mWJT -> 1.1 mWJT -> 1.0 mWJT\n>\n>\n> Instead of Alice's node just locally constructing this path and trying\n> to pay it like normal, she first sends a special probe to Charlie\n> requesting a new hash for which only he knows the preimage. With this\n> hash plus the hash Alice received from Eliza, Alice sends a payment that\n> requires both hashlocks be unlocked before anyone can claim the payment.\n>\n> 1.  When this payment reaches the exchanger, Charlie, he checks that the\n>     payment includes a hashlock he controls before routing the payment on to\n>     a different asset.\n>\n> 2.  When the payment reaches receiver Eliza's node, she releases her\n>     PreImage (PI0) back along the path.\n>\n> 3.  When Eliza's preimage reaches exchanger Charlie's node, he releases\n>     his preimage (PI1) in both directions along the path and continues\n>     forwarding PI0 backwards. Eventually everyone receives both preimages\n>     through the usual offchain or onchain mechanisms.\n>\n>     Alice Bob Charlie Dan Eliza\n>     PI0 <- PI0 <- PI0 <- PI0 <- PI0 (start here)\n>     PI1 <- PI1 <- PI1 -> PI1 -> PI1\n>\n>\n> However, if the exchange rate changes too much for Charlie's comfort\n> before both preimages have been released, Charlie can unilaterally\n> decide to cancel the payment by simply not releasing his preimage.\n>\n> Note that by making the payment contingent on the approval of the\n> exchanger, the ability to create an underhanded call option is\n> transferred to the exchanger. However, this may be less concerning\n> because the exchanger can only keep this option open by refusing to\n> immediately claim the routing fees.\n>\n> For example, our exchanger Charlie is being offered 0.1 mBTC to route\n> the payment (a made up number). If he can route 100 such payments in a\n> day (another made up number), he can earn 10.0 mBTC from routing. By\n> comparison, if he delays a payment of 1.2 mBTC, he'd need to expect the\n> exchange rate to change by an order of magnitude within a day to earn\n> the same amount. In ZmnSCPxj's terminology, the option is now no longer\n> free because Charlie must decide between potential routing income and\n> potential option income. Whether or not exchangers play the option game\n> will therefore likely be based on the amount of honest routing income\n> they can earn relative to the exchange rate volatility (and also on how\n> good nodes get at tracking reliable routes).\n>\n> This idea certainly complicates the current protocol (both routing and\n> transaction construction), but maybe there are simplifications\n> available.\n>\n> -Dave"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-01-05T09:23:51",
                "message_text_only": "Hi David and ZmnSCPxj,\n\nZmnSCPxj,\n\nThanks for your response. I messed something up with my response so my\noriginal post didn't get into the archive. I put it in a gist:\nhttps://gist.github.com/LLFourn/d0afa6b37207aed7cd73f6b9203c0def for\nreference.\n\n> I agree.\n> When I was developing American Call Options on top of onchain HTLCs, I\ncame up with a similar construction for ensuring that the premium is paid\nbefore the HTLCs setting up the option appear onchain.\n\nI would be interested to see how your construction worked. You can actually\nmodify the construction I gave before (in the gist) to create a fair option\ntoo. You just change it so the asset `C` is paid on both branches of the\nHTLC. This changes `C` from collateral to a premium. This sounds a bit\ndifferent to what you describe as the premium isn't paid before the HTLCs\ngo onto the chain.\n\nThe only other proposal for options I've seen is:\nhttps://www.ics.uci.edu/~jamesal1/Swaptions.pdf. I could be missing\nsomething, but this seems to give Alice a free option on an option in this\none. The premium payment has the option problem: Bob cannot cancel his\noffer of an option but Alice can take her time to accept it.\n\n> However, can such a scheme scale on-Lightning?\n\nThe scalability issue with the scheme in payment channels is the lack of\nobjective ordering of events in layer 2. If Alice and Bob disagree on\nwhether \"Take Offer\" or \"Cancel Offer\" happened first, they will have to\nclose their channel and resolve their dispute on the blockchain. This means\nthat channels may have to go to the blockchain much more often than if you\nwere just doing payments. In practice, this problem might not be so severe.\nParties that have frequent disputes will just tend to stop opening channels\nwith each other. It still guarantees that in the worst case there are no\nlong options for either party.\n\n---\nDavid,\n\n> Instead of Alice's node just locally constructing this path and trying\n> to pay it like normal, she first sends a special probe to Charlie\n> requesting a new hash for which only he knows the preimage.  With this\n> hash plus the hash Alice received from Eliza, Alice sends a payment that\n> requires both hashlocks be unlocked before anyone can claim the payment.\n\nMoving the option from the random anonymous person (Alice) to the exchange\nnode is a good improvement. If participants become good at identifying\nexchange nodes that delay in revealing the secret that might be enough to\nmake the cross asset payment idea practical.\n\nAs you hinted at, I think there is a simpler construction that is more\ncompatible with today's lightning:\n1. Alice given `A` wants to send `B` to Bob with Charlie doing the exchange.\n2. Charlie generates a secret `s` and makes a payment of `B` to Bob locked\nunder H(s)\n3. Once Bob has the locked payment of `B` he sends H(s) to Alice\n4. Alice then makes the payment of `A` under H(s) to Charlie.\n5. Charlie now unlocks Alice's payment with `s` and receives `A`\n6. Alice then learns `s` and sends it to Bob\n7. Bob unlocks Charlie's payment with `s` and receives `B`\n\n> In ZmnSCPxj's terminology, the option is now no longer\n> free because Charlie must decide between potential routing income and\n> potential option income\n\nI didn't really get why the exchange would get any routing income from\nthis? The exchange is the receiver of a payment of BTC on one leg and the\nsender of WJT on another. I'd expect the exchange would gain profit from\nspreads rather than fees in these protocols.\n\nLloyd\n\n\\n\n\nOn Sat, Jan 5, 2019 at 6:01 PM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning David,\n>\n> What happens if the exchange node only sends its preimage towards the\n> payer and not towards the payee?\n>\n> If the payer and payee do not coordinate, then it becomes possible for the\n> exchange node to take the funds without the payee gaining the ability to\n> claim the payment.\n> This might be used by a node to take proofs of payment without paying, by\n> simulating the payer and exchange nodes.\n> This may be important if the proof of payment is valuable, such as, the\n> mentioned offline Lightning vending machines, or if the preimage is the\n> decryption key for valuable data (e.g. ransomware; now the ransomware\n> author may find it is scammed off their potential earnings).\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, January 5, 2019 5:05 AM, David A. Harding <dave at dtrt.org>\n> wrote:\n>\n> > On Thu, Dec 27, 2018 at 05:43:51AM +0000, ZmnSCPxj via Lightning-dev\n> wrote:\n> >\n> > > We can try to mitigate this, but the solutions below all have\n> significant drawbacks.\n> >\n> > An alternative is to give the person making the exchange the ability to\n> > cancel the payment if they think the exchange rate has changed\n> > unfavorably for them. I think you could do that by adding an extra\n> > hashlock to the HTLC that's controlled by the exchanger. For example,\n> > here's what we'd expect a cross-asset path to look like:\n> >\n> > Alice Bob Charlie Dan Eliza\n> > 1.3 mBTC -> 1.3 mBTC -> 1.2 mBTC\n> >\n> >                             1.2 mWJT -> 1.1 mWJT -> 1.0 mWJT\n> >\n> >\n> > Instead of Alice's node just locally constructing this path and trying\n> > to pay it like normal, she first sends a special probe to Charlie\n> > requesting a new hash for which only he knows the preimage. With this\n> > hash plus the hash Alice received from Eliza, Alice sends a payment that\n> > requires both hashlocks be unlocked before anyone can claim the payment.\n> >\n> > 1.  When this payment reaches the exchanger, Charlie, he checks that the\n> >     payment includes a hashlock he controls before routing the payment\n> on to\n> >     a different asset.\n> >\n> > 2.  When the payment reaches receiver Eliza's node, she releases her\n> >     PreImage (PI0) back along the path.\n> >\n> > 3.  When Eliza's preimage reaches exchanger Charlie's node, he releases\n> >     his preimage (PI1) in both directions along the path and continues\n> >     forwarding PI0 backwards. Eventually everyone receives both preimages\n> >     through the usual offchain or onchain mechanisms.\n> >\n> >     Alice Bob Charlie Dan Eliza\n> >     PI0 <- PI0 <- PI0 <- PI0 <- PI0 (start here)\n> >     PI1 <- PI1 <- PI1 -> PI1 -> PI1\n> >\n> >\n> > However, if the exchange rate changes too much for Charlie's comfort\n> > before both preimages have been released, Charlie can unilaterally\n> > decide to cancel the payment by simply not releasing his preimage.\n> >\n> > Note that by making the payment contingent on the approval of the\n> > exchanger, the ability to create an underhanded call option is\n> > transferred to the exchanger. However, this may be less concerning\n> > because the exchanger can only keep this option open by refusing to\n> > immediately claim the routing fees.\n> >\n> > For example, our exchanger Charlie is being offered 0.1 mBTC to route\n> > the payment (a made up number). If he can route 100 such payments in a\n> > day (another made up number), he can earn 10.0 mBTC from routing. By\n> > comparison, if he delays a payment of 1.2 mBTC, he'd need to expect the\n> > exchange rate to change by an order of magnitude within a day to earn\n> > the same amount. In ZmnSCPxj's terminology, the option is now no longer\n> > free because Charlie must decide between potential routing income and\n> > potential option income. Whether or not exchangers play the option game\n> > will therefore likely be based on the amount of honest routing income\n> > they can earn relative to the exchange rate volatility (and also on how\n> > good nodes get at tracking reliable routes).\n> >\n> > This idea certainly complicates the current protocol (both routing and\n> > transaction construction), but maybe there are simplifications\n> > available.\n> >\n> > -Dave\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190105/3dc2a953/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-05T18:55:17",
                "message_text_only": "Good morning Lloyd,\n> > I agree.\n> > When I was developing American Call Options on top of onchain HTLCs, I came up with a similar construction for ensuring that the premium is paid before the HTLCs setting up the option appear onchain.\n>\n> I would be interested to see how your construction worked.\u00a0You can actually modify the construction I gave before (in the gist) to create a fair option too. You just change it so the asset `C` is paid on both branches of the HTLC. This changes `C` from collateral to a premium. This sounds a bit different to what you describe as the premium isn't paid before the HTLCs go onto the chain.\n>\n> The only other proposal for options I've seen is:\u00a0\u00a0https://www.ics.uci.edu/~jamesal1/Swaptions.pdf. I could be missing something, but this seems to give Alice a free option on an option in this one. The premium payment has the option problem: Bob cannot cancel his offer of an option but Alice can take her time to accept it.\n\nI have not read the swaptions yet, but in any case, for the onchain American Call Option, I came up with the below, which I call roughly \"pay for contract\".\n\nIn this, construction, we promise to publish a contract, but only if we are paid to do such a publication.\n\nThis construction does not work well as a solution to the problem on Lightning (as it essentially resolves to \"failed routes cost the payer money\", a bad UX for payments in a network with partial information of channel status), but may be of interest otherwise.\n\nSuppose the below situation:\n\nI am selling you a contract that crosses multiple cryptocurrency systems (blockchains or state update channels or etc).\nYou will be willing to pay me for such a contract, contingent on the contract being able to appear completely on all cryptocurrency systems involved.\n\nSo we need to make the below UTXOs appear on the BTC and WJT blockchains:\n\n1.  BTC: `P` BTC, HTLC: hashlock me and preimage of hash, timelock you at time `E`+1.\n2.  WJT: 1 WJT, HTLC: hashlock you and preimage of hash, timelock me at time `E`.\n\nThe above is an American Call Option as before, with you having the option to claim 1 WJT for `P` BTC at any time on or before `E`.\n\nThe setup is that we first have a little ritual.\n\n1.  I generate a *different* preimage and hash.  Let us differentiate it from the option preimage by calling this the contract-setup preimage and hash.\n2.  I prepare on the WJT blockchain the UTXO: 1 WJT, HTLC: hashlock (you+me) and preimage of contract-setup hash, timelock me at time `S`+1.  The time `S` is the contract setup time, which should be nearer (much nearer) than time `E`.\n3.  On top of that, I create a transaction spending that UTXO on WJT, and outputting: 1 WJT, HTLC: hashlock you and preimage of option hash, timelock me at time `E`.\n    This is one part of the American Call Option.\n    I sign this transaction and give it to you.\n    Notice, that this transaction cannot be confirmed: it is lacking your signature and the contract-setup preimage.\n4.  You prepare on the BTC blockchain the UTXO: `P`+`C` BTC, HTLC: hashlock (you+me) and preimage of contract-setup hash, timelock you at time `S`.\n    `C` is the premium on the American Call Option.\n5.  On top of that, you create a transaction spending that UTXO on BTC, with two outputs:\n    1.  `C` BTC, pubkey: me.\n        This is my premium.\n    2.  `P` BTC, HTLC: hashlock me and preimage of option hash, timelock you at time `E`+1.\n    You sign this transaction and give it to me; again the transaction is incomplete as it lacks my signature and the contract-setup preimage.\n6.  I take your transaction and sign it, then add the contract-setup preimage that I know, and publish it on the BTC blockchain.\n    The BTC side of the American Call Option has now been set up.\n    I can now use my premium immediately, and can take the BTC if you ever publish the option preimage.\n7.  You take my transaction and sign it.\n    Since I published the contract-setup preimage in the above step, you can get that preimage and attach it to the WJT transaction and publish it on the WJT blockchain.\n    This now causes the WJT side of the American Call Option to become set up.\n\nIf either of us stalls before step 6, or if I stall at step 6, then our assets revert back to us at time `S` or `S`+1.\nI assume we can safely set `S` to something within a few hours or less.\nIf you stall at step 7 then you have already paid the premium to me at this point and have no incentive to just not continue the protocol, and at step 7 I can no longer stall the protocol since you will have everything to continue the setup of the American Call Option.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "David A. Harding",
                "date": "2019-01-05T16:31:02",
                "message_text_only": "On Sat, Jan 05, 2019 at 07:01:18AM +0000, ZmnSCPxj wrote:\n> Good morning David,\n> \n> What happens if the exchange node only sends its preimage towards the\n> payer and not towards the payee?\n> \n> If the payer and payee do not coordinate, then it becomes possible for\n> the exchange node to take the funds without the payee gaining the\n> ability to claim the payment.\n\nIndeed, you are correct.  I had not taken that into account.  Thinking\nabout it from that perspective, there's no way to depend on proof that\nthe someone received something (e.g. a payment) without also allowing\nthe receiver to block payment by refusing to provide that proof.  That\ninvalidates this class of solutions.\n\nThanks,\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190105/6d4121cf/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-07T10:52:23",
                "message_text_only": "Good morning David and CJP,\n\nAlthough we have determined that the David solution and all classes of that solution are insufficient, it also triggered me to mentally compare the CJP solution to the David solution.\n\nDavid solution effectively makes the exchange node (OM in CJP terminology) also the RM in the route.\nHowever, with use of mere preimages and hashes, it is obvious that such a \"loop\" where the end payee (RM) is also an intermediate node, is foolish, as the end payee will simply claim the payment without letting the loop through.\nAnd since the payee (S in CJP terminology) is paid via the delta from its incoming to its outgoing HTLC on that loop, then if the RM is the OM then it is possible for the OM To simply steal the payment outright.\n\n(It is helpful to realize that payment routes pay not just the end payee, but all hops in the middle; thus the \"real\" target of the payment (the one who receives the bulk of the value) need not be at the *end* of the route)\n\nBut there is a way to safely loop through the end payee, and that is if the final payee has insufficient knowledge to perform the claim unless it lets the payment through via the loop.\nSuppose we can somehow make a route that requires two secrets: a secret known by the final payee (RM == OM) and a separate secret known by the \"actual\" payee (S).\n\nOne way is to use points and scalars, another is to require two hashes from F to OM to S, then a single hash from OM to RM (RM == OM).\nPoints and scalars are probably better since it obscures to intermediate hop nodes whether they are before S in a cross-asset payment or not.\n\nBelow I describe the solution using points and scalars, and also including decorrelation.\nIt should be trivial to convert it to two-hash form.\n\n1.  First, F contacts the OM (i.e. the exchange, who is also the RM) to acquire an exchange rate quotation.\n    The OM provides\n    1.  An exchange rate between BTC and WJT.\n    2.  An exchange fee.\n    3.  A one-time-use \"exchange rate point\".\n    4.  A signature of the exchange rate and fee, signed using the scalar of the exchange rate point.\n        This proves that the OM knows the scalar of the exchange rate point.\n2.  F creates a route from F to S via OM, and a route from S to OM.\n    The route from F to S should pay the desired amount to S, plus the routing fees and exchange fee for the S to OM route.\n3.  As is typical for decorrelation, for every hop (including itself as a hop), F generates a random scalar.\n    F sums up the decorrelation scalars of various parts of the total route:\n    1.  F to OM: `f_to_om_scalar`\n    2.  OM to S: `om_to_s_scalar`\n    3.  S to OM: `s_to_om_scalar`\n4.  F offers a payment to the first hop node (can be OM, can be an independent hop node on BTC side) for the point:\n\n        f_to_om_scalar * G + om_to_s_scalar * G + s_to_om_scalar * G + payment_point + exchange_rate_point\n\n5.  When the payment reaches OM from F, it gets paid if it is able to acquire the scalar corresponding to:\n\n        om_to_s_scalar * G + s_to_om_scalar * G + payment_point + exchange_rate_point\n\n6.  In addition, F adds to the OM onion hop packet the below information:\n    1.  `payment_point`\n    2.  `exchange_rate_point`\n    3.  The point sum of `(om_to_s_scalar + s_to_om_scalar) * G`\n    4.  A signature using the point `(om_to_s_scalar + s_to_om_scalar) * G` of the serialization of the `payment_point` and `exchange_rate_point`.\n7.  The OM verifies:\n    1.  That `exchange_rate_point` is a point corresponding to some exchange rate quotation it issued before.\n    2.  That the exchange rate is still economically viable for it.\n    3.  That the sum of the `payment_point`, `exchange_rate_point`, and `(om_to_s_scalar + s_to_om_scalar) * G` correspond to the point that OM will need to learn the scalar of.\n8.  The OM forwards the route (which is still opaque to it, thus cannot know S or F) subtracting its decorrelation scalar.\n9.  When the payment reaches S from OM, it gets paid if it is able to acquire the scalar corresponding to:\n\n        s_to_om_scalar * G + payment_point + exchange_rate_point\n\n10.  S then subtracts `payment_scalar` (which it should know, with `payment_point = payment_scalar * G`) and its decorrelation scalar, and forwards it to the next hop.\n     Note that S does not learn the identity of OM, and does not learn the exact `exchange_rate_point`.\n     Only F knows who both OM and S are.\n     This is appropriate is it is the one that sets up all the routes.\n11.  When the payment reaches OM from S, it gets paid if it is able to acquire the scalar corresponding to:\n\n        exchange_rate_point\n\n     When a payment terminates at OM, OM checks if it is also one of its exchange rate quotations.\n     If the exchange rate is still economically viable for it, then it claims the payment.\n     If not, it fails the payment, probably with an error for F that the exchange rate has gone out of synch and it should reacquire a new exchange rate.\n\nNote that the OM cannot be fooled.\nSuppose F == S.\n\n1.  Suppose S does not forward, until a time when it is economically viable for F == S to perform the American Call Option.\n    If it is economically viable for F == S to do so, it is economically non-viable for OM to release its exchange rate point and it will simply fail with \"exchange rate deviated too far from quotation\".\n2.  Suppose S forwards immediately and learns the exchange rate scalar, then waits for the American Call Option.\n    The payment S forwarded to learn the exchange rate scalar is the premium on the American Call Option it has set up.\n    Thus the American Call Option is no longer premium-free and this attack vector disappears.\n    The OM would willingly take the premium which it can now use immediately.\n\nNow what are the advantages of this approach?\n\n1.  The OM never learns exactly who F or S are, and thus is not able to censor their transaction.\n2.  There is no RM who is a trusted third party.\n    There is only an OM who F hires for exchange, and S who F wants to pay in order to acquire some scalar proof-of-payment.\n    Thus, we can ignore all arguments for trusted third parties.\n3.  Routing failures due to dead channels or insufficient capacity do not cost anything to F, if F != S or are acting as separate entities.\n4.  It's still possible to set up American Call Options, but they now have an unavoidable premium.\n    Indeed, the \"exchange rate fee\" can be a formula based on the value of one of the assets, and the CLTV the exchange will incur, rather than some fixed value.\n    In short, the exchange offers American Call Options by default, which can be abused in order to make them into a payment from one entity to another, rather than the reverse (the exchange offers a payment route, which can be abused in order to make it into an American Call Option).\n\nThus, we should really move to points and scalars \"soon\", because decorrelation and better proofs-of-payment.\nWe must be brave and face the three `OP_CODESEPARATOR`s needed for this.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, January 6, 2019 12:31 AM, David A. Harding <dave at dtrt.org> wrote:\n\n> On Sat, Jan 05, 2019 at 07:01:18AM +0000, ZmnSCPxj wrote:\n>\n> > Good morning David,\n> > What happens if the exchange node only sends its preimage towards the\n> > payer and not towards the payee?\n> > If the payer and payee do not coordinate, then it becomes possible for\n> > the exchange node to take the funds without the payee gaining the\n> > ability to claim the payment.\n>\n> Indeed, you are correct. I had not taken that into account. Thinking\n> about it from that perspective, there's no way to depend on proof that\n> the someone received something (e.g. a payment) without also allowing\n> the receiver to block payment by refusing to provide that proof. That\n> invalidates this class of solutions.\n>\n> Thanks,\n>\n> -Dave"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-07T12:11:14",
                "message_text_only": "Good morning all,\n\n> 6.  In addition, F adds to the OM onion hop packet the below information:\n>     1.  `payment_point`\n>     2.  `exchange_rate_point`\n>     3.  The point sum of `(om_to_s_scalar + s_to_om_scalar) * G`\n>     4.  A signature using the point `(om_to_s_scalar + s_to_om_scalar) * G` of the serialization of the `payment_point` and `exchange_rate_point`.\n> 7.  The OM verifies:\n>     1.  That `exchange_rate_point` is a point corresponding to some exchange rate quotation it issued before.\n>     2.  That the exchange rate is still economically viable for it.\n>     3.  That the sum of the `payment_point`, `exchange_rate_point`, and `(om_to_s_scalar + s_to_om_scalar) * G` correspond to the point that OM will need to learn the scalar of.\n\nOf course, this is susceptible to a key cancellation attack; `payment_point` may be `secret * G - exchange_rate_point`, which removes the exchange from controlling when the payment completes.\n\nA simple, naive mitigation would be for invoices to include a signature using the `payment_point` of an empty string.\nThen this signature also needs to be provided to OM in order to assure it that `payment_point` does not cancel its point.\n\nThis is a simple proof-by-example that you should not trust your money to cryptosystems created by random people on the Internet.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2019-01-08T14:26:06",
                "message_text_only": "ZmnSCPxj,\n\n\nWithout reading your proposed solution, I don't understand the problem\nyou describe here:\n\n> David solution effectively makes the exchange node (OM in CJP terminology) also the RM in the route.\n> However, with use of mere preimages and hashes, it is obvious that such a \"loop\" where the end payee (RM) is also an intermediate node, is foolish, as the end payee will simply claim the payment without letting the loop through.\n> And since the payee (S in CJP terminology) is paid via the delta from its incoming to its outgoing HTLC on that loop, then if the RM is the OM then it is possible for the OM To simply steal the payment outright.\n>\n> (It is helpful to realize that payment routes pay not just the end payee, but all hops in the middle; thus the \"real\" target of the payment (the one who receives the bulk of the value) need not be at the *end* of the route)\n\n\nAll hops on the route are linked together the same way as hops in a\nregular Lightning payment. An intermediate node who is also the end\npayee, and therefore knows the preimage, can indeed shortcut the payment\nby accepting the payment on the intermediate node instead of forwarding\nit; this is true for all Lightning payments [*].\n\n\nI think the scenario where \"the bulk of the value\" ends up at one or\nmore intermediate nodes should not typically apply here. With a\nsufficiently low spread and fees, the bulk of the value should be\nroughly the same on each hop. The only thing that might be stolen is in\nthose fees and exchange rate differences.\n\n\nBy design, OT will pay the fees, so its outgoing amount will be higher\nthan the incoming amount. RM will not want to exclude OT from its route.\nIf RM is OM, then RM cannot exclude OM from the route either.\nEffectively, you end up with a RM-OT-RM route, which is OK if RM is OM.\nMinimizing Lightning route length to minimize fees is not a bad thing.\n\n\nThere is a remaining issue though, that if RM is OM, then, obviously, RM\nand OM can cooperate to perform a delay attack on OT. I think this is\nacceptable, given that in section 4 of my paper[1] I already described\nsome countermeasures OT can take. I think the attack possibility is\nwider: if OT and OM are anonymous / pseudonymous toward each other, then\nRM can either be OM and attack OT, or it can be OT and attack OM. I\nargued in section 4 that OM is more vulnerable than OT, but luckily the\nassumptions to this argument do not apply anymore. OM knows the\nattacker: it is RM. RM can perform a single attack on OM, and after\nthat, OM will refuse incoming exchange transactions that are coordinated\nby RM.\n\n\nSo my proposal is not perfect, it does contain the trusted role RM, and\nparticipants have to be somewhat careful which RMs they do business\nwith. However, it does have the benefit of de-coupling the trusted role\nRM from the actual trading roles of OT and OM, so you only need to trust\na few parties and you can trade with lots of parties. Trading parties\ncan remain anonymous to RM, and they can hide from RM what second asset\nthey are trading, and to what exchange rate, so there's very little that\ncan be censored by RM.\n\n\nCJP\n\n\n[*] So it is a vulnerability for the idea where you anonymously donate\nto an intermediate node by giving it a huge fee. The vulnerability does\nnot apply if you are the final payee, since nobody else but the final\npayee can perform the attack. Other parties might control multiple nodes\non the route, but they only learn the preimage after HTLC acceptance on\nall hops.\n\n\n[1] https://bitonic.nl/public/slowdown_prevention.pdf"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-08T23:01:35",
                "message_text_only": "Good morning CJP,\n\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, January 8, 2019 10:26 PM, Corn\u00e9 Plooy <corne at bitonic.nl> wrote:\n\n> ZmnSCPxj,\n>\n> Without reading your proposed solution, I don't understand the problem\n> you describe here:\n>\n> > David solution effectively makes the exchange node (OM in CJP terminology) also the RM in the route.\n> > However, with use of mere preimages and hashes, it is obvious that such a \"loop\" where the end payee (RM) is also an intermediate node, is foolish, as the end payee will simply claim the payment without letting the loop through.\n> > And since the payee (S in CJP terminology) is paid via the delta from its incoming to its outgoing HTLC on that loop, then if the RM is the OM then it is possible for the OM To simply steal the payment outright.\n> > (It is helpful to realize that payment routes pay not just the end payee, but all hops in the middle; thus the \"real\" target of the payment (the one who receives the bulk of the value) need not be at the end of the route)\n\nThis is the problem with David solution.\nDavid solution requires that OM be the one that knows the preimage, and releases the preimage.\nThus, it serves as the equivalent to RM.\n\nHowever...\n\n>\n> All hops on the route are linked together the same way as hops in a\n> regular Lightning payment. An intermediate node who is also the end\n> payee, and therefore knows the preimage, can indeed shortcut the payment\n> by accepting the payment on the intermediate node instead of forwarding\n> it; this is true for all Lightning payments [].\n\nIndeed.\nThis is the problem with David solution.\n\n> I think the scenario where \"the bulk of the value\" ends up at one or\n> more intermediate nodes should not typically apply here. With a\n> sufficiently low spread and fees, the bulk of the value should be\n> roughly the same on each hop. The only thing that might be stolen is in\n> those fees and exchange rate differences.\n\nWhat I mean is that the transaction-payee S is paid, not by being the final payee in the route, but via the difference between its incoming and outgoing HTLCs.\nSo semantically S is the transaction payee, but in terms of route, RM is the final payee.\n\n> So my proposal is not perfect, it does contain the trusted role RM, and\n> participants have to be somewhat careful which RMs they do business\n> with. However, it does have the benefit of de-coupling the trusted role\n> RM from the actual trading roles of OT and OM, so you only need to trust\n> a few parties and you can trade with lots of parties.\n\nThere is another issue here.\n\nBy creating the role of RM, we enforce that American Call Options pay a premium.\nF can route via OM to S, and S needs to forward to RM in order to acquire the preimage.\nOnce S has acquired the preimage, however, it can stall, and the HTLCs formed are still an American Call Option equivalent.\nA price has been paid to acquire the preimage --- S had to forward value to RM to get the preimage.\nThis is equivalent to paying a premium.\nThis at least fixes the problem that OT no longer is capable of getting premium-free American Call Options.\n\nBut notice who the premium is paid *to*.\nIt is paid to RM.\nIt is not paid to OM, who is the one who loses if the American Call Option is exercised.\nThis is a rent paid by OM to RM.\n\nThis can lead to rent-seeking behavior from RM if RM != OM.\nFor instance, RM may acquire 8 random letters from /dev/random and start writing long articles about American Call Options on Lightning, as well as waxing lyrical about black swans and bleeder funds and cryptocurrency volatility, under those 8 random letters.\nThis encourages people to create American Call Options that pay a premium to RM while bleeding OM when the option is exercised.\n\nWhat is pernicious here is that, even if we somehow derive some way of verification of RM behavior, on Lightning RM can behave perfectly correctly and release the preimage immediately.\nBut S can still stall once it has paid the premium and acquired the preimage.\n\nThus, RM != OM cannot be safe due to rent-seeking by RM.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-08T05:11:23",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n> HTLCs as American Call Option, or, How Lightning Currently Cannot Work Across Assets, or, An Argument For Single-Asset Lightning Network\n\nInteresting.  FWIW, I believe that multi-asset LN will fail for a\nrelated, but different reason: to prevent long-lived spam payments we\nmay require proof that something went wrong (ie. channel unilateral\nclose tx).  That won't be valid if it's from a different network,\nresulting in the exchange point itself being penalized.  Thus they are\nvulnerable to such a DoS.\n\nCheers,\nRusty."
            },
            {
                "author": "Corn\u00e9 Plooy",
                "date": "2019-01-08T13:27:02",
                "message_text_only": "True, as soon as this measure gets implemented (which AFAIK is not the\ncase right now). However, the attack is not free.\n\n\nThe victim interfaces between two different Lightning networks, each\noperating a different asset, possibly on a different block chain (so\nthat proof of channel closuse on one side cannot be understood on the\nother side) or even using a completely different technology. The problem\nof the victim arises when an exchange transaction arrives from network\nA, the victim forwards it on network B, and then the transaction gets\nstalled. The victim can demand a proof that something went wrong on\nnetwork B, but cannot propagate that proof on network A. Since the\nvictim cannot propagate a valid proof, the victim will be penalized on\nnetwork A.\n\n\nMy point is: the victim can still demand a proof that something went\nwrong on network B. To stall the transaction, the attacker must be\ncontrolling the node on network B that is doing the stalling. The same\nanti-spam measure that penalizes the victim on network A *also*\npenalizes the attacking node on network B.\n\n\nThe penalties may not be the same: maybe on-chain fees are much lower on\nchain B than on chain A. Still, the anti-spam measure should somewhat\nreduce the attractiveness of this attack.\n\n\nCJP\n\n\nOn 08-01-19 06:11, Rusty Russell wrote:\n> ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n>> HTLCs as American Call Option, or, How Lightning Currently Cannot Work Across Assets, or, An Argument For Single-Asset Lightning Network\n> Interesting.  FWIW, I believe that multi-asset LN will fail for a\n> related, but different reason: to prevent long-lived spam payments we\n> may require proof that something went wrong (ie. channel unilateral\n> close tx).  That won't be valid if it's from a different network,\n> resulting in the exchange point itself being penalized.  Thus they are\n> vulnerable to such a DoS.\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-08T13:59:49",
                "message_text_only": "Good morning,\n\nIt may be helpful to remember that \"cross-asset\" need not mean \"cross-chain\"; for example, the RGB project strives to create assets committed on the Bitcoin blockchain, in such a way that it would be possible to put them into Lightning channels.\nThus this \"proof-of-not-my-fault\" apply to cross-asset swaps on the same blockchain?\nHow about same-asset swaps across blockchains, e.g. RSK to Liquid?\n\nOf course the most obvious way, to create a unique assets, involves creating a unique blockchain for it, but the argument applies regardless for a multi-asset blockchain.\n\n\nRegards,\nZmnSCPxj\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, January 8, 2019 9:27 PM, Corn\u00e9 Plooy via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> True, as soon as this measure gets implemented (which AFAIK is not the\n> case right now). However, the attack is not free.\n>\n> The victim interfaces between two different Lightning networks, each\n> operating a different asset, possibly on a different block chain (so\n> that proof of channel closuse on one side cannot be understood on the\n> other side) or even using a completely different technology. The problem\n> of the victim arises when an exchange transaction arrives from network\n> A, the victim forwards it on network B, and then the transaction gets\n> stalled. The victim can demand a proof that something went wrong on\n> network B, but cannot propagate that proof on network A. Since the\n> victim cannot propagate a valid proof, the victim will be penalized on\n> network A.\n>\n> My point is: the victim can still demand a proof that something went\n> wrong on network B. To stall the transaction, the attacker must be\n> controlling the node on network B that is doing the stalling. The same\n> anti-spam measure that penalizes the victim on network A also\n> penalizes the attacking node on network B.\n>\n> The penalties may not be the same: maybe on-chain fees are much lower on\n> chain B than on chain A. Still, the anti-spam measure should somewhat\n> reduce the attractiveness of this attack.\n>\n> CJP\n>\n> On 08-01-19 06:11, Rusty Russell wrote:\n>\n> > ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org writes:\n> >\n> > > HTLCs as American Call Option, or, How Lightning Currently Cannot Work Across Assets, or, An Argument For Single-Asset Lightning Network\n> > > Interesting. FWIW, I believe that multi-asset LN will fail for a\n> > > related, but different reason: to prevent long-lived spam payments we\n> > > may require proof that something went wrong (ie. channel unilateral\n> > > close tx). That won't be valid if it's from a different network,\n> > > resulting in the exchange point itself being penalized. Thus they are\n> > > vulnerable to such a DoS.\n> >\n> > Cheers,\n> > Rusty.\n> >\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "An Argument For Single-Asset Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Lawrence Deacon",
                "Corn\u00e9 Plooy",
                "David A. Harding",
                "CJP",
                "Rusty Russell",
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 24,
            "total_messages_chars_count": 85763
        }
    },
    {
        "title": "[Lightning-dev] visual identification of payee node id",
        "thread_messages": [
            {
                "author": "Maximillian George",
                "date": "2019-01-02T10:31:37",
                "message_text_only": "Why not a confirmation phrase of a few words? This should be easier to implement and fit into a pre-existing design programme. Given a pool of enough words this would surely be as reliable as an identicon, no?\n\nBest regards,\nMax\n\nOn 29 Dec 2018, 17:23 +0100, William Casarin <jb55 at jb55.com>, wrote:\n> Pavol Rusnak via Lightning-dev <lightning-dev at lists.linuxfoundation.org\n> writes:\n>\n> > Hi all!\n> >\n> > Currently, when I perform a payment via QR code, I usually check the\n> > payee node id (public key) in the send dialog. However, this is a rather\n> > long hex value, so for example Eclair app shows just the beginning and\n> > the end of the value.\n> >\n> > Idea: Can we show an identicon (for example https://jdenticon.com/) of\n> > payee node id (= public key) next to the QR code, so user can visually\n> > quickly check whether the recipient is correct?\n>\n> I think it would be interesting if someone came up with a visual hashing\n> algorithm, where small changes in the inputs had uniformly random visual\n> outputs. I was testing jdenticon with my node id:\n>\n> 03f3c108ccd536b8526841f0a5c58212bb9e6584a1eb493080e7c1cc34f82dad71\n>\n> I was surprised to see that small changes to the first digit didn't\n> change the visual output at all. Whether or not this is a useful\n> property in this use case, it's something to keep in mind.\n>\n> Cheers,\n> Will\n>\n> --\n> https://jb55.com\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190102/0b77885c/attachment.html>"
            },
            {
                "author": "Eugene",
                "date": "2019-01-02T13:09:33",
                "message_text_only": "Hi,\n\nhow about using of Chernoff Faces to identify node\u2019s public key? Since humans are best fit to recognize small changes in faces and to remember them.\n\nTo achieve avalanche effect from changing a private key to produce much different face, one can just plug node\u2019s public key into a cryptographic hash function and then plug a result into Chernoff Face generator, thus making  a public key change very easy to notice.\n\n\u0412\u043a\u043b \u0432\u0441, \u0434\u0435\u043a. 23, 2018 \u0432 21:49, Pavol Rusnak via Lightning-dev <lightning-dev at lists.linuxfoundation.org> \u043d\u0430\u043f\u0438\u0441\u0430\u043b(\u0430):\n\n> Hi all!\n>\n> Currently, when I perform a payment via QR code, I usually check the\n> payee node id (public key) in the send dialog. However, this is a rather\n> long hex value, so for example Eclair app shows just the beginning and\n> the end of the value.\n>\n> Idea: Can we show an identicon (for example https://jdenticon.com/) of\n> payee node id (= public key) next to the QR code, so user can visually\n> quickly check whether the recipient is correct?\n>\n> We'd need to add this to UI of all Lightning user-facing wallets to make\n> sense, though.\n>\n> --\n> Best Regards / S pozdravom,\n>\n> Pavol \"stick\" Rusnak\n> CTO, SatoshiLabs\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190102/628c7c2e/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-02T13:16:08",
                "message_text_only": "Good morning Eugene,\n\n>\n> how about using of Chernoff Faces to identify node\u2019s public key? Since humans are best fit to recognize small changes in faces and to remember them.\u00a0\n\nWhy do humans have this circuitry?\nSuch strange objects...\nOne could wonder about sentients without such circuitry.\nThey would not be served well by this.\n(Notice the use of \"they\" here. I am not such a sentient since I am human. Thus, the use of \"they\" in the above setence.)\n\nA side effect of this would be that humans would obsessively reroll their pubkey until they acquire a face they like.\nThis will be a source of much amusement and so on.\nFor this reason alone, I highly approve this suggestion.\n\nRegards,\nZmnSCPxj\n\n>\n> To achieve avalanche effect from changing a private key to produce much different face, one can just plug node\u2019s public key into a cryptographic hash function and then plug a result into Chernoff Face generator, thus making \u00a0a public key change very easy to notice.\n>\n> \u0412\u043a\u043b \u0432\u0441, \u0434\u0435\u043a. 23, 2018 \u0432 21:49, Pavol Rusnak via Lightning-dev <lightning-dev at lists.linuxfoundation.org> \u043d\u0430\u043f\u0438\u0441\u0430\u043b(\u0430):\n>\n> > Hi all!\n> >\n> > Currently, when I perform a payment via QR code, I usually check the\n> > payee node id (public key) in the send dialog. However, this is a rather\n> > long hex value, so for example Eclair app shows just the beginning and\n> > the end of the value.\n> >\n> > Idea: Can we show an identicon (for example https://jdenticon.com/) of\n> > payee node id (= public key) next to the QR code, so user can visually\n> > quickly check whether the recipient is correct?\n> >\n> > We'd need to add this to UI of all Lightning user-facing wallets to make\n> > sense, though.\n> >\n> > --\n> > Best Regards / S pozdravom,\n> >\n> > Pavol \"stick\" Rusnak\n> > CTO, SatoshiLabs\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "visual identification of payee node id",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Maximillian George",
                "ZmnSCPxj",
                "Eugene"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5264
        }
    },
    {
        "title": "[Lightning-dev] Quick analysis of channel_update data",
        "thread_messages": [
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-02T15:47:06",
                "message_text_only": "Hello All, and Happy New Year!\n\nTo understand why there is a steady stream of channel updates, even\nwhen fee parameters don't seem to actually change, I made hourly\nbackups of the routing table of one of our nodes, and compared these\nrouting tables to see what exactly was being modified.\n\nIt turns out that:\n- there are a lot of disable/enable/disable etc\u2026. updates which are\njust sent when a channel is disabled then enabled again (when nodes go\noffline for example ?). This can happen\nthere are also a lot of updates that don\u2019t change anything (just a new\ntimestamp and signatures but otherwise same info), up to several times\na day for the same channel id\n\nIn both cases we end up syncing info that we already have.\nI don\u2019t know yet how best to use this when syncing routing tables, but\nI thought it was worth sharing anyway. A basic checksum that does not\ncover all fields, but only fees and HTLC min/max values could probably\nbe used to improve routing table sync ?\n\nCheers,\n\nFabrice"
            },
            {
                "author": "Christian Decker",
                "date": "2019-01-02T17:26:07",
                "message_text_only": "Hi Fabrice,\n\nhappy new year to you too :-)\n\nThanks for taking the time to collect that information. It's very much\nin line with what we were expecting in that most of the updates come\nfrom flapping channels. Your second observation that some updates only\nchange the timestamp is likely due to the staggered broadcast merging\nmultiple updates, e.g., one disabling and one enabling the channel, that\nare sent very close to each other. This is the very reason we introduced\nthe staggering back in the days, as it limits the maximum rate of\nupdates a single node may produce for each of its channels.\n\nIn the second case we can probably get away with not forwarding the\nupdate, but updating the timestamp and signature for the old\n`channel_update` locally, so that we don't then flap back to an older\none should we get that in a roundabout way. That's purely a local\ndecision and does not warrant a spec change imho.\n\nFor the ones that flap with a period that is long enough for the\ndisabling and enabling updates being flushed, we are presented with a\ntradeoff. IIRC we (c-lightning) currently hold back disabling\n`channel_update`s until someone actually attempts to use the channel at\nwhich point we fail the HTLC and send out the stashed `channel_update`\nthus reducing the publicly visible flapping. For the enabling we can't\ndo that, but we could think about a local policy on how much to delay a\n`channel_update` depending on the past stability of that peer. Again\nthis is local policy and doesn't warrant a spec change.\n\nI think we should probably try out some policies related to when to send\n`channel_update`s and how to hide redundant updates, and then we can see\nwhich ones work best :-)\n\nCheers,\nChristian\n\nFabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> Hello All, and Happy New Year!\n>\n> To understand why there is a steady stream of channel updates, even\n> when fee parameters don't seem to actually change, I made hourly\n> backups of the routing table of one of our nodes, and compared these\n> routing tables to see what exactly was being modified.\n>\n> It turns out that:\n> - there are a lot of disable/enable/disable etc\u2026. updates which are\n> just sent when a channel is disabled then enabled again (when nodes go\n> offline for example ?). This can happen\n> there are also a lot of updates that don\u2019t change anything (just a new\n> timestamp and signatures but otherwise same info), up to several times\n> a day for the same channel id\n>\n> In both cases we end up syncing info that we already have.\n> I don\u2019t know yet how best to use this when syncing routing tables, but\n> I thought it was worth sharing anyway. A basic checksum that does not\n> cover all fields, but only fees and HTLC min/max values could probably\n> be used to improve routing table sync ?\n>\n> Cheers,\n>\n> Fabrice\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-02T19:46:42",
                "message_text_only": "On Wed, 2 Jan 2019 at 18:26, Christian Decker\n<decker.christian at gmail.com> wrote:\n>\n> For the ones that flap with a period that is long enough for the\n> disabling and enabling updates being flushed, we are presented with a\n> tradeoff. IIRC we (c-lightning) currently hold back disabling\n> `channel_update`s until someone actually attempts to use the channel at\n> which point we fail the HTLC and send out the stashed `channel_update`\n> thus reducing the publicly visible flapping. For the enabling we can't\n> do that, but we could think about a local policy on how much to delay a\n> `channel_update` depending on the past stability of that peer. Again\n> this is local policy and doesn't warrant a spec change.\n>\n> I think we should probably try out some policies related to when to send\n> `channel_update`s and how to hide redundant updates, and then we can see\n> which ones work best :-)\n>\nYes, I haven't looked at how to handle this with local policies. My\nhypothesis is that when you're syncing a routing table that is say one\nday old, you end up querying and downloading a lot of information that\nyou already have, and that adding a basic checksum to our channel\nqueries may greatly improve this. Of course this would be much more\nactionable with stats and hard numbers which I'll provide ASAP.\n\nCheers,\n\nFabrice"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-03T22:52:15",
                "message_text_only": "Follow-up: here's more detailed info on the data I collected and\npotential savings we could achieve:\n\nI made hourly routing table backups for 12 days, and collected routing\ninformation for 17 000 channel ids.\n\nThere are 130 000 different channel updates :on average each channel\nhas been updated 8 times. Here, \u201cdifferent\u201d means that at least the\ntimestamp has changed, and a node would have queried this channel\nupdate during its syncing process.\n\nBut only 18 000 pairs of channel updates carry actual fee and/or HTLC\nvalue change. 85% of the time, we just queried information that we\nalready had!\n\nAdding a basic checksum (4 bytes for example) that covers fees and\nHTLC min/max value to our channel range queries would be a significant\nimprovement and I will add this the open BOLT 1.1 proposal to extend\nqueries with timestamps.\n\nI also think that such a checksum could also be used\n- in \u201cinventory\u201d based gossip messages\n- in set reconciliation schemes: we could reconcile [channel id |\ntimestamp | checksum] first\n\nCheers,\n\nFabrice"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-04T03:43:14",
                "message_text_only": "Good morning,\n\n> -   in set reconciliation schemes: we could reconcile [channel id |\n>     timestamp | checksum] first\n\nPerhaps I misunderstand how set reconciliation works, but --- if timestamp is changed while checksum is not, then it would still be seen as a set difference and still require further communication rounds to discover that the channel parameters have not actually changed.\n\nPerhaps it is better to reconcile [channel_id | checksum] instead, and if there is a different set of channel parameters, share the set difference and sort out which timestamp is later at that point.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-04T08:58:17",
                "message_text_only": "On Fri, 4 Jan 2019 at 04:43, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> > -   in set reconciliation schemes: we could reconcile [channel id |\n> >     timestamp | checksum] first\n>\n> Perhaps I misunderstand how set reconciliation works, but --- if timestamp is changed while checksum is not, then it would still be seen as a set difference and still require further communication rounds to discover that the channel parameters have not actually changed.\n>\n> Perhaps it is better to reconcile [channel_id | checksum] instead, and if there is a different set of channel parameters, share the set difference and sort out which timestamp is later at that point.\n\nAh yes of course, the `timestamp` should not be included.\n\nCheers,\nFabrice"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-08T05:23:10",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> Follow-up: here's more detailed info on the data I collected and\n> potential savings we could achieve:\n>\n> I made hourly routing table backups for 12 days, and collected routing\n> information for 17 000 channel ids.\n>\n> There are 130 000 different channel updates :on average each channel\n> has been updated 8 times. Here, \u201cdifferent\u201d means that at least the\n> timestamp has changed, and a node would have queried this channel\n> update during its syncing process.\n\nSide note: some implementations are also sending out updates with the\n*same* timestamp.  This is not allowed...\n\n> But only 18 000 pairs of channel updates carry actual fee and/or HTLC\n> value change. 85% of the time, we just queried information that we\n> already had!\n\nNote that this can happen in two legitimate cases:\n1. The weekly refresh of channel_update.\n2. A node updated too fast (A->B->A) and the ->A update caught up with the\n   ->B update.\n \nFortunately, this seems fairly easy to handle: discard the newer\nduplicate (unless > 1 week old).  For future more advanced\nreconstruction schemes (eg. INV or minisketch), we could remember the\nlatest timestamp of the duplicate, so we can avoid requesting it again.\n\n> Adding a basic checksum (4 bytes for example) that covers fees and\n> HTLC min/max value to our channel range queries would be a significant\n> improvement and I will add this the open BOLT 1.1 proposal to extend\n> queries with timestamps.\n>\n> I also think that such a checksum could also be used\n> - in \u201cinventory\u201d based gossip messages\n> - in set reconciliation schemes: we could reconcile [channel id |\n> timestamp | checksum] first\n\nI think this is overkill?\n\nThanks,\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2019-01-08T15:15:04",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n>> But only 18 000 pairs of channel updates carry actual fee and/or HTLC\n>> value change. 85% of the time, we just queried information that we\n>> already had!\n>\n> Note that this can happen in two legitimate cases:\n> 1. The weekly refresh of channel_update.\n> 2. A node updated too fast (A->B->A) and the ->A update caught up with the\n>    ->B update.\n>  \n> Fortunately, this seems fairly easy to handle: discard the newer\n> duplicate (unless > 1 week old).  For future more advanced\n> reconstruction schemes (eg. INV or minisketch), we could remember the\n> latest timestamp of the duplicate, so we can avoid requesting it again.\n\nUnfortunately this assumes that you have a single update partner, and\nstill results in flaps, and might even result in a stuck state for some\nchannels.\n\nAssume that we have a network in which a node D receives the updates\nfrom a node A through two or more separate paths:\n\nA --- B --- D\n \\--- C ---/\n\nAnd let's assume that some channel of A (c_A) is flapping (not the ones\nto B and C). A will send out two updates, one disables and the other one\nre-enables c_A, otherwise they are identical (timestamp and signature\nare different as well of course). The flush interval in B is sufficient\nto see both updates before flushing, hence both updates get dropped and\nnothing apparently changed (D doesn't get told about anything from\nB). The flush interval of C triggers after getting the re-enable, and D\ngets the disabling update, followed by the enabling update once C's\nflush interval triggers again. Worse if the connection A-C gets severed\nbetween the updates, now C and D learned that the channel is disabled\nand will not get the re-enabling update since B has dropped that one\naltogether. If B now gets told by D about the disable, it'll also go\n\"ok, I'll disable it as well\", leaving the entire network believing that\nthe channel is disabled.\n\nThis is really hard to debug, since A has sent a re-enabling\nchannel_update, but everybody is stuck in the old state.\n\nAt least locally updating timestamp and signature for identical updates\nand then not broadcasting if they were the only changes would at least\nprevent the last issue of overriding a dropped state with an earlier\none, but it'd still leave C and D in an inconsistent state until we have\nsome sort of passive sync that compares routing tables and fixes these\nissues.\n\n>> Adding a basic checksum (4 bytes for example) that covers fees and\n>> HTLC min/max value to our channel range queries would be a significant\n>> improvement and I will add this the open BOLT 1.1 proposal to extend\n>> queries with timestamps.\n>>\n>> I also think that such a checksum could also be used\n>> - in \u201cinventory\u201d based gossip messages\n>> - in set reconciliation schemes: we could reconcile [channel id |\n>> timestamp | checksum] first\n>\n> I think this is overkill?\n\nI think all the bolted on things are pretty much overkill at this point,\nit is unlikely that we will get any consistency in our views of the\nrouting table, but that's actually not needed to route, and we should\nconsider this a best effort gossip protocol anyway. If the routing\nprotocol is too chatty, we should make efforts towards local policies at\nthe senders of the update to reduce the number of flapping updates, not\nbuild in-network deduplications. Maybe something like \"eager-disable\"\nand \"lazy-enable\" is what we should go for, in which disables are sent\nright away, and enables are put on an exponential backoff timeout (after\nall what use are flappy nodes for routing?).\n\nCheers,\nChristian"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-08T17:22:23",
                "message_text_only": "On Tue, 8 Jan 2019 at 17:11, Christian Decker\n<decker.christian at gmail.com> wrote:\n>\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n> > Fortunately, this seems fairly easy to handle: discard the newer\n> > duplicate (unless > 1 week old).  For future more advanced\n> > reconstruction schemes (eg. INV or minisketch), we could remember the\n> > latest timestamp of the duplicate, so we can avoid requesting it again.\n>\n> Unfortunately this assumes that you have a single update partner, and\n> still results in flaps, and might even result in a stuck state for some\n> channels.\n>\n> Assume that we have a network in which a node D receives the updates\n> from a node A through two or more separate paths:\n>\n> A --- B --- D\n>  \\--- C ---/\n>\n> And let's assume that some channel of A (c_A) is flapping (not the ones\n> to B and C). A will send out two updates, one disables and the other one\n> re-enables c_A, otherwise they are identical (timestamp and signature\n> are different as well of course). The flush interval in B is sufficient\n> to see both updates before flushing, hence both updates get dropped and\n> nothing apparently changed (D doesn't get told about anything from\n> B). The flush interval of C triggers after getting the re-enable, and D\n> gets the disabling update, followed by the enabling update once C's\n> flush interval triggers again. Worse if the connection A-C gets severed\n> between the updates, now C and D learned that the channel is disabled\n> and will not get the re-enabling update since B has dropped that one\n> altogether. If B now gets told by D about the disable, it'll also go\n> \"ok, I'll disable it as well\", leaving the entire network believing that\n> the channel is disabled.\n>\n> This is really hard to debug, since A has sent a re-enabling\n> channel_update, but everybody is stuck in the old state.\n\nI think there may even be a simpler case where not replacing updates\nwill result in nodes not knowing that a channel has been re-enabled:\nsuppose you got 3 updates U1, U2, U3 for the same channel, U2 disables\nit, U3 enables it again and is the same as U1. If you discard it and\njust keep U1, and your peer has U2, how will you tell them that the\nchannel has been enabled again ? Unless \"discard\" here means keep the\nupdate but don't broadcast it ?\n\n\n> At least locally updating timestamp and signature for identical updates\n> and then not broadcasting if they were the only changes would at least\n> prevent the last issue of overriding a dropped state with an earlier\n> one, but it'd still leave C and D in an inconsistent state until we have\n> some sort of passive sync that compares routing tables and fixes these\n> issues.\n\nBut then there's a risk that nodes would discard channels as stale\nbecause they don't get new updates when they reconnect.\n\n> I think all the bolted on things are pretty much overkill at this point,\n> it is unlikely that we will get any consistency in our views of the\n> routing table, but that's actually not needed to route, and we should\n> consider this a best effort gossip protocol anyway. If the routing\n> protocol is too chatty, we should make efforts towards local policies at\n> the senders of the update to reduce the number of flapping updates, not\n> build in-network deduplications. Maybe something like \"eager-disable\"\n> and \"lazy-enable\" is what we should go for, in which disables are sent\n> right away, and enables are put on an exponential backoff timeout (after\n> all what use are flappy nodes for routing?).\n\nYes there are probably heuristics that would help reducing gossip\ntraffic, and I see your point but I was thinking about doing the\nopposite: \"eager-enable\" and \"lazy-disable\", because from a sender's\np.o.v trying to use a disabled channel is better than ignoring an\nenabled channel.\n\nCheers,\nFabrice"
            },
            {
                "author": "Christian Decker",
                "date": "2019-01-08T21:28:43",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n\n> I think there may even be a simpler case where not replacing updates\n> will result in nodes not knowing that a channel has been re-enabled:\n> suppose you got 3 updates U1, U2, U3 for the same channel, U2 disables\n> it, U3 enables it again and is the same as U1. If you discard it and\n> just keep U1, and your peer has U2, how will you tell them that the\n> channel has been enabled again ? Unless \"discard\" here means keep the\n> update but don't broadcast it ?\n\nExcellent point, that's a simpler example of how it could break down.\n\n>> I think all the bolted on things are pretty much overkill at this point,\n>> it is unlikely that we will get any consistency in our views of the\n>> routing table, but that's actually not needed to route, and we should\n>> consider this a best effort gossip protocol anyway. If the routing\n>> protocol is too chatty, we should make efforts towards local policies at\n>> the senders of the update to reduce the number of flapping updates, not\n>> build in-network deduplications. Maybe something like \"eager-disable\"\n>> and \"lazy-enable\" is what we should go for, in which disables are sent\n>> right away, and enables are put on an exponential backoff timeout (after\n>> all what use are flappy nodes for routing?).\n>\n> Yes there are probably heuristics that would help reducing gossip\n> traffic, and I see your point but I was thinking about doing the\n> opposite: \"eager-enable\" and \"lazy-disable\", because from a sender's\n> p.o.v trying to use a disabled channel is better than ignoring an\n> enabled channel.\n\nThat depends on what you are trying to optimize. Your solution keeps\nmore channels in enabled mode, potentially increasing failures due to\nchannels being unavailable. I was approaching it from the other side,\nsince failures are on the critical path in the payment flow, they'd\nresult in longer delays and many more retries, which I think is annoying\ntoo. It probably depends on the network structure, i.e., if the fanout\nfrom the endpoints is large, missing some channels shouldn't be a\nproblem, in which case the many failures delaying your payment weighs\nmore than not finding a route (eager-disable & lazy-enable). If on the\nother hand we are really relying on a huge number of flaky connections\nthen eager-enable & lazy-disable might get lucky and get the payment\nthrough. I'm hoping the network will have the latter structure, because\nwe'd have really unpredictable behavior anyway.\n\nWe'll probably gain more insight once we start probing the network. My\nexpectation is that today's network is a baseline, whose resiliency and\nredundancy will improve over time, hopefully swinging in favor of\ntrading off the speed gains over bare routability.\n\nCheers,\nChristian"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-01-08T22:07:02",
                "message_text_only": "I mentioned this on IRC, but note that the flapping is not just useless information to be discarded without consideration. An important use of routing data is providing a \"good\" subset to nodes like mobile clients that don't want all the bandwidth to stay fully in sync. A pretty good indicator of a useless channel would be flapping, given its probably not very reliable for routing.\n\nI'm somewhat unconvinced that we should be optimizing for as little bandwidth use as possible here, though wins that don't lose information are nice.\n\nMatt\n\n> On Jan 8, 2019, at 16:28, Christian Decker <decker.christian at gmail.com> wrote:\n> \n> Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> \n>> I think there may even be a simpler case where not replacing updates\n>> will result in nodes not knowing that a channel has been re-enabled:\n>> suppose you got 3 updates U1, U2, U3 for the same channel, U2 disables\n>> it, U3 enables it again and is the same as U1. If you discard it and\n>> just keep U1, and your peer has U2, how will you tell them that the\n>> channel has been enabled again ? Unless \"discard\" here means keep the\n>> update but don't broadcast it ?\n> \n> Excellent point, that's a simpler example of how it could break down.\n> \n>>> I think all the bolted on things are pretty much overkill at this point,\n>>> it is unlikely that we will get any consistency in our views of the\n>>> routing table, but that's actually not needed to route, and we should\n>>> consider this a best effort gossip protocol anyway. If the routing\n>>> protocol is too chatty, we should make efforts towards local policies at\n>>> the senders of the update to reduce the number of flapping updates, not\n>>> build in-network deduplications. Maybe something like \"eager-disable\"\n>>> and \"lazy-enable\" is what we should go for, in which disables are sent\n>>> right away, and enables are put on an exponential backoff timeout (after\n>>> all what use are flappy nodes for routing?).\n>> \n>> Yes there are probably heuristics that would help reducing gossip\n>> traffic, and I see your point but I was thinking about doing the\n>> opposite: \"eager-enable\" and \"lazy-disable\", because from a sender's\n>> p.o.v trying to use a disabled channel is better than ignoring an\n>> enabled channel.\n> \n> That depends on what you are trying to optimize. Your solution keeps\n> more channels in enabled mode, potentially increasing failures due to\n> channels being unavailable. I was approaching it from the other side,\n> since failures are on the critical path in the payment flow, they'd\n> result in longer delays and many more retries, which I think is annoying\n> too. It probably depends on the network structure, i.e., if the fanout\n> from the endpoints is large, missing some channels shouldn't be a\n> problem, in which case the many failures delaying your payment weighs\n> more than not finding a route (eager-disable & lazy-enable). If on the\n> other hand we are really relying on a huge number of flaky connections\n> then eager-enable & lazy-disable might get lucky and get the payment\n> through. I'm hoping the network will have the latter structure, because\n> we'd have really unpredictable behavior anyway.\n> \n> We'll probably gain more insight once we start probing the network. My\n> expectation is that today's network is a baseline, whose resiliency and\n> redundancy will improve over time, hopefully swinging in favor of\n> trading off the speed gains over bare routability.\n> \n> Cheers,\n> Christian\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-08T23:44:06",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> I think there may even be a simpler case where not replacing updates\n> will result in nodes not knowing that a channel has been re-enabled:\n> suppose you got 3 updates U1, U2, U3 for the same channel, U2 disables\n> it, U3 enables it again and is the same as U1. If you discard it and\n> just keep U1, and your peer has U2, how will you tell them that the\n> channel has been enabled again ? Unless \"discard\" here means keep the\n> update but don't broadcast it ?\n\nThis can only happen if you happen to lose connection to the peer(s)\nwhich sent U2 before it sends U3.\n\nAgain, this corner case penalizes flapping channels.  If we also\nratelimit our own enables to 1 per 120 seconds, you won't hit this case?\n\n> But then there's a risk that nodes would discard channels as stale\n> because they don't get new updates when they reconnect.\n\nYou need to accept redundant updates after 1 week, I think.\n\nCheers,\nRusty."
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-20T19:53:56",
                "message_text_only": "Additional info on channel_update traffic:\n\nComparing daily backups of routing tables over the last 2 weeks shows\nthat nearly all channels get at least a new update every day. This\nmeans that channel_update traffic is not primarily cause by nodes\npublishing new updates when channel are about to become stale:\notherwise we would see 1/14th of our channels getting a new update on\nthe first day, then another 1/14th on the second day and so on.This is\nconfirmed by comparing routing table backups over a single day: nearly\nall channels were updated, one average once, with an update that\nalmost always does not include new information.\n\nIt could be caused by \"flapping\" channels, probably because the hosts\nthat are hosting them are not reliable (as in is often offline).\n\nHeuristics can be used to improve traffic but it's orhtogonal to the\nproblem of improving our current sync protocol.\nAlso, these heuristics would probaly be used to close channels to\nunreliable nodes instead of filtering/delaying publishing updates for\nthem.\n\nFinally, this is not just obsessing over bandwidth (though bandwidth\nis a real issue for most mobile users). I'm also over obsessing over\nstartup time and payment UX :), because they do matter a lot for\nmobile users, and would like to push the current gossip design as far\nas it can go. I also think that we'll face the same issue when\ndesigning inventory messages for channel_update messages.\n\nCheers,\n\nFabrice\n\n\n\nOn Wed, 9 Jan 2019 at 00:44, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n> Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> > I think there may even be a simpler case where not replacing updates\n> > will result in nodes not knowing that a channel has been re-enabled:\n> > suppose you got 3 updates U1, U2, U3 for the same channel, U2 disables\n> > it, U3 enables it again and is the same as U1. If you discard it and\n> > just keep U1, and your peer has U2, how will you tell them that the\n> > channel has been enabled again ? Unless \"discard\" here means keep the\n> > update but don't broadcast it ?\n>\n> This can only happen if you happen to lose connection to the peer(s)\n> which sent U2 before it sends U3.\n>\n> Again, this corner case penalizes flapping channels.  If we also\n> ratelimit our own enables to 1 per 120 seconds, you won't hit this case?\n>\n> > But then there's a risk that nodes would discard channels as stale\n> > because they don't get new updates when they reconnect.\n>\n> You need to accept redundant updates after 1 week, I think.\n>\n> Cheers,\n> Rusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-08T23:38:12",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n> Assume that we have a network in which a node D receives the updates\n> from a node A through two or more separate paths:\n>\n> A --- B --- D\n>  \\--- C ---/\n>\n> And let's assume that some channel of A (c_A) is flapping (not the ones\n> to B and C). A will send out two updates, one disables and the other one\n> re-enables c_A, otherwise they are identical (timestamp and signature\n> are different as well of course).\n\n> The flush interval in B is sufficient\n> to see both updates before flushing, hence both updates get dropped and\n> nothing apparently changed (D doesn't get told about anything from\n> B). The flush interval of C triggers after getting the re-enable, and D\n> gets the disabling update, followed by the enabling update once C's\n> flush interval triggers again.\n\nYes, we save gossip from B->D, but not C->D.  That's OK.\n\nIn general we won't get coalescing if the DOWN/UP combo spans gossip\nflush.  If everyone is the same 60 second timers this will continue to\nhappen across the network AFAICT?  We should probably change our gossip\ntimer to 90 +/- 30 seconds which would (I think?) give more chance of\nflap suppression.\n\n> Worse if the connection A-C gets severed\n> between the updates, now C and D learned that the channel is disabled\n> and will not get the re-enabling update since B has dropped that one\n> altogether. If B now gets told by D about the disable, it'll also go\n> \"ok, I'll disable it as well\", leaving the entire network believing that\n> the channel is disabled.\n\nYou're right; B needs to remember the last timestamp of the update it\ndiscarded, and ignore ones prior.\n\nSo, in this (fairly obscure) scenario, the flapping channel gets\npenalized.  But network is happier, and this suppression is a nice local\npolicy.\n\n> If the routing\n> protocol is too chatty, we should make efforts towards local policies at\n> the senders of the update to reduce the number of flapping updates, not\n> build in-network deduplications. Maybe something like \"eager-disable\"\n> and \"lazy-enable\" is what we should go for, in which disables are sent\n> right away, and enables are put on an exponential backoff timeout (after\n> all what use are flappy nodes for routing?).\n\nWell, we lazy-disable because we assume it's still advertised as\navailable.  We eager-enable (iff we sent a disable) because we assume\nit's advertised as unavailable so we won't get traffic through it.\nThough we could set delay of 30 seconds on the enable, I think we're\nalready current best practice?\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Quick analysis of channel_update data",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Matt Corallo",
                "Fabrice Drouin",
                "Christian Decker",
                "Rusty Russell",
                "ZmnSCPxj"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 29238
        }
    },
    {
        "title": "[Lightning-dev] Reuse of payment_hash in lightning invoices",
        "thread_messages": [
            {
                "author": "Andrea RASPITZU",
                "date": "2019-01-03T12:40:16",
                "message_text_only": "Good morning list,\n\nI wanted to know your thoughts about the reuse of payment_hash in lightning\ninvoices, currently BOLT11 uses as example a donation invoice which seems\nto be \"permanent\" i.e the payment_hash isn't changing after having received\na donation.I believe the reuse of known payment_hash is a security issue\nbecause an intermediary node routing a donation for the second time already\nknows the preimage, thus it can decide to pull the htlc from downstream\nwithout actually forwarding it to upstream (can respond with a\nhtlc_fulfill). For example a malicious receiver can provide an invoice with\nassisted routes where among those he/she controls a node and that node\nwon't forward to the htlc but steal the funds instead (the preimage is\nknown to the intermediate node as well), thus it will be claimed that the\npayment hasn't been received. If the above is correct then there should be\nat least a warning in the spec regarding the reuse of payment_hash in\ninvoices.\n\nCheers, Andrea.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190103/34c9d848/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-03T13:13:47",
                "message_text_only": "Good morning Andrea,\n\n> For example a malicious receiver can provide an invoice with assisted routes where among those he/she controls a node and that node won't forward to the htlc but steal the funds instead (the preimage is known to the intermediate node as well), thus it will be claimed that the payment hasn't been received. If the above is correct then there should be at least a warning in the spec regarding the reuse of payment_hash in invoices.\n\nThe fact that ultimate payer has received the payment preimage is considered sufficient proof of payment.\nThus, in case of reuse, the fact that the ultimate payer has received the payment preimage is sufficient proof of payment, and whatever the receiver claims is to be ignored: the payment preimage in possession of the ultimate payee is considered the whole of the proof of payment.\n\n\n>a malicious receiver can provide an invoice with assisted routes where among those he/she controls a node and that node won't forward to the htlc but steal the funds instead\n\nThen the receiver has received it, not on the purported final node, but on another node it controls, and the fact that the ultimate payer has received the payment preimage is sufficient proof of that.\n\nObviously, if the receiver knows it does not control the entire Lightning Network, it should not reuse payment hashes, since intermediate nodes it does not control could claim the payment and give the proof-of-payment to the ultimate payer.\nThis can be clarified, but in the context of proofs, the attack you described is not possible, since the possession of the payment preimage is itself the entirety of the proof of the payment, regardless of what the receiver claims.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andrea RASPITZU",
                "date": "2019-01-03T15:35:01",
                "message_text_only": "Okay so the knowledge of a preimage for a certain payment_hash is the\nsufficient (and only) payment proof for the payer. But in any case the\nreuse of payment_hashes should be strongly discouraged, in the donations\nscenario 2 donors will send across the network a payment for the same\npreimage and if the routes overlap (as it's likely to happen getting close\nto the recipient) an intermediate routing node can effectively steal the\npayment from the recipient. Shouldn't we make this clear in BOLT11?\n\nCheers, Andrea.\n\n\n\nOn Thu, 3 Jan 2019 at 14:13, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Andrea,\n>\n> > For example a malicious receiver can provide an invoice with assisted\n> routes where among those he/she controls a node and that node won't forward\n> to the htlc but steal the funds instead (the preimage is known to the\n> intermediate node as well), thus it will be claimed that the payment hasn't\n> been received. If the above is correct then there should be at least a\n> warning in the spec regarding the reuse of payment_hash in invoices.\n>\n> The fact that ultimate payer has received the payment preimage is\n> considered sufficient proof of payment.\n> Thus, in case of reuse, the fact that the ultimate payer has received the\n> payment preimage is sufficient proof of payment, and whatever the receiver\n> claims is to be ignored: the payment preimage in possession of the ultimate\n> payee is considered the whole of the proof of payment.\n>\n>\n> >a malicious receiver can provide an invoice with assisted routes where\n> among those he/she controls a node and that node won't forward to the htlc\n> but steal the funds instead\n>\n> Then the receiver has received it, not on the purported final node, but on\n> another node it controls, and the fact that the ultimate payer has received\n> the payment preimage is sufficient proof of that.\n>\n> Obviously, if the receiver knows it does not control the entire Lightning\n> Network, it should not reuse payment hashes, since intermediate nodes it\n> does not control could claim the payment and give the proof-of-payment to\n> the ultimate payer.\n> This can be clarified, but in the context of proofs, the attack you\n> described is not possible, since the possession of the payment preimage is\n> itself the entirety of the proof of the payment, regardless of what the\n> receiver claims.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190103/ce268371/attachment.html>"
            },
            {
                "author": "Jose Manuel Arenillas",
                "date": "2019-01-24T18:00:51",
                "message_text_only": ">From  Anton Kumaigorodski (not in the list till now):\n\n\nThis already happens. Yesterday I was contacted by a user who claimed he\ndid not receive a payment while payer was able to provide a preimage.\n\n\nTurns out he reused the same invoice twice which is this one:\nlnbc100u1pwy03lupp5q004g320cfw6y93lfrv30sxvdfppysjvuqspln6mrzwcmfxzpv5qdq823jhxaqcqzysusu5zpfyqw5qetv3w2hsug7uact0hvpten83h7r57e7tz0gu6y78qv4dwh0z2ggxylnvcjcj55fdycj2dc2h599jf3vl5q2tzr4cw7sqq98vek\n\n\nIt's expired by now but if you try to fulfill it a routing node\n02ee8c40b64c2bd14bba4a7a7a80b06065f3a683b2f02b9580be5e8bffe201beda will\nreturn a preimage right away. I can say this for sure since I've obtained\nuser logs which show no incoming update_add_htlc while outgoing payment\ngets fulfilled in my wallet.\n\n\nThis is definitely not what users would expect, I guess something should be\ndone about it. BLW already warns users about QR reuse yet this happened\nanyway. Any ideas?\n\n\nEl jue., 3 ene. 2019 a las 17:42, Andrea RASPITZU (<andrea.raspitzu at acinq.fr>)\nescribi\u00f3:\n\n> Okay so the knowledge of a preimage for a certain payment_hash is the\n> sufficient (and only) payment proof for the payer. But in any case the\n> reuse of payment_hashes should be strongly discouraged, in the donations\n> scenario 2 donors will send across the network a payment for the same\n> preimage and if the routes overlap (as it's likely to happen getting close\n> to the recipient) an intermediate routing node can effectively steal the\n> payment from the recipient. Shouldn't we make this clear in BOLT11?\n>\n> Cheers, Andrea.\n>\n>\n>\n> On Thu, 3 Jan 2019 at 14:13, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Andrea,\n>>\n>> > For example a malicious receiver can provide an invoice with assisted\n>> routes where among those he/she controls a node and that node won't forward\n>> to the htlc but steal the funds instead (the preimage is known to the\n>> intermediate node as well), thus it will be claimed that the payment hasn't\n>> been received. If the above is correct then there should be at least a\n>> warning in the spec regarding the reuse of payment_hash in invoices.\n>>\n>> The fact that ultimate payer has received the payment preimage is\n>> considered sufficient proof of payment.\n>> Thus, in case of reuse, the fact that the ultimate payer has received the\n>> payment preimage is sufficient proof of payment, and whatever the receiver\n>> claims is to be ignored: the payment preimage in possession of the ultimate\n>> payee is considered the whole of the proof of payment.\n>>\n>>\n>> >a malicious receiver can provide an invoice with assisted routes where\n>> among those he/she controls a node and that node won't forward to the htlc\n>> but steal the funds instead\n>>\n>> Then the receiver has received it, not on the purported final node, but\n>> on another node it controls, and the fact that the ultimate payer has\n>> received the payment preimage is sufficient proof of that.\n>>\n>> Obviously, if the receiver knows it does not control the entire Lightning\n>> Network, it should not reuse payment hashes, since intermediate nodes it\n>> does not control could claim the payment and give the proof-of-payment to\n>> the ultimate payer.\n>> This can be clarified, but in the context of proofs, the attack you\n>> described is not possible, since the possession of the payment preimage is\n>> itself the entirety of the proof of the payment, regardless of what the\n>> receiver claims.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nUn saludo,\n\nJosema\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190124/415684ed/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Reuse of payment_hash in lightning invoices",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Andrea RASPITZU",
                "Jose Manuel Arenillas",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 9330
        }
    },
    {
        "title": "[Lightning-dev] Lite client considerations for Lightning Implementations",
        "thread_messages": [
            {
                "author": "Chris Stewart",
                "date": "2019-01-06T14:57:32",
                "message_text_only": "Hi all,\n\nHope your 2019 is off to a fantastic start. I'm really excited for\nLightning in 2019.\n\nWe are currently reviving a lite client project in bitcoin-s (\nhttps://github.com/bitcoin-s/bitcoin-s-core/pull/280). The goal is to have\na modern replacement for bitcoinj that also can be used for L2 applications\nlike lightning. We also are planning on supporting multiple coins, hsms\netc.\n\nThe current plan is to implement traditional SPV, and then implement\nneutrino when development is picking back up on that in bitcoin core. If\nthat takes too long, we will consider implementing neutrino against btcd.\n\nWhat I wanted to ask of the mailing list is to give us \"things to consider\"\nwhen developing this lite client from a usability perspective for lightning\ndevs. How can we make your lives easier?\n\nOne thing that seems logical is to adhere to the bitcoin core api when\npossible, this means you can use bitcoin-s as a drop in lite client\nreplacement for bitcoin core.\n\nThoughts?\n\n-Chris\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190106/952809b3/attachment.html>"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-07T16:33:13",
                "message_text_only": "Hi Chris,\n\nWhat we've learned building a lite bitcoin/LN wallet is that there are\ndifferent things it must implement:\n- a bitcoin wallet. We started with bitcoinj, but there are known\nissues with Bloom Filters, which is one of the reasons why we ended up\nbuilding our own wallet that connect to Electrum Servers (and it seems\nwe're not the only ones). I'm not sure that a \"better\" implementation\nof BIP37 is actually needed, if that's what you mean by \"traditional\nSPV\". Client-side filters is a nice improvement, and we have a basic\nNeutrino prototype that is up to date with the BIPs but not used in\nour mobile app. We could collaborate on this ?\n- monitoring your channels\" part: detect that your peer is trying to\ncheat and published an old commit tx, and publish a penalty tx. This\nis fairly easy (the \"detecting\" part at least :))\n- validating channels: you receive gossip message, and check that\nchannels actually exist, detect when they've been closed and remove\nthem from your routing table. This is much harder. Electrum servers\nnow have a method for retrieving a tx from its coordinates (height +\nposition), but as the number of channels grows it may become\nimpractical to watch every channel. With Bloom Filters and client-side\nfilters you probably end up having to download all blocks (but not\nnecessarily store them all).\n\nI also think that it's very important the lite wallet support mobile\nplatforms, android in your case, and since it's basically stuck at\nJava 7 you may wan to consider using plain Java (or Kotlin) instead of\nScala as much as possible.\n\nCheers,\n\nFabrice\n\n\n\nOn Sun, 6 Jan 2019 at 15:58, Chris Stewart <chris at suredbits.com> wrote:\n>\n> Hi all,\n>\n> Hope your 2019 is off to a fantastic start. I'm really excited for Lightning in 2019.\n>\n> We are currently reviving a lite client project in bitcoin-s (https://github.com/bitcoin-s/bitcoin-s-core/pull/280). The goal is to have a modern replacement for bitcoinj that also can be used for L2 applications like lightning. We also are planning on supporting multiple coins, hsms etc.\n>\n> The current plan is to implement traditional SPV, and then implement neutrino when development is picking back up on that in bitcoin core. If that takes too long, we will consider implementing neutrino against btcd.\n>\n> What I wanted to ask of the mailing list is to give us \"things to consider\" when developing this lite client from a usability perspective for lightning devs. How can we make your lives easier?\n>\n> One thing that seems logical is to adhere to the bitcoin core api when possible, this means you can use bitcoin-s as a drop in lite client replacement for bitcoin core.\n>\n> Thoughts?\n>\n> -Chris\n>\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Lite client considerations for Lightning Implementations",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Chris Stewart",
                "Fabrice Drouin"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4047
        }
    },
    {
        "title": "[Lightning-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2019-01-07T15:18:52",
                "message_text_only": "Sorry for the late reply.\n\nHmm, I included the old RBF-pinning proposal as a comparison. \nPersonally, I find it both less clean and less convincingly secure.\n\nUltimately, defining a \"near the top of the mempool\" criteria is fraught \nwith issues. While it's probably OK for the original problem (large \nbatched transactions where you don't want a single counterparty to \nprevent confirmation), lightning's requirements are very different. \nInstead is wanting a high probability that the transaction in question \nconfirms \"soon\", we need certainty that it will confirm by some deadline.\n\nThus, even if you imagine a steady-state mempool growth, unless the \n\"near the top of the mempool\" criteria is \"near the top of the next \nblock\" (which is obviously *not* incentive-compatible), its easy to see \nhow the package would fail to confirm within a handful of blocks given \nblock time variance. Giving up the ability to RBF/CPFP more than once in \ncase the fee moves away from us seems to be a rather significant \nrestriction.\n\nTHe original proposal is somewhat of a hack, but its a hack on the \nboundary condition where packages meet our local anti-DoS rules in \nviolation of the \"incentive compatible\" goal anyway (essentially, though \nminers also care about anti-DoS). This proposal is very different and, \nsimilar to how it doesn't work if blocks randomly come in a bit slow for \nan hour or two, isn't incentive compatible if blocks come in a bit fast \nfor an hour or two, as all of a sudden that \"near the top of the \nmempool\" criteria makes no sense and you should have accepted the new \ntransaction(s).\n\nAs for package relay, indeed, we can probably do soemthing simpler for \nthis specific case, but itdepends on what the scope of that design is. \nSuhas opened an issue to try to scope it out a bit more at \nhttps://github.com/bitcoin/bitcoin/issues/14895\n\nMatt\n\n> On Dec 3, 2018, at 22:33, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>> As an alternative proposal, at various points there have been \n>> discussions around solving the \"RBF-pinning\" problem by allowing \n>> transactors to mark their transactions as \"likely-to-be-RBF'ed\", which \n>> could enable a relay policy where children of such transactions would be \n>> rejected unless the resulting package would be \"near the top of the \n>> mempool\". This would theoretically imply such attacks are not possible \n>> to pull off consistently, as any \"transaction-delaying\" channel \n>> participant will have to place the package containing A at an effective \n>> feerate which makes confirmation to occur soon with some likelihood. It \n>> is, however, possible to pull off this attack with low probability in \n>> case of feerate spikes right after broadcast.\n> \n> I like this idea.\n> \n> Firstly, it's incentive-compatible[1]: assuming blocks are full, miners\n> should always take a higher feerate tx if that tx would be in the\n> current block and the replaced txs would not.[2]\n> \n> Secondly, it reduces the problem that the current lightning proposal\n> adds to the UTXO set with two anyone-can-spend txs for 1000 satoshis,\n> which might be too small to cleanup later.  This rule would allow a\n> simple single P2WSH(OP_TRUE) output, or, with IsStandard changed,\n> a literal OP_TRUE.\n> \n>> Note that this clearly relies on some form of package relay, which comes \n>> with its own challenges, but I'll start a separate thread on that.\n> \n> Could be done client-side, right?  Do a quick check if this is above 250\n> satoshi per kweight but below minrelayfee, put it in a side-cache with a\n> 60 second timeout sweep.  If something comes in which depends on it\n> which is above minrelayfee, then process them as a pair[3].\n> \n> Cheers,\n> Rusty.\n> [1] Miners have generally been happy with Defaults Which Are Good For The\n>    Network, but I feel a long term development aim should to be reduce\n>    such cases to smaller and smaller corners.\n> [2] The actual condition is subtler, but this is a clear subset AFAICT.\n> [3] For Lightning, we don't care about child-pays-for-grandparent etc."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-08T05:50:20",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> Ultimately, defining a \"near the top of the mempool\" criteria is fraught \n> with issues. While it's probably OK for the original problem (large \n> batched transactions where you don't want a single counterparty to \n> prevent confirmation), lightning's requirements are very different. \n> Instead is wanting a high probability that the transaction in question \n> confirms \"soon\", we need certainty that it will confirm by some deadline.\n\nI don't think it's different, in practice.\n\n> Thus, even if you imagine a steady-state mempool growth, unless the \n> \"near the top of the mempool\" criteria is \"near the top of the next \n> block\" (which is obviously *not* incentive-compatible)\n\nI was defining \"top of mempool\" as \"in the first 4 MSipa\", ie. next\nblock, and assumed you'd only allow RBF if the old package wasn't in the\ntop and the replacement would be.  That seems incentive compatible; more\nthan the current scheme?\n\nThe attack against this is to make a 100k package which would just get\ninto this \"top\", then push it out with a separate tx at slightly higher\nfee, then repeat.  Of course, timing makes that hard to get right, and\nyou're paying real fees for it too.\n\nSure, an attacker can make you pay next-block high fees, but it's still\nbetter than our current \"*always* overpay and hope!\", and you can always\ndecide at the time based on whether the expiring HTLC(s) are worth it.\n\nBut I think whatever's simplest to implement should win, and I'm not in\na position to judge that accurately.\n\nThanks,\nRusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2019-01-08T14:46:45",
                "message_text_only": "I responded to a few things in-line before realizing I think we're out of sync on what this alternative proposal actually implies. In my understanding is it, it does *not* imply that you are guaranteed the ability to RBF as fees change. The previous problem is still there - your counterparty can announce a bogus package and leave you unable to add a new transaction to it, the difference being it may be significantly more expensive to do so. If it were the case the you could RBF after the fact, I would likely agree with you.\n\n> On Jan 8, 2019, at 00:50, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>> Ultimately, defining a \"near the top of the mempool\" criteria is fraught \n>> with issues. While it's probably OK for the original problem (large \n>> batched transactions where you don't want a single counterparty to \n>> prevent confirmation), lightning's requirements are very different. \n>> Instead is wanting a high probability that the transaction in question \n>> confirms \"soon\", we need certainty that it will confirm by some deadline.\n> \n> I don't think it's different, in practice.\n\nI strongly disagree. If you're someone sending a batched payment, 5% chance it takes 13 blocks is perfectly acceptable. If you're a lightning operator, that quickly turns into \"5% chance, or 35% chance if your counterparty is malicious and knows more about the market structure than you\". Eg in the past it's been the case that transaction volume would spike every day at the same time when Bitmex proceed a flood of withdrawals all at once in separate transactions. Worse, it's probably still the case that, in case is sudden market movement, transaction volume can spike while people arb exchanges and move coins into exchanges to sell.\n\n>> Thus, even if you imagine a steady-state mempool growth, unless the \n>> \"near the top of the mempool\" criteria is \"near the top of the next \n>> block\" (which is obviously *not* incentive-compatible)\n> \n> I was defining \"top of mempool\" as \"in the first 4 MSipa\", ie. next\n> block, and assumed you'd only allow RBF if the old package wasn't in the\n> top and the replacement would be.  That seems incentive compatible; more\n> than the current scheme?\n\nMy point was, because of block time variance, even that criteria doesn't hold up. If you assume a steady flow of new transactions and one or two blocks come in \"late\", suddenly \"top 4MWeight\" isn't likely to get confirmed until a few blocks come in \"early\". Given block variance within a 12 block window, this is a relatively likely scenario.\n\n> The attack against this is to make a 100k package which would just get\n> into this \"top\", then push it out with a separate tx at slightly higher\n> fee, then repeat.  Of course, timing makes that hard to get right, and\n> you're paying real fees for it too.\n> \n> Sure, an attacker can make you pay next-block high fees, but it's still\n> better than our current \"*always* overpay and hope!\", and you can always\n> decide at the time based on whether the expiring HTLC(s) are worth it.\n> \n> But I think whatever's simplest to implement should win, and I'm not in\n> a position to judge that accurately.\n> \n> Thanks,\n> Rusty."
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Matt Corallo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8877
        }
    },
    {
        "title": "[Lightning-dev] LightningWiki.net - community effort to collect information, input greatly appreciated",
        "thread_messages": [
            {
                "author": "Abel Lykens",
                "date": "2019-01-11T14:59:36",
                "message_text_only": "Dear developers,\n\nWhat a time to be alive! I am so excited about Lightning, feels a bit like my experiences with Bitcoin in 2011: not being able to stop reading about Lightning, watching too many youtube videos... I guess you are familiar with it.\n\nI am humbly starting https://LightningWiki.net . It is my attempt to collect information on Lightning centrally. If you read this message just after I sent it, there will be lots of chance to help in expanding the wiki (my way of saying \"there is not much content yet\").\n\nHelp is welcome. The wiki will be a community effort, not specific to an implementation of blockchain. Registration is currently open, I hope that will work well. You can email me directly if you want to help beyond writing articles.\n\nHave a great weekend,\nAbel\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190111/9fac5be5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "LightningWiki.net - community effort to collect information, input greatly appreciated",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Abel Lykens"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1029
        }
    },
    {
        "title": "[Lightning-dev] Mandatory \"d\" or \"h\" UX issues",
        "thread_messages": [
            {
                "author": "Francis Pouliot",
                "date": "2019-01-11T16:37:33",
                "message_text_only": "I'm currently in the process of building the Lightning Network payout\nfeature which will allow users to purchase bitcoins with fiat and have the\ncoins sent to the via LN rather than on-chain. The main issue I'm facing is\nensuring that recipients generate the correct Bolt11 invoice.\n\nHaving the \"d\" and \"h\" fields mandatory creates a UX issue for Bitcoin\nservices that are performing payouts/withdrawals (in the absence of a\nwidely adopted payment protocol).\n\nIt seems to me that the design of Bolt11 may have been biased towards\nmerchants, because normally merchants, as recipients, decide on what the\ninvoice is going to be and the sender doesn't have a choice but to conform\n(since the recipient is the service provider).\n\nBut for LN payouts (e.g. withdrawal from an exchange or a poker site), the\nSender is the services provider, and it is the Sender who will be creating\n(most likely programatically) the terms of the payment. However, this means\nthat the Sender must be able to communicate to his end-user exactly what\ntype of Bolt11 invoice he wants the user to create. This means, in most\ncases, that the user will have to manually enter some fields in his wallet.\nAnd if the content doesnt match, there will be a payment failure.\n\nHere is how I picture the ux issues taking place.\n\n   1. User goes on my app to buy Bitcoin with fiat, and opts to be paid out\n   via LN rather than on-chain BTC.\n   2. My app will tell him: \"make an invoice with the following: msatoshi,\n   description.\n   3. He will go in his wallet and type msatoshi, description.\n   4. It's likey he won't pay too much attention, make a typo in\n   description, leave it blank, write his own description, etc.\n   5. When my app tries to pay, we of course have to decode his bolt11\n   first.\n   6. We have to have some logic that will compare the \"h\" or \"d\" that we\n   instructed him to create and the \"h\" or \"d\" that we got from the decoded\n   bolt 11 (which is an extra hassle for devs)\n   7. In the cases there they are not the same, we need to instruct the\n   user to create a new bolt 11 invoice because the one he created was not\n   correct.\n\nWhat this ends up doing is create a situation where the service provider\ndepends on his user to create a correct invoice before sending him the\nfunds, and creates an added (unecessary) requirement for communication, and\nlower payment success rates, and likely higher abandonment rate.\n\nQuestion: what is the logic behind making \"d\" and \"h\" mandatory? I think\nbusiness logic should be left to Bitcoin businesses.\n\nCan we simply not make \"d\" or \"h\" mandatory without breaking anything?\n\nTL;DR users already have troube entering the correct amount of BTC when\npaying invoices that aren't BIP21, so I am afraid that there will be tons\nof issues with them writing down the correct description.\n\nP.s. I'm using c-lightning right now and would like to not have to switch\n\nP.s.s. this will likely be fixed with a standardised payment protocol but\naddressing this issue seems a lower hanging fruit.\n\nIssue: https://github.com/lightningnetwork/lightning-rfc/issues/541\n\nThanks is for your time,\n\nFrancis\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190111/2cd3eae9/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2019-01-14T23:38:05",
                "message_text_only": "It isn't mandatory. It can be left blank, none of the existing wallets\nrequire users to input a description when they make an invoice.\n\nOn Mon, Jan 14, 2019, 3:28 PM Francis Pouliot <francis at satoshiportal.com\nwrote:\n\n> I'm currently in the process of building the Lightning Network payout\n> feature which will allow users to purchase bitcoins with fiat and have the\n> coins sent to the via LN rather than on-chain. The main issue I'm facing is\n> ensuring that recipients generate the correct Bolt11 invoice.\n>\n> Having the \"d\" and \"h\" fields mandatory creates a UX issue for Bitcoin\n> services that are performing payouts/withdrawals (in the absence of a\n> widely adopted payment protocol).\n>\n> It seems to me that the design of Bolt11 may have been biased towards\n> merchants, because normally merchants, as recipients, decide on what the\n> invoice is going to be and the sender doesn't have a choice but to conform\n> (since the recipient is the service provider).\n>\n> But for LN payouts (e.g. withdrawal from an exchange or a poker site), the\n> Sender is the services provider, and it is the Sender who will be creating\n> (most likely programatically) the terms of the payment. However, this means\n> that the Sender must be able to communicate to his end-user exactly what\n> type of Bolt11 invoice he wants the user to create. This means, in most\n> cases, that the user will have to manually enter some fields in his wallet.\n> And if the content doesnt match, there will be a payment failure.\n>\n> Here is how I picture the ux issues taking place.\n>\n>    1. User goes on my app to buy Bitcoin with fiat, and opts to be paid\n>    out via LN rather than on-chain BTC.\n>    2. My app will tell him: \"make an invoice with the following:\n>    msatoshi, description.\n>    3. He will go in his wallet and type msatoshi, description.\n>    4. It's likey he won't pay too much attention, make a typo in\n>    description, leave it blank, write his own description, etc.\n>    5. When my app tries to pay, we of course have to decode his bolt11\n>    first.\n>    6. We have to have some logic that will compare the \"h\" or \"d\" that we\n>    instructed him to create and the \"h\" or \"d\" that we got from the decoded\n>    bolt 11 (which is an extra hassle for devs)\n>    7. In the cases there they are not the same, we need to instruct the\n>    user to create a new bolt 11 invoice because the one he created was not\n>    correct.\n>\n> What this ends up doing is create a situation where the service provider\n> depends on his user to create a correct invoice before sending him the\n> funds, and creates an added (unecessary) requirement for communication, and\n> lower payment success rates, and likely higher abandonment rate.\n>\n> Question: what is the logic behind making \"d\" and \"h\" mandatory? I think\n> business logic should be left to Bitcoin businesses.\n>\n> Can we simply not make \"d\" or \"h\" mandatory without breaking anything?\n>\n> TL;DR users already have troube entering the correct amount of BTC when\n> paying invoices that aren't BIP21, so I am afraid that there will be tons\n> of issues with them writing down the correct description.\n>\n> P.s. I'm using c-lightning right now and would like to not have to switch\n>\n> P.s.s. this will likely be fixed with a standardised payment protocol but\n> addressing this issue seems a lower hanging fruit.\n>\n> Issue: https://github.com/lightningnetwork/lightning-rfc/issues/541\n>\n> Thanks is for your time,\n>\n> Francis\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190114/09200bcf/attachment-0001.html>"
            },
            {
                "author": "F\u00e9lix-Antoine Paradis",
                "date": "2019-01-15T11:04:56",
                "message_text_only": "Francis\n\nI have seen you ask around for this. c or h are mandatory on a protocol\nlevel but I would never enforce business decisions based on their content.\n\nThe same way as you would not ask a customer to plainly add his customer\nnumber in a Bitcoin transaction... Instead, you give him a unique address\nand base you decisions on this.\n\nOnce you know the amount you are going to owe to this customer, ask for the\npayment_req and decode it to be sure it matches the amount owing. You can\nlookup c or h and store it but I would never parse that.\n\nLet me know if you come to Quebec city, we can have a lightning talk ;)\n\nOn Mon., Jan. 14, 2019, 19:08 Olaoluwa Osuntokun, <laolu32 at gmail.com> wrote:\n\n> It isn't mandatory. It can be left blank, none of the existing wallets\n> require users to input a description when they make an invoice.\n>\n> On Mon, Jan 14, 2019, 3:28 PM Francis Pouliot <francis at satoshiportal.com\n> wrote:\n>\n>> I'm currently in the process of building the Lightning Network payout\n>> feature which will allow users to purchase bitcoins with fiat and have the\n>> coins sent to the via LN rather than on-chain. The main issue I'm facing is\n>> ensuring that recipients generate the correct Bolt11 invoice.\n>>\n>> Having the \"d\" and \"h\" fields mandatory creates a UX issue for Bitcoin\n>> services that are performing payouts/withdrawals (in the absence of a\n>> widely adopted payment protocol).\n>>\n>> It seems to me that the design of Bolt11 may have been biased towards\n>> merchants, because normally merchants, as recipients, decide on what the\n>> invoice is going to be and the sender doesn't have a choice but to conform\n>> (since the recipient is the service provider).\n>>\n>> But for LN payouts (e.g. withdrawal from an exchange or a poker site),\n>> the Sender is the services provider, and it is the Sender who will be\n>> creating (most likely programatically) the terms of the payment. However,\n>> this means that the Sender must be able to communicate to his end-user\n>> exactly what type of Bolt11 invoice he wants the user to create. This\n>> means, in most cases, that the user will have to manually enter some fields\n>> in his wallet. And if the content doesnt match, there will be a payment\n>> failure.\n>>\n>> Here is how I picture the ux issues taking place.\n>>\n>>    1. User goes on my app to buy Bitcoin with fiat, and opts to be paid\n>>    out via LN rather than on-chain BTC.\n>>    2. My app will tell him: \"make an invoice with the following:\n>>    msatoshi, description.\n>>    3. He will go in his wallet and type msatoshi, description.\n>>    4. It's likey he won't pay too much attention, make a typo in\n>>    description, leave it blank, write his own description, etc.\n>>    5. When my app tries to pay, we of course have to decode his bolt11\n>>    first.\n>>    6. We have to have some logic that will compare the \"h\" or \"d\" that\n>>    we instructed him to create and the \"h\" or \"d\" that we got from the decoded\n>>    bolt 11 (which is an extra hassle for devs)\n>>    7. In the cases there they are not the same, we need to instruct the\n>>    user to create a new bolt 11 invoice because the one he created was not\n>>    correct.\n>>\n>> What this ends up doing is create a situation where the service provider\n>> depends on his user to create a correct invoice before sending him the\n>> funds, and creates an added (unecessary) requirement for communication, and\n>> lower payment success rates, and likely higher abandonment rate.\n>>\n>> Question: what is the logic behind making \"d\" and \"h\" mandatory? I think\n>> business logic should be left to Bitcoin businesses.\n>>\n>> Can we simply not make \"d\" or \"h\" mandatory without breaking anything?\n>>\n>> TL;DR users already have troube entering the correct amount of BTC when\n>> paying invoices that aren't BIP21, so I am afraid that there will be tons\n>> of issues with them writing down the correct description.\n>>\n>> P.s. I'm using c-lightning right now and would like to not have to switch\n>>\n>> P.s.s. this will likely be fixed with a standardised payment protocol but\n>> addressing this issue seems a lower hanging fruit.\n>>\n>> Issue: https://github.com/lightningnetwork/lightning-rfc/issues/541\n>>\n>> Thanks is for your time,\n>>\n>> Francis\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190115/9038b978/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-21T05:18:18",
                "message_text_only": "Francis Pouliot <francis at satoshiportal.com> writes:\n> Here is how I picture the ux issues taking place.\n>\n>    1. User goes on my app to buy Bitcoin with fiat, and opts to be paid out\n>    via LN rather than on-chain BTC.\n>    2. My app will tell him: \"make an invoice with the following: msatoshi,\n>    description.\n>    3. He will go in his wallet and type msatoshi, description.\n>    4. It's likey he won't pay too much attention, make a typo in\n>    description, leave it blank, write his own description, etc.\n>    5. When my app tries to pay, we of course have to decode his bolt11\n>    first.\n>    6. We have to have some logic that will compare the \"h\" or \"d\" that we\n>    instructed him to create and the \"h\" or \"d\" that we got from the decoded\n>    bolt 11 (which is an extra hassle for devs)\n>    7. In the cases there they are not the same, we need to instruct the\n>    user to create a new bolt 11 invoice because the one he created was not\n>    correct.\n\nYes, there's a missing \"give me an invoice\" API for this kind of push\npayment.  yalls.org has the same problem: there's a clumsy API where you\ngive them an invoice and it pays it if you have that much.\n\nlninv: URL?  Description, min and max amounts, submission URL?  Ideally\nthe browser would reach out to the wallet to get an invoice and do the\nsubmission itself (preserving sessions, cookies, etc) but I'm not sure\nhow that part of the stack works?\n\nThere was talk of something similar in Adelaide, but I hadn't\nappreciated the concrete problem at the time :(\n\nCheers,\nRusty."
            },
            {
                "author": "Giovanni P",
                "date": "2019-01-21T11:40:22",
                "message_text_only": "What about this?\nhttps://github.com/btcontract/lnurl-rfc/blob/master/spec.md#2-withdrawing-funds-from-a-service\n\nOn Monday, January 21, 2019, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> Francis Pouliot <francis at satoshiportal.com> writes:\n>> Here is how I picture the ux issues taking place.\n>>\n>>    1. User goes on my app to buy Bitcoin with fiat, and opts to be paid\nout\n>>    via LN rather than on-chain BTC.\n>>    2. My app will tell him: \"make an invoice with the following:\nmsatoshi,\n>>    description.\n>>    3. He will go in his wallet and type msatoshi, description.\n>>    4. It's likey he won't pay too much attention, make a typo in\n>>    description, leave it blank, write his own description, etc.\n>>    5. When my app tries to pay, we of course have to decode his bolt11\n>>    first.\n>>    6. We have to have some logic that will compare the \"h\" or \"d\" that we\n>>    instructed him to create and the \"h\" or \"d\" that we got from the\ndecoded\n>>    bolt 11 (which is an extra hassle for devs)\n>>    7. In the cases there they are not the same, we need to instruct the\n>>    user to create a new bolt 11 invoice because the one he created was\nnot\n>>    correct.\n>\n> Yes, there's a missing \"give me an invoice\" API for this kind of push\n> payment.  yalls.org has the same problem: there's a clumsy API where you\n> give them an invoice and it pays it if you have that much.\n>\n> lninv: URL?  Description, min and max amounts, submission URL?  Ideally\n> the browser would reach out to the wallet to get an invoice and do the\n> submission itself (preserving sessions, cookies, etc) but I'm not sure\n> how that part of the stack works?\n>\n> There was talk of something similar in Adelaide, but I hadn't\n> appreciated the concrete problem at the time :(\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190121/3b8879a1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Mandatory \"d\" or \"h\" UX issues",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "F\u00e9lix-Antoine Paradis",
                "Francis Pouliot",
                "Rusty Russell",
                "Olaoluwa Osuntokun",
                "Giovanni P"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 15650
        }
    },
    {
        "title": "[Lightning-dev] Routing fees under custodial conditions (was: Mandatory \"d\" or \"h\" UX issues)",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-15T12:14:39",
                "message_text_only": "Good morning Francis and list,\n\nNot directly related to the original question, but I would like to bring up the issue of routing fees in such custodial cases.\n\nIn your original post:\n\n> But for LN payouts (e.g. withdrawal from an exchange or a poker site), the Sender is the services provider, and it is the Sender who will be creating (most likely programatically) the terms of the payment.\n\nThe issue is: when paying the user-provided invoice, does the Sender in this case deduct also the routing fee from the user account or not?\n\nOne possible attack on a custodial service is:\n\n1.  Acquire 1.0BTC in the custodial service (purchase by fiat, or simple send via Lightning, etc.).\n2.  Create 100,000,000 invoices of 1 satoshi each on a node the attacker controls.\n3.  Have the custodial service pay to the invoices.\n\nPaying 1-satoshi invoices will tend to lead to fees approximately equal, or even greater to, the invoice amount.\n\nThis is of course trivially fixable by imposing either a withdrawal limit (number of invoices that can be paid in a day) or a minimum withdrawal amount.\nThere is some degradation of service, but reasonable defaults (100 withdrawal invoices per day) could still be useful for typical usage.\n\nAlternately, the custodial service may deduct the routing fees from the account of the user.\nHowever, this latter solution is also undesirable in general, as routes (and thus fees) are controlled and selected by the sender, and in this case the user is the receiver, not the sender.\n\nThe custodial service can very easily lie about routing fees; even if the user demands a report of the route, nodes along the route are allowed to change their routing fees at any time, thus the route information is potentially stale as soon as it is finalized and reported.\nThe custodial service might secretly control particular nodes on the network and bias the routefinding algorithm towards those nodes even if those nodes charge high fees.\n\nOverall, however, such issues are minimal.\nCustodial services cannot be trusted to hold substantial money safely for long anyway, so any UX problems with them are largely immaterial.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "F\u00e9lix-Antoine Paradis",
                "date": "2019-01-15T12:22:52",
                "message_text_only": "Good morning!\n\nExcellent point. I would like to add that on a UX perspective, I would be a\nlot more worried about having a well connected node with well\nfunded/balanced channels.\n\nYou can always refuse to pay a lesser invoice but having to wait for a new\nchannel might be a deal breaker.\n\nDeducting routing fees is also important in my view.\n\nFelix\n\nOn Tue, Jan 15, 2019 at 7:14 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Francis and list,\n>\n> Not directly related to the original question, but I would like to bring\n> up the issue of routing fees in such custodial cases.\n>\n> In your original post:\n>\n> > But for LN payouts (e.g. withdrawal from an exchange or a poker site),\n> the Sender is the services provider, and it is the Sender who will be\n> creating (most likely programatically) the terms of the payment.\n>\n> The issue is: when paying the user-provided invoice, does the Sender in\n> this case deduct also the routing fee from the user account or not?\n>\n> One possible attack on a custodial service is:\n>\n> 1.  Acquire 1.0BTC in the custodial service (purchase by fiat, or simple\n> send via Lightning, etc.).\n> 2.  Create 100,000,000 invoices of 1 satoshi each on a node the attacker\n> controls.\n> 3.  Have the custodial service pay to the invoices.\n>\n> Paying 1-satoshi invoices will tend to lead to fees approximately equal,\n> or even greater to, the invoice amount.\n>\n> This is of course trivially fixable by imposing either a withdrawal limit\n> (number of invoices that can be paid in a day) or a minimum withdrawal\n> amount.\n> There is some degradation of service, but reasonable defaults (100\n> withdrawal invoices per day) could still be useful for typical usage.\n>\n> Alternately, the custodial service may deduct the routing fees from the\n> account of the user.\n> However, this latter solution is also undesirable in general, as routes\n> (and thus fees) are controlled and selected by the sender, and in this case\n> the user is the receiver, not the sender.\n>\n> The custodial service can very easily lie about routing fees; even if the\n> user demands a report of the route, nodes along the route are allowed to\n> change their routing fees at any time, thus the route information is\n> potentially stale as soon as it is finalized and reported.\n> The custodial service might secretly control particular nodes on the\n> network and bias the routefinding algorithm towards those nodes even if\n> those nodes charge high fees.\n>\n> Overall, however, such issues are minimal.\n> Custodial services cannot be trusted to hold substantial money safely for\n> long anyway, so any UX problems with them are largely immaterial.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190115/d8326de4/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Routing fees under custodial conditions (was: Mandatory \"d\" or \"h\" UX issues)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "F\u00e9lix-Antoine Paradis",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5015
        }
    },
    {
        "title": "[Lightning-dev] lnurl to enable payer/payee interactions",
        "thread_messages": [
            {
                "author": "Anton Kumaigorodskiy",
                "date": "2019-01-17T19:42:34",
                "message_text_only": "LN as it exists today is not too convinient for end users, I believe some kind of standard is needed for various payer/payee interactions which builds on Lightning invoices and a fact that Bitcoin wallets contain keychains which can be creatively repurposed, my attempt to get this ball rolling is https://github.com/btcontract/lnurl-rfc/blob/master/spec.md\n\n\nSo far this spec defines 4 use cases:\n1. Incoming payment channel request  \n2. Withdrawing funds from a service  \n3. Linkable payments  \n4. Log in with Bitcoin Wallet  \n\n\nI'd like to give some rationale in particular for use cases 3. (Linkable payments) and 4. (Log in with Bitcoin Wallet) since those are related and define a cryptographic protocol (I think) so I'd be greatful if someone more skilled than me checks if those has any obvious flaws.\n\n\nIn both of these cases some kind of stable user identifier is needed, a popular candidate for that would be user's LN node key. But that approach seems flawed because it allows to easily link user actions across different services so what's proposed is to derive a special `LinkingKey` which would be unique for each `(user, service)` pair where `user` is basically wallet seed and `service` is a domain name.\n\n\nAnton"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-19T02:04:05",
                "message_text_only": "Hi Anton,\n\nI believe all of these will be implemented at some point \"soon\" within BOLT rather than as a separate HTTP request.\n\n1.  Incoming payment channel request.\n\nAt some point after implementing dual-funded channels we will also support advertising of liquidity providers.\nSuch liquidity providers will sell a service of providing incoming liquidity to nodes in exchange for a fee.\n\n> Suppose user has a balance on a certain service which he wishes to turn into an incoming channel and service supports such functionality.\n\nThe balance would have to be on the user side, which makes it outgoing capacity, not incoming capacity.\nThis is why the proposal in the future is to have liquidity providers of some sort.\n\n\n2.  Withdrawing funds from a service.\n\nA significant problem with custodial services and LN is the issue of fees on Lightning.\n\nIf the service shoulders the Lightning fee, a user can create two nodes, an internal node and an external node.\nThe internal node only has a single channel, that to the external node (and the internal node refuses incoming channel creation requests except from the external node).\nThe external node charges exorbitant fee.\nThe user then indicates the internal node (which has only one channel) as the destination of the withdrawal, forcing the service to also pay the external node (which is controlled by the same user) the exorbitant fee.\n\nIf the service charges the Lightning fee to the user balance, then the user has to trust the service does not do things like bias routes towards nodes it secretly controls that charge exorbitant fees (basically the dual of the above attack).\n\nFinally, this reveals the public node of the user to the service, which is bad because it is personally-identifiable information and the service has no right to know that node and its location on the network.\n\nA better solution would be to adapt Rendezvous routing to custodial service withdrawals (ping cdecker and CJP about this).\nThe service publicly provides its LN node.\nThe user generates an onion-wrapped encrypted route from the service node to its own node.\nThe route indicates an amount that has to be released by the service, which also pays fees along the route aside from providing the final value to the user node.\n\n*  The service does not know the actual destination node since it receives an onion-wrapped route.\n*  The on Lightning fee is effectively deducted by the service from the balance, which prevents the user attacking the service by using the internal-external node attack above.\n*  The service cannot bias the route towards expensive hop nodes it controls, since the user generates the entire route.  Of course, it could also use the same internal-external node attack.\n\n\n3.  Linkable payments\n\nPayments will have tlv soon.\n\"tlv\" means type-length-value.\nThis is basically a key-value map added to each payment, sent by the payer and interpreted by the payee.\nIt would be trivial to add a user-linking-key to such a key-value map, although it would have to be defined by the BOLT spec.\n\n\n4.  Login with Bitcoin wallet\n\nThe same tlv above can also add a user-challenge.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, January 18, 2019 3:42 AM, Anton Kumaigorodskiy <anton.kumaigorodskiy at outlook.com> wrote:\n\n> LN as it exists today is not too convinient for end users, I believe some kind of standard is needed for various payer/payee interactions which builds on Lightning invoices and a fact that Bitcoin wallets contain keychains which can be creatively repurposed, my attempt to get this ball rolling is https://github.com/btcontract/lnurl-rfc/blob/master/spec.md\n>\n> So far this spec defines 4 use cases:\n>\n> 1.  Incoming payment channel request\n> 2.  Withdrawing funds from a service\n> 3.  Linkable payments\n> 4.  Log in with Bitcoin Wallet\n>\n>     I'd like to give some rationale in particular for use cases 3. (Linkable payments) and 4. (Log in with Bitcoin Wallet) since those are related and define a cryptographic protocol (I think) so I'd be greatful if someone more skilled than me checks if those has any obvious flaws.\n>\n>     In both of these cases some kind of stable user identifier is needed, a popular candidate for that would be user's LN node key. But that approach seems flawed because it allows to easily link user actions across different services so what's proposed is to derive a special `LinkingKey` which would be unique for each `(user, service)` pair where `user` is basically wallet seed and `service` is a domain name.\n>\n>     Anton\n>\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anton Kumaigorodskiy",
                "date": "2019-01-19T09:01:04",
                "message_text_only": "ZmnSCPxj,\n\n\nthis proposal deliberately tries to deal with tasks which are outside of BOLT, those are quite mundane compared to core LN issues but a common format for these would still help a lot.\n\n\n> At some point after implementing dual-funded channels we will also support advertising of liquidity providers.\n\n\nUse case 1 just recognizes a fact that custodial services exist, users may want to use their funds there to open channels and introduction of protocol-level liquidity providers is unlikely to end that. As an example: users can get an incoming channel from Bitrefill today by utilizing their Bitrefill account funds which may be Bitcoin or altcoins. Later if more services join this can also be fiat, I guess protocol level liquidity advertizing can not and should not take this into account.\n\n\n> 2. Withdrawing funds from a service.\n\n\n> A significant problem with custodial services and LN is the issue of fees on Lightning\n\n\n> A better solution would be to adapt Rendezvous routing to custodial service withdrawals\n\n\nNone of this is directly related to use case 2, respected lnurl does not try to replace an invoice format but merely defines a standard way for payer to deliver an invoice to payee. This is a problem mobile wallet users face regulary when they have to somehow get their withdrawal invoince from a phone to a desktop site form.\n\n\n> 3.  Linkable payments\n\n\n> Payments will have tlv soon.\n\n\nIs this about additional fields in an onion? Indeed, having that would improve on proposed scheme as it removes the need for HTTP request ahead of payment. However, user wallet still needs to know what kind of data to include in such a field. In a proposed `linking key` scheme service domain name still has to be somehow communicated to user before payment, so the need for invoice embedded tag remains.\n\n________________________________\n\u041e\u0442: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e: 19 \u044f\u043d\u0432\u0430\u0440\u044f 2019 \u0433. 5:04\n\u041a\u043e\u043c\u0443: Anton Kumaigorodskiy\n\u041a\u043e\u043f\u0438\u044f: lightning-dev at lists.linuxfoundation.org\n\u0422\u0435\u043c\u0430: Re: [Lightning-dev] lnurl to enable payer/payee interactions\n\nHi Anton,\n\nI believe all of these will be implemented at some point \"soon\" within BOLT rather than as a separate HTTP request.\n\n1.  Incoming payment channel request.\n\nAt some point after implementing dual-funded channels we will also support advertising of liquidity providers.\nSuch liquidity providers will sell a service of providing incoming liquidity to nodes in exchange for a fee.\n\n> Suppose user has a balance on a certain service which he wishes to turn into an incoming channel and service supports such functionality.\n\nThe balance would have to be on the user side, which makes it outgoing capacity, not incoming capacity.\nThis is why the proposal in the future is to have liquidity providers of some sort.\n\n\n2.  Withdrawing funds from a service.\n\nA significant problem with custodial services and LN is the issue of fees on Lightning.\n\nIf the service shoulders the Lightning fee, a user can create two nodes, an internal node and an external node.\nThe internal node only has a single channel, that to the external node (and the internal node refuses incoming channel creation requests except from the external node).\nThe external node charges exorbitant fee.\nThe user then indicates the internal node (which has only one channel) as the destination of the withdrawal, forcing the service to also pay the external node (which is controlled by the same user) the exorbitant fee.\n\nIf the service charges the Lightning fee to the user balance, then the user has to trust the service does not do things like bias routes towards nodes it secretly controls that charge exorbitant fees (basically the dual of the above attack).\n\nFinally, this reveals the public node of the user to the service, which is bad because it is personally-identifiable information and the service has no right to know that node and its location on the network.\n\nA better solution would be to adapt Rendezvous routing to custodial service withdrawals (ping cdecker and CJP about this).\nThe service publicly provides its LN node.\nThe user generates an onion-wrapped encrypted route from the service node to its own node.\nThe route indicates an amount that has to be released by the service, which also pays fees along the route aside from providing the final value to the user node.\n\n*  The service does not know the actual destination node since it receives an onion-wrapped route.\n*  The on Lightning fee is effectively deducted by the service from the balance, which prevents the user attacking the service by using the internal-external node attack above.\n*  The service cannot bias the route towards expensive hop nodes it controls, since the user generates the entire route.  Of course, it could also use the same internal-external node attack.\n\n\n3.  Linkable payments\n\nPayments will have tlv soon.\n\"tlv\" means type-length-value.\nThis is basically a key-value map added to each payment, sent by the payer and interpreted by the payee.\nIt would be trivial to add a user-linking-key to such a key-value map, although it would have to be defined by the BOLT spec.\n\n\n4.  Login with Bitcoin wallet\n\nThe same tlv above can also add a user-challenge.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, January 18, 2019 3:42 AM, Anton Kumaigorodskiy <anton.kumaigorodskiy at outlook.com> wrote:\n\n> LN as it exists today is not too convinient for end users, I believe some kind of standard is needed for various payer/payee interactions which builds on Lightning invoices and a fact that Bitcoin wallets contain keychains which can be creatively repurposed, my attempt to get this ball rolling is https://github.com/btcontract/lnurl-rfc/blob/master/spec.md\n>\n> So far this spec defines 4 use cases:\n>\n> 1.  Incoming payment channel request\n> 2.  Withdrawing funds from a service\n> 3.  Linkable payments\n> 4.  Log in with Bitcoin Wallet\n>\n>     I'd like to give some rationale in particular for use cases 3. (Linkable payments) and 4. (Log in with Bitcoin Wallet) since those are related and define a cryptographic protocol (I think) so I'd be greatful if someone more skilled than me checks if those has any obvious flaws.\n>\n>     In both of these cases some kind of stable user identifier is needed, a popular candidate for that would be user's LN node key. But that approach seems flawed because it allows to easily link user actions across different services so what's proposed is to derive a special `LinkingKey` which would be unique for each `(user, service)` pair where `user` is basically wallet seed and `service` is a domain name.\n>\n>     Anton\n>\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190119/f826d80f/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-20T02:25:34",
                "message_text_only": "Good Morning Anton,\n\n\n> As an example: users can get an incoming channel from Bitrefill today by utilizing their Bitrefill account funds which may be Bitcoin or altcoins.\n\nUsually, when we say \"incoming channel\", we mean a channel where the funds are owned by your counterparty, not yours, precisely so that you can receive momey by it.\nNow if you own the funds, obviously it is not owned by your counterparty.\nSo you cannot use \"your\" Bitrefill account funds to get a channel that is incoming to you, assuming Bitrefill actually considers it \"yours\".\nYou *could* use it to *pay* for incoming liquidity, but that is now part of the liquidity provider proposal where you ask for an incoming channel and are given an invoice somehow.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "lnurl to enable payer/payee interactions",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anton Kumaigorodskiy",
                "ZmnSCPxj"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 13698
        }
    },
    {
        "title": "[Lightning-dev] Network probes",
        "thread_messages": [
            {
                "author": "Andrea RASPITZU",
                "date": "2019-01-18T16:46:16",
                "message_text_only": "Good morning list,\n\nI know there have been discussion around how (and if) we should probe the\nnetwork to check for the liveliness of a path before sending out the\npayment. Currently we issue a payment with a random payment_hash that is\nnot redeemable by anyone, if the destination (and the path) is `lively` it\nwill respond Error. Assuming we do want to probe, and it make sense to\nassume so because it can't be prevented, we can improve it by using the\n`padding` of the `per_hop` field of the onion; with a single bit of the\npadding we can tell the final node that this is a probe and not an actual\npayment. This saves the receiving node from doing a database lookup\n(checking if it has the preimage for such a payment_hash) and it does not\nreveal anything to intermediate nodes, we don't want them to change the\nbehavior if they know it's a probe and not an actual payment. I believe\nprobing can help reducing the error rate of payments (and even detect stale\nchannels?) and I'm looking forward to have some feedback, and submit a\ndraft.\n\nCheers, Andrea.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190118/d2440e77/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2019-01-18T21:06:51",
                "message_text_only": "Hi Andrea,\n\n> This saves the receiving node from doing a database lookup\n\nNodes can and eventually should start using bloom filters to avoid most\ndatabase lookups for incoming payment hashes. The false positive rate can be\nset to a very low value as the bloom filter doesn't need to transmitted, and\ncan even be stored persistently. As an optimization, nodes may opt to\nmaintain a series of hierarchical bloom filters, with the highest tier\nfilter containing only payment hashes for non-expired invoices. Clever bloom\nfilter usage by nodes would allow them to avoid almost all database lookups\nfor incoming unknown payment hashes (probes or not).\n\n> we can improve it by using the `padding` of the `per_hop` field of the\n> onion;\n\nI recently implemented a type of spontaneous payment [1] that works today in\nthe wild (gotta love dat End to End Principle). A requirement for this was\nfully functional EOB packing logic at the sender, and multi-packet\nunwrapping at the receiver, the modified packet construction/processing can\nbe found here [2]. Using the terminology of the current draft code, all that\nwould need to be done is specify an EOB type for this special probe type of\nHTLC. As it doesn't need any additional data, it only consumes a single\npivot hop and doesn't require the route to be extended.\n\nHave you seen aj's prior post [3] on this front (making probe HTLCs\nidentifiable to the receiver, and allowing intermediate nodes to drop them)?\nAllowing intermediate nodes to identify probe HTLCs has privacy\nimplications, as all of a sudden we've created two path-level classes of\nHTLCs. On the other hand, this may help with QoS scheduling on the\nforwarding plane for nodes, they may want to prioritize actual payments over\nprobes, with some nodes opting to not forward probes all together.\n\n[1]: https://github.com/lightningnetwork/lnd/pull/2455\n[2]: https://github.com/lightningnetwork/lightning-onion/pull/31\n[3]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001554.html\n\n-- Laolu\n\n\nOn Fri, Jan 18, 2019 at 8:47 AM Andrea RASPITZU <andrea.raspitzu at acinq.fr>\nwrote:\n\n> Good morning list,\n>\n> I know there have been discussion around how (and if) we should probe the\n> network to check for the liveliness of a path before sending out the\n> payment. Currently we issue a payment with a random payment_hash that is\n> not redeemable by anyone, if the destination (and the path) is `lively` it\n> will respond Error. Assuming we do want to probe, and it make sense to\n> assume so because it can't be prevented, we can improve it by using the\n> `padding` of the `per_hop` field of the onion; with a single bit of the\n> padding we can tell the final node that this is a probe and not an actual\n> payment. This saves the receiving node from doing a database lookup\n> (checking if it has the preimage for such a payment_hash) and it does not\n> reveal anything to intermediate nodes, we don't want them to change the\n> behavior if they know it's a probe and not an actual payment. I believe\n> probing can help reducing the error rate of payments (and even detect stale\n> channels?) and I'm looking forward to have some feedback, and submit a\n> draft.\n>\n> Cheers, Andrea.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190118/ca2dccc5/attachment.html>"
            },
            {
                "author": "Andrea RASPITZU",
                "date": "2019-01-21T09:43:57",
                "message_text_only": "Hi Laolu,\n\nGreat idea, effectively with a clever (hierarchical) usage of bloom filters\nnodes can reduce to the bare minimum the DB lookups. I guess with that\nconsidered it's probably redundant to have an explicit probe flag for the\nsender? Not for technical reasons though (the EOB can easily support that -\njust need an extra type) but it seems to me that the only benefit can be\nalready torn away by client-side optimizations and it wouldn't improve much\nto have an explicit probe at this point. Cancellable probes is indeed an\nattracting idea, if i understood it correctly it is about the sender being\nable to send out another different type of probe that would tell the\nintermediate nodes that the previous one wasn't  actually a payment -\nallowing the network to free resources. I agree that introducing probes\nthat can be dropped and/or prioritized by intermediate nodes is a privacy\nissue and can be abused, it allows them to respond differently thus the\nprobe result can not be trusted entirely, perhaps a node policy where nodes\nwould temporary ban a peer that is adding too many unredeemable HTLCs is\nenough for the moment.\n\nCheers, Andrea.\n\nOn Fri, 18 Jan 2019 at 22:07, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n\n> Hi Andrea,\n>\n> > This saves the receiving node from doing a database lookup\n>\n> Nodes can and eventually should start using bloom filters to avoid most\n> database lookups for incoming payment hashes. The false positive rate can\n> be\n> set to a very low value as the bloom filter doesn't need to transmitted,\n> and\n> can even be stored persistently. As an optimization, nodes may opt to\n> maintain a series of hierarchical bloom filters, with the highest tier\n> filter containing only payment hashes for non-expired invoices. Clever\n> bloom\n> filter usage by nodes would allow them to avoid almost all database lookups\n> for incoming unknown payment hashes (probes or not).\n>\n> > we can improve it by using the `padding` of the `per_hop` field of the\n> > onion;\n>\n> I recently implemented a type of spontaneous payment [1] that works today\n> in\n> the wild (gotta love dat End to End Principle). A requirement for this was\n> fully functional EOB packing logic at the sender, and multi-packet\n> unwrapping at the receiver, the modified packet construction/processing can\n> be found here [2]. Using the terminology of the current draft code, all\n> that\n> would need to be done is specify an EOB type for this special probe type of\n> HTLC. As it doesn't need any additional data, it only consumes a single\n> pivot hop and doesn't require the route to be extended.\n>\n> Have you seen aj's prior post [3] on this front (making probe HTLCs\n> identifiable to the receiver, and allowing intermediate nodes to drop\n> them)?\n> Allowing intermediate nodes to identify probe HTLCs has privacy\n> implications, as all of a sudden we've created two path-level classes of\n> HTLCs. On the other hand, this may help with QoS scheduling on the\n> forwarding plane for nodes, they may want to prioritize actual payments\n> over\n> probes, with some nodes opting to not forward probes all together.\n>\n> [1]: https://github.com/lightningnetwork/lnd/pull/2455\n> [2]: https://github.com/lightningnetwork/lightning-onion/pull/31\n> [3]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001554.html\n>\n> -- Laolu\n>\n>\n> On Fri, Jan 18, 2019 at 8:47 AM Andrea RASPITZU <andrea.raspitzu at acinq.fr>\n> wrote:\n>\n>> Good morning list,\n>>\n>> I know there have been discussion around how (and if) we should probe the\n>> network to check for the liveliness of a path before sending out the\n>> payment. Currently we issue a payment with a random payment_hash that is\n>> not redeemable by anyone, if the destination (and the path) is `lively` it\n>> will respond Error. Assuming we do want to probe, and it make sense to\n>> assume so because it can't be prevented, we can improve it by using the\n>> `padding` of the `per_hop` field of the onion; with a single bit of the\n>> padding we can tell the final node that this is a probe and not an actual\n>> payment. This saves the receiving node from doing a database lookup\n>> (checking if it has the preimage for such a payment_hash) and it does not\n>> reveal anything to intermediate nodes, we don't want them to change the\n>> behavior if they know it's a probe and not an actual payment. I believe\n>> probing can help reducing the error rate of payments (and even detect stale\n>> channels?) and I'm looking forward to have some feedback, and submit a\n>> draft.\n>>\n>> Cheers, Andrea.\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190121/c1df59f1/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-01-21T23:15:59",
                "message_text_only": "This seems like a bad idea as it could create timing attacks to discover \nif a node is the target for a payment.\n\nMatt\n\nOn 1/18/19 9:06 PM, Olaoluwa Osuntokun wrote:\n> Nodes can and eventually should start using bloom filters to avoid most\n> database lookups for incoming payment hashes."
            }
        ],
        "thread_summary": {
            "title": "Network probes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Andrea RASPITZU",
                "Olaoluwa Osuntokun",
                "Matt Corallo"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 10041
        }
    },
    {
        "title": "[Lightning-dev] lightning-c RPC",
        "thread_messages": [
            {
                "author": "Alex P",
                "date": "2019-01-22T11:58:32",
                "message_text_only": "Hello guys!\n\nIs there a way to bind RPC to IP:port, not to unix socket?\n\nOf course, it's easy to patch source code, but may be there is a param\nfor config?\n\nThanks!"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-01-22T13:49:13",
                "message_text_only": "Hey Alex,\n\nI think this is currently not being implemented. Also there is a\nmailinglist particularly for issues related to c-lightning at:\nhttps://lists.ozlabs.org/listinfo/c-lightning and of course issues like\nthis could also be asked in the bug tracker at:\nhttps://github.com/ElementsProject/lightning\n\nwith kind regards Rene\n\nOn Tue, Jan 22, 2019 at 1:08 PM Alex P <ap at coinomat.com> wrote:\n\n> Hello guys!\n>\n> Is there a way to bind RPC to IP:port, not to unix socket?\n>\n> Of course, it's easy to patch source code, but may be there is a param\n> for config?\n>\n> Thanks!\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190122/315fa6cf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "lightning-c RPC",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Alex P",
                "Ren\u00e9 Pickhardt"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1211
        }
    },
    {
        "title": "[Lightning-dev] Unification of feature bits?",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2019-01-21T05:28:56",
                "message_text_only": "Hi all,\n\n        I have a concrete proposal for feature bits.\n\n1. Rename 'local features' to 'peer features'.\n2. Rename 'global features' to 'routing features'.\n3. Have them share a number space (ie. peer and routing features don't\n   overlap).\n4. Put both in `features` in node announcements, but never use even bits\n   for peer features.\n\nThis means we can both use node_announcement as \"connect to a peer which\nsupports feature X\" and \"can I route through this node?\".\n\nSimilarly, (future) DNS seed filtering might support filtering only by\npairs of bits (ie. give me peers which support X, even or odd).\n\nCheers,\nRusty."
            },
            {
                "author": "Fabrice Drouin",
                "date": "2019-01-25T16:55:19",
                "message_text_only": "On Mon, 21 Jan 2019 at 08:05, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n> Hi all,\n>\n>         I have a concrete proposal for feature bits.\n>\n> 1. Rename 'local features' to 'peer features'.\n> 2. Rename 'global features' to 'routing features'.\n> 3. Have them share a number space (ie. peer and routing features don't\n>    overlap).\n> 4. Put both in `features` in node announcements, but never use even bits\n>    for peer features.\n>\n> This means we can both use node_announcement as \"connect to a peer which\n> supports feature X\" and \"can I route through this node?\".\n\nUnification of feature bits makes sense but I don't really understand\nthe concept of `routing features` as opposed to `node features`. What\nwould prevent us from routing payments through a node ? (AMP ? changes\nto the onion packet ?)\nI find it easier to reason in terms of `node features`, which are\nadvertised in node announcements, and `peer/connection features`,\nwhich are a subset of `node features` applied to a specific\nconnection.\nNode features would be all the features that we have today\n(option_data_loss_protect, initial_routing_sync,\noption_upfront_shutdown_script, gossip_queries), since it makes sense\nto advertise them except maybe for initial_routing_sync, with the\naddition of wumbo which could only be optional.\n\nWhat is the rationale for not allowing even bits in peer features ? It\nmakes sense for node features, but there are cases where you may\nrequire specific features for a specific connection\n(option_data_loss_protect for example, or\noption_upfront_shutdown_script)\n\nCheers,\n\nFabrice\n\n\n\n\n> Similarly, (future) DNS seed filtering might support filtering only by\n> pairs of bits (ie. give me peers which support X, even or odd).\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-26T23:11:17",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> On Mon, 21 Jan 2019 at 08:05, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>\n>> Hi all,\n>>\n>>         I have a concrete proposal for feature bits.\n>>\n>> 1. Rename 'local features' to 'peer features'.\n>> 2. Rename 'global features' to 'routing features'.\n>> 3. Have them share a number space (ie. peer and routing features don't\n>>    overlap).\n>> 4. Put both in `features` in node announcements, but never use even bits\n>>    for peer features.\n>>\n>> This means we can both use node_announcement as \"connect to a peer which\n>> supports feature X\" and \"can I route through this node?\".\n>\n> Unification of feature bits makes sense but I don't really understand\n> the concept of `routing features` as opposed to `node features`. What\n> would prevent us from routing payments through a node ? (AMP ? changes\n> to the onion packet ?)\n\nThe most obvious one is a change to scriptless scripts, but any other\nchange from preimage to secret exchange would have the same properties.\nYou both need to know what nodes support it (if you want to use it), and\nwhat nodes require it (if you don't).\n\nSimilarly, any kind of mid-path splitting or combining feature.\n\nIt's unusual, though, which is why we don't have any yet.\n\n> I find it easier to reason in terms of `node features`, which are\n> advertised in node announcements, and `peer/connection features`,\n> which are a subset of `node features` applied to a specific\n> connection.\n>\n> Node features would be all the features that we have today\n> (option_data_loss_protect, initial_routing_sync,\n> option_upfront_shutdown_script, gossip_queries), since it makes sense\n> to advertise them except maybe for initial_routing_sync, with the\n> addition of wumbo which could only be optional.\n>\n> What is the rationale for not allowing even bits in peer features ? It\n> makes sense for node features, but there are cases where you may\n> require specific features for a specific connection\n> (option_data_loss_protect for example, or\n> option_upfront_shutdown_script)\n\nYou misunderstand.  You can put the even feature into peer_features on\nconnect (as now), but you only put the odd feature into node_announce.\n\nThat way, even if I don't understand the feature I can still route\nthrough you, which is correct.  If I try to connect to you I find out\nthat you have an unknown feature.\n\nThe alternative is to put a second bitmap (peer_features) into\nnode_announcement, of course.  But since we were discussing combining\nthe feature bits, this seemed the way to make it work.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Unification of feature bits?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Fabrice Drouin"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5139
        }
    },
    {
        "title": "[Lightning-dev] Lightning and the semantic web",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2019-01-21T06:17:31",
                "message_text_only": "Hi All\n\nI work on the solid project [1] and am very interested in the lightning\nnetwork.\n\nIn particular, I am looking at trying to create an integration between\nlightning (layer 2) and solid (layer 3?  web layer?).\n\nThe first step towards integration would be to port some of the lightning\nconcepts to the semantic web.  This is done by creating an ontology.\n\nDoes anyone know of any existing work in this area.  Alternatively, does\nanyone have an interest to collaborate on an ontology?\n\nBest\nMelvin\n\n[1] https://solid.mit.edu/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190121/0139602d/attachment.html>"
            },
            {
                "author": "Bretton Vine",
                "date": "2019-01-21T09:38:16",
                "message_text_only": "On 2019/01/21 08:17, Melvin Carvalho wrote:\n> The first step towards integration would be to port some of the lightning\n> concepts to the semantic web.\u00a0 This is done by creating an ontology.\n\nHow do we do that? Build a list of relevant concepts and create possible\nattributes and links between? i.e.\n\nnode\n  pubkey\n  ipaddress\n  numberchannels\n  channel\n  stateactive/stateclosed\n\nchannel\n  fundingtx\n  localbalance\n  remotebalance\n  closingfee\n  stateopen/stateclosed\n\nfundingtx\n  datetime\n  amount\n  fee\n\ntransaction\n  invoice\n  amount\n  destination\n  validtime\n\nchannelbreach\n  datetime\n  error\n  result\n\n-- \nregards, Bretton\nopenpgp: http://bretton.hivemind.net/bretton_vine.asc"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2019-01-22T14:22:40",
                "message_text_only": "On Mon, 21 Jan 2019 at 11:08, Bretton Vine <bretton at hivemind.net> wrote:\n\n> On 2019/01/21 08:17, Melvin Carvalho wrote:\n> > The first step towards integration would be to port some of the lightning\n> > concepts to the semantic web.  This is done by creating an ontology.\n>\n> How do we do that? Build a list of relevant concepts and create possible\n> attributes and links between? i.e.\n>\n\nExactly!  It's what is known as a vocabulary.  You define terms and link\nthem to other terms.\n\nNormally is starts from a use case, and then basically you come up with a\nnaming system that people agree on the names and store it somewhere.\n\n\n>\n> node\n>   pubkey\n>   ipaddress\n>   numberchannels\n>   channel\n>   stateactive/stateclosed\n>\n> channel\n>   fundingtx\n>   localbalance\n>   remotebalance\n>   closingfee\n>   stateopen/stateclosed\n>\n> fundingtx\n>   datetime\n>   amount\n>   fee\n>\n> transaction\n>   invoice\n>   amount\n>   destination\n>   validtime\n>\n> channelbreach\n>   datetime\n>   error\n>   result\n>\n\nReally good start, I'll try and go through these terms.\n\nAs I say, often we start with small common use cases then build up the set\nof terms.\n\nI have a couple of use cases in mind that others are interested in\n\n1) sending satoshis to an inbox\n2) the pay wall use case (like yalls) over ajax and maybe also on a normal\nURL\n\n\n>\n> --\n> regards, Bretton\n> openpgp: http://bretton.hivemind.net/bretton_vine.asc\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190122/5dd4baf1/attachment-0001.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-01-21T13:11:15",
                "message_text_only": "Dear Melvin,\n\nhave you looked into the W3C Payment Group?\nhttps://www.w3.org/TR/payment-request/ The entire field of semantic web\nkind of originated from W3C and they are working on a recommendation for\nbrowser vendors to enable a low level payment API.\n\nAlso there is LightningJoule that builds on top of webln. While this is not\nan otology it goes implicitly in a similar direction (c.f.:\nhttps://github.com/wbobeirne/webln and in particular this discussion:\nhttps://github.com/wbobeirne/webln/issues/1 in which Will said that in his\nthoughts webln is different to the W3C Payment Group.)\n\nI am looking forward to see your progress with integrating Lightning to the\nsemantic web!\n\nwith kind regards Rene\n\n\n\nOn Mon, Jan 21, 2019 at 7:17 AM Melvin Carvalho <melvincarvalho at gmail.com>\nwrote:\n\n> Hi All\n>\n> I work on the solid project [1] and am very interested in the lightning\n> network.\n>\n> In particular, I am looking at trying to create an integration between\n> lightning (layer 2) and solid (layer 3?  web layer?).\n>\n> The first step towards integration would be to port some of the lightning\n> concepts to the semantic web.  This is done by creating an ontology.\n>\n> Does anyone know of any existing work in this area.  Alternatively, does\n> anyone have an interest to collaborate on an ontology?\n>\n> Best\n> Melvin\n>\n> [1] https://solid.mit.edu/\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190121/bc0c5b29/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2019-01-22T14:19:29",
                "message_text_only": "On Mon, 21 Jan 2019 at 14:11, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\nwrote:\n\n> Dear Melvin,\n>\n> have you looked into the W3C Payment Group?\n> https://www.w3.org/TR/payment-request/ The entire field of semantic web\n> kind of originated from W3C and they are working on a recommendation for\n> browser vendors to enable a low level payment API.\n>\n\nYes I have.  Im a member of the community group.  The working group is more\naligned to the shopping cart experience, but I'm trying to evangelize\nlightning there too.\n\n\n>\n> Also there is LightningJoule that builds on top of webln.\n>\n\nI use it!\n\n\n> While this is not an otology it goes implicitly in a similar direction\n> (c.f.: https://github.com/wbobeirne/webln\n>\n\nLovely, I will read\n\n\n> and in particular this discussion:\n> https://github.com/wbobeirne/webln/issues/1 in which Will said that in\n> his thoughts webln is different to the W3C Payment Group.)\n>\n\nDitto!\n\nI know the w3c folks pretty well.  And we are talking about lightning more\nand more.\n\n\n>\n> I am looking forward to see your progress with integrating Lightning to\n> the semantic web!\n>\n\nThanks!\n\n\n>\n> with kind regards Rene\n>\n>\n>\n> On Mon, Jan 21, 2019 at 7:17 AM Melvin Carvalho <melvincarvalho at gmail.com>\n> wrote:\n>\n>> Hi All\n>>\n>> I work on the solid project [1] and am very interested in the lightning\n>> network.\n>>\n>> In particular, I am looking at trying to create an integration between\n>> lightning (layer 2) and solid (layer 3?  web layer?).\n>>\n>> The first step towards integration would be to port some of the lightning\n>> concepts to the semantic web.  This is done by creating an ontology.\n>>\n>> Does anyone know of any existing work in this area.  Alternatively, does\n>> anyone have an interest to collaborate on an ontology?\n>>\n>> Best\n>> Melvin\n>>\n>> [1] https://solid.mit.edu/\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190122/6c50d852/attachment.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2019-01-24T12:20:57",
                "message_text_only": "On Mon, 21 Jan 2019 at 14:11, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\nwrote:\n\n> Dear Melvin,\n>\n> have you looked into the W3C Payment Group?\n> https://www.w3.org/TR/payment-request/ The entire field of semantic web\n> kind of originated from W3C and they are working on a recommendation for\n> browser vendors to enable a low level payment API.\n>\n> Also there is LightningJoule that builds on top of webln. While this is\n> not an otology it goes implicitly in a similar direction (c.f.:\n> https://github.com/wbobeirne/webln and in particular this discussion:\n> https://github.com/wbobeirne/webln/issues/1 in which Will said that in\n> his thoughts webln is different to the W3C Payment Group.)\n>\n> I am looking forward to see your progress with integrating Lightning to\n> the semantic web!\n>\n> with kind regards Rene\n>\n\nMy first observation is these two data structures in lnd describe graph,\none for channels and one for nodes.  These seem to be two fundamental\nconcepts in lightning.\n\nChannel\n\n        {\n            \"channel_id\": \"615605565348708353\",\n            \"chan_point\":\n\"d8cfed73e0004fe1427d3045c5b20da0418f3cb803e8e35be48ee713aadbf56d:1\",\n            \"last_update\": 1548330355,\n            \"node1_pub\":\n\"024a2e265cd66066b78a788ae615acdc84b5b0dec9efac36d7ac87513015eaf6ed\",\n            \"node2_pub\":\n\"03e03c56bb540c36b9e77c2aea2bb6529b907ece6c1395228c05459af13d0e2a5c\",\n            \"capacity\": \"1000000\",\n            \"node1_policy\": {\n                \"time_lock_delta\": 144,\n                \"min_htlc\": \"1000\",\n                \"fee_base_msat\": \"1000\",\n                \"fee_rate_milli_msat\": \"1\",\n                \"disabled\": false\n            },\n            \"node2_policy\": {\n                \"time_lock_delta\": 144,\n                \"min_htlc\": \"1000\",\n                \"fee_base_msat\": \"1000\",\n                \"fee_rate_milli_msat\": \"1\",\n                \"disabled\": false\n            }\n        }\n\nNode\n\n        {\n            \"last_update\": 1547380072,\n            \"pub_key\":\n\"0200072fd301cb4a680f26d87c28b705ccd6a1d5b00f1b5efd7fe5f998f1bbb1f1\",\n            \"alias\": \"OutaSpace\",\n            \"addresses\": [\n                {\n                    \"network\": \"tcp\",\n                    \"addr\": \"46.163.78.93:9760\"\n                },\n                {\n                    \"network\": \"tcp\",\n                    \"addr\": \"[2a01:488:66:1000:2ea3:4e5d:0:1]:9760\"\n                },\n                {\n                    \"network\": \"tcp\",\n                    \"addr\": \"2dkobxxunnjatyph.onion:9760\"\n                },\n                {\n                    \"network\": \"tcp\",\n                    \"addr\":\n\"nzslu33ecbokyn32teza2peiiiuye43ftom7jvnuhsxdbg3vhw7w3aqd.onion:9760\"\n                }\n            ],\n            \"color\": \"#123456\"\n        },\n\nIt would be useful to write a vocab for these and then document what they\nmean.  It would then be possible to add markup to an explorer to make it\nself documenting.\n\nMy first question is : are these terms consistent across different\nimplementations e.g. c-lightning, eclair ?\n\n\n>\n>\n> On Mon, Jan 21, 2019 at 7:17 AM Melvin Carvalho <melvincarvalho at gmail.com>\n> wrote:\n>\n>> Hi All\n>>\n>> I work on the solid project [1] and am very interested in the lightning\n>> network.\n>>\n>> In particular, I am looking at trying to create an integration between\n>> lightning (layer 2) and solid (layer 3?  web layer?).\n>>\n>> The first step towards integration would be to port some of the lightning\n>> concepts to the semantic web.  This is done by creating an ontology.\n>>\n>> Does anyone know of any existing work in this area.  Alternatively, does\n>> anyone have an interest to collaborate on an ontology?\n>>\n>> Best\n>> Melvin\n>>\n>> [1] https://solid.mit.edu/\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190124/aefe082a/attachment.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-01-24T12:42:17",
                "message_text_only": "Dear Melvin,\n\nI believe the vocabulary is not consistent across implementations. For\nexample if you look at c lightning there is no such command `describegraph`\nbut there are the two commands `listnodes` and `listchannels` which should\ngive the same information. For both I have attached a sample output at the\nend of the mail to demonstrate how the naming of the vocabulary differs.\n\nSince the data of these commands is taken from the gossip store which\nstores the gossip messages I would suggest to take the vocabulary from the\nBOLT 07 which defines the gossip messages. Also this mailinglist is for\nprotocol development and the spec should be the authorative source for\nnaming:\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md\n\nThere are more terms specified in other bolts which could be a basis for a\nvocabulary. I have created an overview by hand and made a Pull Request to\nthe repository which has not been merged yet as it was the wish of the\ndevelopers to have such a list to be extracted automatically.\nStill this the overview in that pull request could serve as a basis for\nsuch a vocabulary :\nhttps://github.com/lightningnetwork/lightning-rfc/pull/458\n\nNow the example outputs from c-lightning we already that there are\ndifferences in naming. Take the identifier for a node for example:\n* BOLT07: node_id\n* LND: pub_key\n* clightning: nodeid\n\nexample outputs:\n\nlighting-cli listnodes\n {\n      \"nodeid\":\n\"02396bf51e81f8f67eaca3652271b4fe8d3f57bedb9578af711606391c5c66760e\",\n      \"alias\": \"PuraSloboda\",\n      \"color\": \"68f442\",\n      \"last_timestamp\": 1548200218,\n      \"globalfeatures\": \"\",\n      \"global_features\": \"\",\n      \"addresses\": [\n        {\n          \"type\": \"ipv4\",\n          \"address\": \"144.136.223.22\",\n          \"port\": 9735\n        }\n      ]\n    }\n\nlightning-cli listchannels\n{\n      \"source\":\n\"03bb88ccc444534da7b5b64b4f7b15e1eccb18e102db0e400d4b9cfe93763aa26d\",\n      \"destination\":\n\"0272045af48b9871013753f7cce1cf82ed80b97d669ca44709e01976a67df80adc\",\n      \"short_channel_id\": \"559893:1912:0\",\n      \"public\": true,\n      \"satoshis\": 47000,\n      \"message_flags\": 0,\n      \"channel_flags\": 1,\n      \"flags\": 1,\n      \"active\": true,\n      \"last_update\": 1548332847,\n      \"base_fee_millisatoshi\": 1000,\n      \"fee_per_millionth\": 1,\n      \"delay\": 144\n    }\n\nWith kind regards Rene\n\n\nOn Thu, Jan 24, 2019 at 1:21 PM Melvin Carvalho <melvincarvalho at gmail.com>\nwrote:\n\n>\n>\n> On Mon, 21 Jan 2019 at 14:11, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\n> wrote:\n>\n>> Dear Melvin,\n>>\n>> have you looked into the W3C Payment Group?\n>> https://www.w3.org/TR/payment-request/ The entire field of semantic web\n>> kind of originated from W3C and they are working on a recommendation for\n>> browser vendors to enable a low level payment API.\n>>\n>> Also there is LightningJoule that builds on top of webln. While this is\n>> not an otology it goes implicitly in a similar direction (c.f.:\n>> https://github.com/wbobeirne/webln and in particular this discussion:\n>> https://github.com/wbobeirne/webln/issues/1 in which Will said that in\n>> his thoughts webln is different to the W3C Payment Group.)\n>>\n>> I am looking forward to see your progress with integrating Lightning to\n>> the semantic web!\n>>\n>> with kind regards Rene\n>>\n>\n> My first observation is these two data structures in lnd describe graph,\n> one for channels and one for nodes.  These seem to be two fundamental\n> concepts in lightning.\n>\n> Channel\n>\n>         {\n>             \"channel_id\": \"615605565348708353\",\n>             \"chan_point\":\n> \"d8cfed73e0004fe1427d3045c5b20da0418f3cb803e8e35be48ee713aadbf56d:1\",\n>             \"last_update\": 1548330355,\n>             \"node1_pub\":\n> \"024a2e265cd66066b78a788ae615acdc84b5b0dec9efac36d7ac87513015eaf6ed\",\n>             \"node2_pub\":\n> \"03e03c56bb540c36b9e77c2aea2bb6529b907ece6c1395228c05459af13d0e2a5c\",\n>             \"capacity\": \"1000000\",\n>             \"node1_policy\": {\n>                 \"time_lock_delta\": 144,\n>                 \"min_htlc\": \"1000\",\n>                 \"fee_base_msat\": \"1000\",\n>                 \"fee_rate_milli_msat\": \"1\",\n>                 \"disabled\": false\n>             },\n>             \"node2_policy\": {\n>                 \"time_lock_delta\": 144,\n>                 \"min_htlc\": \"1000\",\n>                 \"fee_base_msat\": \"1000\",\n>                 \"fee_rate_milli_msat\": \"1\",\n>                 \"disabled\": false\n>             }\n>         }\n>\n> Node\n>\n>         {\n>             \"last_update\": 1547380072,\n>             \"pub_key\":\n> \"0200072fd301cb4a680f26d87c28b705ccd6a1d5b00f1b5efd7fe5f998f1bbb1f1\",\n>             \"alias\": \"OutaSpace\",\n>             \"addresses\": [\n>                 {\n>                     \"network\": \"tcp\",\n>                     \"addr\": \"46.163.78.93:9760\"\n>                 },\n>                 {\n>                     \"network\": \"tcp\",\n>                     \"addr\": \"[2a01:488:66:1000:2ea3:4e5d:0:1]:9760\"\n>                 },\n>                 {\n>                     \"network\": \"tcp\",\n>                     \"addr\": \"2dkobxxunnjatyph.onion:9760\"\n>                 },\n>                 {\n>                     \"network\": \"tcp\",\n>                     \"addr\":\n> \"nzslu33ecbokyn32teza2peiiiuye43ftom7jvnuhsxdbg3vhw7w3aqd.onion:9760\"\n>                 }\n>             ],\n>             \"color\": \"#123456\"\n>         },\n>\n> It would be useful to write a vocab for these and then document what they\n> mean.  It would then be possible to add markup to an explorer to make it\n> self documenting.\n>\n> My first question is : are these terms consistent across different\n> implementations e.g. c-lightning, eclair ?\n>\n>\n>>\n>>\n>> On Mon, Jan 21, 2019 at 7:17 AM Melvin Carvalho <melvincarvalho at gmail.com>\n>> wrote:\n>>\n>>> Hi All\n>>>\n>>> I work on the solid project [1] and am very interested in the lightning\n>>> network.\n>>>\n>>> In particular, I am looking at trying to create an integration between\n>>> lightning (layer 2) and solid (layer 3?  web layer?).\n>>>\n>>> The first step towards integration would be to port some of the\n>>> lightning concepts to the semantic web.  This is done by creating an\n>>> ontology.\n>>>\n>>> Does anyone know of any existing work in this area.  Alternatively, does\n>>> anyone have an interest to collaborate on an ontology?\n>>>\n>>> Best\n>>> Melvin\n>>>\n>>> [1] https://solid.mit.edu/\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>\n>>\n>> --\n>> https://www.rene-pickhardt.de\n>>\n>> Skype: rene.pickhardt\n>>\n>> mobile: +49 (0)176 5762 3618\n>>\n>\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190124/8007367f/attachment-0001.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2019-01-28T06:13:25",
                "message_text_only": "On Thu, 24 Jan 2019 at 13:42, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\nwrote:\n\n> Dear Melvin,\n>\n> I believe the vocabulary is not consistent across implementations. For\n> example if you look at c lightning there is no such command `describegraph`\n> but there are the two commands `listnodes` and `listchannels` which should\n> give the same information. For both I have attached a sample output at the\n> end of the mail to demonstrate how the naming of the vocabulary differs.\n>\n> Since the data of these commands is taken from the gossip store which\n> stores the gossip messages I would suggest to take the vocabulary from the\n> BOLT 07 which defines the gossip messages. Also this mailinglist is for\n> protocol development and the spec should be the authorative source for\n> naming:\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md\n>\n> There are more terms specified in other bolts which could be a basis for a\n> vocabulary. I have created an overview by hand and made a Pull Request to\n> the repository which has not been merged yet as it was the wish of the\n> developers to have such a list to be extracted automatically.\n> Still this the overview in that pull request could serve as a basis for\n> such a vocabulary :\n> https://github.com/lightningnetwork/lightning-rfc/pull/458\n>\n> Now the example outputs from c-lightning we already that there are\n> differences in naming. Take the identifier for a node for example:\n> * BOLT07: node_id\n> * LND: pub_key\n> * clightning: nodeid\n>\n> example outputs:\n>\n> lighting-cli listnodes\n>  {\n>       \"nodeid\":\n> \"02396bf51e81f8f67eaca3652271b4fe8d3f57bedb9578af711606391c5c66760e\",\n>       \"alias\": \"PuraSloboda\",\n>       \"color\": \"68f442\",\n>       \"last_timestamp\": 1548200218,\n>       \"globalfeatures\": \"\",\n>       \"global_features\": \"\",\n>       \"addresses\": [\n>         {\n>           \"type\": \"ipv4\",\n>           \"address\": \"144.136.223.22\",\n>           \"port\": 9735\n>         }\n>       ]\n>     }\n>\n> lightning-cli listchannels\n> {\n>       \"source\":\n> \"03bb88ccc444534da7b5b64b4f7b15e1eccb18e102db0e400d4b9cfe93763aa26d\",\n>       \"destination\":\n> \"0272045af48b9871013753f7cce1cf82ed80b97d669ca44709e01976a67df80adc\",\n>       \"short_channel_id\": \"559893:1912:0\",\n>       \"public\": true,\n>       \"satoshis\": 47000,\n>       \"message_flags\": 0,\n>       \"channel_flags\": 1,\n>       \"flags\": 1,\n>       \"active\": true,\n>       \"last_update\": 1548332847,\n>       \"base_fee_millisatoshi\": 1000,\n>       \"fee_per_millionth\": 1,\n>       \"delay\": 144\n>     }\n>\n> With kind regards Rene\n>\n\nThis is extremely helpful, thank you!\n\nI will go with the RFC naming then.  I'm starting with Nodes and Edges and\nwill put together a document and demo for review.  First step is to do\nNodes.\n\nI have two questions\n\n1. node_id -- that's basically your public key -- what types of key and\nserialization is this (my guess an ecdsa pub key derived from the HD seed),\nany pointers would be great\n\n2. regarding the four address types :\n\n   - 1: ipv4; data = [4:ipv4_addr][2:port] (length 6)\n   - 2: ipv6; data = [16:ipv6_addr][2:port] (length 18)\n   - 3: Tor v2 onion service; data = [10:onion_addr][2:port] (length 12)\n      - version 2 onion service addresses; Encodes an 80-bit, truncated\n      SHA-1 hash of a 1024-bit RSA public key for the onion service (a.k.a.\n      Tor hidden service).\n   - 4: Tor v3 onion service; data = [35:onion_addr][2:port] (length 37)\n      - version 3 (prop224\n      <https://gitweb.torproject.org/torspec.git/tree/proposals/224-rend-spec-ng.txt>)\n      onion service addresses; Encodes: [32:32_byte_ed25519_pubkey] ||\n      [2:checksum] || [1:version], where checksum = sha3(\".onion checksum\"\n      | pubkey || version)[:2].\n\n\nThese can be looked up in the spec.  But in the semantic web we like, where\npossible, to have self describing data.  In particular we like URIs with a\nscheme or protocol so instead of example.com we'll have http://example.com\n\nIn this context would the scheme be lightning: for all 4 address types, or\nis that just for bolt11?\n\n\n\n>\n> On Thu, Jan 24, 2019 at 1:21 PM Melvin Carvalho <melvincarvalho at gmail.com>\n> wrote:\n>\n>>\n>>\n>> On Mon, 21 Jan 2019 at 14:11, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\n>> wrote:\n>>\n>>> Dear Melvin,\n>>>\n>>> have you looked into the W3C Payment Group?\n>>> https://www.w3.org/TR/payment-request/ The entire field of semantic web\n>>> kind of originated from W3C and they are working on a recommendation for\n>>> browser vendors to enable a low level payment API.\n>>>\n>>> Also there is LightningJoule that builds on top of webln. While this is\n>>> not an otology it goes implicitly in a similar direction (c.f.:\n>>> https://github.com/wbobeirne/webln and in particular this discussion:\n>>> https://github.com/wbobeirne/webln/issues/1 in which Will said that in\n>>> his thoughts webln is different to the W3C Payment Group.)\n>>>\n>>> I am looking forward to see your progress with integrating Lightning to\n>>> the semantic web!\n>>>\n>>> with kind regards Rene\n>>>\n>>\n>> My first observation is these two data structures in lnd describe graph,\n>> one for channels and one for nodes.  These seem to be two fundamental\n>> concepts in lightning.\n>>\n>> Channel\n>>\n>>         {\n>>             \"channel_id\": \"615605565348708353\",\n>>             \"chan_point\":\n>> \"d8cfed73e0004fe1427d3045c5b20da0418f3cb803e8e35be48ee713aadbf56d:1\",\n>>             \"last_update\": 1548330355,\n>>             \"node1_pub\":\n>> \"024a2e265cd66066b78a788ae615acdc84b5b0dec9efac36d7ac87513015eaf6ed\",\n>>             \"node2_pub\":\n>> \"03e03c56bb540c36b9e77c2aea2bb6529b907ece6c1395228c05459af13d0e2a5c\",\n>>             \"capacity\": \"1000000\",\n>>             \"node1_policy\": {\n>>                 \"time_lock_delta\": 144,\n>>                 \"min_htlc\": \"1000\",\n>>                 \"fee_base_msat\": \"1000\",\n>>                 \"fee_rate_milli_msat\": \"1\",\n>>                 \"disabled\": false\n>>             },\n>>             \"node2_policy\": {\n>>                 \"time_lock_delta\": 144,\n>>                 \"min_htlc\": \"1000\",\n>>                 \"fee_base_msat\": \"1000\",\n>>                 \"fee_rate_milli_msat\": \"1\",\n>>                 \"disabled\": false\n>>             }\n>>         }\n>>\n>> Node\n>>\n>>         {\n>>             \"last_update\": 1547380072,\n>>             \"pub_key\":\n>> \"0200072fd301cb4a680f26d87c28b705ccd6a1d5b00f1b5efd7fe5f998f1bbb1f1\",\n>>             \"alias\": \"OutaSpace\",\n>>             \"addresses\": [\n>>                 {\n>>                     \"network\": \"tcp\",\n>>                     \"addr\": \"46.163.78.93:9760\"\n>>                 },\n>>                 {\n>>                     \"network\": \"tcp\",\n>>                     \"addr\": \"[2a01:488:66:1000:2ea3:4e5d:0:1]:9760\"\n>>                 },\n>>                 {\n>>                     \"network\": \"tcp\",\n>>                     \"addr\": \"2dkobxxunnjatyph.onion:9760\"\n>>                 },\n>>                 {\n>>                     \"network\": \"tcp\",\n>>                     \"addr\":\n>> \"nzslu33ecbokyn32teza2peiiiuye43ftom7jvnuhsxdbg3vhw7w3aqd.onion:9760\"\n>>                 }\n>>             ],\n>>             \"color\": \"#123456\"\n>>         },\n>>\n>> It would be useful to write a vocab for these and then document what they\n>> mean.  It would then be possible to add markup to an explorer to make it\n>> self documenting.\n>>\n>> My first question is : are these terms consistent across different\n>> implementations e.g. c-lightning, eclair ?\n>>\n>>\n>>>\n>>>\n>>> On Mon, Jan 21, 2019 at 7:17 AM Melvin Carvalho <\n>>> melvincarvalho at gmail.com> wrote:\n>>>\n>>>> Hi All\n>>>>\n>>>> I work on the solid project [1] and am very interested in the lightning\n>>>> network.\n>>>>\n>>>> In particular, I am looking at trying to create an integration between\n>>>> lightning (layer 2) and solid (layer 3?  web layer?).\n>>>>\n>>>> The first step towards integration would be to port some of the\n>>>> lightning concepts to the semantic web.  This is done by creating an\n>>>> ontology.\n>>>>\n>>>> Does anyone know of any existing work in this area.  Alternatively,\n>>>> does anyone have an interest to collaborate on an ontology?\n>>>>\n>>>> Best\n>>>> Melvin\n>>>>\n>>>> [1] https://solid.mit.edu/\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>>\n>>>\n>>> --\n>>> https://www.rene-pickhardt.de\n>>>\n>>> Skype: rene.pickhardt\n>>>\n>>> mobile: +49 (0)176 5762 3618\n>>>\n>>\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n>\n> mobile: +49 (0)176 5762 3618\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190128/0f8993e4/attachment-0001.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-01-28T11:02:59",
                "message_text_only": "Dear Melvin,\n\nI believe the scheme lightning: should only apply\n* for payments in the form of bolt11 strings\n* to identifiy nodes like lightning:node_id at ipaddr:port\n* maybe to identify channels (look up the short_channel_id of the form of a\ntriple separated by the letterx.  BLOCKHEIGHTxTXINDEXxOUTPUTINDEX)\n\nthe orther addresses you mentioned already have a sceme e.g. tcp:\n\nkeep in mind that the ip address and port may change but the only real\nidentifier is the node_id which as you mentioned correctly is the pubkey\nfrom an HD seed and it is bech32 encoded. Also the short channel id points\nto a funding transaction on the base layer so implicitly to identify the\nbase layer transaction we do also need the SHA-256 hash of the genesis\nblock otherwise it is not clear that the blockheigt, txindex, output index\ntriple belongs specifically to the bitcoin blockchain.\n\nwith kind regards Rene\n\n\nOn Mon, Jan 28, 2019 at 7:13 AM Melvin Carvalho <melvincarvalho at gmail.com>\nwrote:\n\n>\n>\n> On Thu, 24 Jan 2019 at 13:42, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\n> wrote:\n>\n>> Dear Melvin,\n>>\n>> I believe the vocabulary is not consistent across implementations. For\n>> example if you look at c lightning there is no such command `describegraph`\n>> but there are the two commands `listnodes` and `listchannels` which should\n>> give the same information. For both I have attached a sample output at the\n>> end of the mail to demonstrate how the naming of the vocabulary differs.\n>>\n>> Since the data of these commands is taken from the gossip store which\n>> stores the gossip messages I would suggest to take the vocabulary from the\n>> BOLT 07 which defines the gossip messages. Also this mailinglist is for\n>> protocol development and the spec should be the authorative source for\n>> naming:\n>> https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md\n>>\n>> There are more terms specified in other bolts which could be a basis for\n>> a vocabulary. I have created an overview by hand and made a Pull Request to\n>> the repository which has not been merged yet as it was the wish of the\n>> developers to have such a list to be extracted automatically.\n>> Still this the overview in that pull request could serve as a basis for\n>> such a vocabulary :\n>> https://github.com/lightningnetwork/lightning-rfc/pull/458\n>>\n>> Now the example outputs from c-lightning we already that there are\n>> differences in naming. Take the identifier for a node for example:\n>> * BOLT07: node_id\n>> * LND: pub_key\n>> * clightning: nodeid\n>>\n>> example outputs:\n>>\n>> lighting-cli listnodes\n>>  {\n>>       \"nodeid\":\n>> \"02396bf51e81f8f67eaca3652271b4fe8d3f57bedb9578af711606391c5c66760e\",\n>>       \"alias\": \"PuraSloboda\",\n>>       \"color\": \"68f442\",\n>>       \"last_timestamp\": 1548200218,\n>>       \"globalfeatures\": \"\",\n>>       \"global_features\": \"\",\n>>       \"addresses\": [\n>>         {\n>>           \"type\": \"ipv4\",\n>>           \"address\": \"144.136.223.22\",\n>>           \"port\": 9735\n>>         }\n>>       ]\n>>     }\n>>\n>> lightning-cli listchannels\n>> {\n>>       \"source\":\n>> \"03bb88ccc444534da7b5b64b4f7b15e1eccb18e102db0e400d4b9cfe93763aa26d\",\n>>       \"destination\":\n>> \"0272045af48b9871013753f7cce1cf82ed80b97d669ca44709e01976a67df80adc\",\n>>       \"short_channel_id\": \"559893:1912:0\",\n>>       \"public\": true,\n>>       \"satoshis\": 47000,\n>>       \"message_flags\": 0,\n>>       \"channel_flags\": 1,\n>>       \"flags\": 1,\n>>       \"active\": true,\n>>       \"last_update\": 1548332847,\n>>       \"base_fee_millisatoshi\": 1000,\n>>       \"fee_per_millionth\": 1,\n>>       \"delay\": 144\n>>     }\n>>\n>> With kind regards Rene\n>>\n>\n> This is extremely helpful, thank you!\n>\n> I will go with the RFC naming then.  I'm starting with Nodes and Edges and\n> will put together a document and demo for review.  First step is to do\n> Nodes.\n>\n> I have two questions\n>\n> 1. node_id -- that's basically your public key -- what types of key and\n> serialization is this (my guess an ecdsa pub key derived from the HD seed),\n> any pointers would be great\n>\n> 2. regarding the four address types :\n>\n>    - 1: ipv4; data = [4:ipv4_addr][2:port] (length 6)\n>    - 2: ipv6; data = [16:ipv6_addr][2:port] (length 18)\n>    - 3: Tor v2 onion service; data = [10:onion_addr][2:port] (length 12)\n>       - version 2 onion service addresses; Encodes an 80-bit, truncated\n>       SHA-1 hash of a 1024-bit RSA public key for the onion service\n>       (a.k.a. Tor hidden service).\n>    - 4: Tor v3 onion service; data = [35:onion_addr][2:port] (length 37)\n>       - version 3 (prop224\n>       <https://gitweb.torproject.org/torspec.git/tree/proposals/224-rend-spec-ng.txt>)\n>       onion service addresses; Encodes: [32:32_byte_ed25519_pubkey] ||\n>       [2:checksum] || [1:version], where checksum = sha3(\".onion\n>       checksum\" | pubkey || version)[:2].\n>\n>\n> These can be looked up in the spec.  But in the semantic web we like,\n> where possible, to have self describing data.  In particular we like URIs\n> with a scheme or protocol so instead of example.com we'll have\n> http://example.com\n>\n> In this context would the scheme be lightning: for all 4 address types, or\n> is that just for bolt11?\n>\n>\n>\n>>\n>> On Thu, Jan 24, 2019 at 1:21 PM Melvin Carvalho <melvincarvalho at gmail.com>\n>> wrote:\n>>\n>>>\n>>>\n>>> On Mon, 21 Jan 2019 at 14:11, Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>\n>>> wrote:\n>>>\n>>>> Dear Melvin,\n>>>>\n>>>> have you looked into the W3C Payment Group?\n>>>> https://www.w3.org/TR/payment-request/ The entire field of semantic\n>>>> web kind of originated from W3C and they are working on a recommendation\n>>>> for browser vendors to enable a low level payment API.\n>>>>\n>>>> Also there is LightningJoule that builds on top of webln. While this is\n>>>> not an otology it goes implicitly in a similar direction (c.f.:\n>>>> https://github.com/wbobeirne/webln and in particular this discussion:\n>>>> https://github.com/wbobeirne/webln/issues/1 in which Will said that in\n>>>> his thoughts webln is different to the W3C Payment Group.)\n>>>>\n>>>> I am looking forward to see your progress with integrating Lightning to\n>>>> the semantic web!\n>>>>\n>>>> with kind regards Rene\n>>>>\n>>>\n>>> My first observation is these two data structures in lnd describe graph,\n>>> one for channels and one for nodes.  These seem to be two fundamental\n>>> concepts in lightning.\n>>>\n>>> Channel\n>>>\n>>>         {\n>>>             \"channel_id\": \"615605565348708353\",\n>>>             \"chan_point\":\n>>> \"d8cfed73e0004fe1427d3045c5b20da0418f3cb803e8e35be48ee713aadbf56d:1\",\n>>>             \"last_update\": 1548330355,\n>>>             \"node1_pub\":\n>>> \"024a2e265cd66066b78a788ae615acdc84b5b0dec9efac36d7ac87513015eaf6ed\",\n>>>             \"node2_pub\":\n>>> \"03e03c56bb540c36b9e77c2aea2bb6529b907ece6c1395228c05459af13d0e2a5c\",\n>>>             \"capacity\": \"1000000\",\n>>>             \"node1_policy\": {\n>>>                 \"time_lock_delta\": 144,\n>>>                 \"min_htlc\": \"1000\",\n>>>                 \"fee_base_msat\": \"1000\",\n>>>                 \"fee_rate_milli_msat\": \"1\",\n>>>                 \"disabled\": false\n>>>             },\n>>>             \"node2_policy\": {\n>>>                 \"time_lock_delta\": 144,\n>>>                 \"min_htlc\": \"1000\",\n>>>                 \"fee_base_msat\": \"1000\",\n>>>                 \"fee_rate_milli_msat\": \"1\",\n>>>                 \"disabled\": false\n>>>             }\n>>>         }\n>>>\n>>> Node\n>>>\n>>>         {\n>>>             \"last_update\": 1547380072,\n>>>             \"pub_key\":\n>>> \"0200072fd301cb4a680f26d87c28b705ccd6a1d5b00f1b5efd7fe5f998f1bbb1f1\",\n>>>             \"alias\": \"OutaSpace\",\n>>>             \"addresses\": [\n>>>                 {\n>>>                     \"network\": \"tcp\",\n>>>                     \"addr\": \"46.163.78.93:9760\"\n>>>                 },\n>>>                 {\n>>>                     \"network\": \"tcp\",\n>>>                     \"addr\": \"[2a01:488:66:1000:2ea3:4e5d:0:1]:9760\"\n>>>                 },\n>>>                 {\n>>>                     \"network\": \"tcp\",\n>>>                     \"addr\": \"2dkobxxunnjatyph.onion:9760\"\n>>>                 },\n>>>                 {\n>>>                     \"network\": \"tcp\",\n>>>                     \"addr\":\n>>> \"nzslu33ecbokyn32teza2peiiiuye43ftom7jvnuhsxdbg3vhw7w3aqd.onion:9760\"\n>>>                 }\n>>>             ],\n>>>             \"color\": \"#123456\"\n>>>         },\n>>>\n>>> It would be useful to write a vocab for these and then document what\n>>> they mean.  It would then be possible to add markup to an explorer to make\n>>> it self documenting.\n>>>\n>>> My first question is : are these terms consistent across different\n>>> implementations e.g. c-lightning, eclair ?\n>>>\n>>>\n>>>>\n>>>>\n>>>> On Mon, Jan 21, 2019 at 7:17 AM Melvin Carvalho <\n>>>> melvincarvalho at gmail.com> wrote:\n>>>>\n>>>>> Hi All\n>>>>>\n>>>>> I work on the solid project [1] and am very interested in the\n>>>>> lightning network.\n>>>>>\n>>>>> In particular, I am looking at trying to create an integration between\n>>>>> lightning (layer 2) and solid (layer 3?  web layer?).\n>>>>>\n>>>>> The first step towards integration would be to port some of the\n>>>>> lightning concepts to the semantic web.  This is done by creating an\n>>>>> ontology.\n>>>>>\n>>>>> Does anyone know of any existing work in this area.  Alternatively,\n>>>>> does anyone have an interest to collaborate on an ontology?\n>>>>>\n>>>>> Best\n>>>>> Melvin\n>>>>>\n>>>>> [1] https://solid.mit.edu/\n>>>>> _______________________________________________\n>>>>> Lightning-dev mailing list\n>>>>> Lightning-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>>\n>>>>\n>>>>\n>>>> --\n>>>> https://www.rene-pickhardt.de\n>>>>\n>>>> Skype: rene.pickhardt\n>>>>\n>>>> mobile: +49 (0)176 5762 3618\n>>>>\n>>>\n>>\n>> --\n>> https://www.rene-pickhardt.de\n>>\n>> Skype: rene.pickhardt\n>>\n>> mobile: +49 (0)176 5762 3618\n>>\n>\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190128/f3c7bdb1/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning and the semantic web",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bretton Vine",
                "Ren\u00e9 Pickhardt",
                "Melvin Carvalho"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 37283
        }
    },
    {
        "title": "[Lightning-dev] Lightning network user identification",
        "thread_messages": [
            {
                "author": "Joao Joyce",
                "date": "2019-01-26T21:09:23",
                "message_text_only": "Hi all,\n\nI was wondering if there is a way to identify a user across multiple LN requests or even authenticate the user in a single step using a LN wallet.\n\nSome use cases.\n\n  *   A company advertising a pay-per-view event could make billboards/posters with LN QR-codes. By scanning the code on the billboard the user would buy the right to see the event later that night. This would happen in just one step, no need for login, just like a regular LN payment.\n  *   A music-streaming company could print QR-codes on posters. By scanning the code the user would imediately get the album on the music-streaming app on his phone.\n  *   A user could anonymously get frequent-user discounts or reward points on vending machines or similar services.\n  *   An arcade game like this one (https://www.youtube.com/watch?v=U0KUNbjFZdk) could identify the user across multiple plays and different machines and provide the user with high-scores and user performance statistics.\n  *   Arcade games could provide multi player gaming keeping user identity, scores, in-game items, etc...\n\nIs this currently possible?\n\nThank you,\nJo\u00e3o Joyce\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190126/0b295e12/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-27T16:13:12",
                "message_text_only": "Good morning Joao,\n\nCurrently no.\nAlso, why would you want to violate user privacy in exchange for a service?\nYou should authorize usage depending on secrets the user knows, not depending on their \"identity\".\n\nThis is precisely why LN is set up to use zero-knowledge contingent payments.\nYou release a secret in exchange for money.\nThen, you authorize the service (streaming data, discount, etc) if someone is able to present proof that they know that secret.\n\nI admit the current proof-of-payment is limited, especially since the secret is sent to each intermediate node.\nHowever, use of payment points and scalars (instead of hashes and preimages) will eventually be deployed, which would hide the secret being paid for from the intermediate nodes.\nIn addition, proof of knowledge of a secret is simply a signature algorithm (points are public keys, scalars are secret keys).\n\n>From this point of view, your \"user\" is simply someone who knows the secret that you released when you were paid for your service.\nPhysical instances of humanity should be allowed to share a single \"user\", or have multiple \"users\"; you will be paid according to your service anyway.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, January 27, 2019 5:09 AM, Joao Joyce <joao.joyce at netcabo.pt> wrote:\n\n> Hi all,\n>\n> I was wondering if there is a way to identify a user across multiple LN requests or even authenticate the user in a single step using a LN wallet.\n>\n> Some use cases.\n>\n> -   A companyadvertising a pay-per-view event could make billboards/posters with LN QR-codes.\u00a0By scanning the code on the billboard the user would buy the right to see the event later that night. This would happen in just one step, no need for login, just like a regular LN payment.\n> -   A music-streaming company could print QR-codes on posters. By scanning the code the user would imediately get the album on the music-streaming app on his phone.\n> -   A user could anonymously get frequent-user discounts or reward points on vending machines or similar services.\n> -   An arcade game like this one (https://www.youtube.com/watch?v=U0KUNbjFZdk) could identify the user across multiple plays and different machines and provide the user with high-scores and user performance statistics.\n> -   Arcade games could provide multi player gaming keeping user identity, scores, in-game items, etc...\n>\n> Is this currently possible?\n>\n> Thank you,\n> Jo\u00e3o Joyce"
            },
            {
                "author": "Joao Joyce",
                "date": "2019-01-28T01:13:14",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you for your thoughtfull input.\n\nLet me just clarify that I share the same concerns regarding user privacy. I do value all the work that\u2019s being done to keep the LN private, trustless and permissionless.\n\nMy intention is not to violate user privacy but to give an option for a user to opt-in on keeping and proving a single identity across multiple payments for the same store (different stores would have different IDs, kind of like what happens in SQRL).\n\nThis would not be something that would happen by default or on most LN payment, but on specific payments.\n\nThe wallet would always make the user aware of it. You could probably even opt-in/out of this feature on the moment the payment is made.\n\nIn certain cases I believe this could enable a higher level of privacy and a smooth transition to better authentication practices.\n\nFor instance, I\u2019ve implement a simple PoC service, where a user can go to an ebook store and pay a LN invoice to buy an ebook directly on the ereader device (https://youtu.be/b1w-W6oMb_M).\n\nBut then I was thinking that I eventually would need to have a way to let the user prove that he had already bought a book in order to redownload it. Authenticating the user and keeping a user account immediately comes to mind. Users are used to it.\n\nBut now I would have to make the user go through a create account/login flow, eventually asking more personal info like emails and passwords, keeping that data safe, etc...I don\u2019t want none of that private data!\n\nAlso I would have to write more code...\n\nEventually I could use something like SQRL or BitID which enable some level of anonymity. But now the user would have to keep an app for login and another for payments. He is expected to have both apps to use the service and keep both private keys secure. Both would use QR codes which makes for a lot of confusion and a terrible user experience. Of course I would have to eventually code the email/password anyway as a fall back.\n\nContrast this scenario with this one which is basically identical to the one in the video:\n1 - User goes to the ebook store.\n2 - User selects the book he wants and scan a LN invoice.\n3 - Wallet shows payment info and asks if user wants to provide his identity.\n4 - User confirms payment and identity in the same action.\n\nThere was no need for the user to create an account or to log in to the service. And no need for the store to keep any private data, just a unique userID that is only valid for that particular store.\n\nOn the larger picture I was thinking that the standardization of such a payment/auth flow could enable services to easily transition from email/password flows to a more anonymous and secure method of private and public keys and that all those capabilities would come for free for every LN user and every LN store.\n\nAlso new use cases like the ones described in the previous email would become possible.\n\nSimple LN payments would coexist with this method. Private, anonymous, non-tracking and perfect as they are.\n\nThanks,\nJo\u00e3o Joyce\n________________________________\nDe: ZmnSCPxj <ZmnSCPxj at protonmail.com>\nEnviado: 27 de janeiro de 2019 16:13:12\nPara: Joao Joyce\nCc: lightning-dev at lists.linuxfoundation.org\nAssunto: Re: [Lightning-dev] Lightning network user identification\n\nGood morning Joao,\n\nCurrently no.\nAlso, why would you want to violate user privacy in exchange for a service?\nYou should authorize usage depending on secrets the user knows, not depending on their \"identity\".\n\nThis is precisely why LN is set up to use zero-knowledge contingent payments.\nYou release a secret in exchange for money.\nThen, you authorize the service (streaming data, discount, etc) if someone is able to present proof that they know that secret.\n\nI admit the current proof-of-payment is limited, especially since the secret is sent to each intermediate node.\nHowever, use of payment points and scalars (instead of hashes and preimages) will eventually be deployed, which would hide the secret being paid for from the intermediate nodes.\nIn addition, proof of knowledge of a secret is simply a signature algorithm (points are public keys, scalars are secret keys).\n\nFrom this point of view, your \"user\" is simply someone who knows the secret that you released when you were paid for your service.\nPhysical instances of humanity should be allowed to share a single \"user\", or have multiple \"users\"; you will be paid according to your service anyway.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, January 27, 2019 5:09 AM, Joao Joyce <joao.joyce at netcabo.pt> wrote:\n\n> Hi all,\n>\n> I was wondering if there is a way to identify a user across multiple LN requests or even authenticate the user in a single step using a LN wallet.\n>\n> Some use cases.\n>\n> -   A companyadvertising a pay-per-view event could make billboards/posters with LN QR-codes. By scanning the code on the billboard the user would buy the right to see the event later that night. This would happen in just one step, no need for login, just like a regular LN payment.\n> -   A music-streaming company could print QR-codes on posters. By scanning the code the user would imediately get the album on the music-streaming app on his phone.\n> -   A user could anonymously get frequent-user discounts or reward points on vending machines or similar services.\n> -   An arcade game like this one (https://www.youtube.com/watch?v=U0KUNbjFZdk) could identify the user across multiple plays and different machines and provide the user with high-scores and user performance statistics.\n> -   Arcade games could provide multi player gaming keeping user identity, scores, in-game items, etc...\n>\n> Is this currently possible?\n>\n> Thank you,\n> Jo\u00e3o Joyce\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190128/280d88b2/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-28T01:21:13",
                "message_text_only": "Good morning Joao,\n\n\n>\n> Eventually I could use something like SQRL or BitID which enable some level of anonymity. But now the user would have to keep an app for login and another for payments. He is expected to have both apps to use the service and keep both private keys secure. Both would use QR codes which makes for a lot of confusion and a terrible user experience. Of course I would have to eventually code the email/password anyway as a fall back.\n>\n> Contrast this scenario with this one which is basically identical to the one in the video:\n> 1 - User goes to the ebook store.\n> 2 - User selects the book he wants and scan a LN invoice.\n> 3 - Wallet shows payment info and asks if user wants to provide his identity.\n> 4 - User confirms payment and identity in the same action.\n>\n> There was no need for the user to create an account or to log in to the service. And no need for the store to keep any private data, just a unique userID that is only valid for that particular store.\n\nWhy is not the proof-of-payment sufficient?\nService generates a secret, user pays for the secret, proof of knowledge of secret authorizes use of the book.\n\nIn short, use the payment preimage as \"unique userID\".\nYou also automatically ensure that userIDs are usable only if paid for.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Joao Joyce",
                "date": "2019-01-28T02:39:13",
                "message_text_only": "Ok, that would work for this particular case which is of course a very simple PoC. But the problem of connecting multiple payments to a user account still stands, or am I missing something?\n\nAnd the user would also be required to keep a copy of the pre-image for every bought item right? It feels like just holding a priv key should be enough to get all my books, items, account info...\n\nI get that there might be implementation and UX issues around something like this but I\u2019m not seeing the privacy risks around it.\n\nWhy should some of these use cases be ruled out preventively and not just pass that responsibility to the user who might benefit from them?\n\nAs a user I think I wouldn\u2019t mind giving permission for a service to keep my high scores or all the books I got, or all the music I bought in the same account...\n\nAnd if that can be done in a single step, opted-in and I don\u2019t even need to provide any personal info that could lead to my \u201chuman identity\u201d even better! That would be a major improvement from most services now who force you to have an email account which can most of the time give a lot of information about someone and provide them a password which, who knows what they do with it and how they store it...\n\n________________________________\nDe: ZmnSCPxj <ZmnSCPxj at protonmail.com>\nEnviado: 28 de janeiro de 2019 01:21:13\nPara: Joao Joyce\nCc: lightning-dev at lists.linuxfoundation.org\nAssunto: Re: [Lightning-dev] Lightning network user identification\n\nGood morning Joao,\n\n\n>\n> Eventually I could use something like SQRL or BitID which enable some level of anonymity. But now the user would have to keep an app for login and another for payments. He is expected to have both apps to use the service and keep both private keys secure. Both would use QR codes which makes for a lot of confusion and a terrible user experience. Of course I would have to eventually code the email/password anyway as a fall back.\n>\n> Contrast this scenario with this one which is basically identical to the one in the video:\n> 1 - User goes to the ebook store.\n> 2 - User selects the book he wants and scan a LN invoice.\n> 3 - Wallet shows payment info and asks if user wants to provide his identity.\n> 4 - User confirms payment and identity in the same action.\n>\n> There was no need for the user to create an account or to log in to the service. And no need for the store to keep any private data, just a unique userID that is only valid for that particular store.\n\nWhy is not the proof-of-payment sufficient?\nService generates a secret, user pays for the secret, proof of knowledge of secret authorizes use of the book.\n\nIn short, use the payment preimage as \"unique userID\".\nYou also automatically ensure that userIDs are usable only if paid for.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190128/fd09c7c4/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-29T06:55:53",
                "message_text_only": "Good morning Joao?\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, January 28, 2019 10:39 AM, Joao Joyce <joao.joyce at netcabo.pt> wrote:\n\n> Ok, that would work for this particular case which is of course a very simple PoC. But the problem of connecting multiple payments to a user account still stands, or am I missing something?\n\nWhy does the *service* need to connect multiple payments to a user account?\n\n>\n> And the user would also be required to keep a copy of the pre-image for every bought item right? It feels like just holding a priv key should be enough to get all my books, items, account info...\n\nMake the user software record locally on the user's device, encrypted with the user's priv key.\nWhy should the service do this?\nThe entire point of Bitcoin and Lightning is for each entity to be able to stand for itself.\n\nIn short, let the user software handle management of all the preimages for all items it bought.\nThe \"user identity\" is thus a virtual one that is created by the user software.\nSimilarly, a \"Bitcoin wallet\" is a virtual wallet created by the user software; what actually exists onchain is addresses, not wallets.\n\n>\n> I get that there might be implementation and UX issues around something like this but I\u2019m not seeing the privacy risks around it.\n\nI do not want anyone, not even vendors, to link my purchase of Strawberry Shortcake paraphernalia with my purchase of XXXtra-Slippery Lubribation Oil.\nMy use of Strawberry Shortcake paraphernalia is my own private affair and whether I reveal it or not is my right.\n\n>\n> Why should some of these use cases be ruled out preventively and not just pass that responsibility to the user who might benefit from them?\n\nWhy do you think that this \"ruling out\" prevents the user from being responsible?\nIt *forces* the user to be responsible since it is the user software, running on the user hardware, that handles the user-owned digital library.\n\nAt the same time, it reduces the privacy leakage since vendors are not able to link different purchases to the same user, at least on LN.\n(Leakage from IP addresses on the other hand...)\n\n>\n> As a user I think I wouldn\u2019t mind giving permission for a service to keep my high scores or all the books I got, or all the music I bought in the same account...\n\n*You* might not.\nI would mind.\n\n\n>\n> And if that can be done in a single step, opted-in and I don\u2019t even need to provide any personal info that could lead to my \u201chuman identity\u201d even better! That would be a major improvement from most services now who force you to have an email account which can most of the time give a lot of information about someone and provide them a password which, who knows what they do with it and how they store it...\n\nAnd how is this an improvement from the case where the \"human identity\" is handled by an application on the user-owned hardware?\n\nIn any case, the principle is simple.\nWe must consider privacy first, and allow users to leak information if they are willing.\nBut such information leakage MUST NOT be required for any purchase.\n\nThus, there is no need for the LN base network to provide some kind of persistent user ID.\nHigher layers may do so selectively, but would be foolish to support such a thing.\n\nIt is difficult to regain privacy if the base layer is nonprivate.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Joao Joyce",
                "date": "2019-01-29T11:49:00",
                "message_text_only": "Hi ZmnSCPxj,\n\nYeah, although I see the added value of a feature like this I completely understand your reasoning.\n\n> It is difficult to regain privacy if the base layer is nonprivate.\n\nSure, people and corporations would probably find multiple ways to abuse this or to turn this into the only way to make LN payments.\n\nThe problem of moving some of this stuff to the hardware of the user is the lack of standardisation. I don\u2019t know if there\u2019s any wallet that currently does this kind of stuff. I\u2019m not even sure if wallets should do it.\u00a0\nOr if other Apps should be given access to pre-images of LN payments.\u00a0\n\nI guess that I was expecting that a replacement for email/password as authentication method could finally come from something I\u2019m hopping will be as pervasive as email addresses :)\nAnyway, authentication might be completely out of scope here.\u00a0\n\nThank you,\nJo\u00e3o \u00a0Joyce"
            }
        ],
        "thread_summary": {
            "title": "Lightning network user identification",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Joao Joyce",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 18198
        }
    },
    {
        "title": "[Lightning-dev] Revocations with OP_CSFS & signed sequence commitments",
        "thread_messages": [
            {
                "author": "James Chiang",
                "date": "2019-01-30T22:31:47",
                "message_text_only": "Dear all,\n I am trying to understand how channel commitment transactions can be revoked with op_checksigfromstack(msg, sig, key) and signed sequence commitments.\n\nI understand that a commitment c(n, randomness)  is signed by both parties for each state, and that this signature can be verified with op_csfs(c, sig(A+B), key(A+B)). The sequence n is incremented for each new state.\n\nGiven the most recent commitment sequence signature (from both parties) and the sequence commitment opening (n++, r), an output script of an older, revoked commitment transaction can verify that a newer signed commitment sequence exists by examining:\nop_checksigfromstack(c++, sig(A+B), key(A+B)) \nc++ == commitment(n++, r)\nHowever, it must also have information about its own sequence number n, so it can verify that this is indeed lower than n++ (current). How is sequence number n committed to the nth commitment tx and accessible on-stack during script evaluation?\n\nI learned about this concept from Johnson Lao's and Roasbeef's Talk from Scaling Bitcoin at Stanford:\nhttps://scalingbitcoin.org/stanford2017/Day1/SB2017_script_2_0.pdf \n\nAny pointers would be very much appreciated.\n\nKind regards,\n\nJames\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190130/358a7d34/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Revocations with OP_CSFS & signed sequence commitments",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "James Chiang"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1375
        }
    }
]