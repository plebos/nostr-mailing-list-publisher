[
    {
        "title": "[Lightning-dev] [bitcoin-dev] SIGHASH_NOINPUT in Segregated Witness",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2016-03-01T23:22:52",
                "message_text_only": "bitcoin-dev dropped, just lightning-dev\n\nOn Mon, Feb 29, 2016 at 10:55:53AM +1030, Rusty Russell wrote:\n> If each HTLC output is a p2sh[1], you need the timeout and rhash for\n> each one to build the script to redeem it.  In practice, there's not\n> much difference between sending a watcher a tx for every commit tx and\n> sending it information for every new HTLC (roughly a factor of 2).\n\nThere's a bigger saving if you've got a very active channel with\ncomparatively long lived HTLCs. With pre-signed transactions you have\nto send:\n\ntx 1234:\n  input: anchor\n  outputs: Alice balance ; Bob balance ; HTLC 1 ; HTLC 2 ; HTLC 3 ; ...\n\ntx 1235: (HTLC 2 cleared)\n  input: anchor\n  outputs: Alice balance ; Bob balance ; HTLC 1 ; HTLC 3 ; HTLC 4 ; ...\n\ntx 1235: (HTLC 4 cleared)\n  input: anchor\n  outputs: Alice balance ; Bob balance ; HTLC 1 ; HTLC 3 ; HTLC 5 ; ...\n\n...\n\nSo if you do, say 30 HTLCs per minute, but each HTLC lasts for 20 seconds,\nthen each HTLC appears in ~10 transactions, and you've correspondingly\ngot to supply 10 signatures to your outsourced claimant for each HTLC\nyou deal with. Comparatively, you only have to supply the R/timeout\nvalues once per HTLC.\n\nWith SIGHASH_NOINPUT you'd still have to send all the R/timeout values\nfor each HTLC, but you'd only need to send a single signature for the\nchannel.\n\n> So we also need to put more in the scriptPubKey for this to work; either\n> the entire redeemscript, or possibly some kind of multiple-choice P2SH\n> where any one of the hashes will redeem the payment.\n\nWe discussed how to recover the timeout/R values recoverable last\nyear fwiw, see the thread surrounding:\n\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000058.html\n\nI don't think there's a big problem with sending that info to a third\nparty who's doing transaction reclaiming; it might hurt privacy a bit.\n\nNote that with segwit, having a visible scriptPubKey so that R is\ntrivially obvious isn't even possible anymore...\n\n(If by \"multiple-choice p2sh\" you mean merkelized abstract syntax trees\nthat would let you exchange 20+4 / 32+4 bytes of R+timeout for 32 bytes\nof a merkle path, which would be an improvement, but not huge. Otherwise\nI think you'd have to have a new double-length script hash type; which\nmight not be friendly to UTXO? Though maybe two 160 bit hashes wouldn't\nbe out of the question, at 40 bytes versus 32 or 64?)\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-02T00:44:51",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> bitcoin-dev dropped, just lightning-dev\n>\n> On Mon, Feb 29, 2016 at 10:55:53AM +1030, Rusty Russell wrote:\n>> If each HTLC output is a p2sh[1], you need the timeout and rhash for\n>> each one to build the script to redeem it.  In practice, there's not\n>> much difference between sending a watcher a tx for every commit tx and\n>> sending it information for every new HTLC (roughly a factor of 2).\n>\n> There's a bigger saving if you've got a very active channel with\n> comparatively long lived HTLCs. With pre-signed transactions you have\n> to send:\n\nYes, with SIGHASH_NOINPUT you only need to send timeout/rval per new\nHTLC, plus new revocation preimage per new commit tx.  Assuming no\nbatching, so every second new commit tx adds a new HTLC, that's (4 + 32)\n/ 2 + 32 = 50 bytes per commit tx.\n\nWithout SIGHASH_NOINPUT, add 64 bytes per commit tx output\n(2+<num-htlcs>), plus you have to generate those signatures.  That's\nprobably going to be less than 1 TCP packet, though.\n\nI'm not convinced it's qualitatively different.\n\n>> So we also need to put more in the scriptPubKey for this to work; either\n>> the entire redeemscript, or possibly some kind of multiple-choice P2SH\n>> where any one of the hashes will redeem the payment.\n>\n> We discussed how to recover the timeout/R values recoverable last\n> year fwiw, see the thread surrounding:\n>\n> http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000058.html\n>\n> I don't think there's a big problem with sending that info to a third\n> party who's doing transaction reclaiming; it might hurt privacy a bit.\n\nThanks for the reminder, re-reading... the result was that all the\nclever tricks don't win much; you can avoid sending/storing the 4 byte\ntimeout.\n\n> Note that with segwit, having a visible scriptPubKey so that R is\n> trivially obvious isn't even possible anymore...\n>\n> (If by \"multiple-choice p2sh\" you mean merkelized abstract syntax trees\n> that would let you exchange 20+4 / 32+4 bytes of R+timeout for 32 bytes\n> of a merkle path, which would be an improvement, but not huge. Otherwise\n> I think you'd have to have a new double-length script hash type; which\n> might not be friendly to UTXO? Though maybe two 160 bit hashes wouldn't\n> be out of the question, at 40 bytes versus 32 or 64?)\n\nNo, MAST doesn't do it for you, since you still need the hash of the\nunknown part.  We'd need a \"script is one of these hashes\" form, which\nas you point out, bloats the UTXO set.\n\nSo not likely to be acceptable until lightning is the main bitcoin user.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2016-03-02T22:36:27",
                "message_text_only": "On Wed, Mar 02, 2016 at 11:14:51AM +1030, Rusty Russell wrote:\n> Yes, with SIGHASH_NOINPUT you only need to send timeout/rval per new\n> HTLC, plus new revocation preimage per new commit tx.  Assuming no\n> batching, so every second new commit tx adds a new HTLC, that's (4 + 32)\n> / 2 + 32 = 50 bytes per commit tx.\n\nAssuming \"batching\" refers to combining multiple changes in a single\ncommitment update, yeah. (I was thinking batching multiple commitment\nupdates in a single packet when updating your blockchain contracter)\n\n> Without SIGHASH_NOINPUT, add 64 bytes per commit tx output\n> (2+<num-htlcs>), plus you have to generate those signatures.  That's\n> probably going to be less than 1 TCP packet, though.\n> I'm not convinced it's qualitatively different.\n\nYou're adding 70 bytes of signature data for every HTLC for every\ncommitment it appears in, all of which have to be stored until the\nchannel's closed. That's a 70% increase in storage requirements.\n\nAs it turns out, I'm confused as to what size a \"TCP packet\" actually\nis these days; is it 65kB or 1500B or somewhere in between? 1500 bytes\nonly gives you about 14 HTLCs open on a channel simultaneously.\n\nBut maybe anyone doing high volume/rate (ie, forwarding other people's\ntransactions, or doing many transactions per minute) should just run\ntheir own bitcoin node anyway. For low volume channels where you only\ndo five transactions an hour, every hour, a whole six months of full\ntransactions is only 21MB.\n\nYeah; I think that persuades me: \"end users\" can outsource just by\ngenerating a new payment tx and sending that off; high volume users can\nrun a bitcoin node themselves and only do the signatures if/when someone\nactually cheats, so SIGHASH_NOINPUT isn't very useful in either case.\n\nThat only works because I don't think people running lightning on their\nphone will be forwarding many transactions though :)\n\n> > I don't think there's a big problem with sending that info to a third\n> > party who's doing transaction reclaiming; it might hurt privacy a bit.\n> Thanks for the reminder, re-reading... the result was that all the\n> clever tricks don't win much; you can avoid sending/storing the 4 byte\n> timeout.\n\nYou can avoid sending the 4 byte commitment index (ie, what you need\nto recover your shachain seed) by encoding that in the commitment\ntransaction's locktime, but you still need to store/send the HTLC\ntimeouts aiui.\n\n> > (If by \"multiple-choice p2sh\" you mean merkelized abstract syntax trees\n> > that would let you exchange 20+4 / 32+4 bytes of R+timeout for 32 bytes\n> > of a merkle path, which would be an improvement, but not huge. Otherwise\n> > I think you'd have to have a new double-length script hash type; which\n> > might not be friendly to UTXO? Though maybe two 160 bit hashes wouldn't\n> > be out of the question, at 40 bytes versus 32 or 64?)\n> No, MAST doesn't do it for you, since you still need the hash of the\n> unknown part.\n\nYeah, MAST just lets you trade the 32+4 bytes of R+timeout for 32 bytes\nof unknown-AST-hash.\n\n> We'd need a \"script is one of these hashes\" form, which\n> as you point out, bloats the UTXO set.\n> So not likely to be acceptable until lightning is the main bitcoin user.\n\nYeah. Of course, an upside is it wouldn't bloat the UTXO set for very\nlong -- lightning transactions should get spent pretty quickly, in case\nthe other side's CTLV timeout expires.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "SIGHASH_NOINPUT in Segregated Witness",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8372
        }
    },
    {
        "title": "[Lightning-dev] Probing final receiver with refund timeout",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-02T11:29:39",
                "message_text_only": "Just discovered that it is possible to attack the onion routing with\nprobing too short of an absolute CLTV refund timeout.\n\nWhen accepting a payment, one will check if the remaining timeout >\nMIN_TIMEOUT.\n\nWhen relaying the payment to the next node, one can either decide to\ncheck directly if the next node would accept it, or just relay and see\nwhat happens (the next node would then refuse to include the payment).\n\nChecking directly is equivalent of checking for 2 * MIN_TIMEOUT before\naccepting it. However, as the next node will check for 2 * MIN_TIMEOUT\nagain, this is running in circles and just blindly increasing the final\nMIN_TIMEOUT.\n\nFor an attacker it is now possible to choose a timeout that is lower\nthan 2 * MIN_TIMEOUT. If the payment succeeds, he knows that the next\nnode was the final receiver, if it doesn't he can redo the payment with\na larger timeout without any drawback, basically probing all payments once.\n\nAs discussed above, testing for a larger timeout before accepting /\nrelaying does not solve this problem. If all nodes only accept payments\nwith timeout > 10 * MIN_TIMEOUT, you can still probe with 10.5 *\nMIN_TIMEOUT.\n\nI think the only way to solve this would be to include\n(1) the timeout the previous node should have sent you\n(2) the timeout you should use for the next node\ninto the onion object and test it accordingly.\n\nIf you discover that the previous node messed with the timeout, you\ndirectly refund it. It further complicates routing though, as the source\nof the payment needs to know all MIN_TIMEOUT of the nodes in the route.\nIt also needs more coordination when doing RP-routing, as the receiver\nhas to include the timeout he chose for the first hop of his route.\n\nIt probably also opens up another attack vector for attacking the\nnetwork with unroutable payments.\n\n\nCheers\n-- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats.jerratsch at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160302/06cb6a52/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-05T09:28:36",
                "message_text_only": "Mats Jerratsch via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org> writes:\n> Just discovered that it is possible to attack the onion routing with\n> probing too short of an absolute CLTV refund timeout.\n>\n> When accepting a payment, one will check if the remaining timeout >\n> MIN_TIMEOUT.\n\nOne mitigation for this particular attack would be to remember the onion\nand always fail an identical one.  That would allow a single probe,\nhowever (basically, \"are you the final destination?\").\n\nAlso the timeout for the next hop should probably be somewhat\nrandomized, at least subtracting (MIN_TIMEOUT to MIN_TIMEOUT*2).\n\nThe question remains as to what HTLC timeout should be set to initially.\nEven if you randomize it, over time the pattern would reveal to your\npeer if you are originating all the HTLCS, for example.\n\nCheers,\nRusty."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-08T15:36:21",
                "message_text_only": "Only mitigates it such that you can't do for free, and it adds some\ncomplexity and we might barricade some future feature with it (like\nhaving multiple payments to one R value, over the same route).\n\nFor now I start with\n\nMAX_HOPS * MAX_OVERLAY * MIN_TIMEOUT\n\nwhere MAX_OVERLAY is some 'consensus' value of how much buffer time each\nnode should deduct from the refund time at most. That way each node can\nuse the full range to randomize the refund time, without running out of\ntime in the end. I do not see how a pattern should emerge from that though.\n\nHowever, I am inclined to use those timestamps in the onion object, as\nthe described attackvector still exists.\n\nCheers\n\n\n\nAm 05/03/2016 um 09:28 schrieb Rusty Russell:\n> Mats Jerratsch via Lightning-dev\n> <lightning-dev at lists.linuxfoundation.org> writes:\n>> Just discovered that it is possible to attack the onion routing with\n>> probing too short of an absolute CLTV refund timeout.\n>>\n>> When accepting a payment, one will check if the remaining timeout >\n>> MIN_TIMEOUT.\n> \n> One mitigation for this particular attack would be to remember the onion\n> and always fail an identical one.  That would allow a single probe,\n> however (basically, \"are you the final destination?\").\n> \n> Also the timeout for the next hop should probably be somewhat\n> randomized, at least subtracting (MIN_TIMEOUT to MIN_TIMEOUT*2).\n> \n> The question remains as to what HTLC timeout should be set to initially.\n> Even if you randomize it, over time the pattern would reveal to your\n> peer if you are originating all the HTLCS, for example.\n> \n> Cheers,\n> Rusty.\n> \n\n-- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-09T00:30:47",
                "message_text_only": "Mats Jerratsch <mats at blockchain.com> writes:\n> Only mitigates it such that you can't do for free, and it adds some\n> complexity and we might barricade some future feature with it (like\n> having multiple payments to one R value, over the same route).\n\nNo, not filtered the same R value, filtered on the bitwise identical\nonion routing information (the origin would generate a fresh onion for\nevery payment, independent of R value).  The malicious node can't\nmanipulate the routing onion, or it won't decode.\n\n(You can actually just save the authentication tag I think, for\ncomparison).\n\n> For now I start with\n>\n> MAX_HOPS * MAX_OVERLAY * MIN_TIMEOUT\n>\n> where MAX_OVERLAY is some 'consensus' value of how much buffer time each\n> node should deduct from the refund time at most. That way each node can\n> use the full range to randomize the refund time, without running out of\n> time in the end. I do not see how a pattern should emerge from that though.\n\nIf A sends many HTLCs through B, B can simply plot what the timeouts\nare and know that A is likely originating the HTLCs rather than relaying\nthem for someone else.\n\nI can't come up a scheme which combats this kind of analysis, but there\nare cleverer people than me on this list...\n\n> However, I am inclined to use those timestamps in the onion object, as\n> the described attackvector still exists.\n\nDoesn't including timestamps in the onion provide explicit information\non the number of previous hops though?\n\nThanks,\nRusty."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-09T09:49:23",
                "message_text_only": "> If A sends many HTLCs through B, B can simply plot what the timeouts\n> are and know that A is likely originating the HTLCs rather than relaying\n> them for someone else.\n\nHm, right. If all payments that come from A have a timeout larger than\nsome minimum value X, he is generating all of them and is just trying to\nrandomize those. However, if he creates a payment with an initial refund\nvalue lower than X, the payment might not succeed, because the\nintermediate nodes deducted too much.\n\nHowever, if we take into account that the amount of nodes in the route\nis not a constant, and only known to the sender, this adds another\ndegree of freedom to choose the initial value.\n\n\n>> However, I am inclined to use those timestamps in the onion object, as\n>> the described attackvector still exists.\n> \n> Doesn't including timestamps in the onion provide explicit information\n> on the number of previous hops though?\n\nNot if they are randomized. The initial sender will choose a good\nstarting value (see above), and deduct MIN_TIMEOUT * MIN_OVERLAY *\nRANDOM from it. Actually it doesn't provide any additional data, as that\nis the very same mechanism the intermediate hops come to that value.\n\n-- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160309/d067aae0/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-15T01:01:38",
                "message_text_only": "Mats Jerratsch <mats at blockchain.com> writes:\n>> If A sends many HTLCs through B, B can simply plot what the timeouts\n>> are and know that A is likely originating the HTLCs rather than relaying\n>> them for someone else.\n>\n> Hm, right. If all payments that come from A have a timeout larger than\n> some minimum value X, he is generating all of them and is just trying to\n> randomize those. However, if he creates a payment with an initial refund\n> value lower than X, the payment might not succeed, because the\n> intermediate nodes deducted too much.\n>\n> However, if we take into account that the amount of nodes in the route\n> is not a constant, and only known to the sender, this adds another\n> degree of freedom to choose the initial value.\n\nGood point. But we still lose on the receiving side; if you ever see a\nsmall timeout you know the next hop is the final one.\n\nI imagine we'll be spending some time getting more sophisticated with\nour value cloaking as attacks emerge, but I'm happy to start with\nsomething reasonable.\n\n>>> However, I am inclined to use those timestamps in the onion object, as\n>>> the described attackvector still exists.\n>> \n>> Doesn't including timestamps in the onion provide explicit information\n>> on the number of previous hops though?\n>\n> Not if they are randomized. The initial sender will choose a good\n> starting value (see above), and deduct MIN_TIMEOUT * MIN_OVERLAY *\n> RANDOM from it. Actually it doesn't provide any additional data, as that\n> is the very same mechanism the intermediate hops come to that value.\n\nOK, let me get the proposal straight:\n\n1.  Each node will publish its MIN_TIMEOUT (along\n    with its other info as per Option 2 in\n    http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-October/000262.html )\n\n2.  The payer sums the MIN_TIMEOUT to the payee, adds some random value\n    (keeping it under the max value allowed by protocol) to give the\n    initial HTLC timeout.\n\n3.  The payer puts the 'expected_timeout' in each layer of the onion, by\n    subtracting the last hops' MIN_TIMEOUT from the initial timeout.\n\neg.  Say maximum allowed timeout is 20 * 12 hours, and route is:\n\n        A (12 hours) -> B (6 hours) -> C (6 hours) -> D (4 hours)\n\n     Initial timeout has to be at least 12 + 6 + 6 + 4 == 28 hours, plus\n     some padding for transmission delays, say 29 hours.\n\n     It picks a random timeout between 29 and 240 hours, say now+100 hours,\n     and onion looks like:\n\n     [ A: now+100 [ B: now+88 [ C: now+82 [ D: now+76 ] ] ] ]\n\nHave I missed anything?\n\nRusty."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-21T09:42:35",
                "message_text_only": "> OK, let me get the proposal straight:\n> \n> 1.  Each node will publish its MIN_TIMEOUT (along\n>    with its other info as per Option 2 in\n>    http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-October/000262.html )\n> \n> 2.  The payer sums the MIN_TIMEOUT to the payee, adds some random value\n>    (keeping it under the max value allowed by protocol) to give the\n>    initial HTLC timeout.\n> \n> 3.  The payer puts the 'expected_timeout' in each layer of the onion, by\n>    subtracting the last hops' MIN_TIMEOUT from the initial timeout.\n> \n> eg.  Say maximum allowed timeout is 20 * 12 hours, and route is:\n> \n>        A (12 hours) -> B (6 hours) -> C (6 hours) -> D (4 hours)\n> \n>     Initial timeout has to be at least 12 + 6 + 6 + 4 == 28 hours, plus\n>     some padding for transmission delays, say 29 hours.\n\nI take a multiply of the MIN_TIMEOUT, a factor around 2, but yes, that sounds about right\n\n> \n>     It picks a random timeout between 29 and 240 hours, say now+100 hours,\n>     and onion looks like:\n> \n>     [ A: now+100 [ B: now+88 [ C: now+82 [ D: now+76 ] ] ] ]\n\nI would not use the MIN_TIMEOUT here, but use it as the minimum time I deduct each hop and add some randomness into it.\nIt also means that you need two values in the onion object:\n\n(1) the value you expect to receive\n(2) the value you should use for the next hop (and therefore the (1) value of the next hop))\n\nSo somewhere along this:\n    [ A: now+100;now+80 [ B: now+80;now+65 [ C: now+65;now+54 [ D: now+54;now+40 ] ] ] ]\nwhich can obviously be saved in a less redundant way\n\nCheers\nMats\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160321/e28421a3/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-22T01:14:15",
                "message_text_only": "Mats Jerratsch <mats at blockchain.com> writes:\n>> OK, let me get the proposal straight:\n>> \n>> 1.  Each node will publish its MIN_TIMEOUT (along\n>>    with its other info as per Option 2 in\n>>    http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-October/000262.html )\n>> \n>> 2.  The payer sums the MIN_TIMEOUT to the payee, adds some random value\n>>    (keeping it under the max value allowed by protocol) to give the\n>>    initial HTLC timeout.\n>> \n>> 3.  The payer puts the 'expected_timeout' in each layer of the onion, by\n>>    subtracting the last hops' MIN_TIMEOUT from the initial timeout.\n>> \n>> eg.  Say maximum allowed timeout is 20 * 12 hours, and route is:\n>> \n>>        A (12 hours) -> B (6 hours) -> C (6 hours) -> D (4 hours)\n>> \n>>     Initial timeout has to be at least 12 + 6 + 6 + 4 == 28 hours, plus\n>>     some padding for transmission delays, say 29 hours.\n>\n> I take a multiply of the MIN_TIMEOUT, a factor around 2, but yes, that sounds about right\n>\n>> \n>>     It picks a random timeout between 29 and 240 hours, say now+100 hours,\n>>     and onion looks like:\n>> \n>>     [ A: now+100 [ B: now+88 [ C: now+82 [ D: now+76 ] ] ] ]\n>\n> I would not use the MIN_TIMEOUT here, but use it as the minimum time I deduct each hop and add some randomness into it.\n> It also means that you need two values in the onion object:\n>\n> (1) the value you expect to receive\n> (2) the value you should use for the next hop (and therefore the (1) value of the next hop))\n>\n> So somewhere along this:\n>     [ A: now+100;now+80 [ B: now+80;now+65 [ C: now+65;now+54 [ D: now+54;now+40 ] ] ] ]\n> which can obviously be saved in a less redundant way\n\nOK, does that randomness add anything useful?  Maybe I need another\ncoffee to see it?\n\nThanks,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Probing final receiver with refund timeout",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Mats Jerratsch"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 14127
        }
    },
    {
        "title": "[Lightning-dev] We don't need R-Value, how OP_CODESEPARATOR saves the day",
        "thread_messages": [
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-07T02:34:09",
                "message_text_only": "I'm amazed as I found a useful case for OP_CODESEPARATOR.\nI think the script can be improved to take less byte for removing the\nduplication of <KeyA>, will take a look later.\nLet's change escape redeem:\n\nOP_HASH160 <RHashA> OP_EQUAL\nOP_IF\n<KeyB>\nOP_ELSE\n<Delay> OP_CSV OP_DROP\n<KeyA>\nOP_ENDIF\nOP_CHECKSIG\n\nTo\n\n<KeyA> OP_CHECKSIG\nOP_IF\n<KeyB>\nOP_ELSE\n<Delay> OP_CSV OP_DROP\nOP_CODESEPARATOR <KeyA>\nOP_ENDIF\nOP_CHECKSIG\n\nThe Escape output would be\n\n<SIG-B> <SIGA-Revocation> {<ESCAPE-REDEEM>}\n\nWhere SIGA-Revocation is the signature of KeyA computed with the\nScriptCode=<ESCAPE-REDEEM>\n\nThe second escape would be\n\n<SIG-A> 0 {<ESCAPE-REDEEMSCRIPT>}\n\nwhere <SIG-A> script equals to\n\n<KeyA>\nOP_ENDIF\nOP_CHECKSIG\n\nYou would revoke a commitment by revealing <SIGA-Revocation>\n\nBtw, you can play with http://n.bitcoin.ninja/checkscript to test such\nscript (I'm checking it myself)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160307/20fd0605/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-07T23:38:42",
                "message_text_only": "Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n> I'm amazed as I found a useful case for OP_CODESEPARATOR.\n\nMe too!  This is an awesome hack.\n\nThere is an important caveats: You must make sure you never ever create\na commit tx which is identical a previous one.\n\nThere's also a requirement that you store all previous signatures,\navoided by both the original draft scheme (using BIP32 and handing over\nold private keys) and the deployable lightning chain-of-hashes.\n\nSince these scripts will hardly ever hit the chain, I think this a\npremature optimization.  But maybe I'm still a bit stunned by this use\nof OP_CODESEPARATOR :)\n\nGreat work!\nRusty."
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-07T07:28:45",
                "message_text_only": "I managed to adapt the payment channel script to use less space.\n\nThis version is winning around 32 bytes in the scriptpubkey (for the R\nvalue) as well as 70 bytes in the signature when Alice close the channel.\n\nAlice closing the channel:\nhttp://n.bitcoin.ninja/checkscript?savedScript=51225750-f245-45b5-a86c-6ca1e87dcafb\n\n\nBob using revocation:\nhttp://n.bitcoin.ninja/checkscript?savedScript=c4d7ebaa-5a79-4c03-ab55-c499854f1e94\n\n\nThis amount to 100 bytes saved between the anchor transaction + commitment\nbroadcasted.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160307/adaf7917/attachment.html>"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2016-03-07T19:09:18",
                "message_text_only": "Hi,\nI may have misunderstood something, but with this scheme instead of R\n+ shachain/elkrem, then how do nodes react when old commit tx are\npublished ? It seems that they would have to store lots of signatures\n?\n\n\nOn 7 March 2016 at 08:28, Nicolas Dorier <nicolas.dorier at gmail.com> wrote:\n> I managed to adapt the payment channel script to use less space.\n>\n> This version is winning around 32 bytes in the scriptpubkey (for the R\n> value) as well as 70 bytes in the signature when Alice close the channel.\n>\n> Alice closing the channel:\n> http://n.bitcoin.ninja/checkscript?savedScript=51225750-f245-45b5-a86c-6ca1e87dcafb\n>\n> Bob using revocation:\n> http://n.bitcoin.ninja/checkscript?savedScript=c4d7ebaa-5a79-4c03-ab55-c499854f1e94\n>\n> This amount to 100 bytes saved between the anchor transaction + commitment\n> broadcasted.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Fabrice Drouin",
                "date": "2016-03-07T20:01:58",
                "message_text_only": "Ok, got my answer from the thread you started on deterministic R values\nand which I had missed :)\n\nOn 7 March 2016 at 20:09, Fabrice Drouin <fabrice.drouin at acinq.fr> wrote:\n> Hi,\n> I may have misunderstood something, but with this scheme instead of R\n> + shachain/elkrem, then how do nodes react when old commit tx are\n> published ? It seems that they would have to store lots of signatures\n> ?\n>\n>\n> On 7 March 2016 at 08:28, Nicolas Dorier <nicolas.dorier at gmail.com> wrote:\n>> I managed to adapt the payment channel script to use less space.\n>>\n>> This version is winning around 32 bytes in the scriptpubkey (for the R\n>> value) as well as 70 bytes in the signature when Alice close the channel.\n>>\n>> Alice closing the channel:\n>> http://n.bitcoin.ninja/checkscript?savedScript=51225750-f245-45b5-a86c-6ca1e87dcafb\n>>\n>> Bob using revocation:\n>> http://n.bitcoin.ninja/checkscript?savedScript=c4d7ebaa-5a79-4c03-ab55-c499854f1e94\n>>\n>> This amount to 100 bytes saved between the anchor transaction + commitment\n>> broadcasted.\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-08T04:25:53",
                "message_text_only": "Yes they do,\n\nBut I did not thought you had a way not to store one R value per\ncommitment.\nIf you store one R Value per commitment, then the solution with\nOP_CODESEPARATOR is strictly better as it saves space on\nblockchain.\n\nSo indeed if old commit tx are published, they need to fetch the\nsignatures.\n\nNicolas,\n\nOn Tue, Mar 8, 2016 at 4:09 AM, Fabrice Drouin <fabrice.drouin at acinq.fr>\nwrote:\n\n> Hi,\n> I may have misunderstood something, but with this scheme instead of R\n> + shachain/elkrem, then how do nodes react when old commit tx are\n> published ? It seems that they would have to store lots of signatures\n> ?\n>\n>\n> On 7 March 2016 at 08:28, Nicolas Dorier <nicolas.dorier at gmail.com> wrote:\n> > I managed to adapt the payment channel script to use less space.\n> >\n> > This version is winning around 32 bytes in the scriptpubkey (for the R\n> > value) as well as 70 bytes in the signature when Alice close the channel.\n> >\n> > Alice closing the channel:\n> >\n> http://n.bitcoin.ninja/checkscript?savedScript=51225750-f245-45b5-a86c-6ca1e87dcafb\n> >\n> > Bob using revocation:\n> >\n> http://n.bitcoin.ninja/checkscript?savedScript=c4d7ebaa-5a79-4c03-ab55-c499854f1e94\n> >\n> > This amount to 100 bytes saved between the anchor transaction +\n> commitment\n> > broadcasted.\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/f7b0831e/attachment-0001.html>"
            },
            {
                "author": "Joseph Poon",
                "date": "2016-03-08T02:56:20",
                "message_text_only": "Hi Nicolas,\n\nYes, I do think exploring using signatures as a method of revocation is\ninteresting! For revoking Commitments, I believe if you did disclosure\nof the private-key as a method of revocation, then it's possible to\nachieve this compactness without using OP_CODESEPARATOR.\n\nSide note: It's necessary to disclose temporary private keys (instead of\nsignatures) under this mechanism, since it's possible to compactly store\nthe keys by making it derived from a tree or chain of hash functions.\n\nA compact revocable example for Bob to broadcast could be:\n<PubkeyAlice> OP_CHECKSIG\nOP_NOTIF\n\t<CSVDelay> OP_DROP OP_CSV \nOP_ENDIF\n<PubkeyBob>\nOP_CHECKSIG\n\nOn the other hand, if Alice broadcasted it, her script could be:\n<PubkeyBob> OP_CHECKSIG\nOP_NOTIF\n\t<CSVDelay> OP_DROP OP_CSV \nOP_ENDIF\n<PubkeyAlice>\nOP_CHECKSIG\n\nAlice successful redemption of her broadcast would be:\n(after one week)\n<AliceSig> <0>\n\nBob's penalty transaction on Alice's broadcast would be:\n<AliceSig> <BobSig>\n\nIf Alice did not broadcast the correct Commitment, Bob can take the\nmoney immediately because she disclosed her private key when creating\nthe new Commitment transaction, so Bob has both PrivkeyBob and\nPrivkeyAlice. If Alice correctly broadcast the most recent Commitment,\nBob does not have PrivkeyAlice so he cannot take the funds, but Alice\ndoes not have PrivkeyBob so she has to wait for the CSV delay.\n\nIf the goal is to save space, it saves a little in the\ntimeout/non-penalty case, but the transactions are larger for penalty\ncases (although they may be less frequent).\n\nIt's also possible to make it just a multisig output with the child\ntransaction spending from it pre-signed as well using nSequence, but\nthat requires more storage and more on-chain transactions (while saving\nin the script output size), this design is not necessary for this\nparticular instance if there's OP_CSV.\n\nAs a side note, OP_CODESEPARATOR may become useful if there is\nSIGHASH_NOINPUT inside segregated witness in the future, by being able\nto have one signature be able to apply towards multiple types of\ntransactions (e.g. different redeemScript/scriptPubKey r-values or\npubkeys).\n\n-- \nJoseph Poon"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-08T04:44:05",
                "message_text_only": "I am catching up with the latest dev of lightning.\nI thought you wanted SIGHASH_NOPINPUT in order\nto fix the problem of storage requirement.\n\nI have not thought about using private key on HD.\nHowever, I think the index (also used for derivation)\nof the commitment would need to be stored in the\ntransaction.\nSo if Bob notice old commitment, he does not have\nto bruteforce what was the key he used.\n\nI re-read slowly your post on bitcoin-dev about\nSIGHASH_NOINPUT, and noticed the problem it\nwas to fix was for third party monitoring.\n\nBut that the linear storage of the channel participant\nwas a problem already solved. I'm synching. :)\n\nOn Tue, Mar 8, 2016 at 11:56 AM, Joseph Poon <joseph at lightning.network>\nwrote:\n\n> Hi Nicolas,\n>\n> Yes, I do think exploring using signatures as a method of revocation is\n> interesting! For revoking Commitments, I believe if you did disclosure\n> of the private-key as a method of revocation, then it's possible to\n> achieve this compactness without using OP_CODESEPARATOR.\n>\n> Side note: It's necessary to disclose temporary private keys (instead of\n> signatures) under this mechanism, since it's possible to compactly store\n> the keys by making it derived from a tree or chain of hash functions.\n>\n> A compact revocable example for Bob to broadcast could be:\n> <PubkeyAlice> OP_CHECKSIG\n> OP_NOTIF\n>         <CSVDelay> OP_DROP OP_CSV\n> OP_ENDIF\n> <PubkeyBob>\n> OP_CHECKSIG\n>\n> On the other hand, if Alice broadcasted it, her script could be:\n> <PubkeyBob> OP_CHECKSIG\n> OP_NOTIF\n>         <CSVDelay> OP_DROP OP_CSV\n> OP_ENDIF\n> <PubkeyAlice>\n> OP_CHECKSIG\n>\n> Alice successful redemption of her broadcast would be:\n> (after one week)\n> <AliceSig> <0>\n>\n> Bob's penalty transaction on Alice's broadcast would be:\n> <AliceSig> <BobSig>\n>\n> If Alice did not broadcast the correct Commitment, Bob can take the\n> money immediately because she disclosed her private key when creating\n> the new Commitment transaction, so Bob has both PrivkeyBob and\n> PrivkeyAlice. If Alice correctly broadcast the most recent Commitment,\n> Bob does not have PrivkeyAlice so he cannot take the funds, but Alice\n> does not have PrivkeyBob so she has to wait for the CSV delay.\n>\n> If the goal is to save space, it saves a little in the\n> timeout/non-penalty case, but the transactions are larger for penalty\n> cases (although they may be less frequent).\n>\n> It's also possible to make it just a multisig output with the child\n> transaction spending from it pre-signed as well using nSequence, but\n> that requires more storage and more on-chain transactions (while saving\n> in the script output size), this design is not necessary for this\n> particular instance if there's OP_CSV.\n>\n> As a side note, OP_CODESEPARATOR may become useful if there is\n> SIGHASH_NOINPUT inside segregated witness in the future, by being able\n> to have one signature be able to apply towards multiple types of\n> transactions (e.g. different redeemScript/scriptPubKey r-values or\n> pubkeys).\n>\n> --\n> Joseph Poon\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/27be3571/attachment-0001.html>"
            },
            {
                "author": "Joseph Poon",
                "date": "2016-03-10T20:30:34",
                "message_text_only": "Hi Nicolas,\n\nOn Tue, Mar 08, 2016 at 01:44:05PM +0900, Nicolas Dorier wrote:\n> I am catching up with the latest dev of lightning. I thought you\n> wanted SIGHASH_NOPINPUT in order to fix the problem of storage\n> requirement.\n> [...]\n> I re-read slowly your post on bitcoin-dev about SIGHASH_NOINPUT, and\n> noticed the problem it was to fix was for third party monitoring.\n\nYes, SIGHASH_NOINPUT is for the storage requirement. I was talking about\nan implementation detail for using OP_CODESEPARATOR to ensure that the\nsignature is valid for multiple types of script outputs.\n\nAs a side point, I think to clarify to the rest of the list what Nicolas\nhas discovered for those who are skimming since I find novel/unusual use\nof OP_CODESEPARATOR interesting, I believe Nicolas was talking about\nnoticing that an aspect of OP_CODESEPARATOR is you can use it to enforce\nbranch execution. For LN, however, the script can be made compact\nwithout OP_CODESEPARATOR.\n\nE.g. if part of the script looked like (ignore optimizations for a sec!)\n\n<alicePubkey> #used for OP_CHECKSIG\nOP_IF\n\t[some kind of conditions, e.g. OP_CLTV, OP_HASH160, etc.]\n\tOP_CODESEPARATOR\n\tOP_CHECKSIG\nOP_ELSE\n\t[OTHER conditions, e.g. OP_CLTV, OP_HASH160, etc.]\n\tOP_CODESEPARATOR\n\tOP_CHECKSIG\nOP_END\n\nIn this situation, a single pubkey can enforce execution of a particular\ncodepath. The codeseparator can enforce whether the first IF path is\nexecuted or the ELSE statement, since a signature can only be valid for\none of the two paths. This is achieved since codeseperator selects which\npart of the script to sign, which is a very interesting result.\n\nWhile this doesn't allow you do things you weren't able to before, this\ndoes offer potential space savings. It's possible to enforce code\nexecution with slightly larger scripts without using OP_CODESEPARATOR by\nusing two different pubkeys or by moving the conditions to be a nested\nOP_IF statement.\n\nThis type of construction is interesting because there can be\nmulti-party multi-signature situations where a party only wants to sign\noff on particular conditions are guaranteed to be executed, especially\nif there is some interactive communication and out-of-band conditions\nfor signing.\n\n-- \nJoseph Poon"
            }
        ],
        "thread_summary": {
            "title": "We don't need R-Value, how OP_CODESEPARATOR saves the day",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Nicolas Dorier",
                "Fabrice Drouin",
                "Joseph Poon"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 13932
        }
    },
    {
        "title": "[Lightning-dev] [BOLT RFC#1] Encryption spec",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-03-07T03:51:02",
                "message_text_only": "Hi all,\n\n        I'm back, and I've even had some sleep!  I've decided I need to\ndo more documentation in parallel with actual implementation, so I've\nput this temporarily in a fork of Mats' document repo:\n\n        https://github.com/rustyrussell/lightning/blob/master/communications/low/01-encryption.md\n\nBut here it is inline (I think I prefer plaintext, but MD isn't too\npainful to read).  Feedback welcome, this is what I'll be moving my\nimplementation towards...\n\nThanks!\nRusty.\n\n# Basis of Lightning Technology RFC 1 #\n\n# Status #\n\nInitial draft\n\n# Author #\n\nRusty Russell, Blockstream <mailto:rusty at rustcorp.com.au>\n\n# Abstract #\n\nAll communications between lightning nodes should be encrypted to make\nanalysis more difficult, and authenticated to avoid malicious\ninterference.  Each node has a known identifier which is a unique\nbitcoin-style public key[1].\n\n## Initial Handshake ##\n\nThe first packet sent by a node is of form:\n\n1. `length`: 4 byte little-endian\n2. `sessionpubkey`: 33 byte DER-encoded compressed public EC-key\n\nThe `length` field is the length after the field itself, and MUST be\n33 or greater.  `length` MUST NOT exceed 1MB (1048576 bytes).\n\nThe `sessionpubkey` field is a compressed public key corresponding to\na `sessionsecretkey`.  The receiver MUST check that `sessionpubkey` is\na valid point.\n\nThe `sessionsecretkey` MUST be is unguessable, MUST BE unique for this\nsession, MUST NOT be zero and MUST BE a valid EC key.\n\nAdditional fields MAY be added, and MUST be included in the `length` field.  These MUST be ignored by implementations which do not understand them.\n\n### Derivation of the Shared Secret and Encryption Keys ###\n\nOnce a node has received the initial handshake, it can derive the\nshared secret using the received `sessionpubkey` point and its own\n`sessionsecretkey` scalar using EC Diffie-Hellman.\n\nNow both nodes have obtained the shared secret, all packets are\nencrypted using keys derived from the shared secret.  Keys are derived\nas follows:\n\n* sending-key: SHA256(shared-secret || sending-node-id)\n* receiving-key: SHA256(shared-secret || receiving-node-id)\n\nie. each node combines the secret with its node id to produce the key\nto encrypt data it sends.\n\n## Encryption of Packets ##\n\nThe protocol uses Authenticated Encryption with Additional Data using\nChaCha20-Poly1305[2].\n\nEach packet contains a header and a body.  The header consists of a\n4-byte length indicating the size of the unencrypted body, and an\n8-byte packet counter.  The 4-byte length and 8-byte counter MUST be\nencoded in little-endian.  The 8-byte counter MUST begin at 0 and be\nincremented before each transmission after the initial authentication\npacket; it MAY be non-zero for the authentication packet for\nre-establishing an existing session.\n\nThe 12-byte header for each packet is encrypted separately (resulting\nin a 28 byte header, when the authentication tag is appended), to\noffer additional protection from traffic analysis.\n\nThe body also has a 16-byte authentication tag appended.\n\nNonces are 64-bit little-endian numbers, which MUST begin at 0 and\nMUST be incremented after each encryption (ie. twice per packet), such\nthat headers are encrypted with even nonces and the packet bodies\nencrypted with odd nonces.\n\n## Authentication Packet ##\n\nOnce the shared secret has been exchanged, the identity of the peer\nhas still not been authenticated.  The first packet sent MUST be an\nauthentication packet:\n\n\tmessage authenticate {\n\t  // Which node this is.\n\t  required bitcoin_pubkey node_id = 1;\n\t  // Signature of your session key.\n\t  required signature session_sig = 2;\n\t};\n\nThe receiving node MUST check that:\n\n1. `node_id` is the expected value for the sending node.\n2. `session_sig` is a valid secp256k1 ECDSA signature encoded as a\n32-byte big endian R value, followed by a 32-byte big endian S value.\n3. `session_sig` is the signature of the SHA256 of SHA256 of the receivers\n   `node_id`, using the secret key corresponding to the sender's `node_id`.\n\nAdditional fields MAY be included, and MUST BE ignored if not\nunderstood (to allow for future extensions).\n\n## Rationale ##\n\nMultiple choices are possible for symmetric encryption; AES256-GSM is\nthe other obvious choice but it is slower if there is no hardware\nacceleration, and the well-supported libsodium[3] doesn't support it\non non-accelerated platforms.\n\nThe header encryption could use a different key for encryption and\neschew 16-bytes for the authentication tag, but modern APIs tend to\nshy away from offering unauthenticated encryption.\n\nWhile multiple choices are possible for public-key cryptography, the\nbitcoin protocol already relies on the secp256k1 elliptic curve, so\nreusing it here avoids additional dependencies.\n\nThe authentication signature ensures that the node owning the\n`node_id` has specifically initiated this session; using double-sha256\nis done because bitcoin transaction signatures use that scheme.\n\n# Security Considerations #\n\nIt is strongly recommended that existing, commonly-used, validated\nlibraries be used for encryption and decryption, to avoid the many\nimplementation pitfalls possible.\n\n# References #\n\n1. https://en.bitcoin.it/wiki/Secp256k1\n2. https://tools.ietf.org/html/rfc7539\n3. https://download.libsodium.org/doc/index.html\n\n# Acknowledgements #\n\nThanks to Olaoluwa Osuntokun for pointing out the idea of encrypting\nthe length, and noting that it needed a separate key if it didn't\ninclude the authentication tag.\n\nThanks to Mats Jerratsch and Anthony Towns for feedback on initial\nhandshake design.\n\n# Feedback #\n\nFeedback is welcome on the [lightning-dev list](https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev)."
            },
            {
                "author": "Anthony Towns",
                "date": "2016-03-18T06:03:17",
                "message_text_only": "On Mon, Mar 07, 2016 at 02:21:02PM +1030, Rusty Russell wrote:\n> ### Derivation of the Shared Secret and Encryption Keys ###\n> Once a node has received the initial handshake, it can derive the\n> shared secret using the received `sessionpubkey` point and its own\n> `sessionsecretkey` scalar using EC Diffie-Hellman.\n\nI think this should be expanded -- I'm assuming the sessionsecretkey is\ncalculated as per libsecp256k1, as:\n\n (x,y) = y.public*x.secret = x.public*y.secret = g*(x.secret*y.secret)\n sha256( (2 + y%2) || x )\n\nThis is different to the NIST specification (see 5.7.1.2 in [0]) which\njust uses the x coordinate of the point directly, ignoring y and not\n(necessarily) hashing it.\n\nI've added some wording for this for your consideration:\n\n  https://github.com/rustyrussell/lightning/pull/1\n\n> While multiple choices are possible for public-key cryptography, the\n> bitcoin protocol already relies on the secp256k1 elliptic curve, so\n> reusing it here avoids additional dependencies.\n\nHmm, if secp256k1 breaks and gets deprecated, that would be a backwards\nincompatible change. You could handle this with the protocol as described\nby incrementing the high byte of \"length\" in the first message; old\nclients would see that as an invalid length, >16M, and refuse the\nconnection; new clients could just treat it as a version byte.\n\nCheers,\naj\n\n[0] http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-21T00:07:00",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Mon, Mar 07, 2016 at 02:21:02PM +1030, Rusty Russell wrote:\n>> ### Derivation of the Shared Secret and Encryption Keys ###\n>> Once a node has received the initial handshake, it can derive the\n>> shared secret using the received `sessionpubkey` point and its own\n>> `sessionsecretkey` scalar using EC Diffie-Hellman.\n>\n> I think this should be expanded -- I'm assuming the sessionsecretkey is\n> calculated as per libsecp256k1, as:\n>\n>  (x,y) = y.public*x.secret = x.public*y.secret = g*(x.secret*y.secret)\n>  sha256( (2 + y%2) || x )\n>\n> This is different to the NIST specification (see 5.7.1.2 in [0]) which\n> just uses the x coordinate of the point directly, ignoring y and not\n> (necessarily) hashing it.\n>\n> I've added some wording for this for your consideration:\n>\n>   https://github.com/rustyrussell/lightning/pull/1\n\nThanks!\n\n>> While multiple choices are possible for public-key cryptography, the\n>> bitcoin protocol already relies on the secp256k1 elliptic curve, so\n>> reusing it here avoids additional dependencies.\n>\n> Hmm, if secp256k1 breaks and gets deprecated, that would be a backwards\n> incompatible change. You could handle this with the protocol as described\n> by incrementing the high byte of \"length\" in the first message; old\n> clients would see that as an invalid length, >16M, and refuse the\n> connection; new clients could just treat it as a version byte.\n\nThe intention is that you'd do any upgrade by adding a second key, and\nincreasing the `length` field to cover it (say, to 66).  If either side\nsends a 33-byte initial packet, they've not ugpraded (whether you hang\nup at this point or continue is up to you); if both send >= 66 bytes,\nyou use the second value instead.\n\nI don't see what manipulating the length does?\n\nCheers,\nRusty.\nPS.  I should add an \"Extensions\" section to each BOLT...\n\n\n\n\n\n\n\n>\n> Cheers,\n> aj\n>\n> [0] http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf"
            }
        ],
        "thread_summary": {
            "title": "Encryption spec",
            "categories": [
                "Lightning-dev",
                "BOLT RFC#1"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9080
        }
    },
    {
        "title": "[Lightning-dev] Thoughts on JoinChannels, benefits for LN using Schnorr sig ?",
        "thread_messages": [
            {
                "author": "J\u00e9r\u00f4me Legoupil",
                "date": "2016-03-07T12:17:55",
                "message_text_only": "Hi,\n\nI am throwing out a thought about multi-party channels (a payment channels\nthat involve > 2 participants). I'm going to call them JoinChannels (I\nhaven't found anything in the literature regarding these objects).\n\nI see significant benefits of JoinChannels over 2-2 payment channels for\nLightning Network :\n\n   -\n\n   JoinChannels take less blockchain space : for example 3 parties linked\n   together with 2-2 channels require 3 channels, that is to say 3\n   multisig(2/2) transactions on the blockchain to open, while a JoinChannel\n   only takes 1 multisig(3/3). The space efficiency really kicks in with\n   Schnorr sigs and the signature time is only 2 rounds (independent of the\n   number of participants !).\n   -\n\n   JoinChannels enable bigger transfers of value threw LN (higher\n   connectivy) : if Alice wants to transfer X to Bob threw LN, all of the\n   intermediate 2-2channels (of the path found) need to all have at least X\n   locked in the right direction. With JoinChannels, an intermediate LN node\n   is more efficient because instead of spreading his funds in multiple 2-2\n   channels, he can put the sum of his funds in a JoinChannels and the\n   threshold condition of a transfer to occur is consequently higher. I have a\n   little example below.\n\nThe downside, is that all the participants of a JoinChannel need to be\nonline in order to participate in a LN transfer (which may become a problem\nif the payment needs to through multiple JoinChannels that contain hundreds\nor thousands of participants).\n\nCheers,\nJerome\n\n---\n\nThis little example shows that JoinChannels enable bigger transfers of\nvalue threw LN.\n\nIn this configuration, Sender can't send \"2\" to Receiver because B doesn't\nhave enough funds in AB channel.\n\nReceiver\n       |1\n       |\n       |2       ??\n      A1-------0B\n 1->2\\         /1->2 ??\n         \\      /\n    1->0\\   /1->0\n            C\n             |1->3\n             |\n             |2->0\n         Sender\n\n\nIf (A,B,C) had performed a (3/3) JoinChannel : Sender could have sent \"2\"\nto Receiver for a same value of funds locked in the previous example\n\nReceiver\n      |1->3\n      |\n      |2->0\n     A        B\n1->3\\\\\\\\////1->1\n        \\\\\\///\n         \\\\//\n          \\/2->0\n          C\n           |1->3\n           |\n           |2->0\n      Sender\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160307/16727742/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-03-07T12:59:16",
                "message_text_only": "I was thinking about something similar, the big problem is that everyone\nhas to be online.  What is needed is a way to do consensus enforced\nsequence numbers.\n\nThe principle is that the locktime would lock the transaction outputs (like\nwith the coinbase outputs) rather than prevent the transaction from being\nincluded in the blockchain.  Transactions could double spend these\ntransactions (and make them invalid) as long as they had higher sequence\nnumbers.    Once the locktime is hit, then the last one is locked.\n\nThinking more about it, this could be done by a soft fork, if the locked\ntransactions list was committed to in the coinbase.  You could only replace\ntransactions in the \"pending\" list if they have higher sequence numbers.\nAt this point, it could need a new field, since sequence numbers are being\nused for relative CLTV.  Transactions which double spend transactions in\nthe pending list would not be allowed in the main blocks.\n\nThis means that broadcasting an expired state of the channel will just have\nsomeone else broadcast one with a higher sequence number and have your\ntransaction removed from the pending list.  It doesn't protect against a\nparty broadcasting early, but at least the final state is the one that ends\nup as the channel close transaction.\n\nThere would be fees to pay to get into the pending list too, and it doesn't\nchange when the final locktime is anyway.\n\nI think the ideal situation would be where only those who are negatively\naffected have to sign to change the state.  Moving money from A to B would\nonly require A's signature on the state change.\n\nFor example, a join-channel could have a \"moderator\" and normal\nparticipants.  To sign a state change, you need the moderator's agreement\nand anyone who would lose money by the change.  The moderator is\nresponsible for making sure each sequence number is only signed once.  Any\nof the participants can poll the moderator to get the current state of the\nchannel after they have been offline for a while.  The hub would probably\nact as moderator and there would have to be a penalty if the moderator\nsigns the same state number twice.\n\nIdeally, the users would sign the updates periodically even if they aren't\ntrading to reduce clutter.  If someone signs state 180, then they are\nsigning all previous states too.  This means that you don't even need to\nhave any state that everyone has signed.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160307/5c7734e5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Thoughts on JoinChannels, benefits for LN using Schnorr sig ?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Tier Nolan",
                "J\u00e9r\u00f4me Legoupil"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5044
        }
    },
    {
        "title": "[Lightning-dev] Backward deterministic R Value",
        "thread_messages": [
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-07T12:35:30",
                "message_text_only": "One way deterministic RValue Generation\n\nMy previous proposal, while saving space on chain, does not\nsolve the fact that we need to save offchain one signature per\ncommitment.\n\nI have another proposal, so you don't need any data to store for\neach commitment.\nKeep the actual HTLC/Payment channel contracts, but make\nthe \"RValues\" backward deterministic.\n\nChoose RValue such that:\n\nRValue(n+1) = PreImage(RValue(n))\nWhere n is the commitment index.\n\nImagine Alice cheats Bob at commitment 100, by sending revocated\ncommitment 50.\n\nBob only have to remember RValue(99) from the 99th revocation, and\nthen hash this value 49 times to find out RValue(50)\n\nHowever, Bob does not know RValue(100) because\nRValue(100) = PreImage(99)\n\nFor Alice, she only have to generate a random number, then generate let's\nsay, 1000 hashes. Then she use hashes 1000 for RValue(0), hashes 999 for\nRValue(1)\netc...\n\nCommitment Revocation is only accepted by the party if RValue(n+1) =\nPreImage(RValue(n))\n\nThe only downside is that Alice need to regenerate all hashes everytimes\nshe need\na new commitment. This can be mitigated by her storing some pre computed\nvalues\nalong the path.\n\nNicolas,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160307/92040252/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-07T23:31:52",
                "message_text_only": "Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n> One way deterministic RValue Generation\n\nHi Nicolas,\n\n        Yes, in fact shachain is a variant of this which avoids\ngenerating several million hashes in advance.  Interesting, I suggested\nusing hashing in the Deployable Lightning paper but didn't actually\nspell out the idea.  Hmm....\n\nSeems like it orignated from Adam Back:\n\nhttps://lists.blockstream.io/pipermail/lightning-dev/2015-May/000000.html\n\nCheers,\nRusty."
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-08T04:53:55",
                "message_text_only": "Great, indeed we had same idea, I don't see how it solve the hashes in\nadvance.\nAs Alice knows\n\nH(1000000) = <random secret seed>).\n\nIf she need the hash to the first commitment she need to hash the random secret\nseed 1000000 times. I think it is exactly the same problem as it is the exact\nsame idea said differently.\n\n\nOn Tue, Mar 8, 2016 at 8:31 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n> > One way deterministic RValue Generation\n>\n> Hi Nicolas,\n>\n>         Yes, in fact shachain is a variant of this which avoids\n> generating several million hashes in advance.  Interesting, I suggested\n> using hashing in the Deployable Lightning paper but didn't actually\n> spell out the idea.  Hmm....\n>\n> Seems like it orignated from Adam Back:\n>\n> https://lists.blockstream.io/pipermail/lightning-dev/2015-May/000000.html\n>\n> Cheers,\n> Rusty.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/a4994ce6/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-08T06:02:14",
                "message_text_only": "Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n> Great, indeed we had same idea, I don't see how it solve the hashes in\n> advance.\n> As Alice knows\n>\n> H(1000000) = <random secret seed>).\n>\n> If she need the hash to the first commitment she need to hash the random secret\n> seed 1000000 times. I think it is exactly the same problem as it is the exact\n> same idea said differently.\n\nSee:\n\n        https://github.com/rustyrussell/ccan/tree/master/ccan/crypto/shachain\n\nCheers,\nRusty."
            },
            {
                "author": "CJP",
                "date": "2016-03-08T07:19:48",
                "message_text_only": "I was wondering: how does deriving R values from a tree structure work\nfor larger Lightning networks? I guess it could work between two nodes,\nif they keep track of the same tree, but if different transactions\nfollow different routes, does that mean the tree structure somehow has\nto be shared across all nodes? The alternative is that intermediate\nnodes still have to remember old R values.\n\nCJP\n\n\nNicolas Dorier schreef op di 08-03-2016 om 13:53 [+0900]:\n> Great, indeed we had same idea, I don't see how it solve the hashes in\n> advance. \n> As Alice knows\n> H(1000000) = <random secret seed>).\n> If she need the hash to the first commitment she need to hash the random secret\n> seed 1000000 times. I think it is exactly the same problem as it is the exact\n> same idea said differently.\n> \n> On Tue, Mar 8, 2016 at 8:31 AM, Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n>         Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n>         > One way deterministic RValue Generation\n>         \n>         Hi Nicolas,\n>         \n>                 Yes, in fact shachain is a variant of this which\n>         avoids\n>         generating several million hashes in advance.  Interesting, I\n>         suggested\n>         using hashing in the Deployable Lightning paper but didn't\n>         actually\n>         spell out the idea.  Hmm....\n>         \n>         Seems like it orignated from Adam Back:\n>         \n>         https://lists.blockstream.io/pipermail/lightning-dev/2015-May/000000.html\n>         \n>         Cheers,\n>         Rusty.\n> \n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-08T15:16:41",
                "message_text_only": "What about if Alice does not want to disclose R? Bob could have taken\ntoo much fee and Alice does not agree to accept a payment too small.\n\nWhile there is technically not really a security problem in disclosing\nthe R values when the payment isn't in the current commitment, the whole\nidea of 'proof-of-payment'/'pay-to-contract' relies on only revealing R\nfor an accepted payment.\n\nOtherwise, knowing R is no longer proof of having made a payment.\n\nAm 08/03/2016 um 07:19 schrieb CJP:\n> I was wondering: how does deriving R values from a tree structure work\n> for larger Lightning networks? I guess it could work between two nodes,\n> if they keep track of the same tree, but if different transactions\n> follow different routes, does that mean the tree structure somehow has\n> to be shared across all nodes? The alternative is that intermediate\n> nodes still have to remember old R values.\n> \n> CJP\n> \n> \n> Nicolas Dorier schreef op di 08-03-2016 om 13:53 [+0900]:\n>> Great, indeed we had same idea, I don't see how it solve the hashes in\n>> advance. \n>> As Alice knows\n>> H(1000000) = <random secret seed>).\n>> If she need the hash to the first commitment she need to hash the random secret\n>> seed 1000000 times. I think it is exactly the same problem as it is the exact\n>> same idea said differently.\n>>\n>> On Tue, Mar 8, 2016 at 8:31 AM, Rusty Russell <rusty at rustcorp.com.au>\n>> wrote:\n>>         Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n>>         > One way deterministic RValue Generation\n>>         \n>>         Hi Nicolas,\n>>         \n>>                 Yes, in fact shachain is a variant of this which\n>>         avoids\n>>         generating several million hashes in advance.  Interesting, I\n>>         suggested\n>>         using hashing in the Deployable Lightning paper but didn't\n>>         actually\n>>         spell out the idea.  Hmm....\n>>         \n>>         Seems like it orignated from Adam Back:\n>>         \n>>         https://lists.blockstream.io/pipermail/lightning-dev/2015-May/000000.html\n>>         \n>>         Cheers,\n>>         Rusty.\n>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n\n-- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/a8837477/attachment-0001.sig>"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-08T15:51:00",
                "message_text_only": "I'm not sure what you mean Alice don't have to disclose R if she does not\nwant to.\nBob can't know the next R because R(n+1) = PreImage(R(n))\n\nOn Wed, Mar 9, 2016 at 12:16 AM, Mats Jerratsch <mats at blockchain.com> wrote:\n\n> What about if Alice does not want to disclose R? Bob could have taken\n> too much fee and Alice does not agree to accept a payment too small.\n>\n> While there is technically not really a security problem in disclosing\n> the R values when the payment isn't in the current commitment, the whole\n> idea of 'proof-of-payment'/'pay-to-contract' relies on only revealing R\n> for an accepted payment.\n>\n> Otherwise, knowing R is no longer proof of having made a payment.\n>\n> Am 08/03/2016 um 07:19 schrieb CJP:\n> > I was wondering: how does deriving R values from a tree structure work\n> > for larger Lightning networks? I guess it could work between two nodes,\n> > if they keep track of the same tree, but if different transactions\n> > follow different routes, does that mean the tree structure somehow has\n> > to be shared across all nodes? The alternative is that intermediate\n> > nodes still have to remember old R values.\n> >\n> > CJP\n> >\n> >\n> > Nicolas Dorier schreef op di 08-03-2016 om 13:53 [+0900]:\n> >> Great, indeed we had same idea, I don't see how it solve the hashes in\n> >> advance.\n> >> As Alice knows\n> >> H(1000000) = <random secret seed>).\n> >> If she need the hash to the first commitment she need to hash the\n> random secret\n> >> seed 1000000 times. I think it is exactly the same problem as it is the\n> exact\n> >> same idea said differently.\n> >>\n> >> On Tue, Mar 8, 2016 at 8:31 AM, Rusty Russell <rusty at rustcorp.com.au>\n> >> wrote:\n> >>         Nicolas Dorier <nicolas.dorier at gmail.com> writes:\n> >>         > One way deterministic RValue Generation\n> >>\n> >>         Hi Nicolas,\n> >>\n> >>                 Yes, in fact shachain is a variant of this which\n> >>         avoids\n> >>         generating several million hashes in advance.  Interesting, I\n> >>         suggested\n> >>         using hashing in the Deployable Lightning paper but didn't\n> >>         actually\n> >>         spell out the idea.  Hmm....\n> >>\n> >>         Seems like it orignated from Adam Back:\n> >>\n> >>\n> https://lists.blockstream.io/pipermail/lightning-dev/2015-May/000000.html\n> >>\n> >>         Cheers,\n> >>         Rusty.\n> >>\n> >>\n> >> _______________________________________________\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n>\n> --\n> Mats Jerratsch\n> Backend Engineer, Blockchain\n> e: mats at blockchain.com\n> PGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160309/1419e43d/attachment-0001.html>"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-08T15:53:04",
                "message_text_only": "I'm not saying they close the channel. Alice could want to receive more\nmoney and accept other payments, but not a particular one. But by doing\nso, she would automatically disclose R for any old payment.\n\nAm 08/03/2016 um 15:51 schrieb Nicolas Dorier:\n> I'm not sure what you mean Alice don't have to disclose R if she does\n> not want to.\n\n-- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/14ff2555/attachment-0001.sig>"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-08T16:14:59",
                "message_text_only": "I don't understand your point, but that may come from me not having\ndeep enough knowledge about the latest great things happening on\nLightning.\n\nI exposed the case of a simple bipayment channel, without HTLC in the\nequation, where all payments are sequential.\n\nYou can't make commitment n+2 before accepting commitment n+1.\n\nMy mental model might be incomplete as I'm followed only remotely\nthe improvements of lightning until now.\n\nOn Wed, Mar 9, 2016 at 12:53 AM, Mats Jerratsch <mats at blockchain.com> wrote:\n\n> I'm not saying they close the channel. Alice could want to receive more\n> money and accept other payments, but not a particular one. But by doing\n> so, she would automatically disclose R for any old payment.\n>\n> Am 08/03/2016 um 15:51 schrieb Nicolas Dorier:\n> > I'm not sure what you mean Alice don't have to disclose R if she does\n> > not want to.\n>\n> --\n> Mats Jerratsch\n> Backend Engineer, Blockchain\n> e: mats at blockchain.com\n> PGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160309/da779a3b/attachment-0001.html>"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-08T16:27:06",
                "message_text_only": "Hah I see, I didn't knew you weren't talking about HTLCs.\n\nBut why would you use R values in the first place then? Maybe I'm a\nlittle bit confused about what exact use case we are talking here, mind\nelaborating? :)\n\nAm 08/03/2016 um 16:14 schrieb Nicolas Dorier:\n> I don't understand your point, but that may come from me not having\n> deep enough knowledge about the latest great things happening on\n> Lightning.\n> \n> I exposed the case of a simple bipayment channel, without HTLC in the\n> equation, where all payments are sequential. \n> \n> You can't make commitment n+2 before accepting commitment n+1.\n> \n> My mental model might be incomplete as I'm followed only remotely\n> the improvements of lightning until now.\n> \n> On Wed, Mar 9, 2016 at 12:53 AM, Mats Jerratsch <mats at blockchain.com\n> <mailto:mats at blockchain.com>> wrote:\n> \n>     I'm not saying they close the channel. Alice could want to receive more\n>     money and accept other payments, but not a particular one. But by doing\n>     so, she would automatically disclose R for any old payment.\n> \n>     Am 08/03/2016 um 15:51 schrieb Nicolas Dorier:\n>     > I'm not sure what you mean Alice don't have to disclose R if she does\n>     > not want to.\n> \n>     --\n>     Mats Jerratsch\n>     Backend Engineer, Blockchain\n>     e: mats at blockchain.com <mailto:mats at blockchain.com>\n>     PGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n> \n> \n\n-- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/1a07bd25/attachment-0001.sig>"
            },
            {
                "author": "Nicolas Dorier",
                "date": "2016-03-08T16:38:11",
                "message_text_only": "That's my fault, I said \"R-Value\" instead of \"Commit Revocation Hash\".\nI've not yet thought about how the idea of hash chain can be used for HTLC.\n\nOn Wed, Mar 9, 2016 at 1:27 AM, Mats Jerratsch <mats at blockchain.com> wrote:\n\n> Hah I see, I didn't knew you weren't talking about HTLCs.\n>\n> But why would you use R values in the first place then? Maybe I'm a\n> little bit confused about what exact use case we are talking here, mind\n> elaborating? :)\n>\n> Am 08/03/2016 um 16:14 schrieb Nicolas Dorier:\n> > I don't understand your point, but that may come from me not having\n> > deep enough knowledge about the latest great things happening on\n> > Lightning.\n> >\n> > I exposed the case of a simple bipayment channel, without HTLC in the\n> > equation, where all payments are sequential.\n> >\n> > You can't make commitment n+2 before accepting commitment n+1.\n> >\n> > My mental model might be incomplete as I'm followed only remotely\n> > the improvements of lightning until now.\n> >\n> > On Wed, Mar 9, 2016 at 12:53 AM, Mats Jerratsch <mats at blockchain.com\n> > <mailto:mats at blockchain.com>> wrote:\n> >\n> >     I'm not saying they close the channel. Alice could want to receive\n> more\n> >     money and accept other payments, but not a particular one. But by\n> doing\n> >     so, she would automatically disclose R for any old payment.\n> >\n> >     Am 08/03/2016 um 15:51 schrieb Nicolas Dorier:\n> >     > I'm not sure what you mean Alice don't have to disclose R if she\n> does\n> >     > not want to.\n> >\n> >     --\n> >     Mats Jerratsch\n> >     Backend Engineer, Blockchain\n> >     e: mats at blockchain.com <mailto:mats at blockchain.com>\n> >     PGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n> >\n> >\n>\n> --\n> Mats Jerratsch\n> Backend Engineer, Blockchain\n> e: mats at blockchain.com\n> PGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160309/a8253fb1/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-09T00:43:36",
                "message_text_only": "Mats Jerratsch via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org> writes:\n> What about if Alice does not want to disclose R? Bob could have taken\n> too much fee and Alice does not agree to accept a payment too small.\n>\n> While there is technically not really a security problem in disclosing\n> the R values when the payment isn't in the current commitment, the whole\n> idea of 'proof-of-payment'/'pay-to-contract' relies on only revealing R\n> for an accepted payment.\n\nNomenclature clash :(\n\nWe usually use R to mean the chained atomic swap preimage, which\nallows you to claim the funds (presumably R means \"receipt\" here).\n\nConfusingly, we also use \"revocation preimage\" as the term method to\ninvalidate old transactions, a private matter between pairs of nodes,\nbut try to avoid abbreviating it to R.\n\nWe can't use a simple chain for R (because they need to disclose them\nout of order), and don't need to (since they don't care about the value\nonce it's spent).\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Backward deterministic R Value",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Nicolas Dorier",
                "Mats Jerratsch",
                "CJP"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 18027
        }
    },
    {
        "title": "[Lightning-dev] Laundry list of inter-peer wire protocol changes",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-03-08T05:55:56",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Wed, Jan 27, 2016 at 01:37:04PM +1030, Rusty Russell wrote:\n>> Misc\n>> ----\n>> - shachain vs elkrem\n>>   - We use this to generate the revocation secrets, to minimize storage\n>>     and computation for a huge number of old commitment txs.\n>>   - They're actually very similar, but elkrem is much easier to grok.[6]\n>\n> Hmm, I was going to say I like it, but I'm not sure I do...\n\nOK, I revisited shachain; it's nicer to describe in terms of a binary\ntree.  The derivation is still a little complex, but people should find\nthis far less brainbendy.\n\nAnd yes, I reversed the indices, so we start with 0xFFFFFFFFFFFFFFFF and\nwork back towards the seed at 0.\n\n>From https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt:\n\nA Tree Solution\n---------------\n\nA better solution is to use a binary tree, with the seed at the root.\nThe left child is the same as the parent, the right child is the\nSHA256() of the parent with one bit flipped (corresponding to the\nheight).\n\nThis gives a tree like so:\n\n                      seed\n                    /      \\\n                  /          \\\n                /              \\\n              /                  \\\n            seed                   SHA256(seed^1)\n           /    \\                  /             \\\n       seed    SHA256(seed^2)  SHA256(seed^1)  SHA256(SHA256(seed^1)^2)\nIndex:  0         1                2                  3\n\nClearly, giving R(2) allows you to derive R(3), giving R(1) allows you\nto derive nothing new (you still have to remember R(2)), and giving\nR(0) allows you to derive everything.\n\nIn pseudocode, this looks like the following for a 64 bit tree:\n\ngenerate_from_seed(index):\n    value = seed\n    for bit in 0 to 63:\n        if bit set in index:\n            flip(bit) in value\n            value = SHA256(value)\n    return value\n\n\nThe Receiver's Tree\n-------------------\n\nTo derive the value for a index N, you need to have the root of a tree\nwhich contains it.  That is the same as needing an index I which is N\nrounded down in binary: eg. if N is 0b001100001, you need 0b001100000,\n0b001000000 or 0b000000000.\n\nPseudocode:\n\n# Can we derive the value for to_index from from_index?\ncan_derive(from_index, to_index):\n    # to_index must be a subtree under from_index; this is the same as\n    # saying that to_index must be the same as from_index up to the\n    # trailing zeros in from_index.\n    for bit in count_trailing_zeroes(from_index)..63:\n        if bit set in from_index != bit set in to_index:\n            return false\n    return true\n\n# Derive a value from a lesser index: generalization of generate_from_seed()\nderive(from_index, to_index, from_value):\n    assert(can_derive(from_index, to_index))\n    value = from_value\n    for bit in 0..63:\n        if bit set in to_index and not bit set in from_index:\n            flip bit in value\n            value = SHA256(value)\n    return value\n\nIf you are receiving values (in reverse order), you need to remember\nup to 64 of them to derive all previous values.  The simplest method\nis to keep an array, indexed by the number of trailing zeroes in the\nreceived index:\n\n# Receive a new value (assumes we receive them in order)\nreceive_value(index, value):\n    pos = count_trailing_zeroes(index)\n    # We should be able to generate every lesser value, otherwise invalid\n    for i in 0..pos-1:\n       if derive(index, value, known[i].index) != known[i].value:\n            return false\n    known[pos].index = index\n    known[pos].value = value\n    return true\n\nTo derive a previous value, find an element in that array from which\nyou can derive the value you want, eg:\n\n# Find an old value\nregenerate_value(index):\n    for i in known:\n        if can_derive(i.index, index):\n            return derive(i.index, i.value, index)\n    fail\n\nYou can see the implementation for more optimized variants of the\nabove code.\n\nRusty Russell <rusty at rustcorp.com.au>"
            }
        ],
        "thread_summary": {
            "title": "Laundry list of inter-peer wire protocol changes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3947
        }
    },
    {
        "title": "[Lightning-dev] Simplifying revocation through a new opcode for general signature verification?",
        "thread_messages": [
            {
                "author": "Martijn Meijering",
                "date": "2016-03-08T19:21:24",
                "message_text_only": "Now that we almost have SegWit and its soft fork mechanism for upgrading\nthe scripting system, wouldn't it be a good idea to introduce a new opcode\nfor signature verification for arbitrary but appropriately\nlength-restricted messages? Instead of maintaining mirror images of txs and\ngoing through the dance of revealing hash preimages, wouldn't it be easier\nto to sign a message that revokes a previous balance (with hash + sequence\nnumber)? Am I overlooking anything? This looks like a simple new opcode\nthat could substantially simplify the LN protocol.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/cdec7da8/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2016-03-08T19:23:33",
                "message_text_only": "How is that in practice any different than a hash preimage?\nOn Mar 8, 2016 2:21 PM, \"Martijn Meijering\" <martijn.meijering at mevs.nl>\nwrote:\n\n> Now that we almost have SegWit and its soft fork mechanism for upgrading\n> the scripting system, wouldn't it be a good idea to introduce a new opcode\n> for signature verification for arbitrary but appropriately\n> length-restricted messages? Instead of maintaining mirror images of txs and\n> going through the dance of revealing hash preimages, wouldn't it be easier\n> to to sign a message that revokes a previous balance (with hash + sequence\n> number)? Am I overlooking anything? This looks like a simple new opcode\n> that could substantially simplify the LN protocol.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160308/80b0d416/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Simplifying revocation through a new opcode for general signature verification?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Martijn Meijering",
                "Mark Friedenbach"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1846
        }
    },
    {
        "title": "[Lightning-dev] terminology",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2016-03-09T06:48:50",
                "message_text_only": ">From IRC:\n\n<rusty> Hmm, what term should I use in documentation for the\n        failure mode where a node uses too tight a timeout and ends up\n        paying out an outgoing HTLC but unable to redeem the incoming\n        HTLC?\n<rusty> \"one-sided redemption\" is what I came up with, but it's not very\n        punchy for \"you screwed up and lost money\"\n\nThat's too loose a timeout, isn't it? You choose the timeout for your\noutgoing payment, so if the incoming timeout runs out, your outgoing\ntimeout was too long.\n\nI'd just call it \"avoiding timeout on incoming HTLC when forwarding\"\nor similar?\n\nOn Wed, Mar 09, 2016 at 11:13:36AM +1030, Rusty Russell wrote:\n> Confusingly, we also use \"revocation preimage\" as the term method to\n> invalidate old transactions, a private matter between pairs of nodes,\n> but try to avoid abbreviating it to R.\n\nYeah, the lack of an obvious abbreviation for the revocation preimage\nhas bugged me a couple of times. What about saying we \"void\" the old\ncommitment, and use \"V\" as the symbol for the hash/signature/whatever?\n\n(R for the HTLC \"receipt\" seems to work okay so probably good to keep\nthat)\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-10T01:13:58",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n>>From IRC:\n>\n> <rusty> Hmm, what term should I use in documentation for the\n>         failure mode where a node uses too tight a timeout and ends up\n>         paying out an outgoing HTLC but unable to redeem the incoming\n>         HTLC?\n> <rusty> \"one-sided redemption\" is what I came up with, but it's not very\n>         punchy for \"you screwed up and lost money\"\n>\n> That's too loose a timeout, isn't it? You choose the timeout for your\n> outgoing payment, so if the incoming timeout runs out, your outgoing\n> timeout was too long.\n>\n> I'd just call it \"avoiding timeout on incoming HTLC when forwarding\"\n> or similar?\n\nHere's what I've got in my current draft, which spells out the exact\nrequirements in detail:\n\n## Risks With HTLC Timeouts ##\n\nHTLCs tend to be chained across the network.  For example, a node A\nmight offer node B an HTLC with a timeout of 3 days, and node B might\noffer node C the same HTLC with a timeout of 2 days.\n\nThis difference in timeouts is important: after 2 days B can try to\nremove the offer to C even if C is unresponsive, by broadcasting the\ncommitment transaction it has with C and spending the HTLC output.\nEven though C might race to try to use its R preimage at that point to\nalso spend the HTLC, it should be resolved well before the 3 day\ndeadline so B can either redeem the HTLC off A or close it.\n\nIf the timing is too close, there is a risk of \"one-sided redemption\",\nwhere the R preimage received from an offered HTLC is too late to be\nused for an incoming HTLC, leaving the node with unexpected liability.\n\nHowever, there is an additional relative delay which needs to be\nconsidered; if the connection fails, the node is forced to broadcast\nthe latest commitment transaction to the blockchain.  It will not be\nable to reclaim timed-out HTLC funds until `delay` (as specified by\nthe other node's `open_message`) has passed.  Thus the actual timeout\nof the HTLC is the greater of `expiry`, and the current time plus\n`delay`.  In addition, there will be some additional delay for the\ntransaction which redeems the HTLC output to be irreversibly committed\nto the blockchain.\n\nThus a node MUST estimate the deadline for successful redemption for\neach HTLC it offers.  A node MUST NOT offer a HTLC after this\ndeadline, and MUST fail the connection if an HTLC which it offered is\nin either node's current commitment transaction past this deadline.\n---\n\n> On Wed, Mar 09, 2016 at 11:13:36AM +1030, Rusty Russell wrote:\n>> Confusingly, we also use \"revocation preimage\" as the term method to\n>> invalidate old transactions, a private matter between pairs of nodes,\n>> but try to avoid abbreviating it to R.\n>\n> Yeah, the lack of an obvious abbreviation for the revocation preimage\n> has bugged me a couple of times. What about saying we \"void\" the old\n> commitment, and use \"V\" as the symbol for the hash/signature/whatever?\n\nInvalidate, hence I?  I find void confusing as it's a noun and verb...\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "terminology",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4138
        }
    },
    {
        "title": "[Lightning-dev] [BOLT RFC#2] Protocol spec",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-03-11T05:15:07",
                "message_text_only": "Hi all,\n\n        More verbiage; this time the actual wire protocol.  It's mainly\ncomplete, but since I haven't modified my implementation to match\n(particularly the parts around fee negotiation), take with a huge grain\nof salt until I've done that.\n\nIt also refers to \"#3: Transaction formats\" and \"#4: Onion Routing And\nError Formats\" which don't exist yet, but they'll have to wait until the\nC implementation has caught up eith this.\n\nNote that I haven't renamed \"revocation\" to \"invalidation\" yet, but I\nthink that's a good idea.\n\nURL here:\n\n\thttps://github.com/rustyrussell/lightning/blob/master/communications/low/02-wire-protocol.md\n\nThanks!\nRusty.\n\n# Basis of Lightning Technology RFC 2 #\n\n# Status #\n\nInitial draft\n\n# Author #\n\nRusty Russell, Blockstream <mailto:rusty at rustcorp.com.au>\n\n# Abstract #\n\nPairs of lightning nodes cooperate to establish a bitcoin transaction\n(called a \"channel\") which requires the two of them to spend, and\nmanage updates which spend that transaction.  This occurs in three\nphases:\n\n1.  Channel Establishment\n2.  Normal Operation\n3.  Channel Close\n\nThis document describes the protocol used between nodes for each of\nthese phases.\n\n# General Protocol #\n\nThe wire protocol used is protobufs[1], passed over an encrypted\nchannel set up and used as specified in BOLT#1[2].\n\nIn general, if a node received a field it does not understand, if the\nfield number is odd it MUST ignore it, if it is even it MUST treat it\nas an error and fail the connection (also known as \"it's OK to be\nodd\").  A node MUST NOT send out an even-numbered field not listed\nhere without prior negotiation for its acceptance.\n\n## pkt message format ##\n\n    // This is the union which defines all of them\n    message pkt {\n      oneof pkt {\n\t  FIXME\n      }\n    }\n\n## Persistence and Retransmission ##\n\nBecause communication transports are unreliable and may need to be\nre-established from time to time, the design of the transport has been\nexplicitly separated from the protocol.\n\nA node MUST handle continuing a previous channel on a new encrypted\ntransport.  A node MUST set the packet counter of the authenticate\nmessage to one less than the messages it intends to retransmit, MUST\nretransmit packets which may not have been received by the other node,\nand MUST ensure they are bitwise identical.\n\n# Channel Establishment #\n\nChannel establishment begins immediately after authentication, and consists of each node sending an `open_channel` message, followed by one node sending `open_anchor`, the other providing its `open_commit_sig` then both sides waiting for the anchor transaction to enter the blockchain and reach their specified depth, at which point they send `open_complete`.  After both sides have sent `open_complete` the channel is established and can begin normal operation.\n\nIf this fails at any stage, or a node decides that the channel terms offered by the other node are not suitable, see \"Failing The Connection\".\n\n## The Initial open_channel message ##\n\nThe first message for a new connection after authentication is the\n`open_channel` message.  This contains information about each node, and\nits requirements to set up a channel.\n\nInformational fields are:\n\n* `revocation_hash`, `next_revocation_hash`: the revocation hashes for the first two commitment transactions.  See \"Revocation Hashes\".\n* `commit_key`: the bitcoin pubkey which this node will use to sign commitment transactions and redeem the anchor transaction output.\n* `final_key`: the bitcoin pubkey to use for a mutual close transaction.\n* `anch`: whether the node will create the anchor transaction to fund the channel or not.  Currently this MUST be set to `WILL_CREATE_ANCHOR` by the node which created the connection, and `WONT_CREATE_ANCHOR` by the node which received the connection request.\n\nThe negotiation fields which place requirements on the receiver are:\n\n* `delay`: the `OP_CHECKSEQUENCEVERIFY` value the other node should use to delay payments to itself.  The sender SHOULD set this to a value sufficient to ensure it can irreversibly spend a commitment transaction output in case of misbehavior by the receiver.  This is effectively a demand on how long the receiver could have their funds withheld, thus the receiver MUST reject the delay if it considers it unreasonably large.\n* `min_depth`: the minimum block depth before the anchor transaction is considered irreversible and Normal Operation can begin.  The receiver MAY reject the delay if it considers it unreasonably large; the sender which is not creating the anchor SHOULD set this to a value sufficient to ensure the anchor cannot be unspent.\n* `commitment_fee_rate`: the fee-per-kilobyte to use on commitment transactions, in satoshi.  The receiver MUST fail the connection if considers this unnecessarily large or too small for timely processing.  The sender SHOULD set this to at least the rate it estimates would cause the transaction to be immediately included in a block.\n\n### open_channel message format ###\n\n    // Set channel params.\n    message open_channel {\n      // Relative locktime for outputs going to us.\n      required locktime delay = 1;\n      // Hash for revoking first commitment transaction.\n      required sha256_hash revocation_hash = 2;\n      // Hash for revoking second commitment transaction.\n      required sha256_hash next_revocation_hash = 8;\n      // Pubkey for anchor to pay into commitment tx.\n      required bitcoin_pubkey commit_key = 3;\n      // How to pay money to us from commit_tx.\n      required bitcoin_pubkey final_key = 4;\n    \n      enum anchor_offer {\n        // I will create the anchor\n        WILL_CREATE_ANCHOR = 1;\n        // I won't create the anchor\n        WONT_CREATE_ANCHOR = 2;\n      }\n      required anchor_offer anch = 5;\n    \n      // How far must anchor be buried before we consider channel live?\n      optional uint32 min_depth = 6 [ default = 0 ];\n    \n      // How much fee would I like on commitment tx?\n      required uint32 commitment_fee_rate = 7;\n    }\n\n## Describing the anchor transaction: open_anchor ##\n\nWhichever node offered the anchor (`WILL_CREATE_ANCHOR`) will initially fund the channel.  This node will create a transaction with an output redeemable by the `commit_key`s from both nodes (see [3]), which it MUST NOT broadcast.  It then sends an `open_anchor` message which allows the recipient to calculate the signature for the initial commitment transaction.\n\nThe fields of this message are:\n\n* `txid`: the transaction ID of the anchor transaction.\n* `output_index`: the index of the output which is to fund the channel.\n* `amount`: the amount in satoshis of the `output_index` output of `txid`.\n* `commit_sig`: the signature for the receiver's initial commitment transaction.\n\nThe receiver MAY fail the connection if `amount` is too low; the sender MUST offer an `amount` sufficient to cover the fees of both initial commitment transactions.  The receiver MUST fail the connection if the `commit_sig` does not sign its initial commit transaction.\n\n### open_anchor message format ###\n\n    // Whoever is supplying anchor sends this.\n    message open_anchor {\n      // Transaction ID of anchor.\n      required sha256_hash txid = 1;\n      // Which output is going to the 2 of 2.\n      required uint32 output_index = 2;\n      // Amount of anchor output.\n      required uint64 amount = 3;\n    \n      // Signature for your initial commitment tx.\n      required signature commit_sig = 4;\n    }\n\n## Accepting the Anchor Transaction: open_commit_sig ##\n\nUpon accepting the `open_anchor` message, the node creates a signature for the anchor creator's initial commitment transaction, and sends it in an `open_commit_sig` message.\n\nThe receiver (ie. anchor creator) MUST fail the connection if the `commit_sig` does not sign its initial commitment transaction.  The receiver SHOULD broadcast the anchor transaction upon receipt of the signature; this ensures that it can use that signature on our initial commitment transaction to redeem the anchor funds in case of failure.\n\n### open_commit_sig message format ###\n\n    // Reply: signature for your initial commitment tx\n    message open_commit_sig {\n      required signature sig = 1;\n    }\n\n## Waiting for the Anchor: open_complete ##\n\nOnce the anchor has reached `min_depth` in the blockchain, the node sends `open_complete` to indicate it is ready to transition to normal operating mode.  A node MUST NOT begin normal operation until it has both sent and received `open_complete`.  A node MAY fail the connection if it does not receive `open_complete` in a timely manner after the other's `min_depth` is reached.\n\n### open_complete message format ###\n\n    // Indicates we've seen anchor reach min-depth.\n    message open_complete {\n      // FIXME: add a merkle proof plus block headers here?\n    }\n\n# Normal Operation #\n\nOnce both nodes have exchanged `open_complete`, the channel can be\nused to make payments via Hash TimeLocked Contracts.  Each node\nstores:\n\n1. Other node's previous obsoleted commitment transactions\n(or at least enough information to spend them, see [3]),\n2. The current HTLCs.\n3. The other node's signature on the commitment transaction created from current HTLCs.\n4. A list of staged changes proposed by the other node.\n5. A list of staged changes proposed by this node.\n\nNote that updates are asynchronous, which means that the two\ncommitment transactions may be out of sync in intermediate stages.\n\nEach node can send messages offering new HTLCs or closing HTLCs\noffered by the other node, and then a signature to commit to those\nchanges and any it has received: this message indicates the highest\nupdate number being applied, as there is a possible ambiguity for\nin-flight updates.  Once a node has received a signature for a new\ncommitment transaction, it sends the revocation preimage which\ninvalides the old one.\n\nHere's an example:\n\n    NODE A                NODE B\n\tCommitted: []         Committed: []\n\tStaged:    []         Staged:    []\n\nA decides to offer a new HTLC X:\n\n    Committed: []\n    Staged:    [X]\n         ADD HTLC X ----->\n\t                      Committed: []\n\t                      Staged:    [X]\n\nB decides to offer a new HTLC Y:\n\n\t                      Committed: []\n\t                      Staged:    [X Y]\n            <---------- ADD HTLC Y\n    Committed: []\n    Staged:    [X Y]\n\nA decides to commit its update, and the 1 update it got from B:\n\n         SIG 1 ----->\n\t                      Committed: [X Y]\n\t                      Staged:    []\n\nB replies with the revocation preimage which invalidates its old\ncommitment transaction, and a signature for the new commitment\ntransaction which includes one update from A:\n\n             <--------- REVOCATION\n             <--------- SIG 1\n\nA receives this signature and now commits and sends its revocation\npreimage for its old commitment transaction:\n\n    Committed: [X Y]\n    Staged:    []\n             REVOCATION --------->\n\nThere are several alternate timing scenarios: if B decided to commit\nin parallel to A, before receiving A's update:\n\n           NODE A                NODE B\n\n                  <---------- ADD HTLC Y\n         ADD HTLC X ------>\n                  <---------- SIG 0\n         SIG 1 ----------->\n\t\t                       Committed: [X Y]\n\t                           Staged:    []\n    Committed: [Y]\n    Staged:    [X]\n         REVOCATION --------->\n\n                  <---------- REVOCATION\n                  <---------- SIG 1\n    Committed: [Y X]\n    Staged:    []\n         REVOCATION --------->\n\nHere, A received the signature and commits B's update but not its own\n(because B didn't acknowledge it); later B responds with a signature\nincluding A's update and A commits that update too.\n\n## Risks With HTLC Timeouts ##\n\nHTLCs tend to be chained across the network.  For example, a node A\nmight offer node B an HTLC with a timeout of 3 days, and node B might\noffer node C the same HTLC with a timeout of 2 days.\n\nThis difference in timeouts is important: after 2 days B can try to\nremove the offer to C even if C is unresponsive, by broadcasting the\ncommitment transaction it has with C and spending the HTLC output.\nEven though C might race to try to use its R preimage at that point to\nalso spend the HTLC, it should be resolved well before the 3 day\ndeadline so B can either redeem the HTLC off A or close it.\n\nIf the timing is too close, there is a risk of \"one-sided redemption\",\nwhere the R preimage received from an offered HTLC is too late to be\nused for an incoming HTLC, leaving the node with unexpected liability.\n\nHowever, there is an additional relative delay which needs to be\nconsidered; if the connection fails, the node is forced to broadcast\nthe latest commitment transaction to the blockchain.  It will not be\nable to reclaim timed-out HTLC funds until `delay` (as specified by\nthe other node's `open_message`) has passed.  Thus the actual timeout\nof the HTLC is the greater of `expiry`, and the current time plus\n`delay`.  In addition, there will be some additional delay for the\ntransaction which redeems the HTLC output to be irreversibly committed\nto the blockchain.\n\nThus a node MUST estimate the deadline for successful redemption for\neach HTLC it offers.  A node MUST NOT offer a HTLC after this\ndeadline, and MUST fail the connection if an HTLC which it offered is\nin either node's current commitment transaction past this deadline.\n\n## Adding an HTLC ##\n\nEither node can offer a HTLC to the other, which is redeemable in\nreturn for a hash preimage (sometimes referred to as R).  Amounts are\nin millisatoshi, though on-chain enforcement is only possible for\nwhole satoshi amounts: in commitment transactions these are rounded\ndown as specified in [3].\n\nA node MUST NOT offer `amount_msat` it cannot pay for in both commitment\ntransactions (see \"Fee Calculation\" ), a node SHOULD fail the\nconnection if this occurs.  `amount_msat` MUST BE greater than 0.\n\nA node MUST NOT add a HTLC if it would result in it offering more than\n1500 HTLCs in either commitment transaction.  At 32 bytes per HTLC\noutput, this is comfortably under the 100k soft-limit for standard\ntransaction relay.\n\nA node SHOULD NOT offer a HTLC with a timeout less than `delay` in the\nfuture.  See also \"Risks With HTLC Timeouts\".\n\n### update_add_htlc message format ###\n\n    message update_add_htlc {\n      // Amount for htlc (millisatoshi)\n      required uint32 amount_msat = 2;\n      // Hash for HTLC R value.\n      required sha256_hash r_hash = 3;\n      // Time at which HTLC expires (absolute)\n      required locktime expiry = 4;\n\t  // Onion-wrapped routing information.\n\t  required routing = 5;\n    }\n\n## Removing an HTLC: update_fulfill_htlc and update_fail_htlc ##\n\nFor simplicity, a node can only remove HTLCs added by the other node.\nThere are three reasons for removing an HTLC: it has timed out, it has\nfailed to route, or the R preimage is supplied.\n\nA node SHOULD remove an HTLC as soon as it can; in particular, a node\nSHOULD fail an HTLC which has timed out, otherwise it risks connection\nfailure (see \"Risks With HTLC Timeouts\").\n\nA node MUST check that the `index` is less than the number of HTLCs it\nhas offered in the current commitment transaction, and MUST fail the\nconnection if it does not.  The `index` refers to the current HTLCs in\nthe order they were offered.\n\nA node MUST check that the `r` value in `update_fulfill_htlc` hashes\nto the corresponding HTLC, and MUST fail the connection if it does not.\n\nThe `reason` field is an opaque encrypted blob for the benefit of the\noriginal HTLC initiator as defined in [4].  A node which closes an\nincoming HTLC in response to an `update_fail_htlc` message on an\noffered HTLC MUST copy this field to the outgoing `update_fail_htlc`.\n\n### update_fulfill_htlc message format ###\n\n    // Complete your HTLC: I have the R value, pay me!\n    message update_fulfill_htlc {\n      // Which HTLC (index into current HTLCs in the order offered)\n      required int32 index = 1;\n      // HTLC R value.\n      required sha256_hash r = 2;\n    }\n    \n### update_fail_htlc message format ###\n\t\n    message update_fail_htlc {\n      // Which HTLC (index into current HTLCs in the order offered)\n      required int32 index = 1;\n\t  // Reason for failure (for relay to initial node)\n\t  required fail_reason reason = 2;\n    }\n\n## Updating Fees: update_fee ##\n\nAn `update_fee` message is used to specify a range of acceptable fees\nfor the next commitment transaction; it constrains the `fee` field in\nthe receiver's next `update_commit` message.\n\nA node SHOULD track bitcoin fees independently, and SHOULD send an\n`update_fee` message whenever they change significantly.  It MAY\nsimply send an `update_fee` message on every new bitcoin block.\n\nA node MUST update bitcoin fees if it estimates that the current\ncommitment transaction will not be processed in a timely manner (see\n\"Risks With HTLC Timeouts\").\n\nA node MAY fail the connection if the `update_fee` range is not\nacceptable.\n\nAs the commitment transaction is only used in failure cases, it is\nsuggested that the minimum fee be the estimated rate required for a\ntransaction to enter the next 6 blocks, and the maximum fee to be at\nleast five times the fee rate estimated for entry into the next block.\n\nFields are as follows:\n* `min_rate`: minimum satoshis per 1000 bytes.\n* `max_rate`: maximum satoshis per 1000 bytes (inclusive).\n\n### update_fee message format ###\n\t\n    message update_fee {\n      required uint64 min_rate = 1;\n      required uint64 max_rate = 2;\n    }\n\n## Signing HTLCs So Far: update_commit and update_revocation ##\n\nWhen a node wants to update the commitment transaction to include the\nstaged changes, it generates the other node's commitment transaction with those changes, signs it and sends an `update_commit` message:\n\n* `sig`: the signature using the private key corresponding to `commit_key` for the receiving node's commitment transaction.\n* `your_changes`: the total number of changes (`update_add_htlc`, `update_fail_htlc`, `update_fulfill_htlc`, `update_fee` and `close_begin`) received so far.\n* `fee_rate`: set the fee for the receiving node's commitment transaction.\n\nA node MUST NOT send an `update_commit` message which does not include any updates.  Note that a node MAY send an `update_commit` message which only alters the fee.\n\nThe sending node MUST set `fee_rate` within the (inclusive) range of the last `update_fee` message acknowledged by `your_changes`.  The sending node MUST NOT set `fee_rate` such that it cannot afford its share of the fee.  See \"Fee Calculation\" for how this alters the commitment transaction.  The suggested `fee_rate` is twice the fee rate estimated for entry into the next block.\n\nThe receiver MUST check `fee` and fail the connection if it is not within this range, or the sending node cannot afford it.\n\nThe receiving node creates its own new commitment transaction\nwith the new fee, all the other node's staged changes and its own\nstaged changes up to and including `your_changes`.  The receiver MUST\ncheck the signature is valid for that transaction.\n\nThe receiver then responds with an `update_revocation` message which\ncontains the preimage for its old commitment transaction.\n\n* `revocation_preimage`: the SHA256() of this value is the revocation hash for the sender's old commitment transaction.\n* `next_revocation_hash`: the hash of the revocation for this node's next commitment transaction.\n\nThe receiver of `update_revocation` MUST check that the SHA256 hash of\n`revocation_preimage` matches the previous commitment transaction, and\nMUST fail if it does not.\n\nNodes MUST NOT broadcast old (revoked) commitment transactions; doing\nso will allow the other node to seize all the funds.  Nodes SHOULD NOT\nsign commitment transactions unless it is about to broadcast them (due\nto a failed connection), to reduce this risk.\n\n### update_commit message format ###\n\n    // Commit all the staged HTLCs.\n    message update_commit {\n      // Signature for your new commitment tx.\n      required signature sig = 1;\n      // Index of your changes included in new commitment tx.\n      required uint32 your_changes = 2;\n      // Fee for the new commitment tx.\n\t  required uint32 fee_rate = 3;\n    }\n\n### update_revocation message format ###\n\n    // Complete the update.\n    message update_revocation {\n      // Hash preimage which revokes old commitment tx.\n      required sha256_hash revocation_preimage = 1;\n      // Revocation hash for my next commit transaction\n      required sha256_hash next_revocation_hash = 2;\n    }\n\n## Fee Calculation ##\n\nThe fee for a commitment transaction is calculated by the multiplying\nthe number of bytes in the commitment transaction by the fee rate,\ndividing by 1000 and truncating (rounding down) the result to an even\nnumber of satoshis.\n\neg.  A 300-byte transaction with a `fee_rate` of 1111 has a fee of:\n\n\t300 * 1111 / 1000 = 333.3333 = 332 satoshis\n\nThe fee is extracted equally from both parties, if possible.  Since\nneither party can offer an HTLC they can't afford, this can only\nfail in two cases:\n\n1. The initial channel where the non-anchor node hasn't received enough\n   funds to allow it to pay its share of the fee, or\n2. Fee increases where one side doesn't have enough funds to pay their\n   share of the increased fee.\n\nIn both these cases, one side pays all it can, and the remainder is\npaid by the other side.  Note that the underpaying side will not be\nable to offer any new HTLCs until it has met its fee obligations.\n\n# Channel Close #\n\nNodes can negotiate a mutual close for the connection, which unlike a\nunilateral close, allows them to access their funds immediately and\ncan be negotiated with lower fees.\n\nClosing happens in two stages: the first is by one side indicating\nthat it wants to clear the channel (and thus will accept no new\nHTLCs), and once all HTLCs are resolved, the final channel close\nnegotiation begins.\n\n## Closing initiation: close_clearing ##\n\nEither node (or both) can send a `close_clearing` packet to initiate closing.\n\nA node MUST NOT send a `update_add_htlc` after a `close_clearing`, and\nmust not send more than one `close_clearing`.  A node MUST NOT send an\n`update_add_htlc` after sending an `update_commit` with a\n`your_changes` field acknowledging the other node's `close_clearing`.\n\nA node MUST respond with `update_fail_htlc` to any HTLC received after it sent `close_clearing`.\n\n### close_clearing message format ###\n\n    // Start clearing out the channel HTLCs so we can close it\n    message close_clearing {\n    }\n\n## Closing negotiation: close_signature ##\n\nOnce clearing is complete the final current commitment transactions\nwill have no HTLCs, and fee negotiation begins.  Each node chooses a\nfee and signs the close transaction with that fee, and sends the\nsignature.  The process terminates when both agree on a fee, or one\nside fails the connection.\n\nNodes SHOULD send a `close_signature` message after `close_clearing` has\nbeen received or acknowledged, and no HTLCs remain in either\ncommitment transaction:\n\n* `close_fee`: the fee to offer for the close transaction (in satoshis).\n* `sig`: the signature for the close transaction with that fee.\n\nThe sender MUST set `close_fee` lower than or equal to the fee of the\nfinal commitment transaction.\n\nThe sender SHOULD set the initial `close_fee` according to its\nestimate of cost of inclusion in a block.  Note that there is no\nsecurity issue if the closing transaction is delayed, and it will be\nbroadcast very soon, so there is usually no reason to pay a premium\nfor rapid processing.\n\nThe receiver MUST check `sig` is valid for the close transaction, and\nMUST fail the connection if it is not.\n\nIf the receiver agrees with the fee, it SHOULD reply with a\n`close_signature` with the same `close_fee` value and sign and\nbroadcast that closing transaction, otherwise it SHOULD propose a\nvalue between the received `close_fee` and its previously sent\n`close_fee`.\n\nOnce a node has sent or received a `close_signature` with matching\n`close_fee` it SHOULD close the connection.\n\n### close_signature message format ###\n\n    message close_signature {\n\t\t// Fee in satoshis.\n\t\trequired uint64 close_fee = 1;\n\t\t// Signature on the close transaction.\n\t\trequired signature sig = 2;\n    }\n\n# Revocation Hashes #\n\nRevocation hashes are used to allow invalidation of old commitment\ntransactions after a new one has been negotiated: the output scripts\nof a commitment transaction allow the other node to immediately spend\nthe output if they have the revocation preimage.\n\nFor efficiency, the series of revocation preimages are generated from\na single seed, which allows the receiver to compactly store them (see\n[5]).\n\nA node MUST select an unguessable 256-bit seed for each connection,\nand MUST NOT reveal the seed.  Up to 2^64-1 preimages can be generated;\nthe first preimage used MUST be index 18446744073709551615, and then\nthe index decremented.\n\nThe preimages P for index N MUST match the output of this algorithm:\n\n    generate_from_seed(seed, N):\n        P = seed\n        for B in 0 to 63:\n            if B set in N:\n                flip(B) in P\n                P = SHA256(P)\n        return P\n\nWhere \"flip(B)\" alternates the B'th least significant bit in the value P.\n\nThe receiving node MAY store all previous R values, or MAY calculate\nit from a compact representation as described in [5].\n\n# On The Blockchain #\n\nThe blockchain is used to enforce commitments in the case where\ncommunication or cooperation breaks down between two nodes.  This is\nslower and more expensive that using off-chain signature exchanges,\nbut vitally important for correct operation.\n\n## Monitoring the Blockchain ##\n\nOnce the anchor transaction is broadcast, a node MUST monitor for\ntransactions which spend the anchor transaction, and if seen it MUST\nfail the connection if not already failing or closed.\n\nIf a node sees a revoked commitment transaction, it MUST use the\nrevocation preimage to spend every output well before `delay` as\nspecified in the `open_channel`.  A node MAY need to use multiple\ntransactions to spend the outputs, and MUST ensure that these\ntransactions are each less than 100,000 bytes.\n\nA node MUST continue to monitor for (and react to) additional\ntransactions until one transaction is deeply buried (usually\nconsidered to be between 6 and 100 blocks).\n\n## On-chain HTLCs ##\n\nWhen a valid commitment transaction is broadcast, any HTLC outputs\nmust be monitored and handled as follows:\n\nFor each HTLC output this node offered:\n\n1. If it is spent (by the other node), the spending transaction\nreveals the R value which this node MUST use to redeem the corresponding\nincoming HTLC, if any.\n2. If it is timed out, this node MUST spend the output to itself (possibly after a delay).\n\nFor each HTLC output offered by the other node:\n\n1. If we know the R value, the node MUST spend the output to itself (possibly after a delay).\n2. Otherwise, if this node has no outgoing HTLC using the same the R value, it SHOULD ignore the output.\n\nNote that for a node broadcasting its own commitment transaction,\nthere is an additional OP_CHECKSEQUENCEVERIFY delay (correponding to\nthe other node's `open_channel` `delay` field) before it can spend the\noutput.\n\n## Failing The Connection ##\n\nFailure can happen under various circumstances, including protocol\nfailures, unreachability, timeouts or deliberate abort decisions.\n\nA node MUST NOT fail a connection simply because communication is lost\nor corrupted, thought it MAY fail after a timeout.\n\nA node MUST fail the connection if it receives an `err` message, and\nMUST NOT send an `err` message in this case.  For other connection\nfailures, a node SHOULD send an informative `err` message.\n\nThe behaviour when failing a connection depends on the state:\n\n1. If no anchor has been broadcast, nothing need be done.\n2. If no HTLC was ever created, the latest commitment transaction\nSHOULD be broadcast.\n3. If a valid `close_signature` was received, the node SHOULD use\n`sig` to create a close transaction, which SHOULD be broadcast.  (The last `close_signature` is closest to our desired fee).\n4. Otherwise, the node SHOULD sign and broadcast the latest commitment\n   transaction.\n\nIn the last two cases, the node MUST continue to monitor the\nblockchain for invalidated commitment transactions as in \"Monitoring\nThe Blockchain\".\n\n### err message format ###\n\n    // This means we're going to hang up; it's to help diagnose only! \n    message error {\n      optional string problem = 1;\n    }\n\n# Security Considerations #\n\nMany.  Try not to Gox anyone.\n\n# References #\n\n[1] https://github.com/google/protobuf\n\n[2] BOLT #1: Inter-node Encryption and Authentication\n\n[3] BOLT #3: Transaction formats\n\n[4] BOLT #4: Onion Routing And Error Formats\n\n[5] shachain design: https://github.com/rustyrussell/ccan/blob/master/ccan/crypto/shachain/design.txt\n\n# Acknowledgements #\n\nFIXME: Too many to list.\n\n# Feedback #\n\nFeedback is welcome on the [lightning-dev list](https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev)."
            }
        ],
        "thread_summary": {
            "title": "Protocol spec",
            "categories": [
                "Lightning-dev",
                "BOLT RFC#2"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 28985
        }
    },
    {
        "title": "[Lightning-dev] Proposal: Decentralized Service Provider",
        "thread_messages": [
            {
                "author": "Samuel Kremser",
                "date": "2016-03-11T08:49:49",
                "message_text_only": "Hi Guys!\n\nI wanna make a improvement proposal for the Lightning Network and would \nlike to hear your thoughts about it.\nI am calling it: Decentralized Service Provider (DSP).\n\nA Decentralized Service Provider (DSP) could grant end users access to \nthe Ligthning Network, so they wouldn't have to validate\nthe Blockchain or care about closing times of channels. Also end users \nwould enjoy the benefit of propably much larger\n(filled with more Bitcoins) channels which allows them to send and \nreceive more money, since all users of one DSP would share their channel(s).\n\nEach DSP consists of several entities (propbly also geographically \ndistributed).\nThese entities manage the DSP's tasks in a collaborative way.\nThese Tasks are:\n1. Managing Bitcoin deposits and withdrawals\n2. Managing the Lightning Network Channel(s)\n3. Managing communication with end users and the Lightning Network\n\nDeposit addresses for the DSP are multi-sig addresses, so that a \nmajority of a DSP's entities is required to sign withdrawals.\nAlso the Lightning Network channels are managed in this multi-sig \nstyle   .....erm.....  yes i am aware that Lightning Network channels\nare multig-sig anyway, what i wanted to say is: a update to the channel \nreqiures now a majority of the DSP's entities to singn AND\nthe other side of that channel to sign. In case both sides of the \nLighting Network channel are DSPs the majority of both DSP's entities \nneed to sign.\n\nDue to this multi-sig construction a single entity of a DSP couldn't \nsteal the end users Bitcoins. It would actually reqire the majority of \nentities of\none DSP to collaborate to steal the end users money.\n\nDSP's entities communicate with signed messages with their end users and \nwith each other, so everything is provable. Whenever some entity of a DSP\nis acting malicious the other entities of that DSP can decide to exclude \nthis entity from this DSP by transferring control of the managed \nBitcoins and\nchannels to some new multi-sig address(es)/channel(s) that doesn't \nrequire the malicous acting entity's signature.\nThis could also be done if one entity isn't reliable available.\n\nAnother advantage of DSP's would be that fewer channels are reqired, \nsince not every end user needs his own channel. Thus DSPs could save even\nmore space on the Blockchain than Lightning alone.\n\nThanks for your attention!\n\nSam"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-16T02:40:26",
                "message_text_only": "Samuel Kremser <sam at kremser-crypto.org> writes:\n> Hi Guys!\n>\n> I wanna make a improvement proposal for the Lightning Network and would \n> like to hear your thoughts about it.\n\nHi Sam!\n\n        Welcome to the list!\n\n> I am calling it: Decentralized Service Provider (DSP).\n>\n> A Decentralized Service Provider (DSP) could grant end users access to \n> the Ligthning Network, so they wouldn't have to validate\n> the Blockchain or care about closing times of channels.\n\nIt's an interesting idea; Lightning As A Service :)\n\n> Also end users \n> would enjoy the benefit of propably much larger\n> (filled with more Bitcoins) channels which allows them to send and \n> receive more money, since all users of one DSP would share their channel(s).\n>\n> Each DSP consists of several entities (propbly also geographically \n> distributed).\n> These entities manage the DSP's tasks in a collaborative way.\n> These Tasks are:\n> 1. Managing Bitcoin deposits and withdrawals\n> 2. Managing the Lightning Network Channel(s)\n> 3. Managing communication with end users and the Lightning Network\n>\n> Deposit addresses for the DSP are multi-sig addresses, so that a \n> majority of a DSP's entities is required to sign withdrawals.\n> Also the Lightning Network channels are managed in this multi-sig \n> style   .....erm.....  yes i am aware that Lightning Network channels\n> are multig-sig anyway, what i wanted to say is: a update to the channel \n> reqiures now a majority of the DSP's entities to singn AND\n> the other side of that channel to sign. In case both sides of the \n> Lighting Network channel are DSPs the majority of both DSP's entities \n> need to sign.\n>\n> Due to this multi-sig construction a single entity of a DSP couldn't \n> steal the end users Bitcoins. It would actually reqire the majority of \n> entities of\n> one DSP to collaborate to steal the end users money.\n\nThis is better than the current web-wallet model where only one party is\nrequired to steal everything :)\n\n> DSP's entities communicate with signed messages with their end users and \n> with each other, so everything is provable. Whenever some entity of a DSP\n> is acting malicious the other entities of that DSP can decide to exclude \n> this entity from this DSP by transferring control of the managed \n> Bitcoins and\n> channels to some new multi-sig address(es)/channel(s) that doesn't \n> require the malicous acting entity's signature.\n> This could also be done if one entity isn't reliable available.\n\nIt's actually tricky to design this system to be robust.  But I look\nforward to seeing someone try!\n\n> Another advantage of DSP's would be that fewer channels are reqired, \n> since not every end user needs his own channel. Thus DSPs could save even\n> more space on the Blockchain than Lightning alone.\n\nIt might shrink the UTXO set, but you still need to transfer bitcoins\nin of course.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Proposal: Decentralized Service Provider",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Samuel Kremser"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5223
        }
    },
    {
        "title": "[Lightning-dev] Lightning-dev Digest, Vol 10, Issue 14",
        "thread_messages": [
            {
                "author": "light at bitseed.org",
                "date": "2016-03-11T18:06:43",
                "message_text_only": "I like this proposal, Sam! This sounds similar to the \"voting pools\" \nconcept described by Justus Ranvier as a way to secure bitcoin that is \ndeposited into Open Transactions notary servers. This way, as you \npointed out, there can be no single point of failure.\n\nhttp://opentransactions.org/wiki/index.php?title=Category:Voting_Pools\n\nThis is similar to how Blockstream is securing their Liquid consortium \nsidechain:\n\nhttps://www.blockstream.com/2015/11/02/liquid-recap-and-faq/\n\nI could see a hybrid of Bitcoin multisig voting pools, OT servers, and \nInterledger-style contracts (to make payments between servers without \nfriction) being used to fulfill a similar purpose to that described in \nyour proposal.\n\nhttp://interledger.org/\n\nThe real magic, it seems, is in the pathfinding between hub nodes and \nendpoints.\n\nJL\n\nOn 2016-03-11 04:00, lightning-dev-request at lists.linuxfoundation.org \nwrote:\n> Message: 1\n> Date: Fri, 11 Mar 2016 09:49:49 +0100\n> From: Samuel Kremser <sam at kremser-crypto.org>\n> To: lightning-dev at lists.linuxfoundation.org\n> Subject: [Lightning-dev] Proposal: Decentralized Service Provider\n> Message-ID: <56E286AD.5060506 at kremser-crypto.org>\n> Content-Type: text/plain; charset=utf-8; format=flowed\n> \n> Hi Guys!\n> \n> I wanna make a improvement proposal for the Lightning Network and would\n> like to hear your thoughts about it.\n> I am calling it: Decentralized Service Provider (DSP).\n> \n> A Decentralized Service Provider (DSP) could grant end users access to\n> the Ligthning Network, so they wouldn't have to validate\n> the Blockchain or care about closing times of channels. Also end users\n> would enjoy the benefit of propably much larger\n> (filled with more Bitcoins) channels which allows them to send and\n> receive more money, since all users of one DSP would share their \n> channel(s).\n> \n> Each DSP consists of several entities (propbly also geographically\n> distributed).\n> These entities manage the DSP's tasks in a collaborative way.\n> These Tasks are:\n> 1. Managing Bitcoin deposits and withdrawals\n> 2. Managing the Lightning Network Channel(s)\n> 3. Managing communication with end users and the Lightning Network\n> \n> Deposit addresses for the DSP are multi-sig addresses, so that a\n> majority of a DSP's entities is required to sign withdrawals.\n> Also the Lightning Network channels are managed in this multi-sig\n> style   .....erm.....  yes i am aware that Lightning Network channels\n> are multig-sig anyway, what i wanted to say is: a update to the channel\n> reqiures now a majority of the DSP's entities to singn AND\n> the other side of that channel to sign. In case both sides of the\n> Lighting Network channel are DSPs the majority of both DSP's entities\n> need to sign.\n> \n> Due to this multi-sig construction a single entity of a DSP couldn't\n> steal the end users Bitcoins. It would actually reqire the majority of\n> entities of\n> one DSP to collaborate to steal the end users money.\n> \n> DSP's entities communicate with signed messages with their end users \n> and\n> with each other, so everything is provable. Whenever some entity of a \n> DSP\n> is acting malicious the other entities of that DSP can decide to \n> exclude\n> this entity from this DSP by transferring control of the managed\n> Bitcoins and\n> channels to some new multi-sig address(es)/channel(s) that doesn't\n> require the malicous acting entity's signature.\n> This could also be done if one entity isn't reliable available.\n> \n> Another advantage of DSP's would be that fewer channels are reqired,\n> since not every end user needs his own channel. Thus DSPs could save \n> even\n> more space on the Blockchain than Lightning alone.\n> \n> Thanks for your attention!\n> \n> Sam\n> \n> \n> \n> ------------------------------\n> \n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n> \n> End of Lightning-dev Digest, Vol 10, Issue 14\n> *********************************************"
            }
        ],
        "thread_summary": {
            "title": "Lightning-dev Digest, Vol 10, Issue 14",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "light at bitseed.org"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4038
        }
    },
    {
        "title": "[Lightning-dev] Payment and Refund Stuck",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2016-03-16T09:27:44",
                "message_text_only": "Hello lightning implementors!\n\n(Posted to lightning-dev as well, hopefully that's fine with everyone)\n\nMatsjj set up a repo a while ago for collaborating on documenting the\nlightning protocol and gave a bunch of us admin access:\n\n - https://github.com/lightning-core/lightning\n\n \"\"\"I think it is a very good idea to carry all the different\n    implementations to one spot. I think such a repository is best suited\n    for it.\"\"\"\n\n - https://github.com/lightning-core/lightning/pull/4#issuecomment-151778273\n\nI think the layout is a bit too nested (which makes sense coming from\nthe Java implementor, I guess? :) and I think it'd be good to have a\nsimple way to decide how to move ideas into/through the repo, without\nmaking it a place where there's any point trying to politicise proposals.\n(It's kind of telling that something's wrong when even matsjj hasn't\nbeen able to get his pull requests accepted :)\n\nAnyway I've taken Rusty's couple of BOLT proposals as well as the shachain\ndesign txt and rearranged them in a way I think makes sense:\n\n - https://github.com/ajtowns/lightning-core/tree/rusty\n\nWhat do you guys think?\n\nI hear there's totally going to be released code out by\nnorthern-hemisphere summer, so documenting the protocols/standards is\nonly going to get more pressing...\n\nMy inclination is to add:\n\n - matsjj's pull requests [0]\n - the anonymous \"R\", via private key reveal stuff [1]\n - Joseph's 2-of-3 Instant Escrow [2]\n\nas additional \"early drafts\". Probably things from Rusty's \"Deployable\nLightning\" paper (like the HTLC scripts), or the \"elkrem\" scheme, or\nNicholas Dorier's \"backward deterministic [revocation] Value\" stuff\nwould be good too...\n\nCheers,\naj\n\n[0] thunsync: https://github.com/lightning-core/lightning/pull/2/files\n    thunenc: https://github.com/lightning-core/lightning/pull/3/files\n    thungoss: https://github.com/lightning-core/lightning/pull/4\n\n[1] rprivkey:\n      http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000314.html\n      http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000344.html\n\n[2] escrow23: http://lists.linuxfoundation.org/pipermail/lightning-dev/2016-January/000403.html"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-17T04:51:08",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> Hello lightning implementors!\n>\n> (Posted to lightning-dev as well, hopefully that's fine with everyone)\n>\n> Matsjj set up a repo a while ago for collaborating on documenting the\n> lightning protocol and gave a bunch of us admin access:\n>\n>  - https://github.com/lightning-core/lightning\n>\n>  \"\"\"I think it is a very good idea to carry all the different\n>     implementations to one spot. I think such a repository is best suited\n>     for it.\"\"\"\n>\n>  - https://github.com/lightning-core/lightning/pull/4#issuecomment-151778273\n>\n> I think the layout is a bit too nested (which makes sense coming from\n> the Java implementor, I guess? :) and I think it'd be good to have a\n> simple way to decide how to move ideas into/through the repo, without\n> making it a place where there's any point trying to politicise proposals.\n> (It's kind of telling that something's wrong when even matsjj hasn't\n> been able to get his pull requests accepted :)\n>\n> Anyway I've taken Rusty's couple of BOLT proposals as well as the shachain\n> design txt and rearranged them in a way I think makes sense:\n>\n>  - https://github.com/ajtowns/lightning-core/tree/rusty\n>\n> What do you guys think?\n>\n> I hear there's totally going to be released code out by\n> northern-hemisphere summer, so documenting the protocols/standards is\n> only going to get more pressing...\n>\n> My inclination is to add:\n>\n>  - matsjj's pull requests [0]\n>  - the anonymous \"R\", via private key reveal stuff [1]\n>  - Joseph's 2-of-3 Instant Escrow [2]\n>\n> as additional \"early drafts\". Probably things from Rusty's \"Deployable\n> Lightning\" paper (like the HTLC scripts), or the \"elkrem\" scheme, or\n> Nicholas Dorier's \"backward deterministic [revocation] Value\" stuff\n> would be good too...\n\nFWIW, my rough plan was BOLT #3 was going to be the transaction formats,\nand BOLT #4 the onion and failure message formats (as portended in BOLT\n#2's references).\n\nCheers,\nRusty."
            },
            {
                "author": "Joseph Poon",
                "date": "2016-03-18T20:29:23",
                "message_text_only": "Hi Anthony,\n\nOn Wed, Mar 16, 2016 at 07:27:44PM +1000, Anthony Towns wrote:\n> What do you guys think?\n\nLooks interesting, thanks for writing this and documenting -- I think it\nwill be very helpful going forward. I think there's some differences\nwith how our code works right now, it'll be good aligning designs going\nforward. We will be putting up our specs in a couple weeks.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-03-21T12:34:37",
                "message_text_only": "> I think the layout is a bit too nested (which makes sense coming from\n> the Java implementor, I guess? :) and I think it'd be good to have a\n> simple way to decide how to move ideas into/through the repo, without\n> making it a place where there's any point trying to politicise proposals.\n> (It's kind of telling that something's wrong when even matsjj hasn't\n> been able to get his pull requests accepted :)\n\nHehe I was waiting for you guys to merge those, as I don\u2019t consider this \u2018my repository\u2019 but rather the specification of the protocol eventually.\nI do agree that the format isn\u2019t perfect yet. I still like these nested packages, because it separates the different parts of the application (and I don\u2019t see why plain numbers are any better than an actual structure? ;) ).\nWhen I started the repository, my goal was to\n(1) bring together all the different implementations\n(2) agree on a common denominator.\n\nWe have to finish (1) first before we actually can concentrate on (2) though.\n\nI suppose it makes sense to have the different parts of the application and have the different implementations side-by-side within that package. Then we can decide how we compose the \u2018final\u2019 specifications of that part.\n\nWhile we still work on the very 1.0 specifications, isn\u2019t it favourable to stick to named proposals, instead of throwing around with numbers? (even though I like the \u201cBOLT\u201d names\u2026)\n\nCheers\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160321/8ef66b64/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Payment and Refund Stuck",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "Mats Jerratsch",
                "Joseph Poon"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 6245
        }
    },
    {
        "title": "[Lightning-dev] Maintenance service for Lightning Network",
        "thread_messages": [
            {
                "author": "Kumaigorodskiy Anton",
                "date": "2016-03-25T21:21:20",
                "message_text_only": "Hi everyone,\nI think LN is a great idea and would like to add it to my Bitcoin wallet. I've been thinking for some time now about how LN could work for an end users (ideally dealing with it should be less frustrating than dealing with Bitcoin itself).\nAs far as I understand a payment sender needs to obtain at least three \"core\" pieces of data before he can start interacting with LN (plus maybe some metadata):\n1. Required hash of R-value.2. Required list of \"full node\" URL's where receiver currently has open channels.3. Required list of receiver ID's for each \"full node\" (so \"full node\" will know whom to ask for R-value).4. Optional but sometimes desirable metadata like name, picture, address etc.\nAnd further requirements:\n- \"Lightning address\" and QR-code approach won't work as R-value should be unique. Ideally no piece of \"core\" data should be easily accessible as text or QR to avoid confusion.\n- \"core\" data sould come directly from receiver's device, either via internet or locally wia bluetooth, WiFiP2P, NFC, etc.\n- Sender needs a way to verify that receiver is who he says he is which means resistance to MITM and identity theft plus some kind of \"name authority\" to validate metadata.\nTaking all the above into account it seems to me that:\n1. LN users should be able to generate stable identites on their devices. EC25519 keys seem a good fit to me because of their small size and applicability for both encryption and signing.\n2. There has to be a service parallel to LN that can transfer \"core\" data in encrypted form (easy because identities are pubKeys), perhaps store requests for some time if receiver's device is offline, optionally act as third-party watcher for broadcasted commitment transactions and, finally, act as \"name authority\" for users who supplied some metadata along with their public keys.\nDoes all this make any sense or am I way off somewhere for some reason?Please let me know. \t\t \t   \t\t  \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160325/fea4de90/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Maintenance service for Lightning Network",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Kumaigorodskiy Anton"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2119
        }
    },
    {
        "title": "[Lightning-dev] Breach tx vulnerability & CPFP attack",
        "thread_messages": [
            {
                "author": "J\u00e9r\u00f4me Legoupil",
                "date": "2016-03-28T09:19:42",
                "message_text_only": "Alice has a channel with Bob, lets say 50BTC on each side, and after some time, the channel ends up with 100BTC in Bob\u2019s favour (so Alice has 0BTC in that channel)\n\nAlice broadcasts the obsolete 50/50BTC commitment tx as well as her revocable tx : Multisig tx -> Alice 50BTC, OP_CSV.\n\nWhen Bob sees that, he broadcasts his breach tx, put it\u2019s not being picked up in blocks. Why ? Alice followed up by broadcasting (or privately sending to major pools) the tx : Alice 50BTC -> Alice 25BTC. She is offering miners to share Bob\u2019s 50BTC with her. \n\nAlice has nothing to lose behaving this way since she had nothing left in the channel anyways and miners have a strong financial incentive to wait and hope to include Alice\u2019s 25BTC offer instead of including Bob\u2019s worthless breach tx.\n\n\u2014\n\nTo defend against this attack Bob should do 1) and 2) :\n\n1) Bob should not allow any of his channels to drop below some certain amount, like 10% or something, in order to keep some garanty from Alice, so she won\u2019t have an incentive to behave maliciously. Unfortunately this reduces the channels efficiency but I think this example shows exhausted channels are insecure. \n\n2) Bob should monitor the blockchain permanently and as soon as he detects an obsolete commitment that is confirmed, he should immediately broadcast his breach tx and he should assume Alice is offering miners to collude with her. Therefore, he should engage ASAP in a scorched earth policy by broadcasting a replace-by-fee CPFP tx to himself, offering Alice\u2019s share to miners. He can increase the fee until it is picked up. He has an advantage over Alice during the contest period but his advantage diminishes as the contest period comes near the end. If he wins, Alice loses her 10%, but 10% may not be enough to outbid Alice and Bob may end up losing money. \n\n3) Bob has better chances to win at a lesser cost, the longer the contest period is. If the channel contains high values, the contest period could be chosen higher than usual at setup to make it more secure.\n\n\nI am not sure this defense is really convincing but that\u2019s the best I could come up with. Any thoughts ? \n\nJ\u00e9r\u00f4me"
            },
            {
                "author": "David A. Harding",
                "date": "2016-03-28T16:18:39",
                "message_text_only": "On Mon, Mar 28, 2016 at 11:19:42AM +0200, J\u00e9r\u00f4me Legoupil wrote:\n> miners have a strong financial incentive to wait and hope to\n> include Alice\u2019s 25BTC offer instead of including Bob\u2019s\n> worthless breach tx.\n\nI think you're treating miners here as a single actor when they should\nbe treated as multiple independent actors competing against each other.\nBob can have his breach transaction included in a block immediately but\nthe sequence lock on the 50 BTC Alice stole prevents her from spending\nit for perhaps hundreds of blocks (I believe the paper uses a value of\n1,500 blocks).\n\nThis means each miner on the network has a choice:\n\n1. Attempt to mine Bob's transaction immediately to claim its modest fee\n   before some other miner claims that fee.\n\n2. Hope no one else mines Bob's transaction for several hundred blocks\n   and then compete with all other miners to attempt to mine Alice's\n   high-fee transaction.\n\nIf the network is functioning correctly (e.g. no miner or mining cartel\nhas a majority of hash rate) then all miners should consider option #1\nto be the more profitable option for them on average.\n\n-Dave"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-03-28T23:47:24",
                "message_text_only": "J\u00e9r\u00f4me Legoupil <jjlegoupil at gmail.com> writes:\n> Alice has a channel with Bob, lets say 50BTC on each side, and after some time, the channel ends up with 100BTC in Bob\u2019s favour (so Alice has 0BTC in that channel)\n>\n> Alice broadcasts the obsolete 50/50BTC commitment tx as well as her revocable tx : Multisig tx -> Alice 50BTC, OP_CSV.\n>\n> When Bob sees that, he broadcasts his breach tx, put it\u2019s not being picked up in blocks. Why ? Alice followed up by broadcasting (or privately sending to major pools) the tx : Alice 50BTC -> Alice 25BTC. She is offering miners to share Bob\u2019s 50BTC with her. \n\nHi Jerome!\n\n        Nasty.  Fortunately, this attack doesn't work very well without\na mining cartel (though it's a very acute demonstration of why\ncensorship avoidance is important!).\n\n        For miner M, Alice's tx is worth 25BTC * P(M mines block) *\nP(nobody else mines Bob's tx).  If we assume everyone is locally\nprofit maximizing, that last term depends on how many small miners\nthere are (a 0.1% miner might see Alice's tx as worth 0.025 BTC, but\nthey're individually not likely to get a block in the 36-block CSV\nwindow).\n\nPeter Todd once said small miners are more important than big miners\n(maybe it was in person; I can't find it with a quick google).  This\nis why.\n\nCheers,\nRusty."
            },
            {
                "author": "Jannes Faber",
                "date": "2016-03-29T01:03:50",
                "message_text_only": "On 29 Mar 2016 2:15 a.m., \"Rusty Russell\" <rusty at rustcorp.com.au> wrote:\n\n> Peter Todd once said small miners are more important than big miners\n> (maybe it was in person; I can't find it with a quick google).  This\n> is why.\n\nPeter Todd:\n\n> So, why do we give miners transaction fees anyway? Well, they are\nproviding a service of \"mining a block\", but the *real* service they are\nproviding is the service of being independent from other miners, and we\nvalue that because we don't want >50%  of the hashing power to be\ncontrolled by any one entity.\n>\n> When you say these small miners are inefficient, you're completely\nignoring what we actually want miners to do, and that is to provide\n*independent* hashing power. The small miners are the most efficient at\nproviding this service, not the least.\n\nVery interesting and very relevant (even 3 years later) thread overall:\nhttps://bitcointalk.org/index.php?topic=144895.10\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160329/c362648b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Breach tx vulnerability & CPFP attack",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "Jannes Faber",
                "J\u00e9r\u00f4me Legoupil"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5666
        }
    },
    {
        "title": "[Lightning-dev] Segnet4",
        "thread_messages": [
            {
                "author": "Eric Lombrozo",
                "date": "2016-03-30T08:29:46",
                "message_text_only": "Hello everyone.\n\nI\u2019m pleased to announce segnet4, a new segwit testnet that features activation via BIP9 as well as support for BIP68, BIP112, and BIP113. In particular, it now supports Lightning Network app development and collaboration.\nI encourage everyone to spin up a node and try it out.\n\nFor source code, please go to sipa's github repo:\nhttps://github.com/sipa/bitcoin/tree/segwit4 <https://github.com/sipa/bitcoin/tree/segwit4>\n\nFeedback is welcome here or on the #segwit-dev channel on Freenode.\n\n\n- Eric\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160330/58e0e038/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Segnet4",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Eric Lombrozo"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 699
        }
    },
    {
        "title": "[Lightning-dev] Acknowledgements in BOLT #2",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-03-31T23:49:26",
                "message_text_only": "Hi all!\n\n        Pierre queried the placement of acknowlegements in BOLT #2; I\nshare his concerns, but wanted to document them here too.\n\n        The current draft (which I've implemented, and seems to work as\nof yesterday) has a header with an \"acknowledge\" field:\n\n(BOLT-encryption):\n* `acknowledge`: an 8-byte little-endian field indicating the number of non-`authenticate` messages received and processed so far.\n\nThis is used so we know what the other side has received when they send\nan \"update_commit\" message, and so we know where to restart the\nconversation after reconnect (\"authenticate\" message).\n\nThe current spec requires that acks never go backwards, meaning in\npractice an implementation needs to write to disk persistently before\n*every* new packet sent.\n\nIf we move the \"ack\" back into the update_commit/authenticatate messages\n(I had this originally), I think we can have the spec say that on\nreconnect you retransmit from previous received update_revocation.  And\nfee updates should Just Work too.  There's also an implied \"ack\" in the\nupdate_revocation message (which has to correspond to the\nupdate_commit).  One will need to be added to the \"authenticate\"\nmessage, too, which is used for connection re-establishment.\n\nIt's not a big code change: it's logically implemented as callbacks when\na packet is acked.  That just means they'll just fire all at once when\nwe receive a update_commit / update_revocation packet...\n\nI'll now try implementing that, and report back if I've missed anything\n:)\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Acknowledgements in BOLT #2",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1533
        }
    }
]