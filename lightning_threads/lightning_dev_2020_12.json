[
    {
        "title": "[Lightning-dev] Mitigating Channel Jamming with Stake Certificates",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-01T00:10:20",
                "message_text_only": "On Mon, Nov 30, 2020 at 7:34 PM Gleb Naumenko <naumenko.gs at gmail.com> wrote:\n\n> Hi Lloyd,\n>\n> > I agree with Z that this proposal is missing a strong argument as to why\n> this is a better \u201cproof-of-stake\u201d than channel balances themselves.\n>\n> I think Z\u2019s consideration is about the alternative Stake Certificates\n> proposed by t-bast, where every link in the route proves something to the\n> next hop.\n> For the context see this post, specifically \u201cpoint-to-point property\u201d:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-November/002888.html\n>\n\nThanks for the correction.\n\n\n>\n> I think you managed to apply the same argument to our original proposal as\n> well :)\n>\n> > In order to send a jamming HTLC you have to have to lock up funds to do\n> it (they need outgoing balance for the sender and incoming balance for the\n> receiver).\n>\n> I think the issue here is with loop attacks (\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html)?\n> This restriction with locking funds doesn\u2019t really work\u2026\n> After getting past their intermediate hop, an attacker can make arbitrary\n> loops and lock 100 BTC channels even by just having 1 BTC locked in the\n> initial hop.\n>\n> Stake Certificates allow for a node in the middle of the route to\n> distinguish where the payment is coming from (in a privacy-preserving\n> manner of course), to distinguish heavy channel users from normal.\n> They also allow to force an attacker to distribute jamming in time and\n> across many channels.\n>\n\nThat's a very interesting point. If we were to be able to prevent loop\nattacks by the sender proving the path is well formed (without revealing\nwho they are or any of the other hops) would this be an alternative\nsolution?\nIt seems to me that disabling loop attacks might be much easier than stake\ncertificates.\n\n\n> Perhaps, alternative restrictions may take place by restricting based on\n> from which immediate channel/node they are coming (one-hop). But that\n> sounds like a mess, as a payment sender doesn\u2019t have any control, and\n> gossiping that would probably be a privacy leak, also it still allows free\n> jamming I think (just a bit different).\n> The big deal here is to distinguish the flows, to better control them.\n> We can discuss this separately.\n>\n> It\u2019s true that any token might achieve the same goal here, but how to make\n> it Sybil-resistant and prevent generating new tokens? Stake Certificates, I\n> don\u2019t know what else we can commit to.\n>\n> > If we are talking about non-economic adversaries who simply wish to\n> destroy LN then that\u2019s another game altogether.\n>\n> I was thinking about this scenario all the way, but maybe I should think\n> about the other one as well.\n>\n>\nBut if we are talking about large holders of Bitcoin that just want to\ndestory LN this seems like a very weak mitigation since they will be able\nto produce stake certificates galore and lock up channels anyway.\nI don't see much of a way around this other than reputation systems.\n\nLL\n\n\n\n>\n> \u2013 gleb\n> On Nov 30, 2020, 6:39 AM +0200, Lloyd Fournier <lloyd.fourn at gmail.com>,\n> wrote:\n>\n> Hi Gleb et al,\n>\n> I really appreciate the out-of-the-box thinking of this proposal.\n> I will put to the side the very difficult task of creating a cryptosystem\n> that efficiently achieves what's necessary for this to work because that\n> seems not to be the main concern.\n>\n> I agree with Z that this proposal is missing a strong argument as to why\n> this is a better \"proof-of-stake\" than channel balances themselves.\n> In order to send a jamming HTLC you have to have to lock up funds to do it\n> (they need outgoing balance for the sender and incoming balance for the\n> receiver).\n> Why would stake certificates be more powerful than this? I get that you\n> decrement the UTXO's credit even if they fail. This increases the cost of\n> sending spam (but it also increases the cost of sending normal payments\n> since you now may be honest but have all your UTXOs run out of credit.)\n> Does this increased cost (it was not zero before) actually prevent the\n> attack without inhibiting normal usage?\n>\n> In general there seems to be an open question about whether these channel\n> jamming attacks are actually economic.\n> If I want to get more payments routed through me would it really be\n> optimal to do channel jamming?\n> Suppose that the nodes react to the jamming by adding extra capacity by\n> splicing out from somewhere else. Then I have jammed up my own coins and\n> got nothing for it.\n> What if instead of attacking I allocated the coins instead to creating\n> more valuable channels. Couldn't this be more profitable?\n> I just posed this question in [1].\n>\n> If we are talking about non-economic adversaries who simply wish to\n> destroy LN then that's another game altogether.\n> For example if the CCP with its 1% of all Bitcoin it seized from the\n> plustoken scam were to try and attack lightning they would likely succeed\n> even if we had this system in place simply because they have a lot of\n> \"stake\".\n> As David points out I don't think you can make a distinction between real\n> LN outputs and fake ones.\n> It seems unavoidable that any coins you own could be used to produce a\n> certificate to give you spam bandwidth (especially if you actually manage\n> to guarantee privacy through ZKPs).\n>\n> [1] https://github.com/t-bast/lightning-docs/issues/7\n>\n> Cheers,\n>\n> LL\n>\n>\n> On Sun, Nov 29, 2020 at 5:25 AM David A. Harding <dave at dtrt.org> wrote:\n>\n>> On Thu, Nov 26, 2020 at 11:40:46PM +0200, Gleb Naumenko wrote:\n>> >\n>> > Hello list,\n>>\n>> Gleb and Antoine,\n>>\n>> This is an interesting idea!  Thank you for working on it.\n>>\n>> I had difficulty with one part of the proposal:\n>>\n>> > #### Should we allow holding *any* Bitcoins (not just LN channels) for\n>> Stake Certificates?\n>> >\n>> > [...] we believe that allowing any UTXO would give an attacker more\n>> > opportunities to use their cold funds for this attack, or even have a\n>> > secondary market where holders sell their proofs (they have nothing to\n>> > loose).\n>>\n>> Can't a malicious user get around this restriction by opening channels\n>> with themself?  (Also, aren't current channel open outputs just P2WSH\n>> 2-of-2 multisigs, and in the future won't they be generic P2TR outputs?\n>> How would a stake certificate prove that the UTXO was generated for LN\n>> rather than just belonging to a user with a 2-of-2 multisig wallet or\n>> any key-path-spendable taproot wallet?)\n>>\n>> According to some random website, the current total channel balance of\n>> the public LN is about 1,000 BTC.  Although I'm sure this will grow with\n>> time, it seems to me that an attacker who can rent access to stake\n>> certificates for a one-week attack at, say, a 5% annual interest rate\n>> would only need to pay 1 BTC to acquire stake certificates equal to all\n>> honest users at present.  That cost doesn't seem high enough to me to\n>> effectively prevent attacks.  Am I missing something?\n>>\n>> Thanks,\n>>\n>> -Dave\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201201/84676029/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-01T12:11:14",
                "message_text_only": "Good morning LL, and list,\n\n\n> That's a very interesting point. If we were to be able to prevent loop attacks by the sender proving the path is well formed (without revealing who they are or any of the other hops) would this be an alternative solution?\n> It seems to me that disabling loop attacks might be much easier than stake certificates.\n\nLoop attacks are not about loops, it only requires that the start and end of a payment are controlled by the same entity.\n\nMultiple nodes on the LN may be owned by the same entity.\nNodes, individually as nodes, are trivially cheap and just need 32 bytes of entropy from a `/dev/random` near you.\nIt is the channels themselves, requiring actual funds, high uptime, and not being a dick to your counterparty, that are fairly expensive.\n\nThus, a \"loop attack\" need not involve a loop per se --- a single entity can run any number of nodes with small numbers of channels each, and thereby grief the network.\n\nStake certificates make the node itself expensive, so a single entity running a number of nodes cannot perform such loop attacks, since it would require entities expensively allocating funds for each node.\n\n\n\n\nOn the other hand, if channels are expensive, then a node with channels is expensive.\n\nIn https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-November/002890.html , which contains the \"Z consideration\" you were alluding to, I note that the \"point-to-point property\" is already proven by the ***existing*** Lightning network without an additional ZK cryptographic proof.\n\nSo let me invert that logic and present an even more extreme position:\n\n* There are two griefing attacks:\n  * Loop attacks, which are deliberate malicious attacks to lock up funds of competitors in order to redirect forwarding towards the attacker.\n  * Accidental \"attacks\", which are accidental due to incompetence, where a forwarding node accidentally goes offline and causes payments to be locked up for long periods and making everyone on the network cry when HTLCs time out and things have to be dropped onchain.\n* The point-to-point property, which is already proven by the ***existing*** Lightning network, is already sufficient to prevent loop attacks, leaving only accidental incompetence-based \"attacks\".\n  * Or: the ***existing*** Lightning Network ***already*** proves the point-to-point property presented by t-bast, and that property is ***already*** sufficient to prevent the loop attacks.\n\nSo, maybe we should instead focus on mitigating the effects of the incompetence-based non-attacks [such as this proposal](https://github.com/ElementsProject/lightning/issues/2632#issuecomment-736438980), instead of attempting to defend against the mirage of loop attacks.\n\n\nI could be utterly wrong here though.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-12-01T17:35:41",
                "message_text_only": "Hello Zeeman,\n\nIf I understand well the \"point-to-point property\" is the following : you\ncan authenticate  an incoming HTLC traffic from your neighbors owing to\ntheir expensive channels.\n\nMy concern with this approach relies on the fact that a routing node isn't\ndecisionary of the HTLC traffic going through itself. Thus its outgoing\ntraffic might be far superior to its locked channel utxos and it will have\nto compensate HTLC receiver for the difference. You're back to some fees\nmechanism for everyone to do its account.\n\nThe interesting property with stake certificates is to overlay the\nliquidity effective user with the HTLC sender. This last one should care\nabout using liquidity resources reasonably, not the routing nodes.\n\nIMO, the more interesting point you're underscoring is that we shouldn't\nbind a HTLC traffic volume to a channel size. E.g you have a small channel\nbut a high HTLC traffic spread through the day and that's lawful. What we\nmay consider is a stake certificate/point-to-point control only relying on\nutxo uniqueness, and not the amount locked. If a utxo-authenticated\nHTLC-traffic is far beyond the median, just blacklist the utxo, thus\nforcing a utxo spend (and bearing onchain fees) by any liquidity abuser.\n\nCheers,\n\nAntoine\n\nLe mar. 1 d\u00e9c. 2020 \u00e0 07:11, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning LL, and list,\n>\n>\n> > That's a very interesting point. If we were to be able to prevent loop\n> attacks by the sender proving the path is well formed (without revealing\n> who they are or any of the other hops) would this be an alternative\n> solution?\n> > It seems to me that disabling loop attacks might be much easier than\n> stake certificates.\n>\n> Loop attacks are not about loops, it only requires that the start and end\n> of a payment are controlled by the same entity.\n>\n> Multiple nodes on the LN may be owned by the same entity.\n> Nodes, individually as nodes, are trivially cheap and just need 32 bytes\n> of entropy from a `/dev/random` near you.\n> It is the channels themselves, requiring actual funds, high uptime, and\n> not being a dick to your counterparty, that are fairly expensive.\n>\n> Thus, a \"loop attack\" need not involve a loop per se --- a single entity\n> can run any number of nodes with small numbers of channels each, and\n> thereby grief the network.\n>\n> Stake certificates make the node itself expensive, so a single entity\n> running a number of nodes cannot perform such loop attacks, since it would\n> require entities expensively allocating funds for each node.\n>\n>\n>\n>\n> On the other hand, if channels are expensive, then a node with channels is\n> expensive.\n>\n> In\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-November/002890.html\n> , which contains the \"Z consideration\" you were alluding to, I note that\n> the \"point-to-point property\" is already proven by the ***existing***\n> Lightning network without an additional ZK cryptographic proof.\n>\n> So let me invert that logic and present an even more extreme position:\n>\n> * There are two griefing attacks:\n>   * Loop attacks, which are deliberate malicious attacks to lock up funds\n> of competitors in order to redirect forwarding towards the attacker.\n>   * Accidental \"attacks\", which are accidental due to incompetence, where\n> a forwarding node accidentally goes offline and causes payments to be\n> locked up for long periods and making everyone on the network cry when\n> HTLCs time out and things have to be dropped onchain.\n> * The point-to-point property, which is already proven by the\n> ***existing*** Lightning network, is already sufficient to prevent loop\n> attacks, leaving only accidental incompetence-based \"attacks\".\n>   * Or: the ***existing*** Lightning Network ***already*** proves the\n> point-to-point property presented by t-bast, and that property is\n> ***already*** sufficient to prevent the loop attacks.\n>\n> So, maybe we should instead focus on mitigating the effects of the\n> incompetence-based non-attacks [such as this proposal](\n> https://github.com/ElementsProject/lightning/issues/2632#issuecomment-736438980),\n> instead of attempting to defend against the mirage of loop attacks.\n>\n>\n> I could be utterly wrong here though.\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201201/e432323a/attachment-0001.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-02T05:02:17",
                "message_text_only": "> Loop attacks are not about loops, it only requires that the start and\nend of a payment are controlled by the same entity\n\nThanks for clearing that up. I was referring to cycles in the payment paths\nwhere you get honest parties to forward your HTLC between themselves over\nand over again as part of a single paryment. I have just realized that it's\neasy to prevent by just looking for duplicate payment hashes. This will be\na problem for randomized PTLCs though.\n\n> * There are two griefing attacks:\n>   * Loop attacks, which are deliberate malicious attacks to lock up funds\nof competitors in order to redirect forwarding towards the attacker.\n> * Accidental \"attacks\", which are accidental due to incompetence, where a\nforwarding node accidentally goes offline and causes payments to be locked\nup for long periods and making everyone on the network cry when HTLCs time\nout and things have to be dropped onchain\n\nAnother one recently pointed out in [1] is to jam a channels towards a\ncompeting merchant. Users who are trying to buy from the merchant will give\nup because of technical failure and instead come to your site where you\nwill sell successfully for a higher price.\nThis seems more plausible to me than completing for fees.\n\nBack to the general topic. Perhaps a way of refining the proposal is the\nfollowing:\n\n1. Drop idea of \"stake certificates\" in favor of a chaumian e-cash kind of\ndesign.\n2. The owner (owners?) of leach LN UTXO can go to any node in the network\nand request a kind of token for their UTXO (i.e. channel id).\n3. When making a payment you present a randomized version of the token to\neach node (it is not linkable to the UTXO) and prove that the UTXO it\nrepresents is large enough to support the payment (the token and proof\nprotocol can hopefully be non-interactive so it can fit in the onion).\n4. If your HTLC fails your token is deleted (and have to wait some period\nbefore requesting a new one).\n5. If your payment succeeds your token is renewed on the spot (and maybe\nforwarded back along the path covertly).\n\nNot saying this will be easy (or even totally coherent) but I feel the\ndirection is a bit more plausible.\nThe benefit here is that you avoid the complicated ZKPs about UTXOs and are\ntreading on a more well worn path of anonymous credentials and ecash.\n\n[1]:\nhttps://github.com/t-bast/lightning-docs/issues/7#issuecomment-736713076\n\nLL\n\nOn Tue, Dec 1, 2020 at 11:11 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning LL, and list,\n>\n>\n> > That's a very interesting point. If we were to be able to prevent loop\n> attacks by the sender proving the path is well formed (without revealing\n> who they are or any of the other hops) would this be an alternative\n> solution?\n> > It seems to me that disabling loop attacks might be much easier than\n> stake certificates.\n>\n> Loop attacks are not about loops, it only requires that the start and end\n> of a payment are controlled by the same entity.\n>\n> Multiple nodes on the LN may be owned by the same entity.\n> Nodes, individually as nodes, are trivially cheap and just need 32 bytes\n> of entropy from a `/dev/random` near you.\n> It is the channels themselves, requiring actual funds, high uptime, and\n> not being a dick to your counterparty, that are fairly expensive.\n>\n> Thus, a \"loop attack\" need not involve a loop per se --- a single entity\n> can run any number of nodes with small numbers of channels each, and\n> thereby grief the network.\n>\n> Stake certificates make the node itself expensive, so a single entity\n> running a number of nodes cannot perform such loop attacks, since it would\n> require entities expensively allocating funds for each node.\n>\n>\n>\n>\n> On the other hand, if channels are expensive, then a node with channels is\n> expensive.\n>\n> In\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-November/002890.html\n> , which contains the \"Z consideration\" you were alluding to, I note that\n> the \"point-to-point property\" is already proven by the ***existing***\n> Lightning network without an additional ZK cryptographic proof.\n>\n> So let me invert that logic and present an even more extreme position:\n>\n> * There are two griefing attacks:\n>   * Loop attacks, which are deliberate malicious attacks to lock up funds\n> of competitors in order to redirect forwarding towards the attacker.\n>   * Accidental \"attacks\", which are accidental due to incompetence, where\n> a forwarding node accidentally goes offline and causes payments to be\n> locked up for long periods and making everyone on the network cry when\n> HTLCs time out and things have to be dropped onchain.\n> * The point-to-point property, which is already proven by the\n> ***existing*** Lightning network, is already sufficient to prevent loop\n> attacks, leaving only accidental incompetence-based \"attacks\".\n>   * Or: the ***existing*** Lightning Network ***already*** proves the\n> point-to-point property presented by t-bast, and that property is\n> ***already*** sufficient to prevent the loop attacks.\n>\n> So, maybe we should instead focus on mitigating the effects of the\n> incompetence-based non-attacks [such as this proposal](\n> https://github.com/ElementsProject/lightning/issues/2632#issuecomment-736438980),\n> instead of attempting to defend against the mirage of loop attacks.\n>\n>\n> I could be utterly wrong here though.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201202/c3d28486/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-02T06:16:15",
                "message_text_only": "Good morning LL,\n\n> Back to the general topic. Perhaps a way of refining the proposal is the following:\n>\n> 1. Drop idea of \"stake certificates\" in favor of a chaumian e-cash kind of design.\n> 2. The owner (owners?) of leach LN UTXO can go to any node in the network and request a kind of token for their UTXO (i.e. channel id).\n\nNot all forwarding nodes have a directly-contactable address published, and many publish only an .onion address; many payers do not bother to run Tor and cannot directly contact .onion addresses.\n\nOn the other hand, it would be possible to use an onion routing (without an attached HTLC) to remotely contact such forwarding nodes, and presumably other nodes will be willing to provide this almost for free since they would not need to lock up funds.\n\n\n> 3. When making a payment you present a randomized version of the token to each node (it is not linkable to the UTXO) and prove that the UTXO it represents is large enough to support the payment (the token and proof protocol can hopefully be non-interactive so it can fit in the onion).\n> 4. If your HTLC fails your token is deleted (and have to wait some period before requesting a new one).\n> 5. If your payment succeeds your token is renewed on the spot (and maybe forwarded back along the path covertly).\n\nI think it should not be success or failure that matters.\nI can still mount the same attack by forwarding a payment to another node I control, with the last hop having a large timeout, waiting out the entire timeout, and then *succeeding* the payment just before the payment times out.\nThe funds are still locked for nearly the entire timeout period, during which my competitors (whether as merchant or as forwarder node --- forwarder nodes are really just merchants of liquidity) are unable to use the liquidity during this timeout period.\nI end up paying fees, but the fees on Lightning are ridiculously tiny and may very well remain so for a good amount of time.\n\nInstead, a particular UTXO size provides so many msat-seconds of lockup credit.\nAs a forwarding node, if I have issued a credential for a UTXO of particular size, offering so many msat-seconds of lockup, if I receive the unblinded credential, after I send out the outgoing HTLC, I measure its size and how long before it gets resolved (in either success or failure), multiply those together, and debit that particular credential.\n(it might be plausible for failure for me to add a little more extra surcharge to the msat-seconds credit of that credential, but nevertheless --- I must still treat a *slow* success as something as bad, or almost as bad, as a *slow* failure)\nIf that credential later reappears on an incoming HTLC and it has been debited to 0 or negative, I just fail it without risking sending out my funds in an outgoing HTLC.\nThis prevents the above trivial variation of the loop attack.\n\nHowever, this exacerbates the effects of accidental incompetence-based failures of other forwarding nodes.\n\nOtherwise I largely agree that anonymous credentials seems a better way to build stake certificates.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Mitigating Channel Jamming with Stake Certificates",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Antoine Riard",
                "Lloyd Fournier"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 23434
        }
    },
    {
        "title": "[Lightning-dev] Lightning Distributed Routing",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-01T11:29:48",
                "message_text_only": "Good morning Joao and Bastien,\n\nI believe the `feeadjuster` plugin for C-Lightning, created by Darosior, already does what you want to do, without a specs change.\n\n* We already know that nodes prefer low-fee routes over high-fee routes.\n* `feeadjuster` adjusts our channel feerate according to balance:\n  * It makes fees low if we own most of the funds in the channel.\n  * It makes fees high if we own almost none of the funds in the channel.\n* Thus, `feeadjuster` signals \"use this channel!\" if it has high capacity in that direction, and signals \"do not use this channel!\" if it has low capacity in that direction.\n\nI believe this is sufficient to achieve your goal, without requiring substantial changes to existing algorithms and implementations.\n\n(CLBOSS, also a C-Lightning plugin, implements similar logic as one of the many things it does, with some differing details but with substantially the same fee-adjustment curve)\n\nI believe concerns on false signaling are unfounded, at least with the limited channel fee signalling that `feeadjuster`/CLBOSS use.\nI can signal a low feerate, but if I do not have sufficient capacity anyway when the inevitable flood of payments wanting to take advantage of the lower fees arrives, then I gain no advantage anyway.\nRather, some amount of honesty would be better for me.\n\nRegards,\nZmnSCPxj\n\n\n\n> Hello Bastien!\n>\n> Firstly I'd like to thank you for the time you took to read the paper, it's been hard to get some quality reviews.\n> Your feedback made me think and reach the following conclusions:\n> Let's assume node A is sending information to its peer, node B, with the goal of attracting more business (increasing the number of payments that are routed through it). In LDR this would mean A would want to announce to B that it belongs to larger volume routes than the ones it actually does.\n> Let's say A and B shared channel state is (A: 1, B: 4).\n> A shares a channel with C, state (A: 2, C: 3).\n> B also shares a channel with C, state (B: 3, C: 6).\n> A could dishonestly share with B knowing a path to C with capacity 4 BTC although it only has 2 currently available. By doing this A would effectively change B's routing preferences for payments to C, making B's routing table go from:\n>\n> Destination | Next Hop | Capacity\n> \u00a0 \u00a0 \u00a0 \u00a0C\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 A\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a02\n> \u00a0 \u00a0 \u00a0 \u00a0C\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 C\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a03\n>\n> ...to:\n>\n> Destination | Next Hop | Capacity\n> \u00a0 \u00a0 \u00a0 \u00a0C\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 A\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a04\n> \u00a0 \u00a0 \u00a0 \u00a0C\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 C\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a03\n>\n> Meaning B now thinks payments to C with volume in the [3, 4] BTC range can only be routed through A and payments to C in the [0, 3] BTC range can be routed to A or directly to C. What does this information change and how does it affect honest nodes?\n> Larger\u00a0[3, 4] BTC payments are not within the capacity provided by the path that goes directly to C and would immediately fail when the payment is made in the LN layer using the path that goes through A. This breaks the incentive to, at least for payments in this volume range, share the invalid information. The cheating nodes would not be putting honest nodes out of business nor increasing the number of payments that go through them.\n> The problem starts when the cheating node fakes directly competing for routes within the capacity range provided by honest nodes and not by them ([2, 3] BTC range for the example). Although this could not be used to collect more fees because payments would eventually fail in the LN layer and the fees wouldn't be able to be collected, it could certainly be used to \"put honest nodes out of work\", stealing routing paths that would otherwise belong to them.\n> I think the solution lies in the way in which a node chooses the next best hop for a certain destination. I started by proposing the following (section 3.1.2):\n>\n> >The \u201dbest next hop\u201d for a certain payment destination is defined as being the hop with the lowest fee from the group of next hops for that destination where\u00a0the maximum volume allowed is bigger than the payment\u2019s volume.\n>\n> I propose changing it to:\n>\n> >The \u201dbest next hop\u201d for a certain payment destination is defined as being a random hop taken from the group of next hops for that destination where\u00a0the maximum volume allowed is higher than the payment\u2019s volume.\n>\n> Which would diminish the incentive attacking nodes have to share fake gossip by not allowing them to set themselves as first in line to be chosen as next hop. A maximum fee that a node is willing to pay would also need to be set,\n> Also, keep in mind that the capacity the maximum path capacity can lie about is limited by the capacity of his biggest channel, available in the blockchain.\u00a0\n>\n> PS: I adapted Figure 5 from your trampoline routing presentation, hope that's ok!\n>\n> Kind regards,\n> Jo\u00e3o Valente\n>\n> On Mon, 30 Nov 2020 at 08:36, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n>\n> > Hi Joao,\n> >\n> > Thanks for the time you spent on this, the paper is clear on the trade-offs (sacrificing some privacy for\n> > efficiency).\n> >\n> > My main negative feedback here is that you seem to assume that nodes will honestly cooperate.\n> > It feels to me that nodes can cheat and gossip biased or invalid information to their peers in order to\n> > attract more payments through their nodes (and collect more fees or put honest routing nodes out of\n> > business).\n> >\n> > Is that something you've thought about?\n> >\n> > Cheers,\n> > Bastien\n> >\n> > Le\u00a0dim. 29 nov. 2020 \u00e0\u00a000:46, Jo\u00e3o Valente <jvalente96 at gmail.com> a \u00e9crit\u00a0:\n> >\n> > > Hey!\n> > >\n> > > I've\u00a0been working on this new concept for routing in the lightning network. It leverages the use of the information nodes have on the distribution of funds in their channels to try and maximize the probability of success for a payment.\n> > > Each node shares with his neighbours the information it has about the distribution of funds in its own neighbourhood through the form of a routing table. As nodes receive new tables they'll be updating their own locally maintained\u00a0tables with the new information, periodically sharing them with their neighbours.\n> > > Routing tables associate destination addresses (representing nodes in the network) to the next hop in the maximum capacity path to these nodes.\n> > > If a new payment\u00a0is to be made a payment\u00a0probe is forwarded by the payer and through every node in the path, collects the path information along the way, and reaches the payee who returns it to the payer. The payer can then use this knowledge and\u00a0confidently use the discovered path to route LN payments\u00a0through.\n> > >\n> > > I wrote a 10 page paper about the subject\u00a0and would love to get some feedback:\n> > > https://drive.google.com/file/d/1dahW0X-N59138ZbY-4odpXjpDnX4Gb7Z/view?usp=sharing\n> > >\n> > > Cheers,\n> > > Jo\u00e3o Valente\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Jo\u00e3o Valente",
                "date": "2020-12-01T16:12:38",
                "message_text_only": "Hello ZmnSCPxj,\n\nThank you for taking the time to read the paper and sending over some\nfeedback, can't stress enough how important that is.\nI took a look at the `feeadjuster` plugin for C-Lightning and although it\ngoes in the same direction as LDR in the sense that it allows for better\nroutes by signalling channel balance availability. It does it through a\ndynamic fee adjustment though, where LDR is more explicit and goes one step\nfurther, directly sharing channel balance information. I'm not sure how\nthese two solutions would compare in practice though but I imagine that\nsharing more information would give LDR a performance edge.\nOh, and there's no need for a spec change. It could work as a separated LN\noverlay network.\n\nCompletely agree on the false signalling idea, a node would not gain any\nmore routing traffic by signalling a better fee or, in LDR's case, bigger\ncapacity routes.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201201/ca816693/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-01T16:33:59",
                "message_text_only": "Good morning Joao,\n\n> Hello\u00a0ZmnSCPxj,\n>\n> Thank you for taking the time to read the paper and sending over some feedback, can't stress enough how important that is.\n> I took a look at the `feeadjuster` plugin for C-Lightning and although it goes in the same direction as LDR in the sense that it allows for better routes by signalling channel balance availability. It does it through a dynamic fee adjustment though, where LDR is more explicit and goes one step further, directly sharing channel balance information. I'm not sure how these two solutions would compare in practice though but I imagine that sharing more information would give LDR a performance edge.\n> Oh, and there's no need for a spec change. It could work as a separated LN overlay network.\n\nI believe it would --- either you write the code for this overlay network for all extant node software (though I suppose targeting lnd will get you 90% of the network anyway...), or you standardize so all implementations are going to target implementing the overlay network.\n\nOn the other hand, using fees as the signaling just reuses an existing signaling layer, and affects payers in the expected ways --- all existing implementations already try to minimize fees, so signaling a low fee when you have high capacity on a channel already does the \"right thing\" on the network today.\n\nIn short, by using fees as a signaling layer you can get something like this partly working for most payers today even if only a small number of nodes run `feeadjuster` or CLBOSS, whereas with LDR you need most payers to upgrade to using the new overlay network in order to get similar benefit, I think, in which case you should really push to standardize it in the specs.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jo\u00e3o Valente",
                "date": "2020-12-01T17:20:59",
                "message_text_only": "Hello ZmnSCPxj!\n\nYou are completely right in saying that LDR presents a bigger barrier in\nthe sense that It needs to be running on literally every node in a payment\npath for it to work whereas 'feeadjuster' can help the sender even if only\none node in the payment path is running it. That is definitely a big LDR\ndisadvantage.\nAbout the specs... My approach was thinking about LDR as an independent\nprotocol with an independent protocol specification which would be\nimplemented by software that run alongside a spec-compliant lightning node,\nwhich is why I was saying that there is no need for a lightning-spec change.\nI started trying to define this new specification it on an extended version\nof the paper, it's available here:\nhttps://drive.google.com/file/d/1tSd5jKny_jLL6M1OuRkIc3NLaNFMBdJ_/view?usp=sharing\nAlso started (early beginnings!) to write the LDR-spec compliant software,\ntargeting lnd and bitcoind: https://github.com/jsmvalente/ldRouting\n\nKind regards,\nJo\u00e3o Valente\n\nOn Tue, 1 Dec 2020 at 16:34, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Joao,\n>\n> > Hello ZmnSCPxj,\n> >\n> > Thank you for taking the time to read the paper and sending over some\n> feedback, can't stress enough how important that is.\n> > I took a look at the `feeadjuster` plugin for C-Lightning and although\n> it goes in the same direction as LDR in the sense that it allows for better\n> routes by signalling channel balance availability. It does it through a\n> dynamic fee adjustment though, where LDR is more explicit and goes one step\n> further, directly sharing channel balance information. I'm not sure how\n> these two solutions would compare in practice though but I imagine that\n> sharing more information would give LDR a performance edge.\n> > Oh, and there's no need for a spec change. It could work as a separated\n> LN overlay network.\n>\n> I believe it would --- either you write the code for this overlay network\n> for all extant node software (though I suppose targeting lnd will get you\n> 90% of the network anyway...), or you standardize so all implementations\n> are going to target implementing the overlay network.\n>\n> On the other hand, using fees as the signaling just reuses an existing\n> signaling layer, and affects payers in the expected ways --- all existing\n> implementations already try to minimize fees, so signaling a low fee when\n> you have high capacity on a channel already does the \"right thing\" on the\n> network today.\n>\n> In short, by using fees as a signaling layer you can get something like\n> this partly working for most payers today even if only a small number of\n> nodes run `feeadjuster` or CLBOSS, whereas with LDR you need most payers to\n> upgrade to using the new overlay network in order to get similar benefit, I\n> think, in which case you should really push to standardize it in the specs.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201201/9806b83b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning Distributed Routing",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Jo\u00e3o Valente"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 12877
        }
    },
    {
        "title": "[Lightning-dev] Recovery of Lightning channels without backups",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-07T00:32:27",
                "message_text_only": "Hi list,\n\nI've been considering the problem of recovering lightning channels after\nlosing channel state in a boating accident. The modern way of doing this\nseems to be \"static channel backups\" -- these are essentially lists of\nchannel ids and the nodes you had the channels with.\n\nThe idea is that with this backup you can remember who you had channels\nwith, connect to them and ask them to force close the channel (can someone\nlink me the concrete protocol messages you send to do this?).\n\nIt occurred to me that if the lightning protocol were changed slightly you\ncould do this without the channel backup at all. Consider the open channel\nmessage and its two fields `funding_pubkey` and `temporary_channel_id`.\n\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#the-open_channel-message\n\nThe reason `temporary_channel_id` is necessarily \"temporary\" is because we\ndon't know the other party's `funding_pubkey`. Instead I propose using\ndeterministically randomized version of the node's static public key as the\n`funding_pubkey` so we know it up front. Specifically, when opening a\nchannel with a remote node, do a Diffie-Hellman operation with their public\nkey and use the resulting shared secret to deterministically produce\nscalars r1 and r2 and use 2-of-2(r1*G + P_local, r2*P_remote) as the script\npubkey of funding output. Now we know what the funding output would look\nlike with any node without interacting with them. Of course, to open\nmultiple channels with the same node we would have to generate a new shared\nsecret from each one by hashing a counter.\n\nNow that we can figure out what our funding outputs with each node look\nlike non-interactively, when we lose our channel state we can find them in\nthe UTXO set as long as we can recreate a list of node's we may have had\nchannels with. For most non-enterprise users (such as myself) this can be\ndone automatically because we exclusively have channels with well known\nreliable public nodes whose public keys can be discovered through routing\ngossip or from public indexes. Therefore if I can just restore my node's\nkeypair from my seed I should be able to scan the network for nodes and\nfigure out if I have channels open with them and then carry out the\nrecovery process. From my perspective this seems to be a rather nice\nimprovement in user experience.\n\nThoughts?\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201207/5d78d233/attachment.html>"
            },
            {
                "author": "Gijs van Dam",
                "date": "2020-12-07T08:24:20",
                "message_text_only": "Hey Lloyd (and others),\n\nI have just been working on something similar. I came up with the following\nplan of attack that works within the current protocol:\n\nCreate a static channel backup after the fact. I have dubbed this a\nsynthetic static channel backup. I only use it to trigger the data loss\nprotection protocol.\nBy restoring this synthetic SCB a `channel_reestablish` is being sent to\nthe remote peer. This `channel_reestablish`contains the\n`next_commitment_number`and the `next_revocation_number` both set to zero.\nThis triggers the remote peer to force close the channel dropping its\ncurrent commitment transaction to the chain. Using the\n`per_commitment_point` received from the remote peer you can now derive the\nprivate key needed for sweeping your funds, using\nprivkey = basepoint_secret + SHA256(per_commitment_point || basepoint)\n\nWe use the basepoint_secret derived (in LND) with\n\n```\nbasePointSecret, err := keyRing.DerivePrivKey(keychain.KeyDescriptor{\n  KeyLocator: keychain.KeyLocator{\n    Family: keychain.KeyFamilyPaymentBase,\n    Index:  0, // Same commitment index as used by the remote node\n  },\n})\n```\n\nI have  got this somewhat working in a test setup. (I probably have\noverlooked some details). I would be interested in hearing Sjors Provoost\non this, since his question and answer on this topic over on the Bitcoin\nStackExchange was really helpful.[1]\nHe lost his backup in a boating accident as well. (What is it with you guys\nand boating? :) )\n\nYour approach covers more cases, and my approach only fits certain edge\ncases. But my approach is possible today, without changes to the Lightning\nprotocol.\n\nRegards,\n\nGijs\n\n[1]:\nhttps://bitcoin.stackexchange.com/questions/90196/how-to-recover-funds-from-a-force-closed-lnd-lightning-channel/90719#90719\n\nOn Mon, Dec 7, 2020 at 8:32 AM Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n\n> Hi list,\n>\n> I've been considering the problem of recovering lightning channels after\n> losing channel state in a boating accident. The modern way of doing this\n> seems to be \"static channel backups\" -- these are essentially lists of\n> channel ids and the nodes you had the channels with.\n>\n> The idea is that with this backup you can remember who you had channels\n> with, connect to them and ask them to force close the channel (can someone\n> link me the concrete protocol messages you send to do this?).\n>\n> It occurred to me that if the lightning protocol were changed slightly you\n> could do this without the channel backup at all. Consider the open channel\n> message and its two fields `funding_pubkey` and `temporary_channel_id`.\n>\n>\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#the-open_channel-message\n>\n> The reason `temporary_channel_id` is necessarily \"temporary\" is because we\n> don't know the other party's `funding_pubkey`. Instead I propose using\n> deterministically randomized version of the node's static public key as the\n> `funding_pubkey` so we know it up front. Specifically, when opening a\n> channel with a remote node, do a Diffie-Hellman operation with their public\n> key and use the resulting shared secret to deterministically produce\n> scalars r1 and r2 and use 2-of-2(r1*G + P_local, r2*P_remote) as the script\n> pubkey of funding output. Now we know what the funding output would look\n> like with any node without interacting with them. Of course, to open\n> multiple channels with the same node we would have to generate a new shared\n> secret from each one by hashing a counter.\n>\n> Now that we can figure out what our funding outputs with each node look\n> like non-interactively, when we lose our channel state we can find them in\n> the UTXO set as long as we can recreate a list of node's we may have had\n> channels with. For most non-enterprise users (such as myself) this can be\n> done automatically because we exclusively have channels with well known\n> reliable public nodes whose public keys can be discovered through routing\n> gossip or from public indexes. Therefore if I can just restore my node's\n> keypair from my seed I should be able to scan the network for nodes and\n> figure out if I have channels open with them and then carry out the\n> recovery process. From my perspective this seems to be a rather nice\n> improvement in user experience.\n>\n> Thoughts?\n>\n> Cheers,\n>\n> LL\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201207/d4af1742/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-09T02:44:51",
                "message_text_only": "> Create a static channel backup after the fact. I have dubbed this a\n> synthetic static channel backup. I only use it to trigger the data loss\n> protection protocol.\n> By restoring this synthetic SCB a `channel_reestablish` is being sent to\n> the remote peer. This `channel_reestablish`contains the\n> `next_commitment_number`and the `next_revocation_number` both set to zero.\n> This triggers the remote peer to force close the channel dropping its\n> current commitment transaction to the chain. Using the\n> `per_commitment_point` received from the remote peer you can now derive the\n> private key needed for sweeping your funds, using\n> privkey = basepoint_secret + SHA256(per_commitment_point || basepoint)\n>\n\nThanks Gijs for describing how this works I wasn't quite sure.\n\nThe thing I dream of is being able to securely restore my layer 1 and 2\nfunds with just my seed.\nThere was discussion of this idea in last lightning dev meeting:\nhttps://github.com/lightningnetwork/lightning-rfc/issues/821#issuecomment-740161185\nA few of the concerns were:\n\n1. You have to remember the counter\n\nThe intention here is to not have to remember any counter. Just as in BIP32\nyou just scan with some allowance for gaps.\nroasbeef correctly points out that this may be more or less difficult\ndepending on your node setup and whether you can ballpark how long ago your\nfunding transactions were put down.\nHowever since you are using this when you have lost your channel states\nwith no static channel backups I think it still provides a very realistic\nchance of recovering a significant chunk of your funds.\n\nAnother point ariard made is that you only have to find one of the channels\nwith a peer to find all of them with a peer if there was some kind of \"list\nchannels\" message request.\n\n2. It only works for public nodes who can be discovered\n\nCorrect. For my use of LN so far I am always connecting to public nodes so\nit would likely work well for me.\nI think this is true for most unsophisticated users who are most likely to\nlose their channels with no backups.\n\nIf each peer allowed you to store some encrypted data with them then\nfinding one honest public peer through the chain could potentially let you\nfind all other peers (even the private ones).\n\n3. We might not want to encourage doing channel recovery by asking the node\nto force close channel\n\nI agree. \"PLEASE BLACKMAIL ME\" is not a bad characterization of the channel\nbackup interaction Gijs describes above.\nI believe there is a lot of room for improvement here. First you have to\nfind the channels though!\n\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201209/22894c20/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2020-12-09T03:52:11",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> Hi list,\n>\n> I've been considering the problem of recovering lightning channels after\n> losing channel state in a boating accident. The modern way of doing this\n> seems to be \"static channel backups\" -- these are essentially lists of\n> channel ids and the nodes you had the channels with.\n>\n> The idea is that with this backup you can remember who you had channels\n> with, connect to them and ask them to force close the channel (can someone\n> link me the concrete protocol messages you send to do this?).\n\nIt's in BOLT #2:\n\n1. type: 136 (`channel_reestablish`)\n2. data:\n   * [`channel_id`:`channel_id`]\n   * [`u64`:`next_commitment_number`]\n   * [`u64`:`next_revocation_number`]\n   * [`32*byte`:`your_last_per_commitment_secret`]\n   * [`point`:`my_current_per_commitment_point`]\n\nThe `your_last_per_commitment_secret` lets Bob prove to Alice that he's\nfrom The Future, and prior to `option_static_remotekey`\nmy_current_per_commitment_point allowed Alice to derive the script used\nfor her output.\n\n> It occurred to me that if the lightning protocol were changed slightly you\n> could do this without the channel backup at all. Consider the open channel\n> message and its two fields `funding_pubkey` and `temporary_channel_id`.\n\nHmm, we had a proposal (for DF) to get rid of the temporary_channel_id\nby using 'SHA256(lesser-revocation-basepoint ||\ngreater-revocation-basepoint)' as the channel_id, which is known\nfrom the start.  I don't see it in the DF spec PR, but it's in\nc-lightning.\n\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#the-open_channel-message\n>\n> The reason `temporary_channel_id` is necessarily \"temporary\" is because we\n> don't know the other party's `funding_pubkey`. Instead I propose using\n> deterministically randomized version of the node's static public key as the\n> `funding_pubkey` so we know it up front. Specifically, when opening a\n> channel with a remote node, do a Diffie-Hellman operation with their public\n> key and use the resulting shared secret to deterministically produce\n> scalars r1 and r2 and use 2-of-2(r1*G + P_local, r2*P_remote) as the script\n> pubkey of funding output. Now we know what the funding output would look\n> like with any node without interacting with them. Of course, to open\n> multiple channels with the same node we would have to generate a new shared\n> secret from each one by hashing a counter.\n\nSay r1=SHA256(ss || counter || 0), r2 = SHA256(ss || counter || 1)?\n\nNice work.  This would be a definite recovery win.  We should add this\nto the DF spec, because Lisa was almost finished implmenting it, so it's\nclearly due for a change!\n\n> Now that we can figure out what our funding outputs with each node look\n> like non-interactively, when we lose our channel state we can find them in\n> the UTXO set as long as we can recreate a list of node's we may have had\n> channels with. For most non-enterprise users (such as myself) this can be\n> done automatically because we exclusively have channels with well known\n> reliable public nodes whose public keys can be discovered through routing\n> gossip or from public indexes. Therefore if I can just restore my node's\n> keypair from my seed I should be able to scan the network for nodes and\n> figure out if I have channels open with them and then carry out the\n> recovery process. From my perspective this seems to be a rather nice\n> improvement in user experience.\n\nNote that in practice you can have nodes reconnecting to you.\n\nWe've long thought about peers supplying some storage for each other, so\nyou can spray out (encrypted) backups that way.  It's actually a fairly\ntrivial addition; your scheme makes for much less data to store.\n\nCheers!\nRusty."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-10T05:23:27",
                "message_text_only": "On Wed, Dec 9, 2020 at 4:26 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n>\n> Say r1=SHA256(ss || counter || 0), r2 = SHA256(ss || counter || 1)?\n>\n> Nice work.  This would be a definite recovery win.  We should add this\n> to the DF spec, because Lisa was almost finished implmenting it, so it's\n> clearly due for a change!\n>\n\nYes that's certainly a fine way to do it.\nI was also thinking you could eliminate all \"basepoints\" (not just funding\npubkey) using something like this. i.e. just use the node pubkey as the\n\"basepoint\" for everything and randomize it using the shared secret for\neach purpose.\n\nNote that in practice you can have nodes reconnecting to you.\n>\n\nHmm, this is a good point.\nI was incorrectly assuming the best way to implement \"recovery mode\" would\nbe to never accept incoming connections.\n\nWe've long thought about peers supplying some storage for each other, so\n> you can spray out (encrypted) backups that way.  It's actually a fairly\n> trivial addition; your scheme makes for much less data to store.\n>\n\nI've also been thinking about the best way to go about this.\nIf you're able to encrypt some backups to different places then all you\nhave to do is find one of your honest channel partners using this method\nand then get encrypted hints to find them all.\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201210/28068208/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Recovery of Lightning channels without backups",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Gijs van Dam",
                "Rusty Russell",
                "Lloyd Fournier"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 15243
        }
    },
    {
        "title": "[Lightning-dev] Covert channel recovery with Oblivious Signatures",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-11T02:02:04",
                "message_text_only": "Hi list,\n\nCurrently, if your lightning node has data loss there are two ways of\nrecovering your funds once you have established which channels you had with\nwhich peers:\n\n1. Wait until your peer closes the channel. The downside is that you have\nno control over when this happens.\n2. Connect to your peer and ask them to close it. The downside is that to a\nmalicious actor this request reads like \"now is a good time to steal my\nmoney or extort me\".\n\nWhat if instead we could somehow covertly get a signed cooperative\nsettlement transaction for the most recent state without your peer knowing\nthat you've received it?\nLuckily this mystical and almost incoherent requirement is provided by one\nof the oldest and well developed cryptographic primitives: the so called\n\"Oblivious Transfer\" (OT).\n\nhttps://en.wikipedia.org/wiki/Oblivious_transfer\n\nThe idea might go something like this: every time you connect to your peer\nthey present you with an unsigned cooperative settlement transaction for\nall channels you have with them. You and your peer then do an oblivious\ntransfer where they send you their signatures on the transaction or nothing\n(whichever you choose). If you want to carry on with the channel you reveal\nto the sender that you chose nothing. If you are recovering funds you\nchoose the signatures and broadcast the transaction.\n\nFor this to be useful we have an extra requirement over typical OT which is\nthat we can verify the contents of the message we didn't choose. i.e. even\nif we are not doing a recovery we have to be able to verify that the\nsignatures we were offered were valid (wihout actually ever being able to\nuse them!). Otherwise a malicious party could just be sending us invalid\nsignatures in the OT the whole time. The name for this oblivious signatures.\n\n## Constructing\n\nOblivious signatures can be created using any verifiable encrypted\nsignature scheme where the encryption key is a group element (this includes\nadaptor signatures).\nIn [1] they actually use adaptor signatures without calling them that to\ncreate a Schnorr oblivious signature scheme that is similar to what you\nwould do with BIP340 Schnorr in practice.\nI used this in [2] to create scriptless lotteries in Bitcoin.\n\nTo start assume that you have three functions (which can be instantiated\nwith adaptor signatures):\n\n- `encrypted_sign(x, m, Y) -> e`\n- `encrypted_signature_verify(X, m, Y) -> true/false`\n- `decrypt_signature(e, y) -> s`\n\nWhere X is the public signing key Y is the encryption key and (x,y) are\ntheir corresponding secret keys.\nIn our case x can be thought of as a secret key on a funding output.\n\nFirst, the party receiving the offer decides whether they want to receive\nthe settlement tx signature by setting c = 0  or otherwise c = 1 and then\ncreates a pedersen commitment Y to c by choosing a random y:\n\nY = y *G + c * H\n\nand sends the commitment Y to its peer.\n\nThe peer then sends `e = encrypted_sign(x, settlement_tx, Y)` back.\n\nIf c = 0 (i.e. it is doing a covert recovery) it does `s =\ndecrypt_signature(e, y)` and attaches to the settlement transaction and\nbroadcasts it.  The channel is now successfully closed assuming the\nencrypted signature was valid.\n\nIf c = 1 (i.e. the node is fine and it wants to continue the channel) then\nit checks `encrypted_signature_verify(X, settlement_tx, Y)`. If it passes\nit sends the commitment blinding y back to prove that it doesn't have the\nsignature (i.e. prove c = 1). If verification fails then the node is\nmalicious and it fails the channel. Note that it is not possible to decrypt\nthe signature if c = 1 since the discrete logarithm of H with respect to G\nis unknown.\n\n## Misc Q&A\n\n- Does this require crazy crypto magic? No with the exception of Pedersen\ncommitments it only requires what is being planned to be included in\nlightning anyway i.e. adaptor signatures.\n\n-  Who is receiver and who is sender? In my imagination this works by the\npeer that is opening the connection being the receiver. This seems more\nuseful since users who are likely to not have redundant storage and\ngenerally mess things up and need to recover are often behind NAT or on\nphone networks without a public ip. There are cases where a public node may\nwant to recover by having people connect to them but I don't know what to\ndo about that. It looks like you have to choose one or the other.\n\n- Can't they still steal money? Yes but this is still a strictly better\nthan the current situation. The attacker has to guess precisely which\nconnection you make is after data loss. This is tricky task especially\nbecause if they ever guess wrongly you close your channel with them and\nblock them. Right now you are the one who tells them you've lost data!\n\n- Are these oblivious signatures secure? Yes. Sender security (receiver\nonly gets the signature if c = 0) is based on discrete log assumption.\nHint: if you instantiate the above algorithms with adaptor signatures we\ncan extract the discrete log of H from a receiver who knows an opening of Y\nwhere c = 1 and also successfully decrypts the signature. Receiver security\nis unconditional (Pedersen commitments are unconditionally hiding).\n\n- Does this work for multiple signatures? Yes you can choose to receive N\nsignatures to close N channels or nothing.  The signer just sends multiple\ne_1, e_2 produced the same way and the receiver can decrypt them all if c =\n0.\n\n- Does it work for key aggregated signatures i.e. MuSig2? -- Yes\n`encrypted_sign` just becomes a two round protocol to produce `e`.\n\n- What do you do if the channel state has HTLCs in flight? I don't know --\nI guess you can just put them onto the settlement tx? That way it's\npossible the payment could still go through. Alternatively you could just\ngift the money to the party offering the recovery settlement.\n\n[1]\nhttp://www.cs.nccu.edu.tw/~raylin/UndergraduateCourse/ComtenporaryCryptography/Spring2009/TSOINSPET2007.pdf\n[2]\nhttps://telaviv2019.scalingbitcoin.org/files/scriptless-lotteries-on-bitcoin-from-oblivious-transfer.pdf\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201211/0179a579/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-12-13T17:41:57",
                "message_text_only": "On Fri, Dec 11, 2020 at 01:02:04PM +1100, Lloyd Fournier wrote:\n> If c = 1 (i.e. the node is fine and it wants to continue the channel) then\n> it checks `encrypted_signature_verify(X, settlement_tx, Y)`. If it passes\n> it sends the commitment blinding y back to prove that it doesn't have the\n> signature (i.e. prove c = 1). If verification fails then the node is\n> malicious and it fails the channel. \n\nThis is really cool!  However, I don't understand why it's needed.  Your\ngoal seems to be for the sender to provide the commitment transaction\nand signatures before he learns whether the receiver actually needs\nthem.  That's just as easily accomplished by sending the data upfront in\nplain text.  For example, it seems to me that both of the following\nprotocols provide identical utility:\n\n1. On every reconnection, request the plain text unsigned commitment\n   transaction, send a pedersen commitment, and receive the encrypted\n   signature(s).  If c=1, verify the encrypted signature(s) and (on\n   success) send the blinding factor or (on failure) fail the channel\n   and ban the peer.  If c=0, decrypt the signature(s), apply them to\n   the commitment transaction, and broadcast.\n\n2. On every reconnection, request the plain text unsigned commitment\n   transaction with all of its signatures, also in plain text.  If our\n   database is intact, verify the commitment transaction and its\n   signatures are valid and (on success) continue or (on failure) fail\n   and ban.  If we lost data, broadcast the commitment transaction.\n\nUnless I'm forgetting something, there's no reason a node shouldn't send\nits latest commitment transaction to its counterparty in plain text\n(over the regular BOLT8 P2P encrypted and authenticated link).\n\nI think the challenge in either protocol above is deciding which peer\ngoes first, because whoever sends the commitment transaction reveals\nwhat they think the current state is.  Any node that refuses to go first\ncan then be suspected of having lost data.  BOLT2\noption_static_remotekey has this same problem, which is reasonably\nmitigated IMO by LN's penalty mechanism forcing any would-be thief to\nrisk their own funds; this doesn't work for basic eltoo, though.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201213/778f3af7/attachment.sig>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-14T05:31:23",
                "message_text_only": "Hi Dave,\n\nThanks for taking a read. You brought up really good points that need\naddressing.\n\nThis is really cool!  However, I don't understand why it's needed.  Your\n> goal seems to be for the sender to provide the commitment transaction\n> and signatures before he learns whether the receiver actually needs\n> them.  That's just as easily accomplished by sending the data upfront in\n> plain text.\n>\n\nTo be clear: The goal is to offer a cooperative settlement transaction up\nfront to the (possibly) recovering party -- *not a commitment transaction*.\nNote we cannot send a cooperative settlement tx up front for each\nconnection since they are not revocable -- the channel is over once it has\nbeen received.\n\nI admit I didn't properly consider just sending commitment transactions\nover. This is probably because it exposes the recovering party to the\npunishment mechanism and in my most recent line of research you *really*\ndon't want to do this. The idea I'm working with in revocable signature\nbased channels [1] is to make the node lose its static secret key if it\nposts a revoked commitment tx. This means they could lose ALL funds from\nALL their channels with ALL their peers if they ever broadcast a single\nrevoked commitment transaction. This would be a very bad thing to happen\nwhile you're trying to recover funds.\n\nI agree with your core point that in LN as it exists today the security\nassumption of both methods is that the adversary will be unable to\ndistinguish a connection attempt after data loss from an ordinary one. If\nthey can reliably do this then both methods can lead to loss of funds so\nwhy bother with the wonky crypto?\n\nI think there is a subtle reason why oblivious settlement signatures are\nstill preferable: it is difficult to provide a coherent UX for recovery\nwhen just sending YOLO commitment transactions. It would be best if the\nrecovery UX was \"hey user I've found 0.367 Bitcoin across these three\nchannels would you like to recover them?\". The user can then accept this or\ncancel the recovery process and go through some extra trouble to recover\ntheir data (in practice, data is often not completely lost but recoverable\nwith some effort). This is how it could work using the oblivious settlement\ntxs I proposed.\n\nUsing YOLO commitment transactions this becomes \"hey user I've found 0.523\nBitcoin across three channels\" which may actually be more than you are owed\nto entice you to shoot yourself in the foot. Even if it's exactly what you\nare owed, when you confirm the recovery your next message might be \"aaaand\nit's gone\" because one of the commit txs was revoked.\n\nIt seems difficult to recommend YOLO commitment transactions becoming the\nstandard way to recover funds. It could be preferable to the current system\nbut even that is up for debate I guess. I feel like I can recommend\noblivious settlements because (i) it's covert (like YOLO commitments txs\nunlike current system) and (ii) it's  \"what you see is what you get\" -- you\nare guaranteed to recover the funds that you are presented with once you\nfinally trigger the recovery.\n\nAlthough I do think oblivious settlement txs is a good idea I am working on\nyet *another* recovery idea for doing peer provided encrypted backup and\nfull channel restoration in a way that provides another guarantee: If the\npeer sends you an outdated encrypted backup (perhaps in the hope that it\nhas a revoked commitment tx in it) -- you can punish them immediately upon\nreceiving the backup (if you haven't actually had data loss).\nUnfortunately, It looks like this will use more heavy cryptographic\nprimitives.\n\nI think the challenge in either protocol above is deciding which peer\n> goes first, because whoever sends the commitment transaction reveals\n> what they think the current state is.  Any node that refuses to go first\n> can then be suspected of having lost data.  BOLT2\n> option_static_remotekey has this same problem, which is reasonably\n> mitigated IMO by LN's penalty mechanism forcing any would-be thief to\n> risk their own funds; this doesn't work for basic eltoo, though.\n>\n\nWhat is the story with option_static_remotekey? I am interested to know how\nthe negotiation of that option has a security issue but I don't see how it\ncould.\n\n[1]: https://github.com/LLFourn/witness-asymmetric-channel\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201214/160c7de0/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-12-14T13:12:48",
                "message_text_only": "On Mon, Dec 14, 2020 at 04:31:23PM +1100, Lloyd Fournier wrote:\n> To be clear: The goal is to offer a cooperative settlement transaction up\n> front to the (possibly) recovering party -- *not a commitment transaction*.\n\nAh, what BOLT0 calls a \"mutual close\".  That makes a lot more sense and\nmakes the protocol even cooler than I thought.  Thanks for clarifying!\n\n> The idea I'm working with in revocable signature based channels [1] is\n> to make the node lose its static secret key if it posts a revoked\n> commitment tx. This means they could lose ALL funds from ALL their\n> channels with ALL their peers if they ever broadcast a single revoked\n> commitment transaction. This would be a very bad thing to happen while\n> you're trying to recover funds.\n\nYikes!  A very bad thing indeed.  I'll have to re-read about witness\nasymmetric channels; I don't think I realized that was a consequence of\nusing them.\n\n> What is the story with option_static_remotekey? I am interested to know how\n> the negotiation of that option has a security issue but I don't see how it\n> could.\n\nWhoops, I got myself confused.  I meant option_data_loss_protect, which\nLND calls \"static channel backups\".  I just git greped the bolts for\n\"static\" and copied the first plausible seeming result.  :facepalm:\n\nOn Mon, Dec 14, 2020 at 12:08:27AM -0800, Ariel Lorenzo-Luaces wrote:\n> I don't think it's so clear that any party refusing to go go first can\n> be assumed to have lost data.\n\nOh, I agree, it's definitely not clear.  I just said they could \"be\n*suspected* of having lost data\". \n\nOn Mon, Dec 14, 2020 at 12:08:27AM -0800, Ariel Lorenzo-Luaces wrote:\n> If the rule is that the party receiving the connection is the one that\n> must send the oblivious signatures then a party that has both lost\n> data and is receiving a connection can just ignore the connection\n> request.\n> \n> There is plausible denyability because knowingly not answering a\n> request can't be distinguished from just having connection issues or\n> distinguished from a machine is just turned off.\n\nIn many cases, the network does behave differently in different\ncases:\n\n    $ nmap -p 80 dtrt.org  ## online and port available\n    80/tcp open  http\n\n    $ nmap -p 80 newmail.dtrt.org  ## online but no service listening\n    80/tcp closed http\n\n    $ nmap -p 22 10.0.0.1  ## online but connection refused\n    22/tcp filtered ssh\n\n    $ nmap -p 80 10.0.0.200  ## not online\n    Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn\n\nMoreover, there's the case where Bob tries to open a connection with\nMallory, but Mallory immediately turns around and tries to open a\nconnection with Bob.  In that case, Bob's unavailability might look\nsuspicious (although it could just be NAT or something else innocuous).\n\nHowever, beyond IP network activity, there's potentially a lot of\nevidence a dishonest counterparty can gather about a\nrecently-reconnected node to evaluate the probability that it suffered a\ndata loss.  Perhaps most persuasive would be seeing what happened to\nthat node's other channels.  Were they all closed?  Did the node fail to\npromptly broadcast a transaction with preimages trying to claim any\npending HTLCs (which can be especially strong evidence if the dishonest\ncounterparty was along the routing path for any of those HTLCs and so\nknows that the preimage was disclosed).  \n\nThe reason option_data_loss_protects works in theory is that the only\nway attacker Mallory can test her hypothesis that victim Bob lost data\nis by Mallory broadcasting an old state that Bob, if he didn't actually\nlose data, can use to penalize Mallory in a way that may profit Bob.  In\nan ideal world, for every victim node that actually lost data there'd be\nseveral honeypot nodes that faked losing data in order to profit from\ndishonest counterparties.  Unfortunately, I doubt that's the case, for\ntwo reasons:\n\n  1. You can only operate a data loss honeypot by causing a channel to\n     be closed onchain, which is going to waste someone's fees.\n\n  2. A dishonest node may only try broadcasting an old state when their\n     channel balance is low, near the minimum allowed by the channel\n     reserve.  The guidelines for channel reserve amounts were chosen\n     (I believe) under the assumption that Mallory can be highly\n     confident that Bob has the latest state, so the reserve is just\n     the bare amount needed to prevent some annoying griefing.  The\n     reserve is probably not large enough to compensate for the work and\n     fee-paying costs of operating data loss honeypots.\n\nThat said, most nodes seem to be honest and hopefully the nodes playing\nwith high-value channels are using some sort of live replication, so I\ndon't think there have been any issues so far.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201214/9ee971e1/attachment.sig>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-15T03:43:46",
                "message_text_only": "> It seems difficult to recommend YOLO commitment transactions becoming\nthe standard way to recover funds. It could be preferable to the current\nsystem but even that is up for debate I guess.\n> I feel like I can recommend oblivious settlements because (i) it's covert\n(like YOLO commitments txs unlike current system) and (ii) it's  \"what you\nsee is what you get\" -- you are guaranteed to recover the funds that you\nare presented with once you finally trigger the recovery\n\nOff list Dave correctly pointed out to me that this wasn't a very clear\npicture of the situation.\nAfter some thought, I came up with these claims that I think I can make\nstrongly:\n\n1. Before you reveal that you are doing recovery you are guaranteed to have\na tx in hand that:\n     i. You can broadcast first\n     ii. You can choose the fee to be as high as you like\n     iii. Is not replaceable.\n2. If the malicious party is *not* willing to risk broadcasting a revoked\ntx then you are guaranteed to recover the face value of the transaction(s)\nyou have in hand.\n3. An honest party is never at risk of broadcasting a revoked commitment tx.\n4. You never have to reveal that you were doing a recovery i.e. the channel\ncan continue (strictly preferable to 1)\n\nCurrent system has: 3\nOblivious mutual close has: 1,2,3\nYOLO commitments has: 1,5\n\nSo I think the question of YOLO commitments vs oblivious mutual close is\nwhether paying the price of losing (2,3) is worth the upgrade from (1) to\n(5).\nThe concern with (1) is that once you broadcast to the network the\nobliviously transferred \"mutual close\" transaction, the malicious party\nthen has a hint that you have lost data and they can try and broadcast a\nfavourable revoked transaction.\nThis should be very hard since in (1) you broadcast first, can choose as\nlarge a fee as you like and the tx does not signal replaceability whereas\nthe revoked tx *will* signal replaceability.\nI'm also personally trying to avoid losing (3) because to keep [1]\napplicable.\n\nAs a side note: in YOLO commitment transactions you have to recover some\nadditional metadata from the other party -- in particular the compressed\nrevocation keys that you *should* know otherwise the channel cannot\ncontinue to operate. So a signature on the compressed revocation keys must\nbe given to the other party before you lose data and returned to you when\nyou are given the commitment transaction upon reconnection.\nThis should be easy enough to do though.\n\n[1]\nhttps://github.com/LLFourn/witness-asymmetric-channel#scorched-earth-punishments\n\nOn Tue, Dec 15, 2020 at 12:13 AM David A. Harding <dave at dtrt.org> wrote:\n\n> > The idea I'm working with in revocable signature based channels [1] is\n> > to make the node lose its static secret key if it posts a revoked\n> > commitment tx. This means they could lose ALL funds from ALL their\n> > channels with ALL their peers if they ever broadcast a single revoked\n> > commitment transaction. This would be a very bad thing to happen while\n> > you're trying to recover funds.\n>\n> Yikes!  A very bad thing indeed.  I'll have to re-read about witness\n> asymmetric channels; I don't think I realized that was a consequence of\n> using them.\n>\n\nIt's an optional feature -- see link[1] above where I just added an\nexplanation of it.\nI actually see no reason why you couldn't apply revocable signatures to\ntransaction asymmetric channels (LN as it is today) you just have to\noverhaul the revocation mechanism.\n\nIn general I agree with your points that side-channels may be effective\ntools to reveal whether a node has had data loss or not.\nI think in both YOLO commitments and oblivious mutual close it is easy\nenough to simulate data-loss up to a point to try and catch malicious peers\nusing side channels.\nAt least you don't have to ask the peer to broadcast a tx to find out!\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201215/7b1e9210/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-15T06:07:04",
                "message_text_only": "Errr please replace 5 with 4 in the previous post. Thanks to devrandom.\n\nLL\n\n\nOn Tue, Dec 15, 2020 at 2:43 PM Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n>\n> > It seems difficult to recommend YOLO commitment transactions becoming the standard way to recover funds. It could be preferable to the current system but even that is up for debate I guess.\n> > I feel like I can recommend oblivious settlements because (i) it's covert (like YOLO commitments txs unlike current system) and (ii) it's  \"what you see is what you get\" -- you are guaranteed to recover the funds that you are presented with once you finally trigger the recovery\n>\n> Off list Dave correctly pointed out to me that this wasn't a very clear picture of the situation.\n> After some thought, I came up with these claims that I think I can make strongly:\n>\n> 1. Before you reveal that you are doing recovery you are guaranteed to have a tx in hand that:\n>      i. You can broadcast first\n>      ii. You can choose the fee to be as high as you like\n>      iii. Is not replaceable.\n> 2. If the malicious party is *not* willing to risk broadcasting a revoked tx then you are guaranteed to recover the face value of the transaction(s) you have in hand.\n> 3. An honest party is never at risk of broadcasting a revoked commitment tx.\n> 4. You never have to reveal that you were doing a recovery i.e. the channel can continue (strictly preferable to 1)\n>\n> Current system has: 3\n> Oblivious mutual close has: 1,2,3\n> YOLO commitments has: 1,5\n>\n> So I think the question of YOLO commitments vs oblivious mutual close is whether paying the price of losing (2,3) is worth the upgrade from (1) to (5).\n> The concern with (1) is that once you broadcast to the network the obliviously transferred \"mutual close\" transaction, the malicious party then has a hint that you have lost data and they can try and broadcast a favourable revoked transaction.\n> This should be very hard since in (1) you broadcast first, can choose as large a fee as you like and the tx does not signal replaceability whereas the revoked tx *will* signal replaceability.\n> I'm also personally trying to avoid losing (3) because to keep [1] applicable.\n>\n> As a side note: in YOLO commitment transactions you have to recover some additional metadata from the other party -- in particular the compressed revocation keys that you *should* know otherwise the channel cannot continue to operate. So a signature on the compressed revocation keys must be given to the other party before you lose data and returned to you when you are given the commitment transaction upon reconnection.\n> This should be easy enough to do though.\n>\n> [1] https://github.com/LLFourn/witness-asymmetric-channel#scorched-earth-punishments\n>\n> On Tue, Dec 15, 2020 at 12:13 AM David A. Harding <dave at dtrt.org> wrote:\n>>\n>> > The idea I'm working with in revocable signature based channels [1] is\n>> > to make the node lose its static secret key if it posts a revoked\n>> > commitment tx. This means they could lose ALL funds from ALL their\n>> > channels with ALL their peers if they ever broadcast a single revoked\n>> > commitment transaction. This would be a very bad thing to happen while\n>> > you're trying to recover funds.\n>>\n>> Yikes!  A very bad thing indeed.  I'll have to re-read about witness\n>> asymmetric channels; I don't think I realized that was a consequence of\n>> using them.\n>\n>\n> It's an optional feature -- see link[1] above where I just added an explanation of it.\n> I actually see no reason why you couldn't apply revocable signatures to transaction asymmetric channels (LN as it is today) you just have to overhaul the revocation mechanism.\n>\n> In general I agree with your points that side-channels may be effective tools to reveal whether a node has had data loss or not.\n> I think in both YOLO commitments and oblivious mutual close it is easy enough to simulate data-loss up to a point to try and catch malicious peers using side channels.\n> At least you don't have to ask the peer to broadcast a tx to find out!\n>\n> Cheers,\n>\n> LL"
            },
            {
                "author": "Ariel Lorenzo-Luaces",
                "date": "2020-12-14T08:08:27",
                "message_text_only": "I don't think it's so clear that any party refusing to go go first can be assumed to have lost data.\n\nIf the rule is that the party receiving the connection is the one that must send the oblivious signatures then a party that has both lost data and is receiving a connection can just ignore the connection request.\n\nThere is plausible denyability because knowingly not answering a request can't be distinguished from just having connection issues or distinguished from a machine is just turned off.\n\nThis reasoning should work well into the future because as long as machine failures are common, the node with data loss can hide in that anonymity set. And if human kind resolves all machine failures then by definition there shouldn't be lightning channel data loss.\n\nCheers\nAriel Lorenzo-Luaces\n\nOn Dec 13, 2020, 10:12 AM, at 10:12 AM, \"David A. Harding\" <dave at dtrt.org> wrote:\n>On Fri, Dec 11, 2020 at 01:02:04PM +1100, Lloyd Fournier wrote:\n>> If c = 1 (i.e. the node is fine and it wants to continue the channel)\n>then\n>> it checks `encrypted_signature_verify(X, settlement_tx, Y)`. If it\n>passes\n>> it sends the commitment blinding y back to prove that it doesn't have\n>the\n>> signature (i.e. prove c = 1). If verification fails then the node is\n>> malicious and it fails the channel. \n>\n>This is really cool!  However, I don't understand why it's needed. \n>Your\n>goal seems to be for the sender to provide the commitment transaction\n>and signatures before he learns whether the receiver actually needs\n>them.  That's just as easily accomplished by sending the data upfront\n>in\n>plain text.  For example, it seems to me that both of the following\n>protocols provide identical utility:\n>\n>1. On every reconnection, request the plain text unsigned commitment\n>   transaction, send a pedersen commitment, and receive the encrypted\n>   signature(s).  If c=1, verify the encrypted signature(s) and (on\n>   success) send the blinding factor or (on failure) fail the channel\n>   and ban the peer.  If c=0, decrypt the signature(s), apply them to\n>   the commitment transaction, and broadcast.\n>\n>2. On every reconnection, request the plain text unsigned commitment\n>   transaction with all of its signatures, also in plain text.  If our\n>   database is intact, verify the commitment transaction and its\n>   signatures are valid and (on success) continue or (on failure) fail\n>   and ban.  If we lost data, broadcast the commitment transaction.\n>\n>Unless I'm forgetting something, there's no reason a node shouldn't\n>send\n>its latest commitment transaction to its counterparty in plain text\n>(over the regular BOLT8 P2P encrypted and authenticated link).\n>\n>I think the challenge in either protocol above is deciding which peer\n>goes first, because whoever sends the commitment transaction reveals\n>what they think the current state is.  Any node that refuses to go\n>first\n>can then be suspected of having lost data.  BOLT2\n>option_static_remotekey has this same problem, which is reasonably\n>mitigated IMO by LN's penalty mechanism forcing any would-be thief to\n>risk their own funds; this doesn't work for basic eltoo, though.\n>\n>-Dave\n>\n>\n>------------------------------------------------------------------------\n>\n>_______________________________________________\n>Lightning-dev mailing list\n>Lightning-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201214/eb2a5521/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-15T10:21:09",
                "message_text_only": "Good morning LL,\n\n\n> - What do you do if the channel state has HTLCs in flight? I don't know -- I guess you can just put them onto the settlement tx? That way it's possible the payment could still go through. Alternatively you could just gift the money to the party offering the recovery settlement.\n\nGifting the money is not a good option --- we allow HTLCs to be almost as high as the total channel value minus fees and reserve.\nThus all the claimable value could potentially be in an outgoing HTLC.\nWorse, if our node is a forwarding node, it would be easy for a third party to arrange to have our funds in various HTLCs.\n\nIf we allow HTLCs to keep going on even while we are in recovery, we need to be able to \"bind\" as well incoming and outgoing HTLCs if our node was a forwarding node.\n\nIn particular, consider this situation:\n\n* We are a forwarding node.\n* We forward a payment whose outgoing expires in 1 day and whose incoming expires in 2 days.\n  * This means we have at least two channels, one with the incoming HTLC and another with the outgoing HTLC.\n* We hit our head and get amnesia.\n* It takes us a day to realize we were formerly a Lightning Network forwarding node.\n* The peer with the outgoing HTLC knows or learns the preimage.\n  * Since we were unresponsive (i.e. still recovering from whatever gave us amnesia) that peer has dropped the channel onchain.\n  * The peer has resolved the onchain HTLC with the hashlock branch.\n* Because the outgoing peer has resolved everything it cares about, it forgets about the channel.\n* We call all public nodes and ask about channels we might have with them.\n* The incoming peer claims we have a channel with them containing an HTLC going to us.\n* The outgoing peer has forgotten about us and does not tell us about the channel.\n\nThus, we cannot recover the outgoing channel, since the peer has already closed it and resolved everything it is interested in.\n(let us suppose that the `to_self_delay` is smaller than our `cltv_delta` setting)\n\nUsing static-key channels (i.e. channel keys are our node keys) allows us to recover even the outgoing channel with outgoing HTLC that has been forgotten by the outgoing peer.\n\nUsing static-key channels does have slightly weaker privacy:\n\n* Published nodes reveal all their channels with other published nodes on the blockchain.\n  * While it is true that published nodes already reveal their channels with published nodes, they are currently only revealed on the LN gossip network, which is not archived; historical channels that are now closed are not informed to current surveillors.\n    * On the other hand, all it takes is one \"LN wayback machine\" to record all LN gossip, which are self-attesting and include a signature from the node.\n* Unpublished nodes risk revealing their channels with published nodes via the blockchain.\n  * Invoices created by unpublished nodes currently reveal their public key.\n    Payers can then uncover all the channels of that node.\n  * An unpublished node could use a faked node id, by combining the payment hash/point with its privkey to generate a new keypair to use as faked node id (I AM NOT A CRYPTOGRAPHER AND THIS TECHNIQUE IS POTENTIALLY GOING TO LOSE ALL YOUR FUNDS AND PRIVACY AND KILL YOUR DOG).\n    On receiving an unparseable onion, it could try combining its privkey with the payment hash/point and try to open the onion that way, in case it is an incoming payment with the faked node id.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-16T04:51:01",
                "message_text_only": "Hey Z,\n\nOn Tue, Dec 15, 2020 at 9:21 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning LL,\n>\n>\n> > - What do you do if the channel state has HTLCs in flight? I don't know -- I guess you can just put them onto the settlement tx? That way it's possible the payment could still go through. Alternatively you could just gift the money to the party offering the recovery settlement.\n>\n> Gifting the money is not a good option --- we allow HTLCs to be almost as high as the total channel value minus fees and reserve.\n> Thus all the claimable value could potentially be in an outgoing HTLC.\n> Worse, if our node is a forwarding node, it would be easy for a third party to arrange to have our funds in various HTLCs.\n\nHopefully this recovery system is used by people whose channels are in\na HTLC free state 99.9999% of the time (and hopefully hardware\nfailures do not somehow coincide with HTLCs!).\nAs a user, it would be cool to be able to just lock up all my Bitcoin\ninto channels with well-established lightning nodes. That way if fees\ngo ballistic I can still move money around cheaply.\nOne of the main concerns for this pattern of user behaviour is the\nrecovery story I think. The first line of defence for routing nodes\n(people who are taking their role in LN seriously) has to be redundant\ndata storage.\nThis would be a poor last-resort solution for routing nodes.\n\n> Using static-key channels (i.e. channel keys are our node keys) allows us to recover even the outgoing channel with outgoing HTLC that has been forgotten by the outgoing peer.\n\nRight. I think this doesn't work with PTLCs though.\n\n> Using static-key channels does have slightly weaker privacy:\n>\n> * Published nodes reveal all their channels with other published nodes on the blockchain.\n>   * While it is true that published nodes already reveal their channels with published nodes, they are currently only revealed on the LN gossip network, which is not archived; historical channels that are now closed are not informed to current surveillors.\n>     * On the other hand, all it takes is one \"LN wayback machine\" to record all LN gossip, which are self-attesting and include a signature from the node.\n> * Unpublished nodes risk revealing their channels with published nodes via the blockchain.\n>   * Invoices created by unpublished nodes currently reveal their public key.\n>     Payers can then uncover all the channels of that node.\n\nI don't think so? You need to know the private key of the node to\ndiscover its channels! The points actually used in the channels would\nbe randomized with shared secret from Diffie-Hellman so are unlinkable\nto the public keys of the two nodes under decisional Diffie-Hellman\nassumption.\n\nThere is more minor but still real concern of \"deniability\" of\nunpublished closed channels if a large node operator later becomes\ncorrupted or coerced by a malicious actor. Since the node operator\nstill knows their secret key (obviously) they can still do a scan\n(same as you would do in recovery) on the whole chain and find any\npast channels they had with any nodes. A mitigation of this problem\nwould be for users who want unpublished channels to turn the\nuse-node-key-as-channel-key feature off for their keys in the channel\nso they would still be able to do a backup-free channel scan but the\nwell-established node would lose the ability to do so. This means that\nafter the channel is closed there would be no way for the large node\nto find the channel again assuming they honestly delete the data.\n\nCheers,\n\nLL"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-16T14:56:30",
                "message_text_only": "Good morning LL,\n\n> > > -   What do you do if the channel state has HTLCs in flight? I don't know -- I guess you can just put them onto the settlement tx? That way it's possible the payment could still go through. Alternatively you could just gift the money to the party offering the recovery settlement.\n> >\n> > Gifting the money is not a good option --- we allow HTLCs to be almost as high as the total channel value minus fees and reserve.\n> > Thus all the claimable value could potentially be in an outgoing HTLC.\n> > Worse, if our node is a forwarding node, it would be easy for a third party to arrange to have our funds in various HTLCs.\n>\n> Hopefully this recovery system is used by people whose channels are in\n> a HTLC free state 99.9999% of the time (and hopefully hardware\n> failures do not somehow coincide with HTLCs!).\n> As a user, it would be cool to be able to just lock up all my Bitcoin\n> into channels with well-established lightning nodes. That way if fees\n> go ballistic I can still move money around cheaply.\n> One of the main concerns for this pattern of user behaviour is the\n> recovery story I think. The first line of defence for routing nodes\n> (people who are taking their role in LN seriously) has to be redundant\n> data storage.\n> This would be a poor last-resort solution for routing nodes.\n\nA common occurrence is that hardware failure is not detected until when the hardware is used, especially when used by casual users.\n\nConsider the sequence of events:\n\n* Part of the storage device fails.\n  * Due to being a casual user, the user does not use state-of-the-art checksumming filesystems like ZFS and does not monitor disk health by S.M.A.R.T.\n* A high-onchain-fee condition exists.\n* The casual user attempts to send out a payment consisting of almost all funds in their LN channels via several HTLCs on MPP or other multipath.\n* Because of the activity generated, the filesystem assigns the LN database to the failing part.\n* Storage fails with most funds in outgoing HTLCs.\n\nThus, merely activating the wallet and using HTLCs may result in a *detectable* failure of the hardware (which was already failing before, just not noticed by the casual user).\n\nOn the other hand, we can consider this situation as having a complexity penalty.\n\nAs someone who has seen a lot of storage devices slowly fail in unique and interesting (and data-losing) ways, I am always going to assume that storage devices are going to fail at any time, including a few hours after installation.\n\nIt would be preferable if HTLCs and PTLCs are not gifted.\nOn the other hand, it might not be possible (as you note about PTLCs).\n\n>\n> > Using static-key channels (i.e. channel keys are our node keys) allows us to recover even the outgoing channel with outgoing HTLC that has been forgotten by the outgoing peer.\n>\n> Right. I think this doesn't work with PTLCs though.\n\nYes, loss of the adaptor signature means we cannot recover in this case.\n\n>\n> > Using static-key channels does have slightly weaker privacy:\n> >\n> > -   Published nodes reveal all their channels with other published nodes on the blockchain.\n> >     -   While it is true that published nodes already reveal their channels with published nodes, they are currently only revealed on the LN gossip network, which is not archived; historical channels that are now closed are not informed to current surveillors.\n> >         -   On the other hand, all it takes is one \"LN wayback machine\" to record all LN gossip, which are self-attesting and include a signature from the node.\n> > -   Unpublished nodes risk revealing their channels with published nodes via the blockchain.\n> >     -   Invoices created by unpublished nodes currently reveal their public key.\n> >         Payers can then uncover all the channels of that node.\n> >\n>\n> I don't think so? You need to know the private key of the node to\n> discover its channels! The points actually used in the channels would\n> be randomized with shared secret from Diffie-Hellman so are unlinkable\n> to the public keys of the two nodes under decisional Diffie-Hellman\n> assumption.\n\nRight, that would work.\n\nHow about just using a multiplicative tweak of your own privkey and the pubkey of the other node (i.e. just use the \"raw\" ECDH point), that would work as 2-of-2 in 2p-ECDSA, and I believe (but do not know) should also be signable using MuSig/MuSig2 under taproot?\n\n\n>\n> There is more minor but still real concern of \"deniability\" of\n> unpublished closed channels if a large node operator later becomes\n> corrupted or coerced by a malicious actor. Since the node operator\n> still knows their secret key (obviously) they can still do a scan\n> (same as you would do in recovery) on the whole chain and find any\n> past channels they had with any nodes.\n\n\"Peer selling private information\" is always going to be an issue with unpublished channels, and this seems to be an inherent issue with that model.\n\nNote that due to the existence of proof-of-discrete-log-equivalence, a node operator can *prove* to someone buying private information that a particular outpoint onchain is actually an unpublished channel.\nIf I have privkey `z` and you have pubkey `L`, I can show `z * G` (my node pubkey), `L` (your \"unpublished\" (ha, ha) node pubkey), and `z * L` (our ECDH secret), plus a proof-of-discrete-log-equivalence that the `z` in `z * G` is the same `z` in `z * L`, in order to convice them of the ECDH secret.\nI suspect part of the proof-of-discrete-log-equivalance can be gated as well by a ZKCP on payment point+scalar the proof is provided only on payment.\nThe selling node operator does not even need to reveal `z`.\n\nAs the ECDH secret is what tweaks the channel keys, that is enough to convince any surveilling buyer.\nFurther, `z` is not revealed, and channel funds cannot be stolen by just knowledge of the ECDH secret, thus protecting the interests of the selling forwarding node.\n\nNow of course, I could just be making up `L` (i.e. LL could be a sockpuppet of mine).\nHowever, between these two choices:\n\n* I lock up a set number of millisatoshi in a Z + L channel where L is a sockpuppet, and sell this fake information to surveillors.\n* I lock up a set number of millisatoshi in a Z + L channel where L is a genuine user node that thinks unpublished channels are private, and sell this genuine information to surveillors.\n\nWhich is more lucrative for me?\nThe latter case would be more lucrative for me, as I not only earn from selling your data to surveillors, I also earn routing fees.\nThe former case can only earn me selling fake data to surveillors, with no opportunity to earn forwarding fees.\n\n> A mitigation of this problem\n> would be for users who want unpublished channels to turn the\n> use-node-key-as-channel-key feature off for their keys in the channel\n> so they would still be able to do a backup-free channel scan but the\n> well-established node would lose the ability to do so.\n\nIf the user has all channels unpublished, it is not (normally) gossiped.\nSo the well-established node would not have the ability to recover *all* channels by backup-free scans of published nodes in the first place, only those that are to published nodes.\n\nOr do you refer to something else?\n\nIt might be easier for the \"client\" here to make up different node IDs for each \"server\" it connects to, by e.g. hashing its base privkey with the server pubkey and using the hash as the privkey for its fake node ID with that server.\n\n\n> This means that\n> after the channel is closed there would be no way for the large node\n> to find the channel again assuming they honestly delete the data.\n\nIf forwarding nodes are expected to have storage redundancy, deletion of data could be difficult as well --- there may be lots of replicas of that data in various places (including obsolete replicas that the node operator might not particularly care about, being obsolete), and deletion might not catch them all.\n\"Honestly delete\" seems like a best-effort to me.\n\nOn the other hand, if the model is that privacy is to be trusted to your peers, then this is no worse than unpublished channels, which has the same model.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-18T00:24:31",
                "message_text_only": "On Thu, Dec 17, 2020 at 1:56 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> A common occurrence is that hardware failure is not detected until when\nthe hardware is used, especially when used by casual users.\n>\n> Consider the sequence of events:\n>\n> * Part of the storage device fails.\n>   * Due to being a casual user, the user does not use state-of-the-art\nchecksumming filesystems like ZFS and does not monitor disk health by\nS.M.A.R.T.\n> * A high-onchain-fee condition exists.\n> * The casual user attempts to send out a payment consisting of almost all\nfunds in their LN channels via several HTLCs on MPP or other multipath.\n> * Because of the activity generated, the filesystem assigns the LN\ndatabase to the failing part.\n> * Storage fails with most funds in outgoing HTLCs.\n\nNote that this is fine if the payment goes through. Their counterparty will\nhave to go on-chain to claim the payment (since your node is down due to\ndata-loss) and then you claim whatever is left from your seed.\nThe main risk here is for routing nodes which are hopefully only using this\ntechnique as a very poor last resort.\nIf you actually manage to get online and try to restore before the on-chain\nsettlement then just attaching outgoing HTLCs to the mutual close would be\nfine -- that way the peer can still claim the money from you if the payment\ngoes through and you can get the refund if not.\n\nThe same could apply to incoming HTLCs as long as you can reproduce your\nHTLC pre-image deterministically.\n\nPS good to hear you are a ZFS user too\n\n>\n> Thus, merely activating the wallet and using HTLCs may result in a\n*detectable* failure of the hardware (which was already failing before,\njust not noticed by the casual user).\n>\n> On the other hand, we can consider this situation as having a complexity\npenalty.\n>\n> As someone who has seen a lot of storage devices slowly fail in unique\nand interesting (and data-losing) ways, I am always going to assume that\nstorage devices are going to fail at any time, including a few hours after\ninstallation.\n>\n> It would be preferable if HTLCs and PTLCs are not gifted.\n\nYes I am convinced.\n\n> >\n> > > Using static-key channels (i.e. channel keys are our node keys)\nallows us to recover even the outgoing channel with outgoing HTLC that has\nbeen forgotten by the outgoing peer.\n> >\n> > Right. I think this doesn't work with PTLCs though.\n>\n> Yes, loss of the adaptor signature means we cannot recover in this case.\n\nLet's think about this again. There is no reason why the oblivious mutual\nclose has to be the only thing the peer sends you upon connection. They can\nalso send you the necessary signatures for each PTLC output on the mutual\nclose because you can't do anything with this unless you choose to receive\nthe mutual close signature. You verify these each time you connect without\ndata loss so optimistically you should be able to recover both incoming and\noutgoing PTLCs\n\n> Right, that would work.\n>\n> How about just using a multiplicative tweak of your own privkey and the\npubkey of the other node (i.e. just use the \"raw\" ECDH point), that would\nwork as 2-of-2 in 2p-ECDSA, and I believe (but do not know) should also be\nsignable using MuSig/MuSig2 under taproot?\n\nI think multiplicative combination of keys does *not* work for Schnorr\nmultisignatures.\n\n>\n> \"Peer selling private information\" is always going to be an issue with\nunpublished channels, and this seems to be an inherent issue with that\nmodel.\n>\n> Note that due to the existence of proof-of-discrete-log-equivalence, a\nnode operator can *prove* to someone buying private information that a\nparticular outpoint onchain is actually an unpublished channel.\n> If I have privkey `z` and you have pubkey `L`, I can show `z * G` (my\nnode pubkey), `L` (your \"unpublished\" (ha, ha) node pubkey), and `z * L`\n(our ECDH secret), plus a proof-of-discrete-log-equivalence that the `z` in\n`z * G` is the same `z` in `z * L`, in order to convice them of the ECDH\nsecret.\n> I suspect part of the proof-of-discrete-log-equivalance can be gated as\nwell by a ZKCP on payment point+scalar the proof is provided only on\npayment.\n> The selling node operator does not even need to reveal `z`.\n>\n> As the ECDH secret is what tweaks the channel keys, that is enough to\nconvince any surveilling buyer.\n> Further, `z` is not revealed, and channel funds cannot be stolen by just\nknowledge of the ECDH secret, thus protecting the interests of the selling\nforwarding node.\n>\n> Now of course, I could just be making up `L` (i.e. LL could be a\nsockpuppet of mine).\n> However, between these two choices:\n>\n> * I lock up a set number of millisatoshi in a Z + L channel where L is a\nsockpuppet, and sell this fake information to surveillors.\n> * I lock up a set number of millisatoshi in a Z + L channel where L is a\ngenuine user node that thinks unpublished channels are private, and sell\nthis genuine information to surveillors.\n>\n> Which is more lucrative for me?\n> The latter case would be more lucrative for me, as I not only earn from\nselling your data to surveillors, I also earn routing fees.\n> The former case can only earn me selling fake data to surveillors, with\nno opportunity to earn forwarding fees.\n\nCorrect and interesting analysis. I agree that you don't want to\naccidentally opt in to having your peer have a way to cryptographically\nprove you have a channel with them.\nExcept in the situation where you are already cryptographically proving to\neveryone you have a channel with them in the channel announcement.\n\n>\n> > A mitigation of this problem\n> > would be for users who want unpublished channels to turn the\n> > use-node-key-as-channel-key feature off for their keys in the channel\n> > so they would still be able to do a backup-free channel scan but the\n> > well-established node would lose the ability to do so.\n>\n> If the user has all channels unpublished, it is not (normally) gossiped.\n> So the well-established node would not have the ability to recover *all*\nchannels by backup-free scans of published nodes in the first place, only\nthose that are to published nodes.\n>\n> Or do you refer to something else?\n\nI was thinking about public nodes with un-announced channels.\nFor completely private/unpublished nodes then I agree with your statement\nthat there is no hope no matter how you compute the keys to recover\nautomatically.\n\n>\n> It might be easier for the \"client\" here to make up different node IDs\nfor each \"server\" it connects to, by e.g. hashing its base privkey with the\nserver pubkey and using the hash as the privkey for its fake node ID with\nthat server.\n>\n\nRight. Something like this is what I was suggesting for public nodes who\nwant to have unpublished channels that they want to be able to channel scan\nfor but *do not want the other party* to be able to do so (to avoid\nconcerns you made clear earlier).\nI think there's no strong reason to make up a new node id -- it can just be\nan option in open_channel  like \"use this key instead of my node id for\neverything in this channel\".\n\nCheers,\n\nLL\n\n\n\nOn Thu, Dec 17, 2020 at 1:56 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning LL,\n>\n> > > > -   What do you do if the channel state has HTLCs in flight? I don't\n> know -- I guess you can just put them onto the settlement tx? That way it's\n> possible the payment could still go through. Alternatively you could just\n> gift the money to the party offering the recovery settlement.\n> > >\n> > > Gifting the money is not a good option --- we allow HTLCs to be almost\n> as high as the total channel value minus fees and reserve.\n> > > Thus all the claimable value could potentially be in an outgoing HTLC.\n> > > Worse, if our node is a forwarding node, it would be easy for a third\n> party to arrange to have our funds in various HTLCs.\n> >\n> > Hopefully this recovery system is used by people whose channels are in\n> > a HTLC free state 99.9999% of the time (and hopefully hardware\n> > failures do not somehow coincide with HTLCs!).\n> > As a user, it would be cool to be able to just lock up all my Bitcoin\n> > into channels with well-established lightning nodes. That way if fees\n> > go ballistic I can still move money around cheaply.\n> > One of the main concerns for this pattern of user behaviour is the\n> > recovery story I think. The first line of defence for routing nodes\n> > (people who are taking their role in LN seriously) has to be redundant\n> > data storage.\n> > This would be a poor last-resort solution for routing nodes.\n>\n> A common occurrence is that hardware failure is not detected until when\n> the hardware is used, especially when used by casual users.\n>\n> Consider the sequence of events:\n>\n> * Part of the storage device fails.\n>   * Due to being a casual user, the user does not use state-of-the-art\n> checksumming filesystems like ZFS and does not monitor disk health by\n> S.M.A.R.T.\n> * A high-onchain-fee condition exists.\n> * The casual user attempts to send out a payment consisting of almost all\n> funds in their LN channels via several HTLCs on MPP or other multipath.\n> * Because of the activity generated, the filesystem assigns the LN\n> database to the failing part.\n> * Storage fails with most funds in outgoing HTLCs.\n>\n> Thus, merely activating the wallet and using HTLCs may result in a\n> *detectable* failure of the hardware (which was already failing before,\n> just not noticed by the casual user).\n>\n> On the other hand, we can consider this situation as having a complexity\n> penalty.\n>\n> As someone who has seen a lot of storage devices slowly fail in unique and\n> interesting (and data-losing) ways, I am always going to assume that\n> storage devices are going to fail at any time, including a few hours after\n> installation.\n>\n> It would be preferable if HTLCs and PTLCs are not gifted.\n> On the other hand, it might not be possible (as you note about PTLCs).\n>\n> >\n> > > Using static-key channels (i.e. channel keys are our node keys) allows\n> us to recover even the outgoing channel with outgoing HTLC that has been\n> forgotten by the outgoing peer.\n> >\n> > Right. I think this doesn't work with PTLCs though.\n>\n> Yes, loss of the adaptor signature means we cannot recover in this case.\n>\n> >\n> > > Using static-key channels does have slightly weaker privacy:\n> > >\n> > > -   Published nodes reveal all their channels with other published\n> nodes on the blockchain.\n> > >     -   While it is true that published nodes already reveal their\n> channels with published nodes, they are currently only revealed on the LN\n> gossip network, which is not archived; historical channels that are now\n> closed are not informed to current surveillors.\n> > >         -   On the other hand, all it takes is one \"LN wayback\n> machine\" to record all LN gossip, which are self-attesting and include a\n> signature from the node.\n> > > -   Unpublished nodes risk revealing their channels with published\n> nodes via the blockchain.\n> > >     -   Invoices created by unpublished nodes currently reveal their\n> public key.\n> > >         Payers can then uncover all the channels of that node.\n> > >\n> >\n> > I don't think so? You need to know the private key of the node to\n> > discover its channels! The points actually used in the channels would\n> > be randomized with shared secret from Diffie-Hellman so are unlinkable\n> > to the public keys of the two nodes under decisional Diffie-Hellman\n> > assumption.\n>\n> Right, that would work.\n>\n> How about just using a multiplicative tweak of your own privkey and the\n> pubkey of the other node (i.e. just use the \"raw\" ECDH point), that would\n> work as 2-of-2 in 2p-ECDSA, and I believe (but do not know) should also be\n> signable using MuSig/MuSig2 under taproot?\n>\n>\n> >\n> > There is more minor but still real concern of \"deniability\" of\n> > unpublished closed channels if a large node operator later becomes\n> > corrupted or coerced by a malicious actor. Since the node operator\n> > still knows their secret key (obviously) they can still do a scan\n> > (same as you would do in recovery) on the whole chain and find any\n> > past channels they had with any nodes.\n>\n> \"Peer selling private information\" is always going to be an issue with\n> unpublished channels, and this seems to be an inherent issue with that\n> model.\n>\n> Note that due to the existence of proof-of-discrete-log-equivalence, a\n> node operator can *prove* to someone buying private information that a\n> particular outpoint onchain is actually an unpublished channel.\n> If I have privkey `z` and you have pubkey `L`, I can show `z * G` (my node\n> pubkey), `L` (your \"unpublished\" (ha, ha) node pubkey), and `z * L` (our\n> ECDH secret), plus a proof-of-discrete-log-equivalence that the `z` in `z *\n> G` is the same `z` in `z * L`, in order to convice them of the ECDH secret.\n> I suspect part of the proof-of-discrete-log-equivalance can be gated as\n> well by a ZKCP on payment point+scalar the proof is provided only on\n> payment.\n> The selling node operator does not even need to reveal `z`.\n>\n> As the ECDH secret is what tweaks the channel keys, that is enough to\n> convince any surveilling buyer.\n> Further, `z` is not revealed, and channel funds cannot be stolen by just\n> knowledge of the ECDH secret, thus protecting the interests of the selling\n> forwarding node.\n>\n> Now of course, I could just be making up `L` (i.e. LL could be a\n> sockpuppet of mine).\n> However, between these two choices:\n>\n> * I lock up a set number of millisatoshi in a Z + L channel where L is a\n> sockpuppet, and sell this fake information to surveillors.\n> * I lock up a set number of millisatoshi in a Z + L channel where L is a\n> genuine user node that thinks unpublished channels are private, and sell\n> this genuine information to surveillors.\n>\n> Which is more lucrative for me?\n> The latter case would be more lucrative for me, as I not only earn from\n> selling your data to surveillors, I also earn routing fees.\n> The former case can only earn me selling fake data to surveillors, with no\n> opportunity to earn forwarding fees.\n>\n> > A mitigation of this problem\n> > would be for users who want unpublished channels to turn the\n> > use-node-key-as-channel-key feature off for their keys in the channel\n> > so they would still be able to do a backup-free channel scan but the\n> > well-established node would lose the ability to do so.\n>\n> If the user has all channels unpublished, it is not (normally) gossiped.\n> So the well-established node would not have the ability to recover *all*\n> channels by backup-free scans of published nodes in the first place, only\n> those that are to published nodes.\n>\n> Or do you refer to something else?\n>\n> It might be easier for the \"client\" here to make up different node IDs for\n> each \"server\" it connects to, by e.g. hashing its base privkey with the\n> server pubkey and using the hash as the privkey for its fake node ID with\n> that server.\n>\n>\n> > This means that\n> > after the channel is closed there would be no way for the large node\n> > to find the channel again assuming they honestly delete the data.\n>\n> If forwarding nodes are expected to have storage redundancy, deletion of\n> data could be difficult as well --- there may be lots of replicas of that\n> data in various places (including obsolete replicas that the node operator\n> might not particularly care about, being obsolete), and deletion might not\n> catch them all.\n> \"Honestly delete\" seems like a best-effort to me.\n>\n> On the other hand, if the model is that privacy is to be trusted to your\n> peers, then this is no worse than unpublished channels, which has the same\n> model.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201218/d47a1446/attachment-0001.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-18T00:43:08",
                "message_text_only": "> I suspect part of the proof-of-discrete-log-equivalance can be gated as\nwell by a ZKCP on payment point+scalar the proof is provided only on\npayment.\n> The selling node operator does not even need to reveal `z`.\n\nActually no -- the fact that you were able to create a secure conditional\npayment for the proof would always prove the proof existed.\nYou wouldn't need to pay for the proof then!\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201218/279bb4a7/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-19T07:48:21",
                "message_text_only": "Good morning LL,\n\n> > I suspect part of the proof-of-discrete-log-equivalance can be gated as well by a ZKCP on payment point+scalar the proof is provided only on payment.\n> > The selling node operator does not even need to reveal `z`.\n>\n> Actually no -- the fact that you were able to create a secure conditional payment for the proof would always prove the proof existed.\n> You wouldn't need to pay for the proof then!\n\nThat depends on the proof.\n\nFor example, one pay-for-proof scheme would be somebody to provide you an `(R, S)` for a public key `P = p * G`,  where `S = s * G` (i.e. a signature, or a proof that you know `p` where `P = p * G`), and it would not prove anything until you pay for the scalar `s` and the prover can provide `s`, since `S` is computable from public information that anyone can have.\nSo it really depends on what you want to prove; a mere ZKCP is not always enough.\n\nRegards,\nZmnSCPxj\n\nPS I am dabbling in BTRFS now though, so ---"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-12-20T04:53:41",
                "message_text_only": "On Sat, Dec 19, 2020 at 6:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning LL,\n>\n> > > I suspect part of the proof-of-discrete-log-equivalance can be gated\n> as well by a ZKCP on payment point+scalar the proof is provided only on\n> payment.\n> > > The selling node operator does not even need to reveal `z`.\n> >\n> > Actually no -- the fact that you were able to create a secure\n> conditional payment for the proof would always prove the proof existed.\n> > You wouldn't need to pay for the proof then!\n>\n> That depends on the proof.\n>\n> For example, one pay-for-proof scheme would be somebody to provide you an\n> `(R, S)` for a public key `P = p * G`,  where `S = s * G` (i.e. a\n> signature, or a proof that you know `p` where `P = p * G`), and it would\n> not prove anything until you pay for the scalar `s` and the prover can\n> provide `s`, since `S` is computable from public information that anyone\n> can have.\n> So it really depends on what you want to prove; a mere ZKCP is not always\n> enough.\n>\n> Regards,\n> ZmnSCPxj\n>\n> PS I am dabbling in BTRFS now though, so ---\n>\n\nYou're right. I stand corrected. It is possible to construct ZKCP payments\nwhere the messages sent by the prover up until the point the prover claims\nthe payment (and reveals the witness) could have been simulated by someone\nwho doesn't know the witness. You give a good example of this. After\nthinking about your post I recalled that I used a similar argument about\nthe security of my protocol for buying an opening of a Pedersen commitment\nwith Bitcoin [1].\n\n[1]\nhttps://github.com/LLFourn/buying-pedersen-commitment/blob/master/main.pdf\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201220/d95be22b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-22T02:09:37",
                "message_text_only": "Good morning LL,\n\n> > > > I suspect part of the proof-of-discrete-log-equivalance can be gated as well by a ZKCP on payment point+scalar the proof is provided only on payment.\n> > > > The selling node operator does not even need to reveal `z`.\n> > >\n> > > Actually no -- the fact that you were able to create a secure conditional payment for the proof would always prove the proof existed.\n> > > You wouldn't need to pay for the proof then!\n> >\n> > That depends on the proof.\n> >\n> > For example, one pay-for-proof scheme would be somebody to provide you an `(R, S)` for a public key `P = p * G`,\u00a0 where `S = s * G` (i.e. a signature, or a proof that you know `p` where `P = p * G`), and it would not prove anything until you pay for the scalar `s` and the prover can provide `s`, since `S` is computable from public information that anyone can have.\n> > So it really depends on what you want to prove; a mere ZKCP is not always enough.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > PS I am dabbling in BTRFS now though, so ---\n>\n> You're right. I stand corrected. It is possible to construct ZKCP payments where the messages sent by the prover up until the point the prover claims the payment (and reveals the witness) could have been simulated by someone who doesn't know the witness. You give a good example of this. After thinking about your post I recalled that I used a similar argument about the security of my protocol for buying an opening of a Pedersen commitment with Bitcoin [1].\n>\n> [1] https://github.com/LLFourn/buying-pedersen-commitment/blob/master/main.pdf\n\nYes, but on the other hand --- as pointed out, the seller could be lying and just made up the \"other node\" in the channel.\nProof that the \"other node\" is in fact the actual \"other node\" on that channel is relatively worthless if there is no proof that the \"other node\" is at all something other than the seller.\n\nOn the other other hand --- if the buyer has additional information that the \"other node\" here is \"of interest\" (i.e. it has other data about the \"other node\" that makes it focus its attention on this \"other node\", and it suspects the seller is not a sockpuppet of the \"other node\" here) then this kind of proof just became very valuable.\n\n--\n\nAnother thought is that this approach potentially makes the LN gossip network a monolithic database that is only weakly consistent.\n\nThe Bitcoin blockchain layer is an existing monolithic database with strong consistency guarantees.\n\nBecause of weak consistency, it is possible for a node to exist in your gossip map, you make a channel to that node, then you get amnesia, then that node is no longer in your gossip map.\n\nDo we need to find ways to increase the consistency of node gossip?\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Covert channel recovery with Oblivious Signatures",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Ariel Lorenzo-Luaces",
                "David A. Harding",
                "Lloyd Fournier"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 66841
        }
    },
    {
        "title": "[Lightning-dev] Battlement: A Quorum Based Design for Lightning Network Key Management",
        "thread_messages": [
            {
                "author": "Omer Shlomovits",
                "date": "2020-12-16T07:26:10",
                "message_text_only": "Hi list, \n\nSharing here a project I started a while ago and recently managed to materialise in writing, \nIn this work I decided to take the traditional cyber security approach, while assuming channels security is sound. \nThe attacker model is intuitive: an attacker attacks a machine which happens to run a lightning node. The attacker is not part of the network. \nUsually the attacked machine/device will have security measures in place: write/read permissions for different users. Our assumption is that the attacker does not necessarily achieve full control over the node but only *some* elevated access: it may have only read or only  write access for example which means it can steal some keys while not deleting them or delete some keys while not been able to steal them.  We analyse the different scenarios and what an attacker can achieve - surprisingly it seems that due the the unique key structure and usage in lightning, it is not trivial how an attacker may profit from this situation (as opposed to bitcoin where any access to key material equal profit to an attacker). \n\nIn the second part of the work we offer a quorum based design that mitigates the attacks. We use threshold cryptography for this. I believe this is one  viable solution but for sure not the only one and we discuss the tradeoffs. One nice thing about this approach is that it allows to somewhat re-use the existing watchtowers - we basically only require that watchtowers will become connected and run some new protocols. \n\nIn the last part we present a simple bribing attack on the current watchtower design, and hand wave on how game theory shows that  a quorum structure like ours may provide a path to solving it. \n\nLink to the writeup is here: \nhttps://static1.squarespace.com/static/5f3a45dc0638305e031b7419/t/5fd877e477d7f03dcdb5b3f9/1608022219533/Battlement.pdf <https://static1.squarespace.com/static/5f3a45dc0638305e031b7419/t/5fd877e477d7f03dcdb5b3f9/1608022219533/Battlement.pdf>\n\nThe paper is written at a high level only so we will be able to focus on the several new ideas I mentioned above.  This work is thus far from complete: \nNo formal security arguments are given and I avoid describing real world considerations like fee structure and parameters . \nI think however it is a good breaking point to share it and get some feedback.\n\nAll the best, \nOmer. \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201216/f8f826e5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Battlement: A Quorum Based Design for Lightning Network Key Management",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Omer Shlomovits"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2542
        }
    },
    {
        "title": "[Lightning-dev] Trampoline routing improvements and updates",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2020-12-28T16:16:43",
                "message_text_only": "Good morning list,\n\nBefore we close this amazing year, I wanted to give you an update and reboot\nexcitement around trampoline routing for 2021.\n\nAcinq has been running a trampoline node for more than a year to provide\nsimple\nand reliable payments for tens of thousands of Phoenix [1] users. We've\nlearned\na lot and I just opened a new trampoline routing spec PR to reflect that\n[2].\n\nThe TL;DR is:\n\n* it's simpler than the previous proposal and more flexible\n* it makes MPP more cost-efficient and reliable\n* it works nicely with rendezvous or route blinding\n* it's as private as normal payments (likely more private) if used properly\n(details in the PR)\n\nI strongly believe the current state of trampoline routing can provide great\nbenefits in terms of wallet UX and reliability, but we need more reviews for\nthe spec to converge before it can be broadly deployed without fear of\nmoving\nparts or breaking changes. Please have a look at the proposal without\npreconceived ideas; you may be surprised by how simple and natural it feels.\n\nI also want to stress that the code changes are very reasonable as it\nre-uses\na lot of components that are already part of every lightning implementation\nand\ndoesn't introduce new assumptions.\n\nAs a matter of fact, an independent implementation has been completed by the\nElectrum team and has been recently tested E2E on mainnet! Having a spec\nagreement on feature bits, invoice hints format and onion error codes would\nallow their wallet to fully interoperate with Phoenix and future trampoline\nwallets, as well as unblock development of even more improvements.\n\nHappy end of year to all and stay #reckless in 2021!\n\nBastien\n\n[1] https://phoenix.acinq.co/\n[2] https://github.com/lightningnetwork/lightning-rfc/pull/829\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20201228/3e357e16/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Trampoline routing improvements and updates",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1940
        }
    }
]