[
    {
        "title": "[Lightning-dev] Section 7 Query: Timestamps & Pruning",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2017-12-04T23:30:05",
                "message_text_only": "Shannon Appelcline <shannona at skotos.net> writes:\n> Section 7 says \"nodes MAY prune channels should the timestamp of the \n> latest `channel_update` be older than 2 weeks (1209600 seconds)\"\n>\n> Yet timestamps are only required to be sequential, not an actual \n> timestamp (\"The creating node MUST set `timestamp` to be greater than \n> that for any previous `node_announcement` it has created. It MAY base it \n> on a UNIX timestamp.\", so there's no way to know the age of a timestamp, \n> at least not by looking at the timestamp.\n\n(lightning-dev CC'd)\n\nIndeed.  The original timestamp field was left undefined, but this\naddition implies it has to be epoch time.\n\nI prefer it to say \"MAY prune channels which have not had a new\n`channel_update` for 2 weeks or more\", but that implies that\nimplementations must keep their own internal timestamp of when they see\nthe update.\n\nBut we should fix it one way or another; I've opened a bug:\n\nhttps://github.com/lightningnetwork/lightning-rfc/issues/302\n\nThanks,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Section 7 Query: Timestamps & Pruning",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1010
        }
    },
    {
        "title": "[Lightning-dev] Directionality of the transaction fees",
        "thread_messages": [
            {
                "author": "Edziu Marynarz",
                "date": "2017-12-06T11:04:34",
                "message_text_only": "I tried to find this information in the BOLT documents but I couldn't find\nit. Is it possible to set up the channel so that the fee depends on the\ndirection, i.e. a different fee on the receive direction and different on\nthe send one? Why such functionality?\n\nImagine that you start with a bidirectional channel to Alice and a channel\nto Bob with 1000 satoshi each. For some reasons, the network routes most of\nthe transactions from Alice to you and then to Bob and you end up with 1900\nsatoshi in the Alice channel and only 100 satoshi in the Bob one. The route\nwill stop working and if there is little traffic in the other direction you\nwill have to close the channels to rebalance them or wait a very long time\nfor the rebalancing.\n\nIf the fee could depend on the direction, one could start to ramp up fees\non the receiving end of the channel that is getting large and lower the one\nthat is empty to prevent the imbalance.\n\nThere is also a risk factor involved. The lightning network channels get\nriskier on the receive side the more the channel value deviates from the\noriginal state since the counterparty may try to broadcast the old state so\nyou may want to regulate this imbalance with fees. It would be best if the\nLN applications could do it automatically.\n\nRegards,\n\nEdward\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171206/e083f092/attachment.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2017-12-07T09:13:19",
                "message_text_only": "Hi, Edward! Welcome to the mailing list :)\nThe fees can indeed be set for each direction of the channel, check out https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#the-channel_update-message [https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#the-channel_update-message]\nBasically each node in the channel can announce the fee til will take to route a payment in the direction leading \u201caway\u201d from it. We also have something called \u201cchannel reserves\u201d ensuring that each node always has some balance at stake in case an old state is broadcast.\nCheers! Johan\n\nOn Wed, Dec 6, 2017 at 12:04, Edziu Marynarz <edziumarynarz at gmail.com> wrote:\nI tried to find this information in the BOLT documents but I couldn't find it. Is it possible to set up the channel so that the fee depends on the direction, i.e. a different fee on the receive direction and different on the send one? Why such functionality?\nImagine that you start with a bidirectional channel to Alice and a channel to Bob with 1000 satoshi each. For some reasons, the network routes most of the transactions from Alice to you and then to Bob and you end up with 1900 satoshi in the Alice channel and only 100 satoshi in the Bob one. The route will stop working and if there is little traffic in the other direction you will have to close the channels to rebalance them or wait a very long time for the rebalancing.\nIf the fee could depend on the direction, one could start to ramp up fees on the receiving end of the channel that is getting large and lower the one that is empty to prevent the imbalance.\nThere is also a risk factor involved. The lightning network channels get riskier on the receive side the more the channel value deviates from the original state since the counterparty may try to broadcast the old state so you may want to regulate this imbalance with fees. It would be best if the LN applications could do it automatically.\nRegards,\nEdward\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171207/df6d2847/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-10T23:15:52",
                "message_text_only": "Johan Tor\u00e5s Halseth <johanth at gmail.com> writes:\n> Hi, Edward! Welcome to the mailing list :)\n> The fees can indeed be set for each direction of the channel, check out https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#the-channel_update-message [https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#the-channel_update-message]\n\nIndeed; just to confirm, after the initial mutual channel_announce\nmessage, each peer sends its own channel_update; this means you control\nyour own fees.\n\nIn particular, fees are charged on entry to the channel, so if there's\nan A->B channel, A charges the fee.  If you traverse B->C, B charges the\nfee, etc.\n\nHope that clarifies,\nRusty."
            },
            {
                "author": "Edward Marynarz",
                "date": "2017-12-11T20:13:13",
                "message_text_only": "On Mon, Dec 11, 2017 at 12:15 AM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n>\n> In particular, fees are charged on entry to the channel, so if there's\n> an A->B channel, A charges the fee.  If you traverse B->C, B charges the\n> fee, etc.\n>\n\nThank you for your explanations.\n\nIt's good, though not as good as if both sender and recipient could set\ntheir own fees.  I know it would have made everything more complicated but\nreceiving is actually more costly than sending. If you have less balance\nthan the initial opening of the channel, it is risk-free. But if you have\nmore than the initial state, you have to monitor if there are no old states\npublished.\n\nAnother trivial question: can the fee be negative? It might help with some\nchannel rebalancing.\n\nI tried to get the information from BOLT #3 but BOLT's are very hard to\nread if you are not an expert. Who pays for the closing of the channel? Is\nit the person who initiates the closing? Since opening and closing fees are\nprobably going to be larger than lifetime channel fees, it is much more\nimportant than the LN fees. I worry about a scenario that I create a\nchannel (paying fees), send some funds through the channel to have the\nchannel available also for receiving and the other side of the channel,\nsimply cashes out the balance, and I'm without the channel  opening fees\nand with no receiving channel.\n\nBest,\n\nEdward\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171211/bb34c289/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-12T01:25:47",
                "message_text_only": "Edward Marynarz <edziumarynarz at gmail.com> writes:\n> On Mon, Dec 11, 2017 at 12:15 AM, Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n>\n>>\n>> In particular, fees are charged on entry to the channel, so if there's\n>> an A->B channel, A charges the fee.  If you traverse B->C, B charges the\n>> fee, etc.\n>>\n>\n> Thank you for your explanations.\n>\n> It's good, though not as good as if both sender and recipient could set\n> their own fees.  I know it would have made everything more complicated but\n> receiving is actually more costly than sending. If you have less balance\n> than the initial opening of the channel, it is risk-free.\n\nBut forwarding nodes do both, so they can charge appropriate fees.\n\n> Another trivial question: can the fee be negative? It might help with some\n> channel rebalancing.\n\nIn my original implementation, they could be.  However, that turns out\nto be a very strange idea, and complicates routing.\n\n> I tried to get the information from BOLT #3 but BOLT's are very hard to\n> read if you are not an expert. Who pays for the closing of the channel? Is\n> it the person who initiates the closing? Since opening and closing fees are\n> probably going to be larger than lifetime channel fees, it is much more\n> important than the LN fees. I worry about a scenario that I create a\n> channel (paying fees), send some funds through the channel to have the\n> channel available also for receiving and the other side of the channel,\n> simply cashes out the balance, and I'm without the channel  opening fees\n> and with no receiving channel.\n\nThe channel initiator pays all onchain fees, at the moment.  This is\nsimple, but potentially gamable.  However, current alternatives are\ncomplex and potentially gamable, so we went with simple.\n\nCheers,\nRusty."
            },
            {
                "author": "Edward Marynarz",
                "date": "2017-12-22T06:37:37",
                "message_text_only": "On Tue, Dec 12, 2017 at 2:25 AM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n\n> > It's good, though not as good as if both sender and recipient could set\n> > their own fees.  I know it would have made everything more complicated\n> but\n> > receiving is actually more costly than sending. If you have less balance\n> > than the initial opening of the channel, it is risk-free.\n>\n> But forwarding nodes do both, so they can charge appropriate fees.\n\n\nIf there is only one path, then yes. But with many paths, you cannot\nrestrict the path you do not want to receive with.\n\n\n>\n> > Another trivial question: can the fee be negative? It might help with\n> some\n> > channel rebalancing.\n>\n> In my original implementation, they could be.  However, that turns out\n> to be a very strange idea, and complicates routing.\n>\n> Interesting.\n\n  > important than the LN fees. I worry about a scenario that I create a\n\n> > channel (paying fees), send some funds through the channel to have the\n> > channel available also for receiving and the other side of the channel,\n> > simply cashes out the balance, and I'm without the channel  opening fees\n> > and with no receiving channel.\n>\n> The channel initiator pays all onchain fees, at the moment.  This is\n> simple, but potentially gamable.  However, current alternatives are\n> complex and potentially gamable, so we went with simple.\n>\n>\nSo the only thing that protect a small-scale user from a hub that closes\nthe channels with some balance fee-free is a)  market pressure by avoiding\nthe hubs that do it b) that Bitcoin is actually more expensive to receive\nthan to send since inputs are larger than outputs?\n\nIt should indeed work now but with Schnorr signatures, b) i no longer the\ncase  and we would only rely on a). And market pressure may be a too weak\nincentive because it requires knowledge that hubs behave in a certain way.\nAnd this information may be difficult to obtain,\n\nRegards,\n\nEdward\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171222/73eb8e90/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Directionality of the transaction fees",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Edward Marynarz",
                "Edziu Marynarz",
                "Johan Tor\u00e5s Halseth"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 9826
        }
    },
    {
        "title": "[Lightning-dev] LN public marketplaces (exchanges)",
        "thread_messages": [
            {
                "author": "U.Mutlu",
                "date": "2017-12-09T18:49:03",
                "message_text_only": "Hi,\n\nwould LN allow the creation of marketplace(s) (ie. echanges)\nwhere users can offer to overtake quasi-instantly the\npayment obligation of someone else, for a little income\nfrom the transaction fees?\n\nIe. then the regular network (bitcoin etc.) would optionally\nfirst look whether there is an intermediary available in the \"orderbook\"\nof the exchange that is willing to instantly overtake the payer's\nobligation, and if yes then this transaction would be dealt by LN...\n\nBy this, the helping users (intermediary settlers, credit-givers)\nwould have a little income stream by helping with their own funds,\nand w/o risking their funds.\n\nI think many users would like such an idea for a small income,\nand many such exchanges would open. They would announce their\nservice on the underlying network(s).\n\nIf such an exhange goes down then it shall have\nno negative consequences for the participants.\n\nCan such an infrastructure be built on top of LN?\n\nThx"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-11T10:59:41",
                "message_text_only": "Not sure I fully understand the use-case you are referring to. Is this\nsupposed to be a short-term loan to get a bill paid or is this supposed\nto facilitate muli-hop payments? In the former case there is no support\nfor it yet, since all of the payments in LN are always fully backed by\nBitcoin. In the latter case, I don't see how that differs from the\nmulti-hop payments we already do.\n\nCheers,\nChristian\n\n\"U.Mutlu\" <um4711 at mutluit.com> writes:\n\n> Hi,\n>\n> would LN allow the creation of marketplace(s) (ie. echanges)\n> where users can offer to overtake quasi-instantly the\n> payment obligation of someone else, for a little income\n> from the transaction fees?\n>\n> Ie. then the regular network (bitcoin etc.) would optionally\n> first look whether there is an intermediary available in the \"orderbook\"\n> of the exchange that is willing to instantly overtake the payer's\n> obligation, and if yes then this transaction would be dealt by LN...\n>\n> By this, the helping users (intermediary settlers, credit-givers)\n> would have a little income stream by helping with their own funds,\n> and w/o risking their funds.\n>\n> I think many users would like such an idea for a small income,\n> and many such exchanges would open. They would announce their\n> service on the underlying network(s).\n>\n> If such an exhange goes down then it shall have\n> no negative consequences for the participants.\n>\n> Can such an infrastructure be built on top of LN?\n>\n> Thx\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "U.Mutlu",
                "date": "2017-12-11T23:08:17",
                "message_text_only": "Christian Decker wrote on 12/11/2017 11:59 AM:\n> Not sure I fully understand the use-case you are referring to. Is this\n> supposed to be a short-term loan to get a bill paid or is this supposed\n> to facilitate muli-hop payments? In the former case there is no support\n> for it yet, since all of the payments in LN are always fully backed by\n> Bitcoin. In the latter case, I don't see how that differs from the\n> multi-hop payments we already do.\n\nI must admit I'm new to LN and don't know yet if it can be used\nin setting up such a scenario:\n\nA bitcoin transaction usually takes at least 10 minutes for confirmation.\nAn instant payment could be realised if a middleman pays out the amount\nto the receiver immediately, and gets his money back from the original\nsender the normal way (ie. waiting the 10+ minutes).\n\nThe middlemen (ie. other users) would announce their such service at\na marketplace (the highest amount he/she is willing to overtake plus\nthe fees he/she wants). With each transaction, Bitcoin would pick\nthe best offer from the orderbook of the maketplace and process the\ntransaction that way (ie. swapping the receiver by the middleman).\n\nThe advantages: the receiver gets the money instantly,\nand any user can play middleman (hence an exchange for it),\nthe middlemen earn from the fees, exchanges get established, ...\n\nJust an idea..."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-13T01:19:00",
                "message_text_only": "Good Morning,\n\nMy understanding of your idea is the below:\n\n1.  I set up as a middleman from the base blockchain to the LN.\n2.  You send me an onchain transaction plus a fee and after 0 confirmations (!! risk) I send to the recipient on LN.\n\nBut please consider that you could run an LN node yourself, open a channel (and spend any fees you might have paid to me in the channel opening) and then sent to the recipient on LN yourself.  Further, you can afterwards make future payments to LN for low fees yourself, without having to make a new onchain transaction each time.  So I see no benefit to you using this service.\n\nRegards,\nZmnSCPxj\n\n-------- Original Message --------\nSubject: Re: [Lightning-dev] LN public marketplaces (exchanges)\nLocal Time: December 12, 2017 7:08 AM\nUTC Time: December 11, 2017 11:08 PM\nFrom: um4711 at mutluit.com\nTo: lightning-dev at lists.linuxfoundation.org\n\nChristian Decker wrote on 12/11/2017 11:59 AM:\nNot sure I fully understand the use-case you are referring to. Is this\nsupposed to be a short-term loan to get a bill paid or is this supposed\nto facilitate muli-hop payments? In the former case there is no support\nfor it yet, since all of the payments in LN are always fully backed by\nBitcoin. In the latter case, I don't see how that differs from the\nmulti-hop payments we already do.\n\nI must admit I'm new to LN and don't know yet if it can be used\nin setting up such a scenario:\n\nA bitcoin transaction usually takes at least 10 minutes for confirmation.\nAn instant payment could be realised if a middleman pays out the amount\nto the receiver immediately, and gets his money back from the original\nsender the normal way (ie. waiting the 10+ minutes).\n\nThe middlemen (ie. other users) would announce their such service at\na marketplace (the highest amount he/she is willing to overtake plus\nthe fees he/she wants). With each transaction, Bitcoin would pick\nthe best offer from the orderbook of the maketplace and process the\ntransaction that way (ie. swapping the receiver by the middleman).\n\nThe advantages: the receiver gets the money instantly,\nand any user can play middleman (hence an exchange for it),\nthe middlemen earn from the fees, exchanges get established, ...\n\nJust an idea...\n\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/ea69fedd/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "LN public marketplaces (exchanges)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "U.Mutlu",
                "Christian Decker"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 6490
        }
    },
    {
        "title": "[Lightning-dev] Comments on BOLT#11",
        "thread_messages": [
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-10T11:37:04",
                "message_text_only": "Hello all,\n\nRecently I have implemented BOLT11 in node JS. You can find it on github at\nbitcoinjs/bolt11 (check the wip branch, I am still working on tests and\nlooking at maybe splitting encode up into two functions, encode and sign,\nif anyone wants to help)\n\nHere are some comments:\n\n1. There should be a tags_length integer before the first tag. This will\nget rid of the awkward dance of parsing from the front and end at the same\ntime and make it easier to detect poorly encoded data quickly.\n2. Why is a description or description commit hash a MUST include tag... it\nshould be SHOULD.\n3. Descriptions say they can encode ASCII only. Sorry, but this is\nnonsense. Full unicode support via UTF8 should be supported.\n4. There should be a maximum length (in bytes) for description. (Otherwise\nwhy have a commit hash tag at all?)\n5. There should be a recommendation for ways for the parsing client to\nfetch the commited purpose description data. (Maybe encode a URL after the\n32 byte commit hash?)\n6. Lightning payment requests can get pretty long, but perhaps there should\nbe a limit. Apparently bech32 with the given parameters can only handle one\nerror correction once it is longer than 1023 words.\n\n\nNow for some things on the BOLT document itself:\n\n1. I made a pull request for adding signature preimage hex data etc. to the\nexamples to help people writing decoders. Some of the language was unclear\nto me and lead to some goof ups.\n2. Would be nice to have a fuller set of test cases on the RFC. I will work\non some cases to increase coverage on the bitcoinjs repo. Would be happy\nfor any help.\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u6280\u8853\u9867\u554f\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nmQENBFTSV/kBB/9FyhUaxI/2bfJ0pBp+y6YAim4LyOXeFDdtZL2C04T2eWBB+n2H\nXD3r9CIifdqefnc0VCKwPe2hpbGXKNVy33tnp3m76CPVwKvIooE/gCcILJUIKwbd\nj1ydsuUiErOhuRaral+iDhEaWuZmSZc1SiBANcufQvTru6o3Ne1MhozenpFHdyUX\nL4zIgifglEKRRsQiqxpF8vyIo/A7u5bDZQPq1HAc9vL13Oe05ZhgXDMp0sgTfHVo\nnd6gNSJxWb7PqDLunY+kvINawqePEADkAJlvcZbXpc07RuX8+/FSRI0LPmZin6w0\nDuvzRAYAE/f1/OcqabWTIXbcmG3F32OmPS4PABEBAAG0MUpvbmF0aGFuIFVuZGVy\nd29vZCA8anVuZGVyd29vZEBiaXRjb2luYmFuay5jby5qcD6JATIEEAEIACYFAlTS\nV/0GCwkIBwMCCRCpJzta0+R7RQQVCAIKAxYCAQIbAwIeAQAAQXgH/jZh+WLLxx4S\nznw5o53nROMn+WChasZ1cOoFzfAXRpFC5UZTXyTS1fMsA1vMA21B88FX/+UCxvCB\n3EHN6MrUIinc8SFh/oZX/041dwfFOFaN2LsWJ5xF9pZpRdz4e+Bzbfyhe7MC/7d7\nKsfwyiEWgPbH8N869SWdQqu8WIH9hIDyyWU4rNx9Un440lZJhN79Z58vaw1q3FRq\n8qy+hKkMU7vi6PYq/D4WPrztfguqHe3vmtmlWaC8WGvy+AG7KEzinkc7VeIXdFtu\nLV70t3L9GyAVNPM+RVxi/nDhQ2FW9tYA0jJ0VYpRltkrMHTvlnP+VRqb/qbvss0g\nhaD3C7bizCmJAS8EEAEIACMFAlTSV/0JEKknO1rT5HtFAhsDBgsJCAcDAgQVCAIK\nAxYCAQAAj7IH/0Wip1XPxYO/VvEd7Q8wvyHUNfcX5EvVtRHvLzmeTMOsVjX2FQ/k\n7Mi8JWrPMBYIAhqrO9TymaNk+O1FeP9j1VbEBtAviSrmMxeP97VbzuU53i3Fi0+i\nHhGE432YEfeqJ6tUcPZQBa2RiASZ3CXNoWSdymy+gGWG8bnNU5HVStrpz0tMH2ur\nmPTVhQAiTcBweRJYbUuyJyByre6JrDph9LjU8zELcncFmNwFvYaRWI9sKnqgYRx8\nw+O/lDOmBkeDxtlyYZu3aRt82Ii7FH9Oca2NOr7AQDHda738Vb2Y8ZV6bCznk+fQ\nfu2cWpYb721+srVEljabIjIJeIKlTrEhfDq0NUpvbmF0aGFuIFVuZGVyd29vZCA8\nanVuZGVyd29vZEBibG9ja2NoYWluZGFpZ2Fra28uanA+iQE3BBMBCgAhBQJZShSg\nAhsDBQsJCAcDBRUKCQgLBRYCAwEAAh4BAheAAAoJEKknO1rT5HtFO0oH/ju1XB75\nP31SS5PfmzdARRjjj08JnaKeiOv5bXJwaDdhDpeaRVovk1gwObr5mHiIjkzuWNBc\n9bunUGWpyuRbZm8oV4lY0hnfKsS6oVSav/qtr6UCQyWsvt/gkTwdx3YcHEQv3iFv\n8LhUlGVRZY60gR6+S0bq03+vFfdrnQlvof7TC0F46SBCIZRud4vdKyxqXKKZz4z2\nB0Al7BiDaAfz3wk820JzUFZV75VSFHZaSQL0ivbhA+Okskte/iI10w3fM+d/0gvh\nYAY1l+ymoaAvutPbfNMM2Nx/m3LV1RrLZ/pKWG96HokhP8vldodnLTAaW2vFa0Wu\nX0L3ScuGirCq2Fi5AQ0EVNJX/QEH/2LRn75y2UIPVVd9Og6gT6Hfwh6CK2PcmjRz\nmGtY0ZU1wu/07CpAk3SP+5jm/o9FSVU46tE7d/VPw1gxj2vLryzsE8ticnUYtOVG\nzCgFmZgzcj+E8HNGLo5BiNaVqFVc1sf/bf3bGytVFWRsPoJmNgLTvwtJOZNXtOD/\n3IAAdiFRifeKDvElMlNhNNYOFncr+O16pnyesmQpg95nVbvww4t8QUjy5c2pg+9W\n1ZLzlEY2GC8bsvhrQsikycyV/pRqzDJo3D+DPLlEB4xASmHnJh6vw0OgVieAt1Cc\nWyzPZQRcEBUQ9TVemvoQ+CBeVEAlivXXHyGu4OPV9miV66G2WTkAEQEAAYkBJQQY\nAQgADwIbDAUCWUIeCQUJCDItDAAKCRCpJzta0+R7RX31B/oD7QxOhrWcKXLSyygb\nh5cEAzKOWkg1D3KWpWPfTjUH2w2SfIJAzCxRvxMmiOmRpOxFzmyDYRocBq71GYkt\nivJMfhxL/P93yQqcptWTAX5eUWyU0OG1MZ6sb64U62r5fmQg6QBD+/q+Gm98ytiL\nUdRl5+YnTz6MhjFUK23rPxR2798RWimJo4Iz++8OZOHCrGO/2w59FiGfNF1iCMuP\nbDV+7kq0qr0YzHIvGp3pdhQfF71xdbTEA3GxDCGHeVsKvsDgPtQo17HwBEnrSKJM\nbhAtlgfqhSuZBCY2SVnX0abnpCiV/ULsZyUWj7nTscuX824pfyhE9Dy39EQWN5Z3\nU8A7uQENBFlCHcMBCADvzo44svewnR+sQcBGqFo7dsir2RePRpKKk0vZn02PDvuT\nqU1fspi6cZs8I8u10pt9L+CygVnqeema7k8UBNy+4UWT1ccBK45VKdIUCQxilRtV\nGEG+bdv1ORkhE+do5jyeFV7cFLUhyO/aF+GnMgbtzuPRdR9+XV7P0J63aX3Xh5VG\nXgsKNDJ3f/S2y718kyfytbtSIWXs0tR/drhGkWslP/9tjoup1wqCplPowse9932J\nxa8jicbF/iNtIaKjXgK0Ue9aGFoggEg47iEGhc9nZ6LGIpOQS7B8PZVr1lQjje0h\nFV574SS1NsAKf9q+DeUYc1jlys2KTv2DmFhfn5s3ABEBAAGJAkQEGAEIAA8CGwIF\nAllCHgkFCQPCZ0YBKcBdIAQZAQgABgUCWUIdwwAKCRCyVhhdOpcZCLz1CAC13GDK\nsesD922i6O9iG1XJpX+i8pFbtsXUE1eh4kmg1o+mMh6n9afWNPoXrgzgX8m4LwNU\nWM+t2LoJQEPjIIoy6a3C3ekxvfFU0vT3DDnPrbnnsAFvnW2qIu1UqQanqT6k9Tws\niMYR+eEC5zOkNFYTzk5/4+uhAasm8PZ+DOKxD8pJk50pAu71huduBTFDT0CjGxpD\nqw28Okuu79fZ6zF44A4epSg2nbslMRFNyVEKN6seSvTHKL52gtFZezjKaL7bZeni\n7Vr8hU7xPO8xVlsBXZPRiogk0rqdb2q2z+X7R5ZJDwo6fwWXLZCTRImoavf+nDls\ndtbSu17+ORn+7EN1CRCpJzta0+R7Rf4jB/sHT/FX5h7XR4rET39HRTdXd9ANoc8G\nrKZil1kIqqafih8d0Jn8JGi7L2G10TwF2za1QL/bZfSq5fC9A/C+tyXvOkR2ZgOf\nqDLacu7SAw4KiHImYD7MjPvQd4FFX7RaqNoTDmkoE+ss0YqkhViudGfXoI/YCWJv\nVUVo0R57cbLRWlt7PZYUcKUYgS4EalxGvv9lzPXOFE5jpeIgCB6LOjN7Ak05gCIo\n+EFOxvfUgb1o3wOtF7nfzTv6kygPX3EdDhLQRUel2pvYPooMnbHRyZ74NLs1B4Lv\nfNUwHfPpdwu41B168qPlqj67NagQawJFZHfq1O8lwXEGNnmNx4K7ZaAG\n=c+/G\n-----END PGP PUBLIC KEY BLOCK-----\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171210/b337d63b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-11T11:10:10",
                "message_text_only": "Good morning Jonathan,\n\n>3. Descriptions say they can encode ASCII only. Sorry, but this is nonsense. Full unicode support via UTF8 should be supported.\n\nI generally agree, but caution must be warned here.  In particular, we should be precise, which variant of UTF8.\n\nPresumably, a naive implementation, that specially treats 0 bytes (as would happen if the implementation were naively written in C or C++, where by default, strings are terminated by a 0 byte), should work correctly without having to particularly care, if the encoding is UTF8 or plain 7-bit ASCII.  This then leads to the use of so-called Modified UTF8 as used by Java in its native interface: embedded null characters are encoded as extralong 3-byte UTF8 sequences, which are normally invalid in UTF8, but which naive treatment by C and C++ leads to (mostly) correct behavior.  Should we use Modifed UTF8 or simply disallow null characters? (Use of ASCII does not avoid this, but ASCII has no alternative to null characters and the standard C string terminating byte 0).\n\nIn addition, pulling in UTF8 brings in the issue, of Unicode normalization.  Multiple different byte-sequences in UTF8 may lead to the same sequence of human-readable glyphs. Specifying ASCII avoids this issue.  Should we specify some Unicode normalization, and should GUI at least try to impose this Unicode normalization (even if backends/daemons simply ignore the description and hence any normalization issues)?\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171211/ee0b6923/attachment.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-11T12:17:19",
                "message_text_only": "ZmnSCPxj,\n\nThanks for the reply.\n\n1. I agree that all naive implementations that do not follow UTF-8 spec\nshould perhaps be mentioned, to help people avoid mojibake corruption.\nHowever, this problem is a problem as old as the internet itself (there are\nstill Japanese websites in shift-JIS encoding) and I think the consensus is\nthat UTF-8 is the standard. Allowing it in the description is fine as long\nas the readers can decode the naive UTF-8 data correctly.\n\n2. Normalization is only an issue when you need to hash something or\ncompare hash data so it is not an issue for the description, where the goal\nis to relay information to the user.\n(so maybe it could become an issue for the 256 bit description of purpose\nof payment (SHA256) but not for the simple description)\n\n\nIn regards to the purpose commit hash, seeing as there is no specified way\nto relay the data for the purpose commit hash, you could just solve it by\nspecifying the data to be fetched from a URL and having the data encoded as\na binary-stream with the exact bytes that were hashed and the UTF-8 parser\non the receiving app will just display it to the user. (since the goal is\nto display info to the user, it doesn't matter if the word is using one\nbyte combination or the other, as long as you can verify the commit hash\nmatches the hash of the data and you then can display the data to the user)\n\nProtocols like BIP39 require normalization because when a user inputs data,\nthey could be using any millions of IMEs that might use different unicode\ncodepoints to represent the same data as other IMEs... and we need to\nensure that the same human readable phrase ALWAYS is the same hash or else\nmoney is lost (or hard to get to)\n\nFor description: \"OMG I LOST 100 BTC BECAUSE THE DESCRIPTION SAID \u304c instead\nof \u304b\u3099 !!!\" will never happen.\n\nI would love to hear your thoughts on other aspects as well.\n\nThanks,\nJon\n\n2017-12-11 20:10 GMT+09:00 ZmnSCPxj <ZmnSCPxj at protonmail.com>:\n\n> Good morning Jonathan,\n>\n> >3. Descriptions say they can encode ASCII only. Sorry, but this is\n> nonsense. Full unicode support via UTF8 should be supported.\n>\n> I generally agree, but caution must be warned here.  In particular, we\n> should be precise, which variant of UTF8.\n>\n> Presumably, a naive implementation, that specially treats 0 bytes (as\n> would happen if the implementation were naively written in C or C++, where\n> by default, strings are terminated by a 0 byte), should work correctly\n> without having to particularly care, if the encoding is UTF8 or plain 7-bit\n> ASCII.  This then leads to the use of so-called Modified UTF8 as used by\n> Java in its native interface: embedded null characters are encoded as\n> extralong 3-byte UTF8 sequences, which are normally invalid in UTF8, but\n> which naive treatment by C and C++ leads to (mostly) correct behavior.\n> Should we use Modifed UTF8 or simply disallow null characters? (Use of\n> ASCII does not avoid this, but ASCII has no alternative to null characters\n> and the standard C string terminating byte 0).\n>\n> In addition, pulling in UTF8 brings in the issue, of Unicode\n> normalization.  Multiple different byte-sequences in UTF8 may lead to the\n> same sequence of human-readable glyphs. Specifying ASCII avoids this\n> issue.  Should we specify some Unicode normalization, and should GUI at\n> least try to impose this Unicode normalization (even if backends/daemons\n> simply ignore the description and hence any normalization issues)?\n>\n> Regards,\n> ZmnSCPxj\n>\n\n\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171211/9da04785/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-12T01:18:10",
                "message_text_only": "Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n> Hello all,\n>\n> Recently I have implemented BOLT11 in node JS. You can find it on github at\n> bitcoinjs/bolt11 (check the wip branch, I am still working on tests and\n> looking at maybe splitting encode up into two functions, encode and sign,\n> if anyone wants to help)\n\nHi, this is great!\n\n> Here are some comments:\n>\n> 1. There should be a tags_length integer before the first tag. This will\n> get rid of the awkward dance of parsing from the front and end at the same\n> time and make it easier to detect poorly encoded data quickly.\n\nI'm not sure what you're referring to?  I've written two decoders, and\nboth pull off the header and fixed fields, then iterate\nwhile (data_len > 520 / 5).\n\n> 2. Why is a description or description commit hash a MUST include tag... it\n> should be SHOULD.\n\nI disagree.  Obviously we can't force people to be descriptive (that's a\nSHOULD), but not including a description of the purpose of the payment\nis a mistake.\n\nThe invoice and the preimage provides a cryptographic proof of\npurchase.  But that's undermined if the description is missing.\n\n> 3. Descriptions say they can encode ASCII only. Sorry, but this is\n> nonsense. Full unicode support via UTF8 should be supported.\n\n>From the ML welcome: \"Be excellent to each other please!\"\n\nI understand this mistake upset you, but \"Sorry, but this is nonsense\"\nmakes me want to find spurious justifications for it.  I prefer \"This\nseems unfairly limiting\", \"This is a mistake\" or \"Woah, time to go 8\nbits, granddad!\".\n\nThe problem is the spec describes the 'd' field like so:\n\n        short description of purpose of payment (ASCII),  e.g. '1 cup of coffee'\n\nThere's nothing in the *requirements* section, at all.\n\nSo, I think we should:\n\n1.  s/ASCII/UTF-8/\n    - It seems everyone handles this fine anyway.\n2.  Add another example, here, which is in UTF-8, say \"or '\u30ca\u30f3\u30bb\u30f3\u30b9\u306e\u30ab\u30c3\u30d7'\" :)\n3.  Add a requirement that the writer MUST use valid UTF-8.\n4.  Modify one of the examples to use a UTF-8 description.\n\n> 4. There should be a maximum length (in bytes) for description. (Otherwise\n> why have a commit hash tag at all?)\n\nThere is; no field can be greater than 640 bytes (1023 5-bit values).\nAlso, the transport might have practical limits, so you might need to\nconsider that in total.  (Maybe not though, if you're going for QR\ncodes, as they go pretty large).\n\n> 5. There should be a recommendation for ways for the parsing client to\n> fetch the commited purpose description data. (Maybe encode a URL after the\n> 32 byte commit hash?)\n\nYes there should, but we left it open for the moment because there's no\ngood solution here, and someone needs to come up with one.  This makes\ndescription hash fairly useless for now, IMHO.\n\nA URL is the obvious solution, but has the terrible property that it\nde-anonymizes the wallet :( (even before the person has decided whether\nthey want to pay).\n\nFWIW, there are a range of possible solutions, depending on the scenario:\n1. If you have some container format, eg. HTML, include the description as a\n   separate tag.\n2. Roasbeef wants to implement HORNET over our network, and that could\n   be used to retrieve the full description.\n\nMeanwhile, 640 bytes should be enough for anyone!\n\n> 6. Lightning payment requests can get pretty long, but perhaps there should\n> be a limit. Apparently bech32 with the given parameters can only handle one\n> error correction once it is longer than 1023 words.\n\nActually I think bech32 loses all guarantees at 1023 words, but it's no\nworse than a 30-bit checksum.  We mainly use it because it's simple and\navailable, and of course any fixed-length code will have some limit.\n\nWhat actually happens if we decode badly is that we derive the wrong\npublic key for the node (50% chance, other 50% we get a signature\nfailure) and we can't route to it or pay to it.  So no funds are\nactually lost.\n\n> Now for some things on the BOLT document itself:\n>\n> 1. I made a pull request for adding signature preimage hex data etc. to the\n> examples to help people writing decoders. Some of the language was unclear\n> to me and lead to some goof ups.\n\nYes, this was *awesome*; I double-checked the values by hacking my\npython encoder, and adjusted for the recent r-encoding change.  It's\nmerged, thanks!\n\n        https://github.com/lightningnetwork/lightning-rfc/pull/312\n\n> 2. Would be nice to have a fuller set of test cases on the RFC. I will work\n> on some cases to increase coverage on the bitcoinjs repo. Would be happy\n> for any help.\n\nThat would be fantastic!  We've talked about changing the test vectors\n(for all the BOLTs) into a more machine-friendly JSON encoding, so if\nyou're feeling ambitious you could start with BOLT 11 :)\n\nThanks!\nRusty."
            },
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-12T02:18:50",
                "message_text_only": "Rusty,\n\n> I'm not sure what you're referring to?  I've written two decoders, and\n> both pull off the header and fixed fields, then iterate\n> while (data_len > 520 / 5).\n\n\nWhat happens if the signature is missing or the signature is improperly\nformatted?\nIt is much easier to detect a case like that at the beginning if we have:\n  1. read 7 words for timestamp\n  2. read 3 words for tags_total_length\n  3. read tags_total_length words for the tags data\n  4. read 104 words for signature and recoveryID\nThen immediately you can tell \"oh, the signature is an invalid length\"\nrather than\nhaving to decide whether \"is the signature malformed or is the last tag\nmalformed?\nif I run out of words while parsing a tag, is it because I just happened\nupon a rare\ncase where I am parsing the signature as tags and the word just happened to\nbe a valid tag?\"\n\nI just think it should be explicit to help prevent problems\n\n\n> I disagree.  Obviously we can't force people to be descriptive (that's a\n> SHOULD), but not including a description of the purpose of the payment\n> is a mistake.\n>\n> The invoice and the preimage provides a cryptographic proof of\n> purchase.  But that's undermined if the description is missing.\n\n\nI disagree, but this is not a huge issue so I withdraw my comment.\n\n\n> From the ML welcome: \"Be excellent to each other please!\"\n>\n> I understand this mistake upset you, but \"Sorry, but this is nonsense\"\n> makes me want to find spurious justifications for it.  I prefer \"This\n> seems unfairly limiting\", \"This is a mistake\" or \"Woah, time to go 8\n> bits, granddad!\".\n>\n> The problem is the spec describes the 'd' field like so:\n>\n>         short description of purpose of payment (ASCII),  e.g. '1 cup of\ncoffee'\n>\n> There's nothing in the *requirements* section, at all.\n>\n> So, I think we should:\n>\n> 1.  s/ASCII/UTF-8/\n>     - It seems everyone handles this fine anyway.\n> 2.  Add another example, here, which is in UTF-8, say \"or '\u30ca\u30f3\u30bb\u30f3\u30b9\u306e\u30ab\u30c3\u30d7'\" :)\n> 3.  Add a requirement that the writer MUST use valid UTF-8.\n> 4.  Modify one of the examples to use a UTF-8 description.\n\n\nSorry I didn't mean to be offensive. I think I have been in Japan for too\nlong,\nmy English senses are dulling.\n\nI agree with 1-4. \"\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f\" is now a lightning meme. I am honored. ;)\n\n\n\n> There is; no field can be greater than 640 bytes (1023 5-bit values).\n> Also, the transport might have practical limits, so you might need to\n> consider that in total.  (Maybe not though, if you're going for QR\n> codes, as they go pretty large).\n\n\n640 bytes is rather long... but this is not really a huge issue for me.\nSo I withdraw my comment.\n\n\n> Yes there should, but we left it open for the moment because there's no\n> good solution here, and someone needs to come up with one.  This makes\n> description hash fairly useless for now, IMHO.\n>\n> A URL is the obvious solution, but has the terrible property that it\n> de-anonymizes the wallet :( (even before the person has decided whether\n> they want to pay).\n>\n> FWIW, there are a range of possible solutions, depending on the scenario:\n> 1. If you have some container format, eg. HTML, include the description\nas a\n>    separate tag.\n> 2. Roasbeef wants to implement HORNET over our network, and that could\n>    be used to retrieve the full description.\n>\n> Meanwhile, 640 bytes should be enough for anyone!\n\n\nHORNET sounds nice. Under this description, it seems like the plain\ndescription\nwill be the primary method of communication for the forseeable future.\n\n\n> Actually I think bech32 loses all guarantees at 1023 words, but it's no\n> worse than a 30-bit checksum.  We mainly use it because it's simple and\n> available, and of course any fixed-length code will have some limit.\n>\n> What actually happens if we decode badly is that we derive the wrong\n> public key for the node (50% chance, other 50% we get a signature\n> failure) and we can't route to it or pay to it.  So no funds are\n> actually lost.\n\n\nUnless the incorrect pubkey just happened to be someone elses!!! (/s)\nYeah I guess if we don't care about error correction, a 30 bit checksum is\nstill pretty good.\n\n\n> Yes, this was *awesome*; I double-checked the values by hacking my\n> python encoder, and adjusted for the recent r-encoding change.  It's\n> merged, thanks!\n>\n>         https://github.com/lightningnetwork/lightning-rfc/pull/312\n\n\nGlad I could be of help. :)\n\n\n> That would be fantastic!  We've talked about changing the test vectors\n> (for all the BOLTs) into a more machine-friendly JSON encoding, so if\n> you're feeling ambitious you could start with BOLT 11 :)\n\n\nI'll have to work on that later this week. Currently trying to iron out our\nLightning\ndeposit / withdrawal UI with our front end engineer.\n\n\n> Thanks!\n\nYou're welcome!\n\nAdditional comment: we should make a requirement to hide text in the\ndescription under certain conditions.\n\nie. \"A reader MUST hide information surrounded by curly brackets {}\nincluding\nthe brackets themselves from the UI, and only make the information avaiable\ninternally.\"\n\nI think a lot of people will want to include extra data in their payment\nrequests' description.\n\nI think HTLC.ME uses it and maybe bitrefill? (correct me if I'm wrong.)\n\nPerhaps adding an \"extra data\" tag?\n\n... hmmm...\n\n\nThanks,\nJon\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/ea57d5a7/attachment.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-12T05:15:47",
                "message_text_only": "I made a payment request using UTF-8 description here:\nlntb1pdz7e9epp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdpquwpc4curk03c9wlrswe78q4eyqc7d8d0e5l2jffz6amujxz82mtagde82dv8jku2jac79k0yxnjmr0l3f4y5x0jxt46vmcrc0ukzh7l99vdmkezsettfwr4gqnhs2ndx8wdqgfsp82rnvp\n\nusing this code: (I just separated encode from sign)\n\nln.sign(ln.encode({\n  tags:[\n    {\n      tagName:'payment_hash',\n\ndata:'0001020304050607080900010203040506070809000102030405060708090102'\n    },\n    {\n      tagName:'description',\n      data:'\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f'\n    }\n  ]\n}, false),\nBuffer.from('e126f68f7eafcc8b74f54d269fe206be715000f94dac067d1c04a8ca3b2db734',\n'hex')).paymentRequest\n\n\nFull results:\n\n{\n  \"coinType\": \"testnet\",\n  \"payeeNodeKey\":\n\"03e7156ae33b0a208d0744199163177e909e80176e55d97a2f221ede0f934dd9ad\",\n  \"paymentRequest\":\n\"lntb1pdz7e9epp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdpquwpc4curk03c9wlrswe78q4eyqc7d8d0e5l2jffz6amujxz82mtagde82dv8jku2jac79k0yxnjmr0l3f4y5x0jxt46vmcrc0ukzh7l99vdmkezsettfwr4gqnhs2ndx8wdqgfsp82rnvp\",\n  \"recoveryFlag\": 1,\n  \"satoshis\": null,\n  \"signature\":\n\"cd3ea92522d777c9184756d7d437275358795b8a9771e2d9e434e5b1bff14d49433e465d74cde0787f2c2bfbe52b1bbb6450cad6970ea804ef054da63b9a0426\",\n  \"tags\": [\n    {\n      \"tagName\": \"payment_hash\",\n      \"data\":\n\"0001020304050607080900010203040506070809000102030405060708090102\"\n    },\n    {\n      \"tagName\": \"description\",\n      \"data\": \"\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f\"\n    }\n  ],\n  \"timestamp\": 1513055417,\n  \"timestampString\": \"2017-12-12T05:10:17.000Z\"\n}\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/3389f867/attachment-0001.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2017-12-12T13:46:28",
                "message_text_only": "Just a few quick comments, as any improvements to BOLT#11 are very much appreciated :)\n\n* I think we should set a reasonable max length for invoices, that MUST be met. This would simplify internal database logic (since you don\u2019t have to plan for invoices infinitely big), and could make sure the error detection is fair for all supported lengths. Not sure if 1023 is enough, considering possibly multiple `r` tags and a juicy description. * Agree with UTF-8 support, and up to 640 bytes length ( this can be made explicit in the Bolt, as now it is limited by the 5 bit length field) :) * Why must the description hash URL be part of the invoice? I always imagined this would be used between clients that already had agreed on payment for some kind of data, and that this hash would just ensure you were paying the correct one.\n- Johan (please explain the Japanese lightning meme plz)\nOn Tue, Dec 12, 2017 at 6:15, Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\nI made a payment request using UTF-8 description here: lntb1pdz7e9epp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdpquwpc4curk03c9wlrswe78q4eyqc7d8d0e5l2jffz6amujxz82mtagde82dv8jku2jac79k0yxnjmr0l3f4y5x0jxt46vmcrc0ukzh7l99vdmkezsettfwr4gqnhs2ndx8wdqgfsp82rnvp\n\nusing this code: (I just separated encode from sign)\nln.sign(ln.encode({ tags:[ { tagName:'payment_hash', data:'0001020304050607080900010203040506070809000102030405060708090102' }, { tagName:'description', data:'\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f' } ] }, false), Buffer.from('e126f68f7eafcc8b74f54d269fe206be715000f94dac067d1c04a8ca3b2db734', 'hex')).paymentRequest\n\n\nFull results:\n{ \"coinType\": \"testnet\", \"payeeNodeKey\": \"03e7156ae33b0a208d0744199163177e909e80176e55d97a2f221ede0f934dd9ad\", \"paymentRequest\": \"lntb1pdz7e9epp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdpquwpc4curk03c9wlrswe78q4eyqc7d8d0e5l2jffz6amujxz82mtagde82dv8jku2jac79k0yxnjmr0l3f4y5x0jxt46vmcrc0ukzh7l99vdmkezsettfwr4gqnhs2ndx8wdqgfsp82rnvp\", \"recoveryFlag\": 1, \"satoshis\": null, \"signature\": \"cd3ea92522d777c9184756d7d437275358795b8a9771e2d9e434e5b1bff14d49433e465d74cde0787f2c2bfbe52b1bbb6450cad6970ea804ef054da63b9a0426\", \"tags\": [ { \"tagName\": \"payment_hash\", \"data\": \"0001020304050607080900010203040506070809000102030405060708090102\" }, { \"tagName\": \"description\", \"data\": \"\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f\" } ], \"timestamp\": 1513055417, \"timestampString\": \"2017-12-12T05:10:17.000Z\" }\n\n_______________________________________________ Lightning-dev mailing list Lightning-dev at lists.linuxfoundation.org https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/35cb4bc6/attachment.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-12T13:58:44",
                "message_text_only": "Haha, Rusty sent me a google translate of \u201ccup of nonsense\u201d (joining my\nnonsense comment with the cup of coffee meme, since \u201ccup of nonsense\u201d seems\nlike a reasonable way to call something nonsense)\n\nI fixed it to a more \u201clooks like it would be on a receipt\u201d format instead\nof the direct translation which sounds more like the cup is made out of\nnonsense instead of being filled with it.\n\nHeh\n\nAlso, I don\u2019t disagree with your assessment of the purpose commit hash, but\nIf the user is shown a description on a website and it says \u201cplease paste\nthis description into your wallet to verify the description with the\npayment request\u201d... I am pretty sure most users won\u2019t bother, or will copy\npaste incorrectly and get a big red error message.\n\nI like to think of my mom trying to use it... and my mom accidentally\nordered a vacuum cleaner on Amazon once. (?????)\n\nSo yeah, I think if the wallet could somehow fetch it that would be best.\n\nBut for now, a simple description is fine imo.\n\nThanks,\nJon\n\n2017\u5e7412\u670812\u65e5(\u706b) 22:46 Johan Tor\u00e5s Halseth <johanth at gmail.com>:\n\n> Just a few quick comments, as any improvements to BOLT#11 are very much\n> appreciated :)\n>\n> * I think we should set a reasonable max length for invoices, that MUST be\n> met. This would simplify internal database logic (since you don\u2019t have to\n> plan for invoices infinitely big), and could make sure the error detection\n> is fair for all supported lengths. Not sure if 1023 is enough, considering\n> possibly multiple `r` tags and a juicy description.\n> * Agree with UTF-8 support, and up to 640 bytes length ( this can be made\n> explicit in the Bolt, as now it is limited by the 5 bit length field) :)\n> * Why must the description hash URL be part of the invoice? I always imagined\n> this would be used between clients that already had agreed on payment for\n> some kind of data, and that this hash would just ensure you were paying the\n> correct one.\n>\n> - Johan\n> (please explain the Japanese lightning meme plz)\n> On Tue, Dec 12, 2017 at 6:15, Jonathan Underwood <\n> junderwood at bitcoinbank.co.jp> wrote:\n>\n> I made a payment request using UTF-8 description here:\n>\n> lntb1pdz7e9epp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdpquwpc4curk03c9wlrswe78q4eyqc7d8d0e5l2jffz6amujxz82mtagde82dv8jku2jac79k0yxnjmr0l3f4y5x0jxt46vmcrc0ukzh7l99vdmkezsettfwr4gqnhs2ndx8wdqgfsp82rnvp\n>\n> using this code: (I just separated encode from sign)\n>\n> ln.sign(ln.encode({\n> tags:[\n> {\n> tagName:'payment_hash',\n> data:'0001020304050607080900010203040506070809000102030405060708090102'\n> },\n> {\n> tagName:'description',\n> data:'\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f'\n> }\n> ]\n> }, false),\n> Buffer.from('e126f68f7eafcc8b74f54d269fe206be715000f94dac067d1c04a8ca3b2db734',\n> 'hex')).paymentRequest\n>\n>\n> Full results:\n>\n> {\n> \"coinType\": \"testnet\",\n> \"payeeNodeKey\":\n> \"03e7156ae33b0a208d0744199163177e909e80176e55d97a2f221ede0f934dd9ad\",\n> \"paymentRequest\":\n> \"lntb1pdz7e9epp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdpquwpc4curk03c9wlrswe78q4eyqc7d8d0e5l2jffz6amujxz82mtagde82dv8jku2jac79k0yxnjmr0l3f4y5x0jxt46vmcrc0ukzh7l99vdmkezsettfwr4gqnhs2ndx8wdqgfsp82rnvp\",\n> \"recoveryFlag\": 1,\n> \"satoshis\": null,\n> \"signature\":\n> \"cd3ea92522d777c9184756d7d437275358795b8a9771e2d9e434e5b1bff14d49433e465d74cde0787f2c2bfbe52b1bbb6450cad6970ea804ef054da63b9a0426\",\n> \"tags\": [\n> {\n> \"tagName\": \"payment_hash\",\n> \"data\": \"0001020304050607080900010203040506070809000102030405060708090102\"\n> },\n> {\n> \"tagName\": \"description\",\n> \"data\": \"\u30ca\u30f3\u30bb\u30f3\u30b9 1\u676f\"\n> }\n> ],\n> \"timestamp\": 1513055417,\n> \"timestampString\": \"2017-12-12T05:10:17.000Z\"\n> }\n>\n>\n> _______________________________________________ Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> --\n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/64cea8d1/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-15T06:12:19",
                "message_text_only": "Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n> Additional comment: we should make a requirement to hide text in the\n> description under certain conditions.\n>\n> ie. \"A reader MUST hide information surrounded by curly brackets {}\n> including\n> the brackets themselves from the UI, and only make the information avaiable\n> internally.\"\n>\n> I think a lot of people will want to include extra data in their payment\n> requests' description.\n>\n> I think HTLC.ME uses it and maybe bitrefill? (correct me if I'm wrong.)\n\nOK, HTLC.ME (cool site!) uses a description of:\n\n        {\"generic_id\":\"ada00363-50b6-4281-82dd-d274393439f1\"}\n\nWhich I really don't understand.  This field is literally only to\ndisplay to the user, for them to validate it's what they wanted.  The\nrecipient never gets it back.\n\nIf I knew who ran HTLC.ME, I'd ask them to fix it: they should have a\ndescription entry field in their \"Request Payment\" form.  It could\ndefault to \"Test payment ada00363-50b6-4281-82dd-d274393439f1\", but\nthey're in spec violation at the moment.\n\n> Perhaps adding an \"extra data\" tag?\n\nEasy to do, if I knew why they wanted it.\n\nThanks!\nRusty."
            },
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-15T23:44:03",
                "message_text_only": "iirc they are using the description as a way to join the user data and the\npayment hash on their end.\n\nhtlc me is one node but separates its balance into user accounts that exist\noutside lightning. I think the identifier is used so when their backend\nchecks the payment request status, the user info is right there in their\nlocal lnd RPC response rather than having to store their own database\nseparately.\n\n2017\u5e7412\u670816\u65e5(\u571f) 8:31 Rusty Russell <rusty at rustcorp.com.au>:\n\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n> > Additional comment: we should make a requirement to hide text in the\n> > description under certain conditions.\n> >\n> > ie. \"A reader MUST hide information surrounded by curly brackets {}\n> > including\n> > the brackets themselves from the UI, and only make the information\n> avaiable\n> > internally.\"\n> >\n> > I think a lot of people will want to include extra data in their payment\n> > requests' description.\n> >\n> > I think HTLC.ME uses it and maybe bitrefill? (correct me if I'm wrong.)\n>\n> OK, HTLC.ME (cool site!) uses a description of:\n>\n>         {\"generic_id\":\"ada00363-50b6-4281-82dd-d274393439f1\"}\n>\n> Which I really don't understand.  This field is literally only to\n> display to the user, for them to validate it's what they wanted.  The\n> recipient never gets it back.\n>\n> If I knew who ran HTLC.ME, I'd ask them to fix it: they should have a\n> description entry field in their \"Request Payment\" form.  It could\n> default to \"Test payment ada00363-50b6-4281-82dd-d274393439f1\", but\n> they're in spec violation at the moment.\n>\n> > Perhaps adding an \"extra data\" tag?\n>\n> Easy to do, if I knew why they wanted it.\n>\n> Thanks!\n> Rusty.\n>\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171215/c9ce5f9b/attachment.html>"
            },
            {
                "author": "Jameson Lopp",
                "date": "2017-12-15T23:46:29",
                "message_text_only": "HTLC.me is run by Alex Bosworth; I'll ping him.\n\nOn Fri, Dec 15, 2017 at 6:44 PM, Jonathan Underwood <\njunderwood at bitcoinbank.co.jp> wrote:\n\n> iirc they are using the description as a way to join the user data and the\n> payment hash on their end.\n>\n> htlc me is one node but separates its balance into user accounts that\n> exist outside lightning. I think the identifier is used so when their\n> backend checks the payment request status, the user info is right there in\n> their local lnd RPC response rather than having to store their own database\n> separately.\n>\n> 2017\u5e7412\u670816\u65e5(\u571f) 8:31 Rusty Russell <rusty at rustcorp.com.au>:\n>\n>> Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n>> > Additional comment: we should make a requirement to hide text in the\n>> > description under certain conditions.\n>> >\n>> > ie. \"A reader MUST hide information surrounded by curly brackets {}\n>> > including\n>> > the brackets themselves from the UI, and only make the information\n>> avaiable\n>> > internally.\"\n>> >\n>> > I think a lot of people will want to include extra data in their payment\n>> > requests' description.\n>> >\n>> > I think HTLC.ME uses it and maybe bitrefill? (correct me if I'm wrong.)\n>>\n>> OK, HTLC.ME (cool site!) uses a description of:\n>>\n>>         {\"generic_id\":\"ada00363-50b6-4281-82dd-d274393439f1\"}\n>>\n>> Which I really don't understand.  This field is literally only to\n>> display to the user, for them to validate it's what they wanted.  The\n>> recipient never gets it back.\n>>\n>> If I knew who ran HTLC.ME, I'd ask them to fix it: they should have a\n>> description entry field in their \"Request Payment\" form.  It could\n>> default to \"Test payment ada00363-50b6-4281-82dd-d274393439f1\", but\n>> they're in spec violation at the moment.\n>>\n>> > Perhaps adding an \"extra data\" tag?\n>>\n>> Easy to do, if I knew why they wanted it.\n>>\n>> Thanks!\n>> Rusty.\n>>\n> --\n> -----------------\n> Jonathan Underwood\n> \u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n> -----------------\n>\n> \u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n>\n> \u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171215/c8efcb9c/attachment.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2017-12-17T12:11:25",
                "message_text_only": "Just to let everyone know. I currently have full coverage and a few test\ncases all ready to go.\n\nAll I really need is some edge cases. Any ideas are welcome.\n\nbitcoinjs/bolt11\n\nThanks,\nJon\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171217/05c927a6/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-16T18:51:03",
                "message_text_only": "Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n> iirc they are using the description as a way to join the user data and the\n> payment hash on their end.\n\nBut the description isn't used when I send a payment.  All they get is\nthe payment_hash.\n\n> htlc me is one node but separates its balance into user accounts that exist\n> outside lightning. I think the identifier is used so when their backend\n> checks the payment request status, the user info is right there in their\n> local lnd RPC response rather than having to store their own database\n> separately.\n\nAh, that's understandable, but it seems like a wrong API.\n\nc-lightning doesn't store the description in the database at all: each\ninvoice uses a label which the invoice creator specifies.  Unlike a\ndescription, this must be unique.  It's not exposed to customers at all.\n\nCheers,\nRusty."
            },
            {
                "author": "Alex Bosworth",
                "date": "2017-12-18T05:20:35",
                "message_text_only": "htlc.me storing data in the description is just an artifact of the\noriginal lnd API which didn't include that data in the payment request\n\nOn Sat, Dec 16, 2017 at 10:51 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n>> iirc they are using the description as a way to join the user data and the\n>> payment hash on their end.\n>\n> But the description isn't used when I send a payment.  All they get is\n> the payment_hash.\n>\n>> htlc me is one node but separates its balance into user accounts that exist\n>> outside lightning. I think the identifier is used so when their backend\n>> checks the payment request status, the user info is right there in their\n>> local lnd RPC response rather than having to store their own database\n>> separately.\n>\n> Ah, that's understandable, but it seems like a wrong API.\n>\n> c-lightning doesn't store the description in the database at all: each\n> invoice uses a label which the invoice creator specifies.  Unlike a\n> description, this must be unique.  It's not exposed to customers at all.\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n-- \nSent from my iPhone"
            }
        ],
        "thread_summary": {
            "title": "Comments on BOLT#11",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Rusty Russell",
                "Alex Bosworth",
                "Johan Tor\u00e5s Halseth",
                "Jameson Lopp",
                "Jonathan Underwood"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 38049
        }
    },
    {
        "title": "[Lightning-dev] [MINUTES] Dev Meeting 2017-12-12 ***TWO BREAKING CHANGES***",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2017-12-12T00:04:48",
                "message_text_only": "https://docs.google.com/document/d/1WaZDvCX7FsfZbrEMepLdchmDQyyRhY9MTBMF4NeZlOc/edit#\n\nUnusually, we had two minor breaking changes, despite the freeze:\n\n1. `r` fee field is now base+millionths like channel_update.\n   * Fixes case where there's no amount ('donation address').\n   * Nobody had implemented *using* this yet, and old versions will\n     parse, just have wrong fee now.\n2. nVersion for closing tx is 2, not 1.\n   * Turns out everyone implemented that, since every other tx is version 2.\n   * Advice from Mark Friedenbach was that using latest supported nVersion is\n     best practice.\n\nRandom notes:\n\nLots of bug-and-quirk fixing as each team sees issues on our\nnow-hetrogeneous testnet network, but it's been generally really stable\nand usable (as much as testnet can be).\n\nRusty promised that the major churn from all the copyediting should be\nalmost over; the big BOLTs have been refactored, it should now be more\nminor stuff.\n\nNo meeting in 2 weeks, as that would be Christmas Day for most.  Have a\ngreat break, and see you in 2018!\n\nNote the master doc for all minutes:\n\n        https://docs.google.com/document/d/1oU4wxzGsYd0T084rTXJbedb7Gvdtj4ax638nMkYUmco/edit#"
            }
        ],
        "thread_summary": {
            "title": "Dev Meeting 2017-12-12 ***TWO BREAKING CHANGES***",
            "categories": [
                "Lightning-dev",
                "MINUTES"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1181
        }
    },
    {
        "title": "[Lightning-dev] Peer selection",
        "thread_messages": [
            {
                "author": "Stan Kladko",
                "date": "2017-12-12T15:32:12",
                "message_text_only": "I have been reading LN specs, one question that I am trying to answer\nis how do I find a peer\nfor my lightning connections.\n\nLets say I want to connect to the network with 6 links, each having $100.\n\n1. How do I select the nodes to peer with?\n\n2. How do I make them to do deposits - ideally I want them to match $100 each.\n    But since they are presumably already sufficiently connected to\nthe network, why would they lock more funds?\n\n3. How do I find out if someone wants to connect to me?"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-13T00:36:24",
                "message_text_only": "Good morning Stan,\n\n>1. How do I select the nodes to peer with?\n\nBy whatever selection criteria you wish.\n\nIn practice, lnd offers an \"auto-pilot\" where it selects peers to channel with automatically using some heuristic (which I do not know).  My understanding, c-lightning will eventually offer a similar feature at some point in the future.\n\nPresumably node gossip will let you learn of other nodes that you might channel with in the future.\n\n>2. How do I make them to do deposits - ideally I want them to match $100 each.\n\nCurrently, channels are initially single-funded.  There is a proposal https://github.com/lightningnetwork/lightning-rfc/pull/184 for dual-funded channel setup, but did not make it into 1.0.\n\n>But since they are presumably already sufficiently connected to\n>the network, why would they lock more funds?\n\nIt helps to consider that you are not particularly special, and neither are the existing nodes on the network particularly special.\n\nIf you have a reason to open a channel to an arbitrary node, then other nodes have a reason to open a channel to an arbitrary node, which might be you.  Even if the network grows large, that also means there are more participants who might decide, via whatever heuristic, to channel to your node.\n\nIf you intend to connect for the purpose of becoming a hub and earning routing fees, if you have some onchain bitcoins you can afford to invest, then it is to your interest to channel with relatively new and low-connectivity nodes. Such nodes might receive payments and if you are one of the few routes (or the only route) you then get a higher chance of being routed through.  Inverting this, if you have a new node with a few channels, others aspiring to become hubs will want to lock spare funds to channel to your node in case you become a very prolific user (sender or receiver) of the network in the future.\n\n>3.  How do I find out if someone wants to connect to me?\n\nThe node connects to yours and sends channel funding messages.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/c8e87abc/attachment.html>"
            },
            {
                "author": "Stan Kladko",
                "date": "2017-12-13T08:58:21",
                "message_text_only": "I see - thank you.\n\nHow to I discover nodes - is there any UI to see nodes currently\nrunning on the network ?\n\n> 3.  How do I find out if someone wants to connect to me?\n> The node connects to yours and sends channel funding messages.\n\nIn this case there is some kind of an UI where I can accept or reject - correct?\nOr I auto-accept everyone that connects to me?\n\n> If you intend to connect for the purpose of becoming a hub and earning routing fees, if you have some onchain bitcoins you can afford to invest, then it is to your interest to channel with  relatively new and low-connectivity nodes.\n\nIf I become a hub, how much to I earn, approximately in routing fees?\nIs it a percentage of transactions? Are routing fees the same for all\nhubs?\n\nIf I am connecting to the network and see many hubs - how can I select\nwhich hub to connect to?  Is there any performance/reputation info\navailable for any hub?\n\n\n\n\nOn Wed, Dec 13, 2017 at 2:36 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> Good morning Stan,\n>\n>>1. How do I select the nodes to peer with?\n>\n> By whatever selection criteria you wish.\n>\n> In practice, lnd offers an \"auto-pilot\" where it selects peers to channel\n> with automatically using some heuristic (which I do not know).  My\n> understanding, c-lightning will eventually offer a similar feature at some\n> point in the future.\n>\n> Presumably node gossip will let you learn of other nodes that you might\n> channel with in the future.\n>\n>>2. How do I make them to do deposits - ideally I want them to match $100\n>> each.\n>\n> Currently, channels are initially single-funded.  There is a proposal\n> https://github.com/lightningnetwork/lightning-rfc/pull/184 for dual-funded\n> channel setup, but did not make it into 1.0.\n>\n>>But since they are presumably already sufficiently connected to\n>>the network, why would they lock more funds?\n>\n> It helps to consider that you are not particularly special, and neither are\n> the existing nodes on the network particularly special.\n>\n> If you have a reason to open a channel to an arbitrary node, then other\n> nodes have a reason to open a channel to an arbitrary node, which might be\n> you.  Even if the network grows large, that also means there are more\n> participants who might decide, via whatever heuristic, to channel to your\n> node.\n>\n> If you intend to connect for the purpose of becoming a hub and earning\n> routing fees, if you have some onchain bitcoins you can afford to invest,\n> then it is to your interest to channel with relatively new and\n> low-connectivity nodes. Such nodes might receive payments and if you are one\n> of the few routes (or the only route) you then get a higher chance of being\n> routed through.  Inverting this, if you have a new node with a few channels,\n> others aspiring to become hubs will want to lock spare funds to channel to\n> your node in case you become a very prolific user (sender or receiver) of\n> the network in the future.\n>\n>>3.  How do I find out if someone wants to connect to me?\n>\n> The node connects to yours and sends channel funding messages.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-13T12:53:52",
                "message_text_only": "Good morning Stan,\n\n>How to I discover nodes - is there any UI to see nodes currently\n>running on the network ?\n\nThere are no UIs to my knowledge. Current LN programs keep track of this in their databases, although each one varies in detail. Presumably their individual main developers know how to extract this information.\n\nMy understanding is that network bootstrap involves some LN nodes being discoverable via DNS, then your node will connect to them, request node gossip, then it (if you use some kind of auto-pilot channeling system like what lnd has) will select from the node information it acquires to select some nodes to connect and channel to.\n\nNote a precision, there is a difference between \"connect\" and \"channel\".  To connect, means only that you contact them over the network and consumes only bandwidth and some small amount of CPU power on your node.  To channel, means to commit some bitcoins to a payment channel between you.\n\n>>>How do I find out if someone wants to connect to me?\n>>The node connects to yours and sends channel funding messages.\n>\n>In this case there is some kind of an UI where I can accept or reject - correct?\n>Or I auto-accept everyone that connects to me?\n\nNone.  You auto-accept incoming channel requests.  You might, if you are up to it, program your node to reject some nodes via any heuristic you choose, but you would have to implement that yourself.  I know of no current LN software that has or intends to have such a feature, as there are little downside to accepting all channels --- you only spend less than a kilobyte of storage for each newly-opened channel --- while the upside is that a channel to you is a potential route which you can charge for, or a route you can receive funds through.\n\n>>If you intend to connect for the purpose of becoming a hub and earning routing fees, if you have some onchain bitcoins you can afford to invest, then it is to your interest to\n>channel with relatively new and low-connectivity nodes.\n>\n>If I become a hub, how much to I earn, approximately in routing fees?\n>Is it a percentage of transactions? Are routing fees the same for all\n>hubs?\n\nEach node indicates as part of its information a \"fixed fee\" and a \"proportional fee\".  The \"fixed fee\" is imposed per successful routing attempt, while the \"proportional fee\" is a ratio of the value traveling through the node when it is on the route.  It is expected that there will be many nodes through which  people can route, so there will be much competition and eventually the system will settle to a state where most nodes charge the same low fee.\n\n>If I am connecting to the network and see many hubs - how can I select\n>which hub to connect to? Is there any performance/reputation info\n>available for any hub?\n\nThere are none.  Presumably your auto-channeling program will gather statistics and other information to make some guesses on which nodes have good performance.\n\nNote that, there is nothing that specially privileges hubs, and this is deliberate.  Any node can become a hub without permission or special treatment of the network, if by \"hub\" we mean \"node with high number of channels\".  Indeed, even the DNS bootstrap, to my knowledge, should only be used to gather initial node gossip to acquire some *other* nodes that can potentially be channeled to.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171213/6bfeed80/attachment.html>"
            },
            {
                "author": "Stan Kladko",
                "date": "2017-12-13T13:04:50",
                "message_text_only": "Thank you\n\n\nPresumably many nodes will be behind firewalls.  Are there any\nfirewall traversal mechanisms included (or some type of an overlay\nnetwork)?)\n\n\n\nOn Wed, Dec 13, 2017 at 2:53 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> Good morning Stan,\n>\n>>How to I discover nodes - is there any UI to see nodes currently\n>>running on the network ?\n>\n> There are no UIs to my knowledge. Current LN programs keep track of this in\n> their databases, although each one varies in detail. Presumably their\n> individual main developers know how to extract this information.\n>\n> My understanding is that network bootstrap involves some LN nodes being\n> discoverable via DNS, then your node will connect to them, request node\n> gossip, then it (if you use some kind of auto-pilot channeling system like\n> what lnd has) will select from the node information it acquires to select\n> some nodes to connect and channel to.\n>\n> Note a precision, there is a difference between \"connect\" and \"channel\".  To\n> connect, means only that you contact them over the network and consumes only\n> bandwidth and some small amount of CPU power on your node.  To channel,\n> means to commit some bitcoins to a payment channel between you.\n>\n>>>>How do I find out if someone wants to connect to me?\n>>>The node connects to yours and sends channel funding messages.\n>>\n>>In this case there is some kind of an UI where I can accept or reject -\n>> correct?\n>>Or I auto-accept everyone that connects to me?\n>\n> None.  You auto-accept incoming channel requests.  You might, if you are up\n> to it, program your node to reject some nodes via any heuristic you choose,\n> but you would have to implement that yourself.  I know of no current LN\n> software that has or intends to have such a feature, as there are little\n> downside to accepting all channels --- you only spend less than a kilobyte\n> of storage for each newly-opened channel --- while the upside is that a\n> channel to you is a potential route which you can charge for, or a route you\n> can receive funds through.\n>\n>>>If you intend to connect for the purpose of becoming a hub and earning\n>>> routing fees, if you have some onchain bitcoins you can afford to invest,\n>>> then it is to your interest to\n>>channel with relatively new and low-connectivity nodes.\n>>\n>>If I become a hub, how much to I earn, approximately in routing fees?\n>>Is it a percentage of transactions? Are routing fees the same for all\n>>hubs?\n>\n> Each node indicates as part of its information a \"fixed fee\" and a\n> \"proportional fee\".  The \"fixed fee\" is imposed per successful routing\n> attempt, while the \"proportional fee\" is a ratio of the value traveling\n> through the node when it is on the route.  It is expected that there will be\n> many nodes through which  people can route, so there will be much\n> competition and eventually the system will settle to a state where most\n> nodes charge the same low fee.\n>\n>>If I am connecting to the network and see many hubs - how can I select\n>>which hub to connect to? Is there any performance/reputation info\n>>available for any hub?\n>\n> There are none.  Presumably your auto-channeling program will gather\n> statistics and other information to make some guesses on which nodes have\n> good performance.\n>\n> Note that, there is nothing that specially privileges hubs, and this is\n> deliberate.  Any node can become a hub without permission or special\n> treatment of the network, if by \"hub\" we mean \"node with high number of\n> channels\".  Indeed, even the DNS bootstrap, to my knowledge, should only be\n> used to gather initial node gossip to acquire some *other* nodes that can\n> potentially be channeled to.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-13T13:15:46",
                "message_text_only": "Good morning Stan,\n\nThe protocol allows nodes to be behind Tor hidden services (.onion domain names).  Tor hidden services automatically have NAT punching and firewall traversal, as long as the firewall allows Tor protocol to go through.\n\nI do not know if there are already LN software that actually supports being run as a Tor hidden service yet, however.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n-------- Original Message --------\nSubject: Re: [Lightning-dev] Peer selection\nLocal Time: December 13, 2017 9:04 PM\nUTC Time: December 13, 2017 1:04 PM\nFrom: stan.kladko at galacticexchange.io\nTo: ZmnSCPxj <ZmnSCPxj at protonmail.com>\nlightning-dev at lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n\nThank you\n\nPresumably many nodes will be behind firewalls. Are there any\nfirewall traversal mechanisms included (or some type of an overlay\nnetwork)?)\n\nOn Wed, Dec 13, 2017 at 2:53 PM, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\nGood morning Stan,\nHow to I discover nodes - is there any UI to see nodes currently\nrunning on the network ?\nThere are no UIs to my knowledge. Current LN programs keep track of this in\ntheir databases, although each one varies in detail. Presumably their\nindividual main developers know how to extract this information.\nMy understanding is that network bootstrap involves some LN nodes being\ndiscoverable via DNS, then your node will connect to them, request node\ngossip, then it (if you use some kind of auto-pilot channeling system like\nwhat lnd has) will select from the node information it acquires to select\nsome nodes to connect and channel to.\nNote a precision, there is a difference between \"connect\" and \"channel\". To\nconnect, means only that you contact them over the network and consumes only\nbandwidth and some small amount of CPU power on your node. To channel,\nmeans to commit some bitcoins to a payment channel between you.\nHow do I find out if someone wants to connect to me?\nThe node connects to yours and sends channel funding messages.\nIn this case there is some kind of an UI where I can accept or reject -\ncorrect?\nOr I auto-accept everyone that connects to me?\nNone. You auto-accept incoming channel requests. You might, if you are up\nto it, program your node to reject some nodes via any heuristic you choose,\nbut you would have to implement that yourself. I know of no current LN\nsoftware that has or intends to have such a feature, as there are little\ndownside to accepting all channels --- you only spend less than a kilobyte\nof storage for each newly-opened channel --- while the upside is that a\nchannel to you is a potential route which you can charge for, or a route you\ncan receive funds through.\nIf you intend to connect for the purpose of becoming a hub and earning\nrouting fees, if you have some onchain bitcoins you can afford to invest,\nthen it is to your interest to\nchannel with relatively new and low-connectivity nodes.\nIf I become a hub, how much to I earn, approximately in routing fees?\nIs it a percentage of transactions? Are routing fees the same for all\nhubs?\nEach node indicates as part of its information a \"fixed fee\" and a\n\"proportional fee\". The \"fixed fee\" is imposed per successful routing\nattempt, while the \"proportional fee\" is a ratio of the value traveling\nthrough the node when it is on the route. It is expected that there will be\nmany nodes through which people can route, so there will be much\ncompetition and eventually the system will settle to a state where most\nnodes charge the same low fee.\nIf I am connecting to the network and see many hubs - how can I select\nwhich hub to connect to? Is there any performance/reputation info\navailable for any hub?\nThere are none. Presumably your auto-channeling program will gather\nstatistics and other information to make some guesses on which nodes have\ngood performance.\nNote that, there is nothing that specially privileges hubs, and this is\ndeliberate. Any node can become a hub without permission or special\ntreatment of the network, if by \"hub\" we mean \"node with high number of\nchannels\". Indeed, even the DNS bootstrap, to my knowledge, should only be\nused to gather initial node gossip to acquire some other nodes that can\npotentially be channeled to.\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171213/d7f5d692/attachment.html>"
            },
            {
                "author": "William Casarin",
                "date": "2017-12-14T02:45:38",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\nwrites:\n\n> Good morning Stan,\n>\n>>How to I discover nodes - is there any UI to see nodes currently\n>>running on the network ?\n>\n> There are no UIs to my knowledge. Current LN programs keep track of this in their databases, although each one varies in detail. Presumably their individual main developers know how to extract this information.\n\nI found this one today [1]. I used it to connect to a couple nodes.\n\n[1] https://explorer.acinq.co\n\n-- \nhttps://jb55.com"
            }
        ],
        "thread_summary": {
            "title": "Peer selection",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Stan Kladko",
                "William Casarin"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 17948
        }
    },
    {
        "title": "[Lightning-dev] Lightning-dev Digest, Vol 28, Issue 9",
        "thread_messages": [
            {
                "author": "Stan Kladko",
                "date": "2017-12-13T09:37:42",
                "message_text_only": "> If you have a reason to open a channel to an arbitrary node, then other nodes have a reason to open a channel to an arbitrary node, which might be you.  Even if the network grows large, that > also means there are more participants who might decide, via whatever heuristic, to channel to your node.\n\nIf I am connected to some nodes, but no one connected to me, then all\nof my deposit is used by me only, and is not used by other nodes.\nIf I am routing nodes through my node, then it can potentially\nnegatively affect availability of my deposit for my own transactions.\nSo it seems to me that the best strategy is to connect but accept no\nincoming connections.\n\nHow much real is this problem?\n\n\n\nOn Wed, Dec 13, 2017 at 10:58 AM,\n<lightning-dev-request at lists.linuxfoundation.org> wrote:\n> Send Lightning-dev mailing list submissions to\n>         lightning-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> or, via email, send a message with subject or body 'help' to\n>         lightning-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         lightning-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Peer selection (Stan Kladko)\n>    2. Re: Peer selection (ZmnSCPxj)\n>    3. Re: LN public marketplaces (exchanges) (ZmnSCPxj)\n>    4. Re: Peer selection (Stan Kladko)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Tue, 12 Dec 2017 17:32:12 +0200\n> From: Stan Kladko <stan.kladko at galacticexchange.io>\n> To: lightning-dev at lists.linuxfoundation.org\n> Subject: [Lightning-dev] Peer selection\n> Message-ID:\n>         <CA+Zg=czbP+UBSsigXF1Gzq+HZGPKAuy8wFpFnX4swY6fR3KqEQ at mail.gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> I have been reading LN specs, one question that I am trying to answer\n> is how do I find a peer\n> for my lightning connections.\n>\n> Lets say I want to connect to the network with 6 links, each having $100.\n>\n> 1. How do I select the nodes to peer with?\n>\n> 2. How do I make them to do deposits - ideally I want them to match $100 each.\n>     But since they are presumably already sufficiently connected to\n> the network, why would they lock more funds?\n>\n> 3. How do I find out if someone wants to connect to me?\n>\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Tue, 12 Dec 2017 19:36:24 -0500\n> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> To: Stan Kladko <stan.kladko at galacticexchange.io>\n> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>         <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] Peer selection\n> Message-ID:\n>         <QUTEyN8gbg0ndyb38Q5-WkyCrooI8ptcnQTVeeoFAK3OGp3NVPfaLkzd8G1iUpeSLy1txlbMW6MORSZaF02CeJ8C8rgt5Ej1AMxqomN_BxM=@protonmail.com>\n>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Good morning Stan,\n>\n>>1. How do I select the nodes to peer with?\n>\n> By whatever selection criteria you wish.\n>\n> In practice, lnd offers an \"auto-pilot\" where it selects peers to channel with automatically using some heuristic (which I do not know).  My understanding, c-lightning will eventually offer a similar feature at some point in the future.\n>\n> Presumably node gossip will let you learn of other nodes that you might channel with in the future.\n>\n>>2. How do I make them to do deposits - ideally I want them to match $100 each.\n>\n> Currently, channels are initially single-funded.  There is a proposal https://github.com/lightningnetwork/lightning-rfc/pull/184 for dual-funded channel setup, but did not make it into 1.0.\n>\n>>But since they are presumably already sufficiently connected to\n>>the network, why would they lock more funds?\n>\n> It helps to consider that you are not particularly special, and neither are the existing nodes on the network particularly special.\n>\n> If you have a reason to open a channel to an arbitrary node, then other nodes have a reason to open a channel to an arbitrary node, which might be you.  Even if the network grows large, that also means there are more participants who might decide, via whatever heuristic, to channel to your node.\n>\n> If you intend to connect for the purpose of becoming a hub and earning routing fees, if you have some onchain bitcoins you can afford to invest, then it is to your interest to channel with relatively new and low-connectivity nodes. Such nodes might receive payments and if you are one of the few routes (or the only route) you then get a higher chance of being routed through.  Inverting this, if you have a new node with a few channels, others aspiring to become hubs will want to lock spare funds to channel to your node in case you become a very prolific user (sender or receiver) of the network in the future.\n>\n>>3.  How do I find out if someone wants to connect to me?\n>\n> The node connects to yours and sends channel funding messages.\n>\n> Regards,\n> ZmnSCPxj\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/c8e87abc/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Tue, 12 Dec 2017 20:19:00 -0500\n> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> To: \"U.Mutlu\" <um4711 at mutluit.com>\n> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>         <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] LN public marketplaces (exchanges)\n> Message-ID:\n>         <l2X2PcULcdRd86iLthJttYfey1v8Vp3gZ9QQEkN4rSZ6wKx1LjLhejYF0LcnI6m1aOkplYVYRGYbNqqxKfMK0l_juZdkYNuAuyy6ctoQxXw=@protonmail.com>\n>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Good Morning,\n>\n> My understanding of your idea is the below:\n>\n> 1.  I set up as a middleman from the base blockchain to the LN.\n> 2.  You send me an onchain transaction plus a fee and after 0 confirmations (!! risk) I send to the recipient on LN.\n>\n> But please consider that you could run an LN node yourself, open a channel (and spend any fees you might have paid to me in the channel opening) and then sent to the recipient on LN yourself.  Further, you can afterwards make future payments to LN for low fees yourself, without having to make a new onchain transaction each time.  So I see no benefit to you using this service.\n>\n> Regards,\n> ZmnSCPxj\n>\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] LN public marketplaces (exchanges)\n> Local Time: December 12, 2017 7:08 AM\n> UTC Time: December 11, 2017 11:08 PM\n> From: um4711 at mutluit.com\n> To: lightning-dev at lists.linuxfoundation.org\n>\n> Christian Decker wrote on 12/11/2017 11:59 AM:\n> Not sure I fully understand the use-case you are referring to. Is this\n> supposed to be a short-term loan to get a bill paid or is this supposed\n> to facilitate muli-hop payments? In the former case there is no support\n> for it yet, since all of the payments in LN are always fully backed by\n> Bitcoin. In the latter case, I don't see how that differs from the\n> multi-hop payments we already do.\n>\n> I must admit I'm new to LN and don't know yet if it can be used\n> in setting up such a scenario:\n>\n> A bitcoin transaction usually takes at least 10 minutes for confirmation.\n> An instant payment could be realised if a middleman pays out the amount\n> to the receiver immediately, and gets his money back from the original\n> sender the normal way (ie. waiting the 10+ minutes).\n>\n> The middlemen (ie. other users) would announce their such service at\n> a marketplace (the highest amount he/she is willing to overtake plus\n> the fees he/she wants). With each transaction, Bitcoin would pick\n> the best offer from the orderbook of the maketplace and process the\n> transaction that way (ie. swapping the receiver by the middleman).\n>\n> The advantages: the receiver gets the money instantly,\n> and any user can play middleman (hence an exchange for it),\n> the middlemen earn from the fees, exchanges get established, ...\n>\n> Just an idea...\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171212/ea69fedd/attachment-0001.html>\n>\n> ------------------------------\n>\n> Message: 4\n> Date: Wed, 13 Dec 2017 10:58:21 +0200\n> From: Stan Kladko <stan.kladko at galacticexchange.io>\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> Cc: \"lightning-dev at lists.linuxfoundation.org\"\n>         <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] Peer selection\n> Message-ID:\n>         <CA+Zg=cwRD-YKtXYjg+0K6Q75E77gS5quON456wGbnTb7R-5-ag at mail.gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> I see - thank you.\n>\n> How to I discover nodes - is there any UI to see nodes currently\n> running on the network ?\n>\n>> 3.  How do I find out if someone wants to connect to me?\n>> The node connects to yours and sends channel funding messages.\n>\n> In this case there is some kind of an UI where I can accept or reject - correct?\n> Or I auto-accept everyone that connects to me?\n>\n>> If you intend to connect for the purpose of becoming a hub and earning routing fees, if you have some onchain bitcoins you can afford to invest, then it is to your interest to channel with  relatively new and low-connectivity nodes.\n>\n> If I become a hub, how much to I earn, approximately in routing fees?\n> Is it a percentage of transactions? Are routing fees the same for all\n> hubs?\n>\n> If I am connecting to the network and see many hubs - how can I select\n> which hub to connect to?  Is there any performance/reputation info\n> available for any hub?\n>\n>\n>\n>\n> On Wed, Dec 13, 2017 at 2:36 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>> Good morning Stan,\n>>\n>>>1. How do I select the nodes to peer with?\n>>\n>> By whatever selection criteria you wish.\n>>\n>> In practice, lnd offers an \"auto-pilot\" where it selects peers to channel\n>> with automatically using some heuristic (which I do not know).  My\n>> understanding, c-lightning will eventually offer a similar feature at some\n>> point in the future.\n>>\n>> Presumably node gossip will let you learn of other nodes that you might\n>> channel with in the future.\n>>\n>>>2. How do I make them to do deposits - ideally I want them to match $100\n>>> each.\n>>\n>> Currently, channels are initially single-funded.  There is a proposal\n>> https://github.com/lightningnetwork/lightning-rfc/pull/184 for dual-funded\n>> channel setup, but did not make it into 1.0.\n>>\n>>>But since they are presumably already sufficiently connected to\n>>>the network, why would they lock more funds?\n>>\n>> It helps to consider that you are not particularly special, and neither are\n>> the existing nodes on the network particularly special.\n>>\n>> If you have a reason to open a channel to an arbitrary node, then other\n>> nodes have a reason to open a channel to an arbitrary node, which might be\n>> you.  Even if the network grows large, that also means there are more\n>> participants who might decide, via whatever heuristic, to channel to your\n>> node.\n>>\n>> If you intend to connect for the purpose of becoming a hub and earning\n>> routing fees, if you have some onchain bitcoins you can afford to invest,\n>> then it is to your interest to channel with relatively new and\n>> low-connectivity nodes. Such nodes might receive payments and if you are one\n>> of the few routes (or the only route) you then get a higher chance of being\n>> routed through.  Inverting this, if you have a new node with a few channels,\n>> others aspiring to become hubs will want to lock spare funds to channel to\n>> your node in case you become a very prolific user (sender or receiver) of\n>> the network in the future.\n>>\n>>>3.  How do I find out if someone wants to connect to me?\n>>\n>> The node connects to yours and sends channel funding messages.\n>>\n>> Regards,\n>> ZmnSCPxj\n>\n>\n> ------------------------------\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> End of Lightning-dev Digest, Vol 28, Issue 9\n> ********************************************"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-16T18:55:01",
                "message_text_only": "Stan Kladko <stan.kladko at galacticexchange.io> writes:\n>> If you have a reason to open a channel to an arbitrary node, then other nodes have a reason to open a channel to an arbitrary node, which might be you.  Even if the network grows large, that > also means there are more participants who might decide, via whatever heuristic, to channel to your node.\n>\n> If I am connected to some nodes, but no one connected to me, then all\n> of my deposit is used by me only, and is not used by other nodes.\n> If I am routing nodes through my node, then it can potentially\n> negatively affect availability of my deposit for my own transactions.\n> So it seems to me that the best strategy is to connect but accept no\n> incoming connections.\n>\n> How much real is this problem?\n\nI don't think it is.  If you have two channels, then people routing\nthrough you doesn't effect your total capacity, it just shifts them\nbetween the channels.\n\nHope that helps,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Lightning-dev Digest, Vol 28, Issue 9",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Stan Kladko"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 13449
        }
    },
    {
        "title": "[Lightning-dev] Peer Selection",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-13T13:13:47",
                "message_text_only": "Good morning,\n\n>>If you have a reason to open a channel to an arbitrary node, then other nodes have a reason to open a channel to an arbitrary node, which might be you. Even if the\n>network grows large, that > also means there are more participants who might decide, via whatever heuristic, to channel to your node.\n>\n>If I am connected to some nodes, but no one connected to me, then all\n>of my deposit is used by me only, and is not used by other nodes.\n>If I am routing nodes through my node, then it can potentially\n>negatively affect availability of my deposit for my own transactions.\n>So it seems to me that the best strategy is to connect but accept no\n>incoming connections.\n>\n>How much real is this problem?\n\nYou would also have to make your outgoing channels private (not sent by node gossip) so that others will not route through you.  You will not be able to receive money on-Lightning (since your channels are private, people who are trying to send money to you on-Lightning will not be able to find a route to you).  You will not earn any money from routing fees (since you are not willing to have others use your channels for routing).\n\nIt has the advantage that you can actually lose Internet connectivity indefinitely with no possibility of loss of funds, simply because in this mode of operation, channels are effectively unidirectional only from you to the rest of the network.\n\nHowever, I think in the long run, you would prefer to receive funds by Lightning also, and so cannot use this kind of operation.  Consider that in the future, you may get paid your salary or dividends in bitcoin over Lightning: your business/employer receives money from its customer over Lightning, it sends part of that money to sub-contractors and suppliers, and some to you (employee or shareholder).  You then spend the money you receive as salary/dividends for food and services and other vices you might have, which are provided by other businesses which have their own shareholders, employees, sub-contractors, and suppliers.\n\nIn such a world, you would have to make your channels public and accept incoming channels, and at minimum accept incoming money (even if you reject routing attempts).  Since routing can earn you some amount of money as fees, you probably want to accept at least a few routing attempts at a time to earn some fees (and offset the fees on your own transactions).  This also leads to a more mesh-like network; the \"unidirectional mode\" where you keep all your channels private and only outgoing effectively makes you a second-class member of the network (and has higher onchain fees: if you have depleted a channel, there is an incentive to keep it open only if you are willing to accept routing attempts through you (every open channel is an opportunity to route, and a channel depleted on your end is full on the opposite end and you can still at least accept transactions toward you), otherwise, you are better off closing channels (and incurring fees) so you can recover the channel reserve).\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171213/33a3734d/attachment-0001.html>"
            },
            {
                "author": "Stan Kladko",
                "date": "2017-12-13T16:10:49",
                "message_text_only": "Thank you - this is lots of information !)\n\n> You would also have to make your outgoing channels private  (not sent by node gossip) so that others will not route through you.\n\nIf I would have only a single outgoing channel I would not have to\nmake it private ? Correct? There is no way to route through a node\nthat has one channel.\n\nAnother interesting question is what happens if I have lots of\nchannels, but in my software block all routing through my node?\n\nIs there a way for me to block all routing through my node by\nmodifying node software but still enjoy all benefits of receiving and\nsending deposits?\n\nAs you said, blocking all routing has lots of benefit since money is\nsafe if the network is down :-)\n\nSorry for playing devils advocate - I am just trying to understand it )\n\n\n\nOn Wed, Dec 13, 2017 at 3:13 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> Good morning,\n>\n>>>If you have a reason to open a channel to an arbitrary node, then other\n>>> nodes have a reason to open a channel to an arbitrary node, which might be\n>>> you. Even if the\n>>network grows large, that > also means there are more participants who\n>> might decide, via whatever heuristic, to channel to your node.\n>>\n>>If I am connected to some nodes, but no one connected to me, then all\n>>of my deposit is used by me only, and is not used by other nodes.\n>>If I am routing nodes through my node, then it can potentially\n>>negatively affect availability of my deposit for my own transactions.\n>>So it seems to me that the best strategy is to connect but accept no\n>>incoming connections.\n>>\n>>How much real is this problem?\n>\n> You would also have to make your outgoing channels private (not sent by node\n> gossip) so that others will not route through you.  You will not be able to\n> receive money on-Lightning (since your channels are private, people who are\n> trying to send money to you on-Lightning will not be able to find a route to\n> you).  You will not earn any money from routing fees (since you are not\n> willing to have others use your channels for routing).\n>\n> It has the advantage that you can actually lose Internet connectivity\n> indefinitely with no possibility of loss of funds, simply because in this\n> mode of operation, channels are effectively unidirectional only from you to\n> the rest of the network.\n>\n> However, I think in the long run, you would prefer to receive funds by\n> Lightning also, and so cannot use this kind of operation.  Consider that in\n> the future, you may get paid your salary or dividends in bitcoin over\n> Lightning: your business/employer receives money from its customer over\n> Lightning, it sends part of that money to sub-contractors and suppliers, and\n> some to you (employee or shareholder).  You then spend the money you receive\n> as salary/dividends for food and services and other vices you might have,\n> which are provided by other businesses which have their own shareholders,\n> employees, sub-contractors, and suppliers.\n>\n> In such a world, you would have to make your channels public and accept\n> incoming channels, and at minimum accept incoming money (even if you reject\n> routing attempts).  Since routing can earn you some amount of money as fees,\n> you probably want to accept at least a few routing attempts at a time to\n> earn some fees (and offset the fees on your own transactions).  This also\n> leads to a more mesh-like network; the \"unidirectional mode\" where you keep\n> all your channels private and only outgoing effectively makes you a\n> second-class member of the network (and has higher onchain fees: if you have\n> depleted a channel, there is an incentive to keep it open only if you are\n> willing to accept routing attempts through you (every open channel is an\n> opportunity to route, and a channel depleted on your end is full on the\n> opposite end and you can still at least accept transactions toward you),\n> otherwise, you are better off closing channels (and incurring fees) so you\n> can recover the channel reserve).\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-14T03:11:56",
                "message_text_only": "Good morning Stan,\n\nMoney is safe when network is down only if you only pay out of your node.  Once you receive, it is possible for your counterparty to transmit an invalid old state where it owns more money than you do.  Then you need to monitor the blockchain for invalid closings of channel state, meaning you cannot be offline for more than a few days (this timeout is settable in your node).\n\nBasically, consider the below situation:\n\nYou make a channel to me and load it with 3mBTC.  You force the channel to be unidirectional, because you might be offline for months.\n\nStan: 3mBTC, ZmnSCPxj: 0mBTC Initial state\nStan: 2mBTC, ZmnSCPxj: 1mBTC after you pay me 1 mBTC\nStan: 1mBTC, ZmnSCPxj: 2mBTC after you pay me 1 mBTC\n\nNow suppose you decide to accept money via this channel.  So the channel history now becomes:\n\nStan: 2mBTC, ZmnSCPxj: 1mBTC after I pay you 1 mBTC\nStan: 3mBTC, ZmnSCPxj: 0mBTC after I pay you 1 mBTC\n\nAt this point, I can take back my 2mBTC by replaying the old \"Stan: 1mBTC, ZmnSCPxj: 2mBTC\" state.  Normally, this is a bad move on my part, since old state is revoked and you can present evidence of fraud on the blockchain layer to take the entire channel value as yours, as damages.  However, you only have a few days where you can present this evidence.  If those few days pass, then the payment is finalized and I get back the 2 mBTC I paid to you.\n\nThe upshot is that if you receive money for any reason (whether for routing, or because you are the final payee) you can only be offline for at most a few days.  Otherwise, you force yourself into unidirectional mode only (you can only pay, never receive): unidirectional mode also is bad for you since you cannot offset the fees you pay for spending using fees you receive for routing.\n\nIf you are going to receive money anyway, you might as well enable routing also, because that lets you earn some fees (to offset the fees you would pay to spend your money).  The added risk is low: most routes will either successfully reach the destination, or fail outright, within a few seconds, freeing the funds back to you again.\n\nThe protocol has two settings \"max_htlc_value_in_flight_msat\" and \"max_accepted_htlcs\" to limit your exposure to routing risk.  These limit how much of your channel funds can be spent on routing (max_htlc_value_in_flight_msat) and the number of routes at a time that should be used on that channel (max_accepted_htlcs).  If those limits would be violated by a route attempting to go to you, the route simply fails and the payer will have to find another route.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n-------- Original Message --------\nSubject: Re: [Lightning-dev] Peer Selection\nLocal Time: December 14, 2017 12:10 AM\nUTC Time: December 13, 2017 4:10 PM\nFrom: stan.kladko at galacticexchange.io\nTo: ZmnSCPxj <ZmnSCPxj at protonmail.com>\nlightning-dev at lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n\nThank you - this is lots of information !)\nYou would also have to make your outgoing channels private (not sent by node gossip) so that others will not route through you.\n\nIf I would have only a single outgoing channel I would not have to\nmake it private ? Correct? There is no way to route through a node\nthat has one channel.\n\nAnother interesting question is what happens if I have lots of\nchannels, but in my software block all routing through my node?\n\nIs there a way for me to block all routing through my node by\nmodifying node software but still enjoy all benefits of receiving and\nsending deposits?\n\nAs you said, blocking all routing has lots of benefit since money is\nsafe if the network is down :-)\n\nSorry for playing devils advocate - I am just trying to understand it )\n\nOn Wed, Dec 13, 2017 at 3:13 PM, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\nGood morning,\nIf you have a reason to open a channel to an arbitrary node, then other\nnodes have a reason to open a channel to an arbitrary node, which might be\nyou. Even if the\nnetwork grows large, that > also means there are more participants who\nmight decide, via whatever heuristic, to channel to your node.\nIf I am connected to some nodes, but no one connected to me, then all\nof my deposit is used by me only, and is not used by other nodes.\nIf I am routing nodes through my node, then it can potentially\nnegatively affect availability of my deposit for my own transactions.\nSo it seems to me that the best strategy is to connect but accept no\nincoming connections.\nHow much real is this problem?\nYou would also have to make your outgoing channels private (not sent by node\ngossip) so that others will not route through you. You will not be able to\nreceive money on-Lightning (since your channels are private, people who are\ntrying to send money to you on-Lightning will not be able to find a route to\nyou). You will not earn any money from routing fees (since you are not\nwilling to have others use your channels for routing).\nIt has the advantage that you can actually lose Internet connectivity\nindefinitely with no possibility of loss of funds, simply because in this\nmode of operation, channels are effectively unidirectional only from you to\nthe rest of the network.\nHowever, I think in the long run, you would prefer to receive funds by\nLightning also, and so cannot use this kind of operation. Consider that in\nthe future, you may get paid your salary or dividends in bitcoin over\nLightning: your business/employer receives money from its customer over\nLightning, it sends part of that money to sub-contractors and suppliers, and\nsome to you (employee or shareholder). You then spend the money you receive\nas salary/dividends for food and services and other vices you might have,\nwhich are provided by other businesses which have their own shareholders,\nemployees, sub-contractors, and suppliers.\nIn such a world, you would have to make your channels public and accept\nincoming channels, and at minimum accept incoming money (even if you reject\nrouting attempts). Since routing can earn you some amount of money as fees,\nyou probably want to accept at least a few routing attempts at a time to\nearn some fees (and offset the fees on your own transactions). This also\nleads to a more mesh-like network; the \"unidirectional mode\" where you keep\nall your channels private and only outgoing effectively makes you a\nsecond-class member of the network (and has higher onchain fees: if you have\ndepleted a channel, there is an incentive to keep it open only if you are\nwilling to accept routing attempts through you (every open channel is an\nopportunity to route, and a channel depleted on your end is full on the\nopposite end and you can still at least accept transactions toward you),\notherwise, you are better off closing channels (and incurring fees) so you\ncan recover the channel reserve).\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171213/4282e3c7/attachment-0001.html>"
            },
            {
                "author": "Stan Kladko",
                "date": "2017-12-14T15:09:05",
                "message_text_only": "I see, thank you for the explanation.\n\nNow  I understand, so if my node is down and I received payments, I\nmay  lose some of my received payments.\nBut if I route and someone routed large amounts of money through me,\nand then my node is down, then may lose these payments too.\n\nBasically, if I am routing,  then if my node crashes, I may be liable\nfor some of the routed funds, in addition losing some of the  funds I\nreceived .\n\nSo from the safety perspective there are three stages of risk\n\na) send only\nb) send and receive\nc) send and receive and route\n\n\n\n\n\nOn Thu, Dec 14, 2017 at 5:11 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> Good morning Stan,\n>\n> Money is safe when network is down only if you only pay out of your node.\n> Once you receive, it is possible for your counterparty to transmit an\n> invalid old state where it owns more money than you do.  Then you need to\n> monitor the blockchain for invalid closings of channel state, meaning you\n> cannot be offline for more than a few days (this timeout is settable in your\n> node).\n>\n> Basically, consider the below situation:\n>\n> You make a channel to me and load it with 3mBTC.  You force the channel to\n> be unidirectional, because you might be offline for months.\n>\n> Stan: 3mBTC, ZmnSCPxj: 0mBTC Initial state\n> Stan: 2mBTC, ZmnSCPxj: 1mBTC after you pay me 1 mBTC\n> Stan: 1mBTC, ZmnSCPxj: 2mBTC after you pay me 1 mBTC\n>\n> Now suppose you decide to accept money via this channel.  So the channel\n> history now becomes:\n>\n> Stan: 2mBTC, ZmnSCPxj: 1mBTC after I pay you 1 mBTC\n> Stan: 3mBTC, ZmnSCPxj: 0mBTC after I pay you 1 mBTC\n>\n> At this point, I can take back my 2mBTC by replaying the old \"Stan: 1mBTC,\n> ZmnSCPxj: 2mBTC\" state.  Normally, this is a bad move on my part, since old\n> state is revoked and you can present evidence of fraud on the blockchain\n> layer to take the entire channel value as yours, as damages.  However, you\n> only have a few days where you can present this evidence.  If those few days\n> pass, then the payment is finalized and I get back the 2 mBTC I paid to you.\n>\n> The upshot is that if you receive money for any reason (whether for routing,\n> or because you are the final payee) you can only be offline for at most a\n> few days.  Otherwise, you force yourself into unidirectional mode only (you\n> can only pay, never receive): unidirectional mode also is bad for you since\n> you cannot offset the fees you pay for spending using fees you receive for\n> routing.\n>\n> If you are going to receive money anyway, you might as well enable routing\n> also, because that lets you earn some fees (to offset the fees you would pay\n> to spend your money).  The added risk is low: most routes will either\n> successfully reach the destination, or fail outright, within a few seconds,\n> freeing the funds back to you again.\n>\n> The protocol has two settings \"max_htlc_value_in_flight_msat\" and\n> \"max_accepted_htlcs\" to limit your exposure to routing risk.  These limit\n> how much of your channel funds can be spent on routing\n> (max_htlc_value_in_flight_msat) and the number of routes at a time that\n> should be used on that channel (max_accepted_htlcs).  If those limits would\n> be violated by a route attempting to go to you, the route simply fails and\n> the payer will have to find another route.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] Peer Selection\n> Local Time: December 14, 2017 12:10 AM\n> UTC Time: December 13, 2017 4:10 PM\n> From: stan.kladko at galacticexchange.io\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> lightning-dev at lists.linuxfoundation.org\n> <lightning-dev at lists.linuxfoundation.org>\n>\n> Thank you - this is lots of information !)\n> You would also have to make your outgoing channels private (not sent by node\n> gossip) so that others will not route through you.\n>\n> If I would have only a single outgoing channel I would not have to\n> make it private ? Correct? There is no way to route through a node\n> that has one channel.\n>\n> Another interesting question is what happens if I have lots of\n> channels, but in my software block all routing through my node?\n>\n> Is there a way for me to block all routing through my node by\n> modifying node software but still enjoy all benefits of receiving and\n> sending deposits?\n>\n> As you said, blocking all routing has lots of benefit since money is\n> safe if the network is down :-)\n>\n> Sorry for playing devils advocate - I am just trying to understand it )\n>\n>\n>\n> On Wed, Dec 13, 2017 at 3:13 PM, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> Good morning,\n> If you have a reason to open a channel to an arbitrary node, then other\n> nodes have a reason to open a channel to an arbitrary node, which might be\n> you. Even if the\n> network grows large, that > also means there are more participants who\n> might decide, via whatever heuristic, to channel to your node.\n> If I am connected to some nodes, but no one connected to me, then all\n> of my deposit is used by me only, and is not used by other nodes.\n> If I am routing nodes through my node, then it can potentially\n> negatively affect availability of my deposit for my own transactions.\n> So it seems to me that the best strategy is to connect but accept no\n> incoming connections.\n> How much real is this problem?\n> You would also have to make your outgoing channels private (not sent by node\n> gossip) so that others will not route through you. You will not be able to\n> receive money on-Lightning (since your channels are private, people who are\n> trying to send money to you on-Lightning will not be able to find a route to\n> you). You will not earn any money from routing fees (since you are not\n> willing to have others use your channels for routing).\n> It has the advantage that you can actually lose Internet connectivity\n> indefinitely with no possibility of loss of funds, simply because in this\n> mode of operation, channels are effectively unidirectional only from you to\n> the rest of the network.\n> However, I think in the long run, you would prefer to receive funds by\n> Lightning also, and so cannot use this kind of operation. Consider that in\n> the future, you may get paid your salary or dividends in bitcoin over\n> Lightning: your business/employer receives money from its customer over\n> Lightning, it sends part of that money to sub-contractors and suppliers, and\n> some to you (employee or shareholder). You then spend the money you receive\n> as salary/dividends for food and services and other vices you might have,\n> which are provided by other businesses which have their own shareholders,\n> employees, sub-contractors, and suppliers.\n> In such a world, you would have to make your channels public and accept\n> incoming channels, and at minimum accept incoming money (even if you reject\n> routing attempts). Since routing can earn you some amount of money as fees,\n> you probably want to accept at least a few routing attempts at a time to\n> earn some fees (and offset the fees on your own transactions). This also\n> leads to a more mesh-like network; the \"unidirectional mode\" where you keep\n> all your channels private and only outgoing effectively makes you a\n> second-class member of the network (and has higher onchain fees: if you have\n> depleted a channel, there is an incentive to keep it open only if you are\n> willing to accept routing attempts through you (every open channel is an\n> opportunity to route, and a channel depleted on your end is full on the\n> opposite end and you can still at least accept transactions toward you),\n> otherwise, you are better off closing channels (and incurring fees) so you\n> can recover the channel reserve).\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-15T19:06:13",
                "message_text_only": "Let me add some more color to the discussion.\n\nIf you do not announce the existence of the channel to the wider network\nyou can still receive incoming payments, by simply telling the payment\nsender about the channel. This is what is being done in the payment\nrequest by adding the `r` parameter to the request. You are selectively\ninforming the sender about the channel, which can then use that\ninformation to construct the route (and onion packet) and initiate the\npayment.\n\nEven though you have only one channel, and announce it, people might\nstill want to route through you, by using the channel twice: once to\nroute to you and then back out from you. While this may seem wasteful,\nit may be useful to hide the real origin/destination of the\npayment. Another scenario for which this is useful is that you are an\nauditor that witnesses the payment while it is being processed, for book\nkeeping or similar cases. This would also work for unannounced channels.\n\nSo the decision whether to announce a channel is exactly what you're\nlooking for. It allows you to do bidirectional payments, and does not\nallow random people to route through you. Implementations might\neventually add an \"endpoint mode\" that rejects any HTLC for which the\nnode is not the origin or the destination, which would further enforce\nthis.\n\nCheers,\nChristian"
            },
            {
                "author": "Stan Kladko",
                "date": "2017-12-15T21:00:50",
                "message_text_only": "Hi Cristian,\n\nIf there is such a great company, BlockStream. and Blockstream runs a\nfantastic high quality node, then as a user why should I connect to\nany node other than Blockstream?\nIn this case I dont need to be online all the time and dont need to\nmonitor the blockchain for anything. I will just believe that\nBlockstream will do no bad to me.\n\nWhy do I need to drink unnamed cola if there is Pepsi?))  People used\nto run emails servers, it is all Gmail now, much more secure and\nreliable!\n\n\n\n\nOn Fri, Dec 15, 2017 at 9:06 PM, Christian Decker\n<decker.christian at gmail.com> wrote:\n> Let me add some more color to the discussion.\n>\n> If you do not announce the existence of the channel to the wider network\n> you can still receive incoming payments, by simply telling the payment\n> sender about the channel. This is what is being done in the payment\n> request by adding the `r` parameter to the request. You are selectively\n> informing the sender about the channel, which can then use that\n> information to construct the route (and onion packet) and initiate the\n> payment.\n>\n> Even though you have only one channel, and announce it, people might\n> still want to route through you, by using the channel twice: once to\n> route to you and then back out from you. While this may seem wasteful,\n> it may be useful to hide the real origin/destination of the\n> payment. Another scenario for which this is useful is that you are an\n> auditor that witnesses the payment while it is being processed, for book\n> keeping or similar cases. This would also work for unannounced channels.\n>\n> So the decision whether to announce a channel is exactly what you're\n> looking for. It allows you to do bidirectional payments, and does not\n> allow random people to route through you. Implementations might\n> eventually add an \"endpoint mode\" that rejects any HTLC for which the\n> node is not the origin or the destination, which would further enforce\n> this.\n>\n> Cheers,\n> Christian"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-15T21:13:37",
                "message_text_only": "For one thing having a single connection means that the peer you're\nconnecting to can see all your payment amounts and their timings, and\nthey can be sure that they are from you since you don't have any other\nchannel. Opening more channels gives you plausible deniability. Also\nit'd make your single peer a single point of failure, meaning that if it\ngoes down you're dead in the water.\n\nAnd then on the other end, we have no interest in running a large hub in\nthe first place. They're expensive to run, since we'd have to allocate\nenough funds to cover the sum of payments you might receive over time\n(which is already hard to know, so we'd have to over-provision). That'd\nalso make the hub an attractive target for an attack, since it'd have a\nlot of funds sitting in hot wallets. Furthermore the utility the hub\ngets from the funds it allocates to the channels going to endpoints,\nsuch as your node, is very minimal, since it can only earn fees on\npayments that are either initiated by you or received by you, meaning\nthe funds mostly sit idle. Compare that to a channel that is very active\nbecause it bridges two large clusters in the network. The low\nutilization of the funds in the channel also means that hubs will have\nto charge large fees for the few times the channels are actually used,\nwhich again is an incentive for you to create bypasses.\n\nI think these arguments alone are probably sufficient to discourage the\nformation of large hubs, and should incentivize even end-users to create\nat least 2 channels. Remember that this is all taken care of in the\nbackground by the client, users don't actually have to think about\nopening/closing/maintaining channels, or how to allocate funds to the\nchannels. Our goal in the end is to create clients that show a single\nbalance, allow users to make both off-chain or on-chain payments from\nthat balance, and not require people to ever think about the details in\nthe background.\n\nI appreciate your trust in Blockstream, but as our informal motto says\n\"don't trust, verify!\" :-)\n\nCheers,\nChristian\n\nStan Kladko <stan.kladko at galacticexchange.io> writes:\n> Hi Cristian,\n>\n> If there is such a great company, BlockStream. and Blockstream runs a\n> fantastic high quality node, then as a user why should I connect to\n> any node other than Blockstream?\n> In this case I dont need to be online all the time and dont need to\n> monitor the blockchain for anything. I will just believe that\n> Blockstream will do no bad to me.\n>\n> Why do I need to drink unnamed cola if there is Pepsi?))  People used\n> to run emails servers, it is all Gmail now, much more secure and\n> reliable!\n>\n>\n>\n>\n> On Fri, Dec 15, 2017 at 9:06 PM, Christian Decker\n> <decker.christian at gmail.com> wrote:\n>> Let me add some more color to the discussion.\n>>\n>> If you do not announce the existence of the channel to the wider network\n>> you can still receive incoming payments, by simply telling the payment\n>> sender about the channel. This is what is being done in the payment\n>> request by adding the `r` parameter to the request. You are selectively\n>> informing the sender about the channel, which can then use that\n>> information to construct the route (and onion packet) and initiate the\n>> payment.\n>>\n>> Even though you have only one channel, and announce it, people might\n>> still want to route through you, by using the channel twice: once to\n>> route to you and then back out from you. While this may seem wasteful,\n>> it may be useful to hide the real origin/destination of the\n>> payment. Another scenario for which this is useful is that you are an\n>> auditor that witnesses the payment while it is being processed, for book\n>> keeping or similar cases. This would also work for unannounced channels.\n>>\n>> So the decision whether to announce a channel is exactly what you're\n>> looking for. It allows you to do bidirectional payments, and does not\n>> allow random people to route through you. Implementations might\n>> eventually add an \"endpoint mode\" that rejects any HTLC for which the\n>> node is not the origin or the destination, which would further enforce\n>> this.\n>>\n>> Cheers,\n>> Christian"
            }
        ],
        "thread_summary": {
            "title": "Peer Selection",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Christian Decker",
                "Stan Kladko"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 29416
        }
    },
    {
        "title": "[Lightning-dev] Every node must be aware of all other nodes - scalability problem?",
        "thread_messages": [
            {
                "author": "Oliver Mattos",
                "date": "2017-12-14T18:02:38",
                "message_text_only": "It seems to me by reading BOLT #7 that every node in the lightning network\nmust be aware of every other. That is necessary to choose a complete route\nto send a transaction for example.\n\nIf the lightning network grows large, one could imagine multiple network\nnodes per person, so say 7e10 nodes. For a fully connected graph, there\nmust also be 7e10 channels, and likely many more.\n\nThat means each node, upon joining the network, must download, keep in\nlocal storage, and keep updates on at least 35TB of data to be able to send\npayments elsewhere on the network.\n\nTo me, that doesn't seem feasible.\n\nSurely there needs to be some kind of method whereby a peer can keep track\nof only the nearby nodes, and have some kind of routing table for groups of\nmore distant nodes, which need not individually be known. A DHT is an\nexample of that. Designing such a system where no intermediate node knows\nboth sender and receiver sounds hard, but possible...\n\nWhy aren't we doing that?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171214/0c84fa32/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-15T21:24:57",
                "message_text_only": "Welcome to the mailing list Oliver :-)\n\n> It seems to me by reading BOLT #7 that every node in the lightning network\n> must be aware of every other. That is necessary to choose a complete route\n> to send a transaction for example.\n\nYes, Bolt 7 is a purposefully simplistic gossiping protocol that does\nnot scale infinitely. It's simple because we need something to get\nstarted and it is not intended to work forever, just long enough for us\nto come up with something better.\n\n> If the lightning network grows large, one could imagine multiple network\n> nodes per person, so say 7e10 nodes. For a fully connected graph, there\n> must also be 7e10 channels, and likely many more.\n>\n> That means each node, upon joining the network, must download, keep in\n> local storage, and keep updates on at least 35TB of data to be able to send\n> payments elsewhere on the network.\n\nI should note that you will absolutely need more than n-1 channels if you\nhave n nodes, otherwise you're just creating a line-graph, that would\nnot be very useful :-)\n\nRusty had some back-of-the-envelope calculations about the raw size of\nthe data that a node has to handle for 1 million nodes [1], and they\ncome to about 120 MB, without updates. And yes the initial sync is also\nvery simplistic, but we are already starting to think about better, more\nfine-grained sync protocols to reduce that upfront download when\njoining, and you can disable the initial sync already.\n\n> Surely there needs to be some kind of method whereby a peer can keep track\n> of only the nearby nodes, and have some kind of routing table for groups of\n> more distant nodes, which need not individually be known. A DHT is an\n> example of that. Designing such a system where no intermediate node knows\n> both sender and receiver sounds hard, but possible...\n>\n> Why aren't we doing that?\n\nWe are also thinking about more advanced path finding algorithms that\nreduce the need for the complete information on the node (some of them\nalso mentioned in that blog post). There's just a lot to implement\ngenerally for Lightning, so we punted on the routing problem a bit,\nsince it is a luxury problem: before we hit that wall we first have to\nhave a network that is successful enough to need a better solution.\n\nCheers,\nChristian\n\n[1] https://medium.com/@rusty_lightning/lightning-routing-rough-background-dbac930abbad"
            }
        ],
        "thread_summary": {
            "title": "Every node must be aware of all other nodes - scalability problem?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Oliver Mattos"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3515
        }
    },
    {
        "title": "[Lightning-dev] General question on routing difficulties",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2017-12-15T21:46:54",
                "message_text_only": "Thanks for filling in some gaps in my knowledge of the internal workings\nof Ripple. I see now my mental model of the system and how it compares to\nwhat's being proposed in SpeedyMurmurs wasn't quite correct.\n\n> In my opinion, it is interesting to look at tradeoffs and the\n> necessary/sufficient guarantees for the routing algorithm in a\n> decentralized payment network such as the LN before we stick to a\nsolution.\n\nAgreed, and there can be many such solutions depending on particular use\ncases. When switching to new routing algorithms, most of the existing code\ndealing with the interaction in the link itself (how channel updates are\ndone, funding channels, resolving multi-hop HTLC's, how disputes are\nsettled on-chain, etc) can be completely reused.\n\n> For what I understand, what you are asking/proposing is a mixture of the\n> routing layer (route from sender to receiver) + onion layer (using\n> \u201cadapted\u201d/\u201doptimized\u201d sphinx)+ payment layer (HTLCs).\n\nNot exactly, I was more asking how w/o onion routing (as we do now), the\nsender is able to construct an outgoing HTLC that satisfies the time lock\nand fee preferences of all participants in the final route. Currently the\nsender completely orchestrates the route so it can select the total amount\nand time locks such that all participants have the preferences upheld.\n\n> Another proposal might consist on a payment operation that does not assume\n> source-routing to start with.  There are many possibilities to investigate\n> and think about.\n\nIndeed. I haven't yet found a satisfactory solution to HTLC parameter\nselection at the sender w/o a degree of source routing. The extreme naive\nversions lead to an excessive total time lock value in the route, or\nsenders losing out more money to fees as the routes are no longer as\nprecise.\n\n> What you describe here is indeed a problem inherent to the original\n> landmark routing mechanism. However, it is no longer an issue in\n> SpeedyMurmurs. In particular, any node could be a landmark or two users\n> could have a different view of what set of nodes constitute the set of\n> landmarks.\n\nAh! I missed this aspect the first time around in my read through. Thanks\nfor resolving a major misunderstanding on my end (along with the usage of\nshortcuts).\n\n> All in all, it seems that there might be some misconceptions and/or\n> aspects in the current draft of the paper that might need clarifications\n> so that the approach is well understood. We are more than happy to\n> further talk about it and answer questions, doubts or concerns that\n> might arise.\n\nThanks for clearing up my initial misunderstandings of the protocol! I'll\ngive the paper (along with the works it derives from) a close read and\nfollow back up with any further questions. Based on your response to my\ninitial comments, it seems I mischaracterized the routing algorithm as\nbeing an incremental advancement compared to the original landmark\nprotocol. Instead, it has gone far beyond that.\n\n> I, however, do not agree that we should choose one routing\n> approach or another based on how unbalanced channels are handled.\n\nI didn't mean to entail that an approach should be *chosen* based on how\nunbalanced channels are handled. Instead, I was highlighting how they're\nhandled using a source routed protocol, to start a discussion on if\npassive rebalancing can be applied to others. As you stated earlier in our\nconversation, we should examine the desirable properties of a routing\nproposal so we can navigate the various trade offs.\n\n> My point is that I think we should not stick to one routing algorithm\n> depending on how another algorithm/functionality at another layer is\n> handled, at least not before we explore and fully understand the\n> tradeoffs, benefits and impossibilities that we will have to face here.\n\nAgreed. The intent of my initial response was to highlight how we handle\ncertain functionalities with the current algorithm so we can then begin to\ninvestigate it those features are possible/applicable to other algorithms\nsuch as SpeedyMurmurs. I don't think any of us see the current algorithm\nas the one and only algorithm we'll be sticking to for the lifetime of the\nsystem. Instead, it's a stepping stone of something with a degree of\nprivacy built-in by default that was simple enough to get the ball rolling\nas far as deployment.\n\n> I also believe that we might have more than just HTLC-based payments in\n> the LN, but this is the topic for another long email :)\n\nDefinitely! HTLC's are just the start...\n\n-- Laolu\n\nOn Thu, Nov 30, 2017 at 8:59 AM Pedro Moreno Sanchez <pmorenos at purdue.edu>\nwrote:\n\n> Hi Laolu,\n> Thanks for your detailed and interesting reply. Please see below some\n> points I would like to make in some of your comments and the answers to\n> your questions in the last email. And of course, I would be happy to\n> further discuss with you.\n>\n>\n> On 11/25/17 2:16 PM, Olaoluwa Osuntokun wrote:\n> > (final try as the prior mail hit the size limit, sorry for the spam!)\n> >\n> > Hi Pedro,\n> >\n> > I came across this paper a few weeks ago, skimmed it lightly, and noted a\n> > few interesting aspects I wanted to dig into later. Your email reminded\n> me\n> > to re-read the paper, so thanks for that! Before reading the paper, I\n> > wasn't aware of the concept of coordinate embedding, nor how that could\n> be\n> > leveraged in order to provide sender+receiver privacy in a payment\n> network\n> > using a distance-vector-like routing system. Very cool technique!\n> >\n> >\n> > After reading the paper again, my current conclusion is that while the\n> > protocol presents some novel traits in the design a routing system for\n> > payment channel based networks, it lends much better to a\n> > closed-membership, credit network, such as Ripple (which is the focus of\n> > the paper).\n> >\n> I personally do not agree with this conclusion. The Ripple network uses\n> a global ledger that contains all the nodes, all the credit links among\n> them and the weight of each credit link at all points in time.\n> Therefore, as such, every user can simply check such public information\n> and decide a route with enough credit on its own. There is no need for a\n> decentralized routing algorithm on Ripple as all the information is\n> being continuously updated in the ledger.\n>\n> In the work we present in this paper, we focus instead on a\n> decentralized payment network, where the links\u2019 states (e.g., bitcoin\n> balances in the payment channels within LN) are not continuously logged\n> in the blockchain but instead, every link is locally maintained by the\n> corresponding pair of users. With such setting in mind, we have designed\n> our routing algorithm (SpeedyMurmurs) and we believe it has potential to\n> be used in the Lightning network as well.\n> >\n> > In Ripple, there are only a handful of gateways, and clients that seek to\n> > interact with the network must chose their gateways *very* carefully,\n> > otherwise consensus faults can occur, violating safety properties of the\n> > network. It would appear that this gateway model nicely translates well\n> to\n> > the concept of landmarks that the protocol is strongly dependant on.\n> > Ideally, each gateway would be a landmark, and as there are a very small\n> > number of gateways within Ripple (as you must be admitted to be a\n> verified\n> > gateway in the network), then parameter L (the total number of landmarks)\n> > is kept small which minimizes routing overhead, the average path-length,\n> > etc.\n> >\n> I think this description confuses the terms: gateway, validator and\n> landmark. A gateway is an online exchange service that is trusted to\n> correctly create a credit link with a new user in the Ripple network. If\n> Alice has a Ripple wallet but no credit link yet in the Ripple network,\n> she can get her first issued credits on a link with a gateway.\n> Similarly, Alice can use such online exchange service to get her first\n> bitcoins by paying fiat currency, for instance. Importantly, a gateway\n> does not take part in the Ripple Consensus Algorithm, and therefore a\n> gateway cannot provoke consensus failures and violate safety properties.\n>\n> The Ripple consensus algorithm is run among a set of validators. A\n> validator is the one that can provoke consensus failures. Note that a\n> validator is a participant in the consensus protocol that might not even\n> have a wallet in the Ripple network and therefore might not even be a\n> gateway. For example, MIT and Microsoft have run a validator and are not\n> gateways in the Ripple network.\n>\n> Finally, a landmark as used in SpeedyMurmurs, the routing algorithm we\n> propose in this paper,  is simply a node in the network that it is\n> *only* used to bootstrap the routing algorithm, and any node in the\n> network can do so. In the very specific case of a decentralized version\n> of the Ripple network such as SilentWhispers\n> (https://eprint.iacr.org/2016/1054), gateways become good candidates to\n> be such landmarks. However, the routing algorithm that we propose in\n> SpeedyMurmurs is by no means tied to gateways and in particular,\n> landmarks can be simply nodes chosen at random from the complete set of\n> nodes in the network, as we show in the paper. Therefore, we believe\n> that SpeedyMurmurs might be suitable for different payment networks, and\n> in particular for the LN.\n> >\n> > When we compare Ripple to LN, we find that the two networks are nearly\n> > polar opposites of each other. LN is an open-membership network that\n> > requires zero initial configuration by central administrators(s). It more\n> > closely resembles *debit* network (a series of tubes of money), as the\n> > funds within channels must be pre-committed in order to establish a link\n> > between two nodes, and cannot be increased without an additional on-chain\n> > control transaction (to add or remove funds). Additionally, AFAIK (I'm no\n> > expert on Ripple of course), there's no concept of fees within the\n> > network. While within LN, the fee structure is a critical component of\n> the\n> > inventive for node operators to lift their coins onto this new layer to\n> > provider payment routing services.  Finally, in LN we rely on time-locks\n> > in order to ensure that all transactions are atomic which adds another\n> set\n> > of constraints. Ripple has no such constraint as transfers are based on\n> > bi-lateral trust.\n> >\n> I agree that comparing Ripple and LN is like comparing apples and\n> oranges. For starters, Ripple is a \u201cblockchain-focussed\u201d payment network\n> as *all* the operations in the network are registered in the blockchain\n> while the LN only uses the blockchain for opening and closing a payment\n> channel. Ripple is a credit network while the LN is a debit network. And\n> many other differences.\n>\n> There are some similarities though. In Ripple *there is* also the\n> concept of fee being charged for forwarding a payment and for currency\n> exchange. This fee structure has a similar motivation as in the LN:\n> create an incentive for users to be used as intermediate hops in\n> payments. Both networks face/will have to face similar challenges:\n> bootstrapping, i.e., how to create the first credit link/payment channel\n> for a new user in the network and with whom so that one can transact\n> with the rest of the network; liquidity: i.e., what should be the\n> network topology and how much credit/debit there should be in the\n> links/channels so that every user can transact to any other user in the\n> network; and many others.\n>\n> But again, in SpeedyMurmurs we are not presenting a routing algorithm\n> for a \u201cblockchain-centered\u201d payment network like Ripple but rather a\n> routing algorithm for a decentralized payment network such as\n> SilentWhispers, LN, Raiden Network or Interledger.\n> >\n> > With that said, the primary difference between this protocol is that\n> > currently we utilize a source-routed system which requires the sender to\n> > know \"most\" of the path to the destination. I say \"most\" as currently,\n> > it's possible for the receiver of a payment to use a poor man's\n> rendezvous\n> > system to provide the sender with a set of suffix paths form what one can\n> > consider ad-hoc landmarks. The sender can then concatenate these with\n> > their own paths, and construct the Sphinx routing package which encodes\n> > the full route. This itself only gives sender privacy, and the receiver\n> > doesn't know the identity of the sender, but the sender learns the\n> > identity of the receiver.\n> >\n> > We have plans to achieve proper sender/receiver privacy by extending our\n> > Sphinx usage to leverage HORNET, such that the payment descriptor\n> (payment\n> > request containing details of the payment) also includes several paths\n> > from rendezvous nodes (Rodrigo's) to the receiver. The rendezvous route\n> > itself will be nested as a further Anonymous Header (AHDR) which includes\n> > the information necessary to complete the onion circuit from Rodrigo to\n> > the receiver. As onion routing is used, only Rodrigo can decrypt the\n> > payload and finalize the route. With such a structure, the only nodes\n> that\n> > need to advertise their channels are nodes which seek to actively serve\n> as\n> > channel routers. All other nodes (phones, laptops, etc), don't need to\n> > advertise their channels to the greater network, reducing the size of the\n> > visible network, and also the storage and validation overhead. This\n> serves\n> > to extend the \"scale ceiling\" a bit.\n> >\n> Two comments here:\n>  * As Christian Decker indicated in a previous email, this routing\n> technique assumes that the routing layer and the onion layer are\n> together by default. This is obviously an interesting alternative worth\n> exploring and investigating what advantages/disadvantages it has and\n> what are the inherent tradeoffs.\n>\n>  * Nevertheless, it is obviously not the only alternative. We could\n> separate the routing layer from the onion layer and study what\n> advantages/disadvantages we can get from there. For instance, in\n> SpeedyMurmurs, nodes only need to announce their channels to their\n> neighbors and yet they are able to reconstruct a path from sender to the\n> receiver.  Our current experiments show that this simplicity has\n> enormous benefits in terms of performance.\n>\n> In my opinion, it is interesting to look at tradeoffs and the\n> necessary/sufficient guarantees for the routing algorithm in a\n> decentralized payment network such as the LN before we stick to a solution.\n>\n> >\n> > My first question is: is it possible to adapt the protocol to allow each\n> > intermediate node to communicate their time lock and fee references to\n> the\n> > sender? Currently, as the full path isn't known ahead of time, the sender\n> > is unable to properly craft the timelocks to ensure safety+atomicity of\n> > the payment. This would mean they don't know what the total timelock\n> > should be on the first outgoing link. Additionally, as they don't know\n> the\n> > total path and the fee schedule of each intermediate node, then once\n> > again, they don't know how much to send on the first out going link. It\n> > would seem that one could extend the probing phase to allow backwards\n> > communication by each intermediate node back to the sender, such that\n> they\n> > can properly craft a valid HTLC. This would increase the set up costs of\n> > the protocol however, and may also increase routing failures as it's\n> > possible incompatibilities arise at run-time between the preferences of\n> > intermediate nodes. Additionally, routes may fail as an intermediate node\n> > consumes too many funds as their fee, causing the funds to be\n> insufficient\n> > when it reaches the destination. One countermeasure would maybe: the\n> > sender always sends waaay more than necessary, and gives the receiver a\n> > one-time payment identifier, requiring that they route the remainder of\n> > the funds *back* to them.\n> >\n> >\n> > To solve this issue presently, we extend the header in Sphinx to include\n> a\n> > per-hop payload which allows the sender to precisely dictate the\n> > structure of the route, allows the intermediate nodes to authenticate the\n> > information given to it, and also allow the intermediate node to verify\n> > that their policies have properly been respected. These payloads can also\n> > be utilized by applications to communicate a small-ish amount of data to\n> > construct higher-level protocols on top of the system. Examples include:\n> > cross-chain swaps, chance payment games, higher-level B2B protocols,\n> > flavors of ZKCP's, media streaming, internet access proxying, etc.\n> >\n> For what I understand, what you are asking/proposing is a mixture of the\n> routing layer (route from sender to receiver) + onion layer (using\n> \u201cadapted\u201d/\u201doptimized\u201d sphinx)+ payment layer (HTLCs). Even in this mixed\n> alternative, we might want to investigate what are the guarantees and\n> tradeoffs provided. For instance, in another recent work from us\n> (https://eprint.iacr.org/2017/820), we proposed multi-hop HTLC: A\n> modification of the HTLC contract so that the condition of the\n> conditional payment does not lead to privacy issues.\n>\n> However, I rather prefer the approach of looking at one layer/component\n> at a time and see what optimizations we can perform there and what are\n> the inherent impossibilities. Therefore, we have not thoroughly studied\n> yet how to integrate the routing algorithm we propose in SpeedyMurmurs\n> with a possible payment operation. Having said that, some variation of\n> what you sketched might work. Another proposal might consist on a\n> payment operation that does not assume source-routing to start with.\n> There are many possibilities to investigate and think about.\n> >\n> > From my point-of-view, when extended to LN, the core component of the\n> > protocol (landmarks), becomes the weakest component. From my reading,\n> > *all* nodes need to be ware of an *identical* set of landmarks (more or\n> > less similar to the desired homogeneity of Gateways), otherwise the\n> > coordinate embedding scheme breaks down. Currently, there's no\n> requirement\n> > that all nodes have a globally consistent view of the network. So then an\n> > important questions arises: who choose the landmarks? A desirable\n> property\n> > of a routing system for LN (IMO) is that is has close to zero required\n> > initial set up by a central administrator. With this protocol, it would\n> > seem that all nodes much ship with a hard coded set of global landmarks\n> > for the path finding to succeed.  This itself pins a hard coordination\n> > requirement amongst implementers to have something like this deployed.\n>\n> I think your description here might not be accurate for what I\n> understand. What you describe here is indeed a problem inherent to the\n> original landmark routing mechanism. However, it is no longer an issue\n> in SpeedyMurmurs. In particular, any node could be a landmark or two\n> users could have a different view of what set of nodes constitute the\n> set of  landmarks. As soon as sender and receiver have a non-empty\n> intersection of their set of landmark-nodes, SpeedyMurmurs provides a\n> route among them.\n>\n> In the approach we present in SpeedyMurmurs, the landmark is just a node\n> that declares himself a landmark by triggering to his neighbors the\n> chain of messages required to construct the embeddings in the whole\n> network. Any node in the network can do this. Moreover, in\n> SpeedyMurmurs, this is a one-time thing. Once a set of embedding are\n> created, the landmark is not used again. Changes in the network topology\n> are locally handled by the neighbors of the newly connected/disconnected\n> node.\n>\n> > Even ignoring this requirement for a minute, I see several other\n> > downsides:\n> >\n> >    * As *all* payments must flow through landmarks (since nodes break up\n> >      their payment into L sub-flows), the landmarks must be very, very\n> >      well capitalized. This would cause strong consolidation of the\n> >      selection of landmarks, as they need extremely large channels in\n> >      order to facilitate transfer within the network.\n>\n> This is true in the original landmark routing. However, this is no\n> longer the case in SpeedyMurmurs. Paths no longer require to have the\n> landmark as intermediate user. Even further, a path from a sender to the\n> receiver might use links that are not even part of the spanning tree. We\n> call them \u201cshortcuts\u201d in the paper. We designed it like this having the\n> capitalization problem you mentioned in mind.\n>\n> >\n> >    * As landmarks must be globally known, this it seems this would\n> >      introduce fragility in the network. If most of the landmarks go down\n> >      (fails stop crashes) due to hardware issues, DoS, exploited bugs,\n> >      etc, then the network's throughput instantly becomes crippled.\n>\n> Again, this is true in the original landmark routing, not the case in\n> SpeedyMurmurs. We use the landmarks as a one-time setup and any node\n> could be a landmark.  In particular, every node in the network could be\n> the landmark if it is really DoS-sensitive. We just require that a\n> sender and a receiver have a non-empty intersection of the landmarks\n> that they have seen so far.\n>\n>\n> >\n> >    * If all payment flow *must* go through landmarks, and the transfers\n> >      within the network are relatively uni-directional (all payment going\n> >      to Candy Crush Ultra: Lighting Strikes Twice), then their\n> >      channels would become unbalanced very quickly.\n>\n> Again, this is true in the original landmark routing, not the case in\n> SpeedyMurmurs. Payments *must not* go through landmarks any longer with\n> our approach. Moreover, unbalanced payment channels are an issue to\n> consider independently of the routing algorithm that is in use.\n>\n> All in all, it seems that there might be some misconceptions and/or\n> aspects in the current draft of the paper that might need clarifications\n> so that the approach is well understood. We are more than happy to\n> further talk about it and answer questions, doubts or concerns that\n> might arise.\n>\n>\n> >\n> >\n> > The last point there invokes another component of the network: passive\n> > channel rebalancing. With source routing, it's possible for nodes to\n> > passive rebalance their channels, in order to keep the in equilibrium,\n> > such that on average they'll be able to handle a payment flow coming from\n> > any direction. This is possible as with source routing, it's easy for a\n> > node to simply send a payment to himself incoming/outgoing from the pair\n> > of channels they wish to adjust the available flow of. With\n> > distance-vector-like protocols, this doesn't seem possible, as the node\n> > doesn't have any control of the incoming channel that the payment will\n> > arrive on.\n> >\n> I think this is another case of mixing functionalities at different\n> layers. I do agree that unbalanced channels is an interesting problem to\n> deal with. I, however, do not agree that we should choose one routing\n> approach or another based on how unbalanced channels are handled.\n>\n> In my understanding, what you propose requires several assumptions: (i)\n> the node should be aware of \u201cenough\u201d network topology so that it is\n> aware of those \u201cspecial topology shapes\u201d. However, if opening channel\n> operations are indistinguishable from other payments in the Bitcoin\n> blockchain, this is not trivial. However, company X might not want to\n> reveal its channel with company Y to its competitors; (ii) such\n> circular/suitable paths actually exist. However, this might just not be\n> the case. (iii) The chosen path(s) has enough liquidity for the\n> \u201cequilibrium\u201d. As the node is not aware of the current capacity of each\n> of the channels, it might be the case that several payments are required\n> for the equilibrium to happen.\n>\n> In any case, my point is not to discuss whether the problem of\n> unbalanced channels is interesting. My point is that I think we should\n> not stick to one routing algorithm depending on how another\n> algorithm/functionality at another layer is handled, at least not before\n> we explore and fully understand the tradeoffs, benefits and\n> impossibilities that we will have to face here.\n>\n> >\n> > Finally, the notion of value privacy within the scheme seems a bit weak.\n> > From this definition, any protocol that didn't broadcast intents to send\n> > payments to the world would achieve this trait. The base Bitcoin\n> > blockchain doesn't mask the values of transfers (yet), but even if it did\n> > unconditionally maintaining value privacy of channel doesn't seem\n> > compatible with multi-hop payment networks (nodes can simply perform\n> > probing/tagging attacks to ascertain a range of the size of a channel). A\n> > possible mitigation would be for nodes to probabilistically drop incoming\n> > payments, with all nodes sampling from the same distribution. However,\n> > this would dramatically increase routing failures by senders, removing\n> the\n> > \"low-latency\" trait of payment networks that many find desirable.\n> >\n> I totally agree with you here. I believe that having stronger notions of\n> value privacy is conceptually hard. Imagine that the payment value must\n> be routed through the path from sender to the receiver. In particular,\n> any intermediate node must know what value is receiving from its\n> predecessor to forward the corresponding value to the successor node in\n> the path.\n> >\n> > Personally, I've very excited to see additional research on the front of\n> > routing within the network! Excellent work by all authors.\n>\n> Thanks. Really looking forward for further conversations and discussions.\n>\n> >\n> >\n> > In the end, I don't think it'll be a one-size fits all solution, as each\n> > routing protocol delivers with it a set of tradeoffs that should be\n> > weighed depending on target characteristics, and use-cases. There's no\n> > strong requirement that the network as a whole uses a *single* routing\n> > protocol. Instead several distinct protocols can be deployed based on\n> > use-case requirements, as we only need to share a single end-to-end\n> > construct: the HTLC. I could see a future in a few years where we have\n> > several deployed protocols, similar to the wide array of existing routing\n> > protocols deployed on the Internet. What we have currently gets us from\n> > Zero to One. We'll definitely need to experiment with additional\n> > approaches as the size of the network grows, and the true economic flow\n> > patterns emerge after we all deploy to mainnet.\n> >\n> I also agree with you here. I also think that there might be several\n> routing approaches at the routing layer, the same way we have BGP, OSPF,\n> RIP protocols for routing in IP today. I also believe that we might have\n> more than just HTLC-based payments in the LN, but this is the topic for\n> another long email :)\n>\n> Many thanks again for the feedback and looking forward for more\n> conversations,\n> Pedro.\n>\n> >\n> > -- Laolu\n> >\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171215/fd7e1429/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "General question on routing difficulties",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 27058
        }
    },
    {
        "title": "[Lightning-dev] General questions about channels",
        "thread_messages": [
            {
                "author": "Andy Schroder",
                "date": "2017-12-17T06:01:39",
                "message_text_only": "What's the rational for using millisatoshis as the units for lightning \nchannels? Aren't you going to loose up to 1/2 of a satoshi when the \nchannel is closed? Is this because it doesn't hurt and you might as well \nbe open to the opportunity for these sub satoshi transactions, because \nif you aren't, you are giving up the opportunity to get accumulated \nrevenue from many of those small transactions, that could end up being \ngreater than 1/2 of a satoshi?\n\nSince millisatoshis is used, is there a maximum channel funding size?\n\nIs the optional initial push of millisatoshis during the channel \ncreation there in order to motivate the other party to be willing to \nwaste their time with the channel creation in the first place? If not, \nwhat's it for?\n\nIn all of the clients that I've looked at, I can't seem to find out how \nto define the timeout closing out a channel when someone does not \ncooperate. Is there a fixed value for this as part of the protocol? Or \ndo most clients have a default that they enforce over all channels that \nthey create?\n\nThanks,\n\n-- \nAndy Schroder"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-12-18T18:40:20",
                "message_text_only": "Andy Schroder <info at AndySchroder.com> writes:\n> What's the rational for using millisatoshis as the units for lightning \n> channels? Aren't you going to loose up to 1/2 of a satoshi when the \n> channel is closed?\n\nYou can lose up to 0.999 satoshi per in-progress payment, yes.  BOLT #3:\n\n    The amounts for each output MUST be rounded down to whole satoshis.\n\n> Is this because it doesn't hurt and you might as well \n> be open to the opportunity for these sub satoshi transactions, because \n> if you aren't, you are giving up the opportunity to get accumulated \n> revenue from many of those small transactions, that could end up being \n> greater than 1/2 of a satoshi?\n\nIn practice, payments of less than a few thousand satoshi are\nimpractical, as they cost more than that to spend.  Channel closing\ncosts dwarf the gains to be made from cheating, however.\n\n> Since millisatoshis is used, is there a maximum channel funding size?\n\nYes, the upper 32 bits must be zero, from BOLT #2:\n\n  - for channels with `chain_hash` identifying the Bitcoin blockchain:\n    - MUST set the four most significant bytes of `amount_msat` to 0.\n\nThis gives a maximum HTLC value of .04294967295 BTC, which, back when\nwe started, was about $10.\n\n> Is the optional initial push of millisatoshis during the channel \n> creation there in order to motivate the other party to be willing to \n> waste their time with the channel creation in the first place? If not, \n> what's it for?\n\nIt's for the common case where you want to connect to someone and\nmake a payment immediately.  I'm not sure how widely it will be used,\nthough.  It's also the only mechanism for the payer to have *zero* funds\nin channel (ie. below reserve).\n\n> In all of the clients that I've looked at, I can't seem to find out how \n> to define the timeout closing out a channel when someone does not \n> cooperate. Is there a fixed value for this as part of the protocol? Or \n> do most clients have a default that they enforce over all channels that \n> they create?\n\nIf there's no in-progress payment, there's no reason to close a channel\nto an unreachable peer, unless you want to abandon the channel and get\nthe funds back.\n\nIf there is, BOLT #2 has you covered:\n\n        https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-8\n\nHope that helps,\nRusty."
            },
            {
                "author": "Andy Schroder",
                "date": "2017-12-27T05:18:22",
                "message_text_only": "Andy Schroder\n\nOn 12/18/2017 01:40 PM, Rusty Russell wrote:\n> Andy Schroder <info at AndySchroder.com> writes:\n>> What's the rational for using millisatoshis as the units for lightning\n>> channels? Aren't you going to loose up to 1/2 of a satoshi when the\n>> channel is closed?\n> You can lose up to 0.999 satoshi per in-progress payment, yes.  BOLT #3:\n>\n>      The amounts for each output MUST be rounded down to whole satoshis.\n\nOkay, round down, not regular rounding!\n\n\n>\n>> Is this because it doesn't hurt and you might as well\n>> be open to the opportunity for these sub satoshi transactions, because\n>> if you aren't, you are giving up the opportunity to get accumulated\n>> revenue from many of those small transactions, that could end up being\n>> greater than 1/2 of a satoshi?\n> In practice, payments of less than a few thousand satoshi are\n> impractical, as they cost more than that to spend.\n\nThey are impractical even on the lightning network?\n\n\n\n\n> Channel closing\n> costs dwarf the gains to be made from cheating, however.\n>\n>> Since millisatoshis is used, is there a maximum channel funding size?\n> Yes, the upper 32 bits must be zero, from BOLT #2:\n>\n>    - for channels with `chain_hash` identifying the Bitcoin blockchain:\n>      - MUST set the four most significant bytes of `amount_msat` to 0.\n>\n> This gives a maximum HTLC value of .04294967295 BTC, which, back when\n> we started, was about $10.\n\nWhat's the point of wasting the upper 32 bits? Seems like this is a \nwaste of data?\n\nIf you have the lower 32 bits of data to use, and 2^32=4,294,967,296, \nthen you have 4,294,967,296 milli satoshis. 1 BTC=10^11 milli satoshis, \nso 4,294,967,296 milli satoshis/((10^11 milli satoshis)/1BTC) = \n0.04294967296 BTC. That is off by 1 milli satoshi from what you say \nabove. Why is this?\n\nRegardless of the discrepancy of 1 milli satoshi, it still seems like \n0.04294967296 BTC is kind of a low maximum channel size for a lot of \nbusiness applications. Why do you want to limit this when you have those \nextra 4 bytes set to zero? You think any more is too much to safely have \nin a hot wallet? You felt keeping it low will encourage \ndecentralization? Something else?\n\n\nIs the max HTLC value the same as the maximum channel size?\n\n\n\n>\n>> Is the optional initial push of millisatoshis during the channel\n>> creation there in order to motivate the other party to be willing to\n>> waste their time with the channel creation in the first place? If not,\n>> what's it for?\n> It's for the common case where you want to connect to someone and\n> make a payment immediately.  I'm not sure how widely it will be used,\n> though.  It's also the only mechanism for the payer to have *zero* funds\n> in channel (ie. below reserve).\n\nWhy would you ever want to start up a channel and immediately have zero \nfunds in reserve? If you are doing that, why not just make a blockchain \ntransaction?\n\n\n>\n>> In all of the clients that I've looked at, I can't seem to find out how\n>> to define the timeout closing out a channel when someone does not\n>> cooperate. Is there a fixed value for this as part of the protocol? Or\n>> do most clients have a default that they enforce over all channels that\n>> they create?\n> If there's no in-progress payment, there's no reason to close a channel\n> to an unreachable peer, unless you want to abandon the channel and get\n> the funds back.\n>\n> If there is, BOLT #2 has you covered:\n>\n>          https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-8\n\n\nOkay, so every time you get a new HTLC, your client can change the \ntimeout that you require for closing the channel, which will control how \nlong it takes you to abandon the channel and get your funds back when \nthe peer is unreachable? Or is that set during initial channel creation \nonly?\n\n\n\n>\n> Hope that helps,\n> Rusty.\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-27T05:56:54",
                "message_text_only": "Good morning Andy,\n\n>\n>\n>> Channel closing\n>> costs dwarf the gains to be made from cheating, however.\n>>\n>>> Since millisatoshis is used, is there a maximum channel funding size?\n>>> Yes, the upper 32 bits must be zero, from BOLT #2:\n>>\n>> - for channels with chain_hash identifying the Bitcoin blockchain:\n>>\n>> - MUST set the four most significant bytes of amount_msat to 0.\n>>\n>> This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>> we started, was about $10.\n>\n> What's the point of wasting the upper 32 bits? Seems like this is a\n> waste of data?\n\nThe specs are intended to eventually support other similar cryptocurrencies, such as Litecoin.  For those currencies, payments of hundreds of whole coins may be practical, and thus the 0.042 limit is not imposed.  For Bitcoin only, the limit is applied.  This simplifies the design of software by only imposing a limit to a large field under certain conditions (i.e. for Bitcoin) while retaining the same format for all coins.  Other cryptocurrencies may have different imposed limits when Lightning gets around to those.\n\n>\n> If you have the lower 32 bits of data to use, and 2^32=4,294,967,296,\n> then you have 4,294,967,296 milli satoshis. 1 BTC=10^11 milli satoshis,\n> so 4,294,967,296 milli satoshis/((10^11 milli satoshis)/1BTC) =\n> 0.04294967296 BTC. That is off by 1 milli satoshi from what you say\n> above. Why is this?\n\nYou have an off-by-one error.  The largest number representable by 32 bits is 2^32 - 1, not 2^32.\n\n>\n> Regardless of the discrepancy of 1 milli satoshi, it still seems like\n> 0.04294967296 BTC is kind of a low maximum channel size for a lot of\n> business applications. Why do you want to limit this when you have those\n> extra 4 bytes set to zero? You think any more is too much to safely have\n> in a hot wallet? You felt keeping it low will encourage\n> decentralization? Something else?\n\nThis is not the channel size.  This is the payment size limit.  The channel size limit is 0.16777215 BTC, or 16777215 satoshi (2^24 - 1).\n\nA single payment can be up to 0.04294967295, but a channel is up to 0.16777215.\n\n>\n> Is the max HTLC value the same as the maximum channel size?\n\nNo\n\n>\n>\n>>> Is the optional initial push of millisatoshis during the channel\n>>> creation there in order to motivate the other party to be willing to\n>>> waste their time with the channel creation in the first place? If not,\n>>> what's it for?\n>>> It's for the common case where you want to connect to someone and\n>>> make a payment immediately. I'm not sure how widely it will be used,\n>>> though. It's also the only mechanism for the payer to have zero funds\n>>> in channel (ie. below reserve).\n>\n> Why would you ever want to start up a channel and immediately have zero\n> funds in reserve? If you are doing that, why not just make a blockchain\n> transaction?\n\nAn exchange might support this.  You buy for example 100USD worth of BTC and indicate a desire to open a new channel between your node to the exchange's.  The exchange opens the channel with your node and specifies the push_msat equivalent of 100USD minus fees to your node.  The exchange will want to do this because your new channel goes directly to the exchange and it can earn routing fees from your spending.  Presumably you want to do this so that you can spend your 100USD on Lightning for things within a short time frame.\n\nThe alternative is to send the money from the exchange onchain to you, then for your node to open a new channel (not necessarily to the exchange, too, so the exchange loses the routing fees) with the onchain funds.  This is two onchain transactions (from exchange to you, and from your node to a Lightning channel), unlike the case where the exchange does a single open and reassigns the funds to you via push_msat.\n\nBoth you and the exchange would want to do this: the exchange wants this so it can capture your routing fees, you want this so that you do not even touch the chain at all and start out in Lightning in the first place.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/868f7521/attachment.html>"
            },
            {
                "author": "Andy Schroder",
                "date": "2017-12-27T06:18:23",
                "message_text_only": "Andy Schroder\n\nOn 12/27/2017 12:56 AM, ZmnSCPxj wrote:\n> Good morning Andy,\n>\n>>\n>>     Channel closing\n>>     costs dwarf the gains to be made from cheating, however.\n>>\n>>         Since millisatoshis is used, is there a maximum channel\n>>         funding size?\n>>         Yes, the upper 32 bits must be zero, from BOLT #2:\n>>\n>>      *\n>>         for channels with |chain_hash| identifying the Bitcoin\n>>         blockchain:\n>>           o MUST set the four most significant bytes of |amount_msat|\n>>             to 0.\n>>\n>>     This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>>     we started, was about $10.\n>>\n>>\n>> What's the point of wasting the upper 32 bits? Seems like this is a\n>> waste of data?\n>\n> The specs are intended to eventually support other similar \n> cryptocurrencies, such as Litecoin.  For those currencies, payments of \n> hundreds of whole coins may be practical, and thus the 0.042 limit is \n> not imposed.  For Bitcoin only, the limit is applied.  This simplifies \n> the design of software by only imposing a limit to a large field under \n> certain conditions (i.e. for Bitcoin) while retaining the same format \n> for all coins. Other cryptocurrencies may have different imposed \n> limits when Lightning gets around to those.\n\nIt seems like you are making assumptions about the purchasing power of \ncertain cryptocurrencies. Why even bother doing this? You have no idea \nwhat the future holds. Why set a limit for any cryptocurrency that might \nuse lightning?\n\nEven if you are right about the purchasing power of a particular \ncryptocurrency, why is a limit needed at all? If I have an high, bi \nweekly paid salary, and I have a low budget lifestyle, let's say I save \n90% of my income. It seems like your assumed limits could require \nmultiple payments and multiple open channels for each bi weekly payment. \nWhat if I want to buy a boat, do you expect me to make payments from a \nlot of different channels? I was kind of under the assumption that the \nlong term goal of lightning was only to have a few on chain payments per \nhuman per year.\n\nOr, are you just worried right now because lightning isn't well tested?\n\n\n\n>\n>>\n>> If you have the lower 32 bits of data to use, and 2^32=4,294,967,296,\n>> then you have 4,294,967,296 milli satoshis. 1 BTC=10^11 milli satoshis,\n>> so 4,294,967,296 milli satoshis/((10^11 milli satoshis)/1BTC) =\n>> 0.04294967296 BTC. That is off by 1 milli satoshi from what you say\n>> above. Why is this?\n>>\n>\n> You have an off-by-one error.  The largest number representable by 32 \n> bits is 2^32 - 1, not 2^32.\n\nOkay, thanks for the clarification.\n\n>\n>>\n>> Regardless of the discrepancy of 1 milli satoshi, it still seems like\n>> 0.04294967296 BTC is kind of a low maximum channel size for a lot of\n>> business applications. Why do you want to limit this when you have those\n>> extra 4 bytes set to zero? You think any more is too much to safely have\n>> in a hot wallet? You felt keeping it low will encourage\n>> decentralization? Something else?\n>>\n>\n> This is not the channel size.  This is the payment size limit.  The \n> channel size limit is 0.16777215 BTC, or 16777215 satoshi (2^24 - 1).\n>\n> A single payment can be up to 0.04294967295, but a channel is up to \n> 0.16777215.\n\nOkay, so why bother making these two amounts different?\n\n>\n>>\n>> Is the max HTLC value the same as the maximum channel size?\n>>\n>>\n>\n> No\n>\n>>\n>>         Is the optional initial push of millisatoshis during the channel\n>>         creation there in order to motivate the other party to be\n>>         willing to\n>>         waste their time with the channel creation in the first\n>>         place? If not,\n>>         what's it for?\n>>         It's for the common case where you want to connect to someone and\n>>         make a payment immediately. I'm not sure how widely it will\n>>         be used,\n>>         though. It's also the only mechanism for the payer to have\n>>         /zero/ funds\n>>         in channel (ie. below reserve).\n>>\n>>\n>> Why would you ever want to start up a channel and immediately have zero\n>> funds in reserve? If you are doing that, why not just make a blockchain\n>> transaction?\n>>\n>\n> An exchange might support this.  You buy for example 100USD worth of \n> BTC and indicate a desire to open a new channel between your node to \n> the exchange's.  The exchange opens the channel with your node and \n> specifies the push_msat equivalent of 100USD minus fees to your node.  \n> The exchange will want to do this because your new channel goes \n> directly to the exchange and it can earn routing fees from your \n> spending.  Presumably you want to do this so that you can spend your \n> 100USD on Lightning for things within a short time frame.\n>\n> The alternative is to send the money from the exchange onchain to you, \n> then for your node to open a new channel (not necessarily to the \n> exchange, too, so the exchange loses the routing fees) with the \n> onchain funds.  This is two onchain transactions (from exchange to \n> you, and from your node to a Lightning channel), unlike the case where \n> the exchange does a single open and reassigns the funds to you via \n> push_msat.\n>\n> Both you and the exchange would want to do this: the exchange wants \n> this so it can capture your routing fees, you want this so that you do \n> not even touch the chain at all and start out in Lightning in the \n> first place.\n\nOkay, so all this feature is doing is saving the extra step of making an \ninitial payment? Just saving a little time, and not a monumental or \nrequired feature?\n\nThanks,\nAndy Schroder\n\n\n>\n> Regards,\n> ZmnSCPxj\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/8e8c3749/attachment.html>"
            },
            {
                "author": "Andy Schroder",
                "date": "2017-12-27T05:58:29",
                "message_text_only": "Andy Schroder\n\nOn 12/27/2017 12:18 AM, Andy Schroder wrote:\n>> Channel closing\n>> costs dwarf the gains to be made from cheating, however.\n>>\n>>> Since millisatoshis is used, is there a maximum channel funding size?\n>> Yes, the upper 32 bits must be zero, from BOLT #2:\n>>\n>>    - for channels with `chain_hash` identifying the Bitcoin blockchain:\n>>      - MUST set the four most significant bytes of `amount_msat` to 0.\n>>\n>> This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>> we started, was about $10.\n>\n> What's the point of wasting the upper 32 bits? Seems like this is a \n> waste of data?\n>\n> If you have the lower 32 bits of data to use, and 2^32=4,294,967,296, \n> then you have 4,294,967,296 milli satoshis. 1 BTC=10^11 milli \n> satoshis, so 4,294,967,296 milli satoshis/((10^11 milli \n> satoshis)/1BTC) = 0.04294967296 BTC. That is off by 1 milli satoshi \n> from what you say above. Why is this?\n>\n> Regardless of the discrepancy of 1 milli satoshi, it still seems like \n> 0.04294967296 BTC is kind of a low maximum channel size for a lot of \n> business applications. Why do you want to limit this when you have \n> those extra 4 bytes set to zero? You think any more is too much to \n> safely have in a hot wallet? You felt keeping it low will encourage \n> decentralization? Something else?\n>\n>\n> Is the max HTLC value the same as the maximum channel size? \n\nOkay, so I may have discovered part of this answer to this question in \nBOLT 2 where it says: \"MUST set |funding_satoshis| to less than 2^24 \nsatoshi\". However, I still don't understand the rational of why |max \n||funding_satoshis doesn't equal max |amount_msat, or where the values \nof (2^24)*10^3 and 2^32 milli satoshis came from. Also, why don't you \nuse units of millisatoshis everywhere in the spec? Sometimes it's \nsatoshis and sometimes it's milli satoshis.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/f270ce79/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-27T06:06:17",
                "message_text_only": "Good morning Andy,\n\n> Andy Schroder\n>\n> On 12/27/2017 12:18 AM, Andy Schroder wrote:\n>\n>>> Channel closing\n>>> costs dwarf the gains to be made from cheating, however.\n>>>\n>>>> Since millisatoshis is used, is there a maximum channel funding size?\n>>>\n>>> Yes, the upper 32 bits must be zero, from BOLT #2:\n>>>\n>>>    - for channels with `chain_hash` identifying the Bitcoin blockchain:\n>>>      - MUST set the four most significant bytes of `amount_msat` to 0.\n>>>\n>>> This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>>> we started, was about $10.\n>>\n>> What's the point of wasting the upper 32 bits? Seems like this is a waste of data?\n>>\n>> If you have the lower 32 bits of data to use, and 2^32=4,294,967,296, then you have 4,294,967,296 milli satoshis. 1 BTC=10^11 milli satoshis, so 4,294,967,296 milli satoshis/((10^11 milli satoshis)/1BTC) = 0.04294967296 BTC. That is off by 1 milli satoshi from what you say above. Why is this?\n>>\n>> Regardless of the discrepancy of 1 milli satoshi, it still seems like 0.04294967296 BTC is kind of a low maximum channel size for a lot of business applications. Why do you want to limit this when you have those extra 4 bytes set to zero? You think any more is too much to safely have in a hot wallet? You felt keeping it low will encourage decentralization? Something else?\n\nYes, I believe Rusty did indeed consider 42mBTC as a reasonable amount to transfer on Lightning.  So that in case of trouble on Lightning, not a lot of money gets lost.  At the time he decided this 42mBTC limit, it was about 10 USD only, so Rusty could always just buy you a drink if he somehow causes c-lightning to lose that much.\n\nOf course, 42mBTC today is much larger.\n\nFor myself, I think the channel limit of 167mBTC is good as it encourages decentralization by encouraging people to make many small channels than one large channel. Many small channels helps in keeping your funds resilient against temporary outages of your fellow nodes.\n\n>> Is the max HTLC value the same as the maximum channel size?\n>\n> Okay, so I may have discovered part of this answer to this question in BOLT 2 where it says: \"MUST setfunding_satoshis to less than 2^24 satoshi\". However, I still don't understand the rational of why max funding_satoshis doesn't equal max amount_msat, or where the values of (2^24)*10^3 and 2^32 milli satoshis came from. Also, why don't you use units of millisatoshis everywhere in the spec? Sometimes it's satoshis and sometimes it's milli satoshis.\n\nThis is actually very simple. Everything that touches the chain (opening and closing) uses satoshis. Everything that does not, uses millisatoshis.  This is because the chain uses satoshis as the smallest amount.  Offchain, we can use millisatoshis, and it is used everywhere offchain.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/e23d2aba/attachment-0001.html>"
            },
            {
                "author": "Andy Schroder",
                "date": "2017-12-27T06:27:12",
                "message_text_only": "Andy Schroder\n\nOn 12/27/2017 01:06 AM, ZmnSCPxj wrote:\n> Good morning Andy,\n>\n>> Andy Schroder\n>> On 12/27/2017 12:18 AM, Andy Schroder wrote:\n>>>> Channel closing\n>>>> costs dwarf the gains to be made from cheating, however.\n>>>>\n>>>>\n>>>>> Since millisatoshis is used, is there a maximum channel funding size?\n>>>> Yes, the upper 32 bits must be zero, from BOLT #2:\n>>>>\n>>>>    - for channels with `chain_hash` identifying the Bitcoin \n>>>> blockchain:\n>>>>      - MUST set the four most significant bytes of `amount_msat` to 0.\n>>>>\n>>>> This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>>>> we started, was about $10.\n>>>>\n>>>\n>>> What's the point of wasting the upper 32 bits? Seems like this is a \n>>> waste of data?\n>>>\n>>> If you have the lower 32 bits of data to use, and \n>>> 2^32=4,294,967,296, then you have 4,294,967,296 milli satoshis. 1 \n>>> BTC=10^11 milli satoshis, so 4,294,967,296 milli satoshis/((10^11 \n>>> milli satoshis)/1BTC) = 0.04294967296 BTC. That is off by 1 milli \n>>> satoshi from what you say above. Why is this?\n>>>\n>>> Regardless of the discrepancy of 1 milli satoshi, it still seems \n>>> like 0.04294967296 BTC is kind of a low maximum channel size for a \n>>> lot of business applications. Why do you want to limit this when you \n>>> have those extra 4 bytes set to zero? You think any more is too much \n>>> to safely have in a hot wallet? You felt keeping it low will \n>>> encourage decentralization? Something else?\n>>>\n>\n> Yes, I believe Rusty did indeed consider 42mBTC as a reasonable amount \n> to transfer on Lightning.  So that in case of trouble on Lightning, \n> not a lot of money gets lost.  At the time he decided this 42mBTC \n> limit, it was about 10 USD only, so Rusty could always just buy you a \n> drink if he somehow causes c-lightning to lose that much.\n>\n> Of course, 42mBTC today is much larger.\n>\n> For myself, I think the channel limit of 167mBTC is good as it \n> encourages decentralization by encouraging people to make many small \n> channels than one large channel. Many small channels helps in keeping \n> your funds resilient against temporary outages of your fellow nodes.\n\nI understand what you are saying about decentralization, but is this \nreally something that will be enforceable? Seems like people will just \nmake an alt-lightning network layer with different limits to get around \nthis, since there isn't really a consensus rule set like on the block \nchain to motivate them.\n\n\n>\n>>>\n>>> Is the max HTLC value the same as the maximum channel size?\n>>\n>> Okay, so I may have discovered part of this answer to this question \n>> in BOLT 2 where it says: \"MUST set|funding_satoshis| to less than \n>> 2^24 satoshi\". However, I still don't understand the rational of why \n>> |max ||funding_satoshis doesn't equal max |amount_msat, or where the \n>> values of (2^24)*10^3 and 2^32 milli satoshis came from. Also, why \n>> don't you use units of millisatoshis everywhere in the spec? \n>> Sometimes it's satoshis and sometimes it's milli satoshis.\n>>\n>\n> This is actually very simple. Everything that touches the chain \n> (opening and closing) uses satoshis. Everything that does not, uses \n> millisatoshis.  This is because the chain uses satoshis as the \n> smallest amount.  Offchain, we can use millisatoshis, and it is used \n> everywhere offchain.\n\nOkay, the unit choices now make sense!\n\n\n>\n> Regards,\n> ZmnSCPxj\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/51e762f0/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-27T10:37:04",
                "message_text_only": "Good morning Andy,\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] General questions about channels\n> Local Time: December 27, 2017 2:27 PM\n> UTC Time: December 27, 2017 6:27 AM\n> From: info at AndySchroder.com\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> Rusty Russell <rusty at rustcorp.com.au>, lightning-dev at lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n>\n> Andy Schroder\n>\n> On 12/27/2017 01:06 AM, ZmnSCPxj wrote:\n>\n>> Good morning Andy,\n>>\n>>> Andy Schroder\n>>>\n>>> On 12/27/2017 12:18 AM, Andy Schroder wrote:\n>>>\n>>>>> Channel closing\n>>>>> costs dwarf the gains to be made from cheating, however.\n>>>>>\n>>>>>> Since millisatoshis is used, is there a maximum channel funding size?\n>>>>>\n>>>>> Yes, the upper 32 bits must be zero, from BOLT #2:\n>>>>>\n>>>>>    - for channels with `chain_hash` identifying the Bitcoin blockchain:\n>>>>>      - MUST set the four most significant bytes of `amount_msat` to 0.\n>>>>>\n>>>>> This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>>>>> we started, was about $10.\n>>>>\n>>>> What's the point of wasting the upper 32 bits? Seems like this is a waste of data?\n>>>>\n>>>> If you have the lower 32 bits of data to use, and 2^32=4,294,967,296, then you have 4,294,967,296 milli satoshis. 1 BTC=10^11 milli satoshis, so 4,294,967,296 milli satoshis/((10^11 milli satoshis)/1BTC) = 0.04294967296 BTC. That is off by 1 milli satoshi from what you say above. Why is this?\n>>>>\n>>>> Regardless of the discrepancy of 1 milli satoshi, it still seems like 0.04294967296 BTC is kind of a low maximum channel size for a lot of business applications. Why do you want to limit this when you have those extra 4 bytes set to zero? You think any more is too much to safely have in a hot wallet? You felt keeping it low will encourage decentralization? Something else?\n>>\n>> Yes, I believe Rusty did indeed consider 42mBTC as a reasonable amount to transfer on Lightning.  So that in case of trouble on Lightning, not a lot of money gets lost.  At the time he decided this 42mBTC limit, it was about 10 USD only, so Rusty could always just buy you a drink if he somehow causes c-lightning to lose that much.\n>>\n>> Of course, 42mBTC today is much larger.\n>>\n>> For myself, I think the channel limit of 167mBTC is good as it encourages decentralization by encouraging people to make many small channels than one large channel. Many small channels helps in keeping your funds resilient against temporary outages of your fellow nodes.\n>\n> I understand what you are saying about decentralization, but is this really something that will be enforceable? Seems like people will just make an alt-lightning network layer with different limits to get around this, since there isn't really a consensus rule set like on the block chain to motivate them.\n\nIf I run a node which refuses the higher limits, then:\n\n1. The alt-lightning network node cannot channel to me directly to unless they accept my channel size limit. (they will have to channel through a node that will accept my channel size limit and also accept their increased channel size limit, or just never open a channel to me greater than 167mBTC).\n2.  The alt-lightning network node cannot route through me unless they accept my payment size (HTLC size) limit.\n3.  I won't route through the alt-lightning network for any value greater than my payment size limit.\n\nMaking Lightning software work is difficult, and given the above constraints it will not be as easy as \"just remove the limit-checking code\" - the alt-lightning network node software is strictly more complicated as it has to check if it is using or creating a channel that has the existing limits imposed or not: indeed, if most of the existing network uses the existing limits, then the alt-lightning node is still practically limited to the 42mBTC limit when routing through the existing network (and the alt-lightning network might not be big enough to find routes through only the alt-lightning nodes - if it has to pass through even one legacy node imposing the 42mBTC limit, then the payment is automatically limited by that node). One might compare the supposedly simple \"just change the constant to 2x its value\" attempted by 2X, when in reality what happens is the more complicated \"change the constant to a variable that has the old value on or before before block N and a new value on or after block N+1\", which also failed rather spectacularly due to off-by-one error..\n\nIndeed, such a \"whale Lightning network\" might be feasible if all the whales channel with each other, but at some point they will have to pay some hoi polloi node imposing the 42mBTC limit.  If I am not a whale and will not be able to send or receive large amounts of bitcoin anyway, I have no real incentive to run a whalenode whose expanded capabilities I would not be able to utilize anyway.  Further, wise whales will keep most of their money in cold storage and only put small spending amounts on hot wallets, which Lightning nodes most definitely are, since they keep the keys on an online computer; there is still no incentive to run a whalenode either.\n\nSo it might be that one day we will remove the limit and find that nobody in practice uses the expanded capacity either.\n\n> It seems like you are making assumptions about the purchasing power of certain cryptocurrencies. Why even bother doing this? You have no idea what the future holds. Why set a limit for any cryptocurrency that might use lightning?\n\nWell, the truth of the matter is that originally, the field was 32-bit and not 64-bit.  Rusty decided that the 42mBTC limit this imposed was A-OK since it would limit the risk involved if payments get stuck to about 10USD at the time, and so on.\n\nWhen Rusty & friends made a \"Litening\" network node (Lightning on Litecoin) 32-bits was not enough for anything practical, since 0.042LTC is really low in value.  So the field was expanded to 64-bit, but for BTC the 42mBTC limit was still imposed by requiring, for BTC only, that the upper 32-bits be 0.\n\nSimilar for the channel limit (it was originally 24-bit only, and was expanded for Litening and the original limit re-imposed specifically for BTC).\n\n> Even if you are right about the purchasing power of a particular cryptocurrency, why is a limit needed at all? If I have an high, bi weekly paid salary, and I have a low budget lifestyle, let's say I save 90% of my income. It seems like your assumed limits could require multiple payments and multiple open channels for each bi weekly payment. What if I want to buy a boat, do you expect me to make payments from a lot of different channels? I was kind of under the assumption that the long term goal of lightning was only to have a few on chain payments per human per year.\n>\n> Or, are you just worried right now because lightning isn't well tested?\n\nPartially this, also.  Lightning is still alpha-level to beta-level software and we want to \"start soft\".  Perhaps some day, in the LONG TERM, the limits may be increased (but in practice it will take time before all nodes upgrade to higher limits, and the existing channels will have to be re-consolidated and so on).\n\nThere is also again the wisdom, that one should keep most of the funds in cold storage, and only a small amount for spending in hot wallets like Lightning nodes; presumably, rare purchases of boats (which I doubt you would want to buy daily) would be doable on-chain straight from cold storage, even with just \"a few on chain payments per human per year\" - even really rich people are likely to buy at a rate of one new car and/or one new boat each year because seriously what would you do with it, so that is still \"a few on chain transactions per year\".\n\nAs for salary accumulation - well indeed, perhaps a higher channel limit would be useful here, but again maybe after a few months you might want to withdraw to  cold storage - as a hot wallet any unexpected 0-days of Lightning software, the hardware you run on, and the operating system you run on, might lose you several months' worth of salary if you kept it on Lightning. You might prefer to receive your salary once a month, put the first month into Lightning and the succeeding months directly into cold storage, until you need to replenish your Lightning funds for groceries.  And so on. Perhaps salary-conversion services (since governments are likely to require your salary be denominated in the local fiat because government) would replenish part of your Lightning funds for you, then forward the rest to your cold storage.\n\n>> A single payment can be up to 0.04294967295, but a channel is up to 0.16777215.\n>\n> Okay, so why bother making these two amounts different?\n\nWhy should they be the same? Should not the channel be able to survive one or two or three 0.042 payments, so the channel limit being 0.167 is just shy of being able to fit 4 max-size payments through it?\n\nIf the two limits were the same, then in practice nobody could use the maximum payment limit.  One must also factor in the \"channel reserve\" and the fact that most of the time it is likely that the channel will be in a \"halfway\" state between the two nodes (i.e. about 83.88mBTC each).  So it is sensible to make the channel limit higher than the payment limit, so that in practice many max-size payments will go through.\n\n> <snip push_msat>\n>\n> Okay, so all this feature is doing is saving the extra step of making an initial payment? Just saving a little time, and not a monumental or required feature?\n\nYes.  Indeed to my knowledge no current LN software implements non-zero push_msat.  It might be useful, it might not be.  The option is there and is supported, especially since support for it is relatively trivial (one only need adjust the initial commitment transactions).\n\nWe are a lot less strict about channel opening message bloat as channel opening is expected to be a rare event, so optimizing these \"wasted always 0 bytes\" in the channel opening messages is not a high priority.  Gossip messages are more likely to be strictly optimized.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/cca71d76/attachment-0001.html>"
            },
            {
                "author": "Daniel McNally",
                "date": "2017-12-27T14:30:28",
                "message_text_only": "I've only really been getting my hands into LN the past few weeks but\nI thought I'd share my thoughts here.\n\nZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> Perhaps some day, in the LONG TERM, the limits may be increased\n\nI was always under the impression that the channel and payment limits\nwere intended to be training wheels, this is the first I've heard of\nthem intended to stick around long term. I find the channel limit to\nbe particularly restrictive, as it hinders some use cases I'd envision\nwhere large payment channels between two parties are useful and can\nalso be used for routing LN payments. Large payments afaik can be\nbroken up into smaller ones without incurring too much cost or\ntrouble, but that's not the case for creating channels. As the channel\nitself involves only two parties - and in sticking to my general\npolitical/philosophical mantra - there is really no justification for\nlimits to be imposed on this. Which brings me to my next point.\n\n> If I run a node which refuses the higher limits, then:\n>\n> 1. The alt-lightning network node cannot channel to me directly to unless\n> they accept my channel size limit. (they will have to channel through a node\n> that will accept my channel size limit and also accept their increased\n> channel size limit, or just never open a channel to me greater than\n> 167mBTC).\n\nThe parenthetical here is correct. If nodes A and B have huge channels\nbetween each other, they can still be totally compatible with the rest\nof the network as long as they don't try exceeding the channel limit\nwith nodes that won't accept it. In practice, \"whales\" will quite\neasily be able to run their own rules with regards to these limits and\nI think that is a good thing.\n\n> There is also again the wisdom, that one should keep most of the funds in\n> cold storage, and only a small amount for spending in hot wallets like\n> Lightning nodes\n\nI think this is a top-down way of thinking that runs counter to the\nspirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\nbuy inflation-adjusted treasury bonds and not mess with bitcoin at\nall, much less the experimental lightning network. As advice this is\nperfectly fine to share with others for them to follow on a voluntary\nbasis, but I don't see why this ought to be enforced as a rule on a\nprotocol level.\n\nAlso, I personally can't see a reason why a node would reject a large\nchannel being made with it, where is the downside or risk? The party\ncommitting funds to the channel is the one risking loss or delay of\nfunds.\n\n> Yes.  Indeed to my knowledge no current LN software implements non-zero\n> push_msat\n\nAs an aside, I believe push_sat is implemented by LND.\n\nAnyway, I think these limits are fine for LN's baby steps, but overly\nrestrictive for a mature LN network. Ideally I believe I'd want these\nlimits to be non-existent or configurable by nodes (and announced to\npeers), but maybe I am missing some technical reasons why such an\napproach would be challenging. Either way I expect I'll be among the\nfirst to run software with less restrictive limits when LN's training\nwheels are ready to come off.\n\nThanks for the discussion and for your work on LN.\n\nDaniel"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-27T20:13:21",
                "message_text_only": "Good morning Daniel,\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] General questions about channels\n> Local Time: December 27, 2017 10:30 PM\n> UTC Time: December 27, 2017 2:30 PM\n> From: therealsangaman at gmail.com\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> Andy Schroder <info at andyschroder.com>, lightning-dev at lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n>\n> I've only really been getting my hands into LN the past few weeks but\n> I thought I'd share my thoughts here.\n>\n> ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org wrote:\n>\n>> Perhaps some day, in the LONG TERM, the limits may be increased\n>\n> I was always under the impression that the channel and payment limits\n> were intended to be training wheels, this is the first I've heard of\n> them intended to stick around long term. I find the channel limit to\n> be particularly restrictive, as it hinders some use cases I'd envision\n> where large payment channels between two parties are useful and can\n> also be used for routing LN payments. Large payments afaik can be\n> broken up into smaller ones without incurring too much cost or\n> trouble,\n\nSplitting up large payments would require multiple invoices at least for now (whether this is troublesome or not may be a matter of opinion, bit I suspect juggling more than a few invoices would be painful as a user experience). Routing larger payments over multiple routes automatically while using a single invoice, is harder as multiple routes need to be set up, and each route must have different preimages: further it is likely you want the entire large payment to be done atomically, which would be harder to arrange.\n\n> but that's not the case for creating channels. As the channel\n> itself involves only two parties - and in sticking to my general\n> political/philosophical mantra - there is really no justification for\n> limits to be imposed on this. Which brings me to my next point.\n\nPerhaps our definition of \"long term\" is askew. A year after mainnet release, I doubt anyone would feel safe implementing removal of the limit; this is my \"long term\".  Five years, I imagine quite a few will use the nonlimited version and may form a subnetwork among themselves.  But possibly by then it would be unlikely that most people using Bitcoin at all would evem be capable of putting 150 mBTC in spending money on a hot wallet, in which case whether there is a 167 mBTC limit per channel or not is largely a moot point. Or perhaps I simply imagine hyperbitcoinization by then, with people putting entire bitcoins into hot wallets equivalent to people putting thousands of USD today in their back pockets as invitation to be attacked.\n\n>\n>\n>> There is also again the wisdom, that one should keep most of the funds in\n>> cold storage, and only a small amount for spending in hot wallets like\n>> Lightning nodes\n>\n> I think this is a top-down way of thinking that runs counter to the\n> spirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\n> buy inflation-adjusted treasury bonds and not mess with bitcoin at\n> all, much less the experimental lightning network. As advice this is\n> perfectly fine to share with others for them to follow on a voluntary\n> basis, but I don't see why this ought to be enforced as a rule on a\n> protocol level.\n\nPossibly.  At the protocol level, a limit encourages the growth of the network towards a mesh network rather than more central forms, however.  I merely put this since it is unlikely that most people following this \"wisdom\" would have an incentive to even run software with the limit removed: that is, by the time Lightning becomes fully deployed the limit may not even be reached in practice.\n\n>\n> Also, I personally can't see a reason why a node would reject a large\n> channel being made with it, where is the downside or risk? The party\n> committing funds to the channel is the one risking loss or delay of\n> funds.\n\nBut the party committing funds to the channel is known via node gossip, and it is known also who the other end of the channel is. If you were to propose opening for example a 5BTC channel to me with the funds coming from you, I would consider the possibility that I might get attacked in order to get to your funds (and I might not have the resources to protect against such an attack on my end, even if you might). Further, putting 5BTC implies that at some point there is the future possibility, due to routing and so on, that the channel will have around 5BTC belonging to me, and at some point before you can spend the entire 5BTC I would want to close the channel and commit the funds that I now own into cold storage (so that the ability to channel 5BTC from you to me is a moot point).\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171227/fe1a36f2/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-12-28T10:38:54",
                "message_text_only": "Splitting a single payment into multiple invoices has bad semantic properties. Beyond implementation difficulties it also makes the payment no longer atomic. You can end up in a situation where part of a transaction has gone through but then channel capacity has been exhausted. The. What do you do?\n\nWhile an annoying (and potentially exploitable) edge case for payments, it also makes it basically impossible in practice to build higher level smart contracts on top of lightning channels as primitives, since those constructs typically use a single HTLC revelation as the decision gate between multiple contingent outcomes.\n\nI had always assumed the protocol limits were training wheels, and would be shocked and dismayed if that were not the case (and would immediately begin work on an alternative fork because such limits would make lightning useless for my intended applications).\n\nOn the topic of cold storage, I think perhaps that is less of a settled issue than you take for granted. I think the value proposition of bitcoin is exactly its ability to serve as non custodial collateral and I do not anticipate a future where large portions of the bitcoin monetary base are not held as collateral in smart contract payment channels. Indeed I would consider that a failure mode both worth designing for...\n\n> On Dec 27, 2017, at 12:13 PM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n> \n> Good morning Daniel,\n> \n> \n> \n>> -------- Original Message --------\n>> Subject: Re: [Lightning-dev] General questions about channels\n>> Local Time: December 27, 2017 10:30 PM\n>> UTC Time: December 27, 2017 2:30 PM\n>> From: therealsangaman at gmail.com\n>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>> Andy Schroder <info at andyschroder.com>, lightning-dev at lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n>> \n>> I've only really been getting my hands into LN the past few weeks but\n>> I thought I'd share my thoughts here.\n>>  \n>> ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org wrote:\n>> Perhaps some day, in the LONG TERM, the limits may be increased\n>>  \n>> I was always under the impression that the channel and payment limits\n>> were intended to be training wheels, this is the first I've heard of\n>> them intended to stick around long term. I find the channel limit to\n>> be particularly restrictive, as it hinders some use cases I'd envision\n>> where large payment channels between two parties are useful and can\n>> also be used for routing LN payments. Large payments afaik can be\n>> broken up into smaller ones without incurring too much cost or\n>> trouble,\n> \n> Splitting up large payments would require multiple invoices at least for now (whether this is troublesome or not may be a matter of opinion, bit I suspect juggling more than a few invoices would be painful as a user experience). Routing larger payments over multiple routes automatically while using a single invoice, is harder as multiple routes need to be set up, and each route must have different preimages: further it is likely you want the entire large payment to be done atomically, which would be harder to arrange.\n> \n>> but that's not the case for creating channels. As the channel\n>> itself involves only two parties - and in sticking to my general\n>> political/philosophical mantra - there is really no justification for\n>> limits to be imposed on this. Which brings me to my next point.\n>> \n> \n> Perhaps our definition of \"long term\" is askew. A year after mainnet release, I doubt anyone would feel safe implementing removal of the limit; this is my \"long term\".  Five years, I imagine quite a few will use the nonlimited version and may form a subnetwork among themselves.  But possibly by then it would be unlikely that most people using Bitcoin at all would evem be capable of putting 150 mBTC in spending money on a hot wallet, in which case whether there is a 167 mBTC limit per channel or not is largely a moot point. Or perhaps I simply imagine hyperbitcoinization by then, with people putting entire bitcoins into hot wallets equivalent to people putting thousands of USD today in their back pockets as invitation to be attacked.\n> \n>>  \n>> There is also again the wisdom, that one should keep most of the funds in\n>> cold storage, and only a small amount for spending in hot wallets like\n>> Lightning nodes\n>>  \n>> I think this is a top-down way of thinking that runs counter to the\n>> spirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\n>> buy inflation-adjusted treasury bonds and not mess with bitcoin at\n>> all, much less the experimental lightning network. As advice this is\n>> perfectly fine to share with others for them to follow on a voluntary\n>> basis, but I don't see why this ought to be enforced as a rule on a\n>> protocol level.\n>> \n> \n> Possibly.  At the protocol level, a limit encourages the growth of the network towards a mesh network rather than more central forms, however.  I merely put this since it is unlikely that most people following this \"wisdom\" would have an incentive to even run software with the limit removed: that is, by the time Lightning becomes fully deployed the limit may not even be reached in practice.\n> \n>>  \n>> Also, I personally can't see a reason why a node would reject a large\n>> channel being made with it, where is the downside or risk? The party\n>> committing funds to the channel is the one risking loss or delay of\n>> funds.\n>> \n> \n> But the party committing funds to the channel is known via node gossip, and it is known also who the other end of the channel is. If you were to propose opening for example a 5BTC channel to me with the funds coming from you, I would consider the possibility that I might get attacked in order to get to your funds (and I might not have the resources to protect against such an attack on my end, even if you might). Further, putting 5BTC implies that at some point there is the future possibility, due to routing and so on, that the channel will have around 5BTC belonging to me, and at some point before you can spend the entire 5BTC I would want to close the channel and commit the funds that I now own into cold storage (so that the ability to channel 5BTC from you to me is a moot point).\n> \n> \n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171228/42da9b77/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-28T11:31:55",
                "message_text_only": "Mark Friedenbach <mark at friedenbach.org> writes:\n> Splitting a single payment into multiple invoices has bad semantic\n> properties. Beyond implementation difficulties it also makes the\n> payment no longer atomic. You can end up in a situation where part of\n> a transaction has gone through but then channel capacity has been\n> exhausted. The. What do you do?\n\nWe are indeed working on a solution for multipath payments, and they are\npretty simple to implement if the sender and recipient know how to\nhandle them. Re-use the same HTLC secret along all paths and the\natomicity is re-established. The only blocker is that it increases\ncomplexity on the recipient, e.g., how do I tell whether the partial\npayment is all I'll ever get, or whether there is more incoming, when do\nI abort waiting, and similar concerns. That's the reason it didn't make\nit into the v1.0 spec, but we are confident that it'll be added soon.\n\nIt is technically already possible to do so, if you hack together the\nrecipient node to wait for all parts of the payment before releasing the\nsecret. No need for multiple invoices.\n\n> While an annoying (and potentially exploitable) edge case for\n> payments, it also makes it basically impossible in practice to build\n> higher level smart contracts on top of lightning channels as\n> primitives, since those constructs typically use a single HTLC\n> revelation as the decision gate between multiple contingent outcomes.\n\nAbsolutely, that's why we want to have the payment contingent on a\nsingle secret, or on secrets that can be derived from one another.\n\n> I had always assumed the protocol limits were training wheels, and\n> would be shocked and dismayed if that were not the case (and would\n> immediately begin work on an alternative fork because such limits\n> would make lightning useless for my intended applications).\n\nThey are training wheels, we just decided for our own implementations\nthat we want to limit individual potential losses due to bugs. It is\ntrivial to change that on a per-channel level, and we have all the\npieces in place to perform an upgrade using the feature bits, no need to\nfork lightning just yet :-) You just need to agree on using larger\namounts with your peer, on the peer layer, there is nothing preventing\nthe use of large channels in the multi-hop layer.\n\nHTH,\nChristian"
            },
            {
                "author": "Andy Schroder",
                "date": "2017-12-29T18:01:03",
                "message_text_only": "Hello,\n\nThanks for all of the discussion on this topic. In general, I don't have \na solid opinion formed yet, but I understand all of the points that \neveryone has made. I think the bottom line is that a limit doesn't hurt \nright now unless the purchasing power of bitcoin dramatically declines. \nThis limit is like the block size limit in that it is conservative and \nwe need to have some experience in order to determine whether the limit \nis needed at all. It proved to be very clear over time that a block size \nlimit was needed as one force against centralization. Maybe a limit is \nneeded for lightning channels, maybe it isn't, but we need to first see \nhow the network starts to evolve. My main concern long term is that a \nlarge business couldn't operate using lightning, because the channel \nsizes and payment sizes are too small. What if you're buying an oil rig, \na locomotive, a gas turbine, a load of coal, or a herd of cattle. Should \na blockchain transaction be used for everyone in the world for these \ntypes of purchases? But then again, maybe different types of users will \nuse different kinds of lightning networks.\n\nAnother reason against accepting large incoming channels yourself would \nbe that you may not want to encourage people paying you to route through \none of the super nodes. Super nodes are likely spies or targets of spies \nand users won't naturally want to deal with those types of actors.\n\nAlso, the Eclair implementation supports push_msat too.\n\nOther than as \"training wheels\", I'm still not sure why we need a \npayment limit if we have a channel limit. It seems as though the channel \nlimit puts an implicit payment limit in place.\n\nAndy Schroder\n\nOn 12/27/2017 03:13 PM, ZmnSCPxj wrote:\n> Good morning Daniel,\n>\n>\n>\n>> -------- Original Message --------\n>> Subject: Re: [Lightning-dev] General questions about channels\n>> Local Time: December 27, 2017 10:30 PM\n>> UTC Time: December 27, 2017 2:30 PM\n>> From: therealsangaman at gmail.com\n>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>> Andy Schroder <info at andyschroder.com>, \n>> lightning-dev at lists.linuxfoundation.org \n>> <lightning-dev at lists.linuxfoundation.org>\n>>\n>> I've only really been getting my hands into LN the past few weeks but\n>> I thought I'd share my thoughts here.\n>>\n>> ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org \n>> <mailto:lightning-dev at lists.linuxfoundation.org> wrote:\n>>\n>>     Perhaps some day, in the LONG TERM, the limits may be increased\n>>\n>>\n>> I was always under the impression that the channel and payment limits\n>> were intended to be training wheels, this is the first I've heard of\n>> them intended to stick around long term. I find the channel limit to\n>> be particularly restrictive, as it hinders some use cases I'd envision\n>> where large payment channels between two parties are useful and can\n>> also be used for routing LN payments. Large payments afaik can be\n>> broken up into smaller ones without incurring too much cost or\n>> trouble,\n>\n> Splitting up large payments would require multiple invoices at least \n> for now (whether this is troublesome or not may be a matter of \n> opinion, bit I suspect juggling more than a few invoices would be \n> painful as a user experience). Routing larger payments over multiple \n> routes automatically while using a single invoice, is harder as \n> multiple routes need to be set up, and each route must have different \n> preimages: further it is likely you want the entire large payment to \n> be done atomically, which would be harder to arrange.\n>\n>> but that's not the case for creating channels. As the channel\n>> itself involves only two parties - and in sticking to my general\n>> political/philosophical mantra - there is really no justification for\n>> limits to be imposed on this. Which brings me to my next point.\n>>\n>\n> Perhaps our definition of \"long term\" is askew. A year after mainnet \n> release, I doubt anyone would feel safe implementing removal of the \n> limit; this is my \"long term\".  Five years, I imagine quite a few will \n> use the nonlimited version and may form a subnetwork among \n> themselves.  But possibly by then it would be unlikely that most \n> people using Bitcoin at all would evem be capable of putting 150 mBTC \n> in spending money on a hot wallet, in which case whether there is a \n> 167 mBTC limit per channel or not is largely a moot point. Or perhaps \n> I simply imagine hyperbitcoinization by then, with people putting \n> entire bitcoins into hot wallets equivalent to people putting \n> thousands of USD today in their back pockets as invitation to be attacked.\n>\n>>\n>>     There is also again the wisdom, that one should keep most of the\n>>     funds in\n>>     cold storage, and only a small amount for spending in hot wallets\n>>     like\n>>     Lightning nodes\n>>\n>>\n>> I think this is a top-down way of thinking that runs counter to the\n>> spirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\n>> buy inflation-adjusted treasury bonds and not mess with bitcoin at\n>> all, much less the experimental lightning network. As advice this is\n>> perfectly fine to share with others for them to follow on a voluntary\n>> basis, but I don't see why this ought to be enforced as a rule on a\n>> protocol level.\n>>\n>\n> Possibly.  At the protocol level, a limit encourages the growth of the \n> network towards a mesh network rather than more central forms, \n> however.  I merely put this since it is unlikely that most people \n> following this \"wisdom\" would have an incentive to even run software \n> with the limit removed: that is, by the time Lightning becomes fully \n> deployed the limit may not even be reached in practice.\n>\n>>\n>> Also, I personally can't see a reason why a node would reject a large\n>> channel being made with it, where is the downside or risk? The party\n>> committing funds to the channel is the one risking loss or delay of\n>> funds.\n>>\n>\n> But the party committing funds to the channel is known via node \n> gossip, and it is known also who the other end of the channel is. If \n> you were to propose opening for example a 5BTC channel to me with the \n> funds coming from you, I would consider the possibility that I might \n> get attacked in order to get to your funds (and I might not have the \n> resources to protect against such an attack on my end, even if you \n> might). Further, putting 5BTC implies that at some point there is the \n> future possibility, due to routing and so on, that the channel will \n> have around 5BTC belonging to me, and at some point before you can \n> spend the entire 5BTC I would want to close the channel and commit the \n> funds that I now own into cold storage (so that the ability to channel \n> 5BTC from you to me is a moot point).\n>\n>\n> Regards,\n> ZmnSCPxj\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171229/b0cc58a4/attachment.html>"
            },
            {
                "author": "dreamwvr",
                "date": "2017-12-24T16:45:48",
                "message_text_only": "On Fri, Dec 29, 2017 at 01:01:03PM -0500, Andy Schroder wrote:\n> Hello,\n> \n> Thanks for all of the discussion on this topic. In general, I don't\n> have a solid opinion formed yet, but I understand all of the points\n> that everyone has made. I think the bottom line is that a limit\n> doesn't hurt right now unless the purchasing power of bitcoin\n> dramatically declines. This limit is like the block size limit in\n> that it is conservative and we need to have some experience in order\n> to determine whether the limit is needed at all. It proved to be\n> very clear over time that a block size limit was needed as one force\n> against centralization. Maybe a limit is needed for lightning\n> channels, maybe it isn't, but we need to first see how the network\n> starts to evolve. My main concern long term is that a large business\n> couldn't operate using lightning, because the channel sizes and\n> payment sizes are too small. What if you're buying an oil rig, a\n> locomotive, a gas turbine, a load of coal, or a herd of cattle.\n> Should a blockchain transaction be used for everyone in the world\n> for these types of purchases? But then again, maybe different types\n> of users will use different kinds of lightning networks.\n> \n> Another reason against accepting large incoming channels yourself\n> would be that you may not want to encourage people paying you to\n> route through one of the super nodes. Super nodes are likely spies\n> or targets of spies and users won't naturally want to deal with\n> those types of actors.\n> \n> Also, the Eclair implementation supports push_msat too.\n> \n> Other than as \"training wheels\", I'm still not sure why we need a\n> payment limit if we have a channel limit. It seems as though the\n> channel limit puts an implicit payment limit in place.\n\ncentralized payments have limits. Is that model flawed or does it\ncreate a situation of check and balances to control situations where\ntransactions go sideways in ways unforseen? \n\n> \n> Andy Schroder\n> \n> On 12/27/2017 03:13 PM, ZmnSCPxj wrote:\n> >Good morning Daniel,\n> >\n> >\n> >\n> >>-------- Original Message --------\n> >>Subject: Re: [Lightning-dev] General questions about channels\n> >>Local Time: December 27, 2017 10:30 PM\n> >>UTC Time: December 27, 2017 2:30 PM\n> >>From: therealsangaman at gmail.com\n> >>To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> >>Andy Schroder <info at andyschroder.com>,\n> >>lightning-dev at lists.linuxfoundation.org\n> >><lightning-dev at lists.linuxfoundation.org>\n> >>\n> >>I've only really been getting my hands into LN the past few weeks but\n> >>I thought I'd share my thoughts here.\n> >>\n> >>ZmnSCPxj via Lightning-dev\n> >>lightning-dev at lists.linuxfoundation.org\n> >><mailto:lightning-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >>    Perhaps some day, in the LONG TERM, the limits may be increased\n> >>\n> >>\n> >>I was always under the impression that the channel and payment limits\n> >>were intended to be training wheels, this is the first I've heard of\n> >>them intended to stick around long term. I find the channel limit to\n> >>be particularly restrictive, as it hinders some use cases I'd envision\n> >>where large payment channels between two parties are useful and can\n> >>also be used for routing LN payments. Large payments afaik can be\n> >>broken up into smaller ones without incurring too much cost or\n> >>trouble,\n> >\n> >Splitting up large payments would require multiple invoices at\n> >least for now (whether this is troublesome or not may be a matter\n> >of opinion, bit I suspect juggling more than a few invoices would\n> >be painful as a user experience). Routing larger payments over\n> >multiple routes automatically while using a single invoice, is\n> >harder as multiple routes need to be set up, and each route must\n> >have different preimages: further it is likely you want the entire\n> >large payment to be done atomically, which would be harder to\n> >arrange.\n> >\n> >>but that's not the case for creating channels. As the channel\n> >>itself involves only two parties - and in sticking to my general\n> >>political/philosophical mantra - there is really no justification for\n> >>limits to be imposed on this. Which brings me to my next point.\n> >>\n> >\n> >Perhaps our definition of \"long term\" is askew. A year after\n> >mainnet release, I doubt anyone would feel safe implementing\n> >removal of the limit; this is my \"long term\".  Five years, I\n> >imagine quite a few will use the nonlimited version and may form a\n> >subnetwork among themselves.  But possibly by then it would be\n> >unlikely that most people using Bitcoin at all would evem be\n> >capable of putting 150 mBTC in spending money on a hot wallet, in\n> >which case whether there is a 167 mBTC limit per channel or not is\n> >largely a moot point. Or perhaps I simply imagine\n> >hyperbitcoinization by then, with people putting entire bitcoins\n> >into hot wallets equivalent to people putting thousands of USD\n> >today in their back pockets as invitation to be attacked.\n> >\n> >>\n> >>    There is also again the wisdom, that one should keep most of the\n> >>    funds in\n> >>    cold storage, and only a small amount for spending in hot wallets\n> >>    like\n> >>    Lightning nodes\n> >>\n> >>\n> >>I think this is a top-down way of thinking that runs counter to the\n> >>spirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\n> >>buy inflation-adjusted treasury bonds and not mess with bitcoin at\n> >>all, much less the experimental lightning network. As advice this is\n> >>perfectly fine to share with others for them to follow on a voluntary\n> >>basis, but I don't see why this ought to be enforced as a rule on a\n> >>protocol level.\n> >>\n> >\n> >Possibly.  At the protocol level, a limit encourages the growth of\n> >the network towards a mesh network rather than more central forms,\n> >however.  I merely put this since it is unlikely that most people\n> >following this \"wisdom\" would have an incentive to even run\n> >software with the limit removed: that is, by the time Lightning\n> >becomes fully deployed the limit may not even be reached in\n> >practice.\n> >\n> >>\n> >>Also, I personally can't see a reason why a node would reject a large\n> >>channel being made with it, where is the downside or risk? The party\n> >>committing funds to the channel is the one risking loss or delay of\n> >>funds.\n> >>\n> >\n> >But the party committing funds to the channel is known via node\n> >gossip, and it is known also who the other end of the channel is.\n> >If you were to propose opening for example a 5BTC channel to me\n> >with the funds coming from you, I would consider the possibility\n> >that I might get attacked in order to get to your funds (and I\n> >might not have the resources to protect against such an attack on\n> >my end, even if you might). Further, putting 5BTC implies that at\n> >some point there is the future possibility, due to routing and so\n> >on, that the channel will have around 5BTC belonging to me, and at\n> >some point before you can spend the entire 5BTC I would want to\n> >close the channel and commit the funds that I now own into cold\n> >storage (so that the ability to channel 5BTC from you to me is a\n> >moot point).\n> >\n> >\n> >Regards,\n> >ZmnSCPxj\n> \n> \n> \n> !DSPAM:5a3fc746296411625131755!\n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n> \n> !DSPAM:5a3fc746296411625131755!"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-30T23:14:02",
                "message_text_only": "Hi Andy,\n\njust one minor point regarding your comparison with the bitcoin block\nsize: while the bitcoin block size is a consensus critical parameter\nthat cannot be modified without every participant agreeing, the capacity\nlimit is not consensus critical and can be changed at any point in\ntime. It can be negotiated by the two endpoints of a channel and no\nother party is involved.\n\nI quite like the comparison to training wheels, it's there as long as\nyou don't feel safe, and you can get rid of them once you're confidence\nin the system and yourself increases :-)\n\nCheers,\nChristian\n\nAndy Schroder <info at AndySchroder.com> writes:\n> Hello,\n>\n> Thanks for all of the discussion on this topic. In general, I don't have \n> a solid opinion formed yet, but I understand all of the points that \n> everyone has made. I think the bottom line is that a limit doesn't hurt \n> right now unless the purchasing power of bitcoin dramatically declines. \n> This limit is like the block size limit in that it is conservative and \n> we need to have some experience in order to determine whether the limit \n> is needed at all. It proved to be very clear over time that a block size \n> limit was needed as one force against centralization. Maybe a limit is \n> needed for lightning channels, maybe it isn't, but we need to first see \n> how the network starts to evolve. My main concern long term is that a \n> large business couldn't operate using lightning, because the channel \n> sizes and payment sizes are too small. What if you're buying an oil rig, \n> a locomotive, a gas turbine, a load of coal, or a herd of cattle. Should \n> a blockchain transaction be used for everyone in the world for these \n> types of purchases? But then again, maybe different types of users will \n> use different kinds of lightning networks.\n>\n> Another reason against accepting large incoming channels yourself would \n> be that you may not want to encourage people paying you to route through \n> one of the super nodes. Super nodes are likely spies or targets of spies \n> and users won't naturally want to deal with those types of actors.\n>\n> Also, the Eclair implementation supports push_msat too.\n>\n> Other than as \"training wheels\", I'm still not sure why we need a \n> payment limit if we have a channel limit. It seems as though the channel \n> limit puts an implicit payment limit in place.\n>\n> Andy Schroder\n>\n> On 12/27/2017 03:13 PM, ZmnSCPxj wrote:\n>> Good morning Daniel,\n>>\n>>\n>>\n>>> -------- Original Message --------\n>>> Subject: Re: [Lightning-dev] General questions about channels\n>>> Local Time: December 27, 2017 10:30 PM\n>>> UTC Time: December 27, 2017 2:30 PM\n>>> From: therealsangaman at gmail.com\n>>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>>> Andy Schroder <info at andyschroder.com>, \n>>> lightning-dev at lists.linuxfoundation.org \n>>> <lightning-dev at lists.linuxfoundation.org>\n>>>\n>>> I've only really been getting my hands into LN the past few weeks but\n>>> I thought I'd share my thoughts here.\n>>>\n>>> ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org \n>>> <mailto:lightning-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>     Perhaps some day, in the LONG TERM, the limits may be increased\n>>>\n>>>\n>>> I was always under the impression that the channel and payment limits\n>>> were intended to be training wheels, this is the first I've heard of\n>>> them intended to stick around long term. I find the channel limit to\n>>> be particularly restrictive, as it hinders some use cases I'd envision\n>>> where large payment channels between two parties are useful and can\n>>> also be used for routing LN payments. Large payments afaik can be\n>>> broken up into smaller ones without incurring too much cost or\n>>> trouble,\n>>\n>> Splitting up large payments would require multiple invoices at least \n>> for now (whether this is troublesome or not may be a matter of \n>> opinion, bit I suspect juggling more than a few invoices would be \n>> painful as a user experience). Routing larger payments over multiple \n>> routes automatically while using a single invoice, is harder as \n>> multiple routes need to be set up, and each route must have different \n>> preimages: further it is likely you want the entire large payment to \n>> be done atomically, which would be harder to arrange.\n>>\n>>> but that's not the case for creating channels. As the channel\n>>> itself involves only two parties - and in sticking to my general\n>>> political/philosophical mantra - there is really no justification for\n>>> limits to be imposed on this. Which brings me to my next point.\n>>>\n>>\n>> Perhaps our definition of \"long term\" is askew. A year after mainnet \n>> release, I doubt anyone would feel safe implementing removal of the \n>> limit; this is my \"long term\".  Five years, I imagine quite a few will \n>> use the nonlimited version and may form a subnetwork among \n>> themselves.  But possibly by then it would be unlikely that most \n>> people using Bitcoin at all would evem be capable of putting 150 mBTC \n>> in spending money on a hot wallet, in which case whether there is a \n>> 167 mBTC limit per channel or not is largely a moot point. Or perhaps \n>> I simply imagine hyperbitcoinization by then, with people putting \n>> entire bitcoins into hot wallets equivalent to people putting \n>> thousands of USD today in their back pockets as invitation to be attacked.\n>>\n>>>\n>>>     There is also again the wisdom, that one should keep most of the\n>>>     funds in\n>>>     cold storage, and only a small amount for spending in hot wallets\n>>>     like\n>>>     Lightning nodes\n>>>\n>>>\n>>> I think this is a top-down way of thinking that runs counter to the\n>>> spirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\n>>> buy inflation-adjusted treasury bonds and not mess with bitcoin at\n>>> all, much less the experimental lightning network. As advice this is\n>>> perfectly fine to share with others for them to follow on a voluntary\n>>> basis, but I don't see why this ought to be enforced as a rule on a\n>>> protocol level.\n>>>\n>>\n>> Possibly.  At the protocol level, a limit encourages the growth of the \n>> network towards a mesh network rather than more central forms, \n>> however.  I merely put this since it is unlikely that most people \n>> following this \"wisdom\" would have an incentive to even run software \n>> with the limit removed: that is, by the time Lightning becomes fully \n>> deployed the limit may not even be reached in practice.\n>>\n>>>\n>>> Also, I personally can't see a reason why a node would reject a large\n>>> channel being made with it, where is the downside or risk? The party\n>>> committing funds to the channel is the one risking loss or delay of\n>>> funds.\n>>>\n>>\n>> But the party committing funds to the channel is known via node \n>> gossip, and it is known also who the other end of the channel is. If \n>> you were to propose opening for example a 5BTC channel to me with the \n>> funds coming from you, I would consider the possibility that I might \n>> get attacked in order to get to your funds (and I might not have the \n>> resources to protect against such an attack on my end, even if you \n>> might). Further, putting 5BTC implies that at some point there is the \n>> future possibility, due to routing and so on, that the channel will \n>> have around 5BTC belonging to me, and at some point before you can \n>> spend the entire 5BTC I would want to close the channel and commit the \n>> funds that I now own into cold storage (so that the ability to channel \n>> 5BTC from you to me is a moot point).\n>>\n>>\n>> Regards,\n>> ZmnSCPxj\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Andy Schroder",
                "date": "2017-12-30T23:25:49",
                "message_text_only": "Hello Christian,\n\nI understand that you have to be in agreement with your direct peers. So \nyou don't really care about what agreements others in your route may \nhave in place? I would think that you would choose not to route through \nhops that violate your capacity limit.\n\nAndy Schroder\n\nOn 12/30/2017 06:14 PM, Christian Decker wrote:\n> Hi Andy,\n>\n> just one minor point regarding your comparison with the bitcoin block\n> size: while the bitcoin block size is a consensus critical parameter\n> that cannot be modified without every participant agreeing, the capacity\n> limit is not consensus critical and can be changed at any point in\n> time. It can be negotiated by the two endpoints of a channel and no\n> other party is involved.\n>\n> I quite like the comparison to training wheels, it's there as long as\n> you don't feel safe, and you can get rid of them once you're confidence\n> in the system and yourself increases :-)\n>\n> Cheers,\n> Christian\n>\n> Andy Schroder <info at AndySchroder.com> writes:\n>> Hello,\n>>\n>> Thanks for all of the discussion on this topic. In general, I don't have\n>> a solid opinion formed yet, but I understand all of the points that\n>> everyone has made. I think the bottom line is that a limit doesn't hurt\n>> right now unless the purchasing power of bitcoin dramatically declines.\n>> This limit is like the block size limit in that it is conservative and\n>> we need to have some experience in order to determine whether the limit\n>> is needed at all. It proved to be very clear over time that a block size\n>> limit was needed as one force against centralization. Maybe a limit is\n>> needed for lightning channels, maybe it isn't, but we need to first see\n>> how the network starts to evolve. My main concern long term is that a\n>> large business couldn't operate using lightning, because the channel\n>> sizes and payment sizes are too small. What if you're buying an oil rig,\n>> a locomotive, a gas turbine, a load of coal, or a herd of cattle. Should\n>> a blockchain transaction be used for everyone in the world for these\n>> types of purchases? But then again, maybe different types of users will\n>> use different kinds of lightning networks.\n>>\n>> Another reason against accepting large incoming channels yourself would\n>> be that you may not want to encourage people paying you to route through\n>> one of the super nodes. Super nodes are likely spies or targets of spies\n>> and users won't naturally want to deal with those types of actors.\n>>\n>> Also, the Eclair implementation supports push_msat too.\n>>\n>> Other than as \"training wheels\", I'm still not sure why we need a\n>> payment limit if we have a channel limit. It seems as though the channel\n>> limit puts an implicit payment limit in place.\n>>\n>> Andy Schroder\n>>\n>> On 12/27/2017 03:13 PM, ZmnSCPxj wrote:\n>>> Good morning Daniel,\n>>>\n>>>\n>>>\n>>>> -------- Original Message --------\n>>>> Subject: Re: [Lightning-dev] General questions about channels\n>>>> Local Time: December 27, 2017 10:30 PM\n>>>> UTC Time: December 27, 2017 2:30 PM\n>>>> From: therealsangaman at gmail.com\n>>>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>>>> Andy Schroder <info at andyschroder.com>,\n>>>> lightning-dev at lists.linuxfoundation.org\n>>>> <lightning-dev at lists.linuxfoundation.org>\n>>>>\n>>>> I've only really been getting my hands into LN the past few weeks but\n>>>> I thought I'd share my thoughts here.\n>>>>\n>>>> ZmnSCPxj via Lightning-dev lightning-dev at lists.linuxfoundation.org\n>>>> <mailto:lightning-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>      Perhaps some day, in the LONG TERM, the limits may be increased\n>>>>\n>>>>\n>>>> I was always under the impression that the channel and payment limits\n>>>> were intended to be training wheels, this is the first I've heard of\n>>>> them intended to stick around long term. I find the channel limit to\n>>>> be particularly restrictive, as it hinders some use cases I'd envision\n>>>> where large payment channels between two parties are useful and can\n>>>> also be used for routing LN payments. Large payments afaik can be\n>>>> broken up into smaller ones without incurring too much cost or\n>>>> trouble,\n>>> Splitting up large payments would require multiple invoices at least\n>>> for now (whether this is troublesome or not may be a matter of\n>>> opinion, bit I suspect juggling more than a few invoices would be\n>>> painful as a user experience). Routing larger payments over multiple\n>>> routes automatically while using a single invoice, is harder as\n>>> multiple routes need to be set up, and each route must have different\n>>> preimages: further it is likely you want the entire large payment to\n>>> be done atomically, which would be harder to arrange.\n>>>\n>>>> but that's not the case for creating channels. As the channel\n>>>> itself involves only two parties - and in sticking to my general\n>>>> political/philosophical mantra - there is really no justification for\n>>>> limits to be imposed on this. Which brings me to my next point.\n>>>>\n>>> Perhaps our definition of \"long term\" is askew. A year after mainnet\n>>> release, I doubt anyone would feel safe implementing removal of the\n>>> limit; this is my \"long term\".  Five years, I imagine quite a few will\n>>> use the nonlimited version and may form a subnetwork among\n>>> themselves.  But possibly by then it would be unlikely that most\n>>> people using Bitcoin at all would evem be capable of putting 150 mBTC\n>>> in spending money on a hot wallet, in which case whether there is a\n>>> 167 mBTC limit per channel or not is largely a moot point. Or perhaps\n>>> I simply imagine hyperbitcoinization by then, with people putting\n>>> entire bitcoins into hot wallets equivalent to people putting\n>>> thousands of USD today in their back pockets as invitation to be attacked.\n>>>\n>>>>      There is also again the wisdom, that one should keep most of the\n>>>>      funds in\n>>>>      cold storage, and only a small amount for spending in hot wallets\n>>>>      like\n>>>>      Lightning nodes\n>>>>\n>>>>\n>>>> I think this is a top-down way of thinking that runs counter to the\n>>>> spirit of bitcoin. The \"wisest\" thing to do in fact may be to simply\n>>>> buy inflation-adjusted treasury bonds and not mess with bitcoin at\n>>>> all, much less the experimental lightning network. As advice this is\n>>>> perfectly fine to share with others for them to follow on a voluntary\n>>>> basis, but I don't see why this ought to be enforced as a rule on a\n>>>> protocol level.\n>>>>\n>>> Possibly.  At the protocol level, a limit encourages the growth of the\n>>> network towards a mesh network rather than more central forms,\n>>> however.  I merely put this since it is unlikely that most people\n>>> following this \"wisdom\" would have an incentive to even run software\n>>> with the limit removed: that is, by the time Lightning becomes fully\n>>> deployed the limit may not even be reached in practice.\n>>>\n>>>> Also, I personally can't see a reason why a node would reject a large\n>>>> channel being made with it, where is the downside or risk? The party\n>>>> committing funds to the channel is the one risking loss or delay of\n>>>> funds.\n>>>>\n>>> But the party committing funds to the channel is known via node\n>>> gossip, and it is known also who the other end of the channel is. If\n>>> you were to propose opening for example a 5BTC channel to me with the\n>>> funds coming from you, I would consider the possibility that I might\n>>> get attacked in order to get to your funds (and I might not have the\n>>> resources to protect against such an attack on my end, even if you\n>>> might). Further, putting 5BTC implies that at some point there is the\n>>> future possibility, due to routing and so on, that the channel will\n>>> have around 5BTC belonging to me, and at some point before you can\n>>> spend the entire 5BTC I would want to close the channel and commit the\n>>> funds that I now own into cold storage (so that the ability to channel\n>>> 5BTC from you to me is a moot point).\n>>>\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "General questions about channels",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Rusty Russell",
                "dreamwvr",
                "Daniel McNally",
                "Andy Schroder",
                "Christian Decker",
                "Mark Friedenbach"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 83792
        }
    },
    {
        "title": "[Lightning-dev] Refilling a channel by sending a payment to yourself.",
        "thread_messages": [
            {
                "author": "Lukehanson",
                "date": "2017-12-20T16:01:39",
                "message_text_only": "New to LN, so forgive me if this is already implemented/planned to be.\n\nI\u2019ve been trying out LN on testnet, treating it as if it was mainnet, as in how I would open channels, to whom and what amount.\n\nOne main problem is that a channel gets exhausted. I could have created a larger channel in the first place but channels are meant to last for days, even months, no? So its hard to predict that amount beforehand.\n\nA = me\nB = say yalls.org\nC = some common channel\nA exhausts his channel with B - all balance are with B.\nA could open another channel with B but this would be costly.\nA could pay B through C now, but as most transactions are micro(few cents) and A pays B for hundreds of articles per month, the base fee would pile up (as LN fees = base fee + proportional fee).\nBalance before : https://imgur.com/a/L2JFA\n\nA - B (0,5)\nA - C (10, 8)\nC - B (10,10)\nA pays self : He sends 5mBTC to C, who sends it to B, who sends it back to A.\nBalance now : https://imgur.com/a/moNXY A - C(5,13)\nC - B(5,15)\nA - B(5,0)\nSo, A does a one time refill of A-B channel with the help of C. The proportional fee would be same if A sent through C every time or did a one time refill, but A in this case pays base fee only once to C.\nI expect base fee to be around 1-2 cents by B, so this plot says the \u201crefill method\u201d could save a couple of dollars.\nFees saved, for various base fees and subsequent articles read- https://imgur.com/a/FAu31 (gotta use the free campus matlab license for something).\nIs doing this the same as using the -r tag in payment invoice? (Bolt #11) In UI terms, a \u201crefill\u201d button could be near a channel name. Luke Hanson\nlukehanson at protonmail.com \ufeff\nGradatim Ferociter!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171220/955fe72d/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-21T06:12:37",
                "message_text_only": "Good morning Lukehanson,\n\nThat is correct.  Indeed this \"pay yourself\" technique is a useful way to rebalance funds.  The main advantage is that it would work without modification of the protocol.\n\nHowever, to my knowledge, no node software currently actually implements this technique of transferring your own funds between your own channels.\n\nNote that this can work as a \"almost-good-enough\" solution to splice-in (i.e. adding more funds to an existing channel).  Rather than splice-in, simply create a new channel to another node, then route a payment from the new channel to the current channel you have.  Splice-in is still strictly more efficient, but requires new specs and new node software that is capable of coordinating with your own.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: [Lightning-dev] Refilling a channel by sending a payment to yourself.\n> Local Time: December 21, 2017 12:01 AM\n> UTC Time: December 20, 2017 4:01 PM\n> From: lightning-dev at lists.linuxfoundation.org\n> To: lightning-dev <lightning-dev at lists.linuxfoundation.org>\n>\n> New to LN, so forgive me if this is already implemented/planned to be.\n>\n> I\u2019ve been trying out LN on testnet, treating it as if it was mainnet, as in how I would open channels, to whom and what amount.\n>\n> One main problem is that a channel gets exhausted. I could have created a larger channel in the first place but channels are meant to last for days, even months, no? So its hard to predict that amount beforehand.\n>\n> A = me\n> B = say yalls.org\n> C = some common channel\n> A exhausts his channel with B - all balance are with B.\n> A could open another channel with B but this would be costly.\n> A could pay B through C now, but as most transactions are micro(few cents) and A pays B for hundreds of articles per month, the base fee would pile up (as LN fees = base fee + proportional fee).\n> Balance before : https://imgur.com/a/L2JFA\n>\n> A - B (0,5)\n> A - C (10, 8)\n> C - B (10,10)\n> A pays self : He sends 5mBTC to C, who sends it to B, who sends it back to A.\n> Balance now : https://imgur.com/a/moNXY A - C(5,13)\n> C - B(5,15)\n> A - B(5,0)\n> So, A does a one time refill of A-B channel with the help of C. The proportional fee would be same if A sent through C every time or did a one time refill, but A in this case pays base fee only once to C.\n> I expect base fee to be around 1-2 cents by B, so this plot says the \u201crefill method\u201d could save a couple of dollars.\n> Fees saved, for various base fees and subsequent articles read- https://imgur.com/a/FAu31 (gotta use the free campus matlab license for something).\n> Is doing this the same as using the -r tag in payment invoice? (Bolt #11) In UI terms, a \u201crefill\u201d button could be near a channel name. Luke Hanson\n> lukehanson at protonmail.com \ufeff\n> Gradatim Ferociter!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171221/51930025/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Refilling a channel by sending a payment to yourself.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Lukehanson"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4926
        }
    },
    {
        "title": "[Lightning-dev] reducing the number of blockchain transactions used by the LN, and the fees paid to confirm them",
        "thread_messages": [
            {
                "author": "Jim Renkel",
                "date": "2017-12-21T00:52:24",
                "message_text_only": "Hello, all!\n\nI'm a long-time computer networking developer, but a newbie to \ncryptocurrency, and am interested in contributing to its development.\n\nWhile looking at the lightning network design and code, I've come up \nwith an idea the would reduce the number of blockchain transactions used \nby the LN, and the fees paid to confirm them, in a common LN use case.\n\nI did a quick search and couldn't find this idea presented previously, \nbut I may have missed it. If so, or if the idea is faulty, I'm sure you \nguys will let me know. :-)\n\nAnd forgive me if I don't have the terminology quite right yet.\n\nThe use case I am referring to is the frequent, repeated purchases by a \ncustomer from the same merchant over an extended period of time. I think \nthis will be a common use case.\n\nFor example: Alice buys a cup of coffee from Bob's Coffee Shoppe every \nday, has done so for years, will do so for years.\n\nTo use the LN to pay for these purchases, Alice opens and funds an LN \nchannel to Bob. This takes one blockchain transaction.\n\nAs coffees are purchased every day, funds are transferred from Alice to \nBob in the channel without any blockchain transactions.\n\nAlice cannot afford to fund the channel for an extended period of time, \nand Bob is unwilling to wait an extended period of time to be paid for \nthe coffees Alice has purchased.\n\nSo every week or so, Alice and Bob close the channel, Alice gets back \nany unspent funds, and Bob gets the funds that have been transferred to \nhim for Alice's purchases. Then Alice and Bob re-open the channel with \nnew funding from Alice. Closing and re-opening the channel each take one \nblockchain transaction.\n\nOver the life of the channel, if there are n close/re-open cycles, 2*n \nblockchain transactions are required: 1 to open the channel initially, 2 \neach time the channel is closed and re-opened (n-1 times), and 1 to \nclose the channel finally.\n\nIf the LN were enhanced with an operation to deposit and withdraw \nfunding in the channel to and from the blockchain without closing the \nchannel, this could be done with a single blockchain transaction that is \nessentially the merge of the closing and re-opening blockchain transactions.\n\nIn this example, each adjustment will only pay Bob his accumulated but \nas yet unpaid funds and charge Alice for the new funds she places into \nthe channel, but leave Alice's unspent funds in the channel. The channel \ncould continue to operate between the launching and confirmation of the \nadjustment transaction if Alice has unspent funds in the channel.\n\nThen the n cycles would only require n+1 blockchain transactions: 1 to \ninitially open the channel, 1 each time the channel funding is adjusted \n(total n-1), and 1 to finally close the channel. This is a significant \nreduction in the number of blockchain transactions required, approaching \n50% in the limit as n approaches infinity.\n\nWhat about blockchain transaction fees? I've done the analysis, but it's \nquite long (several conditions and dozens of combinations of conditions \nto consider), so I won't include it here now. I will included it in \nanother post if anyone is interested and doesn't do the analysis for \nthemselves.\n\nThe bottom line of the analysis is that the number of inputs and the \nnumber of outputs in the funding adjustment transaction are each never \ngreater than the sum of the number of inputs and the number of outputs, \nrespectively, in the channel opening and closing transactions that the \nadjustment transaction replaces.\n\nThus the adjustment transaction is:\n- never bigger than the closing and re-opening transactions put together,\n- sometimes smaller, and\n- occasionally significantly smaller.\n\nAnd there's only one transaction instead of two, so ya always save on \nthe transaction header! :-)\n\nThus, the fee paid for the adjustment transaction, assuming the same fee \nrate for all the transactions, is:\n- never more than the sum of the fees paid for the closing and \nre-opening transactions,\n- sometimes less, and\n- occasionally significantly less.\n\nThis reduction in fees is by an additive amount.\n\nBecause the channel remains open while waiting for the adjustment \ntransaction to confirm, there may be less urgency in having it confirm. \nSo it's fee rate can be reduced, reducing the fee paid by a \nmultiplicative amount.\n\nCombined, these two effects lead to a reduction in total fees paid for \noperating the channel, sometimes a significant reduction.\n\nComments expected and welcome.\n\nIf this high-level, bare-bones idea to seen to be worthy of further \nconsideration, I would like to work with the community to flesh out a \ndetailed specification, and, if consensus can be reached on that, to \nparticipate in the implementation of it.\n\nJim Renkel"
            },
            {
                "author": "Dario Sneidermanis",
                "date": "2017-12-21T01:07:24",
                "message_text_only": "This operation is called splice in/out, or clopen transaction. There's some\ninformation here:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2017-May/000696.html\n\nCheers,\nDario\n\nOn Wed, Dec 20, 2017 at 9:52 PM, Jim Renkel <jim.renkel at comcast.net> wrote:\n\n> Hello, all!\n>\n> I'm a long-time computer networking developer, but a newbie to\n> cryptocurrency, and am interested in contributing to its development.\n>\n> While looking at the lightning network design and code, I've come up with\n> an idea the would reduce the number of blockchain transactions used by the\n> LN, and the fees paid to confirm them, in a common LN use case.\n>\n> I did a quick search and couldn't find this idea presented previously, but\n> I may have missed it. If so, or if the idea is faulty, I'm sure you guys\n> will let me know. :-)\n>\n> And forgive me if I don't have the terminology quite right yet.\n>\n> The use case I am referring to is the frequent, repeated purchases by a\n> customer from the same merchant over an extended period of time. I think\n> this will be a common use case.\n>\n> For example: Alice buys a cup of coffee from Bob's Coffee Shoppe every\n> day, has done so for years, will do so for years.\n>\n> To use the LN to pay for these purchases, Alice opens and funds an LN\n> channel to Bob. This takes one blockchain transaction.\n>\n> As coffees are purchased every day, funds are transferred from Alice to\n> Bob in the channel without any blockchain transactions.\n>\n> Alice cannot afford to fund the channel for an extended period of time,\n> and Bob is unwilling to wait an extended period of time to be paid for the\n> coffees Alice has purchased.\n>\n> So every week or so, Alice and Bob close the channel, Alice gets back any\n> unspent funds, and Bob gets the funds that have been transferred to him for\n> Alice's purchases. Then Alice and Bob re-open the channel with new funding\n> from Alice. Closing and re-opening the channel each take one blockchain\n> transaction.\n>\n> Over the life of the channel, if there are n close/re-open cycles, 2*n\n> blockchain transactions are required: 1 to open the channel initially, 2\n> each time the channel is closed and re-opened (n-1 times), and 1 to close\n> the channel finally.\n>\n> If the LN were enhanced with an operation to deposit and withdraw funding\n> in the channel to and from the blockchain without closing the channel, this\n> could be done with a single blockchain transaction that is essentially the\n> merge of the closing and re-opening blockchain transactions.\n>\n> In this example, each adjustment will only pay Bob his accumulated but as\n> yet unpaid funds and charge Alice for the new funds she places into the\n> channel, but leave Alice's unspent funds in the channel. The channel could\n> continue to operate between the launching and confirmation of the\n> adjustment transaction if Alice has unspent funds in the channel.\n>\n> Then the n cycles would only require n+1 blockchain transactions: 1 to\n> initially open the channel, 1 each time the channel funding is adjusted\n> (total n-1), and 1 to finally close the channel. This is a significant\n> reduction in the number of blockchain transactions required, approaching\n> 50% in the limit as n approaches infinity.\n>\n> What about blockchain transaction fees? I've done the analysis, but it's\n> quite long (several conditions and dozens of combinations of conditions to\n> consider), so I won't include it here now. I will included it in another\n> post if anyone is interested and doesn't do the analysis for themselves.\n>\n> The bottom line of the analysis is that the number of inputs and the\n> number of outputs in the funding adjustment transaction are each never\n> greater than the sum of the number of inputs and the number of outputs,\n> respectively, in the channel opening and closing transactions that the\n> adjustment transaction replaces.\n>\n> Thus the adjustment transaction is:\n> - never bigger than the closing and re-opening transactions put together,\n> - sometimes smaller, and\n> - occasionally significantly smaller.\n>\n> And there's only one transaction instead of two, so ya always save on the\n> transaction header! :-)\n>\n> Thus, the fee paid for the adjustment transaction, assuming the same fee\n> rate for all the transactions, is:\n> - never more than the sum of the fees paid for the closing and re-opening\n> transactions,\n> - sometimes less, and\n> - occasionally significantly less.\n>\n> This reduction in fees is by an additive amount.\n>\n> Because the channel remains open while waiting for the adjustment\n> transaction to confirm, there may be less urgency in having it confirm. So\n> it's fee rate can be reduced, reducing the fee paid by a multiplicative\n> amount.\n>\n> Combined, these two effects lead to a reduction in total fees paid for\n> operating the channel, sometimes a significant reduction.\n>\n> Comments expected and welcome.\n>\n> If this high-level, bare-bones idea to seen to be worthy of further\n> consideration, I would like to work with the community to flesh out a\n> detailed specification, and, if consensus can be reached on that, to\n> participate in the implementation of it.\n>\n> Jim Renkel\n>\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171220/14cdd7b0/attachment-0001.html>"
            },
            {
                "author": "Jim Renkel",
                "date": "2017-12-21T01:52:43",
                "message_text_only": "Hello, all!\n\nI'm a long-time computer networking developer, but a newbie to \ncryptocurrency, and am interested in contributing to its development.\n\nWhile looking at the lightning network design and code, I've come up \nwith an idea the would reduce the number of blockchain transactions used \nby the LN, and the fees paid to confirm them, in a common LN use case.\n\nI did a quick search and couldn't find this idea presented previously, \nbut I may have missed it. If so, or if the idea is faulty, I'm sure you \nguys will let me know. :-)\n\nAnd forgive me if I don't have the terminology quite right yet.\n\nThe use case I am referring to is the frequent, repeated purchases by a \ncustomer from the same merchant over an extended period of time. I think \nthis will be a common use case.\n\nFor example: Alice buys a cup of coffee from Bob's Coffee Shoppe every \nday, has done so for years, will do so for years.\n\nTo use the LN to pay for these purchases, Alice opens and funds an LN \nchannel to Bob. This takes one blockchain transaction.\n\nAs coffees are purchased every day, funds are transferred from Alice to \nBob in the channel without any blockchain transactions.\n\nAlice cannot afford to fund the channel for an extended period of time, \nand Bob is unwilling to wait an extended period of time to be paid for \nthe coffees Alice has purchased.\n\nSo every week or so, Alice and Bob close the channel, Alice gets back \nany unspent funds, and Bob gets the funds that have been transferred to \nhim for Alice's purchases. Then Alice and Bob re-open the channel with \nnew funding from Alice. Closing and re-opening the channel each take one \nblockchain transaction.\n\nOver the life of the channel, if there are n close/re-open cycles, 2*n \nblockchain transactions are required: 1 to open the channel initially, 2 \neach time the channel is closed and re-opened (n-1 times), and 1 to \nclose the channel finally.\n\nIf the LN were enhanced with an operation to deposit and withdraw \nfunding in the channel to and from the blockchain without closing the \nchannel, this could be done with a single blockchain transaction that is \nessentially the merge of the closing and re-opening blockchain transactions.\n\nIn this example, each adjustment will only pay Bob his accumulated but \nas yet unpaid funds and charge Alice for the new funds she places into \nthe channel, but leave Alice's unspent funds in the channel. The channel \ncould continue to operate between the launching and confirmation of the \nadjustment transaction if Alice has unspent funds in the channel.\n\nThen the n cycles would only require n+1 blockchain transactions: 1 to \ninitially open the channel, 1 each time the channel funding is adjusted \n(total n-1), and 1 to finally close the channel. This is a significant \nreduction in the number of blockchain transactions required, approaching \n50% in the limit as n approaches infinity.\n\nWhat about blockchain transaction fees? I've done the analysis, but it's \nquite long (several conditions and dozens of combinations of conditions \nto consider), so I won't include it here now. I will included it in \nanother post if anyone is interested and doesn't do the analysis for \nthemselves.\n\nThe bottom line of the analysis is that the number of inputs and the \nnumber of outputs in the funding adjustment transaction are each never \ngreater than the sum of the number of inputs and the number of outputs, \nrespectively, in the channel opening and closing transactions that the \nadjustment transaction replaces.\n\nThus the adjustment transaction is:\n- never bigger than the closing and re-opening transactions put together,\n- sometimes smaller, and\n- occasionally significantly smaller.\n\nAnd there's only one transaction instead of two, so ya always save on \nthe transaction header! :-)\n\nThus, the fee paid for the adjustment transaction, assuming the same fee \nrate for all the transactions, is:\n- never more than the sum of the fees paid for the closing and \nre-opening transactions,\n- sometimes less, and\n- occasionally significantly less.\n\nThis reduction in fees is by an additive amount.\n\nBecause the channel remains open while waiting for the adjustment \ntransaction to confirm, there may be less urgency in having it confirm. \nSo it's fee rate can be reduced, reducing the fee paid by a \nmultiplicative amount.\n\nCombined, these two effects lead to a reduction in total fees paid for \noperating the channel, sometimes a significant reduction.\n\nComments expected and welcome.\n\nIf this high-level, bare-bones idea is seen to be worthy of further \nconsideration, I would like to work with the community to flesh out a \ndetailed specification, and, if consensus can be reached on that, to \nparticipate in the implementation of it.\n\nJim Renkel"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-21T06:44:27",
                "message_text_only": "Good morning Jim,\n\nThe idea is called \"splce in/out\" and as Dario Sneidermanis mentioned, has occasionally been discussed on this list every now and then.\n\nTo my understanding:\n\n1.  The splicing transaction has as input the previous funding transaction output.\n2.  The splicing transaction has an output that is the next funding transaction output.\n3.  All other inputs (to be spliced-in) of the splicing transaction must spend SegWit UTXOs so that the splicing transaction itself is not malleable.\n4.  For pure splice-out, it would be possible to continue operating the channel even when the splicing transaction is not yet confirmed.  The channel updates commitment transactions that spend the next funding transaction output (an output of the splicing tranasction).  This is because the splicing transaction cannot be invalidated except by use of a revoked transaction.\n5.  For any splice-in, there is the possibility that inputs are forcibly double-spent while the splicing transaction is unconfirmed, so the channel cannot be safely used until the splicing transaction is confirmed.  Getting around this is possible but adds significantly more complexity I think.\n6.  Rough idea of protocol would be like this:\n6.1.  Write up the splicing transaction without signing it.\n6.2.  Write and sign commitment transactions based on the splicing transaction.\n6.3.  Sign the splicing transaction.  This requires both parties.  After signing and before sending the splicing transaction, prevent use of the channel (whether pure splice-out or has any splice-in).\n6.4.  Broadcast the fully-signed transaction.\n6.5.  If pure splice-out, you can now exchange revocation keys for the previous commitment transactions and reenable use of the channel.\n6.6.  If any splice-in is involved, wait for the splicing transaction to confirm before reenabling it (exchanging revocation keys is unnecessary for this since if the splicing transaction confirms, all previous commitment transactions are unuseable).\n\nThe splicing protocol will exist in BOLT 1.1, although I am unaware if there are people already working on this.\n\n--\n\nIt is possible to just open a new channel to a different node that is indirectly connected to the channel you want to replenish, then send a payment from your new channel to your exhausted channel.  This has the advantage that (1) it works with current protocol (although no current node software implements this to my knowledge), (2) the exhausted channel can still be used for receiving and routing while you are doing so.  This also helps the general network health and connectivity.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: [Lightning-dev] reducing the number of blockchain transactions used by the LN, and the fees paid to confirm them\n> Local Time: December 21, 2017 9:52 AM\n> UTC Time: December 21, 2017 1:52 AM\n> From: jim.renkel at comcast.net\n> To: Lightning-dev at lists.linuxfoundation.org\n>\n> Hello, all!\n>\n> I'm a long-time computer networking developer, but a newbie to\n> cryptocurrency, and am interested in contributing to its development.\n>\n> While looking at the lightning network design and code, I've come up\n> with an idea the would reduce the number of blockchain transactions used\n> by the LN, and the fees paid to confirm them, in a common LN use case.\n>\n> I did a quick search and couldn't find this idea presented previously,\n> but I may have missed it. If so, or if the idea is faulty, I'm sure you\n> guys will let me know. :-)\n>\n> And forgive me if I don't have the terminology quite right yet.\n>\n> The use case I am referring to is the frequent, repeated purchases by a\n> customer from the same merchant over an extended period of time. I think\n> this will be a common use case.\n>\n> For example: Alice buys a cup of coffee from Bob's Coffee Shoppe every\n> day, has done so for years, will do so for years.\n>\n> To use the LN to pay for these purchases, Alice opens and funds an LN\n> channel to Bob. This takes one blockchain transaction.\n>\n> As coffees are purchased every day, funds are transferred from Alice to\n> Bob in the channel without any blockchain transactions.\n>\n> Alice cannot afford to fund the channel for an extended period of time,\n> and Bob is unwilling to wait an extended period of time to be paid for\n> the coffees Alice has purchased.\n>\n> So every week or so, Alice and Bob close the channel, Alice gets back\n> any unspent funds, and Bob gets the funds that have been transferred to\n> him for Alice's purchases. Then Alice and Bob re-open the channel with\n> new funding from Alice. Closing and re-opening the channel each take one\n> blockchain transaction.\n>\n> Over the life of the channel, if there are n close/re-open cycles, 2*n\n> blockchain transactions are required: 1 to open the channel initially, 2\n> each time the channel is closed and re-opened (n-1 times), and 1 to\n> close the channel finally.\n>\n> If the LN were enhanced with an operation to deposit and withdraw\n> funding in the channel to and from the blockchain without closing the\n> channel, this could be done with a single blockchain transaction that is\n> essentially the merge of the closing and re-opening blockchain transactions.\n>\n> In this example, each adjustment will only pay Bob his accumulated but\n> as yet unpaid funds and charge Alice for the new funds she places into\n> the channel, but leave Alice's unspent funds in the channel. The channel\n> could continue to operate between the launching and confirmation of the\n> adjustment transaction if Alice has unspent funds in the channel.\n>\n> Then the n cycles would only require n+1 blockchain transactions: 1 to\n> initially open the channel, 1 each time the channel funding is adjusted\n> (total n-1), and 1 to finally close the channel. This is a significant\n> reduction in the number of blockchain transactions required, approaching\n> 50% in the limit as n approaches infinity.\n>\n> What about blockchain transaction fees? I've done the analysis, but it's\n> quite long (several conditions and dozens of combinations of conditions\n> to consider), so I won't include it here now. I will included it in\n> another post if anyone is interested and doesn't do the analysis for\n> themselves.\n>\n> The bottom line of the analysis is that the number of inputs and the\n> number of outputs in the funding adjustment transaction are each never\n> greater than the sum of the number of inputs and the number of outputs,\n> respectively, in the channel opening and closing transactions that the\n> adjustment transaction replaces.\n>\n> Thus the adjustment transaction is:\n>\n> - never bigger than the closing and re-opening transactions put together,\n> - sometimes smaller, and\n> - occasionally significantly smaller.\n>\n> And there's only one transaction instead of two, so ya always save on\n> the transaction header! :-)\n>\n> Thus, the fee paid for the adjustment transaction, assuming the same fee\n> rate for all the transactions, is:\n> - never more than the sum of the fees paid for the closing and\n> re-opening transactions,\n> - sometimes less, and\n> - occasionally significantly less.\n>\n> This reduction in fees is by an additive amount.\n>\n> Because the channel remains open while waiting for the adjustment\n> transaction to confirm, there may be less urgency in having it confirm.\n> So it's fee rate can be reduced, reducing the fee paid by a\n> multiplicative amount.\n>\n> Combined, these two effects lead to a reduction in total fees paid for\n> operating the channel, sometimes a significant reduction.\n>\n> Comments expected and welcome.\n>\n> If this high-level, bare-bones idea is seen to be worthy of further\n> consideration, I would like to work with the community to flesh out a\n> detailed specification, and, if consensus can be reached on that, to\n> participate in the implementation of it.\n>\n> Jim Renkel\n>\n> ---------------------------------------------------------------\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171221/38abb23e/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-21T08:12:44",
                "message_text_only": "Good morning Jim,\n\nReviewing again the link from Dario, I find I am myself in that mailing list thread, for some reason.\n\nChristian Decker mentions the use of a pre-splice-in transaction, implying yet another transaction necessary for splice-in (if we wish to have \"asynchronous\" splice-in, i.e. the time that the channel is unavailable is very short and need not be reported to the rest of the network).  This uses two transactions: a pre-splice-in, and a splicing transaction, meaning the channel splice-in still uses two transactions and is thus not more efficient than the current \"close,then reopen\" available (or my current preference, \"just open a new channel then route funds from the new channel to the old channel and keep both channels open indefinitely\").\n\nWhat I described in the previous e-mail to you is the \"synchronous splice-in\", where the channel is unuseable under a splice-in until the splicing transaction is confirmed.\n\nFor asynchronous splice-in protocol:\n\n1.  Negotiate splice-in with counterparty and create pre-splice-in transaction (leave unsigned).  The pre-splice-in has any number of inputs (from one or both sides of the channel) and a single 2-of-2 output.  The pre-splice-in must be nonmalleable (i.e. it spends only SegWit outputs)\n2.  Create an \"escape transaction\" spending the only output of the pre-splice-in transaction.  This has nLockTime in the future (a few days off) and returns the funds to the sourcing counterparties in the correct amounts.\n3.  Sign the \"escape transaction\" completely and have both sides keep the fully-signed copy of the escape transaction.\n4.  Sign the pre-splice-in transaction and broadcast.\n5.  Wait for the pre-splice-in transaction to confirm.\n6.  Write the splicing transaction, which spends both the current funding transaction output and the pre-splice-in transaction output.\n7.  Write and sign the new commitment transactions.\n8.  Block use of the channel. (this is expected to be a short blockage only between counterparties; if the following steps time out while channel blocked, then the channel needs to be failed).\n9.  Sign the splicing transaction on both sides.  Broadcast (no need to wait for confirmation).\n10.  Invalidate previous commitment transactions: share revocation keys for previous commitment transactions.  Can skip this step if splicing transaction confirms (very unlikely, so maybe not skip this step at all to reduce number of things that need to be tested).\n11.  Unblock use of channel and resume normal operation starting from the new commitment transactions.\n\nFor additional security, the escape transaction and the splicing transaction should be RBF and the splicing transaction should have higher feerate (i.e. it should be able to assuredly replace the escape transaction on the mempool once signed and broadcast).  This may not buy much: possibly, if the splicing transaction does not confirm quickly enough, the splicing-in counterparty can bribe miners out-of-band to include the escape transaction rather than the splicing transaction.\n\nAlso the splicing transaction can also splice-out and splicing in at the same time.\n\nAgain, the above \"asynchronous\" splice-in is not more efficient than the close-then-reopen, but it has the advantage that the channel is unuseable for a tiny amount of time, whereas a close-then-reopen would prevent use of the channel until the reopening funding transaction is confirmed.\n\n1.  Synchronous splice-in: 1 transaction, but cannot use channel until splicing transaction is confirmed (might as well gossip it as a close of the channel, then gossip a reopen when confirmed, to prevent attempts to route via the channel).\n2.  Asynchronous splice-in: 2 transactions, but can use channel as soon as splice protocol completes.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] reducing the number of blockchain transactions used by the LN, and the fees paid to confirm them\n> Local Time: December 21, 2017 2:44 PM\n> UTC Time: December 21, 2017 6:44 AM\n> From: ZmnSCPxj at protonmail.com\n> To: Jim Renkel <jim.renkel at comcast.net>\n> Lightning-dev at lists.linuxfoundation.org <Lightning-dev at lists.linuxfoundation.org>\n>\n> Good morning Jim,\n>\n> The idea is called \"splce in/out\" and as Dario Sneidermanis mentioned, has occasionally been discussed on this list every now and then.\n>\n> To my understanding:\n>\n> 1.  The splicing transaction has as input the previous funding transaction output.\n> 2.  The splicing transaction has an output that is the next funding transaction output.\n> 3.  All other inputs (to be spliced-in) of the splicing transaction must spend SegWit UTXOs so that the splicing transaction itself is not malleable.\n> 4.  For pure splice-out, it would be possible to continue operating the channel even when the splicing transaction is not yet confirmed.  The channel updates commitment transactions that spend the next funding transaction output (an output of the splicing tranasction).  This is because the splicing transaction cannot be invalidated except by use of a revoked transaction.\n> 5.  For any splice-in, there is the possibility that inputs are forcibly double-spent while the splicing transaction is unconfirmed, so the channel cannot be safely used until the splicing transaction is confirmed.  Getting around this is possible but adds significantly more complexity I think.\n> 6.  Rough idea of protocol would be like this:\n> 6.1.  Write up the splicing transaction without signing it.\n> 6.2.  Write and sign commitment transactions based on the splicing transaction.\n> 6.3.  Sign the splicing transaction.  This requires both parties.  After signing and before sending the splicing transaction, prevent use of the channel (whether pure splice-out or has any splice-in).\n> 6.4.  Broadcast the fully-signed transaction.\n> 6.5.  If pure splice-out, you can now exchange revocation keys for the previous commitment transactions and reenable use of the channel.\n> 6.6.  If any splice-in is involved, wait for the splicing transaction to confirm before reenabling it (exchanging revocation keys is unnecessary for this since if the splicing transaction confirms, all previous commitment transactions are unuseable).\n>\n> The splicing protocol will exist in BOLT 1.1, although I am unaware if there are people already working on this.\n>\n> --\n>\n> It is possible to just open a new channel to a different node that is indirectly connected to the channel you want to replenish, then send a payment from your new channel to your exhausted channel.  This has the advantage that (1) it works with current protocol (although no current node software implements this to my knowledge), (2) the exhausted channel can still be used for receiving and routing while you are doing so.  This also helps the general network health and connectivity.\n>\n> Regards,\n> ZmnSCPxj\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n>> -------- Original Message --------\n>> Subject: [Lightning-dev] reducing the number of blockchain transactions used by the LN, and the fees paid to confirm them\n>> Local Time: December 21, 2017 9:52 AM\n>> UTC Time: December 21, 2017 1:52 AM\n>> From: jim.renkel at comcast.net\n>> To: Lightning-dev at lists.linuxfoundation.org\n>>\n>> Hello, all!\n>>\n>> I'm a long-time computer networking developer, but a newbie to\n>> cryptocurrency, and am interested in contributing to its development.\n>>\n>> While looking at the lightning network design and code, I've come up\n>> with an idea the would reduce the number of blockchain transactions used\n>> by the LN, and the fees paid to confirm them, in a common LN use case.\n>>\n>> I did a quick search and couldn't find this idea presented previously,\n>> but I may have missed it. If so, or if the idea is faulty, I'm sure you\n>> guys will let me know. :-)\n>>\n>> And forgive me if I don't have the terminology quite right yet.\n>>\n>> The use case I am referring to is the frequent, repeated purchases by a\n>> customer from the same merchant over an extended period of time. I think\n>> this will be a common use case.\n>>\n>> For example: Alice buys a cup of coffee from Bob's Coffee Shoppe every\n>> day, has done so for years, will do so for years.\n>>\n>> To use the LN to pay for these purchases, Alice opens and funds an LN\n>> channel to Bob. This takes one blockchain transaction.\n>>\n>> As coffees are purchased every day, funds are transferred from Alice to\n>> Bob in the channel without any blockchain transactions.\n>>\n>> Alice cannot afford to fund the channel for an extended period of time,\n>> and Bob is unwilling to wait an extended period of time to be paid for\n>> the coffees Alice has purchased.\n>>\n>> So every week or so, Alice and Bob close the channel, Alice gets back\n>> any unspent funds, and Bob gets the funds that have been transferred to\n>> him for Alice's purchases. Then Alice and Bob re-open the channel with\n>> new funding from Alice. Closing and re-opening the channel each take one\n>> blockchain transaction.\n>>\n>> Over the life of the channel, if there are n close/re-open cycles, 2*n\n>> blockchain transactions are required: 1 to open the channel initially, 2\n>> each time the channel is closed and re-opened (n-1 times), and 1 to\n>> close the channel finally.\n>>\n>> If the LN were enhanced with an operation to deposit and withdraw\n>> funding in the channel to and from the blockchain without closing the\n>> channel, this could be done with a single blockchain transaction that is\n>> essentially the merge of the closing and re-opening blockchain transactions.\n>>\n>> In this example, each adjustment will only pay Bob his accumulated but\n>> as yet unpaid funds and charge Alice for the new funds she places into\n>> the channel, but leave Alice's unspent funds in the channel. The channel\n>> could continue to operate between the launching and confirmation of the\n>> adjustment transaction if Alice has unspent funds in the channel.\n>>\n>> Then the n cycles would only require n+1 blockchain transactions: 1 to\n>> initially open the channel, 1 each time the channel funding is adjusted\n>> (total n-1), and 1 to finally close the channel. This is a significant\n>> reduction in the number of blockchain transactions required, approaching\n>> 50% in the limit as n approaches infinity.\n>>\n>> What about blockchain transaction fees? I've done the analysis, but it's\n>> quite long (several conditions and dozens of combinations of conditions\n>> to consider), so I won't include it here now. I will included it in\n>> another post if anyone is interested and doesn't do the analysis for\n>> themselves.\n>>\n>> The bottom line of the analysis is that the number of inputs and the\n>> number of outputs in the funding adjustment transaction are each never\n>> greater than the sum of the number of inputs and the number of outputs,\n>> respectively, in the channel opening and closing transactions that the\n>> adjustment transaction replaces.\n>>\n>> Thus the adjustment transaction is:\n>>\n>> - never bigger than the closing and re-opening transactions put together,\n>> - sometimes smaller, and\n>> - occasionally significantly smaller.\n>>\n>> And there's only one transaction instead of two, so ya always save on\n>> the transaction header! :-)\n>>\n>> Thus, the fee paid for the adjustment transaction, assuming the same fee\n>> rate for all the transactions, is:\n>> - never more than the sum of the fees paid for the closing and\n>> re-opening transactions,\n>> - sometimes less, and\n>> - occasionally significantly less.\n>>\n>> This reduction in fees is by an additive amount.\n>>\n>> Because the channel remains open while waiting for the adjustment\n>> transaction to confirm, there may be less urgency in having it confirm.\n>> So it's fee rate can be reduced, reducing the fee paid by a\n>> multiplicative amount.\n>>\n>> Combined, these two effects lead to a reduction in total fees paid for\n>> operating the channel, sometimes a significant reduction.\n>>\n>> Comments expected and welcome.\n>>\n>> If this high-level, bare-bones idea is seen to be worthy of further\n>> consideration, I would like to work with the community to flesh out a\n>> detailed specification, and, if consensus can be reached on that, to\n>> participate in the implementation of it.\n>>\n>> Jim Renkel\n>>\n>> ---------------------------------------------------------------\n>>\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171221/9fe3e862/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "reducing the number of blockchain transactions used by the LN, and the fees paid to confirm them",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Jim Renkel",
                "Dario Sneidermanis"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 35973
        }
    },
    {
        "title": "[Lightning-dev] Is it possible to fund multiple channels using single transaction with multiple output?",
        "thread_messages": [
            {
                "author": "Ignatius Rivaldi",
                "date": "2017-12-25T03:12:50",
                "message_text_only": "Hi,\n\nI'm a noob in bitcoin and lightning network, and several days ago I\njust knew a concept called transaction batching, which is to pay\nmultiple payments with single transaction and single transaction fee,\nwhich is much cheaper then doing multiple payments with multiple\ntransactions and multiple transaction fee. Now, is it possible to use\nthis thing to create multiple lightning channels with single\ntransaction, reducing transaction fee?\n\nThanks,"
            },
            {
                "author": "Christian Decker",
                "date": "2017-12-25T11:41:22",
                "message_text_only": "Hi Ignatius,\n\nwelcome to the list :-)\n\n> I'm a noob in bitcoin and lightning network, and several days ago I\n> just knew a concept called transaction batching, which is to pay\n> multiple payments with single transaction and single transaction fee,\n> which is much cheaper then doing multiple payments with multiple\n> transactions and multiple transaction fee. Now, is it possible to use\n> this thing to create multiple lightning channels with single\n> transaction, reducing transaction fee?\n\nAbsolutely, the protocol always refers to a channel by its short channel\nID (blockheight, transaction pos, output pos). So a single transaction\ncan fund multiple channels. I should however mention that this is\ncurrently not implemented in any of the wallets, but it shouldn't be too\nmuch of a problem to do so. The main problem is that in order to use\nthis you need to coordinate the fund-channel process for all channels in\nparallel, so initially it's probably only going to be used to fund\nchannels from a single initiator.\n\nCheers,\nChristian"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-12-26T04:10:03",
                "message_text_only": "Good morning Ignatius and Christian,\n\nI was thinking of this also recently.\n\nI was thinking it would be possible to create a \"multifundchannel\" command, which accepts multiple node id and msatoshi pairs, which would create a transaction with multiple channel outputs and negotiate with each node.  A difficulty would be ensuring that all target nodes are alive, as well as to consider what to do if some of the target nodes are not contactable - do we \"fail hard\" and not make any channels or do we \"fail soft\" and make channels only with nodes that are alive and ignore dead nodes, but that can be added as an option.  Another difficulty would be to wait for all counterparties to complete the protocol and sign the commitment transactions, before signing and broadcasting the initial opening transaction.  Doable, I suppose.\n\nThe same command can then be modified in the future to utilize Decker-Burchert-Wattenhofer channel factories, where the channel factory (like the current channels) are initially funded by a single party.  In the same way that we punted on the funding of channels and made them initially funded by a single party, we could punt on channel factories and make them initially funded by a single party, but add new protocol messages for channel factory operations (although I cannot imagine how those would function as yet -- but then we should really focus on making the network itself first).\n\nRegards,\nZmnSCPxj\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] Is it possible to fund multiple channels using single transaction with multiple output?\n> Local Time: December 25, 2017 7:41 PM\n> UTC Time: December 25, 2017 11:41 AM\n> From: decker.christian at gmail.com\n> To: Ignatius Rivaldi <minecraft2048 at gmail.com>, lightning-dev at lists.linuxfoundation.org\n>\n> Hi Ignatius,\n>\n> welcome to the list :-)\n>\n>> I'm a noob in bitcoin and lightning network, and several days ago I\n>> just knew a concept called transaction batching, which is to pay\n>> multiple payments with single transaction and single transaction fee,\n>> which is much cheaper then doing multiple payments with multiple\n>> transactions and multiple transaction fee. Now, is it possible to use\n>> this thing to create multiple lightning channels with single\n>> transaction, reducing transaction fee?\n>\n> Absolutely, the protocol always refers to a channel by its short channel\n> ID (blockheight, transaction pos, output pos). So a single transaction\n> can fund multiple channels. I should however mention that this is\n> currently not implemented in any of the wallets, but it shouldn't be too\n> much of a problem to do so. The main problem is that in order to use\n> this you need to coordinate the fund-channel process for all channels in\n> parallel, so initially it's probably only going to be used to fund\n> channels from a single initiator.\n>\n> Cheers,\n> Christian\n> ---------------------------------------------------------------\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20171225/b2ef79b1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Is it possible to fund multiple channels using single transaction with multiple output?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Ignatius Rivaldi",
                "Christian Decker"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4761
        }
    }
]