[
    {
        "title": "[Lightning-dev] [BOLT Draft] Onion Routing Spec",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2016-10-03T17:21:35",
                "message_text_only": "> I think this only works if the on-chain keys are Schnorr, right?\n\nWe'd use the same curve equation and domain parameters as Bitcoin uses\ncurrently, but would swap out EC-DSA for EC-Schnorr. So as a result,\npub/priv keys stay the same, meaning the on-chain keys can be used for\nsigning/verifying the multi-sign for channel authentication proofs.\n\n> Indeed.  Let me try to enumerate the different secrets we need to\n> protect, and you tell me what I missed?\n\nExcellent, this looks like an accurate breakdown to me. The only thing I'd\nadd is that compromise of the identity public key allows an attacker to\nopen/accept authenticated+confidential p2p connections on the network. In\nisolation this seems pretty harmless as they're capabilities with one this\nkey is rather limited.\n\n>From a compartmentalization standpoint, unless there are significant gains\nfrom coupling keys from distinct categories, all keying material should be\nas independent as possible.\n\nAt the very least (as you detailed), the commit keys should be rolled anew\nfor each channel. This opens up the doors to architectures such as\nper-channel process signers w/ mlock'd secrets, dedicated hardware, etc.\n\n> Separating onion privkey allows rotation; only a win if we get forward\n> secrecy (not a win for this node, as much as for the network as a\n> whole).\n\nAgreed, if we're not initially doing passive (or active) key rotation for\nthe onion keys, then coupling the identity and onion keys simplifies the\ncode at that level and nixes a few network layer control messages.\n\n> The comms symmetric key should be rotated with forward secrecy as\n> well, for similar reasons.\n\nIndeed, we can throw in a simple ratcheting scheme into the initial p2p\nspec.\n\n-- Laolu\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161003/6a86cc38/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2016-10-03T21:34:57",
                "message_text_only": "On Mon, Oct 03, 2016 at 05:21:35PM +0000, Olaoluwa Osuntokun wrote:\n> > I think this only works if the on-chain keys are Schnorr, right?\n> \n> We'd use the same curve equation and domain parameters as Bitcoin uses\n> currently, but would swap out EC-DSA for EC-Schnorr. So as a result,\n> pub/priv keys stay the same, meaning the on-chain keys can be used for\n> signing/verifying the multi-sign for channel authentication proofs.\n\nSo we'd still be using ECDSA for everything that could go to the\nbitcoin blockchain, and use Schnorr for all other crypto\nprimitives. Sounds good to me, if we can be certain that reuse across\ndifferent schemes does not open us to new threats.\n\n> > Separating onion privkey allows rotation; only a win if we get forward\n> > secrecy (not a win for this node, as much as for the network as a\n> > whole).\n> \n> Agreed, if we're not initially doing passive (or active) key rotation for\n> the onion keys, then coupling the identity and onion keys simplifies the\n> code at that level and nixes a few network layer control messages.\n\nI'd argue that rotating the onion key is already valuable in order to\nlimit the shared secret backlog, allowing us to forget them after a\nrotation, even if we don't have forward secrecy. If we can get forward\nsecrecy as well all the better though :-)\n\nCheers,\nChristian"
            },
            {
                "author": "Christian Decker",
                "date": "2016-10-20T13:40:47",
                "message_text_only": "Just a quick update on my side: I have updated the spec as discussed during\nthe milan meetup and dropped the end-to-end payload, since we don't have\nany good usecase for it currently.\n\nI kept the shared secret backlog for now, since committing the routing\ninformation to the payment hash is awkward: either we include the payment\nhash in each per-hop payload, making it possible to stop a replay\nimmediately, or we add it to the last per-hop payload, at which point only\nthe last hop would be able to identify a replay attack, making it possible\nto replay and observe traffic patterns. In both cases we'd be increasing\nthe per-hop payload size, which is pretty expensive to do.\n\nBoth the C-lightning implementation and the lnd implementations have been\nadapted and can be used.\n\nCheers,\nChristian\n\nOn Mon, Oct 3, 2016 at 11:34 PM Christian Decker <decker.christian at gmail.com>\nwrote:\n\nOn Mon, Oct 03, 2016 at 05:21:35PM +0000, Olaoluwa Osuntokun wrote:\n> > I think this only works if the on-chain keys are Schnorr, right?\n>\n> We'd use the same curve equation and domain parameters as Bitcoin uses\n> currently, but would swap out EC-DSA for EC-Schnorr. So as a result,\n> pub/priv keys stay the same, meaning the on-chain keys can be used for\n> signing/verifying the multi-sign for channel authentication proofs.\n\nSo we'd still be using ECDSA for everything that could go to the\nbitcoin blockchain, and use Schnorr for all other crypto\nprimitives. Sounds good to me, if we can be certain that reuse across\ndifferent schemes does not open us to new threats.\n\n> > Separating onion privkey allows rotation; only a win if we get forward\n> > secrecy (not a win for this node, as much as for the network as a\n> > whole).\n>\n> Agreed, if we're not initially doing passive (or active) key rotation for\n> the onion keys, then coupling the identity and onion keys simplifies the\n> code at that level and nixes a few network layer control messages.\n\nI'd argue that rotating the onion key is already valuable in order to\nlimit the shared secret backlog, allowing us to forget them after a\nrotation, even if we don't have forward secrecy. If we can get forward\nsecrecy as well all the better though :-)\n\nCheers,\nChristian\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161020/dfa568e8/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2016-10-20T22:26:07",
                "message_text_only": "> I kept the shared secret backlog for now, since committing the routing\n> information to the payment hash is awkward\n\nWhen we agreed to include the payment hash in the MAC check within the\nheader, I assumed that the packet format wouldn't be modified to include the\npayment hash (either in the header or e2e payload).\n\nInstead, I envisioned that the payment hash would be a parameter to the\npacket processing/creation function. When creating or processing the packet,\nthe payment hash would be concatenated to the material being authenticated\nsimilar to the \"associated data\" in AEAD cipher modes. With this scheme,\nthere's no additional data added to the packets, but the payment hash is\nauthenticated as part of packet processing at each hop.\n\nSo if an adversary attempts a replay, then they're forced to use the same\npayment hash, otherwise the packet won't propagate. Assuming all nodes\nremember all payment hashes, then replay attempts always fail and come at a\ndirect monetary cost to the attacker.\n\n-- Laolu\n\n\nOn Thu, Oct 20, 2016 at 6:41 AM Christian Decker <decker.christian at gmail.com>\nwrote:\n\n> Just a quick update on my side: I have updated the spec as discussed\n> during the milan meetup and dropped the end-to-end payload, since we don't\n> have any good usecase for it currently.\n>\n> I kept the shared secret backlog for now, since committing the routing\n> information to the payment hash is awkward: either we include the payment\n> hash in each per-hop payload, making it possible to stop a replay\n> immediately, or we add it to the last per-hop payload, at which point only\n> the last hop would be able to identify a replay attack, making it possible\n> to replay and observe traffic patterns. In both cases we'd be increasing\n> the per-hop payload size, which is pretty expensive to do.\n>\n> Both the C-lightning implementation and the lnd implementations have been\n> adapted and can be used.\n>\n> Cheers,\n> Christian\n>\n>\n> On Mon, Oct 3, 2016 at 11:34 PM Christian Decker <\n> decker.christian at gmail.com> wrote:\n>\n> On Mon, Oct 03, 2016 at 05:21:35PM +0000, Olaoluwa Osuntokun wrote:\n> > > I think this only works if the on-chain keys are Schnorr, right?\n> >\n> > We'd use the same curve equation and domain parameters as Bitcoin uses\n> > currently, but would swap out EC-DSA for EC-Schnorr. So as a result,\n> > pub/priv keys stay the same, meaning the on-chain keys can be used for\n> > signing/verifying the multi-sign for channel authentication proofs.\n>\n> So we'd still be using ECDSA for everything that could go to the\n> bitcoin blockchain, and use Schnorr for all other crypto\n> primitives. Sounds good to me, if we can be certain that reuse across\n> different schemes does not open us to new threats.\n>\n> > > Separating onion privkey allows rotation; only a win if we get forward\n> > > secrecy (not a win for this node, as much as for the network as a\n> > > whole).\n> >\n> > Agreed, if we're not initially doing passive (or active) key rotation for\n> > the onion keys, then coupling the identity and onion keys simplifies the\n> > code at that level and nixes a few network layer control messages.\n>\n> I'd argue that rotating the onion key is already valuable in order to\n> limit the shared secret backlog, allowing us to forget them after a\n> rotation, even if we don't have forward secrecy. If we can get forward\n> secrecy as well all the better though :-)\n>\n> Cheers,\n> Christian\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161020/40137071/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2016-10-21T08:30:59",
                "message_text_only": "On Thu, Oct 20, 2016 at 10:26:07PM +0000, Olaoluwa Osuntokun wrote:\n> When we agreed to include the payment hash in the MAC check within the\n> header, I assumed that the packet format wouldn't be modified to include the\n> payment hash (either in the header or e2e payload).\n> \n> Instead, I envisioned that the payment hash would be a parameter to the\n> packet processing/creation function. When creating or processing the packet,\n> the payment hash would be concatenated to the material being authenticated\n> similar to the \"associated data\" in AEAD cipher modes. With this scheme,\n> there's no additional data added to the packets, but the payment hash is\n> authenticated as part of packet processing at each hop.\n> \n> So if an adversary attempts a replay, then they're forced to use the same\n> payment hash, otherwise the packet won't propagate. Assuming all nodes\n> remember all payment hashes, then replay attempts always fail and come at a\n> direct monetary cost to the attacker.\n\nDamn, I knew I was forgetting something, thank Laolu for the reminder,\nI'll add that to the spec and the implementations.\n\nCheers,\nChristian"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-10-24T03:59:10",
                "message_text_only": "Olaoluwa Osuntokun <laolu32 at gmail.com> writes:\n>> I kept the shared secret backlog for now, since committing the routing\n>> information to the payment hash is awkward\n>\n> When we agreed to include the payment hash in the MAC check within the\n> header, I assumed that the packet format wouldn't be modified to include the\n> payment hash (either in the header or e2e payload).\n\nYep, that was my understanding too.\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Onion Routing Spec",
            "categories": [
                "Lightning-dev",
                "BOLT Draft"
            ],
            "authors": [
                "Rusty Russell",
                "Olaoluwa Osuntokun",
                "Christian Decker"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 10968
        }
    },
    {
        "title": "[Lightning-dev] Blockstream Successfully Tests End-to-End Lightning Micropayment Transaction",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2016-10-05T16:00:18",
                "message_text_only": "Hi everybody\n\nThe following blog post describes our recent use of an v0.5 C lightning\nprototype, showcasing a completed transaction that included invoicing,\nmulti-hop payment, and item delivery. The included links provide additional\ncontent and supporting code, as well as a short video. This will be going\nlive on Blockstream\u2019s blog shortly.\n\nRegards,\nRusty Russell\nDr. Christian Decker\n\n\n\nLightning First Strike: Christian Bought a Cat\nRusty Russell, October 5, 2016\nhttps://blockstream.com/blog/\n\nThis story of feline acquisition begins with the demonstration of v0.5 of\nthe C lightning prototype, a lightning-fast micropayment system we've been\nworking on here at Blockstream (see\nhttps://github.com/ElementsProject/lightning). To test the impending\nprototype, we set up a web server to create invoices for test bitcoin\npayments over the lightning network, and in return to offer a cat, or at\nleast an ASCII cat picture.\n\nDr. Christian Decker, another Blockstream developer working with me,\npurchased the feline picture using 0.01 test bitcoin to open a lightning\nchannel with the server (see\nhttp://tbtc.blockr.io/tx/info/c909f1fb5e971e32ae20e34cf6cf766f7237bfadf75aa6646a42063b9acba82b),\nwhich was mined in test block 928335 (see\nhttp://tbtc.blockr.io/block/info/928335). After a single confirmation, he\npaid the invoice with a 100 satoshi transfer. Afterward, he accessed the\nlink to find his cat picture (see\nhttp://128.199.80.48/?43744e221d794dcc0e61f8a757fa0346). He discovered it\nwas an ASCII picture, with a nice bonus. Two cats! Christian promptly\nopened another node, connected to the first node, and bought a second copy\nof the cat picture by routing through the previous node.\n\nWhat Happened Behind The Scenes?\n\nA Digital Ocean server runs Apache, bitcoind, and lightningd. When\naccessed, a CGI script calls 'lightning-cli invoice 100000' to create an\ninvoice, which is presented to the user (see\nhttps://github.com/rustyrussell/lightning-cat/blob/cc206788c552e2f7feb616170178c7ec38ccedb5/catsearch.sh).\nThe user clicks through a unique link, and if 'lightning-cli listinvoice'\nindicates that the invoice was paid, the script presents the picture.\n\nThis is the first end-to-end test of a lightning micropayment network,\nincluding invoicing, multi-hop payment, and item delivery. It is very\ndifferent from Acinq's recent simulation (see\nhttp://www.coindesk.com/bitcoins-lightning-network-milestone-acinq-routing/)\nof a lightning routing algorithm called Flare (See\nhttp://bitfury.com/content/5-white-papers-research/whitepaper_flare_an_approach_to_routing_in_lightning_network_7_7_2016.pdf).\nTheir work shows how, by way of simple analogy, one can create a streetmap\nto get from A to B in an efficient way, while the test we've demonstrated\nhere with v0.5 of the C lightning prototype has us actually walking that\npath on the street.\n\nWhat's Next?\n\nWe found a few bugs in corner cases and hit some known FIXMEs, but also\nmade lightningd more robust against misconfiguration. There are a few rough\nedges that we'd still like to smooth and some documentation that we'd like\nto write before the 0.5 release. Then, we want to create libraries to allow\nweb developers to play with constructing their own cat picture stores!\n\nIn the meantime, here's a short video that shows this working (see\nhttps://asciinema.org/a/ergldrzd43j08klix08hf9yl3). The low production\nvalue fits with the ASCII art.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161005/05e0db9d/attachment.html>"
            },
            {
                "author": "gb",
                "date": "2016-10-05T21:11:49",
                "message_text_only": "Hi\n\nThanks for the demo Christian. \n\nRandy, you might like to know that I noticed that lightningd is using\nport 8334 and that namecoind has used port 8334 since it was launched in\nMay 2011.\n\nOn Wed, 2016-10-05 at 16:00 +0000, Christian Decker wrote:\n> Hi everybody\n> \n> \n> The following blog post describes our recent use of an v0.5 C\n> lightning prototype, showcasing a completed transaction that included\n> invoicing, multi-hop payment, and item delivery. The included links\n> provide additional content and supporting code, as well as a short\n> video. This will be going live on Blockstream\u2019s blog shortly.\n> \n> \n> Regards,\n> Rusty Russell\n> Dr. Christian Decker\n> \n> \n> \n> \n> \n> \n> Lightning First Strike: Christian Bought a Cat\n> Rusty Russell, October 5, 2016\n> https://blockstream.com/blog/\n> \n> \n> This story of feline acquisition begins with the demonstration of v0.5\n> of the C lightning prototype, a lightning-fast micropayment system\n> we've been working on here at Blockstream (see\n> https://github.com/ElementsProject/lightning). To test the impending\n> prototype, we set up a web server to create invoices for test bitcoin\n> payments over the lightning network, and in return to offer a cat, or\n> at least an ASCII cat picture.\n> \n> \n> Dr. Christian Decker, another Blockstream developer working with me,\n> purchased the feline picture using 0.01 test bitcoin to open a\n> lightning channel with the server (see\n> http://tbtc.blockr.io/tx/info/c909f1fb5e971e32ae20e34cf6cf766f7237bfadf75aa6646a42063b9acba82b), which was mined in test block 928335 (see http://tbtc.blockr.io/block/info/928335). After a single confirmation, he paid the invoice with a 100 satoshi transfer. Afterward, he accessed the link to find his cat picture (see http://128.199.80.48/?43744e221d794dcc0e61f8a757fa0346). He discovered it was an ASCII picture, with a nice bonus. Two cats! Christian promptly opened another node, connected to the first node, and bought a second copy of the cat picture by routing through the previous node.\n> \n> \n> What Happened Behind The Scenes?\n> \n> \n> A Digital Ocean server runs Apache, bitcoind, and lightningd. When\n> accessed, a CGI script calls 'lightning-cli invoice 100000' to create\n> an invoice, which is presented to the user (see\n> https://github.com/rustyrussell/lightning-cat/blob/cc206788c552e2f7feb616170178c7ec38ccedb5/catsearch.sh). The user clicks through a unique link, and if 'lightning-cli listinvoice' indicates that the invoice was paid, the script presents the picture.\n>  \n> This is the first end-to-end test of a lightning micropayment network,\n> including invoicing, multi-hop payment, and item delivery. It is very\n> different from Acinq's recent simulation (see\n> http://www.coindesk.com/bitcoins-lightning-network-milestone-acinq-routing/) of a lightning routing algorithm called Flare (See http://bitfury.com/content/5-white-papers-research/whitepaper_flare_an_approach_to_routing_in_lightning_network_7_7_2016.pdf). Their work shows how, by way of simple analogy, one can create a streetmap to get from A to B in an efficient way, while the test we've demonstrated here with v0.5 of the C lightning prototype has us actually walking that path on the street.\n>  \n> What's Next?\n> \n> \n> We found a few bugs in corner cases and hit some known FIXMEs, but\n> also made lightningd more robust against misconfiguration. There are a\n> few rough edges that we'd still like to smooth and some documentation\n> that we'd like to write before the 0.5 release. Then, we want to\n> create libraries to allow web developers to play with constructing\n> their own cat picture stores!\n>  \n> In the meantime, here's a short video that shows this working (see\n> https://asciinema.org/a/ergldrzd43j08klix08hf9yl3). The low production\n> value fits with the ASCII art.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Christian Decker",
                "date": "2016-10-05T21:37:06",
                "message_text_only": "Hi gb,\n\nthat is mostly just coincidence, by default the implementation will bind to\na random port, but to make the server easier to find Rusty fixed the port\nto 8334, it's just easier to remember than a random one :-)\n\nCheers,\nChristian\n\nOn Wed, Oct 5, 2016 at 11:11 PM gb <kiwigb at yahoo.com> wrote:\n\n> Hi\n>\n> Thanks for the demo Christian.\n>\n> Randy, you might like to know that I noticed that lightningd is using\n> port 8334 and that namecoind has used port 8334 since it was launched in\n> May 2011.\n>\n> On Wed, 2016-10-05 at 16:00 +0000, Christian Decker wrote:\n> > Hi everybody\n> >\n> >\n> > The following blog post describes our recent use of an v0.5 C\n> > lightning prototype, showcasing a completed transaction that included\n> > invoicing, multi-hop payment, and item delivery. The included links\n> > provide additional content and supporting code, as well as a short\n> > video. This will be going live on Blockstream\u2019s blog shortly.\n> >\n> >\n> > Regards,\n> > Rusty Russell\n> > Dr. Christian Decker\n> >\n> >\n> >\n> >\n> >\n> >\n> > Lightning First Strike: Christian Bought a Cat\n> > Rusty Russell, October 5, 2016\n> > https://blockstream.com/blog/\n> >\n> >\n> > This story of feline acquisition begins with the demonstration of v0.5\n> > of the C lightning prototype, a lightning-fast micropayment system\n> > we've been working on here at Blockstream (see\n> > https://github.com/ElementsProject/lightning). To test the impending\n> > prototype, we set up a web server to create invoices for test bitcoin\n> > payments over the lightning network, and in return to offer a cat, or\n> > at least an ASCII cat picture.\n> >\n> >\n> > Dr. Christian Decker, another Blockstream developer working with me,\n> > purchased the feline picture using 0.01 test bitcoin to open a\n> > lightning channel with the server (see\n> >\n> http://tbtc.blockr.io/tx/info/c909f1fb5e971e32ae20e34cf6cf766f7237bfadf75aa6646a42063b9acba82b),\n> which was mined in test block 928335 (see\n> http://tbtc.blockr.io/block/info/928335). After a single confirmation, he\n> paid the invoice with a 100 satoshi transfer. Afterward, he accessed the\n> link to find his cat picture (see\n> http://128.199.80.48/?43744e221d794dcc0e61f8a757fa0346). He discovered it\n> was an ASCII picture, with a nice bonus. Two cats! Christian promptly\n> opened another node, connected to the first node, and bought a second copy\n> of the cat picture by routing through the previous node.\n> >\n> >\n> > What Happened Behind The Scenes?\n> >\n> >\n> > A Digital Ocean server runs Apache, bitcoind, and lightningd. When\n> > accessed, a CGI script calls 'lightning-cli invoice 100000' to create\n> > an invoice, which is presented to the user (see\n> >\n> https://github.com/rustyrussell/lightning-cat/blob/cc206788c552e2f7feb616170178c7ec38ccedb5/catsearch.sh).\n> The user clicks through a unique link, and if 'lightning-cli listinvoice'\n> indicates that the invoice was paid, the script presents the picture.\n> >\n> > This is the first end-to-end test of a lightning micropayment network,\n> > including invoicing, multi-hop payment, and item delivery. It is very\n> > different from Acinq's recent simulation (see\n> >\n> http://www.coindesk.com/bitcoins-lightning-network-milestone-acinq-routing/)\n> of a lightning routing algorithm called Flare (See\n> http://bitfury.com/content/5-white-papers-research/whitepaper_flare_an_approach_to_routing_in_lightning_network_7_7_2016.pdf).\n> Their work shows how, by way of simple analogy, one can create a streetmap\n> to get from A to B in an efficient way, while the test we've demonstrated\n> here with v0.5 of the C lightning prototype has us actually walking that\n> path on the street.\n> >\n> > What's Next?\n> >\n> >\n> > We found a few bugs in corner cases and hit some known FIXMEs, but\n> > also made lightningd more robust against misconfiguration. There are a\n> > few rough edges that we'd still like to smooth and some documentation\n> > that we'd like to write before the 0.5 release. Then, we want to\n> > create libraries to allow web developers to play with constructing\n> > their own cat picture stores!\n> >\n> > In the meantime, here's a short video that shows this working (see\n> > https://asciinema.org/a/ergldrzd43j08klix08hf9yl3). The low production\n> > value fits with the ASCII art.\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161005/59acada7/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2016-10-06T06:59:39",
                "message_text_only": "On Wed, Oct 05, 2016 at 09:37:06PM +0000, Christian Decker wrote:\n> that is mostly just coincidence, by default the implementation will bind to a\n> random port, but to make the server easier to find Rusty fixed the port to\n> 8334, it's just easier to remember than a random one :-)\n\nApparently there's a unicode symbol for lightning, U+2607 (\u2607)\nwhich would be 9735 in decimal, which per IANA is an unassigned port\nat present...\n\n(also, congrats!)\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Blockstream Successfully Tests End-to-End Lightning Micropayment Transaction",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "gb",
                "Christian Decker"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 12683
        }
    },
    {
        "title": "[Lightning-dev] Block chain fee proposal worked out in more detail",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2016-10-10T20:53:25",
                "message_text_only": "I can think more clearly when no one is talking, so I took advantage of\nthe evening to work out my fee proposal in more detail. :-)\n\nA deposits into channel, as a way of paying B.\nAmount to be paid to B:         1.000 BTC\nExtra amount stored in channel: 1.997 BTC\nFee required for commit tx:     0.003 BTC\n\nAnchor tx output size:          3.000 BTC\nCommit tx outputs:\n  to A:                         1.997 BTC\n  to B:                         1.000 BTC\n  fee:                          0.003 BTC\n\n\nNext, A makes microtx to B:\nAmount to be paid to B:         0.500 BTC\nExtra fee required for HTLC:    0.001 BTC\n\nCommit tx outputs while tx is locked:\n  to A:                         1.497 BTC\n  HTLC:                         0.499 BTC\n  to B:                         1.000 BTC\n  fee:                          0.004 BTC\nCommit tx outputs when tx is released to B:\n  to A:                         1.497 BTC\n  to B:                         1.500 BTC\n  fee:                          0.003 BTC\nCommit tx outputs if tx were returned to A:\n  (just like before tx was locked)\n\n\nNext, B makes microtx to A:\nAmount to be paid to A:         1.000 BTC\nExtra fee required for HTLC:    0.001 BTC\n\nCommit tx outputs (while tx is locked):\n  to A:                         1.497 BTC\n  HTLC:                         0.999 BTC\n  to B:                         0.500 BTC\n  fee:                          0.004 BTC\nCommit tx outputs (if tx is released to A):\n  to A:                         2.497 BTC\n  to B:                         0.500 BTC\n  fee:                          0.003 BTC\nCommit tx outputs (if tx is returned to A):\n  (just like before tx was locked)\n\nSo, summarizing the algorithm:\n* Initially, the channel creator pays the fee (presumably, he has an\ninterest in creating the channel, and this is consistent with regular\nBTC payments).\n* Generally speaking, while using the channel, you're just shifting\naround the non-fee part, without touching the fee itself.\n* For as far as adding an HTLC requires extra fees (since it makes the\ntx larger), that fee is deducted from the HTLC itself. Dust-sized txes\nwould create negative-size HTLCs; of course you'd just not create the\nHTLC at even larger tx sizes (the fees of follow-up txes would not make\nthe HTLC worth the effort).\n\nNot yet covered: how to change the fee size when on-blockchain fee\nmarket conditions change.\n\nComments?\n\nCJP"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-10-17T03:15:17",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n> I can think more clearly when no one is talking, so I took advantage of\n> the evening to work out my fee proposal in more detail. :-)\n\nYou effectively extract the bitcoin fee from the HTLC creator on\nestablishment, but extract from the HTLC recipient on HTLC success (by\nrequiring them to on-pay more than the HTLC amount).\n\nThat's a novel twist, but I don't think it's less exploitable than a\nnaive system.  Fees only matter if someone drops onchain; I can make you\npush a pile of HTLCs to me, then drop.\n\nIt does increase channel capacity slightly, since fees come out of\nHTLCs.  But is it worth the complexity?\n\n(FWIW: Note that the Summit decided fees for now would be\ninitiator-pays, initiator-sets, for simplicity, so this discussion would\nbe aimed at v1.1 or whatever we call it).\n\nThanks!\nRusty.\n\n> A deposits into channel, as a way of paying B.\n> Amount to be paid to B:         1.000 BTC\n> Extra amount stored in channel: 1.997 BTC\n> Fee required for commit tx:     0.003 BTC\n>\n> Anchor tx output size:          3.000 BTC\n> Commit tx outputs:\n>   to A:                         1.997 BTC\n>   to B:                         1.000 BTC\n>   fee:                          0.003 BTC\n>\n>\n> Next, A makes microtx to B:\n> Amount to be paid to B:         0.500 BTC\n> Extra fee required for HTLC:    0.001 BTC\n>\n> Commit tx outputs while tx is locked:\n>   to A:                         1.497 BTC\n>   HTLC:                         0.499 BTC\n>   to B:                         1.000 BTC\n>   fee:                          0.004 BTC\n> Commit tx outputs when tx is released to B:\n>   to A:                         1.497 BTC\n>   to B:                         1.500 BTC\n>   fee:                          0.003 BTC\n> Commit tx outputs if tx were returned to A:\n>   (just like before tx was locked)\n>\n>\n> Next, B makes microtx to A:\n> Amount to be paid to A:         1.000 BTC\n> Extra fee required for HTLC:    0.001 BTC\n>\n> Commit tx outputs (while tx is locked):\n>   to A:                         1.497 BTC\n>   HTLC:                         0.999 BTC\n>   to B:                         0.500 BTC\n>   fee:                          0.004 BTC\n> Commit tx outputs (if tx is released to A):\n>   to A:                         2.497 BTC\n>   to B:                         0.500 BTC\n>   fee:                          0.003 BTC\n> Commit tx outputs (if tx is returned to A):\n>   (just like before tx was locked)\n>\n> So, summarizing the algorithm:\n> * Initially, the channel creator pays the fee (presumably, he has an\n> interest in creating the channel, and this is consistent with regular\n> BTC payments).\n> * Generally speaking, while using the channel, you're just shifting\n> around the non-fee part, without touching the fee itself.\n> * For as far as adding an HTLC requires extra fees (since it makes the\n> tx larger), that fee is deducted from the HTLC itself. Dust-sized txes\n> would create negative-size HTLCs; of course you'd just not create the\n> HTLC at even larger tx sizes (the fees of follow-up txes would not make\n> the HTLC worth the effort).\n>\n> Not yet covered: how to change the fee size when on-blockchain fee\n> market conditions change.\n>\n> Comments?\n>\n> CJP\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Block chain fee proposal worked out in more detail",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "CJP"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5763
        }
    },
    {
        "title": "[Lightning-dev] Allowing acknowledgement via commit messages",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-10-13T19:15:36",
                "message_text_only": "Hi all,\n\n        I've been trying to write the spec part about the\npropose/commitsig/revoke cycle.  We agreed that the commitsig message\nwould include an extra \"I included these updates from you\" field.  This\nhas two side-effects I hadn't appreciated.\n\n1. Without it, the state of updates is always linear:\n\n        RECEIVER-PENDING: update pending on receiver side\n        RECEIVER-COMMITTED: update included in receiver commit tx\n        RECEIVER-LOCKEDIN-SENDER-PENDING: and previous receiver commit\n                        tx preimage revealed, update now pending on sender.\n        RECEIVER-LOCKEDIN-SENDER-COMMITTED: update included in sender commit tx\n        BOTH-LOCKEDIN: and previous sender commit tx preimage revealed.\n\n   This means you trigger forwarding on the final state, since both sides\n   are fully committed at that point.\n\n   With the ability to push proposed received updates to the other side\n   by including them in your own commit message, these changes are\n   unordered.  It's no longer a linear state machine (and certainly has\n   many more states).\n\n2. We can't do fail-fast in future.  There was an idea that if the\n   receiver knew it was going to immediately fail an HTLC, it could\n   reply with a \"this HTLC is going to fail\"; if the sender receives\n   that message before it sends \"commit\", it can send a \"undo that\n   HTLC add\" and cancel it out immediately.  It's an easy extension.\n\n   If the receiver can push the uncommitted changes into the sender's\n   commit tx, the receiver can't \"undo\" before commit, and this scheme\n   fails.\n\nI feel bound by decisions we already made, but I am struggling to write\nthe spec clearly enough with this addition.\n\nThoughts?\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Allowing acknowledgement via commit messages",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1705
        }
    },
    {
        "title": "[Lightning-dev] BIP 2: BIP process, revised (review please)",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-10-15T13:01:33",
                "message_text_only": "BIP 2 is currently believed to be a final draft of what will replace BIP 1 in \nspecifying how the entire BIP process works. This Process BIP will require \nrough consensus from the Bitcoin-dev mailing list to become Active (see BIP 2 \nfor the procedure, which I intend to use for its own activation due to absence \nof a clear process defined in BIP 1).\n\nTherefore, if you have any objections to the new BIP process as specified in \nBIP 2, please voice your concerns ASAP.\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki\n\nThanks for your review,\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "BIP 2: BIP process, revised (review please)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 565
        }
    },
    {
        "title": "[Lightning-dev] c-lightning 0.5: Bitcoin Savings & Trust Daily Interest",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-10-19T01:52:29",
                "message_text_only": "Hi all!\n\n\thttps://github.com/ElementsProject/lightning/releases/tag/v0.5-2016-10-19\n\n\tThis release can actually buy a cat picture from\nhttp://128.199.80.48/ which is also running a lightning server on port\n8334.\n\nChristian Decker did much of the heavy lifting for this release, but it\npredates the Milan spec so that's to be the focus of 0.6.\n\nCheers,\nRusty.\n\nChangelog:\n- IRC-based node and channel announcements (thanks Christian).\n- Sphinx-based onion for HTLC privacy (thanks Christian).\n- Primitive helper scripts in contrib/\n- Invoice support for receiving payments.\n- A bit more robustness for operation testnet.\n- Many minor fixes and cleanups."
            }
        ],
        "thread_summary": {
            "title": "c-lightning 0.5: Bitcoin Savings & Trust Daily Interest",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 652
        }
    },
    {
        "title": "[Lightning-dev] Recovering a channel state",
        "thread_messages": [
            {
                "author": "Anton Kumaigorodskiy",
                "date": "2016-10-21T13:52:48",
                "message_text_only": "Mobile devices often get lost/stolen/data erased/etc so possibility of channel recovering or at least having an ability to break it unilaterally on a new device has to be somehow accounted for.\n\nThese are my thoughts so far:\n\n1. The easiest one seems to be an ability to do a unilateral close: on new channel creation it's essential parameters (sufficient to establish an encrypted connection and send an `error` message) are recorded on some server and later retrieved in a case of need.\n\n2. Ability to fully recover a latest channel state seems tricky: a server could be used to sync an entire state on each commit but in this case we'd have to trust a server to never provide an outdated snapshot (and attempt to use an outdated snapshot with a revoked commit is the worst possible scenario). Also once we lose a history of revoked transactions we'd have to completely rely on a chain watcher's honesty from here on (assuming we use a watcher which has to be a case on mobile device).\n\nI was thinking maybe it is somehow possible to directly ask counterparty to provide us the latest channel state? Since counterparty has a mirrored view of our current state it should be fully reconstructible and we can check our own commit tx signature to make sure the snapshot is not completely made up (assuming commit and final keys are derived from a mnemonic code so we can always regenerate them). But once again there seems to be no way to check that snapshot supplied by counterparty is an unrevoked one because at this point we have neither a ShaChain nor a history of revoked commit transactions (we could probably ask a chain watcher if it has such a commit transaction but it once again involves trust).\n\nI'd like to hear your thoughts whether it's possible to get a latest channel snapshot from counterparty in a trustless manner or if it's a good idea at all. If not then what about unilateral close in a way described above?\n\nAnton\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161021/ba8ed4ba/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-10-24T04:11:38",
                "message_text_only": "Anton Kumaigorodskiy <anton.kumaigorodskiy at outlook.com> writes:\n> Mobile devices often get lost/stolen/data erased/etc so possibility of\n> channel recovering or at least having an ability to break it\n> unilaterally on a new device has to be somehow accounted for.\n\nYes, this is a fun topic!  In particular it's one we deferred for 1.0,\nbut it's important to discuss.\n\nLet's assume you still have your ID: if you lose that key, you're\nscrewed.\n\nTadge has done a lot of work on outsourcing vigilence: uploading\nencrypted information to watchers.  This has almost enough information\nfor you to reconstruct the current state, sufficient to mutually close\nthe channel.\n\nThere's an interesting subset of this, which you could do with your\npeers.  Each peer would keep some amount of (encrypted) data for you,\nand *always* send it to you whenever you first connect (if you have\nto ask for it, that's giving too much away).\n\nAs long as one peer is honest, you get enough state to at least cleanly\nshutdown the other peers without getting robbed, or, indeed, them\nknowing that you had data loss.\n\nThere's a lot more work to be done enumerating exactly how this works,\nhowever.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Recovering a channel state",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anton Kumaigorodskiy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3307
        }
    },
    {
        "title": "[Lightning-dev] Single channel on mobile clients",
        "thread_messages": [
            {
                "author": "Anton Kumaigorodskiy",
                "date": "2016-10-29T18:08:27",
                "message_text_only": "It seems to me there are substantial reasons for a mobile LN wallet to only support a single payment channel:\n\n- Typical usage scenario on phones and tablets will be \"open an app\" - \"conduct a micropayment\" - \"send an app to background to be automatically shut down by OS in a few minutes\". So it's safe to say that majority of LN nodes on such devices will be offline 99% of time and as such won't be of much use in relaying payments. Also often it might not be in user's interest if a portion of funds suddenly becomes locked in HTLC (especially if the lock lasts for hours).\n\n- One channel with 1 BTC is better than two 0.5 BTC channels for an end user in a way that he can receive and send larger amounts: two 0.5 BTC channels will never let me receive 0.51 BTC (AFAIK combining multiple channel capacities for a single transaction is possible in theory but won't be implemented in initial LN release).\n\n- Last but not least, having a single payment channel improves UX and simplifies UI and thus lowers the barrier for adoption. Also it is my understanding that mobile users won't care much about relaying payments (and for those of them who will using a phone for this purpose is a bad idea anyway).\n\nMy current plan as I continue working on an Android LN wallet is to design UI and UX in a way that only supports a single payment channel but it's quite possible I've missed something important here so once again I'd like to hear if you think this is a viable approach.\n\nAnton\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20161029/cdb56690/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2016-10-30T15:46:53",
                "message_text_only": "On Sat, Oct 29, 2016 at 06:08:27PM +0000, Anton Kumaigorodskiy wrote:\n> It seems to me there are substantial reasons for a mobile LN wallet to only support a single payment channel:\n\nIf at all possible I'd like to enable even mobile users to open\nmultiple channels and increase the connectivity in the network. I\nthink users are likely to want to open multiple channels, to earn some\nfees, offsetting their own payments, or just to support the\nnetwork. And on the other side, I don't think they'd be too upset if\nwallets went ahead and just created a number of channels by default.\n\n> - Typical usage scenario on phones and tablets will be \"open an app\" - \"conduct a micropayment\" - \"send an app to background to be automatically shut down by OS in a few minutes\". So it's safe to say that majority of LN nodes on such devices will be offline 99% of time and as such won't be of much use in relaying payments. Also often it might not be in user's interest if a portion of funds suddenly becomes locked in HTLC (especially if the lock lasts for hours).\n\nRunning a lightning daemon should be relatively lightweight, so I\nthink it would be reasonable for people to have a wallet running, even\nonly when the phone is plugged in. Even having the app run only a few\nminutes like you said, it can be used to forward a decent amount of\ntransfers over channels that are already established. The locking up\nof funds is indeed problematic, but we can limit the maximum amount\nthat can be locked in at any point in time, and would only impact if\nthe user is attempting to make a transfer that is larger than the\nreserve.\n\n> - One channel with 1 BTC is better than two 0.5 BTC channels for an end user in a way that he can receive and send larger amounts: two 0.5 BTC channels will never let me receive 0.51 BTC (AFAIK combining multiple channel capacities for a single transaction is possible in theory but won't be implemented in initial LN release).\n\nI'd argue the opposite: two channels with 50% each are better, since\nthe user is not relying on a single peer being available when she\nintends to make a payment. Opening a single channel is a classical\nsingle point of failure, a costly one too, since you'd have to tear\ndown the channel, and create a new one.\n\nCombining multiple channels is trivial, and only the two endpoints\nneed to know how to do it. The sender simply generates multiple\nroutes, avoiding exhausted channels, and the recipient has to know\nthat he should wait for the entirety of the funds to be secure before\ntriggering the clearing. So even if the 1.0 protocol does not support\nit, we can add signaling between the endpoints.\n\n> - Last but not least, having a single payment channel improves UX and simplifies UI and thus lowers the barrier for adoption. Also it is my understanding that mobile users won't care much about relaying payments (and for those of them who will using a phone for this purpose is a bad idea anyway).\n\nI don't see a direct connection between UX and the fact that there are\nmultiple channels, just like Bitcoin wallets don't just chose a single\nTCP connection. The underlying connections do not actually have to\nshow up in the UX interface at all, especially if we allow for\nmulti-path routes as above.\n\nIt's true that users won't care too much about relaying other people's\ntransactions, but if the message is that they can offset their own\nfees or earn something by being a nice neighbor, I think people will\nwant to do that :-)\n\n> My current plan as I continue working on an Android LN wallet is to design UI and UX in a way that only supports a single payment channel but it's quite possible I've missed something important here so once again I'd like to hear if you think this is a viable approach.\n\nI am speculating on what users might want, and I might very well be\nwrong. So if you find it easier to build the app assuming a single\nchannel, then that's perfectly fine. But maybe it is possible not to\nbind the single channel and the UX too tightly :-)\n\n> Anton\n\nCheers,\nChristian\n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Single channel on mobile clients",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anton Kumaigorodskiy",
                "Christian Decker"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5884
        }
    }
]