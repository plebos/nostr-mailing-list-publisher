[
    {
        "title": "[Lightning-dev] Onion routing strawman proposal",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-10-02T05:48:39",
                "message_text_only": "Hi all!\n\n        So, I've pushed some test onion routing code in an acceptable\nformat:\nhttps://github.com/ElementsProject/lightning/blob/onion/test/test_onion.c\n\n        #define MESSAGE_SIZE 128\n        #define MAX_HOPS 20\n\n        /* Prepend 0x02 to get pubkey for libsecp256k1 */\n        struct pubkey {\n        \tunsigned char u8[32];\n        };\n\n        struct hop {\n        \tunsigned char msg[MESSAGE_SIZE];\n        \tstruct pubkey pubkey;\n        \tstruct sha256 hmac;\n        };\n\n        struct onion {\n        \tstruct hop hop[MAX_HOPS];\n        };\n\nThat's a fixed 3840 bytes; each node decrypts and removed the tail\nentry, then prepends padding.  (Working backwards like that turns out to\nbe slightly more efficient for generating, see git commits).\n\nThere's nothing exotic in here: it's AES128 counter mode, HMAC using\nSHA256, and Bitcoin's EC with ECDH.  But crypto review particularly\nwelcome!\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-03T16:38:56",
                "message_text_only": "On Fri, Oct 02, 2015 at 03:18:39PM +0930, Rusty Russell wrote:\n> So, I've pushed some test onion routing code in an acceptable\n> format:\n> https://github.com/ElementsProject/lightning/blob/onion/test/test_onion.c\n\n>         struct hop {\n>         \tunsigned char msg[MESSAGE_SIZE];\n>         \tstruct pubkey pubkey;\n>         \tstruct sha256 hmac;\n>         };\n> That's a fixed 3840 bytes;\n\nIs the idea to switch that to non-fixed size using protobufs, or?\n\n> then prepends padding.\n\n(prefixes...)\n\nMy understandng is it works as follows:\n\n * random EC key pairs are generated for each hop, known to the\n   initiator\n * the public key for each hop is included in plaintext as hop.pubkey\n * ECDH is used to establish a shared secret with each hop\n   (initiator uses routing node's pubkey (ie, their lightning node id)\n    and the generated privkey; routing node uses their privkey and the\n    hop.pubkey value)\n * symmetric AES & HMAC keys are derived based on the secret\n\nWhen you receive a message (say you're hop 5) what you'll get is:\n\n  P4 P3 P2 P1 H20 H19 ... H5\n\nwhere P1 is padding added at node 1, and H19 is the hop structure\nintended for node 19, etc; all of those in various stages of\nencryption/decryption.\n\nYou then grab the pubkey from H5.pubkey; which is already plaintext,\nand calculate your shared secret, and generate AES key, HMAC key, IV\nand padding IV from those. That then lets you run a hmac of everything\nyou've received, excluding the final hmac (so, P4 ... P1 H20 .. H6 +\nmsg + pubkey), and compare that to the hmac.\n\nYou then decrypt everything (except maybe the hmac and pubkey, but\nwhatever) using AES in CTR mode with a nonce of IV, giving you:\n\n  P4' P3' P2' P1' H20' H19' .. H4' [M5]\n\nM5 lets you know what to do, and if you need to forward it, you generate\nP5 by encrypting 0000's with AES in CTR mode with a nonce of PAD_IV. You\nforward:\n\n  P5 P4' P3' .. H4'\n\nand you're done.\n\nQuestion:\n\n - I think this means lightning nodes are identified by the\n   full 512 bit (or 257 bit?) public key used for routing -- (ie,\n   knowing the HASH160 of the pubkey isn't enough, unlike in normal\n   bitcoin pay2pubkey transactions).\n\n - I think you can still use different keys for routing and\n   anchors/commitments so far. (Using the anchor transaction to turn\n   your routing id into a beacon would probably change that though)\n\nSigh. I've had a go at reimplementing it in python, but I'm stuck trying\nto reproduce the secret info using pyelliptic (which in turn uses\nopenssl).\n\n...\n\nAh, it looks like the problem is that libsec256k1 actually goes a step\nfurther and runs SHA256(y||x), where \"x\" is the value I'm getting and y\nis '\\x02' is the y value is even and '\\x03' if it's odd. If I try both,\none of them turns out right:\n\n Secret1: d9946724c6bd8d5b58bdd2256a0251816a42f9707c794427a410075e4dbb199c\n Secret2: 105e0c04f0a910d72dcf2683c21903ba08cd8b225e4124afc41bb2341dc40f49\n\nUnfortunately openssl throws away y and just gives us x, so I'm not sure\nif I can work out the right secret directly. I guess I can run the HMAC\ntwice and pick the value that worked?\n\nOkay, we'll see if we can get any further tomorrow.\n\nCheers,\naj"
            },
            {
                "author": "Richard Kiss",
                "date": "2015-10-03T18:02:39",
                "message_text_only": ">\n>\n> Ah, it looks like the problem is that libsec256k1 actually goes a step\n> further and runs SHA256(y||x), where \"x\" is the value I'm getting and y\n> is '\\x02' is the y value is even and '\\x03' if it's odd. If I try both,\n> one of them turns out right:\n>\n>  Secret1: d9946724c6bd8d5b58bdd2256a0251816a42f9707c794427a410075e4dbb199c\n>  Secret2: 105e0c04f0a910d72dcf2683c21903ba08cd8b225e4124afc41bb2341dc40f49\n>\n> Unfortunately openssl throws away y and just gives us x, so I'm not sure\n> if I can work out the right secret directly. I guess I can run the HMAC\n> twice and pick the value that worked?\n>\n> Okay, we'll see if we can get any further tomorrow.\n>\n> Cheers,\n> aj\n>\n\nMy open source library pycoin has a function that will give you Y from X,\nso you can use that or just pilfer enough code to reproduce it (it's not\nnative, but it's not a very complex operation).\n\nhttps://github.com/richardkiss/pycoin/blob/master/pycoin/ecdsa/ecdsa.py#L115\n\nRichard\n\n-- \nhttp://richardkiss.com/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151003/4c630e5d/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-05T14:49:00",
                "message_text_only": "On Sat, Oct 03, 2015 at 11:02:39AM -0700, Richard Kiss wrote:\n> > Ah, it looks like the problem is that libsec256k1 actually goes a step\n> > further and runs SHA256(y||x), where \"x\" is the value I'm getting and y\n> > is '\\x02' is the y value is even and '\\x03' if it's odd. If I try both,\n> > one of them turns out right:\n> >\n> > Unfortunately openssl throws away y and just gives us x, so I'm not sure\n> > if I can work out the right secret directly. I guess I can run the HMAC\n> > twice and pick the value that worked?\n> \n> My open source library pycoin has a function that will give you Y from X,\n> so you can use that or just pilfer enough code to reproduce it (it's not\n> native, but it's not a very complex operation).\n\nYep, but I'd still need to know whether to set is_even True or False,\nwhich is what I'm trying to find out.\n\nAnd if I want to be able to send onion messages not just forward them,\nthen I need to know. So to this end I've implemented ECDH directly (it's\njust a single EC_POINT_mul operation afterall). Aside from a bug where I\nwas checking eveness by comparing the last byte to 0 rather than the\nlast bit, all good.\n\nStill, it'd probably be friendlier to alternative implementations for\nECDH to only use the x value when creating secrets. I've added a comment\nto an existing secp256k1 pull request to that effect:\n\n https://github.com/bitcoin/secp256k1/pull/262#issuecomment-145473597\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-04T05:57:17",
                "message_text_only": "On Sun, Oct 04, 2015 at 02:38:56AM +1000, Anthony Towns wrote:\n> Sigh. I've had a go at reimplementing it in python, but ...\n\nBut nothing! The decoding/forwarding is successfully working in python\nwith pyelliptic. (I'm running the HMAC twice rather than actually working\nout y)\n\n$ test/test_onion 15 > TEST.OUT\n$ python test/test_onion.py < TEST.OUT\nMessage to 0\nMessage to 1\nMessage to 2\nMessage to 3\nMessage to 4\nMessage to 5\nMessage to 6\nMessage to 7\nMessage to 8\nMessage to 9\nMessage to 10\nMessage to 11\nMessage to 12\nMessage to 13\nMessage to 14\ndone\n\nI changed test_onion.c to output the generated node keypairs (private\nkey and non-compressed public key) and to dump the first message, like\nso:\n\n$ grep -v Decrypting TEST.OUT | tail -n3 | cut -c1-300\n * Keypair 13: 3f62802944de7ca5894e5759d351adac869580ec17e485f18c0c66f17cc07cbb 047d1b9ad310727493cf5fab067ec9b7476eac30eca03348ddce13f63f73ccce235dfa2807ab608a81628df72aa29d16c284379e8a48e2ddc1b98cfccf07c12a42\n * Keypair 14: 22fce466da610b63af62bc83b4692f3affaf271693ac071fb86d11342d8def4f 045319588ea4788b57452821af386aaf25842c96e680fc3a0f16076bd4bf21f1647144bc5ff1e492fcb6c12c1f893a02dc5d12ba85d96d4eaea0faaeded0f452fa\n * Message: 9c9e39281020fe4e4193ba2c1147753038c88e7ca98f4cbc1e074011fc0f85f15dd7576d9e400779eff31b27872b7762e1844447a92772a0bd495f86389a9ae0eae16f0f8dff246d57156a3a5aa36ebae2eaafd50e3bb7e08fc6b97e435b8e62f715980068f23bcf6c177d50b61507efdaf377fd1de20374ca556ec323acd7533e19031c36945e895be7935ec9d6c181\n\nEh, I made it a pull request; those are fun right?\n\nhttps://github.com/ElementsProject/lightning/pull/8\n\nSome notes:\n\n - AES128 just uses the first half of the calculated enckey, iv and\n   pad_iv\n - I couldn't get pyCrypto's AES128 to work -- I think because I wasn't\n   sure exactly how openssl turns an \"IV\" into a \"counter\". I couldn't\n   find docs on what openssl is trying to do here either, but didn't\n   bother looking at the source\n - since libsecp256k1 already sha256s the ecdh secret; the hmac/enckey/etc\n   end up being sha256'ed twice (with a byte added in between). confused\n   me for a minute.\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-05T15:02:10",
                "message_text_only": "On Sun, Oct 04, 2015 at 03:57:17PM +1000, Anthony Towns wrote:\n> On Sun, Oct 04, 2015 at 02:38:56AM +1000, Anthony Towns wrote:\n> > Sigh. I've had a go at reimplementing it in python, but ...\n> But nothing! The decoding/forwarding is successfully working in python\n> with pyelliptic. (I'm running the HMAC twice rather than actually working\n> out y)\n> $ test/test_onion 15 > TEST.OUT\n> $ python test/test_onion.py < TEST.OUT\n> Message to 0\n> Message to 1\n\nOkay, and now the python version does creation as well, though I haven't\nchecked if the C version can decode it:\n\n$ ./test/test_onion 3 | python test/test_onion.py\nMessage to 0\nMessage to 1\nMessage to 2\ndone\n\n$ python test/test_onion.py generate 3 | python test/test_onion.py\nHowzit 0...\nHowzit 1...\nHowzit 2...\ndone\n\n$ wc test/test_onion.{c,py} -l\n  684 test/test_onion.c\n  329 test/test_onion.py\n\n(though about 1/3 of the python lines are just implementing \"determine\ny given x\" and \"ecdh with y as well as x\", bleh. It also doesn't have\nthe \"export-friendly encryption\" mode implemented ;)\n\n> Eh, I made it a pull request; those are fun right?\n> https://github.com/ElementsProject/lightning/pull/8\n\n(This is updated correspondingly)\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-06T01:49:14",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> (though about 1/3 of the python lines are just implementing \"determine\n> y given x\" and \"ecdh with y as well as x\", bleh. It also doesn't have\n> the \"export-friendly encryption\" mode implemented ;)\n>\n>> Eh, I made it a pull request; those are fun right?\n>> https://github.com/ElementsProject/lightning/pull/8\n>\n> (This is updated correspondingly)\n\nThanks, merged.\n\nI reworked test_onion and Makefile test to separate generate and decode;\nwe should mix in the python version there too.\n\nSee updated onion branch.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-06T01:48:11",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Oct 02, 2015 at 03:18:39PM +0930, Rusty Russell wrote:\n> Question:\n>\n>  - I think this means lightning nodes are identified by the\n>    full 512 bit (or 257 bit?) public key used for routing -- (ie,\n>    knowing the HASH160 of the pubkey isn't enough, unlike in normal\n>    bitcoin pay2pubkey transactions).\n\nYes, since you need to encrypt to it, you need the full pubkey.\n\n>  - I think you can still use different keys for routing and\n>    anchors/commitments so far. (Using the anchor transaction to turn\n>    your routing id into a beacon would probably change that though)\n\nYes, that's still TBD.\n\n>From the other email:\n\n>   - AES128 just uses the first half of the calculated enckey, iv and\n>     pad_iv\n\nTrue.\n\n>  - since libsecp256k1 already sha256s the ecdh secret; the hmac/enckey/etc\n>    end up being sha256'ed twice (with a byte added in between). confused\n>    me for a minute.\n\nI didn't notice that.  Perhaps this is somewhere we should optimize?\n\nCheers,\nRusty.\nPS.  Message size of 128 bytes is completely made up, as is 20 hops.  We\n     might want to reduce to 96 or 64 bytes."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-06T05:22:36",
                "message_text_only": "On Tue, Oct 06, 2015 at 12:19:14PM +1030, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> >> https://github.com/ElementsProject/lightning/pull/8\n> > (This is updated correspondingly)\n> Thanks, merged.\n\nNifty.\n\n> I reworked test_onion and Makefile test to separate generate and\n> decode;\n> we should mix in the python version there too.\n\nIn onion_key.c, I don't see why you're using flip_key() -- that's only \nneeded for the single use onion-msg-keys, aiui?\n\nOn Tue, Oct 06, 2015 at 12:18:11PM +1030, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> >   - AES128 just uses the first half of the calculated enckey, iv and\n> >     pad_iv\n> True.\n\n> >  - since libsecp256k1 already sha256s the ecdh secret; the hmac/enckey/etc\n> >    end up being sha256'ed twice (with a byte added in between). confused\n> >    me for a minute.\n> I didn't notice that.  Perhaps this is somewhere we should optimize?\n\nYou could save a sha call by using both halves of a sha for iv and pad_iv,\nrather than two separate sha's. Otherwise don't see anything obvious to\ndo? I assume the ECDH step dominates as far as performance goes anyway?\n\n> PS.  Message size of 128 bytes is completely made up, as is 20 hops.  We\n>      might want to reduce to 96 or 64 bytes.\n\nI figured 20=floor(4096/192) which made sense to me. AFAICS the message\n*needs* to include fee info and the forwarding address; so that's 4B and\n20B-32B respectively (you could use the hash160 here and assume the\nforwarding node can figure it out).\n\nBut maybe some nodes want to do clever things, like allow you to tell it\nto deliberately delay forwarding for an hour or two, or deduct (different)\nfees from multiple HTLC's simultaneously. But I guess 64B is probably\nplenty for that?\n\nOther thing is if you want to redirect an onion routed payment (which we\ntalked about as a possibility originally, as compared to only allowing\nsource-based routing). ie, a HTLC is sent from A to B->C->D->E, but\nC actually needs to send it to D via X->Y->Z->D rather than doing it\ndirectly. AFAICS, in that case you need to add and drop hops, ie:\n\n   A->B:  - - - - - - - E D C B\n   B->C:  b - - - - - - - E D C\n   C->X:  c b - - - - - - - E D Z Y X\n   X->Y:  x c b - - - - - - - E D Z Y\n   Y->Z:  y x c b - - - - - - - E D Z\n   Z->D:  c b - - - - - - - E D\n   D->E:  d c b - - - - - - - E\n\nie, Z needs to be able to be told \"don't add padding, in fact, drop two\nblocks worth of padding before forwarding\". That presumably just needs a\nbyte or two of data; but it completely messes up the constant-size\npackets. :-/\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-06T14:01:34",
                "message_text_only": "> On Tue, Oct 06, 2015 at 12:19:14PM +1030, Rusty Russell wrote:\n> > I reworked test_onion and Makefile test to separate generate and\n> > decode;\n> > we should mix in the python version there too.\n\nOkay, branch updated:\n\nhttps://github.com/ElementsProject/lightning/pull/9\n\nOn Tue, Oct 06, 2015 at 03:22:36PM +1000, Anthony Towns wrote:\n> In onion_key.c, I don't see why you're using flip_key() -- that's only \n> needed for the single use onion-msg-keys, aiui?\n\nSo I disabled that, and made the 02/03 prefix explicit. Maybe saving\na bit/byte somewhere will be worth it; but it seems way premature and\njust gave me the heebie-jeebies. :)\n\nI also changed the \"Message for blah...\" to serialize the pubkey before\nturning it into hex -- aiui you were dumping the internal representation\nof the point, which would be hard to duplicate compatibly.\n\nI tweaked onion_key to avoid the for loop and cut calls. pyelliptic\ndoesn't like to generate a pubkey given a privkey, so I'm just passing\nboth to it directly.\n\nRunning decoding through python is slooooow -- unfortunately most of\nthe time is in loading the interpretor and crypto modules, so only way\nto improve it would be to run the decodes in a single python process,\nwhich I'm not sure is actually desirable?\n\nAnyway, fwiw.\n\nWas there any conclusion on the wiki/rfc/whatever ideas about documenting\nlightning protocol/technology decisions? That'd be good to try, no?\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-06T22:35:01",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n>> On Tue, Oct 06, 2015 at 12:19:14PM +1030, Rusty Russell wrote:\n>> > I reworked test_onion and Makefile test to separate generate and\n>> > decode;\n>> > we should mix in the python version there too.\n>\n> Okay, branch updated:\n>\n> https://github.com/ElementsProject/lightning/pull/9\n>\n> On Tue, Oct 06, 2015 at 03:22:36PM +1000, Anthony Towns wrote:\n>> In onion_key.c, I don't see why you're using flip_key() -- that's only \n>> needed for the single use onion-msg-keys, aiui?\n>\n> So I disabled that, and made the 02/03 prefix explicit. Maybe saving\n> a bit/byte somewhere will be worth it; but it seems way premature and\n> just gave me the heebie-jeebies. :)\n\nYeah, it made more sense when it was common code.  The 32 bytes fits\nneatly into the onion in a way 33 bytes really doesn't (esp. for AES).\n\nBut this only applies for the temporary keys used for the onion, not\nso much the node keys.  Will apply your patches then cleanup.\n\n> I also changed the \"Message for blah...\" to serialize the pubkey before\n> turning it into hex -- aiui you were dumping the internal representation\n> of the point, which would be hard to duplicate compatibly.\n\nOops, yeah.\n\n> I tweaked onion_key to avoid the for loop and cut calls. pyelliptic\n> doesn't like to generate a pubkey given a privkey, so I'm just passing\n> both to it directly.\n\nSure.\n\n> Running decoding through python is slooooow -- unfortunately most of\n> the time is in loading the interpretor and crypto modules, so only way\n> to improve it would be to run the decodes in a single python process,\n> which I'm not sure is actually desirable?\n>\n> Anyway, fwiw.\n>\n> Was there any conclusion on the wiki/rfc/whatever ideas about documenting\n> lightning protocol/technology decisions? That'd be good to try, no?\n\nHmm, let me try to write an RFC...\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Onion routing strawman proposal",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Richard Kiss"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 17560
        }
    },
    {
        "title": "[Lightning-dev] Negotiating & Committing Signatures",
        "thread_messages": [
            {
                "author": "Derek Atkins",
                "date": "2015-10-09T17:55:13",
                "message_text_only": "Hi Rusty,\n\nI was considering creating a prototype of using AEDSA here, just to see\nhow well it might fit in and see if I can gauge the performance.  Do you\nthink that would be a reasonable project?  I was hoping to possibly get\nthis done and make measurements in time to present at the next Scaling\nBitcoin workshop.\n\nIf you agree this is a reasonable experiment, is it something I would\nonly need to change within lightning or would I also need to update\nbitcoind/alphad?\n\nThanks,\n\n-derek\n\nOn Mon, 2015-08-31 at 12:24 +0930, Rusty Russell wrote:\n> Jeremy Rubin <jr at mit.edu> writes:\n> > Negotiating & Committing Signatures\n> > ============================\n> >\n> > In this proposal, I suggest the addition of new types of signature schemes\n> > to Bitcoin, and running lightning over multi signature of the\n> > variants to utilize the advantages of multiple signature schemes without\n> > the drawbacks.\n> \n> Hi Jeremy,\n> \n>         Such a hybrid would certainly be possible (though getting novel\n> crypto into bitcoin is a large task).\n> \n> You refer to an \"order or magnitude\" increase in pubkey and signature\n> sizes, but signatures of even 64k wouldn't make much logistical\n> difference to the LN.  Giant pubkeys might be a logistical issue, though\n> using the bitcoin trick of referring to them via their RIPEMD160 should\n> work there, too.\n> \n> Cheers,\n> Rusty.\n\n-- \nDerek Atkins\nChief Technology Officer\nSecureRF Corporation\n\nOffice: 203.227.3151  x1343\nDirect: 617.623.3745\nMobile: 617.290.5355\nEmail: DAtkins at SecureRF.com\n\nThis email message may contain confidential, proprietary and / or\nlegally privileged information and intended only for the use of the\nintended recipient(s) and others specifically authorized. Any\ndisclosure, dissemination, copying, distribution or use of the\ninformation contained in this email message, including any attachments,\nto or by anyone other than the intended recipient is strictly\nprohibited.  If you received this in error, please immediately advise\nthe sender by reply email or at the telephone number above, and then\ndelete, shred, or otherwise dispose of this message."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-11T19:43:24",
                "message_text_only": "Derek Atkins <datkins at securerf.com> writes:\n> Hi Rusty,\n>\n> I was considering creating a prototype of using AEDSA here, just to see\n> how well it might fit in and see if I can gauge the performance.  Do you\n> think that would be a reasonable project?  I was hoping to possibly get\n> this done and make measurements in time to present at the next Scaling\n> Bitcoin workshop.\n>\n> If you agree this is a reasonable experiment, is it something I would\n> only need to change within lightning or would I also need to update\n> bitcoind/alphad?\n\nHi Derek,\n\n        Bitcoin is most interesting, as a prerequisite.  Lightning is a\nbox of pieces at this point, and thus uninteresting.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Negotiating & Committing Signatures",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Derek Atkins"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2811
        }
    },
    {
        "title": "[Lightning-dev] Minor protocol revisions.",
        "thread_messages": [
            {
                "author": "Pierre",
                "date": "2015-10-13T11:45:39",
                "message_text_only": ">> Argh, I already have trouble understanding the rationale behind all\n>> the existing closing flows and states :-s Would it be possible to\n>> publish an updated version of the svg ? aj, any chance you could do\n>> the same with your 'flat' version ?\n>\n> Yeah. I've updated state.py so the following flow works:\n\nThanks!\n\nI guess what I'm missing about all those closing states is the reason\nwhy we need to handle combinations of the 3 basic cases (current\ncommit, revoked commit or mutual close).\n\nThis cannot happen since they all spend the same anchor right ? Why do\nwe care if they are broadcasted and not confirmed ?\n\nCheers,\n\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-13T19:52:50",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n>>> Argh, I already have trouble understanding the rationale behind all\n>>> the existing closing flows and states :-s Would it be possible to\n>>> publish an updated version of the svg ? aj, any chance you could do\n>>> the same with your 'flat' version ?\n>>\n>> Yeah. I've updated state.py so the following flow works:\n>\n> Thanks!\n>\n> I guess what I'm missing about all those closing states is the reason\n> why we need to handle combinations of the 3 basic cases (current\n> commit, revoked commit or mutual close).\n>\n> This cannot happen since they all spend the same anchor right ? Why do\n> we care if they are broadcasted and not confirmed ?\n\nWe need to keep watching until (any one of them) is buried deep enough\nthat we don't care (say 100 deep).  Otherwise a revoked transaction +\nchain reorganization could cheat us of funds.\n\nThese details are what makes a robust implementation so difficult :(\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Minor protocol revisions.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Pierre"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1590
        }
    },
    {
        "title": "[Lightning-dev] Preventing MITM - Providing new nodes with real pubkeys",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-16T13:22:25",
                "message_text_only": "So being done with encryption and authentication, the next layer for\nme now is to figure out how exactly nodes will broadcast their\nexistence and open channels and everything.\n\nThe one problem that we have currently with the way encryption and\nauthentication works, is that the encryption layer is not protecting\nagainst MITM attacks, such that an attacker could have a connection\nwith both and establish different encryption with both and just reads\nand relays all the data.\n\nThis gets defeated with the agreed-on authentication layer, where both\nnodes sign a message with their real pubkey and the temp pubkey of the\nparty they are talking to, where a MITM could not produce these\nsignatures. However, this only holds true if the nodes actually know\nthe pubkey of the node they want to talk to. Which raises the point of\n- how do we bring this information across securely? A new node joining\nthe network and obtaining one/some IP of another network participant\nwill want to get a list with nodes/pubkeys/IPs. Without a central\nauthority that could provide trust into the data, an attacker could\ntrick it into a fake network, even if just for vandalism. (Having peer\ndiscovery trust on some hardcoded nodes to obtain IP addresses is\ndangerous enough, we don't want to rely on that for pubkeys as well)\n\n\nThere are some possibilities how to mitigate the risk / make an attack expensive\n\n(1)\nHave a snapshot of the data hashed and linked to the blockchain.\nSimilar to the way 'Factom' works. It would provide the data with some\nintegrity framework, but keeping track of the changes would require\nsome overhead. Without a central service it would further be difficult\nto establish who should make these linking transactions to the\nblockchain...\n\n(2)\nAs long as the malleability issue has not been fixed, the blockchain\ncan only used with additional techniques to obtain a map of the\nchannels from it. As the anchor transactions are P2SH, we need to\nexpose the script, such that others are able to verify we at least\nhave an anchor tx on the blockchain (associated with costs after all).\nFor the current form it would be enough to have\nSecretAHash || KeyB' || KeyB || KeyA || TxID || SignatureB (L=231B)\nwith KeyB being the node pubkey (lots of key reusage...)\nor\nSecretAHash || KeyB' || KeyB || KeyA || TxID || nodePubKey ||\nSignatureB (L=264B) with KeyB as a channel key that does not need to\nbe equal with the nodePubKey.\n\nThis is information everyone should store in case a new node joins a\nnetwork, similar to the blockchain. New nodes can then check against\nthe blockchain, whether this data is actually present there. An\nattacker can fake a complete network together with lots of\ntransactions on the blockchain, but the incentive is low (vandalism)\nand the costs are high. For 100k nodes and 10 open channels per node,\nthis adds up to 220MB. Not too bad, considering full nodes are highly\nincentivised to run full bitcoin nodes as well, it is actually rather\nnegligible. This information is pretty static, however we want\neveryone to have a decently consistent view of the network, so we\nwould probably do some rebroadcast of that every few days, just to\nensure everyone knows about it.\n\n(3)\nSimilar to (2), but instead of broadcasting our script we add a\nOP_RETURN output to each anchor transaction. It is cheap to implement\nit, as we don't have to broadcast anything specific to this issue. It\nis more expensive to attack, but also more expensive to open up a new\nchannel. And it doesn't help scaling either, so I tend to dislike this\nidea.\n\n(4)\nStart with one node and just go through a lot of different IP\naddresses you get from that node and repeat over and over and compare\nwhat the different nodes are telling you about the system. We can\nalways add this technique on top of the other 3, and add IP addresses\nas an additional cost vector for a successful attack. If most of the\nIP addresses the first node gave you are dead, you can assume he gave\nyou wrong information about the network and start again with another\nnode.\n\n\nAs I'm implementing broadcast messages anyways for other purposes (see\nother ML post), I tent to like (2) the most, it is the most expensive\nto attack as well I think.\n\nMats Jerratsch"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-16T20:50:30",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> So being done with encryption and authentication, the next layer for\n> me now is to figure out how exactly nodes will broadcast their\n> existence and open channels and everything.\n\nHi Mats,\n\n        Thanks for bringing this on-list!\n\n> (2)\n> As long as the malleability issue has not been fixed, the blockchain\n> can only used with additional techniques to obtain a map of the\n> channels from it. As the anchor transactions are P2SH, we need to\n> expose the script, such that others are able to verify we at least\n> have an anchor tx on the blockchain (associated with costs after all).\n\nThis makes some sense (though the anchor transactions don't need to be\nP2SH, it's nicer for bitcoin's UTXO if they are).\n\n> For the current form it would be enough to have\n> SecretAHash || KeyB' || KeyB || KeyA || TxID || SignatureB (L=231B)\n> with KeyB being the node pubkey (lots of key reusage...)\n> or\n> SecretAHash || KeyB' || KeyB || KeyA || TxID || nodePubKey ||\n> SignatureB (L=264B) with KeyB as a channel key that does not need to\n> be equal with the nodePubKey.\n\nYes, I think avoiding key reuse is good.  So, to be clear, the anchor TX\noutput looks like:\n\n        P2SH (2 KEYA KEYB 2 OP_CHECKMULTISIG)\n\nTo prove we control KEYA, we simply need to sign something with it (our\nnodePubKey):\n\n        KEYA NODE-PUBKEY TXID SIGNATURE\n\nI think we can do slightly better with Schnorr signatures (which you can\nsimply do multisig by addition, if I understand correctly) where both\nparties cooperate to form:\n\n        KEYA KEYB NODE-PUBKEYA NODE-PUBKEYB TXID DUAL-SIGNATURE\n\nThat's 33+33+33+33+32+64 = 228 bytes per channel.\n\nLater on, we can send SPV proofs for TXID.\n\n> This is information everyone should store in case a new node joins a\n> network, similar to the blockchain. New nodes can then check against\n> the blockchain, whether this data is actually present there. An\n> attacker can fake a complete network together with lots of\n> transactions on the blockchain, but the incentive is low (vandalism)\n> and the costs are high. For 100k nodes and 10 open channels per node,\n> this adds up to 220MB. Not too bad, considering full nodes are highly\n> incentivised to run full bitcoin nodes as well, it is actually rather\n> negligible. This information is pretty static, however we want\n> everyone to have a decently consistent view of the network, so we\n> would probably do some rebroadcast of that every few days, just to\n> ensure everyone knows about it.\n\nAlso, once a node is live, I'm not sure how much of the map it will need\nto keep.  It might be able to prune distant parts of the map randomly,\nand get it back from the rest of the network if needed?  Requires more\nthought, though.\n\n> As I'm implementing broadcast messages anyways for other purposes (see\n> other ML post), I tent to like (2) the most, it is the most expensive\n> to attack as well I think.\n\nI agree.  Least on-chain spam.\n\nThanks!\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-16T23:47:47",
                "message_text_only": "On Sat, Oct 17, 2015 at 07:20:30AM +1030, Rusty Russell wrote:\n>         KEYA KEYB NODE-PUBKEYA NODE-PUBKEYB TXID DUAL-SIGNATURE\n\nAFAICS, to have a lightning channel between NODE-A and NODE-B, you just\nhave to have a way for those two people to be comfortable writing IOUs\nto each other. HTLCs and commitments spending anchor transactions on\nthe blockchain is one way to do this, but you could also do it on a\npegged sidechain, or, if the two parties trusted each other, you could\ndo it with literal IOUs written on bits of paper. I'm not sure we want\nto block people from doing those things?\n\nAlso, if you're only doing dual-signature, not quad-signature, I think\nit's open to creating fake edges in the routing graph: ie, I make up to\nkeys AJ1 and AJ2, and publish a multisig transaction in the blockchain,\nthen claim there's a route between RUSTY and MATS by publishing\n\n    AJ1 AJ2 RUSTY MATS TX <SIG:AJ1 AJ2>\n\nThen when Alice wants to route to Bob, she decides to use that edge, and\nher transaction fails because it doesn't exist.\n\n(If you just sign with RUSTY and MATS, obviously you can claim to have\na route just by referencing any multisig transaction that you know the\npubkeys of)\n\n> > For 100k nodes and 10 open channels per node,\n> > this adds up to 220MB. [...]\n> Also, once a node is live, I'm not sure how much of the map it will need\n> to keep.  It might be able to prune distant parts of the map randomly,\n> and get it back from the rest of the network if needed?  Requires more\n> thought, though.\n\nWell, we could not worry about it until there are >10k nodes; and then\nwe'd have actual data as well?\n\nCheers,\naj"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-18T11:21:13",
                "message_text_only": "> This makes some sense (though the anchor transactions don't need to be\n> P2SH, it's nicer for bitcoin's UTXO if they are).\n\nWell, currently there is no one working on a malleability fix, so we\nshould probably work forwards the next available goal. ;)\n\n>> For the current form it would be enough to have\n>> SecretAHash || KeyB' || KeyB || KeyA || TxID || SignatureB (L=231B)\n>> with KeyB being the node pubkey (lots of key reusage...)\n>> or\n>> SecretAHash || KeyB' || KeyB || KeyA || TxID || nodePubKey ||\n>> SignatureB (L=264B) with KeyB as a channel key that does not need to\n>> be equal with the nodePubKey.\n>\n> Yes, I think avoiding key reuse is good.  So, to be clear, the anchor TX\n> output looks like:\n>\n>         P2SH (2 KEYA KEYB 2 OP_CHECKMULTISIG)\n\nHaving to deal with malleability, the only viable solution for anchor\ntransactions are with escape and fast-escape?\n\n> I think we can do slightly better with Schnorr signatures (which you can\n> simply do multisig by addition, if I understand correctly) where both\n> parties cooperate to form:\n>\n>         KEYA KEYB NODE-PUBKEYA NODE-PUBKEYB TXID DUAL-SIGNATURE\n>\n> That's 33+33+33+33+32+64 = 228 bytes per channel.\n\nInteresting, I kinda feel uncomfortable with Schnorr though. It feels\nlike some experimental method, and at least for Java, there are very\nfew implementations around (and I don't feel comfortable implementing\nit on my own either..)\n\nI like the idea of adding together one object for the channel to be\nsent by both nodes. Even without Schnorr it saves some bytes and the\noverhead of gossipping.. We can always switch the signature to Schnorr\ntoo..\n\n> Also, once a node is live, I'm not sure how much of the map it will need\n> to keep.  It might be able to prune distant parts of the map randomly,\n> and get it back from the rest of the network if needed?  Requires more\n> thought, though.\n>\n>> As I'm implementing broadcast messages anyways for other purposes (see\n>> other ML post), I tent to like (2) the most, it is the most expensive\n>> to attack as well I think.\n>\n> I agree.  Least on-chain spam.\n\nWell, all nodes can always refuse to participate in the gossip network\nanyway by just never requesting data and never relaying anything\neither. For a lot of things, it is very similar to the whole\nblockchain. Important to keep at some points, most of it is throw-away\nfor individual nodes already participating in the network though.. But\nI don't see this a problem anywhere soon..\n\nCheers,\nMats"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-20T01:42:26",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n>> This makes some sense (though the anchor transactions don't need to be\n>> P2SH, it's nicer for bitcoin's UTXO if they are).\n>\n> Well, currently there is no one working on a malleability fix, so we\n> should probably work forwards the next available goal. ;)\n\nOh, I'm pushing BIP 62, as well, in parallel with everything else :)\n\n>>> For the current form it would be enough to have\n>>> SecretAHash || KeyB' || KeyB || KeyA || TxID || SignatureB (L=231B)\n>>> with KeyB being the node pubkey (lots of key reusage...)\n>>> or\n>>> SecretAHash || KeyB' || KeyB || KeyA || TxID || nodePubKey ||\n>>> SignatureB (L=264B) with KeyB as a channel key that does not need to\n>>> be equal with the nodePubKey.\n>>\n>> Yes, I think avoiding key reuse is good.  So, to be clear, the anchor TX\n>> output looks like:\n>>\n>>         P2SH (2 KEYA KEYB 2 OP_CHECKMULTISIG)\n>\n> Having to deal with malleability, the only viable solution for anchor\n> transactions are with escape and fast-escape?\n>\n>> I think we can do slightly better with Schnorr signatures (which you can\n>> simply do multisig by addition, if I understand correctly) where both\n>> parties cooperate to form:\n>>\n>>         KEYA KEYB NODE-PUBKEYA NODE-PUBKEYB TXID DUAL-SIGNATURE\n>>\n>> That's 33+33+33+33+32+64 = 228 bytes per channel.\n>\n> Interesting, I kinda feel uncomfortable with Schnorr though. It feels\n> like some experimental method, and at least for Java, there are very\n> few implementations around (and I don't feel comfortable implementing\n> it on my own either..)\n>\n> I like the idea of adding together one object for the channel to be\n> sent by both nodes. Even without Schnorr it saves some bytes and the\n> overhead of gossipping.. We can always switch the signature to Schnorr\n> too..\n\nYes, we've not as bound to consensus, which is nice.  Schnorr is\nsomething we can decide on later, for sure.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-16T23:01:42",
                "message_text_only": "On Fri, Oct 16, 2015 at 02:22:25PM +0100, Mats Jerratsch wrote:\n> [...] an attacker could trick it into a fake network, [...]\n\nHow do you tell the difference between the \"real\" network and a \"fake\"\none? (ie, what does a Turing test for the lightning network look like?)\n\nI think there's two things:\n\n 1) you can figure out a route to people you want to pay (and\n    vice-versa)\n\n 2) payments on those routes actually go through\n\nEven better, you can test this! Get a couple of merchant ids you find\ninteresting, and pay 1 satoshi to each of them, setting the R value as\nthe (double) SHA256 of the decrypted onion message. [0]\n\nIf you spent 1 satoshi to each of 10 merchants every day for a year to\nverify connectivity, that'd still only amount to about $0.01 USD total\nat current exchange rates, so it seems pretty affordable. [1]\n\nIt only works if you actually setup a channel, though -- so you have to\nlock some money into the channel for however many confirmations until\nthe channel activates, before you can test, plus the OP_CSV delay if\nthe test fails.\n\nBut I think that would let people trustlessly avoid \"fake\" lightning\nnetworks, even with a sybil-esque attack; no extra infrastructure needed.\n\nCheers,\naj\n\n[0] If you're already on the lightning network, and you're establishing\n    a new channel as backup, you can just pay yourself 1 satoshi to verify\n    connectivity. If you have friends on lightning, you could pay them\n    1 satoshi to verify connectivity rather than a random merchant too.\n\n[1] Hmm, does forwarding 1 satoshi (2.6 10,000ths of a cent) make\n    sense, or would the CPU cycles cost more than the fees you'd make?\n    How much does it cost to forward a transaction? In python on my\n    laptop, I get about 1000 ECDH operations per second in python, and\n    290k AES ops over a 3kB onion per second, and about 77k SHA256 ops\n    per second. So just counting elliptic ops, forwarding a transaction\n    requires three ops: an ECDH on the onion message, and an ECDSA on\n    the commitment transaction to add the HTLC, and another sometime\n    later to remove it.  So say 1/350th of a CPU-second. My linode costs\n    3c/hour and seems to be about half as fast on the SHA256 test, but\n    gives me two CPUs which evens it out. So so 3/60/60/350 cents is\n    about the cost of forwarding a single transaction, which is about\n    2.4e-8 dollars, which is currently about 9.1e-11 bitcoin, which\n    is 0.0091 satoshi. Conveniently lightning balances are denominated\n    in millisatoshi, so as long as yours increases by 9 or 10, you're\n    doing fine. 10 millisatoshi is 1% of 1 satoshi, so that seems like\n    the right order of magnitude."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-18T11:25:29",
                "message_text_only": "> It only works if you actually setup a channel, though -- so you have to\n> lock some money into the channel for however many confirmations until\n> the channel activates, before you can test, plus the OP_CSV delay if\n> the test fails.\n\nAnd there's the catch. If an attacker achieves nodes opening up\nchannels with him, he already succeeded in vandalism. Furthermore, an\nattacker can always play by the rules and forward all payments up to\none point where he stops. And even worse, if everyone connect to his\nnodes, he can relay all payments, but he is able to distinctively\nidentify payee and payers, even with onion routing.\n\n> [1] Hmm, does forwarding 1 satoshi (2.6 10,000ths of a cent) make\n>     sense, or would the CPU cycles cost more than the fees you'd make?\n>     How much does it cost to forward a transaction? In python on my\n>     laptop, I get about 1000 ECDH operations per second in python, and\n>     290k AES ops over a 3kB onion per second, and about 77k SHA256 ops\n>     per second. So just counting elliptic ops, forwarding a transaction\n>     requires three ops: an ECDH on the onion message, and an ECDSA on\n>     the commitment transaction to add the HTLC, and another sometime\n>     later to remove it.  So say 1/350th of a CPU-second. My linode costs\n>     3c/hour and seems to be about half as fast on the SHA256 test, but\n>     gives me two CPUs which evens it out. So so 3/60/60/350 cents is\n>     about the cost of forwarding a single transaction, which is about\n>     2.4e-8 dollars, which is currently about 9.1e-11 bitcoin, which\n>     is 0.0091 satoshi. Conveniently lightning balances are denominated\n>     in millisatoshi, so as long as yours increases by 9 or 10, you're\n>     doing fine. 10 millisatoshi is 1% of 1 satoshi, so that seems like\n>     the right order of magnitude.\n\nInteresting math, thank you for that!"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-19T01:41:00",
                "message_text_only": "On Sun, Oct 18, 2015 at 01:25:29PM +0200, Mats Jerratsch wrote:\n> > It only works if you actually setup a channel, though -- so you have to\n> > lock some money into the channel for however many confirmations until\n> > the channel activates, before you can test, plus the OP_CSV delay if\n> > the test fails.\n> And there's the catch. If an attacker achieves nodes opening up\n> channels with him, he already succeeded in vandalism.\n\nI'm not sure this is true? Supposing there are V vandals on the system,\ncompared to T total nodes, so V/T is your probability of selecting a\nvandal. Then, to join the lightning network, you open up N channels\nwith randomly chosen nodes at $1 each, committing $N in total, and\n(if they're all run by vandals and have to get closed) spending about\n2*N*2c (so 4%?) in fees. If there are 1000 nodes (ie, lots), then the\nprobability of finding at least one good node is about 1-(V/T)^N.  If you\nwant a probability of 99% of getting a good node on your first try, then:\n\n  V/T = 10%: N = 2\n  V/T = 20%: N = 3\n  V/T = 30%: N = 4\n  V/T = 40%: N = 6\n  V/T = 50%: N = 7\n  V/T = 60%: N = 9\n  V/T = 70%: N = 13\n  V/T = 80%: N = 21\n  V/T = 90%: N = 43\n  V/T = 95%: N = 86\n  V/T = 99%: N = 368\n\nSo with 90% of nodes being hostile, that'd be getting expensive, but\nnot completely implausible. If 40%-plus of the network is legit, though,\njust trying out 10 random nodes seems like it works fine, and only locks\nup $10 for a couple of days and costs about 40c in bitcoin fees...\n\nAlso, if you've got to run 2.5 times as many vandal nodes as there are\nlegitimate nodes for people to even really be bothered, I don't think\nyou'll see many vandals in the first place...\n\n(Once you've got a node that actually works, you can expand your channel\nfrom $1 to $10 or $100, and/or open additional channels, and at that point\n(afaics) you're set.)\n\nThat's only necessary if you don't know anyone with a lightning account\nalready, though. Since anyone can forward for you, you could start with\nsomeone you trust in real life -- eg, a friend, a bank, a government,\netc. If Rusty tells me he'll route my payments (as long as they're made\nbetween 10am and 3pm Adelaide time on a weekday, maybe) then I can open\na $5 channel with him, and use that to send 1 satoshi payments to test\nconnectivity. So, if I'm wondering whether BOBSBANK is reliable, I work\nout a route:\n\n  aj -> rusty -> a -> b -> c -> BOBSBANK -> x -> y -> z -> rusty -> aj\n\napply it as an onion so it can't get short-circuited, and see if it gets\nback to me, at a cost of maybe 10% of a satoshi (10 hops at 1% each)...\nIf it does, BOBSBANK is connected and functional, and I can try opening a\nchannel. If it doesn't, I can try a different route to BOBSBANK, or try\nsomeone else entirely.\n\n> Furthermore, an\n> attacker can always play by the rules and forward all payments up to\n> one point where he stops.\n\n(For example, he could happily route payments on $1 channels, but refuse\nto do likewise when the channel capacity was upped to $10)\n\nIn the general case though, does that even count as an attack? Isn't\nthat just like a web site going down or being put behind a paywall? ie,\nannoying, but completely legitimate? I mean, if someone downloads the\nlightning software to try it out, runs it for a while, then decides it's\nno fun and stops, they'll be \"playing by the rules up to one point where\nthey stop\"; but they're not trying to \"attack\" the system.\n\nCoping with unreliability is definitely important, but running a node that\nworks sometimes but is deliberately unreliable is a lot more effort than\nrunning a node that claims to work, but never does. It's also more work\n(and less profitable) than just running a node that actually work...\n\n> And even worse, if everyone connect to his\n> nodes, he can relay all payments, but he is able to distinctively\n> identify payee and payers, even with onion routing.\n\nThat's a different attack isn't it? To get everyone to connect to your\nnodes, you'd have to be running the majority of nodes -- ie, there's\n5000 different organisations running lightning nodes, but 4999 of them\nrun one or two nodes each, but one of them runs 100,000 nodes.\n\nBut if it were cheap enough for one org to run 100k nodes, why wouldn't\nthe others treat it as an arms race and end up running, say, 20-50\nnodes each?  They'd have an economic incentive to do so, in that it\nincreases their odds of collecting fees... At that point the attacker's\nalready reduced to 28%-50% of nodes.  ie, I think that's likely to be\nself-correcting?\n\nBut! An arms race in nodes-per-person would probably cause a scaling\nproblem for the network (depending on how routing actually works), and\nyou'd have to address that by creating some cost to run (or at least\nregister?) a node/channel. But if they're all legitimate nodes, I think\nthat's just a scaling problem, rather than vandalism per se.\n\n(An additional but: even if spamming the list of nodes doesn't work as\nan effective attack, if you can spam the list of *channels* with valid\nlooking edges that won't actually route payments successfully, you can\nscrew over the network pretty well)\n\nCheers,\naj"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-19T07:45:34",
                "message_text_only": "All of your assumptions have the premise though, that choosing a\n'good' vs a 'bad' guy is pure probability, like picking the right ball\nout of a bag. There are other systematic attacks though, where an\nattacker can trick you into his network for practically zero costs,\nespecially if there is no other solution in place (like checking the\nblockchain for all of the networks anchors).\n\nThink about an attacker who is able to MITM your internet connection,\nlike the hotspot you connect to at a Cafe (or your ISP if hijacked).\nThey can build locally a gigantic network, all pointing to the same\nnode. You can't tell, and they don't have to necessarily just block\nyour payments. (see above)\n\nI am mainly concerned over those. Especially since there is not really\nanything we can do about dishonest nodes joining our network, but it's\nencouraging to see your math. Since everything security-wise so far\nstands only with knowing pubkeys of nodes actually connected to the\nnetwork, this should be the first thing to tackle. (that is, making it\nexpensive to attack it this way)\n\nOnly nuisance is that it requires either SPV or full node to check the\nanchor, but I kinda like the idea of having all (or a good amount) of\nlightning nodes be full bitcoin nodes as well.\n\ncheers\nMats Jerratsch\n\n\n\n2015-10-19 3:41 GMT+02:00 Anthony Towns <aj at erisian.com.au>:\n> On Sun, Oct 18, 2015 at 01:25:29PM +0200, Mats Jerratsch wrote:\n>> > It only works if you actually setup a channel, though -- so you have to\n>> > lock some money into the channel for however many confirmations until\n>> > the channel activates, before you can test, plus the OP_CSV delay if\n>> > the test fails.\n>> And there's the catch. If an attacker achieves nodes opening up\n>> channels with him, he already succeeded in vandalism.\n>\n> I'm not sure this is true? Supposing there are V vandals on the system,\n> compared to T total nodes, so V/T is your probability of selecting a\n> vandal. Then, to join the lightning network, you open up N channels\n> with randomly chosen nodes at $1 each, committing $N in total, and\n> (if they're all run by vandals and have to get closed) spending about\n> 2*N*2c (so 4%?) in fees. If there are 1000 nodes (ie, lots), then the\n> probability of finding at least one good node is about 1-(V/T)^N.  If you\n> want a probability of 99% of getting a good node on your first try, then:\n>\n>   V/T = 10%: N = 2\n>   V/T = 20%: N = 3\n>   V/T = 30%: N = 4\n>   V/T = 40%: N = 6\n>   V/T = 50%: N = 7\n>   V/T = 60%: N = 9\n>   V/T = 70%: N = 13\n>   V/T = 80%: N = 21\n>   V/T = 90%: N = 43\n>   V/T = 95%: N = 86\n>   V/T = 99%: N = 368\n>\n> So with 90% of nodes being hostile, that'd be getting expensive, but\n> not completely implausible. If 40%-plus of the network is legit, though,\n> just trying out 10 random nodes seems like it works fine, and only locks\n> up $10 for a couple of days and costs about 40c in bitcoin fees...\n>\n> Also, if you've got to run 2.5 times as many vandal nodes as there are\n> legitimate nodes for people to even really be bothered, I don't think\n> you'll see many vandals in the first place...\n>\n> (Once you've got a node that actually works, you can expand your channel\n> from $1 to $10 or $100, and/or open additional channels, and at that point\n> (afaics) you're set.)\n>\n> That's only necessary if you don't know anyone with a lightning account\n> already, though. Since anyone can forward for you, you could start with\n> someone you trust in real life -- eg, a friend, a bank, a government,\n> etc. If Rusty tells me he'll route my payments (as long as they're made\n> between 10am and 3pm Adelaide time on a weekday, maybe) then I can open\n> a $5 channel with him, and use that to send 1 satoshi payments to test\n> connectivity. So, if I'm wondering whether BOBSBANK is reliable, I work\n> out a route:\n>\n>   aj -> rusty -> a -> b -> c -> BOBSBANK -> x -> y -> z -> rusty -> aj\n>\n> apply it as an onion so it can't get short-circuited, and see if it gets\n> back to me, at a cost of maybe 10% of a satoshi (10 hops at 1% each)...\n> If it does, BOBSBANK is connected and functional, and I can try opening a\n> channel. If it doesn't, I can try a different route to BOBSBANK, or try\n> someone else entirely.\n>\n>> Furthermore, an\n>> attacker can always play by the rules and forward all payments up to\n>> one point where he stops.\n>\n> (For example, he could happily route payments on $1 channels, but refuse\n> to do likewise when the channel capacity was upped to $10)\n>\n> In the general case though, does that even count as an attack? Isn't\n> that just like a web site going down or being put behind a paywall? ie,\n> annoying, but completely legitimate? I mean, if someone downloads the\n> lightning software to try it out, runs it for a while, then decides it's\n> no fun and stops, they'll be \"playing by the rules up to one point where\n> they stop\"; but they're not trying to \"attack\" the system.\n>\n> Coping with unreliability is definitely important, but running a node that\n> works sometimes but is deliberately unreliable is a lot more effort than\n> running a node that claims to work, but never does. It's also more work\n> (and less profitable) than just running a node that actually work...\n>\n>> And even worse, if everyone connect to his\n>> nodes, he can relay all payments, but he is able to distinctively\n>> identify payee and payers, even with onion routing.\n>\n> That's a different attack isn't it? To get everyone to connect to your\n> nodes, you'd have to be running the majority of nodes -- ie, there's\n> 5000 different organisations running lightning nodes, but 4999 of them\n> run one or two nodes each, but one of them runs 100,000 nodes.\n>\n> But if it were cheap enough for one org to run 100k nodes, why wouldn't\n> the others treat it as an arms race and end up running, say, 20-50\n> nodes each?  They'd have an economic incentive to do so, in that it\n> increases their odds of collecting fees... At that point the attacker's\n> already reduced to 28%-50% of nodes.  ie, I think that's likely to be\n> self-correcting?\n>\n> But! An arms race in nodes-per-person would probably cause a scaling\n> problem for the network (depending on how routing actually works), and\n> you'd have to address that by creating some cost to run (or at least\n> register?) a node/channel. But if they're all legitimate nodes, I think\n> that's just a scaling problem, rather than vandalism per se.\n>\n> (An additional but: even if spamming the list of nodes doesn't work as\n> an effective attack, if you can spam the list of *channels* with valid\n> looking edges that won't actually route payments successfully, you can\n> screw over the network pretty well)\n>\n> Cheers,\n> aj\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-19T21:58:01",
                "message_text_only": "On Mon, Oct 19, 2015 at 09:45:34AM +0200, Mats Jerratsch wrote:\n> All of your assumptions have the premise though, that choosing a\n> 'good' vs a 'bad' guy is pure probability, like picking the right ball\n> out of a bag. [...]\n\nThree sorts of attack:\n\n - Vandals randomly join the lightning network with dysfunctional nodes.\n   They don't have special powers to corrupt your network, and aren't\n   targetting anyone in specific, just trying to damage things because\n   they think lightning is a bad idea and want to stop it happening.\n   This is just a denial of service attack. This is the class of attack\n   that gives the \"pure probability\" of hitting a bad node.\n\n - Sybil attack, where someone is targetting you personally, and\n   controlling all the nodes you connect to. This is the \"compromised\n   wifi or ISP\" case, and afaics denial-of-service is trivial here,\n   so all you can reasonably do is detect that you can't send funds to\n   anyone usefully, and avoid locking up lots of funds while trying.\n\n - Pervasive attack, where everyone in some large group is\n   simultaenously suffering from a sybil attack; eg the Chinese gov or an\n   ISP blocks lightning connections unless they're to one of its nodes,\n   so they always see both ends of payments between their victims. This\n   seems very expensive to pull off to me (you have to do deep inspection\n   of a whole bunch of people's internet connections), but I'm not sure\n   it can be effectively defended against. \"Oh i was just forwarding\n   that to someone else\" doesn't work if there wasn't any way you could\n   make a channel with anyone else (or if secretly forwarding payments\n   is criminal in itself).\n\n> Think about an attacker who is able to MITM your internet connection,\n> like the hotspot you connect to at a Cafe (or your ISP if hijacked).\n> They can build locally a gigantic network, all pointing to the same\n> node. You can't tell, and they don't have to necessarily just block\n> your payments. (see above)\n\nBut you can tell, just by seeing whether a well-known third party's\nlightning address is routable? If every node on your network is an\nattacker's, then you won't see the third party's address.\n\nIf you do see a route to the third party (ie, Me -> Attacker -> Attacker\n-> Attacker -> Bob -> Carol -> Third party), then you could work backwards\nasking Carol and Bob to connect directly to you, which would get you a\nnon-attacker node with reasonable probability, assuming there are any.\n\nI guess there's two ways in which a node is \"on the network\" -- one\nis if it's reachable by p2p hopping (\"Hey, what are your neighbours'\nnetwork addresses?\" \"Okay, connect to them and repeat\"), the other if it's\nroutable over established channels. If you do a Sybil attack against p2p\nhopping; my argument is you can still use the payment channels as a way\nof connecting to other nodes. And if you do a Sybil attack against both\np2p hopping /and/ the graph of channels, then that's detectable because\nwell-known nodes simply won't appear in the graph.\n\n> Only nuisance is that it requires either SPV or full node to check the\n> anchor, but I kinda like the idea of having all (or a good amount) of\n> lightning nodes be full bitcoin nodes as well.\n\nYou need to monitor the blockchain for spends of your own anchors\nanyway, so that doesn't seem like a big additional limitation to me.\n\nCheers,\naj"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-20T07:27:11",
                "message_text_only": "> But you can tell, just by seeing whether a well-known third party's\n> lightning address is routable? If every node on your network is an\n> attacker's, then you won't see the third party's address.\n>\n> If you do see a route to the third party (ie, Me -> Attacker -> Attacker\n> -> Attacker -> Bob -> Carol -> Third party), then you could work backwards\n> asking Carol and Bob to connect directly to you, which would get you a\n> non-attacker node with reasonable probability, assuming there are any.\n\nNo you can't, that's the whole point. ;)\nJust because they are attacking you personally does not mean they do\nnot have a working link to the rest of the network. They can still\nroute all your payment and (1) monitor all your activity (2) gain some\nprofit by charging some high fees off of you.\n\nMaybe I am missing something though.."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-20T06:25:04",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> Think about an attacker who is able to MITM your internet connection,\n> like the hotspot you connect to at a Cafe (or your ISP if hijacked).\n> They can build locally a gigantic network, all pointing to the same\n> node. You can't tell, and they don't have to necessarily just block\n> your payments. (see above)\n>\n> I am mainly concerned over those. Especially since there is not really\n> anything we can do about dishonest nodes joining our network, but it's\n> encouraging to see your math. Since everything security-wise so far\n> stands only with knowing pubkeys of nodes actually connected to the\n> network, this should be the first thing to tackle. (that is, making it\n> expensive to attack it this way)\n\nWell, bitcoin protects from this using checkpoints, which are\ncentralized.  Because AFAICT there's no really good way of doing it.\n\nIf we use beacons, this does become a bit easier: beacons indicate the\nsize of the network (statistically), so you can embed that estimate in\nhow large you expect the network to be.\n\n> Only nuisance is that it requires either SPV or full node to check the\n> anchor, but I kinda like the idea of having all (or a good amount) of\n> lightning nodes be full bitcoin nodes as well.\n\nWe're going to need to support both, but for the moment I expect they'll\nbe full nodes.\n\nCheers,\nRusty."
            },
            {
                "author": "Peter Todd",
                "date": "2015-10-20T15:38:52",
                "message_text_only": "On Tue, Oct 20, 2015 at 04:55:04PM +1030, Rusty Russell wrote:\n> Mats Jerratsch <matsjj at gmail.com> writes:\n> > Think about an attacker who is able to MITM your internet connection,\n> > like the hotspot you connect to at a Cafe (or your ISP if hijacked).\n> > They can build locally a gigantic network, all pointing to the same\n> > node. You can't tell, and they don't have to necessarily just block\n> > your payments. (see above)\n> >\n> > I am mainly concerned over those. Especially since there is not really\n> > anything we can do about dishonest nodes joining our network, but it's\n> > encouraging to see your math. Since everything security-wise so far\n> > stands only with knowing pubkeys of nodes actually connected to the\n> > network, this should be the first thing to tackle. (that is, making it\n> > expensive to attack it this way)\n> \n> Well, bitcoin protects from this using checkpoints, which are\n> centralized.  Because AFAICT there's no really good way of doing it.\n\nActually, I'd point out that checkpoints aren't as centralized as you'd\nthink! Checkpoints are set sufficiently far back in the past that if\nthey come into play for any reason other than initial bootstrapping, an\nactive attacker exists that has sufficient hashing power to destroy\nBitcoin anyway. Thus, checkpoints do *not* need consensus between\ndifferent implementations; my Bitcoin implementation can set a different\ncheckpoint than yours and both will work fine, except in the case of\nmassive attacks that Bitcoin can't survive anyway.\n\nI probably should release a Bitcoin implementation with different\ncheckpoints than Bitcoin Core to make this point more clearly...\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000024918099cc7ec614db68e95d5f8b2b54fb5d06d33c764d9\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151020/c7053b57/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-20T23:15:26",
                "message_text_only": "Peter Todd <pete at petertodd.org> writes:\n> On Tue, Oct 20, 2015 at 04:55:04PM +1030, Rusty Russell wrote:\n>> Mats Jerratsch <matsjj at gmail.com> writes:\n>> > Think about an attacker who is able to MITM your internet connection,\n>> > like the hotspot you connect to at a Cafe (or your ISP if hijacked).\n>> > They can build locally a gigantic network, all pointing to the same\n>> > node. You can't tell, and they don't have to necessarily just block\n>> > your payments. (see above)\n>> >\n>> > I am mainly concerned over those. Especially since there is not really\n>> > anything we can do about dishonest nodes joining our network, but it's\n>> > encouraging to see your math. Since everything security-wise so far\n>> > stands only with knowing pubkeys of nodes actually connected to the\n>> > network, this should be the first thing to tackle. (that is, making it\n>> > expensive to attack it this way)\n>> \n>> Well, bitcoin protects from this using checkpoints, which are\n>> centralized.  Because AFAICT there's no really good way of doing it.\n>\n> Actually, I'd point out that checkpoints aren't as centralized as you'd\n> think! Checkpoints are set sufficiently far back in the past that if\n> they come into play for any reason other than initial bootstrapping, an\n> active attacker exists that has sufficient hashing power to destroy\n> Bitcoin anyway. Thus, checkpoints do *not* need consensus between\n> different implementations; my Bitcoin implementation can set a different\n> checkpoint than yours and both will work fine, except in the case of\n> massive attacks that Bitcoin can't survive anyway.\n\nBitcoin implementations could remove the confusion by simply specifying\nhow much total work there is expected to be, but that still allows\nnuisance attacks with alternate chains.\n\nMy point was more that \"it's good enough for bitcoin\" so don't feel too\nbad if we end up with clients hardcoding details about the lightning\nnetwork they expect to connect to (at the very least, its size).\n\nThanks,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Preventing MITM - Providing new nodes with real pubkeys",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Mats Jerratsch",
                "Peter Todd"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 39278
        }
    },
    {
        "title": "[Lightning-dev] Specifications of Broadcasting Layers",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-16T13:23:34",
                "message_text_only": "Other post was quite long already and they are actually dealing with\ntwo different issues.\n\n\nSo currently I can think of 3 different broadcast messages, that are\ndifferently dynamic and needs different handling, so I attach them\neach with a new signature (which bloats a lot unfortunately).\n(1) Pubkey-Channel-Relationships (see other post on ML)\nVery static, relayed every 10 days\n264 Bytes\n\n(2) Node addresses/IP\nDepends on the nodes (dynamic/static IP), approx every 12h\n133 Bytes (some estimate, as I want to support addresses too, not just IPs)\n\n(3) Channel-Status (capacity, fee, ...)\nHighly depending on actual traffic and node usage - once an hour?\n176 Bytes (estimated, depends on actual content)\n\nI would love to combine (1) and (3) to save the 80B of an additional\nsignature, but at the same time (1) is not worth an hourly broadcast.\nFurthermore, I would spare some additional bytes in (1) for some\nreputation system (yes, I really am into these.)\nThese three add up to 2.5GB daily data, or 30kb/s constant load.\nFor hard drive space it is around 330MB.\n\n\nI think we can either realise it as some kind of gossip protocol (easy\nto implement, overhead of an efficient gossip protocol can be very\nlow) or use some DHT approach (difficult to bootstrap, has to be\ndesigned to be highly resistant to failure/highly redundant).\nA new node would want to retrieve the full dataset similar to the\nblockchain before actually opening a channel with a new node. So we\nneed to design a way of retrieving the full dataset for fresh nodes,\nprobably in some load-distributed way, although 330MB isn't too much\nto retrieve from 1-5 nodes. (and 100k nodes is a pretty optimistic\nview of the network too currently, although rusty usually starts even\nhigher...)\n\n\nMats Jerratsch"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-19T00:48:30",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> Other post was quite long already and they are actually dealing with\n> two different issues.\n>\n>\n> So currently I can think of 3 different broadcast messages, that are\n> differently dynamic and needs different handling, so I attach them\n> each with a new signature (which bloats a lot unfortunately).\n\nIndeed, I think this breakdown is correct.\n\n> (1) Pubkey-Channel-Relationships (see other post on ML)\n> Very static, relayed every 10 days\n> 264 Bytes\n>\n> (2) Node addresses/IP\n> Depends on the nodes (dynamic/static IP), approx every 12h\n> 133 Bytes (some estimate, as I want to support addresses too, not just IPs)\n>\n> (3) Channel-Status (capacity, fee, ...)\n> Highly depending on actual traffic and node usage - once an hour?\n> 176 Bytes (estimated, depends on actual content)\n\nThese estimates seem about the right ballpark to me.  But once per hour\nmay be extremely optimistic when channels approach exhaustion.  That's\nbecause (1) it's logical for fees to rise significantly at that point,\nand (2) you want to know if capacity is sufficient for the amount you're\nsending.\n\nA random beacon model has the advantage of requiring only partial\ntopology knowledge, which makes these numbers sacle much better.\nHowever, it introduces another factor.\n\n> I think we can either realise it as some kind of gossip protocol (easy\n> to implement, overhead of an efficient gossip protocol can be very\n> low) or use some DHT approach (difficult to bootstrap, has to be\n> designed to be highly resistant to failure/highly redundant).\n\nBram Cohen was supportive of the idea of using BitTorrent's DHT.  I\nthink that's the most sensible approach if we are going to go that route\nfor (1 and 2).\n\nFor #3, we need our own inline protocol.\n\n> A new node would want to retrieve the full dataset similar to the\n> blockchain before actually opening a channel with a new node. So we\n> need to design a way of retrieving the full dataset for fresh nodes,\n> probably in some load-distributed way, although 330MB isn't too much\n> to retrieve from 1-5 nodes. (and 100k nodes is a pretty optimistic\n> view of the network too currently, although rusty usually starts even\n> higher...)\n\nYeah, my design point has been 1M nodes.  Ideally, on a cell phone :)\n\nIn the very short term, Bitcoin used IRC as the peer protocol.  It has\nthe advantage of being really easy to debug, and trivial to implement,\nso I'm going to aim at that while we research our more ambitious\nproposals...\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-19T23:55:01",
                "message_text_only": "On Mon, Oct 19, 2015 at 11:18:30AM +1030, Rusty Russell wrote:\n> > (1) Pubkey-Channel-Relationships (see other post on ML)\n> > Very static, relayed every 10 days // 264 Bytes\n> > (2) Node addresses/IP\n> > ... approx every 12h // 133 Bytes [...]\n> > (3) Channel-Status (capacity, fee, ...)\n> > ... once an hour? // 176 Bytes [...]\n> These estimates seem about the right ballpark to me.  But once per hour\n> may be extremely optimistic when channels approach exhaustion.\n\n> Yeah, my design point has been 1M nodes.  Ideally, on a cell phone :)\n\n> In the very short term, Bitcoin used IRC as the peer protocol.  It has\n> the advantage of being really easy to debug, and trivial to implement,\n> so I'm going to aim at that while we research our more ambitious\n> proposals...\n\nI'm totally a fan of being able to log the entire network dynamics too...\n\nSo doing the above over IRC means maybe doubling the byte size to encode\nkeys/sigs into hex, and adding maybe 32B per message for IRC protocol\noverhead.  So:\n\n  560B/channel/10 days\n  298B/node/12h\n  384B/channel/1h\n\nAssume ~10 channels per node and converting to bytes/node/day:\n\n     560B/node/day\n     564B/node/day\n  92,160B/node/day\n= 93,284B/node/day total\n\nwhich is about 1.054 KiB/s per thousand nodes. If it's a single server\nrelaying that to a thousand nodes, that's 8.2 megabit/s outgoing\nalready. So that plan probably maxes out somewhere between 500-3000 nodes?\n\n>From what I gather bitcoin only used IRC to get IP addresses to connect\nto, which were encoded in the nicks used, rather than anything being\nactually said. It seems like that got up to 10000 nodes [0]. Hopefully\nlightning's irc usage doesn't get misdetected as botnet C&C :)\n\n[0] https://bitcointalk.org/index.php?topic=9240.0\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-20T06:31:16",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Mon, Oct 19, 2015 at 11:18:30AM +1030, Rusty Russell wrote:\n>> > (1) Pubkey-Channel-Relationships (see other post on ML)\n>> > Very static, relayed every 10 days // 264 Bytes\n>> > (2) Node addresses/IP\n>> > ... approx every 12h // 133 Bytes [...]\n>> > (3) Channel-Status (capacity, fee, ...)\n>> > ... once an hour? // 176 Bytes [...]\n>> These estimates seem about the right ballpark to me.  But once per hour\n>> may be extremely optimistic when channels approach exhaustion.\n>\n>> Yeah, my design point has been 1M nodes.  Ideally, on a cell phone :)\n>\n>> In the very short term, Bitcoin used IRC as the peer protocol.  It has\n>> the advantage of being really easy to debug, and trivial to implement,\n>> so I'm going to aim at that while we research our more ambitious\n>> proposals...\n>\n> I'm totally a fan of being able to log the entire network dynamics too...\n>\n> So doing the above over IRC means maybe doubling the byte size to encode\n> keys/sigs into hex, and adding maybe 32B per message for IRC protocol\n> overhead.  So:\n>\n>   560B/channel/10 days\n>   298B/node/12h\n>   384B/channel/1h\n>\n> Assume ~10 channels per node and converting to bytes/node/day:\n>\n>      560B/node/day\n>      564B/node/day\n>   92,160B/node/day\n> = 93,284B/node/day total\n\nWe'll get kicked off freenode long before that.  But it allows us to\nmaster the other parts of the protocol first, up to a few hundred nodes.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Specifications of Broadcasting Layers",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Mats Jerratsch"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7501
        }
    },
    {
        "title": "[Lightning-dev] daemon/p2p protocol",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-10-16T20:53:55",
                "message_text_only": "Hey *,\n\nA few thoughts on the daemon/p2p protocol in slightly longer form than\nis feasible on IRC...\n\n# protobufs or capnp or flatbuffers or ...\n\nCurrently lightning relies on protobuf's with union support, which\nrequires a newer version of protobuf-c than is in Debian or Ubuntu.\nI've filed this as http://bugs.debian.org/801950 -- seems to be an\neasy fix.\n\n11:43  * rusty looks at capnproto, is tempted to see what that would\n         look like compared to protobufs.\n\ncapnp's canonical implementation is in C++ rather than C; the C version\nis serialisaion-only, which seems like it loses the fancy time-travel\nRPC feature? C and Python versions of capnp don't seem to be packaged\nfor Debian. Not a show-stopper afaics, but I'm not seeing the benefit?\n\n11:44 <rusty> But it still doesn't have fixed-length fields, which is a\n              PITA.\n\nFWIW, I think that \"fixed-length fields\" is just a schema/IDL thing? ie\nthe serialised format should still have a byte or two to specify format\nand length (because it's no big deal and slightly safer/saner when\ndeserialising), but if it's not the correct value from the schema/.proto\nfile, you get an error when you try to de/serialise.\n\nWith protobufs, I think you could do this with custom field options:\n\nhttps://developers.google.com/protocol-buffers/docs/proto?hl=en#customoptions \n\nSomething like:\n\n  import \"descriptor.proto\";\n  extend google.protobuf.FieldOptions {\n    optional int32 fixed_size = 59797;\n  }\n\n  // Protobufs don't have fixed-length fields, so these are a hack.\n  message sha256_hash2 {\n    required bytes hash = 1 [(fixed_size)=32];\n  }\n\nseems like it works as documentation. Not obvious how to get it passed\nthrough to C somehow so that you could actually check it automatically.\n(Not sure what's with the brackets around fixed_size; it whines if you\ndon't have them.)\n\n\n# lightning public keys...\n\nI think there are (at least) three uses for public key crypto in lightning:\n\n  1) routing keys -- used for constructing the onion. the routing public\n     key is essentially the node's identity as far as lightning is\n     concerned and must be well known and associated with channels\n     and fees for routing to be possible. *However* a single lightning\n     instance might play host to multiple routing keys.  (This would be\n     less efficient for the network, but might be a win for privacy or\n     might be dictated by deployment reasons...)\n\n  2) anchor keys -- used for spending the anchor transaction for a\n     channel and thus signing commitment transactions; only needs to be\n     known by the counterparty you're constructing a channel with; can\n     be different for every channel.\n\n  3) p2p keys -- used for establishing a shared secret when talking to a\n     node, to avoid your p2p communications being available to someone\n     else (either a passive observer or a MITM). could be different for\n     every connection, or could just have one the lightning instance.\n\n\n\n# p2p protocol...\n\nIf Alice tries to connect to Bob, I think the current protocol (as of\ngit commit gc7eaa4f, from daemon/cryptopkt.c) is:\n\n  Alice: \"Call me <RichGirl57914>.\"\n  Bob: \"Call me <MoneyBags70623>.\"\n\nThen, encrypted to key based on ECDH(RichGirl57914, MoneyBag70623):\n\n  Alice: \"RichGirl57914 is actually Alice, signed <Alice>\"\n  Bob: \"MoneyBags70623 is actually Bob, signed <Bob>\"\n\nThis is secure against passive monitoring; and after the signatures are\nverified, it's also secure against MITM attacks.\n\nIt seems like it has a couple of downsides though:\n\n - if you're accepting incoming p2p connections, you'll reveal your node\n   id to anyone who asks\n\n - if the node you're connecting to is MITM'ed, you'll reveal your node\n   id before realising you're MITM'ed\n\n - you can't run multiple node ids on a single connection\n\n - Bob has to do crypto operations for every connection, leading to\n   potential DoS attacks\n\nI think treating the relationship between a network address (IPv4/IPv6\naddr and port, tor service) and the lightning network address as sensitive\nis valuable. Revealing a network address helps reveal physical identity,\nmakes denial-of-service attacks straightforward, and gives a point of\nentry for targetted hacking to steal your money."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-19T05:30:03",
                "message_text_only": "On Sat, Oct 17, 2015 at 06:53:55AM +1000, Anthony Towns wrote:\n> I think treating the relationship between a network address (IPv4/IPv6\n> addr and port, tor service) and the lightning network address as sensitive\n> is valuable. Revealing a network address helps reveal physical identity,\n> makes denial-of-service attacks straightforward, and gives a point of\n> entry for targetted hacking to steal your money.\n\nI guess the attacks I'm thinking of are something like:\n\nExploits leading to theft:\n\n - if you're a merchant, it's easy to find out your lightning id (just\n   buy something from you!) and during the trading day you'll probably\n   have a relatively large balance in your lightning channels (up until\n   you close it out by committing your profits to the blockchain eg). If\n   I can find your IP address and hack into your system, I can steal\n   that money.\n\n - if you're making lots of money routing payments, I might be able to\n   deduce that from public information (like how cheap your fees are,\n   how rarely your fees change, how many connections you have, ...)\n   and thus know that you have a lot of money in lightning channels that\n   I can steal\n\n - if you're just being a consumer, however, I can't think of a reason\n   your lightning id would matter -- if I can snoop on your IP connection,\n   I can probably tell you're mostly a consumer by traffic analysis,\n   and conclude that you've probably got $10-$100 that could be\n   stolen. failure of imagination on my behalf?\n\nDenial of service:\n\n - I might know the lightning id of someone I don't like; a merchant who\n   sells something unpopular, or a node that routes payment for people I\n   don't like. If I can translate that into an IP address, I might be\n   able to DoS them using botnets etc.\n\nExploits that help you exploit others:\n\n - if I know X has a channel with you; figuring out X's IP might let\n   me monitor X's TCP connections (by hacking into their system, or\n   by subpoena'ing their ISP), which in turn would help me figure out\n   your IP.\n\nI guess there's three ways you can associate the info:\n\n a) given a lightning id, cheaply work out the IP that provides it\n\n b) given an IP, cheaply work out the lightning id associated with it\n\n c) given an IP and a lightning id, confirm/deny whether that lightning\n    id is provided by that IP\n\n(a) is what you want if you're planning theft or DoS\n\n(c) is enough if you've got other information about whoever you want to\n    attack that can narrow down the lightning ids and IP addresses (eg, you\n    want to attack a local business, so you can find out their lightning id\n    directly, and narrow down their IP based on local ISPs)\n\n(c) is obviously trivial if you've already got (a) or (b).\n\nYou can get to (a) from (b) if (b) is cheap enough and you can build up\na database that you can query in reverse.\n\nIf you're not an attacker, then (a) is useful if you want to have new\nchannels not be totally random (eg, to have people be able to connect\nto newly announced beacons). And (c) is presumably necessary if you\nwant to reconnect to someone you had a channel with, when you lose your\ninternet connction.\n\nOne \"clever\" way to handle (a) might be via a \"fund a new channel by\nlightning transaction\" operation. ie, if you (Alice) want to open a\nchannel with Bob, route a payment to Bob with instructions to forward to\nAlice, and to do that by connecting to a given IP/port and establishing\na new channel; ie rather than just telling Bob to route to Alice in the\nonion payoad, also included Alice's network address. That way Alice\nreveals her IP precisely to Bob; and Bob only reveals his IP if he\ndecides he is interested in opening a channel.\n\nThat'd also provide a way of reconnecting with a peer if you lose your\nconnection and both of you change your IPs. It assumes that you both\nhave an alternative channel that's still functional though.\n\n\nOkay... so how about the following. When making a new p2p connection, when\nyou know who you're talking to, you rely on a shared secret X, and send:\n\n    Alice: \"Hi. I'm <session key A>. My nonce is X.\"\n    Bob: \"Good to meet you, I'm <session key B>.\"\n\nRest is encrypted to ECDH(A,B).\n\n    Alice: SIG_Alice(Alice || Bob || A || ECDH(A,B))\n    Bob: SIG_Bob(Bob || Alice || B || ECDH(A,B))\n\n    Alice: \"Hi Bob!\"\n    Bob: \"Hi Alice!\"\n\n\nIf you don't know who you're talking to, you don't send a nonce and\nyou do the current protocol. Once you're connected (or once you have a\nchannel setup) they'll tell you a nonce to use next time:\n\n    Alice: \"Hi. I'm <session key A>.\"\n    Bob: \"Good to meet you, I'm <session key B>.\"\n\nRest is encrypted to ECDH(A,B).\n\n    Alice: I'm Alice, SIG(Alice || A || ECDH(A,B))\n    Bob: I'm Bob, SIG(Bob || B || ECDH(A,B))\n    Bob: BTW, next time you connect, use nonce <Y>.\n\nIf Bob wants some degree of privacy, while still accepting anonymous\nconnections, then he generates a new id to hand out to anonymous\nconnections every so often, linking it up to one of his other ids, or\nto one of his neighbours by reusing a pre-existing channel. If you're\nasking someone to connect to you and have a bunch of ids, you give them\na nonce to use that will select the correct one. You use nonces as a\nhash key to lookup your id, their id, and any channels you have open.\nYou don't share or reuse nonces.\n\n(If an attacker knows Alice and Bob have a connection, and can MITM\nAlice trying to connect to X, the above lets them verify which of Alice's\nconnections is Bob. If that's a reasonable attack, it'd be avoidable if\nthe nonce X was replaced by X and Y; X sent in cleartext as above, but\nY simply included in the info being signed. That prevents the attacker\nfrom being able to verify the signature info at all)\n\nNot convinced that's quite right, but maybe something along those lines\nmight work out.\n\nUntil there's a substantial number of lightning nodes (1000s?), it's\nprobably trivial to link network address and lightning id by traffic\nanalysis, so I think it's probably sane to leave implementing any of\nthe above until later.\n\nCheers,\naj"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-19T08:51:52",
                "message_text_only": "Hm interesting. So far the IP-PubKey-Relationship was public for me\n(furthermore, I even think about adding it to the gossip protocol, see\nother post).\n\nI think we can mitigate the risks associated fairly well. Suppose\nlightning nodes run on dedicated machines, firewalled against any\nincoming connections (except ones on the lightning port).\n\nAgainst DDoS attacks it could be sufficient to just close this port as\nsoon as you are connected to all of the nodes you want to be\nconnected. Open connections are not affected by this.\n\n\nHowever, I think it will be more difficult to establish a connection\nbetween 'Real identity'-'PubKey'. And this relationship should really\nbe more sensitive. When you pay to someone, he will only provide you\nwith a rendezvous point and the onion object towards him, which is\nencrypted. Lightning nodes can always have a dedicated IP address, to\nmake it more difficult to relate merchant IP and pubkey.\n\nI think it is important to have a map of IP/PubKey for those who want\nto provide it at least. The object which relates your pubkey and IP\nwill be signed with your private key. If you never sign and send such\nan object, no one will be able to tell your IP other than your direct\nneighbors. I think though that most nodes should be able to receive\nnew connections and build channels with foreign nodes. It is a direct\nconsequence of sufficiently hardening the network against failure. If\nyou observe a high fee rate for a specific route, you should be able\nto establish new connections to help the network.\n\n\nAgainst MITM and eavesdropping your pubkey to a stranger connecting to\nyour node, we can change the protocol such that the one initiating the\nconnection always sends his signed pubkey object first. It is up to\nyou to accept it and send yours if you know the other guy or don't\ncare, or to abort the connection if you don't like strangers.\n\nCheers\nMats Jerratsch\n\n2015-10-19 7:30 GMT+02:00 Anthony Towns <aj at erisian.com.au>:\n> On Sat, Oct 17, 2015 at 06:53:55AM +1000, Anthony Towns wrote:\n>> I think treating the relationship between a network address (IPv4/IPv6\n>> addr and port, tor service) and the lightning network address as sensitive\n>> is valuable. Revealing a network address helps reveal physical identity,\n>> makes denial-of-service attacks straightforward, and gives a point of\n>> entry for targetted hacking to steal your money.\n>\n> I guess the attacks I'm thinking of are something like:\n>\n> Exploits leading to theft:\n>\n>  - if you're a merchant, it's easy to find out your lightning id (just\n>    buy something from you!) and during the trading day you'll probably\n>    have a relatively large balance in your lightning channels (up until\n>    you close it out by committing your profits to the blockchain eg). If\n>    I can find your IP address and hack into your system, I can steal\n>    that money.\n>\n>  - if you're making lots of money routing payments, I might be able to\n>    deduce that from public information (like how cheap your fees are,\n>    how rarely your fees change, how many connections you have, ...)\n>    and thus know that you have a lot of money in lightning channels that\n>    I can steal\n>\n>  - if you're just being a consumer, however, I can't think of a reason\n>    your lightning id would matter -- if I can snoop on your IP connection,\n>    I can probably tell you're mostly a consumer by traffic analysis,\n>    and conclude that you've probably got $10-$100 that could be\n>    stolen. failure of imagination on my behalf?\n>\n> Denial of service:\n>\n>  - I might know the lightning id of someone I don't like; a merchant who\n>    sells something unpopular, or a node that routes payment for people I\n>    don't like. If I can translate that into an IP address, I might be\n>    able to DoS them using botnets etc.\n>\n> Exploits that help you exploit others:\n>\n>  - if I know X has a channel with you; figuring out X's IP might let\n>    me monitor X's TCP connections (by hacking into their system, or\n>    by subpoena'ing their ISP), which in turn would help me figure out\n>    your IP.\n>\n> I guess there's three ways you can associate the info:\n>\n>  a) given a lightning id, cheaply work out the IP that provides it\n>\n>  b) given an IP, cheaply work out the lightning id associated with it\n>\n>  c) given an IP and a lightning id, confirm/deny whether that lightning\n>     id is provided by that IP\n>\n> (a) is what you want if you're planning theft or DoS\n>\n> (c) is enough if you've got other information about whoever you want to\n>     attack that can narrow down the lightning ids and IP addresses (eg, you\n>     want to attack a local business, so you can find out their lightning id\n>     directly, and narrow down their IP based on local ISPs)\n>\n> (c) is obviously trivial if you've already got (a) or (b).\n>\n> You can get to (a) from (b) if (b) is cheap enough and you can build up\n> a database that you can query in reverse.\n>\n> If you're not an attacker, then (a) is useful if you want to have new\n> channels not be totally random (eg, to have people be able to connect\n> to newly announced beacons). And (c) is presumably necessary if you\n> want to reconnect to someone you had a channel with, when you lose your\n> internet connction.\n>\n> One \"clever\" way to handle (a) might be via a \"fund a new channel by\n> lightning transaction\" operation. ie, if you (Alice) want to open a\n> channel with Bob, route a payment to Bob with instructions to forward to\n> Alice, and to do that by connecting to a given IP/port and establishing\n> a new channel; ie rather than just telling Bob to route to Alice in the\n> onion payoad, also included Alice's network address. That way Alice\n> reveals her IP precisely to Bob; and Bob only reveals his IP if he\n> decides he is interested in opening a channel.\n>\n> That'd also provide a way of reconnecting with a peer if you lose your\n> connection and both of you change your IPs. It assumes that you both\n> have an alternative channel that's still functional though.\n>\n>\n> Okay... so how about the following. When making a new p2p connection, when\n> you know who you're talking to, you rely on a shared secret X, and send:\n>\n>     Alice: \"Hi. I'm <session key A>. My nonce is X.\"\n>     Bob: \"Good to meet you, I'm <session key B>.\"\n>\n> Rest is encrypted to ECDH(A,B).\n>\n>     Alice: SIG_Alice(Alice || Bob || A || ECDH(A,B))\n>     Bob: SIG_Bob(Bob || Alice || B || ECDH(A,B))\n>\n>     Alice: \"Hi Bob!\"\n>     Bob: \"Hi Alice!\"\n>\n>\n> If you don't know who you're talking to, you don't send a nonce and\n> you do the current protocol. Once you're connected (or once you have a\n> channel setup) they'll tell you a nonce to use next time:\n>\n>     Alice: \"Hi. I'm <session key A>.\"\n>     Bob: \"Good to meet you, I'm <session key B>.\"\n>\n> Rest is encrypted to ECDH(A,B).\n>\n>     Alice: I'm Alice, SIG(Alice || A || ECDH(A,B))\n>     Bob: I'm Bob, SIG(Bob || B || ECDH(A,B))\n>     Bob: BTW, next time you connect, use nonce <Y>.\n>\n> If Bob wants some degree of privacy, while still accepting anonymous\n> connections, then he generates a new id to hand out to anonymous\n> connections every so often, linking it up to one of his other ids, or\n> to one of his neighbours by reusing a pre-existing channel. If you're\n> asking someone to connect to you and have a bunch of ids, you give them\n> a nonce to use that will select the correct one. You use nonces as a\n> hash key to lookup your id, their id, and any channels you have open.\n> You don't share or reuse nonces.\n>\n> (If an attacker knows Alice and Bob have a connection, and can MITM\n> Alice trying to connect to X, the above lets them verify which of Alice's\n> connections is Bob. If that's a reasonable attack, it'd be avoidable if\n> the nonce X was replaced by X and Y; X sent in cleartext as above, but\n> Y simply included in the info being signed. That prevents the attacker\n> from being able to verify the signature info at all)\n>\n> Not convinced that's quite right, but maybe something along those lines\n> might work out.\n>\n> Until there's a substantial number of lightning nodes (1000s?), it's\n> probably trivial to link network address and lightning id by traffic\n> analysis, so I think it's probably sane to leave implementing any of\n> the above until later.\n>\n> Cheers,\n> aj\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-19T22:09:09",
                "message_text_only": "On Mon, Oct 19, 2015 at 10:51:52AM +0200, Mats Jerratsch wrote:\n> Hm interesting. So far the IP-PubKey-Relationship was public for me\n> (furthermore, I even think about adding it to the gossip protocol, see\n> other post).\n\nYeah, it's definitely easier to think about that way.\n\n> I think we can mitigate the risks associated fairly well. Suppose\n> lightning nodes run on dedicated machines, firewalled against any\n> incoming connections (except ones on the lightning port).\n\n(I don't think lightning wallets can realistically run on dedicated\nmachines/IPs; so that makes a significant distinction between wallets\nfor consumers and nodes for routing/merchants I think)\n\n> Against MITM and eavesdropping your pubkey to a stranger connecting to\n> your node, we can change the protocol such that the one initiating the\n> connection always sends his signed pubkey object first.\n\nI don't thnk that works -- if you can MITM Alice and Bob, then you just do\nthat while they're in the middle of a connection. When Alice reconnects,\nshe immediately tells you who she is. If Bob tries reconnecting as well,\nyou find out who he is too. Sending a shared secret nonce instead,\nthen just sending signatures avoids that; either one can re-establish\nthe connection if they can actually talk, and if there's a MITM they\nreveal nothing, but do discover they can't talk.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-21T01:11:45",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Mon, Oct 19, 2015 at 10:51:52AM +0200, Mats Jerratsch wrote:\n>> Hm interesting. So far the IP-PubKey-Relationship was public for me\n>> (furthermore, I even think about adding it to the gossip protocol, see\n>> other post).\n>\n> Yeah, it's definitely easier to think about that way.\n>\n>> I think we can mitigate the risks associated fairly well. Suppose\n>> lightning nodes run on dedicated machines, firewalled against any\n>> incoming connections (except ones on the lightning port).\n>\n> (I don't think lightning wallets can realistically run on dedicated\n> machines/IPs; so that makes a significant distinction between wallets\n> for consumers and nodes for routing/merchants I think)\n>\n>> Against MITM and eavesdropping your pubkey to a stranger connecting to\n>> your node, we can change the protocol such that the one initiating the\n>> connection always sends his signed pubkey object first.\n>\n> I don't thnk that works -- if you can MITM Alice and Bob, then you just do\n> that while they're in the middle of a connection. When Alice reconnects,\n> she immediately tells you who she is. If Bob tries reconnecting as well,\n> you find out who he is too. Sending a shared secret nonce instead,\n> then just sending signatures avoids that; either one can re-establish\n> the connection if they can actually talk, and if there's a MITM they\n> reveal nothing, but do discover they can't talk.\n\nHaving a session nonce does help after first handshake, though it allows\ncorrelation, so it needs to change (pretty trivial, it could just be\nsha256() of some shared secret plus a number which increments on each\nsuccessful handshake).\n\nIn practice I think \"successful handshake\" is a bit vague, so may\nrequire allowing +/- 1 nonce.  I'd have to think harder about this\nthough.\n\nIs this overcomplicating things?\n\nCoffee....\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-21T03:43:10",
                "message_text_only": "On Wed, Oct 21, 2015 at 11:41:45AM +1030, Rusty Russell wrote:\n> Having a session nonce does help after first handshake, though it allows\n> correlation, so it needs to change (pretty trivial, it could just be\n> sha256() of some shared secret plus a number which increments on each\n> successful handshake).\n\nCan just be the first 4-8 bytes of that too (leaving the next 4-28 bytes\nto be the secret response in the signature). ECDH of the node ids would\nbe the obvious shared secret to use as a base?\n\n> In practice I think \"successful handshake\" is a bit vague, so may\n> require allowing +/- 1 nonce.  I'd have to think harder about this\n> though.\n> Is this overcomplicating things?\n\nWhile nodes are publishing their ids (and IPs -- even if only by /whois)\nin a public IRC channel, I don't think a nonce does any good -- the info\nit's trying to avoid revealing is already being revealed anyway. So I\nthink table this for now?\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-19T18:44:19",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> Hey *,\n>\n> A few thoughts on the daemon/p2p protocol in slightly longer form than\n> is feasible on IRC...\n>\n> # protobufs or capnp or flatbuffers or ...\n>\n> Currently lightning relies on protobuf's with union support, which\n> requires a newer version of protobuf-c than is in Debian or Ubuntu.\n> I've filed this as http://bugs.debian.org/801950 -- seems to be an\n> easy fix.\n>\n> 11:43  * rusty looks at capnproto, is tempted to see what that would\n>          look like compared to protobufs.\n>\n> capnp's canonical implementation is in C++ rather than C; the C version\n> is serialisaion-only, which seems like it loses the fancy time-travel\n> RPC feature? C and Python versions of capnp don't seem to be packaged\n> for Debian. Not a show-stopper afaics, but I'm not seeing the benefit?\n\nI like the capnproto design, and protobufsq v3 has already been introduced by\nGoogle to deprecate protobufs v2.\n\nHowever, bitcoin already uses protobufs for the payment protocol, and as\nyour research reveals, it's more widely supported.\n\n> 11:44 <rusty> But it still doesn't have fixed-length fields, which is a\n>               PITA.\n>\n> FWIW, I think that \"fixed-length fields\" is just a schema/IDL thing? ie\n> the serialised format should still have a byte or two to specify format\n> and length (because it's no big deal and slightly safer/saner when\n> deserialising), but if it's not the correct value from the schema/.proto\n> file, you get an error when you try to de/serialise.\n\nYou want the deserialization to do as much sanity checking as possible,\n*particularly* when it comes to lengths of things.  Working around this\nfeature is YA footgun.\n\n> With protobufs, I think you could do this with custom field options:\n>\n> https://developers.google.com/protocol-buffers/docs/proto?hl=en#customoptions \n\nI use multiple values, which is even uglier but supported\nout-of-the-box.\n\n> # lightning public keys...\n>\n> I think there are (at least) three uses for public key crypto in lightning:\n>\n>   1) routing keys -- used for constructing the onion. the routing public\n>      key is essentially the node's identity as far as lightning is\n>      concerned and must be well known and associated with channels\n>      and fees for routing to be possible. *However* a single lightning\n>      instance might play host to multiple routing keys.  (This would be\n>      less efficient for the network, but might be a win for privacy or\n>      might be dictated by deployment reasons...)\n\nMats calls this \"nodepubkey\" and I've just been calling it \"nodeid\".\n\n>   2) anchor keys -- used for spending the anchor transaction for a\n>      channel and thus signing commitment transactions; only needs to be\n>      known by the counterparty you're constructing a channel with; can\n>      be different for every channel.\n\nYeah, Mats suggested nodes publish the proof from anchor key -> routing\nkey.\n\n>   3) p2p keys -- used for establishing a shared secret when talking to a\n>      node, to avoid your p2p communications being available to someone\n>      else (either a passive observer or a MITM). could be different for\n>      every connection, or could just have one the lightning instance.\n\nIndeed, current crypto handshake starts with this key exchange, then\nproves ownership of the routing key.\n\n> # p2p protocol...\n>\n> If Alice tries to connect to Bob, I think the current protocol (as of\n> git commit gc7eaa4f, from daemon/cryptopkt.c) is:\n>\n>   Alice: \"Call me <RichGirl57914>.\"\n>   Bob: \"Call me <MoneyBags70623>.\"\n>\n> Then, encrypted to key based on ECDH(RichGirl57914, MoneyBag70623):\n>\n>   Alice: \"RichGirl57914 is actually Alice, signed <Alice>\"\n>   Bob: \"MoneyBags70623 is actually Bob, signed <Bob>\"\n>\n> This is secure against passive monitoring; and after the signatures are\n> verified, it's also secure against MITM attacks.\n>\n> It seems like it has a couple of downsides though:\n>\n>  - if you're accepting incoming p2p connections, you'll reveal your node\n>    id to anyone who asks\n\nYes, unless you wait for them to go first.  Of course, only one side can\ndo this...\n\n>  - if the node you're connecting to is MITM'ed, you'll reveal your node\n>    id before realising you're MITM'ed\n>\n>  - you can't run multiple node ids on a single connection\n>\n>  - Bob has to do crypto operations for every connection, leading to\n>    potential DoS attacks\n>\n> I think treating the relationship between a network address (IPv4/IPv6\n> addr and port, tor service) and the lightning network address as sensitive\n> is valuable. Revealing a network address helps reveal physical identity,\n> makes denial-of-service attacks straightforward, and gives a point of\n> entry for targetted hacking to steal your money.\n\nIt would be possible to move to a different address once authenticated.\nBut someone needs to run public nodes.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "daemon/p2p protocol",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "Mats Jerratsch"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 27729
        }
    },
    {
        "title": "[Lightning-dev] [PATCH v3] daemon: encrypted communication (version 3)",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-10-23T01:33:33",
                "message_text_only": "OK, once I started trying to send data, I refined this a little so\nwe always send protobufs after the initial session key.\n\nFeedback gratefully accepted!\n\nThanks,\nRusty.\n--\nAfter useful feedback from Anthony Towns and Mats Jerratsch (of\nthunder.network fame), this is the third version of inter-node crypto.\n\n1) First, each side sends a 33-byte session pubkey.  This is a\n   bitcoin-style compressed EC key, unique for each session.\n  \n2) ECDH is used to derive a shared secret.  From this we generate\n   the following transmission encoding parameters for each side:\n   Session AES-128 key: SHA256(shared-secret || my-sessionpubkey || 0)\n   Session HMAC key: SHA256(shared-secret || my-sessionpubkey || 1)\n   IV for AES: SHA256(shared-secret || my-sessionpubkey || 2)\n\n3) All packets from then on are encrypted of form:\n\t/* HMAC, covering totlen and data */\n\tstruct sha256 hmac;\n\t/* Total data transmitted (including this). */\n\tle64 totlen;\n\t/* Encrypted contents, rounded up to 16 byte boundary. */\n\tu8 data[];\n\n4) The first packet is an Authenticate protobuf, containing this node's\n   pubkey, and a bitcoin-style EC signature of the other side's session\n   pubkey.\n\n5) Unknown protobuf fields are handled in the protocol as follows\n   (including in the initial Authenticate packet):\n\n   1) Odd numbered fields are optional, and backwards compatible.\n   2) Even numbered fields are required; abort if you get one.\n\nCurrently both sides just send an error packet \"hello\" after the\nhandshake, and make sure they receive the same.\n\nSigned-off-by: Rusty Russell <rusty at rustcorp.com.au>\n\ndiff --git a/daemon/Makefile b/daemon/Makefile\nindex 699cdc9..dfdcc0f 100644\n--- a/daemon/Makefile\n+++ b/daemon/Makefile\n@@ -14,6 +14,7 @@ DAEMON_LIB_SRC :=\t\t\t\t\\\n DAEMON_LIB_OBJS := $(DAEMON_LIB_SRC:.c=.o)\n \n DAEMON_SRC :=\t\t\t\t\t\\\n+\tdaemon/cryptopkt.c\t\t\t\\\n \tdaemon/dns.c\t\t\t\t\\\n \tdaemon/jsonrpc.c\t\t\t\\\n \tdaemon/lightningd.c\t\t\t\\\n@@ -31,6 +32,7 @@ DAEMON_JSMN_HEADERS := daemon/jsmn/jsmn.h\n \n DAEMON_HEADERS :=\t\t\t\t\\\n \tdaemon/configdir.h\t\t\t\\\n+\tdaemon/cryptopkt.h\t\t\t\\\n \tdaemon/dns.h\t\t\t\t\\\n \tdaemon/json.h\t\t\t\t\\\n \tdaemon/jsonrpc.h\t\t\t\\\ndiff --git a/daemon/cryptopkt.c b/daemon/cryptopkt.c\nnew file mode 100644\nindex 0000000..0667d6d\n--- /dev/null\n+++ b/daemon/cryptopkt.c\n@@ -0,0 +1,511 @@\n+#include \"bitcoin/shadouble.h\"\n+#include \"bitcoin/signature.h\"\n+#include \"cryptopkt.h\"\n+#include \"lightning.pb-c.h\"\n+#include \"lightningd.h\"\n+#include \"log.h\"\n+#include \"peer.h\"\n+#include \"protobuf_convert.h\"\n+#include \"secrets.h\"\n+#include <ccan/build_assert/build_assert.h>\n+#include <ccan/crypto/sha256/sha256.h>\n+#include <ccan/endian/endian.h>\n+#include <ccan/io/io_plan.h>\n+#include <ccan/mem/mem.h>\n+#include <ccan/short_types/short_types.h>\n+#include <inttypes.h>\n+#include <openssl/aes.h>\n+#include <openssl/evp.h>\n+#include <openssl/hmac.h>\n+#include <openssl/rand.h>\n+#include <secp256k1.h>\n+#include <secp256k1_ecdh.h>\n+\n+#define MAX_PKT_LEN (1024 * 1024)\n+\n+#define ROUNDUP(x,a) (((x) + ((a)-1)) & ~((a)-1))\n+\n+struct crypto_pkt {\n+\t/* HMAC */\n+\tstruct sha256 hmac;\n+\t/* Total length transmitted. */\n+\tle64 totlen;\n+\t/* ... contents... */\n+\tu8 data[];\n+};\n+\n+/* Temporary structure for negotiation (peer->io_data->neg) */\n+struct key_negotiate {\n+\t/* Our session secret key. */\n+\tu8 seckey[32];\n+\n+\t/* Our pubkey, their pubkey. */\n+\tu8 our_sessionpubkey[33], their_sessionpubkey[33];\n+\n+\t/* Callback once it's all done. */\n+\tstruct io_plan *(*cb)(struct io_conn *, struct peer *);\n+};\n+\n+/* ARM loves to add padding to structs; be paranoid! */ \n+#define SESSION_PROOF_BASE_SIZE (64 + 33)\n+\n+#define ENCKEY_SEED 0\n+#define HMACKEY_SEED 1\n+#define IV_SEED 2\n+\n+struct enckey {\n+\tstruct sha256 k;\n+};\n+\n+struct hmackey {\n+\tstruct sha256 k;\n+};\n+\n+struct iv {\n+\tunsigned char iv[AES_BLOCK_SIZE];\n+};\n+\n+static void sha_with_seed(const unsigned char secret[32],\n+\t\t\t  const unsigned char serial_pubkey[33],\n+\t\t\t  unsigned char seed,\n+\t\t\t  struct sha256 *res)\n+{\n+\tstruct sha256_ctx ctx;\n+\n+\tsha256_init(&ctx);\n+\tsha256_update(&ctx, memcheck(secret, 32), 32);\n+\tsha256_update(&ctx, memcheck(serial_pubkey, 33), 33);\n+\tsha256_u8(&ctx, seed);\n+\tsha256_done(&ctx, res);\n+}\n+\n+static struct enckey enckey_from_secret(const unsigned char secret[32],\n+\t\t\t\t\tconst unsigned char serial_pubkey[33])\n+{\n+\tstruct enckey enckey;\n+\tsha_with_seed(secret, serial_pubkey, ENCKEY_SEED, &enckey.k);\n+\treturn enckey;\n+}\n+\n+static struct hmackey hmackey_from_secret(const unsigned char secret[32],\n+\t\t\t\t\t  const unsigned char serial_pubkey[33])\n+{\n+\tstruct hmackey hmackey;\n+\tsha_with_seed(secret, serial_pubkey, HMACKEY_SEED, &hmackey.k);\n+\treturn hmackey;\n+}\n+\n+static struct iv iv_from_secret(const unsigned char secret[32],\n+\t\t\t\tconst unsigned char serial_pubkey[33])\n+{\n+\tstruct sha256 sha;\n+\tstruct iv iv;\n+\n+\tsha_with_seed(secret, serial_pubkey, IV_SEED, &sha);\n+\tmemcpy(iv.iv, sha.u.u8, sizeof(iv.iv));\n+\treturn iv;\n+}\n+\n+struct dir_state {\n+\tu64 totlen;\n+\tstruct hmackey hmackey;\n+\tEVP_CIPHER_CTX evpctx;\n+\n+\t/* Current packet. */\n+\tstruct crypto_pkt *cpkt;\n+};\n+\n+static bool setup_crypto(struct dir_state *dir,\n+\t\t\t u8 shared_secret[32], u8 serial_pubkey[33])\n+{\n+\tstruct iv iv;\n+\tstruct enckey enckey;\n+\n+\tdir->totlen = 0;\t\n+\tdir->hmackey = hmackey_from_secret(shared_secret, serial_pubkey);\n+\tdir->cpkt = NULL;\n+\t\n+\tiv = iv_from_secret(shared_secret, serial_pubkey);\n+\tenckey = enckey_from_secret(shared_secret, serial_pubkey);\n+\n+\treturn EVP_EncryptInit(&dir->evpctx, EVP_aes_128_ctr(),\n+\t\t\t       memcheck(enckey.k.u.u8, sizeof(enckey.k)),\n+\t\t\t       memcheck(iv.iv, sizeof(iv.iv))) == 1;\n+}\n+\n+struct io_data {\n+\t/* Stuff we need to keep around to talk to peer. */\n+\tstruct dir_state in, out;\n+\n+\t/* Header we're currently reading. */\n+\tsize_t len_in;\n+\tstruct crypto_pkt hdr_in;\n+\n+\t/* For negotiation phase. */\n+\tstruct key_negotiate *neg;\n+};\n+\n+static void *proto_tal_alloc(void *allocator_data, size_t size)\n+{\n+\treturn tal_arr(allocator_data, char, size);\n+}\n+\n+static void proto_tal_free(void *allocator_data, void *pointer)\n+{\n+\ttal_free(pointer);\n+}\n+\n+static Pkt *decrypt_pkt(struct peer *peer, struct crypto_pkt *cpkt,\n+\t\t\tsize_t data_len)\n+{\n+\tsize_t full_len;\n+\tstruct sha256 hmac;\n+\tint outlen;\n+\tstruct io_data *iod = peer->io_data;\n+\tstruct ProtobufCAllocator prototal;\n+\tPkt *ret;\n+\n+\tfull_len = ROUNDUP(data_len, AES_BLOCK_SIZE);\n+\n+\tHMAC(EVP_sha256(), iod->in.hmackey.k.u.u8, sizeof(iod->in.hmackey),\n+\t     (unsigned char *)&cpkt->totlen, sizeof(cpkt->totlen) + full_len,\n+\t     hmac.u.u8, NULL);\n+\n+\tif (CRYPTO_memcmp(&hmac, &cpkt->hmac, sizeof(hmac)) != 0) {\n+\t\tlog_unusual(peer->log, \"Packet has bad HMAC\");\n+\t\treturn NULL;\n+\t}\n+\n+\t/* FIXME: Assumes we can decrypt in place! */\n+\tEVP_DecryptUpdate(&iod->in.evpctx, cpkt->data, &outlen,\n+\t\t\t  memcheck(cpkt->data, full_len), full_len);\n+\tassert(outlen == full_len);\n+\n+\t/* De-protobuf it. */\n+\tprototal.alloc = proto_tal_alloc;\n+\tprototal.free = proto_tal_free;\n+\tprototal.allocator_data = tal(iod, char);\n+\n+\tret = pkt__unpack(&prototal, data_len, cpkt->data);\n+\tif (!ret)\n+\t\ttal_free(prototal.allocator_data);\n+\telse\n+\t\t/* Make sure packet owns contents */\n+\t\ttal_steal(ret, prototal.allocator_data);\n+\treturn ret;\n+}\n+\n+static struct crypto_pkt *encrypt_pkt(struct peer *peer,\n+\t\t\t\t      const Pkt *pkt,\n+\t\t\t\t      size_t *total_len)\n+{\n+\tstatic unsigned char zeroes[AES_BLOCK_SIZE-1];\n+\tstruct crypto_pkt *cpkt;\n+\tunsigned char *dout;\n+\tsize_t len, full_len;\n+\tint outlen;\n+\tstruct io_data *iod = peer->io_data;\n+\n+\tlen = pkt__get_packed_size(pkt);\n+\tfull_len = ROUNDUP(len, AES_BLOCK_SIZE);\n+\t*total_len = sizeof(*cpkt) + full_len;\n+\n+\tcpkt = (struct crypto_pkt *)tal_arr(peer, char, *total_len);\n+\tiod->out.totlen += len;\n+\tcpkt->totlen = cpu_to_le64(iod->out.totlen);\n+\t\n+\tdout = cpkt->data;\n+\t/* FIXME: Assumes we can encrypt in place! */\n+\tpkt__pack(pkt, dout);\n+\tEVP_EncryptUpdate(&iod->out.evpctx, dout, &outlen,\n+\t\t\t  memcheck(dout, len), len);\n+\tdout += outlen;\n+\n+\t/* Now encrypt tail, padding with zeroes if necessary. */\n+\tEVP_EncryptUpdate(&iod->out.evpctx, dout, &outlen, zeroes,\n+\t\t\t  full_len - len);\n+\tassert(dout + outlen == cpkt->data + full_len);\n+\n+\tHMAC(EVP_sha256(), iod->out.hmackey.k.u.u8, sizeof(iod->out.hmackey),\n+\t     (unsigned char *)&cpkt->totlen, sizeof(cpkt->totlen) + full_len,\n+\t     cpkt->hmac.u.u8, NULL);\n+\n+\treturn cpkt;\n+}\n+\n+static int do_read_packet(int fd, struct io_plan_arg *arg)\n+{\n+\tstruct peer *peer = arg->u1.vp;\n+\tstruct io_data *iod = peer->io_data;\n+\tu64 max;\n+\tsize_t data_off, data_len;\n+\tint ret;\n+\n+\t/* Still reading header? */\n+\tif (iod->len_in < sizeof(iod->hdr_in)) {\n+\t\tret = read(fd, (char *)&iod->hdr_in + iod->len_in,\n+\t\t\t   sizeof(iod->hdr_in) - iod->len_in);\n+\t\tif (ret <= 0)\n+\t\t\treturn -1;\n+\t\tiod->len_in += ret;\n+\t\t/* We don't ever send empty packets, so don't check for\n+\t\t * that here. */\n+\t\treturn 0;\n+\t}\n+\n+\tmax = ROUNDUP(le64_to_cpu(iod->hdr_in.totlen) - iod->in.totlen,\n+\t\t      AES_BLOCK_SIZE);\n+\n+\tif (iod->len_in == sizeof(iod->hdr_in)) {\n+\t\t/* FIXME: Handle re-xmit. */\n+\t\tif (le64_to_cpu(iod->hdr_in.totlen) < iod->in.totlen) {\n+\t\t\tlog_unusual(peer->log,\n+\t\t\t\t    \"Packet went backwards: %\"PRIu64\n+\t\t\t\t    \" -> %\"PRIu64,\n+\t\t\t\t    iod->in.totlen,\n+\t\t\t\t    le64_to_cpu(iod->hdr_in.totlen));\n+\t\t\treturn -1;\n+\t\t}\n+\t\tif (le64_to_cpu(iod->hdr_in.totlen)\n+\t\t    > iod->in.totlen + MAX_PKT_LEN) {\n+\t\t\tlog_unusual(peer->log,\n+\t\t\t\t    \"Packet overlength: %\"PRIu64\" -> %\"PRIu64,\n+\t\t\t\t    iod->in.totlen,\n+\t\t\t\t    le64_to_cpu(iod->hdr_in.totlen));\n+\t\t\treturn -1;\n+\t\t}\n+\t\tiod->in.cpkt = (struct crypto_pkt *)\n+\t\t\ttal_arr(iod, u8, sizeof(struct crypto_pkt) + max);\n+\t\tmemcpy(iod->in.cpkt, &iod->hdr_in, sizeof(iod->hdr_in));\n+\t}\n+\n+\tdata_off = iod->len_in - sizeof(struct crypto_pkt);\n+\tret = read(fd, iod->in.cpkt->data + data_off, max - data_off);\n+\tif (ret <= 0)\n+\t\treturn -1;\n+\n+\tiod->len_in += ret;\n+\tif (iod->len_in <= max)\n+\t\treturn 0;\n+\n+\t/* Can't overflow len arg: packet can't be more than MAX_PKT_LEN */\n+\tdata_len = le64_to_cpu(iod->hdr_in.totlen) - iod->in.totlen;\n+\tpeer->inpkt = decrypt_pkt(peer, iod->in.cpkt, data_len);\n+\tiod->in.cpkt = tal_free(iod->in.cpkt);\n+\n+\tif (!peer->inpkt)\n+\t\treturn -1;\n+\tiod->in.totlen += data_len;\n+\treturn 1;\n+}\n+\n+struct io_plan *peer_read_packet(struct io_conn *conn,\n+\t\t\t\t struct peer *peer,\n+\t\t\t\t struct io_plan *(*cb)(struct io_conn *,\n+\t\t\t\t\t\t       struct peer *))\n+{\n+\tstruct io_plan_arg *arg = io_plan_arg(conn, IO_IN);\n+\n+\tpeer->io_data->len_in = 0;\n+\targ->u1.vp = peer;\n+\treturn io_set_plan(conn, IO_IN, do_read_packet,\n+\t\t\t   (struct io_plan *(*)(struct io_conn *, void *))cb,\n+\t\t\t   peer);\n+}\n+\n+/* Caller must free data! */\n+struct io_plan *peer_write_packet(struct io_conn *conn,\n+\t\t\t\t  struct peer *peer,\n+\t\t\t\t  const Pkt *pkt,\n+\t\t\t\t  struct io_plan *(*next)(struct io_conn *,\n+\t\t\t\t\t\t\t  struct peer *))\n+{\n+\tstruct io_data *iod = peer->io_data;\n+\tsize_t totlen;\n+\n+\t/* We free previous packet here, rather than doing indirection\n+\t * via io_write */\n+\ttal_free(iod->out.cpkt);\n+\tiod->out.cpkt = encrypt_pkt(peer, pkt, &totlen);\n+\treturn io_write(conn, iod->out.cpkt, totlen, next, peer);\n+}\n+\n+static void *pkt_unwrap(struct peer *peer, Pkt__PktCase which)\n+{\n+\tsize_t i;\n+\tconst ProtobufCMessage *base;\n+\n+\tif (peer->inpkt->pkt_case != which) {\n+\t\tlog_unusual(peer->log, \"Expected %u, got %u\",\n+\t\t\t    which, peer->inpkt->pkt_case);\n+\t\treturn NULL;\n+\t}\n+\n+\t/* It's a union, and each member starts with base.  Pick one */\n+\tbase = &peer->inpkt->error->base;\n+\n+\t/* Look for unknown fields.  Remember, \"It's OK to be odd!\" */\n+\tfor (i = 0; i < base->n_unknown_fields; i++) {\n+\t\tlog_debug(peer->log, \"Unknown field in %u: %u\",\n+\t\t\t  which, base->unknown_fields[i].tag);\n+\t\t\t/* Odd is OK */\n+\t\t\tif (base->unknown_fields[i].tag & 1)\n+\t\t\t\tcontinue;\n+\t\t\tlog_unusual(peer->log, \"Unknown field %u in %u\",\n+\t\t\t\t    base->unknown_fields[i].tag, which);\n+\t\t\treturn NULL;\n+\t}\n+\treturn peer->inpkt->error;\n+}\n+\n+static struct io_plan *check_proof(struct io_conn *conn, struct peer *peer)\n+{\n+\tstruct key_negotiate *neg = peer->io_data->neg;\n+\tstruct sha256_double sha;\n+\tstruct signature sig;\n+\tstruct io_plan *(*cb)(struct io_conn *, struct peer *);\n+\tstruct pubkey id;\n+\tAuthenticate *auth;\n+\n+\tauth = pkt_unwrap(peer, PKT__PKT_AUTH);\n+\tif (!auth)\n+\t\treturn io_close(conn);\n+\n+\tif (!proto_to_signature(auth->session_sig, &sig)) {\n+\t\tlog_unusual(peer->log, \"Invalid auth signature\");\n+\t\treturn io_close(conn);\n+\t}\n+\n+\tif (!proto_to_pubkey(auth->node_id, &id)) {\n+\t\tlog_unusual(peer->log, \"Invalid auth id\");\n+\t\treturn io_close(conn);\n+\t}\n+\n+\t/* Signature covers *our* session key. */\n+\tsha256_double(&sha,\n+\t\t      neg->our_sessionpubkey, sizeof(neg->our_sessionpubkey));\n+\n+\tif (!check_signed_hash(&sha, &sig, &id)) {\n+\t\tlog_unusual(peer->log, \"Bad auth signature\");\n+\t\treturn io_close(conn);\n+\t}\n+\n+\ttal_free(auth);\n+\n+\t/* All complete, return to caller. */\n+\tcb = neg->cb;\n+\tpeer->io_data->neg = tal_free(neg);\n+\treturn cb(conn, peer);\n+}\n+\n+static struct io_plan *receive_proof(struct io_conn *conn, struct peer *peer)\n+{\n+\treturn peer_read_packet(conn, peer, check_proof);\n+}\n+\n+/* Steals w onto the returned Pkt */\n+static Pkt *pkt_wrap(const tal_t *ctx, void *w, Pkt__PktCase pkt_case)\n+{\n+\tPkt *pkt = tal(ctx, Pkt);\n+\tpkt__init(pkt);\n+\tpkt->pkt_case = pkt_case;\n+\t/* Union, so any will do */\n+\tpkt->error = tal_steal(pkt, w);\n+\treturn pkt;\n+}\n+\n+static Pkt *authenticate_pkt(const tal_t *ctx,\n+\t\t\t     const struct pubkey *node_id,\n+\t\t\t     const struct signature *sig)\n+{\n+\tAuthenticate *auth = tal(ctx, Authenticate);\n+\tauthenticate__init(auth);\n+\tauth->node_id = pubkey_to_proto(auth, node_id);\n+\tauth->session_sig = signature_to_proto(auth, sig);\n+\treturn pkt_wrap(ctx, auth, PKT__PKT_AUTH);\n+}\n+\n+static struct io_plan *keys_exchanged(struct io_conn *conn, struct peer *peer)\n+{\n+\tu8 shared_secret[32];\n+\tstruct pubkey sessionkey;\n+\tstruct signature sig;\n+\tstruct key_negotiate *neg = peer->io_data->neg;\n+\tPkt *auth;\n+\n+\tif (!pubkey_from_der(neg->their_sessionpubkey,\n+\t\t\t     sizeof(neg->their_sessionpubkey),\n+\t\t\t     &sessionkey)) {\n+\t\t/* FIXME: Dump key in this case. */\n+\t\tlog_unusual(peer->log, \"Bad sessionkey\");\n+\t\treturn io_close(conn);\n+\t}\n+\n+\t/* Derive shared secret. */\n+\tif (!secp256k1_ecdh(peer->state->secpctx, shared_secret,\n+\t\t\t    &sessionkey.pubkey, neg->seckey)) {\n+\t\tlog_unusual(peer->log, \"Bad ECDH\");\n+\t\treturn io_close(conn);\n+\t}\n+\n+\t/* Each side combines with their OWN session key to SENDING crypto. */\n+\tif (!setup_crypto(&peer->io_data->in, shared_secret,\n+\t\t\t  neg->their_sessionpubkey)\n+\t    || !setup_crypto(&peer->io_data->out, shared_secret,\n+\t\t\t     neg->our_sessionpubkey)) {\n+\t\tlog_unusual(peer->log, \"Failed setup_crypto()\");\n+\t\treturn io_close(conn);\n+\t}\n+\n+\t/* Now sign their session key to prove who we are. */\n+\tprivkey_sign(peer, neg->their_sessionpubkey,\n+\t\t     sizeof(neg->their_sessionpubkey), &sig);\n+\n+\t/* FIXME: Free auth afterwards. */\n+\tauth = authenticate_pkt(peer, &peer->state->id, &sig);\n+\treturn peer_write_packet(conn, peer, auth, receive_proof);\n+}\n+\n+static struct io_plan *session_key_receive(struct io_conn *conn,\n+\t\t\t\t\t   struct peer *peer)\n+{\n+\tstruct key_negotiate *neg = peer->io_data->neg;\n+\t/* Now read their key. */\n+\treturn io_read(conn, neg->their_sessionpubkey,\n+\t\t       sizeof(neg->their_sessionpubkey), keys_exchanged, peer);\n+}\n+\n+static void gen_sessionkey(secp256k1_context *ctx,\n+\t\t\t   u8 seckey[32],\n+\t\t\t   secp256k1_pubkey *pubkey)\n+{\n+\tdo {\n+\t\tif (RAND_bytes(seckey, 32) != 1)\n+\t\t\tfatal(\"Could not get random bytes for sessionkey\");\n+\t} while (!secp256k1_ec_pubkey_create(ctx, pubkey, seckey));\n+}\n+\n+struct io_plan *peer_crypto_setup(struct io_conn *conn, struct peer *peer,\n+\t\t\t\t  struct io_plan *(*cb)(struct io_conn *,\n+\t\t\t\t\t\t\tstruct peer *))\n+{\n+\tsize_t outputlen;\n+\tsecp256k1_pubkey sessionkey;\n+\tstruct key_negotiate *neg;\n+\n+\tpeer->io_data = tal(peer, struct io_data);\n+\n+\t/* We store negotiation state here. */\n+\tneg = peer->io_data->neg = tal(peer->io_data, struct key_negotiate);\n+\tneg->cb = cb;\n+\n+\tgen_sessionkey(peer->state->secpctx, neg->seckey, &sessionkey);\n+\n+\tsecp256k1_ec_pubkey_serialize(peer->state->secpctx,\n+\t\t\t\t      neg->our_sessionpubkey, &outputlen,\n+\t\t\t\t      &sessionkey,\n+\t\t\t\t      SECP256K1_EC_COMPRESSED);\n+\tassert(outputlen == sizeof(neg->our_sessionpubkey));\n+\treturn io_write(conn, neg->our_sessionpubkey, outputlen,\n+\t\t\tsession_key_receive, peer);\n+}\ndiff --git a/daemon/cryptopkt.h b/daemon/cryptopkt.h\nnew file mode 100644\nindex 0000000..06c6167\n--- /dev/null\n+++ b/daemon/cryptopkt.h\n@@ -0,0 +1,26 @@\n+#ifndef LIGHTNING_DAEMON_CRYPTOPKT_H\n+#define LIGHTNING_DAEMON_CRYPTOPKT_H\n+#include \"config.h\"\n+#include \"lightning.pb-c.h\"\n+#include <ccan/io/io.h>\n+\n+struct peer;\n+\n+struct io_plan *peer_crypto_setup(struct io_conn *conn,\n+\t\t\t\t  struct peer *peer,\n+\t\t\t\t  struct io_plan *(*cb)(struct io_conn *,\n+\t\t\t\t\t\t\tstruct peer *));\n+\n+/* Reads packet into peer->inpkt/peer->inpkt_len */\n+struct io_plan *peer_read_packet(struct io_conn *conn,\n+\t\t\t\t struct peer *peer,\n+\t\t\t\t struct io_plan *(*cb)(struct io_conn *,\n+\t\t\t\t\t\t       struct peer *));\n+\n+struct io_plan *peer_write_packet(struct io_conn *conn,\n+\t\t\t\t  struct peer *peer,\n+\t\t\t\t  const Pkt *pkt,\n+\t\t\t\t  struct io_plan *(*next)(struct io_conn *,\n+\t\t\t\t\t\t\t  struct peer *));\n+\n+#endif /* LIGHTNING_DAEMON_CRYPTOPKT_H */\ndiff --git a/daemon/peer.c b/daemon/peer.c\nindex 5f578ee..ed4fcda 100644\n--- a/daemon/peer.c\n+++ b/daemon/peer.c\n@@ -1,3 +1,4 @@\n+#include \"cryptopkt.h\"\n #include \"dns.h\"\n #include \"jsonrpc.h\"\n #include \"lightningd.h\"\n@@ -14,6 +15,33 @@\n #include <sys/socket.h>\n #include <sys/types.h>\n \n+/* Send and receive (encrypted) hello message. */\n+static struct io_plan *peer_test_check(struct io_conn *conn, struct peer *peer)\n+{\n+\tif (peer->inpkt->pkt_case != PKT__PKT_ERROR)\n+\t\tfatal(\"Bad packet type %u\", peer->inpkt->pkt_case);\n+\tif (!peer->inpkt->error->problem\n+\t    || strcmp(peer->inpkt->error->problem, \"hello\") != 0)\n+\t\tfatal(\"Bad packet '%.6s'\", peer->inpkt->error->problem);\n+\tlog_info(peer->log, \"Successful hello!\");\n+\treturn io_close(conn);\n+}\n+\n+static struct io_plan *peer_test_read(struct io_conn *conn, struct peer *peer)\n+{\n+\treturn peer_read_packet(conn, peer, peer_test_check);\n+}\n+\n+static struct io_plan *peer_test(struct io_conn *conn, struct peer *peer)\n+{\n+\tError err = ERROR__INIT;\n+\tPkt pkt = PKT__INIT;\n+\tpkt.pkt_case = PKT__PKT_ERROR;\n+\tpkt.error = &err;\n+\terr.problem = \"hello\";\n+\treturn peer_write_packet(conn, peer, &pkt, peer_test_read);\n+}\n+\n static void destroy_peer(struct peer *peer)\n {\n \tlist_del_from(&peer->state->peers, &peer->list);\n@@ -32,6 +60,7 @@ static struct peer *new_peer(struct lightningd_state *state,\n \tpeer->state = state;\n \tpeer->addr.type = addr_type;\n \tpeer->addr.protocol = addr_protocol;\n+\tpeer->io_data = NULL;\n \n \t/* FIXME: Attach IO logging for this peer. */\n \ttal_add_destructor(peer, destroy_peer);\n@@ -63,7 +92,7 @@ struct io_plan *peer_connected_out(struct io_conn *conn,\n \t\treturn io_close(conn);\n \t}\n \tlog_info(peer->log, \"Connected out to %s:%s\", name, port);\n-\treturn io_write(conn, \"Hello!\", 6, io_close_cb, NULL);\n+\treturn peer_crypto_setup(conn, peer, peer_test);\n }\n \n static struct io_plan *peer_connected_in(struct io_conn *conn,\n@@ -73,8 +102,9 @@ static struct io_plan *peer_connected_in(struct io_conn *conn,\n \t\t\t\t     \"in\");\n \tif (!peer)\n \t\treturn io_close(conn);\n-\t\n-\treturn io_write(conn, \"Hello!\", 6, io_close_cb, NULL);\n+\n+\tlog_info(peer->log, \"Peer connected in\");\n+\treturn peer_crypto_setup(conn, peer, peer_test);\n }\n \n static int make_listen_fd(struct lightningd_state *state,\ndiff --git a/daemon/peer.h b/daemon/peer.h\nindex 50cea69..c39f943 100644\n--- a/daemon/peer.h\n+++ b/daemon/peer.h\n@@ -1,6 +1,7 @@\n #ifndef LIGHTNING_DAEMON_PEER_H\n #define LIGHTNING_DAEMON_PEER_H\n #include \"config.h\"\n+#include \"lightning.pb-c.h\"\n #include \"netaddr.h\"\n #include <ccan/list/list.h>\n \n@@ -14,6 +15,12 @@ struct peer {\n \t/* The other end's address. */\n \tstruct netaddr addr;\n \n+\t/* Current received packet. */\n+\tPkt *inpkt;\n+\t\n+\t/* Current ongoing packetflow */\n+\tstruct io_data *io_data;\n+\t\n \t/* What happened. */\n \tstruct log *log;\n };\ndiff --git a/lightning.pb-c.c b/lightning.pb-c.c\nindex 5dde94f..62777aa 100644\n--- a/lightning.pb-c.c\n+++ b/lightning.pb-c.c\n@@ -222,6 +222,49 @@ void   funding__free_unpacked\n   assert(message->base.descriptor == &funding__descriptor);\n   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n }\n+void   authenticate__init\n+                     (Authenticate         *message)\n+{\n+  static Authenticate init_value = AUTHENTICATE__INIT;\n+  *message = init_value;\n+}\n+size_t authenticate__get_packed_size\n+                     (const Authenticate *message)\n+{\n+  assert(message->base.descriptor == &authenticate__descriptor);\n+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));\n+}\n+size_t authenticate__pack\n+                     (const Authenticate *message,\n+                      uint8_t       *out)\n+{\n+  assert(message->base.descriptor == &authenticate__descriptor);\n+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);\n+}\n+size_t authenticate__pack_to_buffer\n+                     (const Authenticate *message,\n+                      ProtobufCBuffer *buffer)\n+{\n+  assert(message->base.descriptor == &authenticate__descriptor);\n+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);\n+}\n+Authenticate *\n+       authenticate__unpack\n+                     (ProtobufCAllocator  *allocator,\n+                      size_t               len,\n+                      const uint8_t       *data)\n+{\n+  return (Authenticate *)\n+     protobuf_c_message_unpack (&authenticate__descriptor,\n+                                allocator, len, data);\n+}\n+void   authenticate__free_unpacked\n+                     (Authenticate *message,\n+                      ProtobufCAllocator *allocator)\n+{\n+  assert(message->base.descriptor == &authenticate__descriptor);\n+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n+}\n void   open_channel__init\n                      (OpenChannel         *message)\n {\n@@ -1344,6 +1387,57 @@ const ProtobufCMessageDescriptor funding__descriptor =\n   (ProtobufCMessageInit) funding__init,\n   NULL,NULL,NULL    /* reserved[123] */\n };\n+static const ProtobufCFieldDescriptor authenticate__field_descriptors[2] =\n+{\n+  {\n+    \"node_id\",\n+    1,\n+    PROTOBUF_C_LABEL_REQUIRED,\n+    PROTOBUF_C_TYPE_MESSAGE,\n+    0,   /* quantifier_offset */\n+    offsetof(Authenticate, node_id),\n+    &bitcoin_pubkey__descriptor,\n+    NULL,\n+    0,             /* flags */\n+    0,NULL,NULL    /* reserved1,reserved2, etc */\n+  },\n+  {\n+    \"session_sig\",\n+    2,\n+    PROTOBUF_C_LABEL_REQUIRED,\n+    PROTOBUF_C_TYPE_MESSAGE,\n+    0,   /* quantifier_offset */\n+    offsetof(Authenticate, session_sig),\n+    &signature__descriptor,\n+    NULL,\n+    0,             /* flags */\n+    0,NULL,NULL    /* reserved1,reserved2, etc */\n+  },\n+};\n+static const unsigned authenticate__field_indices_by_name[] = {\n+  0,   /* field[0] = node_id */\n+  1,   /* field[1] = session_sig */\n+};\n+static const ProtobufCIntRange authenticate__number_ranges[1 + 1] =\n+{\n+  { 1, 0 },\n+  { 0, 2 }\n+};\n+const ProtobufCMessageDescriptor authenticate__descriptor =\n+{\n+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n+  \"authenticate\",\n+  \"Authenticate\",\n+  \"Authenticate\",\n+  \"\",\n+  sizeof(Authenticate),\n+  2,\n+  authenticate__field_descriptors,\n+  authenticate__field_indices_by_name,\n+  1,  authenticate__number_ranges,\n+  (ProtobufCMessageInit) authenticate__init,\n+  NULL,NULL,NULL    /* reserved[123] */\n+};\n static const ProtobufCEnumValue open_channel__anchor_offer__enum_values_by_number[2] =\n {\n   { \"WILL_CREATE_ANCHOR\", \"OPEN_CHANNEL__ANCHOR_OFFER__WILL_CREATE_ANCHOR\", 1 },\n@@ -2259,7 +2353,7 @@ const ProtobufCMessageDescriptor error__descriptor =\n   (ProtobufCMessageInit) error__init,\n   NULL,NULL,NULL    /* reserved[123] */\n };\n-static const ProtobufCFieldDescriptor pkt__field_descriptors[17] =\n+static const ProtobufCFieldDescriptor pkt__field_descriptors[18] =\n {\n   {\n     \"update\",\n@@ -2465,8 +2559,21 @@ static const ProtobufCFieldDescriptor pkt__field_descriptors[17] =\n     0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n     0,NULL,NULL    /* reserved1,reserved2, etc */\n   },\n+  {\n+    \"auth\",\n+    50,\n+    PROTOBUF_C_LABEL_OPTIONAL,\n+    PROTOBUF_C_TYPE_MESSAGE,\n+    offsetof(Pkt, pkt_case),\n+    offsetof(Pkt, auth),\n+    &authenticate__descriptor,\n+    NULL,\n+    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */\n+    0,NULL,NULL    /* reserved1,reserved2, etc */\n+  },\n };\n static const unsigned pkt__field_indices_by_name[] = {\n+  17,   /* field[17] = auth */\n   13,   /* field[13] = close */\n   15,   /* field[15] = close_ack */\n   14,   /* field[14] = close_complete */\n@@ -2485,13 +2592,14 @@ static const unsigned pkt__field_indices_by_name[] = {\n   3,   /* field[3] = update_signature */\n   7,   /* field[7] = update_timedout_htlc */\n };\n-static const ProtobufCIntRange pkt__number_ranges[4 + 1] =\n+static const ProtobufCIntRange pkt__number_ranges[5 + 1] =\n {\n   { 1, 0 },\n   { 20, 9 },\n   { 30, 13 },\n   { 40, 16 },\n-  { 0, 17 }\n+  { 50, 17 },\n+  { 0, 18 }\n };\n const ProtobufCMessageDescriptor pkt__descriptor =\n {\n@@ -2501,10 +2609,10 @@ const ProtobufCMessageDescriptor pkt__descriptor =\n   \"Pkt\",\n   \"\",\n   sizeof(Pkt),\n-  17,\n+  18,\n   pkt__field_descriptors,\n   pkt__field_indices_by_name,\n-  4,  pkt__number_ranges,\n+  5,  pkt__number_ranges,\n   (ProtobufCMessageInit) pkt__init,\n   NULL,NULL,NULL    /* reserved[123] */\n };\ndiff --git a/lightning.pb-c.h b/lightning.pb-c.h\nindex 26219cc..4178a1e 100644\n--- a/lightning.pb-c.h\n+++ b/lightning.pb-c.h\n@@ -20,6 +20,7 @@ typedef struct _Signature Signature;\n typedef struct _Locktime Locktime;\n typedef struct _BitcoinPubkey BitcoinPubkey;\n typedef struct _Funding Funding;\n+typedef struct _Authenticate Authenticate;\n typedef struct _OpenChannel OpenChannel;\n typedef struct _OpenAnchor OpenAnchor;\n typedef struct _OpenCommitSig OpenCommitSig;\n@@ -150,6 +151,26 @@ struct  _Funding\n /*\n  * Set channel params.\n  */\n+struct  _Authenticate\n+{\n+  ProtobufCMessage base;\n+  /*\n+   * Which node this is.\n+   */\n+  BitcoinPubkey *node_id;\n+  /*\n+   * Signature of your session key. * \n+   */\n+  Signature *session_sig;\n+};\n+#define AUTHENTICATE__INIT \\\n+ { PROTOBUF_C_MESSAGE_INIT (&authenticate__descriptor) \\\n+    , NULL, NULL }\n+\n+\n+/*\n+ * Set channel params.\n+ */\n struct  _OpenChannel\n {\n   ProtobufCMessage base;\n@@ -500,6 +521,7 @@ struct  _Error\n \n typedef enum {\n   PKT__PKT__NOT_SET = 0,\n+  PKT__PKT_AUTH = 50,\n   PKT__PKT_OPEN = 20,\n   PKT__PKT_OPEN_ANCHOR = 21,\n   PKT__PKT_OPEN_COMMIT_SIG = 22,\n@@ -528,6 +550,10 @@ struct  _Pkt\n   Pkt__PktCase pkt_case;\n   union {\n     /*\n+     * Start of connection\n+     */\n+    Authenticate *auth;\n+    /*\n      * Opening\n      */\n     OpenChannel *open;\n@@ -658,6 +684,25 @@ Funding *\n void   funding__free_unpacked\n                      (Funding *message,\n                       ProtobufCAllocator *allocator);\n+/* Authenticate methods */\n+void   authenticate__init\n+                     (Authenticate         *message);\n+size_t authenticate__get_packed_size\n+                     (const Authenticate   *message);\n+size_t authenticate__pack\n+                     (const Authenticate   *message,\n+                      uint8_t             *out);\n+size_t authenticate__pack_to_buffer\n+                     (const Authenticate   *message,\n+                      ProtobufCBuffer     *buffer);\n+Authenticate *\n+       authenticate__unpack\n+                     (ProtobufCAllocator  *allocator,\n+                      size_t               len,\n+                      const uint8_t       *data);\n+void   authenticate__free_unpacked\n+                     (Authenticate *message,\n+                      ProtobufCAllocator *allocator);\n /* OpenChannel methods */\n void   open_channel__init\n                      (OpenChannel         *message);\n@@ -1017,6 +1062,9 @@ typedef void (*BitcoinPubkey_Closure)\n typedef void (*Funding_Closure)\n                  (const Funding *message,\n                   void *closure_data);\n+typedef void (*Authenticate_Closure)\n+                 (const Authenticate *message,\n+                  void *closure_data);\n typedef void (*OpenChannel_Closure)\n                  (const OpenChannel *message,\n                   void *closure_data);\n@@ -1082,6 +1130,7 @@ extern const ProtobufCMessageDescriptor signature__descriptor;\n extern const ProtobufCMessageDescriptor locktime__descriptor;\n extern const ProtobufCMessageDescriptor bitcoin_pubkey__descriptor;\n extern const ProtobufCMessageDescriptor funding__descriptor;\n+extern const ProtobufCMessageDescriptor authenticate__descriptor;\n extern const ProtobufCMessageDescriptor open_channel__descriptor;\n extern const ProtobufCEnumDescriptor    open_channel__anchor_offer__descriptor;\n extern const ProtobufCMessageDescriptor open_anchor__descriptor;\ndiff --git a/lightning.proto b/lightning.proto\nindex 5f0eb03..0c1fcdd 100644\n--- a/lightning.proto\n+++ b/lightning.proto\n@@ -52,6 +52,14 @@ message funding {\n //\n \n // Set channel params.\n+message authenticate {\n+  // Which node this is.\n+  required bitcoin_pubkey node_id = 1;\n+  // Signature of your session key. */\n+  required signature session_sig = 2;\n+};\n+\n+// Set channel params.\n message open_channel {\n   // Relative locktime for outputs going to us.\n   required locktime delay = 1;\n@@ -205,6 +213,8 @@ message error {\n // This is the union which defines all of them\n message pkt {\n   oneof pkt {\n+    // Start of connection\n+    authenticate auth = 50;\n     // Opening\n     open_channel open = 20;\n     open_anchor open_anchor = 21;"
            },
            {
                "author": "Pierre",
                "date": "2015-10-27T10:34:44",
                "message_text_only": "Hi Rusty,\n\n> 5) Unknown protobuf fields are handled in the protocol as follows\n>    (including in the initial Authenticate packet):\n>\n>    1) Odd numbered fields are optional, and backwards compatible.\n>    2) Even numbered fields are required; abort if you get one.\n\nI don't get it, what is it about ?\n\nThanks,\n\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-27T19:41:20",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hi Rusty,\n>\n>> 5) Unknown protobuf fields are handled in the protocol as follows\n>>    (including in the initial Authenticate packet):\n>>\n>>    1) Odd numbered fields are optional, and backwards compatible.\n>>    2) Even numbered fields are required; abort if you get one.\n>\n> I don't get it, what is it about ?\n\nYes, I really need to write this up in Matsjj's lightning-core docs\nrepository.\n\nSince protobuf fields are explicitly numbered, we can use this to\ndeliberately break backwards compatibility in future after some\ntransition.\n\nFor example, if we want to add a \"currency identifier\" field in HTLC,\nfor non-bitcoin transactions.  That would be an even numbered field,\nsince you need to understand it.  (There would also need to be some way\nto indicate you support those, during connection setup or something).\n\nBut if we want to add an optional new field, we'd make it odd, and\nexisting implementations could ignore it.\n\nCheers,\nRusty."
            },
            {
                "author": "Peter Todd",
                "date": "2015-10-27T20:40:47",
                "message_text_only": "On Wed, Oct 28, 2015 at 06:11:20AM +1030, Rusty Russell wrote:\n> Pierre <pm+lists at acinq.fr> writes:\n> > Hi Rusty,\n> >\n> >> 5) Unknown protobuf fields are handled in the protocol as follows\n> >>    (including in the initial Authenticate packet):\n> >>\n> >>    1) Odd numbered fields are optional, and backwards compatible.\n> >>    2) Even numbered fields are required; abort if you get one.\n> >\n> > I don't get it, what is it about ?\n> \n> Yes, I really need to write this up in Matsjj's lightning-core docs\n> repository.\n> \n> Since protobuf fields are explicitly numbered, we can use this to\n> deliberately break backwards compatibility in future after some\n> transition.\n> \n> For example, if we want to add a \"currency identifier\" field in HTLC,\n> for non-bitcoin transactions.  That would be an even numbered field,\n> since you need to understand it.  (There would also need to be some way\n> to indicate you support those, during connection setup or something).\n> \n> But if we want to add an optional new field, we'd make it odd, and\n> existing implementations could ignore it.\n\nFWIW an analogous idea is OpenPGP's \"critical bit\" for packets, which\nindicates that if the software doesn't understand the packet it should\nconsider the signature to be invalid:\n\nhttps://tools.ietf.org/html/rfc4880#section-5.2.3.1\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000000b3f41bf1f2b9c5547bbdaa1ab40c914ab26faf764ff16a5\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 650 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151027/1b0bc972/attachment.sig>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-28T00:32:18",
                "message_text_only": "Peter Todd <pete at petertodd.org> writes:\n> On Wed, Oct 28, 2015 at 06:11:20AM +1030, Rusty Russell wrote:\n>> Pierre <pm+lists at acinq.fr> writes:\n>> > Hi Rusty,\n>> >\n>> >> 5) Unknown protobuf fields are handled in the protocol as follows\n>> >>    (including in the initial Authenticate packet):\n>> >>\n>> >>    1) Odd numbered fields are optional, and backwards compatible.\n>> >>    2) Even numbered fields are required; abort if you get one.\n>> >\n>> > I don't get it, what is it about ?\n>> \n>> Yes, I really need to write this up in Matsjj's lightning-core docs\n>> repository.\n>> \n>> Since protobuf fields are explicitly numbered, we can use this to\n>> deliberately break backwards compatibility in future after some\n>> transition.\n>> \n>> For example, if we want to add a \"currency identifier\" field in HTLC,\n>> for non-bitcoin transactions.  That would be an even numbered field,\n>> since you need to understand it.  (There would also need to be some way\n>> to indicate you support those, during connection setup or something).\n>> \n>> But if we want to add an optional new field, we'd make it odd, and\n>> existing implementations could ignore it.\n>\n> FWIW an analogous idea is OpenPGP's \"critical bit\" for packets, which\n> indicates that if the software doesn't understand the packet it should\n> consider the signature to be invalid:\n>\n> https://tools.ietf.org/html/rfc4880#section-5.2.3.1\n\nYes, it's a pretty simple idea.  In lightning, you should probably never\nsend an implementation a packet it won't understand (after the initial\nhandshake stage), but it still serves as belt-and-braces check.\n\neg. if we want to introduce a field with the intent to eventually make\nit optional, we would add it as *two* optional fields, say 11 and 12.\nYou could set one or the other, not both, but accept either.  In a few\nyears' time, implementations would stop using 11.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-28T02:17:20",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n> eg. if we want to introduce a field with the intent to eventually make\n> it optional, we would add it as *two* optional fields, say 11 and 12.\n\nI mean, \"eventually make it compulsory\"...\n\nThanks AJ,\nRusty."
            },
            {
                "author": "Pierre",
                "date": "2015-10-27T17:00:24",
                "message_text_only": "A few more remarks:\n\n> 2) ECDH is used to derive a shared secret.  From this we generate\n>    the following transmission encoding parameters for each side:\n>    Session AES-128 key: SHA256(shared-secret || my-sessionpubkey || 0)\n>    Session HMAC key: SHA256(shared-secret || my-sessionpubkey || 1)\n>    IV for AES: SHA256(shared-secret || my-sessionpubkey || 2)\nI suppose we use only the first 16 bytes for aes_key and aes_iv ?\n\n> 3) All packets from then on are encrypted of form:\n>         /* HMAC, covering totlen and data */\n>         struct sha256 hmac;\n>         /* Total data transmitted (including this). */\n>         le64 totlen;\n>         /* Encrypted contents, rounded up to 16 byte boundary. */\n>         u8 data[];\nLooking at your code it seems totlen is actually the size of the\nunencrypted serialized protobuf message, not the total data\ntransmitted right ? If so, the comment is a bit misleading, and why\nmake totlen include the length of itself since it doesn't define the\nencrypted message boundaries anyway ?\nAlso, why encode the length on 64 bits rather than 32 bits ?\n\nCheers,\n\nPierre"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-27T18:01:32",
                "message_text_only": ">> 3) All packets from then on are encrypted of form:\n>>         /* HMAC, covering totlen and data */\n>>         struct sha256 hmac;\n>>         /* Total data transmitted (including this). */\n>>         le64 totlen;\n>>         /* Encrypted contents, rounded up to 16 byte boundary. */\n>>         u8 data[];\n> Looking at your code it seems totlen is actually the size of the\n> unencrypted serialized protobuf message, not the total data\n> transmitted right ? If so, the comment is a bit misleading, and why\n> make totlen include the length of itself since it doesn't define the\n> encrypted message boundaries anyway ?\n> Also, why encode the length on 64 bits rather than 32 bits ?\n\nActually I think we do not need this field. Initially, the idea was to\nprovide replay protection. You keep track of totlen locally, and\ncompare it with the value the other party sends to you.\n\nHowever, as we are using AES-CTR, we do not need to do that. We have a\ndedicated counter in the IV that does keep track of all messages in\neach direction respectively. If some attacker tries to replay the same\nmessage towards us, we are unable to decrypt it, as the IV is not\ncorrect (as it is assuming a different counter)"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-27T19:48:52",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n>>> 3) All packets from then on are encrypted of form:\n>>>         /* HMAC, covering totlen and data */\n>>>         struct sha256 hmac;\n>>>         /* Total data transmitted (including this). */\n>>>         le64 totlen;\n>>>         /* Encrypted contents, rounded up to 16 byte boundary. */\n>>>         u8 data[];\n>> Looking at your code it seems totlen is actually the size of the\n>> unencrypted serialized protobuf message, not the total data\n>> transmitted right ? If so, the comment is a bit misleading, and why\n>> make totlen include the length of itself since it doesn't define the\n>> encrypted message boundaries anyway ?\n>> Also, why encode the length on 64 bits rather than 32 bits ?\n>\n> Actually I think we do not need this field. Initially, the idea was to\n> provide replay protection. You keep track of totlen locally, and\n> compare it with the value the other party sends to you.\n>\n> However, as we are using AES-CTR, we do not need to do that. We have a\n> dedicated counter in the IV that does keep track of all messages in\n> each direction respectively. If some attacker tries to replay the same\n> message towards us, we are unable to decrypt it, as the IV is not\n> correct (as it is assuming a different counter)\n\nThis is true.  However, the protocol actually requires some replay, for\nrobustness when a node crashes (I think the worst case is 5 packets).\nThere's a FIXME in the current code for this case.\n\nIt's certainly overkill, but I thought combining counter and length was\nkinda cute...\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-27T19:44:07",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> A few more remarks:\n>\n>> 2) ECDH is used to derive a shared secret.  From this we generate\n>>    the following transmission encoding parameters for each side:\n>>    Session AES-128 key: SHA256(shared-secret || my-sessionpubkey || 0)\n>>    Session HMAC key: SHA256(shared-secret || my-sessionpubkey || 1)\n>>    IV for AES: SHA256(shared-secret || my-sessionpubkey || 2)\n> I suppose we use only the first 16 bytes for aes_key and aes_iv ?\n\nYes, indeed...\n\n>> 3) All packets from then on are encrypted of form:\n>>         /* HMAC, covering totlen and data */\n>>         struct sha256 hmac;\n>>         /* Total data transmitted (including this). */\n>>         le64 totlen;\n>>         /* Encrypted contents, rounded up to 16 byte boundary. */\n>>         u8 data[];\n\n> Looking at your code it seems totlen is actually the size of the\n> unencrypted serialized protobuf message, not the total data\n> transmitted right ?\n\nYeah, bad wording.  \"data\" here doesn't count the header, just\nthe contents.\n\n> If so, the comment is a bit misleading, and why\n> make totlen include the length of itself since it doesn't define the\n> encrypted message boundaries anyway ?\n\nWe need to know how much padding to ignore.\n\n> Also, why encode the length on 64 bits rather than 32 bits ?\n\nSo it never wraps.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "daemon: encrypted communication (version 3)",
            "categories": [
                "Lightning-dev",
                "PATCH v3"
            ],
            "authors": [
                "Rusty Russell",
                "Peter Todd",
                "Mats Jerratsch",
                "Pierre"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 40018
        }
    },
    {
        "title": "[Lightning-dev] GitHub Repository for Detailed Specifications of Lightning Nodes",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-10-26T17:12:18",
                "message_text_only": "Hey everybody,\n\nI created a new OSS-organisation on GitHub lightning-core and opened a\nnew repository dedicated to hold the specifications of any lightning\nnode.\n\nhttps://github.com/lightning-core/lightning\n\nThis has several positive effects:\n\n(1)\nI am positive this will help to ensure we all build somewhat\ncompatible software. As we all only come together every once and again\non IRC (and rarely on the mailing list), we end up building the same\nthings in parallel that are not compatible at the end of the day.\nWhile it is great to have implementations in different languages for\ndifferent systems, would be even better if they end up being one large\nnetwork at the end of the day.\n\n(2)\nIt is in general a good idea to have the product specifications and\nimplementations in separate repositories. This way we have the\ncontract each implementation has to abide separate and clear in view.\n\n(3)\nIt is easier to work towards different targets that may seem out of\nreach right now, but still have them structurally on the same\nrepository. If some guy decides to work on an implementation on some\nadvanced topic, he will have a difficult time getting it across on the\nmailing list. I think a github repo is a much better place to share\nthese ideas.\n\n(4)\nAnyone doing a complete new implementation does not have to search\nacross different implementations and mailing list posts to find\nanswers how his software should behave to communicate with the\nnetwork. The specification will be a great guideline for new\nimplementations\n\n\nAs I just started it, practically everything is still missing. I\nstarted writing together the current implementation on the encryption\nlayer, but even there I noticed how much of it I have to scramble\ntogether from different sources.\n\nFeel free to fork and write up, we can always discuss the status quo\nbefore pushing it to master. The skeleton is missing a lot too, but we\nhave to start at some point...\n\nCheers\nMats"
            }
        ],
        "thread_summary": {
            "title": "GitHub Repository for Detailed Specifications of Lightning Nodes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Mats Jerratsch"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1944
        }
    },
    {
        "title": "[Lightning-dev] Lightning fees vs miner fees",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-10-27T05:40:29",
                "message_text_only": "Hi all,\n\nA question that's been raised a few times in various places [0] is what\nthe impact of a fully armed and operational lightning network on miners\nfees will be -- lightning depends on the security of the blockchain to\nbe functional, but the blockchain will eventually rely on transaction\nfees to be secure, so lightning had better leave sufficient transactions\nfor the blockchain!\n\nA trivial answer to this is \"market forces will work it out\" -- too many\nlightning transactions reduces security, reduces lightning transactions,\nso it will presumably stabilise at something sane, and everyone lives\nhappily every after.\n\nBut I think it's actually a tractable question, so we can probably\nactually work out numbers!\n\nBasic assumptions:\n\n 1. devs/miners limit the number of transactions per block\n 2. miners choose the transactions that pay the highest fees to fill\n    blocks\n 3. bitcoin watch what miners accept, and all settle on the smallest\n    per-transaction fee that will get them included in a block\n 4. some people would like to use bitcoin, but are priced out because\n    there are cheaper alternatives at the given per-transaction fee.\n    eg at 8c/tx, it might be cheaper to send 50c by paypal (at 5c+5%)\n    than the blockchain; whereas at 7c/tx bitcoin would be preferred.\n\nIf blocks were unlimited, miners would accept every transaction, no\nmatter how small the fee (2), which would set the per-tx fee to ~1\nsatoshi (3). Rational miners will thus limit the number of txs they\naccept (1) to ensure fees don't go to zero.\n\nMarket assumptions:\n\n 5. the only thing preventing bitcoin from replacing credit card\n    transactions at point of sale is (a) adoption of bitcoin, and (b)\n    the transaction fees -- ie, if Visa/Mastercard is cheaper, people\n    will keep using it.\n 6. Visa does around $7e12 (7 trillion) in volume per year in the US;\n    and about 60e9 (60 billion) transactions [1]; on average that's 1900\n    tx/s, and about $117 per transaction.\n 7. The micropayments market is very small by comparison, with only\n    $1e10 (10 billion) in volume per year, counting anything under $12\n    as a \"micropayment\".\n 8. Imagine payments are distributed in a log-normal distribution,\n    then we can use the figures from (6) and (7) to get parameters\n    median=exp(mu)=77.669, sigma=0.9021.\n 9. Visa charges about 20c+2% per transaction\n10. Lightning will charge 1% for a full transaction (eg, 8 hops,\n    0.125% per hop)\n\nBasic conclusions:\n\n A. First thing to note is that of the three alternatives, ie, Visa,\n    lightning and blockchain; that Visa and lightning get more expensive\n    as the transaction amount increases, but bitcoin doesn't.\n    Additionally, lightning is (by assumption) always chepaer than Visa.\n\n B. Without lightning, then, the highest value N transactions will go\n    via the blockchain filling it up, at a fee equal to about 20c+2%\n    of the smallest transaction. (If the fee were any lower, smaller\n    transactions would be eligible for the blockchain, and higher value\n    transactions would bid higher fees to ensure they were included first)\n    So if the fee turned out to be 40c, transactions above $10 would be\n    in the blockchain, and smaller than that would be via Visa.\n\n C. Without lightning, as bitcoin adoption increases, either fees rise,\n    or number of transactions per block increases proportionally. If\n    1% of people know about bitcoin, and use it whenever it's cheap;\n    then 2% of people knowing about bitcoin gives twice as many\n    transactions at any given price level. If blocks accepted 2000 txs,\n    and there were 1000 $20 tx/block and 1000 $10 tx/block, then\n    doubling adoption either means having 2000 $20 tx/block and a new\n    fee of about 60c (versus 40c), or doubling the block size and\n    keeping the fee.\n\n D. Without lightning, fees increase rapidly with adoption: there are\n    1900 tx/s on Visa with an average value of $120, so there are probably\n    around 900 tx/s with a value greater than $100. With a 1MB block\n    allowing 2000 tx every 10 minutes, 0.4% adoption of bitcoin allows\n    everyone of those transactions to be worth over $100, which in turn\n    means the per transaction fee could be up to $2.20 (compared to\n    about 2c at present)\n\n E. Without lightning, by this analysis, miners fees are mostly subject\n    to what the competition charges -- if Visa drops their rates from\n    20c+2% to 5c+1.5%, bitcoin transaction fees will drop\n    correspondingly.\n\n F. With lightning, the only part of the above that changes is the\n    comparison to Visa -- instead of the only alternative to putting\n    your transaction in the blockchain being to pay 20c+2% to Visa; you\n    can pay 1% to lightning nodes to route your payment; so the outcome\n    to miners is exactly the same as if Visa dropped its rates to a\n    flat 1%.  If the number of transactions per block stays constant,\n    the transactions actually selected will also be the same, but fees\n    paid to miners will reduce by about half (ie $2.20 to $1, 60c to 20c,\n    40c to 10c)\n\nNumerical conclusions:\n\n G. 60e9 transactions per year is 164M transactions per day or 1.13M\n    transactions every ten minutes. If each megabyte of block size allows\n    2000 transactions, then handling 1.13M transactions every 10 minutes\n    would require 565MB per block. However this would also drive fees down\n    to zero; so there is a smaller blocksize that induces optimal fees.\n\n H. Given the log-normal distribution in (8), at 100% adoption and 100%\n    availability of lightning, this turns out to occur with a blocksize\n    of about 83MB, and a corresponding fee of about $2.02.  This implies\n    a rate of 276 tx/second on the blockchain, and miner revenue of\n    about $335,000 in fees per block (compared to the inflation reward\n    of about $7500 per block, at 25 BTC and $300/BTC).\n\n J. In such a scenario, lightning would be cheaper for any\n    transaction with a value under $202, by far the majority of\n    transactions. Lightning nodes would thus take the remaining 1624\n    tx/second, and earn what works out to be about $107M in fees per\n    day, or, for comparison purposes, about $750,000 in fees per block.\n    Collectively, lightning nodes would be handling 5.8 times as many\n    transactions for about 2.2 times as much in fees.\n\n K. In the same scenario as above, but without lightning (and thus Visa\n    as the only alternative, pushing fees up), the optimal blocksize\n    works out to be 90MB, with a corresponding fee of about $4 per\n    transaction. That works out a rate of 300 tx/second, and miner\n    revenue of $720,000 in fees per block. Visa would handle the\n    remaining transactions, earning $232M per day, or for comparison\n    purposes about $1,615,000 per block.\n\n L. If people adopt bitcoin and lightning independently of their\n    transaction amounts, and the log-normal model above is accurate,\n    those figures scale fairly simply: with lightning, $2.02 remains the\n    revenue-maximising per-transaction fee for miners; optimal blocksize\n    scales proportionally; ie with 10% adoption, an 16000 transactions per\n    block or about 8MB is optimal, and with 1% adoption, 1600 transactions\n    per block or about 800kB is optiomal.\n\n M. Varying the fee lightning nodes charge in the scenario above has a\n    direct effect on the bitcoin fee, but does not change the optimal\n    block size for a given level of adoption. So halving the lightning\n    fee to 0.5% would result in the optimal fee also halving, with miners'\n    revenue halving to about $168,000 per block.\n\n N. If lightning had fees at 0.22%, the optimal bitcoin fee would be\n    about 45c per transaction (with lightning still cheaper for\n    transactions below $200 in value); at 10% adoption, optimal blocksize\n    would be about 8MB or 16000 transactions per block, which would\n    result in about $7200 per block in fee to miners, which is about\n    24BTC per block given a price of $300/BTC. This might be a plausible\n    set of figures to target -- reasonable volume, reasonable profit,\n    still fairly cheap, and with wide but not completely crazy adoption?\n\nCaveats:\n\n Z. The log-normal distribution might not be reasonable. I've no idea of\n    anything better though. Also, the numbers from Visa might be\n    inaccurate or incomplete in the first place. They're also a couple\n    of years old, don't include Mastercard, Amex, etc.\n\n Y. Visa, bitoin and lightning aren't exact subsititutes:\n     * Neither Visa nor Lightning can execute \"smart contracts\" like\n       bitcoin can; so the blockchain has additional demand on it beyond\n       Visa's current market.\n     * Visa is expensive or unsuitable for micropayments while lightning\n       is designed for them, so the potential demand may be larger than\n       estimated above (7).\n     * Unlike Visa, lightning and bitcoin do not naturally support\n       payments on credit or fraud protection for consumers, so some\n       proportion of Visa's market is probably not addressable by lightning\n       or bitcoin.\n     * Lightning payments are confirmed immediately, unlike bitcoin\n       transactions which take some time to be confirmed and can be\n       unconfirmed for a short period afterwards, and unlike Visa where\n       chargebacks are possible for month.\n\n X. Increased adoption probably has some correlation to transaction\n    sizes rather than being completely independent; ie early adopters\n    probably have a different distribution of transaction amounts compared\n    to late adopters. No idea /how/ that's likely to differ though...\n\n W. Current fees of up to ~2c/tx differs wildly from the above estimates\n    of $2 to $4 as the revenue maximising fees for miners above, given\n    alternative methods of payment take 1%-2% in fees. Maybe that just\n    means miners aren't maximising fee revenue at present (given low\n    adoption, and high inflation reward that's probably reasonable);\n    but maybe it means the distribution of payment sizes in bitcoin is\n    wildly different to the estimated distribution of Visa transactions\n    above (and skewed much lower). Alternatively, maybe it means that\n    miners aren't an effective cartel, and thus can't force fees to rise\n    to maximise revenue; that doesn't seem likely to me though...\n\nCheers,\naj\n\n[0] https://www.reddit.com/r/Bitcoin/comments/3n89cu/lightning_network_onion_routing_proposal/cvlvskx\n    https://www.reddit.com/r/bitcoinxt/comments/3hf74y/lighting_network_ultimately_takes_fees_away_from/\n    http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-October/011523.html\n\n[1] http://investor.visa.com/files/doc_downloads/annual%20meeting/Visa%20Annual%20Report%202013%20final%20website.pdf"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-27T05:53:12",
                "message_text_only": "On Tue, Oct 27, 2015 at 03:40:29PM +1000, Anthony Towns wrote:\n>  7. The micropayments market is very small by comparison, with only\n>     $1e10 (10 billion) in volume per year, counting anything under $12\n>     as a \"micropayment\".\n\nOoops. [2]\n\n[2] http://letstalkpayments.com/payment-entrepreneurs-go-micropayments-segment-13-b-opportunity-globally/\n\nCheers,\naj"
            },
            {
                "author": "Pierre",
                "date": "2015-10-27T09:38:52",
                "message_text_only": "Hello aj,\n\nThis is very interesting, thanks!\n\nYou seem to be considering that bitcoin tx and lightning tx are completely\nindependent, which is not entirely true because of anchor transactions.\nWhile this is certainly a valid assumption, maybe it would be worth stating\nit explicitely ?\n\nCheers,\n\nPierre\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151027/704b7bd3/attachment.html>"
            },
            {
                "author": "Benjamin",
                "date": "2015-10-27T09:46:45",
                "message_text_only": ">> But I think it's actually a tractable question, so we can probably actually\nwork out numbers!\n\nThe whole point of a market would be that you get users to work out \"the\nnumbers\". If Bitcoin would have a market then capacity would be set by its\nuse and more demand would trigger supply, and vice versa. Fixing that in\ncode is inevitably going to lead to bad results. So these discussions about\nblocksize and capacity went fundamentally going in the wrong direction.\nThere is no sensible algorithm to determining prices of anything without\nusing the input of people in the market. Its not really clear Bitcoin could\nbuild in a mechanism to handle that.\n\nIt would be advantageous if fees would be variable by transaction size.\nBitcoin should handle large nominal volumes and low transaction volumes and\na possible second layer handle low nominal values and high transaction\nvolumes. So it's good to consider BTC amount transferred per bytes. The\nhigher that number the better for Bitcoin's capacity.\n\nOn Tue, Oct 27, 2015 at 10:38 AM, Pierre <pm+lists at acinq.fr> wrote:\n\n> Hello aj,\n>\n> This is very interesting, thanks!\n>\n> You seem to be considering that bitcoin tx and lightning tx are completely\n> independent, which is not entirely true because of anchor transactions.\n> While this is certainly a valid assumption, maybe it would be worth stating\n> it explicitely ?\n>\n> Cheers,\n>\n> Pierre\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151027/e19ca702/attachment-0001.html>"
            },
            {
                "author": "Benjamin",
                "date": "2015-10-27T10:05:09",
                "message_text_only": "To make myself more clear. If I assume (roughly based on BCI data):\n\n1000 tx / block\n1 BTC volume per tx\n300$ BTC/USD\n=> 300.000$ of dollar volume moved per block\n=> 36B$ dollar volume capacity per year\n\nOne of the key aspects of scaling would be to move low value transactions\nto a 2nd layer, and leave high value transactions for the most secure\nmechanism. Assume for instance that Bitcoin only processes transactions\nwhich have a dollar nominal value of say 100$ and everything else is\nhandled by 2nd layer. I don't know the statistical distribution, but I\nassume this would cut e.g. 95% of transaction volume and brings the average\nto 100 BTC. Then the total dollar volume capacity increases by a factor of\n100, that is 3600B$ with the same 1 MB blocksize. The key to scaling in my\nopinion is to figure out some way to make this split work based on nominal\nvalue of the transaction. That's already how the financial system is\norganised. Banks make huge transaction volumes on closed systems. Hubs in\nLightning and banks in the fiat money system would be very similar things.\n\n\nOn Tue, Oct 27, 2015 at 10:46 AM, Benjamin <benjamin.l.cordes at gmail.com>\nwrote:\n\n> >> But I think it's actually a tractable question, so we can probably actually\n> work out numbers!\n>\n> The whole point of a market would be that you get users to work out \"the\n> numbers\". If Bitcoin would have a market then capacity would be set by its\n> use and more demand would trigger supply, and vice versa. Fixing that in\n> code is inevitably going to lead to bad results. So these discussions about\n> blocksize and capacity went fundamentally going in the wrong direction.\n> There is no sensible algorithm to determining prices of anything without\n> using the input of people in the market. Its not really clear Bitcoin could\n> build in a mechanism to handle that.\n>\n> It would be advantageous if fees would be variable by transaction size.\n> Bitcoin should handle large nominal volumes and low transaction volumes and\n> a possible second layer handle low nominal values and high transaction\n> volumes. So it's good to consider BTC amount transferred per bytes. The\n> higher that number the better for Bitcoin's capacity.\n>\n> On Tue, Oct 27, 2015 at 10:38 AM, Pierre <pm+lists at acinq.fr> wrote:\n>\n>> Hello aj,\n>>\n>> This is very interesting, thanks!\n>>\n>> You seem to be considering that bitcoin tx and lightning tx are\n>> completely independent, which is not entirely true because of anchor\n>> transactions. While this is certainly a valid assumption, maybe it would be\n>> worth stating it explicitely ?\n>>\n>> Cheers,\n>>\n>> Pierre\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20151027/806adb1d/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-28T00:02:52",
                "message_text_only": "On Tue, Oct 27, 2015 at 10:38:52AM +0100, Pierre wrote:\n> You seem to be considering that bitcoin tx and lightning tx are completely\n> independent, which is not entirely true because of anchor transactions.\n> While this is certainly a valid assumption, maybe it would be worth stating\n> it explicitely ?\n\nYep.\n\nI'm not sure what the frequency of anchor transactions is likely to\nbe. If you consider 10% adoption to be 30M users (10% of US population),\neach of whom does an anchor and claim once a month, that would be 720M\ntransactions, at 500B/tx that's an extra 7MB per block, compared to the\n8MB of high value transactions we were taking from Visa at 10% adoption.\nIf anchor/claim happens once a year on average, instead of every month,\nthat would be an extra 570kB compared to the same 8MB.\n\n(Using Metcalfe's law, 10% adoption by transaction volume might actually\nrequire 94M users (P(tx via btc) = P(userA has btc) * P(userB has btc)\n= 94/300*94/300 = 0.098 ~= 10%; so 21MB or 1.8MB in lightning anchor/tx\ntxs compared to 8MB of high-value ex-Visa transactions per block)\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-27T19:33:25",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n>  C. Without lightning, as bitcoin adoption increases, either fees rise,\n>     or number of transactions per block increases proportionally. If\n>     1% of people know about bitcoin, and use it whenever it's cheap;\n>     then 2% of people knowing about bitcoin gives twice as many\n>     transactions at any given price level.\n\nMetcalf's law?  Both sides need to \"know about bitcoin\".\n\nSay: 1 billion people, each initiating 100 txs per year.  But only 1%\nknow about bitcoin, so those 10M can only use it for 1 of their annual\ntransactions.  At 2%, 20M can use it for 2 of their annual transactions...\n\nNot sure how this alters the rest of your calculations.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-28T00:15:29",
                "message_text_only": "On Wed, Oct 28, 2015 at 06:03:25AM +1030, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> >  C. Without lightning, as bitcoin adoption increases, either fees rise,\n> >     or number of transactions per block increases proportionally. If\n> >     1% of people know about bitcoin, and use it whenever it's cheap;\n> >     then 2% of people knowing about bitcoin gives twice as many\n> >     transactions at any given price level.\n> Metcalf's law?  Both sides need to \"know about bitcoin\".\n\nI think Metcalf's law would be a lower bound -- you're more likely to\nadopt bitcoin if the people you transact with use bitcoin, so they're\nnot independent. ie,\n\n  P(tx via bitcoin | bitcoin is cheaper than alternatives)\n    = P(consumer can use bitcoin) *\n        P(merchant can use bitcoin | consumer can use bitcoin)\n\nIf those are independent and P(consumer)=P(merchant), you get Metcalf's\nlaw. If P(merchant|consumer)=1 you get my assumption above.\n\nI assume reality would be somewhere in between; because I think once\na merchant had a few customers asking for bitcoin they're more likely\n(though not certain) to offer it as a payment method. Getting an actual\nmodel would probably depend on what marketing strategy was undertaken\nfor lightning.\n\n> Say: 1 billion people, each initiating 100 txs per year.  But only 1%\n> know about bitcoin, so those 10M can only use it for 1 of their annual\n> transactions.  At 2%, 20M can use it for 2 of their annual transactions...\n\nYeah, so if Metcalf's law applied directly, you'd just have:\n\n p_tx = p_u^2\n\nor p_u = sqrt(p_tx), where p_u is the proportion of users with access\nto bitcoin, and p_tx is the proportion of transactions that could be\ndone on bitcoin (what I called \"adoption\").\n\n> Not sure how this alters the rest of your calculations.\n\nI don't think I actually used the proportion of users in any calculations\nin the original mail.\n\nIt would matter for adoption rates, and I think it matters for comparing\nhow many bytes are needed for lightning anchor txs on the blockchain\n(as per my previous mail) though.\n\nCheers,\naj"
            },
            {
                "author": "CJP",
                "date": "2015-10-27T21:34:12",
                "message_text_only": "> Alternatively, maybe it means that\n> miners aren't an effective cartel, and thus can't force fees to\n> rise to maximise revenue; that doesn't seem likely to me though...\n\nWhy not?\n\nAnyway, it will most likely be the case if we somehow manage to\nre-decentralize mining (e.g. let individual miners make the blocks\ninstead of letting pool operators do that).\n\nSo, how do your calculations work out if the miners are not a cartel,\nbut instead completely non-organized? What if, in the style of the\nprisoners dilemma / tragedy of the commons, each miners' actions are\ntargeted towards maximizing its own profits, even if that comes with a\ndisproportional cost for other miners?\n\nFor a miner it makes sense to include transactions that have much lower\nfees than the \"cartel optimum\": if you don't do that, you don't get the\nfees, but some other miner will still include them and \"spoil the\nmarket\", so it might as well be you who takes the profit. This is how a\nfree market with many independent actors leads to lower prices than a\nmarket operated by a monopoly / cartel.\n\nStill, even under such conditions, there will be natural limits, since\nthere are costs related to including transactions in your own blocks. I\nmade some estimations based on the assumption that, in the absence of an\nartificial block size limit, the limiting factor is how long it takes\nother miners to download+verify your block, which is assumed to be\nproportional to block size. Long download+verification times reduce the\nchance that other miners start building on top of your block before\nanother block is found.\n\nMy conclusion was that miners will continue to include transactions\nuntil it takes almost ten minutes to download + verify a block. The\n\"almost\" is a bit dependent on the distribution of fees people are\nprepared to pay: if all transactions use the same fee/kB it equals 10\nminutes; if a small part of the transactions pays the majority of the\nfees, miners are better off including those transactions but excluding\nmost of the rest. The same is true in the presence of a large\ninflationary block reward (current situation): that is effectively a\nsingle transaction with a very large transaction fee. Miners don't want\nto risk losing that reward by including lots of low-fee transactions.\n\nI haven't taken into account that it takes different miners different\ntimes to download+verify blocks.\n\nCJP"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-10-28T00:36:18",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n>> Alternatively, maybe it means that\n>> miners aren't an effective cartel, and thus can't force fees to\n>> rise to maximise revenue; that doesn't seem likely to me though...\n>\n> Why not?\n\nI deleted my own reply.  I think we're entering an already-inflamed area\nof debate which is not productive for lightning.  Recommend\nbitcoin-discuss.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-10-28T02:13:59",
                "message_text_only": "On Tue, Oct 27, 2015 at 10:34:12PM +0100, CJP wrote:\n> > Alternatively, maybe it means that\n> > miners aren't an effective cartel, and thus can't force fees to\n> > rise to maximise revenue; that doesn't seem likely to me though...\n> Why not?\n\nTrivially, if a majority of hashpower wanted to act as a cartel, they\ncould just use the soft-fork protocol to make and enforce any decisions\n(eg, versionbits to vote on decisions, then orphan any non-compliant\nblocks to enforce it).\n\n> So, how do your calculations work out if the miners are not a cartel,\n> but instead completely non-organized? \n\nI don't see how to come up with a figure for fees or miner revenue other\nthan than maximising revenue for miners (ie, the same fees they'd charge\nif they were a cartel) or minimising costs for users (ie fees at 0 or 1\nsatoshi per tx). The supply constraints for transactions per block aren't\nreally tied to miners' costs, so supply capacity doesn't particularly\nincrease with costs, and so supply/demand curves don't help much.\n\nIf you choose somewhere in between those extremes, that might mean the\nblockchain gets used for transactions above $20 or $100 rather than only\nabove $200; but given we're talking about lightning payments being below\nabout $10 each, that seems fine.\n\n> What if, in the style of the\n> prisoners dilemma / tragedy of the commons, each miners' actions are\n> targeted towards maximizing its own profits, even if that comes with a\n> disproportional cost for other miners?\n\nHmm. Having miners accept txs with different fees introduces a timing\naspect -- ie, it's not just \"is it worthwhile to pay Bob $5 if it costs\n45c?\" it's \"is it worth paying Bob $5 in 10 minutes for 45c; or in 60\nminutes for 20c?\"\n\nOnce you add that complication to the analysis I think you have to figure\na cartel would take it into account too. If every 10 minutes you had a\nnew set of transactions from people with the following willingness to pay:\n\n  1000 tx worth 100c in 10 minutes or 20c in 60 minutes\n   500 tx worth  90c in 10 minutes or 20c in 60 minutes\n   200 tx worth  30c in 10 minutes or 25c in 60 minutes\n   100 tx worth  20c in 10 minutes or 20c in 60 minutes\n\nThen I think you'd optimise your revenue by accepting any transactions at\n90c or more immediately, along with any transactions that are at least\n50 minutes old at 25c or more. Or you could just include 17% of 25c txs\nfrom the mempool in each block for roughly the same effect. That would\nmake you around $1400 in fees, and does better than:\n\n  $1350 in fees if you just accept 90c txs asap\n  $1000 in fees if you just accept 100c txs asap\n   $510 in fees if you just accept 30c txs asap\n   $360 in fees if you accept 20c txs at anytime up to 50m\n\nIf a non-cartel miner comes into the picture with 17% hashpower (so gets\none block an hour roughly), they could have a different policy. (If they\nhad less hashpower, they couldn't affect prices) They'd still get the\n1500 90c fees that were set based on assuming a cartel member would\nonly pick them up immediately at that price. They could pick up all\nthe 20c fee transactions, without having to let them age 50m as well,\nfor maybe $1650 in total fees. But if the non-cartel miner accepted 20c\ntransactions as well, users would notice, realise they can just offer\n20c in fees and still be fairly reliably accepted within an hour, and\nthat miner would only end up collecting $360 in fees, rather than $1650.\n\n(Accepting all the 25c transactions actually means consumers would be\npaying 25c to get their transaction accepted in about 55 minutes rather\nthan 60 minutes which might also affect prices, but the analysis is hard\nenough already...)\n\n> For a miner it makes sense to include transactions that have much lower\n> fees than the \"cartel optimum\": if you don't do that, you don't get the\n> fees, but some other miner will still include them and \"spoil the\n> market\",\n\nBecause you only get blocks in relation to your hashpower, and people care\nabout timeliness of confirmations, I don't think you can spoil the market\neasily just by being a miner with a small percent of hashpower.\n\n*Alternative* payment methods to publishing on the blockchain (like\nlightning, altcoins, or fiat payments) can undercut prices and steal\nmarketshare though. So I think prices will still end up at \"free market\"\nrates rather than anything really extortionate -- ie, lightning fees of\n1% and bitcoin txs would cap bitcoin fees at about $2/tx even with an\nabsolutely effective revenue-maximising bitcoin miner cartel.\n\n(Calling bitcoin miners a cartel is probably unfair; you don't call\n\"Visa\" a cartel just because it sets its own fees at a profit-maximising\nlevel. You'd only really have a cartel if the /industry/ cooperated\nlike that, so Visa, Amex and Mastercard all coordinating fees. Likewise\nyou'd only have a blockchain cartel if Bitcoin and litecoin and other\naltcoins coordinated fees; switching to an altcoin seems about as easy\nas changing credit card providers)\n\nAnyway, this is pretty tangential to lightning at this point. Followups\nto bitcoin-discuss or direct mail?\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Lightning fees vs miner fees",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Pierre",
                "CJP",
                "Rusty Russell",
                "Benjamin"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 28096
        }
    }
]