[{"title": "[Lightning-dev] Possible Attack IF we add BOTH upfront AND negative routing fees to the Lightning Network", "thread_messages": [{"author": "Ren\u00e9 Pickhardt", "date": "2023-01-01T11:29:35", "message_text_only": "Happy new year dear fellow Lightning Network Developers,\n\nlast month I have made a small observation why we probably should at most\nprogress EITHER with `negative fees` [1] OR `upfront fees` [2] but not with\nBOTH as adding both features to the protocol would result in a potentially\nlucrative attack that I will describe here.\n\nAssumption:\n=========\n\nFor simplicity of the argument please assume all nodes do payment delivery\nby optimizing purely for fees instead of probabilistic payment delivery or\na combination of these two and potentially other features in their cost\nfunction. The Argument will however work as long as fees are part of the\ncost function.\n\nThe Attack:\n=========\n\n1. Malory sets the routing fees of her channel(s) sufficiently negative.\n2. Now the cheapest route for all possible payment pairs on the network\ngoes through Malory.\n3. Malory will accept any incoming HTLC but will shortly after the HTLC is\nlocked in fail the payment without forwarding.\n( 4. Depending on the design of upfront fees she may need a collaborating\nproxy node)\n\nOutcome:\n========\n\n1. After announcing the negative routing fees every node that has seen the\n`channel_update`  will route through Malory if initiating a payment. This\neffectively redirects the entire traffic of the network through her node.\n2. Malory has create a DoS attack on her own node but depending on the size\nof the network she will not even see it as her channel partners will go\ndown from the DoS first (or she is able to handle the traffic as she was\nprepared)\n3. Assuming Malory has enough Channel partners (or collaborates with them)\nshe can collect the tiny unconditional upfront fees (Depending on the price\nof the upfront fees, the size of the network and the base load of payments\nper second this may or may not be lucrative)\n\nAlso as her fees were so negative most nodes might not even blame her for\nthe routing failures as they might assume others were just more quickly\nsniping that juicy liquidity. Yet Alice has collected some upfront fees of\nall payments that are going on at that time.\n\nSome thoughts about mitigation strategies:\n=================================\n\n## Working:\n* Choose weather to progress with either negative fees or upfront fees will\nstop this particular problem to come up.\n\n## Probably not working:\n* Forcing channels with negative fees to set the the upfront fee negative\nwill not work. This is effectively handing out free money to the channel\npartner: As soon as someone announces negative fees the channel partner\nwill send out fake payments and earn the negative upfront fee.\n* Allow `channel_updates` only to be relayed from connections that maintain\na channel so that Mallory cannot quickly inform the entire network about\nbeing the most central node by connecting to everyone may help in\ncombination with rate limiting of payments and reputation ideas but I guess\nothers are more experienced than me with reputation systems. Also I think\nnew participants need `channel_updates` even if they don't have channels\nyet.\n\nOwn thoughts:\n===========\n\nAs many of you know I am currently writing a paper about the fundamental\nlimitations of the scaling abilities of the Lightning Network to conduct\nBitcoin payments [3]. Most folks I talk to see deliberate and malicious\nchannel jamming as a problem. While I agree with the problem I think the\nsituation is worse. It is my current understanding that natural congestion\nresulting from the selfish behavior of both sending and routing nodes will\nbe a huge challenge for the network. This is amplified by the uncertainty\n(for example about liquidity). However, even without uncertainty it will\ncreate an upper boundary of how many payments per second the participants\nof the network will be able to conduct. This boundary is more or less given\nby the weighted betweenness centrality of the most central node and the\nrouting throughput that this node is able to handle. More on this is soon\nto come here...\n\nThat being said, independently of the up-front fees it seems to me that\nallowing negative fees tend to increase centralization effects and thus the\nprice of anarchy and natural congestion. Yet I can't quantify this at this\ntime and thus I don't know yet if this fundamentally speaks against\nnegative fees. However as discussed above in combination with upfront fees\nthere seems to be an economic incentive to abuse both together.\n\nThanks to Christian Decker for spotting an error in an edge cases when I\ninitially presented him a similar argument for review.\n\nwith kind regards Rene Pickhardt\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-September/003685.html\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n[3] https://twitter.com/renepickhardt/status/1605189724293169153\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230101/7e0f200b/attachment.html>", "summary": "A potential attack on the Lightning Network protocol involving negative and upfront fees has been highlighted. The attack involves redirecting network traffic through a node and collecting upfront fees. Mitigation strategies include choosing to progress with only one type of fee."}], "thread_summary": {"title": "Possible Attack IF we add BOTH upfront AND negative routing fees to the Lightning Network", "categories": ["Lightning-dev"], "authors": ["Ren\u00e9 Pickhardt"], "messages_count": 1, "total_messages_chars_count": 4979}}, {"title": "[Lightning-dev] Swap-in-Potentiam: Moving Onchain Funds \"Instantly\" To Lightning", "thread_messages": [{"author": "ZmnSCPxj", "date": "2023-01-03T13:57:58", "message_text_only": "Subject: Swap-in-Potentiam: Moving Onchain Funds \"Instantly\" To Lightning\n\nby Jesse Posner, ZmnSCPxj\n\nIntroduction\n============\n\nMoving funds from an onchain-only address to Lightning Network is slow,\nespecially if you desire trust-minimization (which removes solutions\nrelying on 0-conf).\n\nBasically, to reduce trust requirements in all onchain transactions,\nonchain receivers *MUST* ensure confirmation of the onchain transaction\nthat creates their UTXO.\nIn practice, the minimum should be at least 3 blocks, since reorgs of\nup to 2 blocks are common occurences, but even 1 confirmation can\ntake an inordinately long time in the real world due to the random\nnature of mining.\n\nThis is particularly acute for mobile phone use-cases.\nAs mobile phones run on a battery, mobile phone OSs often greatly\nrestrict CPU and other resource consumption when an app is not\ncurrently open by the user.\n\nNow consider this user story, for a wallet app that supports both\nBitcoin blockchain and Lightning Network operations:\n\n* The user wants to be paid over the Bitcoin blockchain.\n* The user gets an address from their wallet and provides it to\n  some other party to receive their payment.\n* The user closes their wallet app, which causes the mobile phone\n  OS to kill all its threads.\n* The other party sends their payment over blockchain while the\n  user is asleep.\n* The blockchain transaction confirms and time passes.\n* The user wakes up and checks their favorite blockchain explorer,\n  and sees they received funds on their wallet address.\n* The user opens their wallet app and decides they need a coffee,\n  so they buy coffee over Lightning.\n\nFor current solutions to move funds from the blockchain layer to\nLightning, however, the above user story would need to complete\nover a long time, possibly measurable in dozens of minutes or\neven hours in the worst case, due to the need for confirmation:\n\n* Channel open: Requires confirmation, many nodes require 6 or\n  more confirmations.\n* Submarine swap/peerswap: Requires confirmation before the swap\n  service will send out the HTLC on Lightning.\n* Splice-in: Channel remains operational, but until the splice\n  transaction confirms, the channel operates in \"dual mode\"\n  where both pre-splice and post-splice state is valid, and\n  that means only the lower amount of the pre-splice and\n  post-splice can be used in the mean time.\n  For splice-in, the pre-splice amount will be lower, thus\n  the amount being spliced in will not be credited until\n  the splice transaction is confirmed.\n\nIn this writeup, we present a novel protocol, swap-in-potentiam,\nthat can be used for immediate transfer from the blockchain\nlayer to the Lightning layer, in the above user story.\n\nAdvantages And Limitations\n--------------------------\n\nTo whet your appetite, here are the advantages:\n\n* Immediate transfer of already-confirmed-received onchain\n  funds to Lightning.\n* Onchain funds can also be transferred to another onchain\n  address (subject to normal onchain confirmation rules).\n  * This can be \"immediate\" if sending to a receiver that\n    accepts the risk of 0-conf onchain transactions.\n* Minimized trust requirement.\n\nThe disadvantages, to help convince you that yes, this is\ntechnology and not magic beans (and to not oversell this\ntech, Bitcoin media reporting often tend to oversell\nnew technologies because the disadvantages are often\nhidden away behind technical minutae):\n\n* Requires a cooperating LSP.\n  If LSP is down or refuses to cooperate, onchain funds\n  are locked for some time.\n  This has a timeout (so if the LSP never comes online\n  again, you just wait out the timeout) and the timeout\n  starts from when the receiving UTXO is confirmed in a\n  blocks, so it will not cause loss of funds, only loss\n  of opportunity (i.e. \"involuntary HODLing\").\n* If you have multiple LSPs, when you generate an address\n  you *have to* select one of them at that point, you\n  *cannot* commit to multiple LSPs and select one of them\n  later when your phone wakes up again.\n  This exacerbates the above disadvantage, since you have\n  to select one of your LSPs and hope that when your\n  phone wakes up the LSP you selected is also up and\n  cooperative.\n* The onchain-received funds have to be confirmed first,\n  otherwise we still need to wait for confirmation of the\n  onchain-received funds.\n  This is generally true for many blockchain-only wallets\n  anyway and is thus not a worsening, but is also not an\n  improvement.\n* If the timeout is too near, actions must be performed\n  onchain that require confirmation.\n\nSwap-in-Potentiam\n=================\n\nAll onchain fund movements, as noted, require confirmation.\nThese include onchain fund movements to the Lightning network.\n\nIf the onchain address that the wallet provides was controlled\nsolely by that wallet, then any action that requires cooperation\nwith a Lightning Network participant --- channel open, swap, or\nsplice --- would require an onchain transaction that commits to\nthat specific Lightning Network participant.\nOnly when the new onchain transaction is confirmed, can that\nLightning participant rely on the transaction output without\nhaving to trust the initiator.\n\n>From there, we can consider: what if the wallet provides an\naddress that *already* commits to that specific Lightning Network\nparticipant?\n\nIf so, then the \"timer for confirmation\" starts as soon as\nthe wallet receives on the blockchain, not as soon as the wallet\ndecides to move funds from blockchain to Lightning.\n\nThis is a significant difference for a mobile wallet: the mobile\nenvironment does not support the mobile wallet being online for\nlong.\nThus, the mobile wallet may not have any CPU to make the decision\nto move funds from blockchain to Lightning, until the actual user\nexplicitly opens the mobile wallet app.\n\nIt has already been generally accepted that due to the limitations\nof the mobile phone environment, a mobile phone wallet with\nLightning support would need some LSP anyway.\nThus, a mobile wallet that can receive on the blockchain layer\nand then send on the Lightning layer can commit to a specific,\ndifferent, Lightning participant: the LSP it has channels with.\n\nThus, the mobile wallet can provide an address that commits to\none particular Lightning Network participant: its LSP.\n\nThe mobile wallet can then initiate a single-hop swap with the\nLSP when the mobile wallet app is in the foreground and has CPU\nto think with.\nIf it received funds into the address that have already been\nconfirmed, then it can do this single-hop swap immediately with\nits LSP.\nThe LSP can immediately resolve this swap, crediting funds to\nchannel, while atomically ensuring it has sole claim to the\nonchain UTXO.\n\nThe Contract\n------------\n\nThe contract has two participants: Alice the funds owner, and\nBob its potential swap partner.\n\nOnce *any* funds have been confirmed received into an address\ncommitting to this contract, Alice owns the funds and can\ndispose of them as it likes (with cooperation from Bob).\nThe source of the funds need not be Alice, it could be a third\nparty that has an obligation to pay Alice onchain.\n\nThe contract has only 2 branches:\n\n* Onchain/channel branch: Alice and Bob.\n* Timelock branch: Alice plus a relative timelock (`OP_CSV`)\n  measurable in weeks.\n\nAstute readers will realize that the above is really a variant\nof [CLTV-style unidirectional time-limited channels][1],\nthemselves a variant of Spilman-style channels:\n\n* Uses an explicit opcode to simplify channel setup (no need\n  to pre-sign a timeout transaction between Alice and Bob,\n  can just send funds directly to the address).\n* Uses a relative locktime instead of an absolute one to\n  allow funding of the channel address (= receive onchain\n  funds ready to spend over Lightning) at any time.\n\nThe use-cases this enables are:\n\n* If Alice wants to pay to another onchain address, and Bob\n  is also online and cooperative, Alice can ask Bob to help\n  sign the Onchain/channel branch to move the funds in any\n  arbitrary onchain manner.\n* If Alice wants to pay to a Lightning invoice / keysend, and\n  has insufficient Lightning outgoing capacity (but has\n  sufficient *total* capacity), it can swap with Bob, by\n  offerring a transaction that spends via the Onchain/channel\n  branch and instantiates a fresh onchain HTLC that Bob can\n  then forward over Lightning.\n  As soon as Alice offers its signature of that transaction,\n  Bob can immediately offer an in-Lightning HTLC to Alice on\n  their channel, and then Alice can immediately resolve it\n  (thus immediately getting its funds into Lightning).\n* If Bob is offline or uncooperative, Alice can unilterally\n  recover its funds after the timeout in the Timelock\n  branch.\n\nTrust is required only to the extent that Alice trusts Bob to\nbe cooperative so that Alice can dispose of its funds immediately.\nIn case Bob turns out to be non-trustworthy, Alice can recover\nits funds via the timelock branch after the timeout period.\nThere is no scope for Bob to steal funds (indeed, it is easier\nfor Bob to steal Lightning funds than to steal swap-in-potentiam\nfunds).\n\nThe intent here is that the mobile wallet is Alice, while the\nLSP is Bob.\n\n### Bob Security\n\nBob *MUST* ensure that, for each UTXO, it is either asked to\nsign an arbitrary onchain transaction (i.e the first use-case\nabove) *OR* it gets offered an onchain HTLC from that UTXO.\nOnce Alice has asked Bob to cooperate in either case for a\nparticular UTXO, Bob *MUST* ensure that it does not sign the other\ncase (and Bob *MUST* refuse to cooperate in the other case once\none case has been requested).\n\nIn addition, Bob *MUST* ensure that, if it is used in the\n\"channel\" case (i.e. the second use-case above), the timeout of\nthe Timelock branch is far enough in the future that it is likely\nthat spends using the Onchain/channel branch have confirmed by\nthen.\n\nWith both invariants enforced by Bob, Bob can ensure that, if\nAlice requests a swap using the Onchain/channel branch, only Bob\ncan spend the UTXO (at least before the timeout), and thus can\nsafely offer a Lightning HTLC to Alice immediately without any\nadditional waiting for onchain confirmations.\n\nAs Bob needs to know the UTXO in the first use-case above, this\nrequirement prevents the use of blind signing techniques when\nimplementing the first use-case.\nBasically, when being asked to sign, Bob must generate the entire\n`SIGHASH` from data that Alice provides, so that Bob is able to\nkeep track of UTXOs it is signing for.\n\n### Remote Swap\n\nWhile Bob is generally considered \"the\" LSP of the mobile wallet\nAlice, nothing in the Lightning protocol actually requires that\nBob be a direct peer of Alice.\nThe only real requirement is that Bob is able to send funds to\nAlice over Lightning in exchange for possession of the equivalent\nonchain funds.\n\nAgainst this, we should note that the mobile wallet is already\ndependent on one or more LSPs anyway, so it may as well just use\nits direct peer LSPs instead of a remote node.\n\n### Address Derivation\n\nSwap-in-potentiam addresses can be derived from a root public or\nprivate key.\n\nWe only need one keypair each from Alice and Bob.\nAlice can use standard derivation paths for its keypair.\n\nAs Bob is intended to be an LSP, we can just use its Lightning\nnode ID as the public key.\nBob needs to be in possession of the corresponding private key\nanyway in order to set up BOLT 8 encrypted transports.\n\nAs LSPs are part of the public network, Alice can simply try to\nscan for all published nodes that advertise support for\nswap-in-potentiam.\nAlternately if the wallet has a short list of fixed LSPs it\nwill use, it can simply refer to that list.\n\nThus:\n\n* Alice uses a derived keypair.\n* Bob uses a fixed keypair (its Lightning node ID).\n\nThe above is sufficient to derive swap-in-potentiam addresses\nfrom an `xprv` or `xpub` root key.\n\nSwap-in-potentiam For LSPs\n==========================\n\nWhile the original design of swap-in-potentiam has the mobile\nwallet in the \"Alice\" role and its LSP in the \"Bob\" role, it\nturns out that LSPs can provide special service to improve\nreceiving mobile wallets.\n\nSuppose that the LSP keeps track of statistics, and thus has\nan idea of which of its mobile wallet clients are likely to\nbe net receivers.\n\nNet receivers will often have low inbound capacity (since the\ninbound capacity has been used up during previous LN receives).\n\nDuring times of low onchain fees, an LSP can check which of its\noffline mobile wallet clients have low inbound capacity, and are\nlikely to come online in the future to receive.\nIn those cases, the LSP can commit funds to a swap-in-potentiam\nwith the mobile client, with the LSP as \"Alice\" and the mobile\nclient as \"Bob\".\nThis at least lets the LSP set up half of a swap during a time of\nlow fees.\n\nIf the transfer to swap-in-potentiam addresses is confirmed by\nthe time the mobile wallet client comes online, the LSP can\nimmediately initiate a swap, giving inbound capacity towards the\nmobile client.\nThis swap can be immediately resolved, and allows the mobile\nwallet client to immediately receive funds over Lightning.\n\nIn particular, if \"offline receive\" as designed by TheBlueMatt\nis implemented, then the LSP already has indication of a pending\npayment towards an offline mobile wallet client.\nThe LSP can check if the offline mobile wallet client has\ninsufficient incoming capacity to receive the funds, and if so,\narrange to fund a swap-in-potentiam with that client.\nThen, when the mobile wallet client comes online, the LSP can\ninitiate the swap with them, and once the swap completes (and\nthus the mobile wallet client has sufficient incoming capacity)\nthe LSP can contact the sender LSP to complete the payment.\n\nIn particular, this use-case allows for *immediate* receives as\nsoon as the mobile wallet client gets foregrounded and has CPU\ntime, **without** requiring 0-conf trusted transactions and\nthus without requiring any kind of semi-custodial trust, even\nif the mobile wallet client had insufficient incoming capacity.\nA channel still has to be set up beforehand (without 0-conf, if\ntrusting funds to the LSP is undesirable).\n\nImplementation Sketch\n=====================\n\nThe intent is to use Taproot with Schnorr signatures, but\n**without** using the keyspend path (at least initially).\n\nThe plan currently is to use a `MuSig(A, B)` as the internal\npubkey, but with the branches still explicitly laid out as\ntapleaves.\nThat is, there are two tapleaf SCRIPTs corresponding to the\ntwo branches described above:\n\n* `<A> OP_CHECKSIGVERIFY <B> OP_CHECKSIG`\n* `<timelock> OP_CHECKSEQUENCEVERIFY OP_DROP <A> OP_CHECKSIG`\n\nUsing an explicit 2-of-2 branch rather than a MuSig allows\nfor a simple protocol at least for initial deployment:\nwe can have Alice send the signature using `A` in a single\nhalf-round without having to engage in a 2-round MuSig2 signing\nritual.\n\nWe intend to use Taproot since the mobile wallet client\nmay need to use a 2-of-3 or 2-of-2 signing scheme, similar\nto Blockstream Green.\nThis allows either Alice or Bob in the contract to secretly\nbe a FROST 2-of-3 or MuSig 2-of-2 (or any FROST k-of-n or\nMuSig n-of-n).\nThis is also another reason for avoiding a 2-of-2 MuSig\nkeyspend path between Alice and Bob, as there is (to our\nknowledge) no publicly-reviewed security proof that\nFROST-in-MuSig and MuSig-in-MuSig are safe (or the\ncorresponding variants using MuSig2 for the signing\nritual).\n\nLater, when we are more confident of the use of MuSig2 and\nFROST inside a MuSig2, and with using MuSig2 with possibly\nuntrusted outsiders (who might exploit any mis-implementation\nof the MuSig2 signing protocol if we are not careful with\ndesigning it), we can seamlessly upgrade the protocol\nto use the keyspend path later, to save witness bytes.\n\nFor the Onchain use-case (i.e. Alice wants to spend the UTXO\nto an onchain address), the protocol betweeen Alice and Bob\nwould be:\n\n* `request_arbitrary_signature` Alice->Bob: Requests Bob\n  to sign a PSBT spending a swap-in-potentiam address\n  using the Onchain branch.\n* `response_arbitrary_signature` Bob->Alice: Response to\n  the above, returning the requested signature.\n* `reject_arbitrary_signature` Bob->Alice: Sent in\n  response to `request_arbitary_signature` if Bob refuses\n  to cooperate (e.g. the UTXO being spent has already\n  been accepted by Bob in a Channel use-case below).\n\nFor the Channel use-case (i.e. Alice wants to spend the UTXO\nto a Lightning receiver), we operate the swap-in-potentiam\nUTXO(s) as a Spilman-like channel over two states:\n\n* HTLC-offering: Offering an amount `N` HTLC from Alice to\n  Bob, with any remaining amount to a change address to\n  Alice.\n* Resolved: Giving the amount `N` outright to Bob, with any\n  remaining amount to a change address to Alice.\n\nThe intention is that the channel is initially put into\nthe HTLC-offerring state.\nThen Bob offers a corresponding in-Lightning HTLC to Alice\nover their channel.\nWhen Alice resolves the in-Lightning HTLC, it can then\nsend a new signature for the Resolved state.\nOnce the channel is in a Resolved state, Bob *SHOULD* sign\nthe last state and broadcast it on the blockchain, thereby\nclosing the Spilman-like channel.\n\nThe protocol messages for the Channel use-case are:\n\n* `request_swap_in` Alice->Bob: Tell Bob the UTXOs with\n  the same swap-in-potentiam address to spend, how\n  much to put into the Alice->Bob channel direction,\n  what channel to move into, and (optionally) a change\n  address for Alice.\n* `reject_swap_in` Bob->Alice: Sent in response to\n  `request_swap_in` if Bob refuses to cooperate (e.g.\n  one of the UTXOs on offer was already signed with\n  `response_arbitrary_signature`, or Bob cannot legally\n  accept control of funds from one or more of the UTXOs\n  offerred).\n* `accept_swap_in` Bob->Alice: Sent in response to\n  `request_swap_in`, containing the Bob-side address to\n  send funds to later once the state is Resolved.\n* `swap_in_signed` Alice->Bob: Response to\n  `accept_swap_in`, containing the Alice-side signature\n  for the HTLC-offering state transaction.\n  Once Bob receives this, Bob can safely construct a\n  new on-Lightning HTLC using BOLT1\n  `update_offer_htlc`.\n* `swap_in_resolved` Alice->Bob: Sent after Alice has\n  acquired the funds via `update_fulfill_htlc` of the\n  corresponding on-Lightning HTLC, containing the\n  Alice-side signature for the Resolved state\n  transaction.\n  The Resolved state transaction spends to the Bob-side\n  address given in `accept_swap_in`, and any change to\n  the Alice-side change address in `request_swap_in`.\n\nThe plan is to reserve only one odd BOLT1 message ID,\nand to embed the actual swap-in-potentiam message ID\nas the first 2 bytes of the BOLT1 message, to reduce\npollution of the limited BOLT1 message ID space and to\nallow more flexibility for swap-in-potentiam to expand\nto new messages inside its own message ID space.\n\nFor a richer future protocol, we will want to consider\nhow a swap-in can be combined with a splice-in.\nThis is useful if the current total capacity of the\nchannel is lower than the available onchain funds.\nThe swap-in can be credited immediately (and is limited\nto the current total capacity) while additional funds\ncan be added to the channel via splice-in (which is\ncredited only once the splice-in is confirmed).\n\nAs-is, a similar result can be obtained using openv1,\nwherein a swap-in is combined with a channel open,\nwith the swap-in immediately credited while the channel\nopen is awaiting confirmation:\n\n* Alice and Bob currently have one or more existing\n  channels, and Alice has a UTXO in a swap-in-potentiam\n  address whose value exceeds the incoming capacity of\n  the existing channel(s).\n* Alice->Bob `open_channel`.\n* Bob->Alice `accept_channel`.\n* Alice->Bob `request_swap_in` with the \"change address\"\n  being the funding address of the channel.\n* Bob->Alice `accept_swap_in` provides the TXID of the\n  funding transaction (Alice now knows the \"change\n  address\" and the Bob final Resolved address, letting it\n  know the final Resolved state transaction TXID).\n* Alice->Bob `funding_created` with the TXID.\n* Bob->Alice `funding_signed`.\n* Alice->Bob `swap_in_signed` to provide the signature\n  spending the swap-in-potentiam address to Bob.\n* Bob then constructs an HTLC over the existing channel,\n  which Alice claims, revealing the preimage.\n* Alice->Bob `swap_in_resolved`.\n* Bob then broadcasts the Resolved state transaction,\n  which is also the funding transaction of the new channel.\n* Both Alice and Bob await confirmation of the transaction\n  in order to use the new channel.\n  Alice can still use the existing channel, which has been\n  topped-up with fresh outgoing capacity by the swap-in.\n\n(The above is not safe, as Bob can complete the protocol\nby using the HTLC-offerring state transaction; this can\nbe fixed by having Alice open *2* channels with the same\namount, one with the HTLC-offering state transaction as\nthe funding tx, the other with the Resolved state\ntransaction as the funding tx, and later `error`ing the\nchannel corresponding to the transaction that is not\nconfirmed; this is left as an exercise to the reader,\nthough note that it requires two different change addresses\nfor Alice for both HTLC-offerring and Resolved states,\nwhich can be arranged for the protocol)\n\n--\n\n[1]: https://en.bitcoin.it/wiki/Payment_channels#CLTV-style_payment_channels", "summary": "A new protocol called swap-in-potentiam allows for immediate transfer of onchain funds to Lightning Network, reducing the time required for confirmation."}, {"author": "David A. Harding", "date": "2023-01-03T18:36:01", "message_text_only": "On 2023-01-03 03:57, ZmnSCPxj via Lightning-dev wrote:\n> The contract has two participants: Alice the funds owner, and\n> Bob its potential swap partner.\n> [...]\n> The contract has only 2 branches:\n> \n> * Onchain/channel branch: Alice and Bob.\n> * Timelock branch: Alice plus a relative timelock (`OP_CSV`)\n>   measurable in weeks.\n\nGood morning Jesse and ZmnSCPxj,\n\nIs the following an accurate summary of the proposal's benefits and \ncosts? At some point x blocks before Alice expects she might want to \nspend her funds on LN (but also wants the option to quickly spend her \nfunds onchain), she enters into a contract protocol with Bob.  At any \ntime, with Bob's cooperation, she can send an onchain transaction.  Or, \nafter the contract protocol deposit transaction gets x confirmations, \nAlice can instantly fund a fully initialized LN channel with Bob's \ncooperation, from which she can immediately send LN payments.\n\nIf the above is accurate, how does that compare to splice outs?  For \nexample: at some point x blocks before Alice expects she might want to \nspend her funds on LN (but also wants the option to quickly spend her \nfunds onchain), she enters into a contract protocol with Bob by opening \nan LN channel.  At any time, with Bob's cooperation, she can send an \nonchain transaction using a splice out.  Or, after the contract protocol \n(LN) deposit transaction gets x confirmations, Alice now has a funded \nfully initialized LN channel with Bob's participation as counterparty, \nfrom which she can immediately send LN payments.\n\nIf the value for x blocks is the same in both cases, those two scenarios \nlook very similar to me.\n\nThe only advantages I see of your proposal are:\n\n1. It allows Alice's LN wallet to remain offline indefinitely---but only \nif Alice doesn't have any other funds in open channels.\n2. It's easier to implement than splice-outs (I would guess)---but it \nalso only provides the benefits of sending onchain payments at the time \nbefore the first LN transaction is made, whereas actual splice out can \nbe used any time in a channel's lifetime to immediately send onchain \npayments.\n\nAm I missing something?\n\n-Dave", "summary": "A proposal for a contract protocol between two parties, Alice and Bob, with two branches: on-chain/channel and timelock, for instant LN payments."}, {"author": "Jesse Posner", "date": "2023-01-04T01:24:09", "message_text_only": "Hi David,\n\nConsider a scenario where Alice receives on-chain funds while her mobile\nwallet\napp is not running. The app can't perform a splice-in until it is opened.\nLet's\nsay she doesn't open the app until she is ready to buy her coffee with an LN\npayment, and there's not sufficient outbound liquidity in the channel to\nmake\nthe payment. At that point, it's inconvenient for Alice to have to wait for\nan\non-chain splice-in to confirm before she can buy her coffee.\n\nHowever, if she received on-chain funds with a swap-in-potentiam address,\nthe\napp can draw upon the liquidity when the LN payment needs to be made without\nhaving to wait for an on-chain transaction. Furthermore, Alice can defer her\ndecision about whether she wants to pay the fees to increase her outbound\nliquidity until she needs the liquidity.\n\nSimilarly, this process can work in reverse, such that she can increase her\ninbound liquidity in the channel, and pay for it, on-demand when the\nliquidity\nis needed and not before.\n\nAll the best,\n\nJesse\n\nOn Tue, Jan 3, 2023 at 10:36 AM David A. Harding <dave at dtrt.org> wrote:\n\n> On 2023-01-03 03:57, ZmnSCPxj via Lightning-dev wrote:\n> > The contract has two participants: Alice the funds owner, and\n> > Bob its potential swap partner.\n> > [...]\n> > The contract has only 2 branches:\n> >\n> > * Onchain/channel branch: Alice and Bob.\n> > * Timelock branch: Alice plus a relative timelock (`OP_CSV`)\n> >   measurable in weeks.\n>\n> Good morning Jesse and ZmnSCPxj,\n>\n> Is the following an accurate summary of the proposal's benefits and\n> costs? At some point x blocks before Alice expects she might want to\n> spend her funds on LN (but also wants the option to quickly spend her\n> funds onchain), she enters into a contract protocol with Bob.  At any\n> time, with Bob's cooperation, she can send an onchain transaction.  Or,\n> after the contract protocol deposit transaction gets x confirmations,\n> Alice can instantly fund a fully initialized LN channel with Bob's\n> cooperation, from which she can immediately send LN payments.\n>\n> If the above is accurate, how does that compare to splice outs?  For\n> example: at some point x blocks before Alice expects she might want to\n> spend her funds on LN (but also wants the option to quickly spend her\n> funds onchain), she enters into a contract protocol with Bob by opening\n> an LN channel.  At any time, with Bob's cooperation, she can send an\n> onchain transaction using a splice out.  Or, after the contract protocol\n> (LN) deposit transaction gets x confirmations, Alice now has a funded\n> fully initialized LN channel with Bob's participation as counterparty,\n> from which she can immediately send LN payments.\n>\n> If the value for x blocks is the same in both cases, those two scenarios\n> look very similar to me.\n>\n> The only advantages I see of your proposal are:\n>\n> 1. It allows Alice's LN wallet to remain offline indefinitely---but only\n> if Alice doesn't have any other funds in open channels.\n> 2. It's easier to implement than splice-outs (I would guess)---but it\n> also only provides the benefits of sending onchain payments at the time\n> before the first LN transaction is made, whereas actual splice out can\n> be used any time in a channel's lifetime to immediately send onchain\n> payments.\n>\n> Am I missing something?\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230103/8ef5ad59/attachment.html>", "summary": "A proposal suggests using a swap-in-potentiam address to draw upon liquidity when making LN payments without waiting for an on-chain transaction. This can work in reverse to increase inbound liquidity on-demand. The proposal offers advantages such as allowing the LN wallet to remain offline and being easier to implement."}, {"author": "Lloyd Fournier", "date": "2023-01-04T02:06:36", "message_text_only": "Dear Jesse & Z,\n\nI believe this kind of scheme is of crucial importance. I think if we're\nserious about bridging layer-1 and layer-2 systems transparently for users,\nwallets must be able to give out addresses that are covert channel openings\nwithout the sender's knowledge. e.g. I should be able to withdraw coins\nfrom an exchange straight into a channel by submitting an address without\nknowing precisely how much money I will receive to that address. I hadn't\nconsidered this particular design before -- it's very practical and works\ntoday. My own minor effort on this topic was to suggest that researchers\ndesigning sophisticated covenant proposals should make sure that they\nachieve this functionality cleanly [1]. The advantage of using a covenant\nis that the channel would not have an expiry date and therefore be a first\nclass citizen among channels.\n\n[1]\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg/issues/19#issue-1492942389\n\nCheers,\n\nLL\n\n\nOn Wed, 4 Jan 2023 at 00:58, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Subject: Swap-in-Potentiam: Moving Onchain Funds \"Instantly\" To Lightning\n>\n> by Jesse Posner, ZmnSCPxj\n>\n> Introduction\n> ============\n>\n> Moving funds from an onchain-only address to Lightning Network is slow,\n> especially if you desire trust-minimization (which removes solutions\n> relying on 0-conf).\n>\n> Basically, to reduce trust requirements in all onchain transactions,\n> onchain receivers *MUST* ensure confirmation of the onchain transaction\n> that creates their UTXO.\n> In practice, the minimum should be at least 3 blocks, since reorgs of\n> up to 2 blocks are common occurences, but even 1 confirmation can\n> take an inordinately long time in the real world due to the random\n> nature of mining.\n>\n> This is particularly acute for mobile phone use-cases.\n> As mobile phones run on a battery, mobile phone OSs often greatly\n> restrict CPU and other resource consumption when an app is not\n> currently open by the user.\n>\n> Now consider this user story, for a wallet app that supports both\n> Bitcoin blockchain and Lightning Network operations:\n>\n> * The user wants to be paid over the Bitcoin blockchain.\n> * The user gets an address from their wallet and provides it to\n>   some other party to receive their payment.\n> * The user closes their wallet app, which causes the mobile phone\n>   OS to kill all its threads.\n> * The other party sends their payment over blockchain while the\n>   user is asleep.\n> * The blockchain transaction confirms and time passes.\n> * The user wakes up and checks their favorite blockchain explorer,\n>   and sees they received funds on their wallet address.\n> * The user opens their wallet app and decides they need a coffee,\n>   so they buy coffee over Lightning.\n>\n> For current solutions to move funds from the blockchain layer to\n> Lightning, however, the above user story would need to complete\n> over a long time, possibly measurable in dozens of minutes or\n> even hours in the worst case, due to the need for confirmation:\n>\n> * Channel open: Requires confirmation, many nodes require 6 or\n>   more confirmations.\n> * Submarine swap/peerswap: Requires confirmation before the swap\n>   service will send out the HTLC on Lightning.\n> * Splice-in: Channel remains operational, but until the splice\n>   transaction confirms, the channel operates in \"dual mode\"\n>   where both pre-splice and post-splice state is valid, and\n>   that means only the lower amount of the pre-splice and\n>   post-splice can be used in the mean time.\n>   For splice-in, the pre-splice amount will be lower, thus\n>   the amount being spliced in will not be credited until\n>   the splice transaction is confirmed.\n>\n> In this writeup, we present a novel protocol, swap-in-potentiam,\n> that can be used for immediate transfer from the blockchain\n> layer to the Lightning layer, in the above user story.\n>\n> Advantages And Limitations\n> --------------------------\n>\n> To whet your appetite, here are the advantages:\n>\n> * Immediate transfer of already-confirmed-received onchain\n>   funds to Lightning.\n> * Onchain funds can also be transferred to another onchain\n>   address (subject to normal onchain confirmation rules).\n>   * This can be \"immediate\" if sending to a receiver that\n>     accepts the risk of 0-conf onchain transactions.\n> * Minimized trust requirement.\n>\n> The disadvantages, to help convince you that yes, this is\n> technology and not magic beans (and to not oversell this\n> tech, Bitcoin media reporting often tend to oversell\n> new technologies because the disadvantages are often\n> hidden away behind technical minutae):\n>\n> * Requires a cooperating LSP.\n>   If LSP is down or refuses to cooperate, onchain funds\n>   are locked for some time.\n>   This has a timeout (so if the LSP never comes online\n>   again, you just wait out the timeout) and the timeout\n>   starts from when the receiving UTXO is confirmed in a\n>   blocks, so it will not cause loss of funds, only loss\n>   of opportunity (i.e. \"involuntary HODLing\").\n> * If you have multiple LSPs, when you generate an address\n>   you *have to* select one of them at that point, you\n>   *cannot* commit to multiple LSPs and select one of them\n>   later when your phone wakes up again.\n>   This exacerbates the above disadvantage, since you have\n>   to select one of your LSPs and hope that when your\n>   phone wakes up the LSP you selected is also up and\n>   cooperative.\n> * The onchain-received funds have to be confirmed first,\n>   otherwise we still need to wait for confirmation of the\n>   onchain-received funds.\n>   This is generally true for many blockchain-only wallets\n>   anyway and is thus not a worsening, but is also not an\n>   improvement.\n> * If the timeout is too near, actions must be performed\n>   onchain that require confirmation.\n>\n> Swap-in-Potentiam\n> =================\n>\n> All onchain fund movements, as noted, require confirmation.\n> These include onchain fund movements to the Lightning network.\n>\n> If the onchain address that the wallet provides was controlled\n> solely by that wallet, then any action that requires cooperation\n> with a Lightning Network participant --- channel open, swap, or\n> splice --- would require an onchain transaction that commits to\n> that specific Lightning Network participant.\n> Only when the new onchain transaction is confirmed, can that\n> Lightning participant rely on the transaction output without\n> having to trust the initiator.\n>\n> From there, we can consider: what if the wallet provides an\n> address that *already* commits to that specific Lightning Network\n> participant?\n>\n> If so, then the \"timer for confirmation\" starts as soon as\n> the wallet receives on the blockchain, not as soon as the wallet\n> decides to move funds from blockchain to Lightning.\n>\n> This is a significant difference for a mobile wallet: the mobile\n> environment does not support the mobile wallet being online for\n> long.\n> Thus, the mobile wallet may not have any CPU to make the decision\n> to move funds from blockchain to Lightning, until the actual user\n> explicitly opens the mobile wallet app.\n>\n> It has already been generally accepted that due to the limitations\n> of the mobile phone environment, a mobile phone wallet with\n> Lightning support would need some LSP anyway.\n> Thus, a mobile wallet that can receive on the blockchain layer\n> and then send on the Lightning layer can commit to a specific,\n> different, Lightning participant: the LSP it has channels with.\n>\n> Thus, the mobile wallet can provide an address that commits to\n> one particular Lightning Network participant: its LSP.\n>\n> The mobile wallet can then initiate a single-hop swap with the\n> LSP when the mobile wallet app is in the foreground and has CPU\n> to think with.\n> If it received funds into the address that have already been\n> confirmed, then it can do this single-hop swap immediately with\n> its LSP.\n> The LSP can immediately resolve this swap, crediting funds to\n> channel, while atomically ensuring it has sole claim to the\n> onchain UTXO.\n>\n> The Contract\n> ------------\n>\n> The contract has two participants: Alice the funds owner, and\n> Bob its potential swap partner.\n>\n> Once *any* funds have been confirmed received into an address\n> committing to this contract, Alice owns the funds and can\n> dispose of them as it likes (with cooperation from Bob).\n> The source of the funds need not be Alice, it could be a third\n> party that has an obligation to pay Alice onchain.\n>\n> The contract has only 2 branches:\n>\n> * Onchain/channel branch: Alice and Bob.\n> * Timelock branch: Alice plus a relative timelock (`OP_CSV`)\n>   measurable in weeks.\n>\n> Astute readers will realize that the above is really a variant\n> of [CLTV-style unidirectional time-limited channels][1],\n> themselves a variant of Spilman-style channels:\n>\n> * Uses an explicit opcode to simplify channel setup (no need\n>   to pre-sign a timeout transaction between Alice and Bob,\n>   can just send funds directly to the address).\n> * Uses a relative locktime instead of an absolute one to\n>   allow funding of the channel address (= receive onchain\n>   funds ready to spend over Lightning) at any time.\n>\n> The use-cases this enables are:\n>\n> * If Alice wants to pay to another onchain address, and Bob\n>   is also online and cooperative, Alice can ask Bob to help\n>   sign the Onchain/channel branch to move the funds in any\n>   arbitrary onchain manner.\n> * If Alice wants to pay to a Lightning invoice / keysend, and\n>   has insufficient Lightning outgoing capacity (but has\n>   sufficient *total* capacity), it can swap with Bob, by\n>   offerring a transaction that spends via the Onchain/channel\n>   branch and instantiates a fresh onchain HTLC that Bob can\n>   then forward over Lightning.\n>   As soon as Alice offers its signature of that transaction,\n>   Bob can immediately offer an in-Lightning HTLC to Alice on\n>   their channel, and then Alice can immediately resolve it\n>   (thus immediately getting its funds into Lightning).\n> * If Bob is offline or uncooperative, Alice can unilterally\n>   recover its funds after the timeout in the Timelock\n>   branch.\n>\n> Trust is required only to the extent that Alice trusts Bob to\n> be cooperative so that Alice can dispose of its funds immediately.\n> In case Bob turns out to be non-trustworthy, Alice can recover\n> its funds via the timelock branch after the timeout period.\n> There is no scope for Bob to steal funds (indeed, it is easier\n> for Bob to steal Lightning funds than to steal swap-in-potentiam\n> funds).\n>\n> The intent here is that the mobile wallet is Alice, while the\n> LSP is Bob.\n>\n> ### Bob Security\n>\n> Bob *MUST* ensure that, for each UTXO, it is either asked to\n> sign an arbitrary onchain transaction (i.e the first use-case\n> above) *OR* it gets offered an onchain HTLC from that UTXO.\n> Once Alice has asked Bob to cooperate in either case for a\n> particular UTXO, Bob *MUST* ensure that it does not sign the other\n> case (and Bob *MUST* refuse to cooperate in the other case once\n> one case has been requested).\n>\n> In addition, Bob *MUST* ensure that, if it is used in the\n> \"channel\" case (i.e. the second use-case above), the timeout of\n> the Timelock branch is far enough in the future that it is likely\n> that spends using the Onchain/channel branch have confirmed by\n> then.\n>\n> With both invariants enforced by Bob, Bob can ensure that, if\n> Alice requests a swap using the Onchain/channel branch, only Bob\n> can spend the UTXO (at least before the timeout), and thus can\n> safely offer a Lightning HTLC to Alice immediately without any\n> additional waiting for onchain confirmations.\n>\n> As Bob needs to know the UTXO in the first use-case above, this\n> requirement prevents the use of blind signing techniques when\n> implementing the first use-case.\n> Basically, when being asked to sign, Bob must generate the entire\n> `SIGHASH` from data that Alice provides, so that Bob is able to\n> keep track of UTXOs it is signing for.\n>\n> ### Remote Swap\n>\n> While Bob is generally considered \"the\" LSP of the mobile wallet\n> Alice, nothing in the Lightning protocol actually requires that\n> Bob be a direct peer of Alice.\n> The only real requirement is that Bob is able to send funds to\n> Alice over Lightning in exchange for possession of the equivalent\n> onchain funds.\n>\n> Against this, we should note that the mobile wallet is already\n> dependent on one or more LSPs anyway, so it may as well just use\n> its direct peer LSPs instead of a remote node.\n>\n> ### Address Derivation\n>\n> Swap-in-potentiam addresses can be derived from a root public or\n> private key.\n>\n> We only need one keypair each from Alice and Bob.\n> Alice can use standard derivation paths for its keypair.\n>\n> As Bob is intended to be an LSP, we can just use its Lightning\n> node ID as the public key.\n> Bob needs to be in possession of the corresponding private key\n> anyway in order to set up BOLT 8 encrypted transports.\n>\n> As LSPs are part of the public network, Alice can simply try to\n> scan for all published nodes that advertise support for\n> swap-in-potentiam.\n> Alternately if the wallet has a short list of fixed LSPs it\n> will use, it can simply refer to that list.\n>\n> Thus:\n>\n> * Alice uses a derived keypair.\n> * Bob uses a fixed keypair (its Lightning node ID).\n>\n> The above is sufficient to derive swap-in-potentiam addresses\n> from an `xprv` or `xpub` root key.\n>\n> Swap-in-potentiam For LSPs\n> ==========================\n>\n> While the original design of swap-in-potentiam has the mobile\n> wallet in the \"Alice\" role and its LSP in the \"Bob\" role, it\n> turns out that LSPs can provide special service to improve\n> receiving mobile wallets.\n>\n> Suppose that the LSP keeps track of statistics, and thus has\n> an idea of which of its mobile wallet clients are likely to\n> be net receivers.\n>\n> Net receivers will often have low inbound capacity (since the\n> inbound capacity has been used up during previous LN receives).\n>\n> During times of low onchain fees, an LSP can check which of its\n> offline mobile wallet clients have low inbound capacity, and are\n> likely to come online in the future to receive.\n> In those cases, the LSP can commit funds to a swap-in-potentiam\n> with the mobile client, with the LSP as \"Alice\" and the mobile\n> client as \"Bob\".\n> This at least lets the LSP set up half of a swap during a time of\n> low fees.\n>\n> If the transfer to swap-in-potentiam addresses is confirmed by\n> the time the mobile wallet client comes online, the LSP can\n> immediately initiate a swap, giving inbound capacity towards the\n> mobile client.\n> This swap can be immediately resolved, and allows the mobile\n> wallet client to immediately receive funds over Lightning.\n>\n> In particular, if \"offline receive\" as designed by TheBlueMatt\n> is implemented, then the LSP already has indication of a pending\n> payment towards an offline mobile wallet client.\n> The LSP can check if the offline mobile wallet client has\n> insufficient incoming capacity to receive the funds, and if so,\n> arrange to fund a swap-in-potentiam with that client.\n> Then, when the mobile wallet client comes online, the LSP can\n> initiate the swap with them, and once the swap completes (and\n> thus the mobile wallet client has sufficient incoming capacity)\n> the LSP can contact the sender LSP to complete the payment.\n>\n> In particular, this use-case allows for *immediate* receives as\n> soon as the mobile wallet client gets foregrounded and has CPU\n> time, **without** requiring 0-conf trusted transactions and\n> thus without requiring any kind of semi-custodial trust, even\n> if the mobile wallet client had insufficient incoming capacity.\n> A channel still has to be set up beforehand (without 0-conf, if\n> trusting funds to the LSP is undesirable).\n>\n> Implementation Sketch\n> =====================\n>\n> The intent is to use Taproot with Schnorr signatures, but\n> **without** using the keyspend path (at least initially).\n>\n> The plan currently is to use a `MuSig(A, B)` as the internal\n> pubkey, but with the branches still explicitly laid out as\n> tapleaves.\n> That is, there are two tapleaf SCRIPTs corresponding to the\n> two branches described above:\n>\n> * `<A> OP_CHECKSIGVERIFY <B> OP_CHECKSIG`\n> * `<timelock> OP_CHECKSEQUENCEVERIFY OP_DROP <A> OP_CHECKSIG`\n>\n> Using an explicit 2-of-2 branch rather than a MuSig allows\n> for a simple protocol at least for initial deployment:\n> we can have Alice send the signature using `A` in a single\n> half-round without having to engage in a 2-round MuSig2 signing\n> ritual.\n>\n> We intend to use Taproot since the mobile wallet client\n> may need to use a 2-of-3 or 2-of-2 signing scheme, similar\n> to Blockstream Green.\n> This allows either Alice or Bob in the contract to secretly\n> be a FROST 2-of-3 or MuSig 2-of-2 (or any FROST k-of-n or\n> MuSig n-of-n).\n> This is also another reason for avoiding a 2-of-2 MuSig\n> keyspend path between Alice and Bob, as there is (to our\n> knowledge) no publicly-reviewed security proof that\n> FROST-in-MuSig and MuSig-in-MuSig are safe (or the\n> corresponding variants using MuSig2 for the signing\n> ritual).\n>\n> Later, when we are more confident of the use of MuSig2 and\n> FROST inside a MuSig2, and with using MuSig2 with possibly\n> untrusted outsiders (who might exploit any mis-implementation\n> of the MuSig2 signing protocol if we are not careful with\n> designing it), we can seamlessly upgrade the protocol\n> to use the keyspend path later, to save witness bytes.\n>\n> For the Onchain use-case (i.e. Alice wants to spend the UTXO\n> to an onchain address), the protocol betweeen Alice and Bob\n> would be:\n>\n> * `request_arbitrary_signature` Alice->Bob: Requests Bob\n>   to sign a PSBT spending a swap-in-potentiam address\n>   using the Onchain branch.\n> * `response_arbitrary_signature` Bob->Alice: Response to\n>   the above, returning the requested signature.\n> * `reject_arbitrary_signature` Bob->Alice: Sent in\n>   response to `request_arbitary_signature` if Bob refuses\n>   to cooperate (e.g. the UTXO being spent has already\n>   been accepted by Bob in a Channel use-case below).\n>\n> For the Channel use-case (i.e. Alice wants to spend the UTXO\n> to a Lightning receiver), we operate the swap-in-potentiam\n> UTXO(s) as a Spilman-like channel over two states:\n>\n> * HTLC-offering: Offering an amount `N` HTLC from Alice to\n>   Bob, with any remaining amount to a change address to\n>   Alice.\n> * Resolved: Giving the amount `N` outright to Bob, with any\n>   remaining amount to a change address to Alice.\n>\n> The intention is that the channel is initially put into\n> the HTLC-offerring state.\n> Then Bob offers a corresponding in-Lightning HTLC to Alice\n> over their channel.\n> When Alice resolves the in-Lightning HTLC, it can then\n> send a new signature for the Resolved state.\n> Once the channel is in a Resolved state, Bob *SHOULD* sign\n> the last state and broadcast it on the blockchain, thereby\n> closing the Spilman-like channel.\n>\n> The protocol messages for the Channel use-case are:\n>\n> * `request_swap_in` Alice->Bob: Tell Bob the UTXOs with\n>   the same swap-in-potentiam address to spend, how\n>   much to put into the Alice->Bob channel direction,\n>   what channel to move into, and (optionally) a change\n>   address for Alice.\n> * `reject_swap_in` Bob->Alice: Sent in response to\n>   `request_swap_in` if Bob refuses to cooperate (e.g.\n>   one of the UTXOs on offer was already signed with\n>   `response_arbitrary_signature`, or Bob cannot legally\n>   accept control of funds from one or more of the UTXOs\n>   offerred).\n> * `accept_swap_in` Bob->Alice: Sent in response to\n>   `request_swap_in`, containing the Bob-side address to\n>   send funds to later once the state is Resolved.\n> * `swap_in_signed` Alice->Bob: Response to\n>   `accept_swap_in`, containing the Alice-side signature\n>   for the HTLC-offering state transaction.\n>   Once Bob receives this, Bob can safely construct a\n>   new on-Lightning HTLC using BOLT1\n>   `update_offer_htlc`.\n> * `swap_in_resolved` Alice->Bob: Sent after Alice has\n>   acquired the funds via `update_fulfill_htlc` of the\n>   corresponding on-Lightning HTLC, containing the\n>   Alice-side signature for the Resolved state\n>   transaction.\n>   The Resolved state transaction spends to the Bob-side\n>   address given in `accept_swap_in`, and any change to\n>   the Alice-side change address in `request_swap_in`.\n>\n> The plan is to reserve only one odd BOLT1 message ID,\n> and to embed the actual swap-in-potentiam message ID\n> as the first 2 bytes of the BOLT1 message, to reduce\n> pollution of the limited BOLT1 message ID space and to\n> allow more flexibility for swap-in-potentiam to expand\n> to new messages inside its own message ID space.\n>\n> For a richer future protocol, we will want to consider\n> how a swap-in can be combined with a splice-in.\n> This is useful if the current total capacity of the\n> channel is lower than the available onchain funds.\n> The swap-in can be credited immediately (and is limited\n> to the current total capacity) while additional funds\n> can be added to the channel via splice-in (which is\n> credited only once the splice-in is confirmed).\n>\n> As-is, a similar result can be obtained using openv1,\n> wherein a swap-in is combined with a channel open,\n> with the swap-in immediately credited while the channel\n> open is awaiting confirmation:\n>\n> * Alice and Bob currently have one or more existing\n>   channels, and Alice has a UTXO in a swap-in-potentiam\n>   address whose value exceeds the incoming capacity of\n>   the existing channel(s).\n> * Alice->Bob `open_channel`.\n> * Bob->Alice `accept_channel`.\n> * Alice->Bob `request_swap_in` with the \"change address\"\n>   being the funding address of the channel.\n> * Bob->Alice `accept_swap_in` provides the TXID of the\n>   funding transaction (Alice now knows the \"change\n>   address\" and the Bob final Resolved address, letting it\n>   know the final Resolved state transaction TXID).\n> * Alice->Bob `funding_created` with the TXID.\n> * Bob->Alice `funding_signed`.\n> * Alice->Bob `swap_in_signed` to provide the signature\n>   spending the swap-in-potentiam address to Bob.\n> * Bob then constructs an HTLC over the existing channel,\n>   which Alice claims, revealing the preimage.\n> * Alice->Bob `swap_in_resolved`.\n> * Bob then broadcasts the Resolved state transaction,\n>   which is also the funding transaction of the new channel.\n> * Both Alice and Bob await confirmation of the transaction\n>   in order to use the new channel.\n>   Alice can still use the existing channel, which has been\n>   topped-up with fresh outgoing capacity by the swap-in.\n>\n> (The above is not safe, as Bob can complete the protocol\n> by using the HTLC-offerring state transaction; this can\n> be fixed by having Alice open *2* channels with the same\n> amount, one with the HTLC-offering state transaction as\n> the funding tx, the other with the Resolved state\n> transaction as the funding tx, and later `error`ing the\n> channel corresponding to the transaction that is not\n> confirmed; this is left as an exercise to the reader,\n> though note that it requires two different change addresses\n> for Alice for both HTLC-offerring and Resolved states,\n> which can be arranged for the protocol)\n>\n> --\n>\n> [1]:\n> https://en.bitcoin.it/wiki/Payment_channels#CLTV-style_payment_channels\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230104/22436848/attachment-0001.html>", "summary": "A new scheme for bridging layer-1 and layer-2 systems transparently for users has been proposed, allowing wallets to give out addresses that are covert channel openings without the sender's knowledge. This would enable users to withdraw coins from an exchange straight into a channel by submitting an address without knowing precisely how much money they will receive to that address. The use of a covenant would mean the channel would not have an expiry date and therefore be a first-class citizen among channels."}, {"author": "Anthony Towns", "date": "2023-01-04T03:08:47", "message_text_only": "On Wed, Jan 04, 2023 at 01:06:36PM +1100, Lloyd Fournier wrote:\n> The advantage of using a covenant\n> is that the channel would not have an expiry date and therefore be a first\n> class citizen among channels.\n\nI think the approach here would be:\n\n * receive funds on the in-potentiam address with 8000 block CSV\n * LSP tracks immediately\n * user's wallet wakes up, LSP reports address to user, user signs\n   a funding tx to establish the channel, and the state 0 close tx\n * LSP considers it immediately active\n * LSP broadcasts the tx, targeting confirmation within 3 days\n * if the funding tx confirms promptly, you just have an ordinary channel\n * after 800 blocks, if the tx hasn't confirmed, LSP fee bumps or\n   closes the channel (relying on the high-feerate unilateral close\n   tx to do the fee bumping)\n\nie:\n\n day 0: someone -> in-potentiam address (payment made on-chain, confirmed)\n\n day 7: in-potentiam -> funding (wallet wakes up, tx signed and broadcast,\n          not necessarily confirmed, channel active)\n\n day 12: in-potentiam -> funding (confirmed)\n\n day 9999: funding -> unilateral/cooperative close\n\nor:\n\n day 0: someone -> in-potentiam address (payment made on-chain, confirmed)\n\n day 14: LSP forgets about in-potentiam utxo as its expiry is only 1000\n         blocks away\n\n day 420: in-potentiam -> wherever (payment made on-chain by user)\n\nSo while the tx introspection approach you advocate *would* allow the\nsetup phase to skip the \"expiry on day 14\" restriction, I think the\n*bigger* benefit is that you also wouldn't need the on-chain \"in-potentiam\n-> funding\" transaction, but could instead just leave the in-potentiam\ntx on chain indefinitely, until it was time to close the channel (which,\nif it was a cooperative close, could just be a musig key path spend).\n\nEither approach probably implies that you either have multiple channels\nwith your LSP (one for each in-potentiam payment you receive), or\nthat your single channel with your LSP is backed by multiple UTXOs\n(maybe you choose an order for them, so that Alice owns 100% of the\nbalance in utxos 1..(k-1) and Bob owns 100% of the balance in utxos\n(k+1)..n?). Otherwise you'd need an on-chain tx anyway to splice the new\nfunds into your existing channel; and that seems both annoying of itself,\nand probably bad for privacy.\n\nCheers,\naj", "summary": "A proposal for using a covenant to establish a channel without an expiry date, allowing it to be a first-class citizen among channels."}, {"author": "Olaoluwa Osuntokun", "date": "2023-01-04T03:02:23", "message_text_only": "Hi Z,\n\n> * Submarine swap/peerswap: Requires confirmation before the swap service\n> will send out the HTLC on Lightning.\n\nI might be missing something, but I don't see how this is different from a\nnormal on-chain to off-chain swap (calling this Loop In for short in the\nremainder of the email).\n\nGiven some static swap server params (server key, user key, preimage), a\nuser can derive a tapscript tree and use that to make addresses that any 3rd\nparty can send to. Services like Loop return a few addrs (including P2TR!)\nthe client can use depending on their wallet sophistication [1] (in this\ncase the command is: `loop in --amt=X --external\\, external means a 3rd\nparty will send to the addr). After a 3rd party sends to the script, the\nswap can be completed at anytime as soon as the client is online (assuming\nswap server is always there).\n\nIn the scenario above, the newly created outputs to our swap addr need to be\nconfirmed before the swap server will initiate the swap. As you mention,\nthis could even be zero conf assuming all sides take w/e precautions they're\ncomfortable with. If the swap server goes away for w/e reason, a long\ntimeout in the swap can let the user sweep the funds via some other\nmeans eventually. This doesn't need to be a direct swap either, and it can\nflow multi-hop like any other swap.\n\nIn your scheme you say that:\n\n> If so, then the \"timer for confirmation\" starts as soon as the wallet\n> receives on the blockchain, not as soon as the wallet decides to move\n> funds from blockchain to Lightning.\n\nWhich seems to be the exact same as the flow I described above. For our\nnewer musig2-enabled swaps, the top level keyspend can be spent by both\nparties, so you also emulate the ability for Alice to move the funds on\nchain anywhere else w/ the server's cooperation.\n\nUsing regular swaps also simplified the \"Bob Security\" section a lot, as Bob\nsends out an HTLC w/ the corresponding swap hash (he watches the chain for\nthe scripts, then initiates the swap once they're seen).\n\n[1]: https://lightning.engineering/api-docs/api/loop/swap-client/loop-in\n\n-- Laolu\n\nOn Tue, Jan 3, 2023 at 5:58 AM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Subject: Swap-in-Potentiam: Moving Onchain Funds \"Instantly\" To Lightning\n>\n> by Jesse Posner, ZmnSCPxj\n>\n> Introduction\n> ============\n>\n> Moving funds from an onchain-only address to Lightning Network is slow,\n> especially if you desire trust-minimization (which removes solutions\n> relying on 0-conf).\n>\n> Basically, to reduce trust requirements in all onchain transactions,\n> onchain receivers *MUST* ensure confirmation of the onchain transaction\n> that creates their UTXO.\n> In practice, the minimum should be at least 3 blocks, since reorgs of\n> up to 2 blocks are common occurences, but even 1 confirmation can\n> take an inordinately long time in the real world due to the random\n> nature of mining.\n>\n> This is particularly acute for mobile phone use-cases.\n> As mobile phones run on a battery, mobile phone OSs often greatly\n> restrict CPU and other resource consumption when an app is not\n> currently open by the user.\n>\n> Now consider this user story, for a wallet app that supports both\n> Bitcoin blockchain and Lightning Network operations:\n>\n> * The user wants to be paid over the Bitcoin blockchain.\n> * The user gets an address from their wallet and provides it to\n>   some other party to receive their payment.\n> * The user closes their wallet app, which causes the mobile phone\n>   OS to kill all its threads.\n> * The other party sends their payment over blockchain while the\n>   user is asleep.\n> * The blockchain transaction confirms and time passes.\n> * The user wakes up and checks their favorite blockchain explorer,\n>   and sees they received funds on their wallet address.\n> * The user opens their wallet app and decides they need a coffee,\n>   so they buy coffee over Lightning.\n>\n> For current solutions to move funds from the blockchain layer to\n> Lightning, however, the above user story would need to complete\n> over a long time, possibly measurable in dozens of minutes or\n> even hours in the worst case, due to the need for confirmation:\n>\n> * Channel open: Requires confirmation, many nodes require 6 or\n>   more confirmations.\n> * Submarine swap/peerswap: Requires confirmation before the swap\n>   service will send out the HTLC on Lightning.\n> * Splice-in: Channel remains operational, but until the splice\n>   transaction confirms, the channel operates in \"dual mode\"\n>   where both pre-splice and post-splice state is valid, and\n>   that means only the lower amount of the pre-splice and\n>   post-splice can be used in the mean time.\n>   For splice-in, the pre-splice amount will be lower, thus\n>   the amount being spliced in will not be credited until\n>   the splice transaction is confirmed.\n>\n> In this writeup, we present a novel protocol, swap-in-potentiam,\n> that can be used for immediate transfer from the blockchain\n> layer to the Lightning layer, in the above user story.\n>\n> Advantages And Limitations\n> --------------------------\n>\n> To whet your appetite, here are the advantages:\n>\n> * Immediate transfer of already-confirmed-received onchain\n>   funds to Lightning.\n> * Onchain funds can also be transferred to another onchain\n>   address (subject to normal onchain confirmation rules).\n>   * This can be \"immediate\" if sending to a receiver that\n>     accepts the risk of 0-conf onchain transactions.\n> * Minimized trust requirement.\n>\n> The disadvantages, to help convince you that yes, this is\n> technology and not magic beans (and to not oversell this\n> tech, Bitcoin media reporting often tend to oversell\n> new technologies because the disadvantages are often\n> hidden away behind technical minutae):\n>\n> * Requires a cooperating LSP.\n>   If LSP is down or refuses to cooperate, onchain funds\n>   are locked for some time.\n>   This has a timeout (so if the LSP never comes online\n>   again, you just wait out the timeout) and the timeout\n>   starts from when the receiving UTXO is confirmed in a\n>   blocks, so it will not cause loss of funds, only loss\n>   of opportunity (i.e. \"involuntary HODLing\").\n> * If you have multiple LSPs, when you generate an address\n>   you *have to* select one of them at that point, you\n>   *cannot* commit to multiple LSPs and select one of them\n>   later when your phone wakes up again.\n>   This exacerbates the above disadvantage, since you have\n>   to select one of your LSPs and hope that when your\n>   phone wakes up the LSP you selected is also up and\n>   cooperative.\n> * The onchain-received funds have to be confirmed first,\n>   otherwise we still need to wait for confirmation of the\n>   onchain-received funds.\n>   This is generally true for many blockchain-only wallets\n>   anyway and is thus not a worsening, but is also not an\n>   improvement.\n> * If the timeout is too near, actions must be performed\n>   onchain that require confirmation.\n>\n> Swap-in-Potentiam\n> =================\n>\n> All onchain fund movements, as noted, require confirmation.\n> These include onchain fund movements to the Lightning network.\n>\n> If the onchain address that the wallet provides was controlled\n> solely by that wallet, then any action that requires cooperation\n> with a Lightning Network participant --- channel open, swap, or\n> splice --- would require an onchain transaction that commits to\n> that specific Lightning Network participant.\n> Only when the new onchain transaction is confirmed, can that\n> Lightning participant rely on the transaction output without\n> having to trust the initiator.\n>\n> From there, we can consider: what if the wallet provides an\n> address that *already* commits to that specific Lightning Network\n> participant?\n>\n> If so, then the \"timer for confirmation\" starts as soon as\n> the wallet receives on the blockchain, not as soon as the wallet\n> decides to move funds from blockchain to Lightning.\n>\n> This is a significant difference for a mobile wallet: the mobile\n> environment does not support the mobile wallet being online for\n> long.\n> Thus, the mobile wallet may not have any CPU to make the decision\n> to move funds from blockchain to Lightning, until the actual user\n> explicitly opens the mobile wallet app.\n>\n> It has already been generally accepted that due to the limitations\n> of the mobile phone environment, a mobile phone wallet with\n> Lightning support would need some LSP anyway.\n> Thus, a mobile wallet that can receive on the blockchain layer\n> and then send on the Lightning layer can commit to a specific,\n> different, Lightning participant: the LSP it has channels with.\n>\n> Thus, the mobile wallet can provide an address that commits to\n> one particular Lightning Network participant: its LSP.\n>\n> The mobile wallet can then initiate a single-hop swap with the\n> LSP when the mobile wallet app is in the foreground and has CPU\n> to think with.\n> If it received funds into the address that have already been\n> confirmed, then it can do this single-hop swap immediately with\n> its LSP.\n> The LSP can immediately resolve this swap, crediting funds to\n> channel, while atomically ensuring it has sole claim to the\n> onchain UTXO.\n>\n> The Contract\n> ------------\n>\n> The contract has two participants: Alice the funds owner, and\n> Bob its potential swap partner.\n>\n> Once *any* funds have been confirmed received into an address\n> committing to this contract, Alice owns the funds and can\n> dispose of them as it likes (with cooperation from Bob).\n> The source of the funds need not be Alice, it could be a third\n> party that has an obligation to pay Alice onchain.\n>\n> The contract has only 2 branches:\n>\n> * Onchain/channel branch: Alice and Bob.\n> * Timelock branch: Alice plus a relative timelock (`OP_CSV`)\n>   measurable in weeks.\n>\n> Astute readers will realize that the above is really a variant\n> of [CLTV-style unidirectional time-limited channels][1],\n> themselves a variant of Spilman-style channels:\n>\n> * Uses an explicit opcode to simplify channel setup (no need\n>   to pre-sign a timeout transaction between Alice and Bob,\n>   can just send funds directly to the address).\n> * Uses a relative locktime instead of an absolute one to\n>   allow funding of the channel address (= receive onchain\n>   funds ready to spend over Lightning) at any time.\n>\n> The use-cases this enables are:\n>\n> * If Alice wants to pay to another onchain address, and Bob\n>   is also online and cooperative, Alice can ask Bob to help\n>   sign the Onchain/channel branch to move the funds in any\n>   arbitrary onchain manner.\n> * If Alice wants to pay to a Lightning invoice / keysend, and\n>   has insufficient Lightning outgoing capacity (but has\n>   sufficient *total* capacity), it can swap with Bob, by\n>   offerring a transaction that spends via the Onchain/channel\n>   branch and instantiates a fresh onchain HTLC that Bob can\n>   then forward over Lightning.\n>   As soon as Alice offers its signature of that transaction,\n>   Bob can immediately offer an in-Lightning HTLC to Alice on\n>   their channel, and then Alice can immediately resolve it\n>   (thus immediately getting its funds into Lightning).\n> * If Bob is offline or uncooperative, Alice can unilterally\n>   recover its funds after the timeout in the Timelock\n>   branch.\n>\n> Trust is required only to the extent that Alice trusts Bob to\n> be cooperative so that Alice can dispose of its funds immediately.\n> In case Bob turns out to be non-trustworthy, Alice can recover\n> its funds via the timelock branch after the timeout period.\n> There is no scope for Bob to steal funds (indeed, it is easier\n> for Bob to steal Lightning funds than to steal swap-in-potentiam\n> funds).\n>\n> The intent here is that the mobile wallet is Alice, while the\n> LSP is Bob.\n>\n> ### Bob Security\n>\n> Bob *MUST* ensure that, for each UTXO, it is either asked to\n> sign an arbitrary onchain transaction (i.e the first use-case\n> above) *OR* it gets offered an onchain HTLC from that UTXO.\n> Once Alice has asked Bob to cooperate in either case for a\n> particular UTXO, Bob *MUST* ensure that it does not sign the other\n> case (and Bob *MUST* refuse to cooperate in the other case once\n> one case has been requested).\n>\n> In addition, Bob *MUST* ensure that, if it is used in the\n> \"channel\" case (i.e. the second use-case above), the timeout of\n> the Timelock branch is far enough in the future that it is likely\n> that spends using the Onchain/channel branch have confirmed by\n> then.\n>\n> With both invariants enforced by Bob, Bob can ensure that, if\n> Alice requests a swap using the Onchain/channel branch, only Bob\n> can spend the UTXO (at least before the timeout), and thus can\n> safely offer a Lightning HTLC to Alice immediately without any\n> additional waiting for onchain confirmations.\n>\n> As Bob needs to know the UTXO in the first use-case above, this\n> requirement prevents the use of blind signing techniques when\n> implementing the first use-case.\n> Basically, when being asked to sign, Bob must generate the entire\n> `SIGHASH` from data that Alice provides, so that Bob is able to\n> keep track of UTXOs it is signing for.\n>\n> ### Remote Swap\n>\n> While Bob is generally considered \"the\" LSP of the mobile wallet\n> Alice, nothing in the Lightning protocol actually requires that\n> Bob be a direct peer of Alice.\n> The only real requirement is that Bob is able to send funds to\n> Alice over Lightning in exchange for possession of the equivalent\n> onchain funds.\n>\n> Against this, we should note that the mobile wallet is already\n> dependent on one or more LSPs anyway, so it may as well just use\n> its direct peer LSPs instead of a remote node.\n>\n> ### Address Derivation\n>\n> Swap-in-potentiam addresses can be derived from a root public or\n> private key.\n>\n> We only need one keypair each from Alice and Bob.\n> Alice can use standard derivation paths for its keypair.\n>\n> As Bob is intended to be an LSP, we can just use its Lightning\n> node ID as the public key.\n> Bob needs to be in possession of the corresponding private key\n> anyway in order to set up BOLT 8 encrypted transports.\n>\n> As LSPs are part of the public network, Alice can simply try to\n> scan for all published nodes that advertise support for\n> swap-in-potentiam.\n> Alternately if the wallet has a short list of fixed LSPs it\n> will use, it can simply refer to that list.\n>\n> Thus:\n>\n> * Alice uses a derived keypair.\n> * Bob uses a fixed keypair (its Lightning node ID).\n>\n> The above is sufficient to derive swap-in-potentiam addresses\n> from an `xprv` or `xpub` root key.\n>\n> Swap-in-potentiam For LSPs\n> ==========================\n>\n> While the original design of swap-in-potentiam has the mobile\n> wallet in the \"Alice\" role and its LSP in the \"Bob\" role, it\n> turns out that LSPs can provide special service to improve\n> receiving mobile wallets.\n>\n> Suppose that the LSP keeps track of statistics, and thus has\n> an idea of which of its mobile wallet clients are likely to\n> be net receivers.\n>\n> Net receivers will often have low inbound capacity (since the\n> inbound capacity has been used up during previous LN receives).\n>\n> During times of low onchain fees, an LSP can check which of its\n> offline mobile wallet clients have low inbound capacity, and are\n> likely to come online in the future to receive.\n> In those cases, the LSP can commit funds to a swap-in-potentiam\n> with the mobile client, with the LSP as \"Alice\" and the mobile\n> client as \"Bob\".\n> This at least lets the LSP set up half of a swap during a time of\n> low fees.\n>\n> If the transfer to swap-in-potentiam addresses is confirmed by\n> the time the mobile wallet client comes online, the LSP can\n> immediately initiate a swap, giving inbound capacity towards the\n> mobile client.\n> This swap can be immediately resolved, and allows the mobile\n> wallet client to immediately receive funds over Lightning.\n>\n> In particular, if \"offline receive\" as designed by TheBlueMatt\n> is implemented, then the LSP already has indication of a pending\n> payment towards an offline mobile wallet client.\n> The LSP can check if the offline mobile wallet client has\n> insufficient incoming capacity to receive the funds, and if so,\n> arrange to fund a swap-in-potentiam with that client.\n> Then, when the mobile wallet client comes online, the LSP can\n> initiate the swap with them, and once the swap completes (and\n> thus the mobile wallet client has sufficient incoming capacity)\n> the LSP can contact the sender LSP to complete the payment.\n>\n> In particular, this use-case allows for *immediate* receives as\n> soon as the mobile wallet client gets foregrounded and has CPU\n> time, **without** requiring 0-conf trusted transactions and\n> thus without requiring any kind of semi-custodial trust, even\n> if the mobile wallet client had insufficient incoming capacity.\n> A channel still has to be set up beforehand (without 0-conf, if\n> trusting funds to the LSP is undesirable).\n>\n> Implementation Sketch\n> =====================\n>\n> The intent is to use Taproot with Schnorr signatures, but\n> **without** using the keyspend path (at least initially).\n>\n> The plan currently is to use a `MuSig(A, B)` as the internal\n> pubkey, but with the branches still explicitly laid out as\n> tapleaves.\n> That is, there are two tapleaf SCRIPTs corresponding to the\n> two branches described above:\n>\n> * `<A> OP_CHECKSIGVERIFY <B> OP_CHECKSIG`\n> * `<timelock> OP_CHECKSEQUENCEVERIFY OP_DROP <A> OP_CHECKSIG`\n>\n> Using an explicit 2-of-2 branch rather than a MuSig allows\n> for a simple protocol at least for initial deployment:\n> we can have Alice send the signature using `A` in a single\n> half-round without having to engage in a 2-round MuSig2 signing\n> ritual.\n>\n> We intend to use Taproot since the mobile wallet client\n> may need to use a 2-of-3 or 2-of-2 signing scheme, similar\n> to Blockstream Green.\n> This allows either Alice or Bob in the contract to secretly\n> be a FROST 2-of-3 or MuSig 2-of-2 (or any FROST k-of-n or\n> MuSig n-of-n).\n> This is also another reason for avoiding a 2-of-2 MuSig\n> keyspend path between Alice and Bob, as there is (to our\n> knowledge) no publicly-reviewed security proof that\n> FROST-in-MuSig and MuSig-in-MuSig are safe (or the\n> corresponding variants using MuSig2 for the signing\n> ritual).\n>\n> Later, when we are more confident of the use of MuSig2 and\n> FROST inside a MuSig2, and with using MuSig2 with possibly\n> untrusted outsiders (who might exploit any mis-implementation\n> of the MuSig2 signing protocol if we are not careful with\n> designing it), we can seamlessly upgrade the protocol\n> to use the keyspend path later, to save witness bytes.\n>\n> For the Onchain use-case (i.e. Alice wants to spend the UTXO\n> to an onchain address), the protocol betweeen Alice and Bob\n> would be:\n>\n> * `request_arbitrary_signature` Alice->Bob: Requests Bob\n>   to sign a PSBT spending a swap-in-potentiam address\n>   using the Onchain branch.\n> * `response_arbitrary_signature` Bob->Alice: Response to\n>   the above, returning the requested signature.\n> * `reject_arbitrary_signature` Bob->Alice: Sent in\n>   response to `request_arbitary_signature` if Bob refuses\n>   to cooperate (e.g. the UTXO being spent has already\n>   been accepted by Bob in a Channel use-case below).\n>\n> For the Channel use-case (i.e. Alice wants to spend the UTXO\n> to a Lightning receiver), we operate the swap-in-potentiam\n> UTXO(s) as a Spilman-like channel over two states:\n>\n> * HTLC-offering: Offering an amount `N` HTLC from Alice to\n>   Bob, with any remaining amount to a change address to\n>   Alice.\n> * Resolved: Giving the amount `N` outright to Bob, with any\n>   remaining amount to a change address to Alice.\n>\n> The intention is that the channel is initially put into\n> the HTLC-offerring state.\n> Then Bob offers a corresponding in-Lightning HTLC to Alice\n> over their channel.\n> When Alice resolves the in-Lightning HTLC, it can then\n> send a new signature for the Resolved state.\n> Once the channel is in a Resolved state, Bob *SHOULD* sign\n> the last state and broadcast it on the blockchain, thereby\n> closing the Spilman-like channel.\n>\n> The protocol messages for the Channel use-case are:\n>\n> * `request_swap_in` Alice->Bob: Tell Bob the UTXOs with\n>   the same swap-in-potentiam address to spend, how\n>   much to put into the Alice->Bob channel direction,\n>   what channel to move into, and (optionally) a change\n>   address for Alice.\n> * `reject_swap_in` Bob->Alice: Sent in response to\n>   `request_swap_in` if Bob refuses to cooperate (e.g.\n>   one of the UTXOs on offer was already signed with\n>   `response_arbitrary_signature`, or Bob cannot legally\n>   accept control of funds from one or more of the UTXOs\n>   offerred).\n> * `accept_swap_in` Bob->Alice: Sent in response to\n>   `request_swap_in`, containing the Bob-side address to\n>   send funds to later once the state is Resolved.\n> * `swap_in_signed` Alice->Bob: Response to\n>   `accept_swap_in`, containing the Alice-side signature\n>   for the HTLC-offering state transaction.\n>   Once Bob receives this, Bob can safely construct a\n>   new on-Lightning HTLC using BOLT1\n>   `update_offer_htlc`.\n> * `swap_in_resolved` Alice->Bob: Sent after Alice has\n>   acquired the funds via `update_fulfill_htlc` of the\n>   corresponding on-Lightning HTLC, containing the\n>   Alice-side signature for the Resolved state\n>   transaction.\n>   The Resolved state transaction spends to the Bob-side\n>   address given in `accept_swap_in`, and any change to\n>   the Alice-side change address in `request_swap_in`.\n>\n> The plan is to reserve only one odd BOLT1 message ID,\n> and to embed the actual swap-in-potentiam message ID\n> as the first 2 bytes of the BOLT1 message, to reduce\n> pollution of the limited BOLT1 message ID space and to\n> allow more flexibility for swap-in-potentiam to expand\n> to new messages inside its own message ID space.\n>\n> For a richer future protocol, we will want to consider\n> how a swap-in can be combined with a splice-in.\n> This is useful if the current total capacity of the\n> channel is lower than the available onchain funds.\n> The swap-in can be credited immediately (and is limited\n> to the current total capacity) while additional funds\n> can be added to the channel via splice-in (which is\n> credited only once the splice-in is confirmed).\n>\n> As-is, a similar result can be obtained using openv1,\n> wherein a swap-in is combined with a channel open,\n> with the swap-in immediately credited while the channel\n> open is awaiting confirmation:\n>\n> * Alice and Bob currently have one or more existing\n>   channels, and Alice has a UTXO in a swap-in-potentiam\n>   address whose value exceeds the incoming capacity of\n>   the existing channel(s).\n> * Alice->Bob `open_channel`.\n> * Bob->Alice `accept_channel`.\n> * Alice->Bob `request_swap_in` with the \"change address\"\n>   being the funding address of the channel.\n> * Bob->Alice `accept_swap_in` provides the TXID of the\n>   funding transaction (Alice now knows the \"change\n>   address\" and the Bob final Resolved address, letting it\n>   know the final Resolved state transaction TXID).\n> * Alice->Bob `funding_created` with the TXID.\n> * Bob->Alice `funding_signed`.\n> * Alice->Bob `swap_in_signed` to provide the signature\n>   spending the swap-in-potentiam address to Bob.\n> * Bob then constructs an HTLC over the existing channel,\n>   which Alice claims, revealing the preimage.\n> * Alice->Bob `swap_in_resolved`.\n> * Bob then broadcasts the Resolved state transaction,\n>   which is also the funding transaction of the new channel.\n> * Both Alice and Bob await confirmation of the transaction\n>   in order to use the new channel.\n>   Alice can still use the existing channel, which has been\n>   topped-up with fresh outgoing capacity by the swap-in.\n>\n> (The above is not safe, as Bob can complete the protocol\n> by using the HTLC-offerring state transaction; this can\n> be fixed by having Alice open *2* channels with the same\n> amount, one with the HTLC-offering state transaction as\n> the funding tx, the other with the Resolved state\n> transaction as the funding tx, and later `error`ing the\n> channel corresponding to the transaction that is not\n> confirmed; this is left as an exercise to the reader,\n> though note that it requires two different change addresses\n> for Alice for both HTLC-offerring and Resolved states,\n> which can be arranged for the protocol)\n>\n> --\n>\n> [1]:\n> https://en.bitcoin.it/wiki/Payment_channels#CLTV-style_payment_channels\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230103/5b5b2cad/attachment-0001.html>", "summary": "A proposal for a faster way to move funds from an on-chain address to the Lightning Network using regular swaps, which simplifies the process and reduces trust requirements."}, {"author": "ZmnSCPxj", "date": "2023-01-04T15:11:06", "message_text_only": "Good morning Laolu,\n\n\n> Hi Z,\n> \n> > * Submarine swap/peerswap: Requires confirmation before the swap service\n> > will send out the HTLC on Lightning.\n> \n> I might be missing something, but I don't see how this is different from a\n> normal on-chain to off-chain swap (calling this Loop In for short in the\n> remainder of the email).\n> \n> Given some static swap server params (server key, user key, preimage), a\n> user can derive a tapscript tree and use that to make addresses that any 3rd\n> party can send to. Services like Loop return a few addrs (including P2TR!)\n> the client can use depending on their wallet sophistication [1] (in this\n> case the command is: `loop in --amt=X --external\\, external means a 3rd\n> party will send to the addr). After a 3rd party sends to the script, the\n> swap can be completed at anytime as soon as the client is online (assuming\n> swap server is always there).\n> \n> In the scenario above, the newly created outputs to our swap addr need to be\n> confirmed before the swap server will initiate the swap. As you mention,\n> this could even be zero conf assuming all sides take w/e precautions they're\n> comfortable with. If the swap server goes away for w/e reason, a long\n> timeout in the swap can let the user sweep the funds via some other\n> means eventually. This doesn't need to be a direct swap either, and it can\n> flow multi-hop like any other swap.\n> \n> In your scheme you say that:\n> \n> > If so, then the \"timer for confirmation\" starts as soon as the wallet\n> > receives on the blockchain, not as soon as the wallet decides to move\n> > funds from blockchain to Lightning.\n> \n> Which seems to be the exact same as the flow I described above. For our\n> newer musig2-enabled swaps, the top level keyspend can be spent by both\n> parties, so you also emulate the ability for Alice to move the funds on\n> chain anywhere else w/ the server's cooperation.\n> \n> Using regular swaps also simplified the \"Bob Security\" section a lot, as Bob\n> sends out an HTLC w/ the corresponding swap hash (he watches the chain for\n> the scripts, then initiates the swap once they're seen).\n> \n> [1]: https://lightning.engineering/api-docs/api/loop/swap-client/loop-in\n\nQuick question: is the address given by the `loop in --external` command safe for reuse?\n\nIn many common onchain-only wallets **available today**, you can do something like get a receive address and add it to your forum sig or on a static webpage or forum post or whatever, and then anyone can send to it, possibly multiple times with different amounts coming from different people.\n\nThe fact that `loop in` requires a specific `--amt=X` flag suggests to me that the address generated is not safe for address reuse (in particular, once *one* swap has completed, I am almost sure that any future funds to the same address can be stolen by the swap server without handing it over to the purported owner of the funds).\n\nSwap-in-potentiam is safe for address reuse, because each UTXO for the same address backs a new, separate swap (if Alice wanted it).\nThe advantage is that:\n\n* You get stable addresses that are safe for reuse (which is already possible today on non-Lightning wallets, so people already do this today).\n* Those stable addresses can still be spent from quickly on the Lightning Network as soon as they are reasonably confirmed.\n\nRegards,\nZmnSCPxj", "summary": "The proposed submarine swap/peerswap is not different from a normal on-chain to off-chain swap. The address generated by the `loop in --external` command may not be safe for reuse."}, {"author": "Olaoluwa Osuntokun", "date": "2023-01-05T02:07:51", "message_text_only": "Hi Z,\n\n> Quick question: is the address given by the `loop in --external` command\nsafe\n> for reuse?\n\nThx for this question, I think this is the key difference I was looking for\n(not the aspect about confirmations, since that's no different). Since that\naddress contains a swap hash in the script, it's not safe to reuse (just\nlike a\nvanilla invoice on LN today: ppl will learn the pre-image).\n\nThe potentiam swap is effectively a sort of deferred two stage swap. The\nLoop\nIn swap I described earlier it complete after two transactions: initial\nswap tx\nconfirmation, and the swap by the user. This swap can only be complete after\nthree transactions: initial deferred \"no-premium swaption\" (Alice can swap,\nor\njust leave it for a while), swap transaction confirmation (Alice initiates\nw/\nthe HTLC added), and final sweep.\n\nSo this swap is less efficient from an on-chain perspective (2 vs 3 txns),\nbut\nit gives Alice more optionality. Both variants however enable the final step\n(sweeping on chain) to be batched with other related or distinct swaps.\n\nI think one can make the Loop In swap addr pseudo-reusable by adding a\n\"cancel\"\nleaf in the rooted tapscript. It would slow down the process though, as\nyou'd\nneed another level of relative timeout for Alice to get the funds back. Ofc,\nall this is muuuch nicer w/ proper covenants ;).\n\n> The fact that `loop in` requires a specific `--amt=X` flag suggests to me\n> that the address generated is not safe for address reuse\n\nThe amt field can in theory be left out of the flow, with the swap server\njust\nassuming w/e was sent to the address is the sending amt.\n\n> Swap-in-potentiam is safe for address reuse, because each UTXO for the\nsame\n> address backs a new, separate swap (if Alice wanted it).  The advantage is\n> that:\n\nIndeed, if I were to re-write your initial post, I'd lead with this as (to\nmyself at least) it makes the contribution of this scheme much clearer.\n\n-- Laolu\n\n\nOn Wed, Jan 4, 2023 at 7:11 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n>\n> Good morning Laolu,\n>\n>\n> > Hi Z,\n> >\n> > > * Submarine swap/peerswap: Requires confirmation before the swap\n> service\n> > > will send out the HTLC on Lightning.\n> >\n> > I might be missing something, but I don't see how this is different from\n> a\n> > normal on-chain to off-chain swap (calling this Loop In for short in the\n> > remainder of the email).\n> >\n> > Given some static swap server params (server key, user key, preimage), a\n> > user can derive a tapscript tree and use that to make addresses that any\n> 3rd\n> > party can send to. Services like Loop return a few addrs (including\n> P2TR!)\n> > the client can use depending on their wallet sophistication [1] (in this\n> > case the command is: `loop in --amt=X --external\\, external means a 3rd\n> > party will send to the addr). After a 3rd party sends to the script, the\n> > swap can be completed at anytime as soon as the client is online\n> (assuming\n> > swap server is always there).\n> >\n> > In the scenario above, the newly created outputs to our swap addr need\n> to be\n> > confirmed before the swap server will initiate the swap. As you mention,\n> > this could even be zero conf assuming all sides take w/e precautions\n> they're\n> > comfortable with. If the swap server goes away for w/e reason, a long\n> > timeout in the swap can let the user sweep the funds via some other\n> > means eventually. This doesn't need to be a direct swap either, and it\n> can\n> > flow multi-hop like any other swap.\n> >\n> > In your scheme you say that:\n> >\n> > > If so, then the \"timer for confirmation\" starts as soon as the wallet\n> > > receives on the blockchain, not as soon as the wallet decides to move\n> > > funds from blockchain to Lightning.\n> >\n> > Which seems to be the exact same as the flow I described above. For our\n> > newer musig2-enabled swaps, the top level keyspend can be spent by both\n> > parties, so you also emulate the ability for Alice to move the funds on\n> > chain anywhere else w/ the server's cooperation.\n> >\n> > Using regular swaps also simplified the \"Bob Security\" section a lot, as\n> Bob\n> > sends out an HTLC w/ the corresponding swap hash (he watches the chain\n> for\n> > the scripts, then initiates the swap once they're seen).\n> >\n> > [1]: https://lightning.engineering/api-docs/api/loop/swap-client/loop-in\n>\n> Quick question: is the address given by the `loop in --external` command\n> safe for reuse?\n>\n> In many common onchain-only wallets **available today**, you can do\n> something like get a receive address and add it to your forum sig or on a\n> static webpage or forum post or whatever, and then anyone can send to it,\n> possibly multiple times with different amounts coming from different people.\n>\n> The fact that `loop in` requires a specific `--amt=X` flag suggests to me\n> that the address generated is not safe for address reuse (in particular,\n> once *one* swap has completed, I am almost sure that any future funds to\n> the same address can be stolen by the swap server without handing it over\n> to the purported owner of the funds).\n>\n> Swap-in-potentiam is safe for address reuse, because each UTXO for the\n> same address backs a new, separate swap (if Alice wanted it).\n> The advantage is that:\n>\n> * You get stable addresses that are safe for reuse (which is already\n> possible today on non-Lightning wallets, so people already do this today).\n> * Those stable addresses can still be spent from quickly on the Lightning\n> Network as soon as they are reasonably confirmed.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230104/75286083/attachment.html>", "summary": "The address generated by the Loop In command is not safe for reuse as it contains a swap hash in the script. The Potentiam swap is a deferred two-stage swap that is less efficient but gives Alice more optionality. The Swap-in-potentiam is safe for address reuse."}], "thread_summary": {"title": "Swap-in-Potentiam: Moving Onchain Funds \"Instantly\" To Lightning", "categories": ["Lightning-dev"], "authors": ["Olaoluwa Osuntokun", "David A. Harding", "Jesse Posner", "ZmnSCPxj", "Anthony Towns", "Lloyd Fournier"], "messages_count": 8, "total_messages_chars_count": 86902, "convo_summary": "A new protocol called swap-in-potentiam allows for immediate transfer of onchain funds to Lightning Network, reducing the time required for confirmation. Several proposals were made for faster ways to move funds from on-chain to Lightning Network, including a covenant to establish a channel without an expiry date and a scheme for bridging layer-1 and layer-2 systems transparently for users. The proposed submarine swap/peerswap is not different from a normal on-chain to off-chain swap, but the address generated by the Loop In command is not safe for reuse."}}, {"title": "[Lightning-dev] Two-party eltoo w/ punishment", "thread_messages": [{"author": "Antoine Riard", "date": "2023-01-05T23:59:42", "message_text_only": "Hi AJ,\n\n> Chia uses different terminology to bitcoin; \"puzzle\" is just what we call\n> \"scriptPubKey\" in bitcoin, more or less. Since its scripting capabilities\n> are pretty powerful, you can rig up a TLUV/OP_EVICT like mechanism, but\n> for a two-party setup, in practice I think that mostly just means you\n> can encode the logic directly as script, and when updating the state you\n> then only need to exchange CHECKSIGFROMSTACK-like signatures along the\n> lines of \"state N implies outputs of A,B,C,... -- Alice\", rather than\n> signing multiple transactions.\n\nIn the multi-party setup, encoding more of the unrolling logic directly as\nscript could be a witness space gain, I guess. To express a channel\nfactory/payment pool withdrawal, at the minimum I think you need an\namount/exit scriptPubKey committed by the signature. Or maybe the output\nvalue could be a spent input amount distribution among a set of signers, if\nyou would like some non-interactive pre-funded scheme.\n\n> If you have fully symmetric transactions, then you could have the\n> situation where Alice broadcasts update K, then attacks Bob and when\n> he attempts to post update N, she instead does a pinning attack by\n> broadcasting update K+1 (spending update K), which then forces Bob to\n> generate a new version update N, which she then blocks with update K+2,\n> etc. An attack like that is presumably pretty difficult to pull off in\n> practice, but it makes it pretty hard to reason about many of the limits.\n>\n> A simple advantage to breaking the symmetry is that if A does a unilateral\n> close, then B can immediately confirm that closure releasing all funds\n> for both parties. Without breaking the symmetry, you can't distinguish\n> that case from B attempting to confirm his own unilateral close, which\n> would allow B to cheat.\n\nYes, IIUC the proposed flow is UA.n -> CB.n -> money, and in this\noptimistic case, there is only one CLTV delay to respect the spend of the\nUA. In terms of timevalue cost to redeem all the funds, I think this is\nmaking the cost equivalent for all the parties. With today's LN-penalty,\nthe broadcaster balance is encumbered by the CSV delay, not the\ncounterparty one.\n\n(Note on the gist, the UA state description includes a Pa or tapscript \"IF\nCODESEP n OP_CLTV DROP ENDIF 1 CHECKSIG\" as spendable paths and the CA.n\nstate description nSequence = 0, so I'm not sure how the update/justice\ndelay is enforced)\n\n> Yes, you can unilaterally close the channel with state N-1; but even\n> then they might respond by bumping to state N anyway. If that happens,\n> then the funds can remain locked up until the timeout, as you can no\n> longer time the htlc out off-chain.\n>\n> Still, if it's one hung per htlc for the channel's entire lifetime\n> (because you close it \"immediately\" when it happens), that's probably\n> not going to cause problems frequently...\n\nI think here the issue can be corrected by selecting conservatively your\nimplementation channel breakout timers, you should go to chain with the\nstate N-1 with X buffer of block and ensure your CLTV delta are always\nbigger than X, where X=delay * 2. That way even if your counterparty is\nbroadcasting state N at X-1, your htlc-timeout should be safe, I guess.\n\n> If Alice is dishonest, and posts a very old state (n-x), then Bob could\n> post up to x watchtower txs (WB.(n-x+1) .. WB.n) causing Alice to be\n> unable to access her funds for up to (x+1)*to_self_delay blocks. But\n> that's just a reason for her to not be dishonest in the first place.\n\nSo I think there still is the case of Bob broadcasting a very old state and\nAlice's watchtowers colluding to prevent Alice's honest funds access,\npotentially preventing the HTLC-timeout, IIUC. I don't know if we're not\nintroducing some changes in the trust assumptions towards watchtowers where\nwith vanilla eltoo a single compromised watchtower can be corrected by the\nhonest channel holder or another watchtower, iirc.\n\n> No -- the RB.n transactions immediately release A's funds after applying\n> the penalty, so if the watchtower colludes with A and has an old RB.y\n> transaction, Alice can steal funds by posting UA.x and RB.y, provided that\n> her balance now is sufficiently less than her balance then (ie bal.n <\n> bal.y - penalty).\n>\n> In this model, Bob shouldn't be signing RB.n or CB.n txs until Alice\n> has already started a unilateral close and posted UA.n/UA.k.\n\nSo the penalty transactions should not be delegated to untrusted\nwatchtowers. In case of RB.n signing key compromise, the whole channel\nfunds might be lost.\n\n> Doesn't generalise to redundant untrusted watchtowers though, but\n> presumably nothing does. (You could use the same utxo across multiple\n> watchtowers, but a rogue watchtower could just post an old WA.k tx and\n> claim your funds, preventing some honest watchtower from helping)\n\nSo you could have a channel balance between the watchtower and yourself,\nwhere the tower balance is the payment for the WA.n broadcast, and there is\nan assumption the balance is cooperatively updated to adjust for on-chain\nfees. For sure, I'm not sure either how it would generalize to an untrusted\nwatchtower, where interactions might be even bounded to avoid leak of the\nclient identity.\n\nStill, I think eltoo channels would simplify the implementation of\ndistributed towers by Lightning implementation, notably handling concurrent\nbroadcast w.r.t chain asynchronicity issues, and hopefully removing the\nconcern of commitment transaction key duplication by tower [0].\n\nBest,\nAntoine\n\n[0] https://github.com/lightningdevkit/rust-lightning/pull/679\n\nLe ven. 9 d\u00e9c. 2022 \u00e0 01:55, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> On Thu, Dec 08, 2022 at 02:14:06PM -0500, Antoine Riard wrote:\n> > >  - 2022-10-21, eltoo/chia:\n> > https://twitter.com/bramcohen/status/1583122833932099585\n> > On the eltoo/chia variant, from my (quick) understanding, the main\n> > innovation aimed for is\n>\n> I'd say the main innovation aimed for is just doing something like\n> lightning over the top of chia (rather than bitcoin, liquid, ethereum\n> etc), and making it simple enough to be easily implemented.\n>\n> > the limitation of the publication of eltoo states\n> > more than once by a counterparty, by introducing a cryptographic puzzle,\n> > where the witness can be produced once and only once ? I would say you\n> > might need the inheritance of the updated scriptpubkey across the chain\n> of\n> > eltoo states, with a TLUV-like mechanism.\n>\n> Chia uses different terminology to bitcoin; \"puzzle\" is just what we call\n> \"scriptPubKey\" in bitcoin, more or less. Since its scripting capabilities\n> are pretty powerful, you can rig up a TLUV/OP_EVICT like mechanism, but\n> for a two-party setup, in practice I think that mostly just means you\n> can encode the logic directly as script, and when updating the state you\n> then only need to exchange CHECKSIGFROMSTACK-like signatures along the\n> lines of \"state N implies outputs of A,B,C,... -- Alice\", rather than\n> signing multiple transactions.\n>\n> > > The basic idea is \"if it's a two party channel with just Alice and Bob,\n> > > then if Alice starts a unilateral close, then she's already had her\n> say,\n> > > so it's only Bob's opinion that matters from now on, and he should be\n> > > able to act immediately\", and once it's only Bob's opinion that\n> matters,\n> > > you can simplify a bunch of things.\n> > From my understanding, assuming Eltoo paper terminology, Alice can\n> publish\n> > an update K transaction, and then after Bob can publish an update\n> > transaction K<N or Alice can publish the settlement transaction N, or Bob\n> > can publish an update transaction N. The main advantage of this\n> > construction I can see is a strict bound on the shared_delay encumbered\n> in\n> > the on-chain publication of the channel ?\n>\n> If you have fully symmetric transactions, then you could have the\n> situation where Alice broadcasts update K, then attacks Bob and when\n> he attempts to post update N, she instead does a pinning attack by\n> broadcasting update K+1 (spending update K), which then forces Bob to\n> generate a new version update N, which she then blocks with update K+2,\n> etc. An attack like that is presumably pretty difficult to pull off in\n> practice, but it makes it pretty hard to reason about many of the limits.\n>\n> A simple advantage to breaking the symmetry is that if A does a unilateral\n> close, then B can immediately confirm that closure releasing all funds\n> for both parties. Without breaking the symmetry, you can't distinguish\n> that case from B attempting to confirm his own unilateral close, which\n> would allow B to cheat.\n>\n> > > fast forwards: we might want to allow our channel partner\n> > > to immediately rely on a new state we propose without needing a\n> > > round-trip delay -- this potentially makes forwarding payments much\n> > > faster (though with some risk of locking the funds up, if you do a\n> > > fast forward to someone who's gone offline)\n> >\n> > IIRC, there has already been a \"fast-forward\" protocol upgrade proposal\n> > based on update-turn in the LN-penalty paradigm [0]. I think reducing the\n> > latency of HTLC propagation across payment paths would constitute a UX\n> > improvement, especially a link-level update mechanism upgrade deployment\n> > might be incentivized by routing algorithms starting to penalize routing\n> > hops HTLC relay latency. What is unclear is the additional risk of\n> locking\n> > the funds up. If you don't receive acknowledgement the fast forward state\n> > has been received, you should still be able to exit with the state N-1 ?\n>\n> Yes, you can unilaterally close the channel with state N-1; but even\n> then they might respond by bumping to state N anyway. If that happens,\n> then the funds can remain locked up until the timeout, as you can no\n> longer time the htlc out off-chain.\n>\n> Still, if it's one hung per htlc for the channel's entire lifetime\n> (because you close it \"immediately\" when it happens), that's probably\n> not going to cause problems frequently...\n>\n> > > doubled delays: once we publish the latest state we can, we want to\n> > > be able to claim the funds immediately after to_self_delay expires;\n> > > however if our counterparty has signatures for a newer state than we\n> > > do (which will happen if it was fast forwarded), they could post that\n> > > state shortly before to_self_delay expires, potentially increasing\n> > > the total delay to 2*to_self_delay.\n> >\n> > While the 2*to_self_delay sounds the maximum time delay in the state\n> > publication scenario where the cheating counterparty publishes a old\n> state\n> > then the honest counterparty publishes the latest one, there could be the\n> > case where the cheating counterparty broadcast chain of old states, up to\n> > mempool's `limitancestorcount`. However, this chain of eltoo transactions\n> > could be replaced by the honest party paying a higher-feerate (assuming\n> > something like nversion=3).\n>\n> With the asymmetric transactions proposed here, you'd need to have your\n> watchtowers collude with the attacker for this to happen.\n>\n> I think you could prevent chains from building up in the mempool by\n> requiring a relative timelock of perhaps 2 or 3 blocks for a WA.n/WB.n\n> tx to be valid (giving you time to post RA.n/RB.n in the meantime).\n>\n> > > * WA.n, WB.n : watchtower update to state n\n> > >   - this is for an untrusted watchtower to correct attempted cheating\n> > >     by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n> > >     (or UA.k/WB.k) respectively, provided k < n.\n> > I wonder if the introduction of watchtower specific transactions doesn't\n> > break the 2*to_self_delay assumption\n>\n> The to_self_delay applies to whoever initiated the unilateral close,\n> and provided they actually posted the most recent state, no watchtower\n> tx is a valid spend. ie, if Alice is honest and n is the latest state,\n> then the only possible spends of UA.n are SA.n (after a delay) or CB.n,\n> and as soon as either of those are on chain, she gets access to her funds.\n> No version of WB.k or RB.k (or WA.k, CA.k, RA.k) are valid if k<=n and\n> UA.n is confirmed.\n>\n> If Alice is dishonest, and posts a very old state (n-x), then Bob could\n> post up to x watchtower txs (WB.(n-x+1) .. WB.n) causing Alice to be\n> unable to access her funds for up to (x+1)*to_self_delay blocks. But\n> that's just a reason for her to not be dishonest in the first place.\n>\n> > (iiuc it's a design goal of current\n> > protocol) and what is the design rationale. Beyond that, there is a\n> concern\n> > with watchtower-specific transactions, it might leak your towers topology\n> > (i.e the number of them and the distribution in the p2p network) to an\n> > adversary.\n>\n> If you have a watchtower and it takes action, I don't think you can\n> expect to retain privacy over the fact that you have a watchtower,\n> and how effective it is against an attacker with extensive monitoring\n> of the p2p network...\n>\n> > > * SA.n, SB.n : slowly claim funds according to state n\n> > >   - this is for Alice to claim her funds if Bob is completely offline\n> > >     (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n> > >     timelock of to_self_delay.\n> >\n> > If I'm following correctly the description, this is logically equivalent\n> to\n> > the sweep of a `to_local`/`to_remote` output on a commitment transaction\n> > though instead the waiting delay is eltoo shared_delay. There is no\n> > to_self_delay, at the punishment seems only to happen on the\n> update-level,\n> > or maybe one should be also able to punish slow fund exit, and another\n> > relative locktime should exist on the S* transactions.\n>\n> I'm just using \"to_self_delay\" as the X in \"if you attempt to cheat,\n> I'll definitely notice and take action within X blocks\". If you post\n> UA.n then post SA.n after X blocks (due to SA.n's relative time lock)\n> then you've already proven you didn't cheat, because that was enough\n> time for B to notice and take action.\n>\n> > > * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n> > >     F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n> > Could the punishment transactions R* be also delegated to watchtowers,\n> > assuming they have been pre-signed to lockdown the exit scriptpubkeys ?\n>\n> No -- the RB.n transactions immediately release A's funds after applying\n> the penalty, so if the watchtower colludes with A and has an old RB.y\n> transaction, Alice can steal funds by posting UA.x and RB.y, provided that\n> her balance now is sufficiently less than her balance then (ie bal.n <\n> bal.y - penalty).\n>\n> In this model, Bob shouldn't be signing RB.n or CB.n txs until Alice\n> has already started a unilateral close and posted UA.n/UA.k.\n>\n> > > In order to allow fast-forwards, when Alice proposes a new state,\n> > > she needs to send her partial signatures to allow Bob to unilaterally\n> > > accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n> > > also needs to be able to claim the funds if Bob proposes the new state\n> > > and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n> > > achieved with an adaptor signature approach (spelt out a bit more fully\n> > > in the gist) or a CTV-like approach, provided that UB.n reveals the\n> > > state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n> > >\n> >\n> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n> > ).\n> >\n> > If you would like to have fast forward of chain of transactions, I wonder\n> > if there could be also the \"sig-in-the-script\" trick, where UB.n\n> > scriptpubkey (or one of its tapscripts) contains the signature for CB.n,\n> > SB.n, RB.n. Though you might have an issue of re-generating the\n> > witnessscript in case of state loss.\n>\n> Broadcasting UB.n will only reveal signatures by B; so that would only\n> potentially help with CA.n or RA.n; and if UB.n is on-chain, then RA.n\n> isn't valid (since it would require \"n < n\").\n>\n> The EXPR_SETTLE stuff in the github link describes how to do the trick\n> via a CTV-ish approach (including an APO signature in a tapscript in the\n> scriptPubKey of UA.n here; and including data in the annex so that you\n> can recalculate thinks if an old UA.n is broadcast after you've\n> forgotten n's state details).\n>\n> > > * how to pay watchtowers -- when a watchtower broadcasts a W\n> > >   transaction, it needs to add fees, and it's not clear (to me) how it\n> > >   could fairly and reliably ensure it's compensated for those costs,\n> > >   particularly if multiple W transactions are broadcast for a single\n> > >   unilateral close attempt, due to one or more watchtowers colluding\n> > >   with an attacker, or simply having out of date information.\n> > I wonder if paying a watchtower, or getting paid as a watchtower isn't  a\n> > \"counterparty risk\" similar to what is happening with jamming due to\n> > non-covered HTLC forward risk.\n>\n> Actually, perhaps you could \"yo dawg\" it: if you give the watchtower a\n> pre-signed transaction WA.n:\n>\n>     input 1: UA.k/WA.k (ANYPREVOUTANYSCRIPT, SINGLE)\n>     input 2: my funds (SINGLE, ALL)\n>\n>     output 1: WA.n\n>     output 2: new lightning channel between me and watchtower\n>     output 3: ephemeral OP_TRUE output\n>\n> then you could have the \"new lightning channel\" be setup with an initial\n> capacity of \"my funds\", and off-chain update the state of that channel so\n> that the watchtower's balance is how much you're willing to contribute in\n> fees if the watchtower does its job. If you set things up so that you're\n> always able to claim a penalty via WA.n->RA.n if the watchtower acts,\n> then you can give up to that penalty to the watchtower and still end up\n> making a profit.\n>\n> Doesn't generalise to redundant untrusted watchtowers though, but\n> presumably nothing does. (You could use the same utxo across multiple\n> watchtowers, but a rogue watchtower could just post an old WA.k tx and\n> claim your funds, preventing some honest watchtower from helping)\n>\n> (Yo dawg, I heard you liked closing lightning channels, so we put a\n> lightning channel in your watchtower, so you can close a channel while\n> you're closing a channel. Alternatively: \"when god closes one channel,\n> he opens another\")\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230105/a6627adb/attachment-0001.html>", "summary": "The article discusses the use of Chia's scripting capabilities in multi-party setups and breaking symmetry to prevent cheating in unilateral channel closures."}, {"author": "Anthony Towns", "date": "2023-01-06T04:19:53", "message_text_only": "On Thu, Jan 05, 2023 at 06:59:42PM -0500, Antoine Riard wrote:\n> > A simple advantage to breaking the symmetry is that if A does a unilateral\n> > close, then B can immediately confirm that closure releasing all funds\n> > for both parties. Without breaking the symmetry, you can't distinguish\n> > that case from B attempting to confirm his own unilateral close, which\n> > would allow B to cheat.\n> Yes, IIUC the proposed flow is UA.n -> CB.n -> money, and in this\n> optimistic case, there is only one CLTV delay to respect the spend of the\n> UA.\n\nThe only delay in the UA.n/CB.n case is if someone's trying to redeem\nan HTLC that times out in the future, in which case you might have UA.n,\nCB.n, (CB.n -> A's balance), (CB.n -> B's balance), (CB.n -> A claiming\nHTLC x with preimage x') all in the same block, but (CB.n -> A claiming\nHTLC y at timeout) happening 100 blocks later, when y times out.\n\n> (Note on the gist, the UA state description includes a Pa or tapscript \"IF\n> CODESEP n OP_CLTV DROP ENDIF 1 CHECKSIG\" as spendable paths and the CA.n\n> state description nSequence = 0, so I'm not sure how the update/justice\n> delay is enforced)\n\n(Note that the CLTV here is just for eltoo state ratcheting, and is\nalways in the past so doesn't imply an actual delay)\n\nCA.n is only able to spend UB.n, not UA.n. (Or it can spend WA.n, but\nWA.n can only spend UB.k or prior WA.k, so it means much the same\nthing).\n\nThat's achievable by having the CA.n signature use ANYPREVOUT rather than\nANYPREVOUTANYSCRIPT (thus committing to UB.n/WA.n's shared scriptPubKey)\nand having different scriptPubKey's between UA.n and UB.n (which breaks\nthe symmetry).\n\nSA.n spends UA.n or WB.n in the same way, except also sets nSequence to\nforce a relative timelock.\n\n> > If Alice is dishonest, and posts a very old state (n-x), then Bob could\n> > post up to x watchtower txs (WB.(n-x+1) .. WB.n) causing Alice to be\n> > unable to access her funds for up to (x+1)*to_self_delay blocks. But\n> > that's just a reason for her to not be dishonest in the first place.\n> So I think there still is the case of Bob broadcasting a very old state and\n> Alice's watchtowers colluding to prevent Alice's honest funds access,\n> potentially preventing the HTLC-timeout, IIUC.\n\nAlice was the dishonest one here, so it'd be Alice broadcasting an old\nstate, preventing Bob from accessing funds.\n\nIf you're not online and have no honest watchtowers, then Alice can just\nbroadcast an old state, wait for the delay, and confirm the old state\n(UA.k -> SA.k), and steal as much as she wants.\n\nIf you are online, or have honest watchtowers, then your honest CB.n\nor WB.n can be confirmed in the same block as 2000 dishonest WB.(k+1),\nWA.(k+2) txs. The point of having a watchtower helping you out is that the\nwatchtower can do fancier things than your lightning node on your phone,\nlike observe the mempool and potentially have direct relationships with\nmining pools to overcome things like the 25 tx ancestor/descendant limit.\n\n> I don't know if we're not\n> introducing some changes in the trust assumptions towards watchtowers where\n> with vanilla eltoo a single compromised watchtower can be corrected by the\n> honest channel holder or another watchtower, iirc.\n\nThe same scenario applies in traditional eltoo, except in that case\nAlice doesn't need to compromise any of Bob's watchtowers, she can\njust broadcast multiple states herself -- since the txs are symmetric,\nthere's no difference between Alice.1 -> Alice.2 and Alice.1 -> Bob.2;\nso you can't allow the latter while preventing the former (and there's\nlikewise no difference between those and Alice.1 -> Watchtower.2).\n\n> > No -- the RB.n transactions immediately release A's funds after applying\n> > the penalty, so if the watchtower colludes with A and has an old RB.y\n> > transaction, Alice can steal funds by posting UA.x and RB.y, provided that\n> > her balance now is sufficiently less than her balance then (ie bal.n <\n> > bal.y - penalty).\n> >\n> > In this model, Bob shouldn't be signing RB.n or CB.n txs until Alice\n> > has already started a unilateral close and posted UA.n/UA.k.\n> So the penalty transactions should not be delegated to untrusted\n> watchtowers. \n\nYes.\n\n> In case of RB.n signing key compromise, the whole channel\n> funds might be lost.\n\nCompromise of pretty much any of the signing keys allows all the channel\nfunds to be lost; this is always true of the key used for signing\ncooperative closes, for instance.\n\nIf you do want to delegate punishment, you could probably have an\nalternative setup where every watchtower transaction implies punishment.\n\n(I assume watchtower punishment needs to be all or nothing, otherwise a\ncompromised watchtower would just rbf any attempts to punish, switching\nthem over to non-punishment, which then encourages attackers to compromise\nwatchtowers (and prioritise attacking people who use their compromised\nwatchtowers), and you'd end up with \"nothing\" anyway...)\n\nSomething like:\n\nno-punishment:\n  UA.n -> delay -> SA.n (keypath)\n  UA.k -> CB.n         (k <= n)\n\npunishment of Alice:\n  UA.k -> RB.n         (k < n - X)\n  UA.k -> WB.n         (k < n)\n  WB.k -> WB.n         (k < n)\n  WB.k -> RB.n         (k <= n)\n  WB.n -> delay -> TA.n\n\nwhere A only signs WB.n when the state has already updated to n+X,\nand TA.n/RB.n transfers the punishment amount from A's balance to B's\nbalance compared to SA.n/CB.n.\n\nThat introduces an extra signature per state for TA.n, and probably an\nadditional one given the different constraints for RB.n when spending\nUA.k vs WB.k.\n\nCheers,\naj", "summary": "The proposed lightning network update breaks symmetry to prevent cheating and allow for immediate confirmation of closure, but there are still potential vulnerabilities."}], "thread_summary": {"title": "Two-party eltoo w/ punishment", "categories": ["Lightning-dev"], "authors": ["Antoine Riard", "Anthony Towns"], "messages_count": 2, "total_messages_chars_count": 24006, "convo_summary": "The article and discussion revolve around the use of Chia's scripting capabilities and the proposed lightning network update to prevent cheating and vulnerabilities in unilateral channel closures. The update breaks symmetry and allows for immediate confirmation of closure, but there are still potential vulnerabilities."}}, {"title": "[Lightning-dev] Async payments proof-of-payment: a wishlist for researchers", "thread_messages": [{"author": "vwallace", "date": "2023-01-10T19:41:09", "message_text_only": "Hi list!\n\nThis email is a belated Christmas wishlist for interested researchers to solve an open question in lightning.\n\nFor context, recently there\u2019s been some discussion about supporting \u201casync payments\u201d[1]. Supporting this feature would mean that e.g. a mobile noncustodial user would be able to receive payments even if they\u2019re regularly offline. See the linked email and preliminary spec PR[2] for details on this scheme.\n\nThe open research question relates to how the sender will get an invoice from the receiver, given that they are offline at sending-time. If the receiver trusts their LSP, this is easy \u2013 they\u2019ll give their LSP a bunch of invoices ahead of time, and trust the LSP to never provide the same one twice, since doing this would allow the LSP (or some intermediate node on the path) to steal the funds, due to already knowing the preimage.\n\nThis trust isn\u2019t ideal, obviously. In the original ML email[1], the solution presented to this problem is PTLCs. However, upon further investigation, it turns out that the current PTLCs design wouldn\u2019t solve this problem: the LSP would be able to steal funds the same as before, see [3].\n\nNote that even if we don\u2019t want to trust LSPs, this problem doesn\u2019t halt async payment progress entirely: the working solution for now is for the receiver\u2019s LSP to provide a reusable keysend[4] invoice to senders. The current thinking is that BOLT12 invoices will add a feature bit to support keysend, and the recipient\u2019s BOLT12 offer will direct senders to its LSP to retrieve the keysend invoice. This isn\u2019t ideal because it loses the proof-of-payment property, but it seems OK as a stopgap.\n\nSo more specifically, the research question is: what is a scheme that allows a regularly-offline receiver to create a reusable invoice for their LSP to provide to senders, such that senders have proof-of-payment? This may ideally be built on top of PTLCs. **Note that while the recipient may be offline when the sender initiates the payment, the recipient will come back online some time later to fulfill the incoming payment.**\n\nA possible direction suggested by BlueMatt could be to stick with keysend, but have the sender encode a nonce + the time they sent the payment + the payment amount as a tweak to the keysend PTLC point (as well as in the onion), and make the receiver tweak their point with the same data when fulfilling the payment. Such a scheme may force the receiver to commit to the sender-encoded data[5], which wouldn\u2019t exactly provide proof-of-payment, but would allow the sender to prove \u201cI sent X amount at Y time.\u201d Handwave handwave.\n\nThoughts welcome!\n\nCheers,\n\nVal\n\n[1]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003307.html\n\n[2]: https://github.com/lightning/bolts/pull/989\n\n[3]: https://github.com/lightning/bolts/pull/989#issuecomment-1325389542\n\n[4]: https://github.com/lightning/blips/blob/master/blip-0003.md\n\n[5]: https://github.com/lightning/bolts/pull/989#issuecomment-1327881563\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230110/8bab4c04/attachment.html>", "summary": "Lightning developers are seeking a solution to enable offline receivers to create a reusable invoice for their LSP to provide to senders with proof-of-payment."}, {"author": "Olaoluwa Osuntokun", "date": "2023-01-11T01:35:28", "message_text_only": "Hi Val,\n\nHappy to see ppl continue to work on the problem space after discussions and\nbrainstorming we had at the past LN Summit in Oakland.\n\n> The open research question relates to how the sender will get an invoice\n> from the receiver, given that they are offline at sending-time\n\nOne existing protocol extension that solves this is AMP [1][2]. The AMP\ninvoice is fully reusable (tho it can expire), and can be posted anywhere on\nthe internet, enabling a sender to at least _attempt_ the payment without\nthe receiver being online. As the sender is the one that generates the\npre-image, it's easy to prevent payment hash re-use (generate a new root\nhash, just like you do a shared secret when making an onion). The LSP (or\nanyone else) can't steal the funds, as the pre-image shares are in the final\nhop of the onion payload, which can only be decrypted by the receiver.\n\nEach payment can use the payment_addr/payment_secret field in the\ninvoice, but then also generate a new set_id for each logical payment. The\nset_id is included in the final hop payload, which lets the receiver\naggregate the HTLCs until they can finally settle it after recovering the\nroot payment pre-image.\n\nInvoice negotiation protocols such as BOLT 12, LN-URL, and Lightning Address\ncan also be used to fetch a self-contained AMP invoice.\n\nHere's a testnet AMP invoice that can be paid w/ any amt:\n```\nlntb1p3murampp56m9m254s7xduktrm7g6j5r7qrpw9kvzc2tpqul7eskhyqfh95lnqdqqcqzpgxq9z0rgqsp5eyam7wajd3mmwk9qmfthzk3t96s0rklv05tc49ak68p8wvks0cmq9q8pqqqssq3jvnkdqn289fd7l3w2weqps89p9zaan4xlqenj3tmclwwkjgudrzn9jvvmkzgemehrdc7dlg4z7sxu0hmeul55keewqk0kdulc6058qpu644f8\n```\n\n> such that senders have proof-of-payment? This may ideally be built on top\n> of PTLCs\n\nI can't find the original slides (the old LN Conf URL seems to just redirect\nto the Fulmo website now), but back in the day, Conner gave a talk about an\nAMP extension he called \"invoice tunneling\". The idea is that you force the\nreceiver to reveal a unique secret bound to the invoice or payment attempt.\nRather than having the set_id be a 32-byte value, it would instead be a\npoint and mixed in along all the transmitted partial HTLC shares. In order\nto settle the HTLC, both the secret of the point in the original invoice, as\nwell as the sender provided root payment pre-image would be required.\n\nAs usual though, I'm pretty dubious of any sort of \"proof of payment\"\nschemes. Particularly given that virtual no wallets today (UI-wise) give you\ndirect access to a pre-image, there's no standard that has emerged yet\n(seemingly due to a lack of an actual need) to encode such information, and\nalso most schemes would let any 3rd party that learned the pre-image (an\nintermediate node) to claim that they sent the payment (w/o any other\nasymmetric crypto).\n\nCircling back to the discussion in Oakland, one of my key takeaways was\nthat: Trampoline payments are a critical part of any sort of async payment\nscheme. Otherwise, you'll require the sender to be online in a synchronous\nmanner as _they're_ the ones that need to retry the payment continually.\n\nWith Trampoline payments, the sender's \"LSP\" can retry the payment at will\nw/o needing to fetch a fresh onion each time. With that the entire flow can\nbe async:\n\n  1. user tries initial payment\n  2. LSP gets it, can delay the initial try to \"phone home\" to the receiver\n  3. HTLC eventually gets the penultimate (second to last hop before the\n  receiver)\n  4. Receiver comes online eventually to reveal pre-image\n  5. pre-image propagates backwards thru the route\n  6. sender eventually comes back online again to acknowledge receipt\n\nWith the way LN works, once step 4 is reached, then the payment has\neffectively been completed from the PoV of the receiver (UI can update,\netc). With AMP usage, the receiver also doesn't need to be online for the\nsender to even _attempt_ to make a payment.\n\n-- Laolu\n\n[1]: https://github.com/lightning/bolts/pull/658\n[2]: https://docs.lightning.engineering/lightning-network-tools/lnd/amp\n\nOn Tue, Jan 10, 2023 at 11:41 AM vwallace via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hi list!\n>\n> This email is a belated Christmas wishlist for interested researchers to\n> solve an open question in lightning.\n>\n> For context, recently there\u2019s been some discussion about supporting \u201casync\n> payments\u201d[1]. Supporting this feature would mean that e.g. a mobile\n> noncustodial user would be able to receive payments even if they\u2019re\n> regularly offline. See the linked email and preliminary spec PR[2] for\n> details on this scheme.\n>\n> The open research question relates to how the sender will get an invoice\n> from the receiver, given that they are offline at sending-time. If the\n> receiver trusts their LSP, this is easy \u2013 they\u2019ll give their LSP a bunch of\n> invoices ahead of time, and trust the LSP to never provide the same one\n> twice, since doing this would allow the LSP (or some intermediate node on\n> the path) to steal the funds, due to already knowing the preimage.\n>\n> This trust isn\u2019t ideal, obviously. In the original ML email[1], the\n> solution presented to this problem is PTLCs. However, upon further\n> investigation, it turns out that the current PTLCs design wouldn\u2019t solve\n> this problem: the LSP would be able to steal funds the same as before, see\n> [3].\n>\n> Note that even if we don\u2019t want to trust LSPs, this problem doesn\u2019t halt\n> async payment progress entirely: the working solution for now is for the\n> receiver\u2019s LSP to provide a reusable keysend[4] invoice to senders. The\n> current thinking is that BOLT12 invoices will add a feature bit to support\n> keysend, and the recipient\u2019s BOLT12 offer will direct senders to its LSP to\n> retrieve the keysend invoice. This isn\u2019t ideal because it loses the\n> proof-of-payment property, but it seems OK as a stopgap.\n>\n> So more specifically, the research question is: what is a scheme that\n> allows a regularly-offline receiver to create a reusable invoice for their\n> LSP to provide to senders, such that senders have proof-of-payment? This\n> may ideally be built on top of PTLCs. **Note that while the recipient may\n> be offline when the sender initiates the payment, the recipient will come\n> back online some time later to fulfill the incoming payment.**\n>\n> A possible direction suggested by BlueMatt could be to stick with keysend,\n> but have the sender encode a nonce + the time they sent the payment + the\n> payment amount as a tweak to the keysend PTLC point (as well as in the\n> onion), and make the receiver tweak their point with the same data when\n> fulfilling the payment. Such a scheme may force the receiver to commit to\n> the sender-encoded data[5], which wouldn\u2019t exactly provide\n> proof-of-payment, but would allow the sender to prove \u201cI sent X amount at Y\n> time.\u201d Handwave handwave.\n>\n> Thoughts welcome!\n>\n> Cheers,\n>\n> Val\n>\n> [1]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003307.html\n>\n>\n> [2]: https://github.com/lightning/bolts/pull/989\n>\n> [3]: https://github.com/lightning/bolts/pull/989#issuecomment-1325389542\n>\n> [4]: https://github.com/lightning/blips/blob/master/blip-0003.md\n> [5]: https://github.com/lightning/bolts/pull/989#issuecomment-1327881563\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230110/f1b1ffe6/attachment-0001.html>", "summary": "The open research question is how the sender will get an invoice from the receiver, given that they are offline at sending-time. One existing protocol extension that solves this is AMP."}, {"author": "vwallace", "date": "2023-01-12T23:05:29", "message_text_only": "Hi Laolu,\n\nTo your point about AMP \u2013 yeah, posting an AMP invoice or serving it over LNURL/BOLT12 seems equivalent to the keysend scheme outlined in my email. The current design is based on BOLT12 because it has broader support. I think others have pointed this out, but it would be useful to see a spec PR for the AMP reusable invoice format rather than high-level API docs, otherwise (a) it\u2019s hard to evaluate using it for async payments and (b) it hasn\u2019t gone through a stage of garnering community feedback.\n\n> one of my key takeaways was that: Trampoline payments are a critical part of any sort of async payment scheme.\n\n100% agreed with this point and explanation; async payments are not very interesting without trampoline.\n\n> \"invoice tunneling\". The idea is that you force the receiver to reveal a unique secret bound to the invoice or payment attempt.\n\nI would be interested to read more about this, it sounds like it\u2019s thinking along similar lines to Matt\u2019s idea mentioned at the end of my email, which is also outlined in the notes from an async payments meeting[1]. Though if it\u2019s HTLCs-based, then I don\u2019t see how it would work without changes to the onchain script format to commit to additional data, since you can\u2019t change the preimage(?).\n\nWhether PoP is necessary or not seems like a separate discussion to me :p the current HTLCs-based async payments plan does not have the PoP property anyway, but it would be nice to have a plan for how we *could* have it in the future, hence the research wishlist.\n\n-Val\n\n[1]: https://docs.google.com/document/d/1X6Hap9Hi5qJ9a-XVXmLILol2cBcpXExutw6-adPLAb0/edit\n\n------- Original Message -------\nOn Tuesday, January 10th, 2023 at 5:35 PM, Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n\n> Hi Val,\n>\n> Happy to see ppl continue to work on the problem space after discussions and\n> brainstorming we had at the past LN Summit in Oakland.\n>\n>> The open research question relates to how the sender will get an invoice\n>> from the receiver, given that they are offline at sending-time\n>\n> One existing protocol extension that solves this is AMP [1][2]. The AMP\n> invoice is fully reusable (tho it can expire), and can be posted anywhere on\n> the internet, enabling a sender to at least _attempt_ the payment without\n> the receiver being online. As the sender is the one that generates the\n> pre-image, it's easy to prevent payment hash re-use (generate a new root\n> hash, just like you do a shared secret when making an onion). The LSP (or\n> anyone else) can't steal the funds, as the pre-image shares are in the final\n> hop of the onion payload, which can only be decrypted by the receiver.\n>\n> Each payment can use the payment_addr/payment_secret field in the\n> invoice, but then also generate a new set_id for each logical payment. The\n> set_id is included in the final hop payload, which lets the receiver\n> aggregate the HTLCs until they can finally settle it after recovering the\n> root payment pre-image.\n>\n> Invoice negotiation protocols such as BOLT 12, LN-URL, and Lightning Address\n> can also be used to fetch a self-contained AMP invoice.\n>\n> Here's a testnet AMP invoice that can be paid w/ any amt:\n> ```\n> lntb1p3murampp56m9m254s7xduktrm7g6j5r7qrpw9kvzc2tpqul7eskhyqfh95lnqdqqcqzpgxq9z0rgqsp5eyam7wajd3mmwk9qmfthzk3t96s0rklv05tc49ak68p8wvks0cmq9q8pqqqssq3jvnkdqn289fd7l3w2weqps89p9zaan4xlqenj3tmclwwkjgudrzn9jvvmkzgemehrdc7dlg4z7sxu0hmeul55keewqk0kdulc6058qpu644f8\n> ```\n>\n>> such that senders have proof-of-payment? This may ideally be built on top\n>> of PTLCs\n>\n> I can't find the original slides (the old LN Conf URL seems to just redirect\n> to the Fulmo website now), but back in the day, Conner gave a talk about an\n> AMP extension he called \"invoice tunneling\". The idea is that you force the\n> receiver to reveal a unique secret bound to the invoice or payment attempt.\n> Rather than having the set_id be a 32-byte value, it would instead be a\n> point and mixed in along all the transmitted partial HTLC shares. In order\n> to settle the HTLC, both the secret of the point in the original invoice, as\n> well as the sender provided root payment pre-image would be required.\n>\n> As usual though, I'm pretty dubious of any sort of \"proof of payment\"\n> schemes. Particularly given that virtual no wallets today (UI-wise) give you\n> direct access to a pre-image, there's no standard that has emerged yet\n> (seemingly due to a lack of an actual need) to encode such information, and\n> also most schemes would let any 3rd party that learned the pre-image (an\n> intermediate node) to claim that they sent the payment (w/o any other\n> asymmetric crypto).\n>\n> Circling back to the discussion in Oakland, one of my key takeaways was\n> that: Trampoline payments are a critical part of any sort of async payment\n> scheme. Otherwise, you'll require the sender to be online in a synchronous\n> manner as _they're_ the ones that need to retry the payment continually.\n>\n> With Trampoline payments, the sender's \"LSP\" can retry the payment at will\n> w/o needing to fetch a fresh onion each time. With that the entire flow can\n> be async:\n>\n> 1. user tries initial payment\n> 2. LSP gets it, can delay the initial try to \"phone home\" to the receiver\n> 3. HTLC eventually gets the penultimate (second to last hop before the\n> receiver)\n> 4. Receiver comes online eventually to reveal pre-image\n> 5. pre-image propagates backwards thru the route\n> 6. sender eventually comes back online again to acknowledge receipt\n>\n> With the way LN works, once step 4 is reached, then the payment has\n> effectively been completed from the PoV of the receiver (UI can update,\n> etc). With AMP usage, the receiver also doesn't need to be online for the\n> sender to even _attempt_ to make a payment.\n>\n> -- Laolu\n>\n> [1]: https://github.com/lightning/bolts/pull/658\n> [2]: https://docs.lightning.engineering/lightning-network-tools/lnd/amp\n>\n> On Tue, Jan 10, 2023 at 11:41 AM vwallace via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi list!\n>>\n>> This email is a belated Christmas wishlist for interested researchers to solve an open question in lightning.\n>>\n>> For context, recently there\u2019s been some discussion about supporting \u201casync payments\u201d[1]. Supporting this feature would mean that e.g. a mobile noncustodial user would be able to receive payments even if they\u2019re regularly offline. See the linked email and preliminary spec PR[2] for details on this scheme.\n>>\n>> The open research question relates to how the sender will get an invoice from the receiver, given that they are offline at sending-time. If the receiver trusts their LSP, this is easy \u2013 they\u2019ll give their LSP a bunch of invoices ahead of time, and trust the LSP to never provide the same one twice, since doing this would allow the LSP (or some intermediate node on the path) to steal the funds, due to already knowing the preimage.\n>>\n>> This trust isn\u2019t ideal, obviously. In the original ML email[1], the solution presented to this problem is PTLCs. However, upon further investigation, it turns out that the current PTLCs design wouldn\u2019t solve this problem: the LSP would be able to steal funds the same as before, see [3].\n>>\n>> Note that even if we don\u2019t want to trust LSPs, this problem doesn\u2019t halt async payment progress entirely: the working solution for now is for the receiver\u2019s LSP to provide a reusable keysend[4] invoice to senders. The current thinking is that BOLT12 invoices will add a feature bit to support keysend, and the recipient\u2019s BOLT12 offer will direct senders to its LSP to retrieve the keysend invoice. This isn\u2019t ideal because it loses the proof-of-payment property, but it seems OK as a stopgap.\n>>\n>> So more specifically, the research question is: what is a scheme that allows a regularly-offline receiver to create a reusable invoice for their LSP to provide to senders, such that senders have proof-of-payment? This may ideally be built on top of PTLCs. **Note that while the recipient may be offline when the sender initiates the payment, the recipient will come back online some time later to fulfill the incoming payment.**\n>>\n>> A possible direction suggested by BlueMatt could be to stick with keysend, but have the sender encode a nonce + the time they sent the payment + the payment amount as a tweak to the keysend PTLC point (as well as in the onion), and make the receiver tweak their point with the same data when fulfilling the payment. Such a scheme may force the receiver to commit to the sender-encoded data[5], which wouldn\u2019t exactly provide proof-of-payment, but would allow the sender to prove \u201cI sent X amount at Y time.\u201d Handwave handwave.\n>>\n>> Thoughts welcome!\n>>\n>> Cheers,\n>>\n>> Val\n>>\n>> [1]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003307.html\n>>\n>> [2]: https://github.com/lightning/bolts/pull/989\n>>\n>> [3]: https://github.com/lightning/bolts/pull/989#issuecomment-1325389542\n>>\n>> [4]: https://github.com/lightning/blips/blob/master/blip-0003.md\n>>\n>> [5]: https://github.com/lightning/bolts/pull/989#issuecomment-1327881563\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230112/22bf5df0/attachment-0001.html>", "summary": "The use of AMP invoices or serving them over LNURL/BOLT12 is equivalent to the keysend scheme, but a spec PR for the AMP reusable invoice format is needed for community feedback. Trampoline payments are critical for async payments, and \"invoice tunneling\" may be a solution, but changes to the onchain script format may be necessary. PoP is a separate discussion, but having a plan for it in the future would be nice."}, {"author": "vwallace", "date": "2023-01-25T23:50:52", "message_text_only": "Hey all,\n\nThe research question still stands, but I wanted to issue a correction to this email \u2013\n\n> However, upon further investigation, it turns out that the current PTLCs design wouldn\u2019t solve this problem: the LSP would be able to steal funds the same as before, see [3].\n\nThis is not true: if a regular PTLCs-based invoice generated by the receiver was given out multiple times by the receiver\u2019s LSP, said LSP would not be able to steal the payment funds. This is because payers randomly tweak each hop\u2019s point on every payment attempt, so the receiver\u2019s LSP never learns the invoice\u2019s original secret (unlike with HTLCs, where every hop learns the payment preimage). Further, the LSP would also need to know the sum of the aforementioned per-hop tweaks to steal, and they only know the tweak corresponding to their own hop. See this helpful PTLCs diagram from my teammate Arik: https://imgur.com/a/ZpdbYrt\n\nNote that PTLC invoices when reused still do not provide PoP because the same secret would be revealed to every payer on every payment.\n\nThanks,\nVal\n\n------- Original Message -------\nOn Tuesday, January 10th, 2023 at 2:41 PM, vwallace <vwallace at protonmail.com> wrote:\n\n> Hi list!\n>\n> This email is a belated Christmas wishlist for interested researchers to solve an open question in lightning.\n>\n> For context, recently there\u2019s been some discussion about supporting \u201casync payments\u201d[1]. Supporting this feature would mean that e.g. a mobile noncustodial user would be able to receive payments even if they\u2019re regularly offline. See the linked email and preliminary spec PR[2] for details on this scheme.\n>\n> The open research question relates to how the sender will get an invoice from the receiver, given that they are offline at sending-time. If the receiver trusts their LSP, this is easy \u2013 they\u2019ll give their LSP a bunch of invoices ahead of time, and trust the LSP to never provide the same one twice, since doing this would allow the LSP (or some intermediate node on the path) to steal the funds, due to already knowing the preimage.\n>\n> This trust isn\u2019t ideal, obviously. In the original ML email[1], the solution presented to this problem is PTLCs. However, upon further investigation, it turns out that the current PTLCs design wouldn\u2019t solve this problem: the LSP would be able to steal funds the same as before, see [3].\n>\n> Note that even if we don\u2019t want to trust LSPs, this problem doesn\u2019t halt async payment progress entirely: the working solution for now is for the receiver\u2019s LSP to provide a reusable keysend[4] invoice to senders. The current thinking is that BOLT12 invoices will add a feature bit to support keysend, and the recipient\u2019s BOLT12 offer will direct senders to its LSP to retrieve the keysend invoice. This isn\u2019t ideal because it loses the proof-of-payment property, but it seems OK as a stopgap.\n>\n> So more specifically, the research question is: what is a scheme that allows a regularly-offline receiver to create a reusable invoice for their LSP to provide to senders, such that senders have proof-of-payment? This may ideally be built on top of PTLCs. **Note that while the recipient may be offline when the sender initiates the payment, the recipient will come back online some time later to fulfill the incoming payment.**\n>\n> A possible direction suggested by BlueMatt could be to stick with keysend, but have the sender encode a nonce + the time they sent the payment + the payment amount as a tweak to the keysend PTLC point (as well as in the onion), and make the receiver tweak their point with the same data when fulfilling the payment. Such a scheme may force the receiver to commit to the sender-encoded data[5], which wouldn\u2019t exactly provide proof-of-payment, but would allow the sender to prove \u201cI sent X amount at Y time.\u201d Handwave handwave.\n>\n> Thoughts welcome!\n>\n> Cheers,\n>\n> Val\n>\n> [1]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003307.html\n>\n> [2]: https://github.com/lightning/bolts/pull/989\n>\n> [3]: https://github.com/lightning/bolts/pull/989#issuecomment-1325389542\n>\n> [4]: https://github.com/lightning/blips/blob/master/blip-0003.md\n>\n> [5]: https://github.com/lightning/bolts/pull/989#issuecomment-1327881563\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230125/5b96b964/attachment.html>", "summary": "Lightning Network researchers seek a solution for offline receivers to create reusable invoices for their LSPs without compromising security. PTLCs may be a solution."}, {"author": "Anthony Towns", "date": "2023-01-26T01:04:12", "message_text_only": "On Tue, Jan 10, 2023 at 07:41:09PM +0000, vwallace via Lightning-dev wrote:\n> The open research question relates to how the sender will get an invoice from the receiver, given that they are offline at sending-time.\n\nAssuming the overall process is:\n\n * Alice sends a payment to Bob, who has provided a reusable address\n   AddrBob\n * Bob is offline at the time the payment is sent, but his semi-trusted\n   LSP Larry is online\n * Alice is willing/able to do bidirectional communication with Larry\n * The payment does not complete until Bob is online (at which point\n   Alice may be offline)\n\nI think in this case you want to aim for the receipt to be a BIP340\nsignature of the message \"Alice has paid me $50 -- signed Bob\".\n\nGiven Bob's public signature nonce, R, Alice (and Larry) can calculate\nS = R + H(R,P,m)*P (m is the receipt message, P is Bob's public key),\nand then Alice can send a PTLC conditional on revealing the log of S, ie\ns where s*G=S; and at that point (s, R) is a valid signature by Bob of a\nmessage confirming payment to Bob, which then serves as the final receipt.\n\nHowever for this to work, Alice needs to discover \"R\" while Bob is\noffline. I think this is only doable if Bob pre-generates a set of\nnonces and shares the public part with Larry, who can then share them\nwith potential payers.  I think to avoid attacks via Wagner's algorithm,\nyou probably need to do a similar setup as musig2 does, ie share (R1,R2)\npairs, and calculate R = H(P,R1,R2,m)*R1+R2.\n\nSo a setup like:\n\n  Alice gets AddrBob. Decodes Bob's pubkey, Larry's pubkey, and the\n  route to Larry.\n\n  Alice -> Larry: \"Hi, I want to send Bob $50, and get a receipt\"\n  Larry -> Alice: \"The nonce for that will be R\"\n  Alice: calculates m = \"Hash(\"Alice paid Bob $50\"), S = R+H(R,P,m)*P\n  Alice -> Larry(for Bob): PTLC[$50, S]\n\n  Larry -> Bob: PTLC[$50, S]\n                Alice wants to pay you $50, using nonce pair #12345\n  Bob: verifies nonce #12345 has not been previously used, calculates R,\n       calculates m, calculates s, and checks that s*G = S, checks\n       there's a $50 PTLC conditional on S waiting for confirmation.\n  Bob -> Alice: claims $50 from PTLC by revealing s\n\n  Alice: receives s; (R,s) serves as Bob's signature confirming payment\n\nseems plausible?\n\nEvery \"S\" here commits to a value chosen by the sender (ie, their\n\"identity\"), so there's no way for Larry to get two different payers\nto use the same S. Using the same nonce twice will just mean Bob has to\nreject the payment (and find a new LSP).\n\nIt may make sense to require Alice to make a micropayment to Larry in\norder to claim a nonce. You'd want a standard template for \"m\" so that\nit's easy to generate and parse consistently, of course.\n\nI think you could even have separate LSPs if you wanted: one to issue\nnonces while you're offline, and the other to actually hold onto incoming\nPTLCs while you're offline.\n\nFWIW, some previous discussion, which didn't focus on offline recipients:\n\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/001034.html\n\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001490.html\n\nCheers,\naj", "summary": "The open research question is how the sender will receive an invoice from the offline receiver. A possible solution is to use BIP340 signature and nonce sharing."}], "thread_summary": {"title": "Async payments proof-of-payment: a wishlist for researchers", "categories": ["Lightning-dev"], "authors": ["Olaoluwa Osuntokun", "vwallace", "Anthony Towns"], "messages_count": 5, "total_messages_chars_count": 27770, "convo_summary": "Lightning developers are looking for a way for offline receivers to create reusable invoices for their LSPs to provide to senders with proof-of-payment. One solution is AMP invoices or serving them over LNURL/BOLT12. Trampoline payments and \"invoice tunneling\" may also be options. PTLCs and BIP340 signature and nonce sharing are being considered for security."}}, {"title": "[Lightning-dev] Reputation Credentials renaming and iteration: the Staking Credentials architecture", "thread_messages": [{"author": "Antoine Riard", "date": "2023-01-12T21:24:37", "message_text_only": "Hi LN devs,\n\nFollowing the November proposal of mitigating channel jamming with\nReputation Credentials, started to document the protocol architecture.\nAfter feedback on the naming protocol itself, I switched to Staking\nCredentials. In fact the proposed architecture enables mitigations\ndeployment both within a reputation strategy or a monetary strategy in\nfunction of the base collateral considered (proof-of-utxo ownership or\non-chain/off-chain payments).\n\nThe main advance is the clear separation of the credentials issuance phase\nfrom the redemption phase. Participants in the architecture have been\nabstracted to answer multiple types of Lightning deployment: credentials\nissuance and redemption fully-sourced on the client-side, issuance\ndelegation where the credentials mining is delegated to a LSP, redemption\ndelegation where the credentials are attached on the fly to a HTLC by a hop\nsupporting trampoline. Abstraction has been done also on the routing-hop\nside, where the credentials issuer can be dissociated from the routing hop\nagainst which it can be redeemed (to allow \"phantom node\" style of\ndeployment [0]).\n\nThe credentials redemption mechanism itself has been abstracted to cover\ndiverse Lightning channel counterparty risks, with a primary focus on HTLC\njamming. Beyond, the redemption flow could be easily deployed to solve the\nrisk asymmetries brought by the signature release flow in the context of\ndual-funding/splicing.\n\nArchitecture document is available here:\nhttps://github.com/ariard/lightning-rfc/blob/2022-11-reputation-credentials/60-staking-credentials-archi.md\n\nCredential issuance phase, redemption phase, onion communication channels\nas credential transport protocol, credentials data format, cryptographic\nprimitives used for unlinking and recommendations for risk-management\nstrategy (among others) should land in their own documents with time.\n\nNext focus on advancing the work-in-progress implementation:\nhttps://github.com/ariard/lightning-risk-engine\n\nModule is designed to be uncoupled from LDK architecture specifics and\ngeneric to minimize interdependencies with independent advances in channel\ntypes/transaction-relay policy.\n\nCheers,\nAntoine\n\n[0] https://lightningdevkit.org/blog/introducing-phantom-node-payments/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230112/7ab3d050/attachment.html>", "summary": "Lightning Network developers are documenting a protocol architecture for mitigating channel jamming with Staking Credentials, enabling deployment within a reputation or monetary strategy. The architecture separates the credentials issuance phase from the redemption phase and abstracts participants to answer multiple types of Lightning deployment. The credentials redemption mechanism covers diverse Lightning channel counterparty risks, with a primary focus on HTLC jamming. The module is designed to be uncoupled from LDK architecture specifics and generic to minimize interdependencies with independent advances in channel types/transaction-relay policy."}], "thread_summary": {"title": "Reputation Credentials renaming and iteration: the Staking Credentials architecture", "categories": ["Lightning-dev"], "authors": ["Antoine Riard"], "messages_count": 1, "total_messages_chars_count": 2447}}, {"title": "[Lightning-dev] A new Bitcoin implementation integrated with Core Lightning", "thread_messages": [{"author": "Michael Folkson", "date": "2023-01-14T20:26:07", "message_text_only": "I tweeted this [0] back in November 2022.\n\n\"With the btcd bugs and the analysis paralysis on a RBF policy option in Core increasingly thinking @BitcoinKnots and consensus compatible forks of Core are the future. Gonna chalk that one up to another thing @LukeDashjr was right about all along.\"\n\nA new bare bones Knots style Bitcoin implementation (in C++/C) integrated with Core Lightning was a long term idea I had (and presumably many others have had) but the dysfunction on the Bitcoin Core project this week (if anything it has been getting worse over time, not better) has made me start to take the idea more seriously. It is clear to me that the current way the Bitcoin Core project is being managed is not how I would like an open source project to be managed. Very little discussion is public anymore and decisions seem to be increasingly made behind closed doors or in private IRC channels (to the extent that decisions are made at all). Core Lightning seems to have the opposite problem. It is managed effectively in the open (admittedly with fewer contributors) but doesn't have the eyeballs or the usage that Bitcoin Core does. Regardless, selfishly I at some point would like a bare bones Bitcoin and Lightning implementation integrated in one codebase. The Bitcoin Core codebase has collected a lot of cruft over time and the ultra conservatism that is needed when treating (potential) consensus code seems to permeate into parts of the codebase that no one is using, definitely isn't consensus code and should probably just be removed.\n\nThe libbitcoinkernel project was (is?) an attempt to extract the consensus engine out of Core but it seems like it won't achieve that as consensus is just too slippery a concept and Knots style consensus compatible codebase forks of Bitcoin Core seem to still the model. To what extent you can safely chop off this cruft and effectively maintain this less crufty fork of Bitcoin Core also isn't clear to me yet.\n\nThen there is the question of whether it makes sense to mix C and C++ code that people have different views on. C++ is obviously a superset of C but assuming this merging of Bitcoin Core and Core Lightning is/was the optimal final destination it surely would have been better if Core Lightning was written in the same language (i.e. with classes) as Bitcoin Core.\n\nI'm just floating the idea to (hopefully) hear from people who are much more familiar with the entirety of the Bitcoin Core and Core Lightning codebases. It would be an ambitious long term project but it would be nice to focus on some ambitious project(s) (even if just conceptually) for a while given (thankfully) there seems to be a lull in soft fork activation chaos.\n\nThanks\nMichael\n\n[0]: https://twitter.com/michaelfolkson/status/1589220155006910464?s=20&t=GbPm7w5BqS7rS3kiVFTNcw\n\n--\nMichael Folkson\nEmail: michaelfolkson at [protonmail.com](http://protonmail.com/)\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230114/306cd5ac/attachment.html>", "summary": "Michael Folkson suggests that a bare bones Knots style Bitcoin implementation integrated with Core Lightning may be the future due to dysfunction in Bitcoin Core's management."}, {"author": "Fabian", "date": "2023-01-14T20:34:38", "message_text_only": "Hi Michael,\n\nhave you seen Mako? It might at least be a good start for what you would like to achieve: https://github.com/chjj/mako\n\nBest,\nFabian\n------- Original Message -------\nOn Saturday, January 14th, 2023 at 9:26 PM, Michael Folkson via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> I tweeted this [0] back in November 2022.\n>\n> \"With the btcd bugs and the analysis paralysis on a RBF policy option in Core increasingly thinking @BitcoinKnots and consensus compatible forks of Core are the future. Gonna chalk that one up to another thing @LukeDashjr was right about all along.\"\n>\n> A new bare bones Knots style Bitcoin implementation (in C++/C) integrated with Core Lightning was a long term idea I had (and presumably many others have had) but the dysfunction on the Bitcoin Core project this week (if anything it has been getting worse over time, not better) has made me start to take the idea more seriously. It is clear to me that the current way the Bitcoin Core project is being managed is not how I would like an open source project to be managed. Very little discussion is public anymore and decisions seem to be increasingly made behind closed doors or in private IRC channels (to the extent that decisions are made at all). Core Lightning seems to have the opposite problem. It is managed effectively in the open (admittedly with fewer contributors) but doesn't have the eyeballs or the usage that Bitcoin Core does. Regardless, selfishly I at some point would like a bare bones Bitcoin and Lightning implementation integrated in one codebase. The Bitcoin Core codebase has collected a lot of cruft over time and the ultra conservatism that is needed when treating (potential) consensus code seems to permeate into parts of the codebase that no one is using, definitely isn't consensus code and should probably just be removed.\n>\n> The libbitcoinkernel project was (is?) an attempt to extract the consensus engine out of Core but it seems like it won't achieve that as consensus is just too slippery a concept and Knots style consensus compatible codebase forks of Bitcoin Core seem to still the model. To what extent you can safely chop off this cruft and effectively maintain this less crufty fork of Bitcoin Core also isn't clear to me yet.\n>\n> Then there is the question of whether it makes sense to mix C and C++ code that people have different views on. C++ is obviously a superset of C but assuming this merging of Bitcoin Core and Core Lightning is/was the optimal final destination it surely would have been better if Core Lightning was written in the same language (i.e. with classes) as Bitcoin Core.\n>\n> I'm just floating the idea to (hopefully) hear from people who are much more familiar with the entirety of the Bitcoin Core and Core Lightning codebases. It would be an ambitious long term project but it would be nice to focus on some ambitious project(s) (even if just conceptually) for a while given (thankfully) there seems to be a lull in soft fork activation chaos.\n>\n> Thanks\n> Michael\n>\n> [0]: https://twitter.com/michaelfolkson/status/1589220155006910464?s=20&t=GbPm7w5BqS7rS3kiVFTNcw\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at [protonmail.com](http://protonmail.com/)\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230114/acc6e73d/attachment-0001.html>", "summary": "Michael is considering the idea of a bare bones Knots-style Bitcoin implementation integrated with Core Lightning due to dysfunction in the Bitcoin Core project."}, {"author": "Michael Folkson", "date": "2023-01-14T20:45:38", "message_text_only": "I saw it was announced, yes. The author is brilliant, he has now managed two alternative implementations of Core in two different languages :)\n\nThe problem though and why I and many others think the Knots style fork of Core is the better option is because you avoid reimplementing consensus code in a different language. If you're ultra conservative about consensus code you either want to run Core in parallel with your alternative implementation to check they don't go out of consensus or you want to run the same consensus code as Core in a Knots like fork. Hence a Knots like fork of Core in C++ integrated with Core Lightning in C seems like the better option to me for serious running in production like use cases.\n\n--\nMichael Folkson\nEmail: michaelfolkson at [protonmail.com](http://protonmail.com/)\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n------- Original Message -------\nOn Saturday, January 14th, 2023 at 20:34, Fabian <fjahr at protonmail.com> wrote:\n\n> Hi Michael,\n>\n> have you seen Mako? It might at least be a good start for what you would like to achieve: https://github.com/chjj/mako\n>\n> Best,\n> Fabian\n> ------- Original Message -------\n> On Saturday, January 14th, 2023 at 9:26 PM, Michael Folkson via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>\n>> I tweeted this [0] back in November 2022.\n>>\n>> \"With the btcd bugs and the analysis paralysis on a RBF policy option in Core increasingly thinking @BitcoinKnots and consensus compatible forks of Core are the future. Gonna chalk that one up to another thing @LukeDashjr was right about all along.\"\n>>\n>> A new bare bones Knots style Bitcoin implementation (in C++/C) integrated with Core Lightning was a long term idea I had (and presumably many others have had) but the dysfunction on the Bitcoin Core project this week (if anything it has been getting worse over time, not better) has made me start to take the idea more seriously. It is clear to me that the current way the Bitcoin Core project is being managed is not how I would like an open source project to be managed. Very little discussion is public anymore and decisions seem to be increasingly made behind closed doors or in private IRC channels (to the extent that decisions are made at all). Core Lightning seems to have the opposite problem. It is managed effectively in the open (admittedly with fewer contributors) but doesn't have the eyeballs or the usage that Bitcoin Core does. Regardless, selfishly I at some point would like a bare bones Bitcoin and Lightning implementation integrated in one codebase. The Bitcoin Core codebase has collected a lot of cruft over time and the ultra conservatism that is needed when treating (potential) consensus code seems to permeate into parts of the codebase that no one is using, definitely isn't consensus code and should probably just be removed.\n>>\n>> The libbitcoinkernel project was (is?) an attempt to extract the consensus engine out of Core but it seems like it won't achieve that as consensus is just too slippery a concept and Knots style consensus compatible codebase forks of Bitcoin Core seem to still the model. To what extent you can safely chop off this cruft and effectively maintain this less crufty fork of Bitcoin Core also isn't clear to me yet.\n>>\n>> Then there is the question of whether it makes sense to mix C and C++ code that people have different views on. C++ is obviously a superset of C but assuming this merging of Bitcoin Core and Core Lightning is/was the optimal final destination it surely would have been better if Core Lightning was written in the same language (i.e. with classes) as Bitcoin Core.\n>>\n>> I'm just floating the idea to (hopefully) hear from people who are much more familiar with the entirety of the Bitcoin Core and Core Lightning codebases. It would be an ambitious long term project but it would be nice to focus on some ambitious project(s) (even if just conceptually) for a while given (thankfully) there seems to be a lull in soft fork activation chaos.\n>>\n>> Thanks\n>> Michael\n>>\n>> [0]: https://twitter.com/michaelfolkson/status/1589220155006910464?s=20&t=GbPm7w5BqS7rS3kiVFTNcw\n>>\n>> --\n>> Michael Folkson\n>> Email: michaelfolkson at [protonmail.com](http://protonmail.com/)\n>> Keybase: michaelfolkson\n>> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230114/f701a6df/attachment.html>", "summary": "The author suggests that a Knots-style fork of Core in C++ integrated with Core Lightning in C is a better option for serious production use cases."}], "thread_summary": {"title": "A new Bitcoin implementation integrated with Core Lightning", "categories": ["Lightning-dev"], "authors": ["Michael Folkson", "Fabian"], "messages_count": 3, "total_messages_chars_count": 11226, "convo_summary": "Michael Folkson proposes a Knots-style Bitcoin implementation integrated with Core Lightning as a better option for serious production use cases due to dysfunction in Bitcoin Core's management."}}, {"title": "[Lightning-dev] Efficient Factories For Lightning Channels", "thread_messages": [{"author": "jlspc", "date": "2023-01-15T21:13:08", "message_text_only": "TL;DR\n=====\n\n* Factories that create and update a large number of Lightning channels efficiently are essential for scaling the Lightning Network.\n* This post presents the first known protocol for Lightning factories that can be closed unilaterally in O(1) time using O(1) on-chain transactions.\n  - If P parties use the protocol, they create P conflicting Commitment transactions, any of which can be used to establish the factory's state.\n  - As a result, each party must maintain P copies of the state of each channel created by the factory.\n  - Another factory protocol is presented that eliminates the need to maintain P copies of each channel state (at the expense of requiring more on-chain bytes).\n* Both factory protocols are modifications of the Tunable-Penalty Channel protocol and share many of its properties, including:\n  - tunable penalties for putting old transactions on-chain, and\n  - watchtowers with storage that's logarithmic in the number of factory states supported (but linear in the number of parties in the factory).\n\nOverview\n========\n\nFactories that allow multiple two-party Lightning channels to be created, re-sized and closed with a small number of on-chain transactions are essential to the scalability of Bitcoin [2].\nLet P denote the number of parties, C denote tha number of channels created, and S denote the number of factory states supported.\nThe most efficient previously-known factory, created by Burchert, Decker and Wattenhofer [2], can be closed unilaterally in O(log S) time using O(log S) on-chain transactions and O(C + log S) on-chain bytes.\nA single fixed transaction is used to instantiate the factory's channels when it's closed unilaterally, so the parties using the factory can maintain just a one version of each off-chain channel state.\nPerforming a unilateral close with O(log S) on-chain transactions requires that the party closing the factory interact with the blockchain at O(log S) different blockheights (so a unilateral close is an O(log S)-shot procedure [4]), which could be awkward for some users [8].\n\nThis paper presents two protocols for factories that can be closed unilaterally in O(1) time using O(1) on-chain transactions.\nThe first protocol, called the Tunable-Penalty Factory (TPF) protocol, requires only O(C) on-chain bytes for a unilateral close, but it can use P different transactions to instantiate the factory's channels, thus forcing the parties using the factory to maintain P different versions of each off-chain channel state.\nThe second protocol, called the Single-Commitment (SC) protocol, requires O(C + log S) on-chain bytes for a unilateral close, but it uses only a single transaction to instantiate the factory's channels, so multiple versions of off-chain channel states aren't required.\nThe TPF protocol is particularly simple and allows a 2-shot unilateral close (that is, the party closing the channel only has to perform actions at 2 different blockheights).\n\nBoth protocols are based on the Tunable-Penalty Channel (TPC) protocol [5] and they share many of its properties, including:\n* tunable penalties for putting old transactions on-chain, and\n* watchtowers with storage that's logarithmic in the number of factory states supported (but linear in the number of parties in the factory).\n\nNo change to the underlying Bitcoin protocol is required.\n\nA more complete description, including a proof of correctness and better figures, is available in a paper [6].\n\nThe Tunable-Penalty Factory (TPF) Protocol\n==========================================\n\nThe TPF protocol is a slight modification of the TPC protocol [5].\n\nEach party using the TPC protocol has their own on-chain Individual transaction, the output of which they spend with their State transaction.\nThis State transaction is a control transaction and its first output's value is equal to the desired penalty for putting an old State transaction on-chain.\nThis first output can be spent by the same party's Commitment transaction for the same state, but only after a relative delay equal to the maximum of the parties' to_self_delay parameters.\nThe relative delay gives the other party time to revoke an old State transaction by spending its first output and thus claiming the penalty.\nThe State transaction also has an HTLC control output for each HTLC that is active in that state.\nThe TPC protocol revokes old State transactions with per-commitment keys that can be known to all parties, rather than with revocation keys that cannot be known by the party putting the revocable transaction on-chain [5].\n\nThe TPC protocol is modified to create the TPF protocol by:\n* eliminating the HTLC control outputs from the State transactions,\n* modifying the Commitment transactions to have channel outputs, each of which is owned by two parties in the factory, and\n* supporting P > 2 parties by allowing each party to have their own Individual, State and Commitment transactions.\n\nThe TPF protocol is shown below:\n\n+-+ A..Z                           +----+ AD\n|F|------+-------------------------| CC |-----\n+-+      |                         |    |\n         |                         |    | BC\n         |                         |    |-----\n         |                         |    |\n         .                         |    | MZ\n         .                         |    |-----\n         .                         +----+\n         |\n         |                         +----+ AD\n         +-------------------------|C_Ai|-----\n         |                         |    |\n         |                         |    | BC\n         |                         |    |-----\n         |                         |    |\n         |               tsdAZ & A |    | MZ\n         |             +-----------|    |-----\n         |             |           +----+\n         |             |\n         |             |           +----+ AD\n         +-------------------------|C_Bi|-----\n         |             |           |    |\n         |             |           |    | BC\n         |             |           |    |-----\n         |             |           |    |\n         .             | tsdAZ & B |    | MZ\n         .           +-------------|    |-----\n         .           | |           +----+\n         |           | |\n         |           | |           +----+ AD\n         +-------------------------|C_Zi|-----\n         |           | |           |    |\n         .           | |           |    | BC\n         .           | |           |    |-----\n         .           | |           |    |\n         |           | | tsdAZ & Z |    | MZ\n         V         +---------------|    |-----\n                   | | |           +----+\n                   | | |\n+----+ A  +-----+  | | | pckeyAi\n|In_A|----|St_Ai|------+-----------\n+----+    |     |  | |\n          +-----+  | |\n                   | |\n+----+ B  +-----+  | |   pckeyBi\n|In_B|----|St_Bi|----+-------------\n+----+    |     |  |\n          +-----+  |\n  .          .     .\n  .          .     .\n  .          .     .\n                   |\n+----+ Z  +-----+  |     pckeyZi\n|In_Z|----|St_Zi|--+---------------\n+----+    |     |\n          +-----+\n\nwhere:\nF is the Funding transaction,\nCC is the Cooperative Close transaction,\nIn_{A..Z} is {A..Z's} Individual transaction,\nSt_{A..Z}i is {A..Z's} State transaction for state i, and\nC_{A..Z}i is {A..Z's} Commitment transaction for state i.\n\nRequirements for output cases are as follows:\n{A..Z}: {A..Z}'s signature (a single party's signature),\nA..Z: A..Z's signature (every parties' signature),\npairs of capital letters indicate signatures from those two parties,\npckey{A..Z}i: a signature using a per-commitment key for revoking {A..Z}'s state i transaction, and\ntsdAZ: a relative delay equal to the maximum of {A..Z}'s to_self_delay parameters.\n\nIn order to establish a new factory state, all parties:\n* calculate the State and Commitment transactions for the new state (this step includes exchanging per-commitment pubkeys for the new state with each of the other parties),\n* exchange partial signatures for the new state's Commitment transactions, and\n* exchange per-commitment keys for the old state, thus revoking it.\n\nAll parties constantly look for old (revoked) State transactions put on-chain by other parties, and if they find such a transaction they use the corresponding per-commitment key to spend its first output, thus obtaining the penalty funds and revoking the old state.\nOnce a State transaction has been on-chain for tsdAZ without its first output being spent, the party that put the State transaction on-chain can attempt to put their corresponding Commitment transaction on-chain at any time.\nAny party can close the factory unilaterally by putting their current State transaction on-chain, waiting until it has been on-chain for tsdAZ, and then submitting their corresponding Commitment transaction to the blockchain.\n\nAs was the case with the TPC protocol, per-commitment keys can use the Lightning protocol's compact storage technique for revocation keys to consume only O(log S) storage to revoke a maximum of S old transactions that could be put on-chain by a single other party [7][5].\nTherefore, each party requires O(P*log S) storage to hold the per-commitment keys for all of the P parties.\n\nThe Single-Commitment (SC) Factory Protocol\n===========================================\n\nNote that the TPF factory protocol uses P conflicting Commitment transactions to establish the factory state and to instantiate the factory's channels.\nTherefore, a separate channel state must be maintained and updated for each of the P versions of the channel that could be instantiated, thus increasing the computation, storage, and communication for channels by a factor of P.\nThe result could be quite expensive if there are a large number of parties in the factory.\n\nThe SC protocol eliminates this factor of P blow-up by having all of the parties use a single shared Commitment transaction.\nLike the TPF protocol, the SC protocol uses revocable State transactions, each of which spends a single party's Individual transaction output, to ensure that only the current Commitment transaction can be put on-chain.\nThe challenge is how to use a single shared Commitment transaction that depends on the value of an unrevoked State transaction without actually spending any of the outputs of that State transaction (as spending a State transaction output would make the Commitment transaction's input dependent on which party's State transaction it spends, thus preventing the use of a single shared Commitment transaction).\nThis challenge is solved by introducing a shared Trigger transaction and a per-user Mold transaction, where the Commitment and Mold transactions compete for the Trigger transaction's outputs.\nThe Mold transaction is put on-chain prior to the Commitment transaction, and it constrains the Commitment transactions that can be put on-chain somewhat like how a mold shapes a liquid that is poured into it.\n\nSpecifically, the Trigger transaction has one value output and log_2(S) control outputs, numbered 0 .. log_2(S) - 1. Commitment transaction i, 0 <= i <= S - 1, spends those Trigger control outputs b, 0 <= b <= log_2(S) - 1, such that bit position b of the binary representation of i is a 0.\nEach Mold transaction i, 0 <= i <= S - 1, spends the output of the same party's State i transaction, and Trigger control outputs b, 0 <= b <= log_2(S) - 1, such that bit position b of the binary representation of i is a 1.\nThis construction guarantees that if a Mold transaction for state i is on-chain, only Commitment transactions for states j >= i can be put on-chain.\n\nStates 0 through S - 1 are supported, with the exception of states of the form 2^b where 1 <= b <= log_2(S) - 1.\nThese exceptions are made to guarantee that it is impossible to put Mold transactions on-chain for two consecutive states (other than states 0 and 1) where they would prevent any current Commitment transaction from being put on-chain.\nWhen state i is supported but state i+1 is not, the next state after i is i+2.\n\nThe protocol operation is similar to that of the TPF protocol, except parties closing the channel unilaterally submit the Trigger transaction and their current State transaction to the blockchain, and once their State transaction has been on-chain for tsdAZ, submit their Mold transaction for the same state to the blockchain.\nOnce the Trigger transaction has been on-chain for 3tsdAZ, they submit to the blockchain the Commitment transaction for the same state as the on-chain Mold transaction.\n\nAlso, all parties monitor the blockchain for the Trigger transaction, and if they find it they use the above protocol for closing the factory as soon as possible.\n\nBecause only Mold transactions for unrevoked State transactions can be put on-chain, and because only the latest State transactions can be unrevoked, only the latest (and thus current) Commitment transactions can be put on-chain.\n\nA figure for the SC protocol, and a detailed proof of correctness, are in the paper [6].\n\nRelated Work\n============\n\nThe concept of creating a channel factory for Lightning, as well as the most efficient published protocol for such a factory, was presented by Burchert, Decker and Wattenhofer [2].\nThe protocols presented here differ in only requiring O(1) time and O(1) on-chain transactions for a unilateral factory close.\n\nA number of researchers have proposed changes to Bitcoin in order to support simpler and more efficient factories.\nThe eltoo factory protocol [3] has a particularly simple structure and it allows the parties to maintain only one version of each off-chain channel state.\nIt requires O(1) time, O(1) on-chain transactions and O(1) on-chain bytes for a unilateral close.\nHowever, a malicious party could delay the closing of the factory until O(S) transactions are put on-chain, if the malicious party is willing to pay the required fees.\nThe eltoo protocol differs from the protocols presented here by requiring a change to Bitcoin, namely the support for BIP 118 [1].\n\nThe TPF and SC protocols are based on the TPC protocol presented by Law [5].\n\nConclusions\n===========\n\nThis post presents new factory protocols that require O(1) time and O(1) on-chain transactions for a unilateral close.\nThey are the first factory protocols known that achieve those bounds with the existing Bitcoin protocol.\n\nThe ability to unilaterally close a factory with just two or three submissions to the blockchain, with a fixed delay between them, is quite a bit simpler than closing previously-published factories [2].\nAs a result, it's hoped that TPF and SC factories will lead to the increased use of factories in practice, thus improving the scalability of Bitcoin and Lightning.\n\nRegards,\nJohn\n\nReferences\n==========\n[1] \"BIP 118: SIGHASH_ANYPREVOUT\", available at https://anyprevout.xyz/ and https://github.com/bitcoin/bips/pull/943.\n[2] Burchert, Decker and Wattenhofer, \"Scalable Funding of Bitcoin Micropayment Channel Networks\", available at http://dx.doi.org/10.1098/rsos.180089.\n[3] Decker, Russell and Osuntokun. eltoo: A Simple Layer2 Protocol for Bitcoin. Available at https://blockstream.com/eltoo.pdf.\n[4] Law, \"Watchtower-Free Lightning Channels For Casual Users\", available at https://github.com/JohnLaw2/ln-watchtower-free.\n[5] Law, \"Lightning Channels With Tunable Penalties\", available at https://github.com/JohnLaw2/ln-tunable-penalties.\n[6] Law, \"Efficient Factories For Lightning Channels\", available at https://github.com/JohnLaw2/ln-efficient-factories.\n[7] Russell, \"Efficient Per-Commitment Secret Storage\", available at https://github.com/lightning/bolts/blob/master/03-transactions.md#efficient-per-commitment-secret-storage.\n[8] ZmnSCPxj, \"Channel Eviction From Channel Factories By New Covenant Operations\", available at https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-February/003479.html.\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230115/1c24b7f0/attachment-0001.html>", "summary": "New protocols for Lightning factories that can be closed unilaterally in O(1) time using O(1) on-chain transactions have been presented, which are essential for scaling the Lightning Network. The Tunable-Penalty Factory (TPF) protocol requires P different transactions to instantiate the factory's channels, while the Single-Commitment (SC) protocol uses only a single transaction."}], "thread_summary": {"title": "Efficient Factories For Lightning Channels", "categories": ["Lightning-dev"], "authors": ["jlspc"], "messages_count": 1, "total_messages_chars_count": 16112}}, {"title": "[Lightning-dev] Jamming mitigation call for 2023", "thread_messages": [{"author": "Clara Shikhelman", "date": "2023-01-18T20:09:42", "message_text_only": "Hi All,\n\nTime to bring back the anti-jamming discussions!\n\nOur next call will be on January 23rd at 6 pm UTC (notice the time change)\nat the usual place: https://meet.jit.si/UnjammingLN.\n\nA draft of the agenda is available here:\nhttps://github.com/ClaraShk/LNJamming/issues/1\n\nPlease feel free to add agenda items on the issue!\n\nSee you soon,\nClara\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230118/74b63c37/attachment.html>", "summary": "Join the anti-jamming discussions on January 23rd at 6 pm UTC via https://meet.jit.si/UnjammingLN. Check the agenda and add items."}], "thread_summary": {"title": "Jamming mitigation call for 2023", "categories": ["Lightning-dev"], "authors": ["Clara Shikhelman"], "messages_count": 1, "total_messages_chars_count": 533}}, {"title": "[Lightning-dev] A security review of Validating Lightning Signer architecture and code", "thread_messages": [{"author": "Antoine Riard", "date": "2023-01-23T14:15:07", "message_text_only": "Hi all,\n\n\nSince starting to hack on LDK, I\u2019ve been interested in running some\ncomponents of a Lightning node in a dedicated hardware environment, in the\nimage of what is done by the smart card industry. We have been doing a\nbunch of refactoring in that sense early on to isolate our signing\noperations [0].\n\nBuilding on top of this generic signing interface, the Validating Lightning\nSigner has been growing into a mature Lightning signer during the past\nyears, performing a comprehensive set of policy checks to ensure the keys\nare not misused [1]. The module development is advanced enough to be\nfunctional with both deployment of LDK and CLN nodes (waiting internal\nrefactoring by other implementations for eventual support).\n\nDuring the past months, in cooperation with the VLS project team, I\u2019ve done\na third-party security audit of VLS core mechanisms, evaluating its state\nof readiness for production by the community of Lightning node operators.\n\nThe critical vulnerabilities and attacks vectors found are the following:\n\n\n- The legacy `option_anchor_outputs` is accepted by the Signer, there is no\nprotection against channel opening downgrades to unsafe channel type. This\nopens the way to the known fee siphoning attack capturing almost all\nchannel value in function of capacity [2].\n\n- The Signer does not enforce an upper bound on the sum of trimmed HTLC as\nminer fees. This opens the way to the known dust inflate attack capturing a\nminority of channel value if the adversary has low-hashrate capabilities\n[3].\n\n- There is a lack of a `policy-cltv-delta-reasonable` rule for routing\nhops. There is no enforcement of a reasonable `cltv_expiry_delta` between\ninbound HTLC and outbound HTLC, where reasonable is defined according to\nthe BOLT2\u2019s `cltv_expiry_delta` selection recommendations [4]. This opens\nthe way to HTLC-double-spend attack where up to\n`max_htlc_value_in_flight_msat` of channel value can be captured.\n\n\n- There is a lack of verification of `nLocktime` field soundness of the\nHTLC-timeout at counterparty signature reception. This opens the way to\nHTLC value freezing or double-spend in function of the deployment\n\n- There is a lack of rejection of non-Segwit input for the funding\ntransaction. This opens the way to known freezing of full channel value by\nthe counterparty [5].\n\n- The Signer is suffering from high-exposure to a fee-siphoning attack by\nan adversary with minimal hashrate capabilities (i.e 1 block without time\nboundary). Both funding/commitment transactions weights and feerate can be\ninflated to increase the absolute fee signed.\n\nBeyond that, there are still missing not-implemented critical policy rules\nand the invoices and payments flows are still hardened with a consistent\nsecurity model. Those issues were known by the project.\n\nThe issues have been communicated to the VLS team ahead of the report\npublication and they\u2019re committed to address them.\n\n\nThe full audit report can be found here:\n\nhttps://github.com/ariard/validating-lightning-signer/blob/main/VLS-audit-v0.2.pdf\n\nIn the future, as the LN ecosystem matures, extended policies are expected\nto be introduced covering the variety of LN use-cases: merchant, mobile,\nrouting nodes, LSP, where the policy set of rules could bind to the\napplication logic. E.g as BOLT12 offers to introduce a richer semantic on\npayment protocol, the request structure could be enforced by the VLS [6].\nMoreover, other data flows could be submitted to VLS to detect anomalies,\nsuch as the historical mempools data in a compressed way.\n\nBeyond Lightning node security, the VLS architecture could be generalized\nto other Bitcoin contracting protocols (e.g vaults), where spending\npolicies are also leveraged to introduce fine-grained control of custodied\nBitcoin funds between cold and warm wallets.\n\n\nCheers,\n\nAntoine\n\n\n[0] https://github.com/lightningdevkit/rust-lightning/pull/214\n[1] https://vls.tech\n\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-September/002796.html\n[3]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html\n<https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html>\n\n[4]\nhttps://github.com/lightning/bolts/blob/master/02-peer-protocol.md#cltv_expiry_delta-selection\n\n[5]\nhttps://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#user-content-Trustfree_unconfirmed_transaction_dependency_chain\n[6] http://bolt12.org\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230123/33179656/attachment.html>", "summary": "A security audit of the Validating Lightning Signer (VLS) has revealed critical vulnerabilities and attack vectors, including fee siphoning and dust inflate attacks. The VLS team has been informed and committed to addressing the issues."}], "thread_summary": {"title": "A security review of Validating Lightning Signer architecture and code", "categories": ["Lightning-dev"], "authors": ["Antoine Riard"], "messages_count": 1, "total_messages_chars_count": 4589}}, {"title": "[Lightning-dev] A Universal Coin Swap system based on bitcoin and a Bitcoin NFT system", "thread_messages": [{"author": "Aymeric Vitte", "date": "2023-01-26T20:15:38", "message_text_only": "Please see:\n\n\"A Bitcoin NFT system\"\nhttps://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7 \"The\npurpose of this proposal is to propose a simple NFT system based on the\nBitcoin blockchain, assuming that the main purpose of a NFT is to be\nsold/bought, but not only, it can be something that you keep for\nyourself proving your ownership on the blockchain, or something that you\noffer to someone else, the advantages compared to using Ethereum or any\nblockchain/sidechain on both networks (or others) will be explained below\"\n\nAnd the continuation:\n\n\"A Universal Coin Swap system based on bitcoin\"\nhttps://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7 \"The\npurpose here is to propose a simple Coin Swap decentralized system based\non Bitcoin but that works for all blockchains/tokens\"\n\nThe idea is to propose something simple, that people can understand,\nsecured, decentralized, easy to implement/use, not expensive for the\nusers, unlike Ethereum solutions, showing also that bitcoin can easily\ndo in a much more simple manner what ethereum is doing\n\nIt's a bit similar to Lightning but not as sophisticated, basically the\nproof of deals are stored in OP_RETURN (looks trivial, yes, but unlike\nother solutions the proposals store a real proof and does not flood the\nbitcoin network with funny stuff, it could be turned into bitcoin\ncontracts which most likely will not be recognized as standard), we\ncannot enforce everything like Lightning but the trust here is more\nbased on a reputation model, and same as Lightning the cheater just lose\nits bitcoin or get tagged as a cheater, will be tracked and might assume\nthe consequences later\n\nAs written, I am a fan of Lightning but see it more as a middle/long\nterm relationship between people since coins must be locked into a\nmultisig transaction while here we are more talking about a one time\ndeal, where you don't know if you will buy something else to the seller,\nwith which coin and where (metaverse for example)\n\nFor your review and comments, here or in private, no real inventions\nhere but some non usual ideas like the double hash, the third party and\nothers, solving also one of my personal problematic since years: \"how to\nsell a secret NFT?\"\n\nIn any case it remains decentralized (but of course some tools/wallets\nmust ease the process for the users), like Lightning, and unlike\neverything that is existing today in those areas to my knowledge, except\nLightning again\n\nRegards\n\nAymeric\n\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com", "summary": "The proposal suggests a simple NFT system and a universal coin swap system based on the Bitcoin blockchain, highlighting advantages over Ethereum solutions and offering a decentralized, secure, and easy-to-use alternative. The NFT system can be used for buying/selling or proving ownership, while the coin swap system works for all blockchains/tokens and uses a reputation model for trust. The proof of deals is stored in OP_RETURN, and the proposal solves the problem of selling a secret NFT. The systems are decentralized and do not flood the Bitcoin network with unnecessary data."}, {"author": "Aymeric Vitte", "date": "2023-01-31T18:36:28", "message_text_only": "I am not sure to understand the current discussion about ordinals\nrelayed by the press, it's from my standpoint a no for storing things in\nwitness, and a no to use ordinals as a NFT system\n\nPlease remember that NFTs are not only electronic things, it can be real\nthings, or whatever you like, just referenced in the blockchain by a\n\"double hash\" for my proposal\n\nBitcoin is currently completely out of the future: the so-called \"web3\",\nand lightning will not solve everything\n\nThen please see my two proposals and comment, it's simple and easy to\nread, and just complies with all comments related to/against the\nordinals proposal (storing things for my proposals in a good old\nOP_RETURN the hashes and signatures only, not flooding bitcoin with\nproofs of nothing, docs, images, etc), or just point out other better\nsystems based on bitcoin\n\nIt just shows again that bitcoin is better in all aspects compared to\nother systems\n\nI am not against ordinals but don't see it for \"web3\"\n\n\nLe 26/01/2023 \u00e0 21:15, Aymeric Vitte a \u00e9crit :\n> Please see:\n>\n> \"A Bitcoin NFT system\"\n> https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7 \"The\n> purpose of this proposal is to propose a simple NFT system based on the\n> Bitcoin blockchain, assuming that the main purpose of a NFT is to be\n> sold/bought, but not only, it can be something that you keep for\n> yourself proving your ownership on the blockchain, or something that you\n> offer to someone else, the advantages compared to using Ethereum or any\n> blockchain/sidechain on both networks (or others) will be explained below\"\n>\n> And the continuation:\n>\n> \"A Universal Coin Swap system based on bitcoin\"\n> https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7 \"The\n> purpose here is to propose a simple Coin Swap decentralized system based\n> on Bitcoin but that works for all blockchains/tokens\"\n>\n> The idea is to propose something simple, that people can understand,\n> secured, decentralized, easy to implement/use, not expensive for the\n> users, unlike Ethereum solutions, showing also that bitcoin can easily\n> do in a much more simple manner what ethereum is doing\n>\n> It's a bit similar to Lightning but not as sophisticated, basically the\n> proof of deals are stored in OP_RETURN (looks trivial, yes, but unlike\n> other solutions the proposals store a real proof and does not flood the\n> bitcoin network with funny stuff, it could be turned into bitcoin\n> contracts which most likely will not be recognized as standard), we\n> cannot enforce everything like Lightning but the trust here is more\n> based on a reputation model, and same as Lightning the cheater just lose\n> its bitcoin or get tagged as a cheater, will be tracked and might assume\n> the consequences later\n>\n> As written, I am a fan of Lightning but see it more as a middle/long\n> term relationship between people since coins must be locked into a\n> multisig transaction while here we are more talking about a one time\n> deal, where you don't know if you will buy something else to the seller,\n> with which coin and where (metaverse for example)\n>\n> For your review and comments, here or in private, no real inventions\n> here but some non usual ideas like the double hash, the third party and\n> others, solving also one of my personal problematic since years: \"how to\n> sell a secret NFT?\"\n>\n> In any case it remains decentralized (but of course some tools/wallets\n> must ease the process for the users), like Lightning, and unlike\n> everything that is existing today in those areas to my knowledge, except\n> Lightning again\n>\n> Regards\n>\n> Aymeric\n>\n>\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com", "summary": "The author proposes a simple NFT system and a universal coin swap system based on Bitcoin, which are easy to understand, secure, and decentralized. They argue that Bitcoin can do what Ethereum does in a simpler manner. The author is not against ordinals but does not see them as suitable for the \"web3\" future."}], "thread_summary": {"title": "A Universal Coin Swap system based on bitcoin and a Bitcoin NFT system", "categories": ["Lightning-dev"], "authors": ["Aymeric Vitte"], "messages_count": 2, "total_messages_chars_count": 7478, "convo_summary": "Aymeric Vitte proposes a simple NFT system and universal coin swap system based on Bitcoin blockchain, offering a decentralized, secure, and easy-to-use alternative to Ethereum solutions. The systems are stored in OP_RETURN and do not flood the Bitcoin network with unnecessary data. The author argues that Bitcoin can do what Ethereum does in a simpler manner, and is not against ordinals but does not see them as suitable for the \"web3\" future."}}, {"title": "[Lightning-dev] Async payments proof-of-payment: a wishlist for researchers]", "thread_messages": [{"author": "Anthony Towns", "date": "2023-01-30T04:27:23", "message_text_only": "After listening to the optech space on the topic, thought it might be\nworth having a second go at explaining the idea...\n\n\nAlice is trying to pay Bob. Alice has an LSP, Louise. Bob has an LSP\nLarry. Louise and Larry are online 24/7 but don't have access to Alice\nand Bob's private keys. We want the payment flow to be something like:\n\n 1) Larry gets some setup info from Bob, Bob goes offline.\n\n * Alice hears about Bob's address, and decides to pay Bob $50.\n 2) Alice coordinates a unique invoice id with Larry, which we'll call S.\n 3) Alice tells Louise that she's trying to pay Bob $50 for invoice S.\n * Louise registers with Larry to be told when Bob is online.\n * Alice goes offline.\n\n * Bob goes online.\n * Larry tells Louise that Bob is online.\n 4) Louise sends the payment to Bob conditional on S.\n 5) Bob accepts the payment.\n * Louise claims the $50 from Alice and closes out the transaction.\n 6) Alice receives a receipt from Bob.\n\nThe goal of a receipt is that if two people want to pay Bob $50, they'll\nbe able to guarantee that (a) Bob was paid, rather than someone else; (b)\nthat the receipts are different (so Bob received $100 total, rather than\n$50 going somewhere else and one of them just got a photocopied receipt);\nand (c) after the fact they can prove that the receipt was theirs,\nnot someone else's. (a) and (b) prevent the funds getting misdirected;\n(c) potentially allows you to use the receipt as evidence to a third\nparty if you paid for something in advance, then didn't receive it.\n\nTo get all those things, what we want is really more like a signature,\nthan just a hash/preimage. But PTLC preimages and schnorr signatures\naren't much different: with a PTLC preimage, you pay to point S and then\nreceive back the preimage s, where s*G = S. Meanwhile schnorr signatures\nare made up of a number (s) and a point (R), which satisfy the equation:\n\n  s*G = R + H(R,P,m)*P\n\nBut, if you're willing to squint a bit, you can just wrap the whole\nright side of the equation up as \"S\", and treat it as a PTLC.\n\n(notation: I use capital letters to represent points, and lower case\nletters to represent numbers; so if A is a point, a is it's discrete log,\nand a*G = A)\n\nTo calculate S, you need to know three things: R, P and m -- P is just\nthe signer's public key, m is the message being signed, but \"R\" is the\npublic \"nonce\" part of the signature, that has to be chosen by the signer\n(otherwise whoever does choose it can probably arrange to discover the\nsigner's private key after a signature or two).\n\nSo in that case, the protocol looks like:\n\n  Alice proposes that Bob signs a message, eg\n    m = \"Alice paid me $50 -- Bob\"\n    (perhaps this can be some standard nostr message, eg)\n  Bob chooses an R for this signature, and tells Alice what R is\n  Alice calculates \"S\"\n  Alice pays Bob $50 via a PTLC conditional on S\n  If Bob accepts the $50, Alice receives the preimage of S, ie s\n  Alice combines (R,s) and that is a Bob's signature on her message\n\nHaving Bob be offline with Alice only able to talk to his\nnot-fully-trusted representative Larry complicates things. Bob now can't\njust choose a brand new R after already knowing Alice's message m, and\nthat introduces cryptographic attacks [0], where if Alice can request\nnonces for many messages she may be able to find a lucky combination\nof messages/nonces where she can combine the signatures Bob ends up\ngenerating to steal Bob's private key.\n\n[0] https://medium.com/blockstream/insecure-shortcuts-in-musig-2ad0d38a97da\n\nI *think* those attacks can be avoided by using the same musig2 approach\nto generating nonces:\n\n  Bob prepares a nonce *pair* R1, R2\n  Alice chooses the message m\n  The nonce for the message m is calculated as H(R1,R2,m)*R1 + R2\n\nNote that this doesn't allow you to safely reuse nonces -- if you have\nthree messages signed with the same R1/R2 pair, the schnorr signing\nequation (s = r + H(R,P,m)*p) over each of the three messages gives you\nthree equations with just three unknowns (r1, r2, and the secret key\np), which you can use regular maths to solve, no fancy attacks needed.\n(Presumably if you just reuse a pair twice you open yourself back up to\na Wagner attack)\n\nSo that adds up to:\n\n 1) Bob shares with Larry a bunch of (R1,R2) points that will form the\n    basis of his signature nonces. They can be constructed via a\n    (hardened) HD scheme so that Bob can easily regenerate them just\n    from an index, eg.\n\n 2) Alice obtains a unique (R1,R2) pair from Larry\n    Alice determines the message she wants Bob to sign (presumably Bob\n    provides a standard template, and Alice fills in her name and perhaps\n    what she's paying for) -- this is \"m\".\n    Alice calculates R from R1,R2,m; and S from R,P,m \n\n 3) Alice passes \"m\" and \"S\" onto Louise and starts the payment, locking\n    up her funds\n\n 4) Louise passes \"m\", \"R1\", \"R2\" onto Bob once he's online and sends\n    the payment to Bob.\n \n 5) Bob checks that R1/R2 were what he generated and haven't already\n    been used; Bob checks that \"m\" is something he's willing to sign;\n    Bob calculates s and S, and accepts the payment for S, provided it's\n    the correct amount as specified in \"m\", by revealing s.\n\n 6) Alice already calculated R and now receives s from Louise when\n    Louise claims her funds, and (R,s) is a BIP340 signature of m by\n    Bob, satisfying s*G = R + H(R,P,m)*P, and that signature serves as\n    her payment receipt from Bob.\n\nCheers,\naj\n\nOn Thu, Jan 26, 2023 at 11:04:12AM +1000, Anthony Towns wrote:\n> On Tue, Jan 10, 2023 at 07:41:09PM +0000, vwallace via Lightning-dev wrote:\n> > The open research question relates to how the sender will get an invoice from the receiver, given that they are offline at sending-time.\n> \n> Assuming the overall process is:\n> \n>  * Alice sends a payment to Bob, who has provided a reusable address\n>    AddrBob\n>  * Bob is offline at the time the payment is sent, but his semi-trusted\n>    LSP Larry is online\n>  * Alice is willing/able to do bidirectional communication with Larry\n>  * The payment does not complete until Bob is online (at which point\n>    Alice may be offline)\n> \n> I think in this case you want to aim for the receipt to be a BIP340\n> signature of the message \"Alice has paid me $50 -- signed Bob\".\n> \n> Given Bob's public signature nonce, R, Alice (and Larry) can calculate\n> S = R + H(R,P,m)*P (m is the receipt message, P is Bob's public key),\n> and then Alice can send a PTLC conditional on revealing the log of S, ie\n> s where s*G=S; and at that point (s, R) is a valid signature by Bob of a\n> message confirming payment to Bob, which then serves as the final receipt.\n> \n> However for this to work, Alice needs to discover \"R\" while Bob is\n> offline. I think this is only doable if Bob pre-generates a set of\n> nonces and shares the public part with Larry, who can then share them\n> with potential payers.  I think to avoid attacks via Wagner's algorithm,\n> you probably need to do a similar setup as musig2 does, ie share (R1,R2)\n> pairs, and calculate R = H(P,R1,R2,m)*R1+R2.\n> \n> So a setup like:\n> \n>   Alice gets AddrBob. Decodes Bob's pubkey, Larry's pubkey, and the\n>   route to Larry.\n> \n>   Alice -> Larry: \"Hi, I want to send Bob $50, and get a receipt\"\n>   Larry -> Alice: \"The nonce for that will be R\"\n>   Alice: calculates m = \"Hash(\"Alice paid Bob $50\"), S = R+H(R,P,m)*P\n>   Alice -> Larry(for Bob): PTLC[$50, S]\n> \n>   Larry -> Bob: PTLC[$50, S]\n>                 Alice wants to pay you $50, using nonce pair #12345\n>   Bob: verifies nonce #12345 has not been previously used, calculates R,\n>        calculates m, calculates s, and checks that s*G = S, checks\n>        there's a $50 PTLC conditional on S waiting for confirmation.\n>   Bob -> Alice: claims $50 from PTLC by revealing s\n> \n>   Alice: receives s; (R,s) serves as Bob's signature confirming payment\n> \n> seems plausible?\n> \n> Every \"S\" here commits to a value chosen by the sender (ie, their\n> \"identity\"), so there's no way for Larry to get two different payers\n> to use the same S. Using the same nonce twice will just mean Bob has to\n> reject the payment (and find a new LSP).\n> \n> It may make sense to require Alice to make a micropayment to Larry in\n> order to claim a nonce. You'd want a standard template for \"m\" so that\n> it's easy to generate and parse consistently, of course.\n> \n> I think you could even have separate LSPs if you wanted: one to issue\n> nonces while you're offline, and the other to actually hold onto incoming\n> PTLCs while you're offline.\n> \n> FWIW, some previous discussion, which didn't focus on offline recipients:\n> \n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/001034.html\n> \n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001490.html\n\n----- End forwarded message -----", "summary": "Alice trying to pay Bob through their respective LSPs, Louise and Larry, using a PTLC preimage and a schnorr signature to ensure payment authenticity."}], "thread_summary": {"title": "Async payments proof-of-payment: a wishlist for researchers]", "categories": ["Lightning-dev"], "authors": ["Anthony Towns"], "messages_count": 1, "total_messages_chars_count": 8791}}, {"title": "[Lightning-dev] Jamming Mitigation Call Summary - 01/23", "thread_messages": [{"author": "Carla Kirk-Cohen", "date": "2023-01-30T15:24:56", "message_text_only": "Hi list,\n\nOn Monday last week we resumed our fortnightly channel jamming\nmitigation calls for 2023.\n\nDetails for the next call:\n* Monday 02/06 @ 18:00 UTC\n* https://meet.jit.si/UnjammingLN\n* Agenda: https://github.com/ClaraShk/LNJamming/issues/2\n\n# Meeting Summary\nThis email attempts to summarize the discussion, but is of course\nsubject to my errors and opinions so the full transcript is available\nat [1]. It is (imperfectly) AI generated, so please reach out to myself\nor Clara if you'd like clarification for a specific section.\n\n1. Upgrade Mechanisms\nThe first topic of discussion was around how we would go about\nupgrading the network to support an anti-jamming mitigation. Most\nsolutions share the following characteristics:\n  * They will likely require a network wide upgrade: when a sender\n    makes a payment, the full path will need to understand the new\n    feature bit for it to be used.\n  * Sending nodes are unlikely to be incentivised to upgrade to\n    support a channel jamming mitigation, as jamming mitigations incur\n    additional cost (be it in the form of upfront fees, tokens or some\n    other mechanism).\n  * Routing nodes have no way of knowing whether a payment comes from\n    a node that is not upgraded, or simply doesn't want to pay the\n    additional cost introduced by a jamming mitigation.\n\nIt was generally agreed that the network is still in an early enough\nstage that it is fair for relaying nodes to initially upgrade but not\nenforce the feature, and later look at forwarding traffic to determine\nwhether it is appropriate to require the feature. This will require\nsending nodes to opt-in to the new feature before the network can\nwidely enforce it, as no rational routing node will require a feature\nwhich would reduce its ability to serve un-upgraded traffic (unless\nunder attack, which is not the case at present).\n\nA note was also made that wallets tend to upgrade less frequently, in\npart because some providers run forked versions of LN implementations,\nso this horizon may be quite long. It was emphasized that this type of\nnetwork upgrade would require input from wallets, designers and\napplication developers anyway, so hopefully by the time we look to\ndeploy a change there is rough consensus among the Lightning community\nalready.\n\n2. Upfront Fees\nNext, we discussed the draft proposal for upfront fees [2] that\nimplements the first of a two-part jamming mitigation described in [3].\nAs it stands, the PR describes the simplest possible way to introduce\nupfront fees to the protocol:\n  * Upfront fees are expressed as a ppm of a channel's success-case\n    fees, and charged on the outgoing link of a route.\n  * Nodes can advertise custom upfront fee rates if desired, but to\n    save gossip bandwidth we assume a network-wide default of 1%.\n  * Upfront fees accumulate along the route (as htlc payment amounts\n    do), and are simply pushed to the `to_remote` balance on\n    `update_add_htlc`.\n  * Final hop nodes advertise an upfront fee policy in bolt 11 invoices\n    (or bolt 12 blinded routes) which is sufficiently padded to\n    obfuscate their location in the route.\n\nThe interaction between upfront fees and possible future protocol\nchanges such as inbound fees and negative fees was briefly discussed,\nspecifically the case where a node sets low (or negative) fees to\nattract traffic then fails payments to accumulate upfront fees. As is,\nall implementations\u2019 algorithms optimize for factors other than fees -\nspecifically avoiding a node once it's produced failures - and we\nsuspect that careful sender-side behavior will mitigate this risk.\nHowever, it was also acknowledged that a node that attempts this attack\nmay be able to fool multiple individual senders and still be able to\naccumulate some fees.\n\nWe then discussed the shortcomings of the \"simplest possible\" upfront\nfees in [2], specifically focused on the following scenario where\nnodes receive 1% of their success-case fees as an upfront payment:\n  * Alice is sending a payment to Dave, who is a popular sink node in\n    the network.\n  * Bob -> Carol has low/default routing policy: 1000 msat success\n    case / 10 msat upfront fee\n  * Carol -> Dave has high fees: 400,000 msat success case / 4000 msat\n    upfront fee\n  * Dave advertises no success case fee (is recipient) / 100 msat of\n    upfront fee chosen for his invoice.\n\nAlice ------ Bob ------ Carol ------ Dave\n\nSince we need to source all of these funds from the sender (Alice), the\nforwarding of funds is as follows:\n  * Alice pushes 4110 msat to Bob.\n  * Bob _should_ push 4100 msat to Carol, claiming his 10 msat upfront\n    fee.\n  * Carol _should_ push 100 msat to Dave, claiming her 4000 msat\n    upfront fee.\n\nHowever, Bob has no real incentive to forward the HTLC to Carol and\npush her the 4100 msat because that value is more than the fees he'll\nearn from successfully forwarding and settling the HTLC (10 msat\nupfront fees + 1000 msat success case fees). It's worth noting that\nthis type of fee differential already exists in the network today - I\ngot these example numbers by looking at the fee rates of the Loop\nnode's peers [4].\n\nThere were a few points discussed around this issue:\n  * Whether we should look into a more complicated approach that\n    includes a \"proof of forward\" secret in the next node's onion which\n    must be supplied to claim the upfront fee.\n  * Discussion about whether these order of magnitude fee differences\n    will exist in an efficient market (differing opinions).\n  * Whether Bob _would_ steal the upfront fee by dropping the payment,\n    as it'll impact nodes' desire to route through them in future.\n  * Is there a way to deliver upfront fees to nodes along the route\n    *without* them adding up along the route (other than the naive\n    version of sending each hop a payment, which comes with its own\n    problems)? Seems not, but bright ideas are wanted and welcome!\n  * That nodes will decide where they fall in the trade-off of setting\n    upfront fees to cover their opportunity cost for high routing fees\n    and market pressure to keep these fees low for the sake of\n    remaining competitive.\n\nA few people mentioned the desire to keep an upfront fee solution as\nsimple as possible, but generally it seemed that a solution where the\naccumulated upfront fees at any point along a route exceed any single\nhop's expected success case fees is unacceptable because incentives\nare misaligned (even if we can properly attribute errors with [5]).\n\nWe touched briefly on a few \"proof of forwarding\" solutions for\nupfront fees:\n  * Using a locking mechanism that relies on a secret that is provided\n    by the next node's onion.\n  * A taproot tree for all HTLCs where each leaf has a subset of HTLCs,\n    and fees could be incorporated here (summary note: apparently some\n    work has been done here, but I couldn't find the link).\n  * If we're confident that a more complicated solution will solve many\n    problems, then we should pursue them, otherwise a simple solution\n    is possibly a _good enough_ first step.\n\nThere was some discussion about how we want to go about addressing\nspamming in the network:\n  * Is it good enough to deploy something today that just charges a\n    simple, capped upfront fee (eg 1 sat per hop) that solves jamming\n    for the current state of the network and allows us to learn\n    something then iterate?\n  * Should our first attempt at solving this issue be for a future\n    steady state where nodes have significant traffic and nodes face\n    real opportunity cost (in the form of lost revenue) if they are\n    targeted by a jamming attack?\n\n3. Circuit Breaker Update\n  * Circuit breaker has a UI now, and some issues are being opened in\n    the repo so people have at minimum gone through the effort to spin\n    it up.\n  * It's still pretty manual, but it does provide node operators with\n    information about the payment failures on their nodes (not easily\n    surfaced in many LN UIs).\n  * Hoping to get insights into stuck HTLCs and spam HTLCs so that we\n    can learn from real life experience.\n  * Circuit breaker is generally pushing in the same direction as the\n    reputation scheme in [3], just a more manual one. We could\n    possibly use it to visualize the endorsement system in [3] before\n    enforcing it.\n  * While circuit breaker isn't necessarily *the* solution to solving\n    jamming on LN, it provides us with some data points and a\n    practical way for individual operators to address spamming of\n    their nodes.\n\n3. Tokens Update\nSince our last discussion an architecture document was added to the\nproposal [6], details in the mailing list post [7]. The main goal is\nto try to dissociate the people paying the fees from those gaining the\nbenefits from the credentials, so that credentials can be paid by a\nLSP (for example).\n\n4. Reputation discussions in LSP Specification\nSome attendees have been working on a reputation system for the LSP\nspecification group [8]. This system is intended to provide standard\nmetrics about what makes a node good/bad to connect to in the context\nof a decentralized marketplace. While this work looks at the problem\nfrom a different perspective, there's a possibility to consolidate\nthe efforts. It seems particularly useful in the anti-jamming case\nwhere a node has newly connected to you, and needs a \"start state\"\nreputation score. The idea of defining what qualifies as good\nbehavior in the Lightning Network is useful across the board. The\nLSP specification group also has bi-weekly calls, and welcomes\nadditional participants!\n\n5. Call Cadence\nAttendees agreed to continue with calls every two weeks. General\nconsensus was that we would aim for a 30 minute meeting with the\noption to extend to an hour if discussion warrants it.\n\n# What's next\nThanks to everyone who attended last week's meeting, we hope to see\nmore folks in the next one!\n\nThere's a lot to discuss - brave readers who made it all the way to\nthe bottom of this email will notice a fair number of question marks\nscattered about - and we're going to continue to break the problem\ndown into smaller parts to discuss in the hope of making progress.\n\nAny change to the Lightning Network that aims to address channel\njamming attacks will be a significant (but necessary) change to the\nprotocol, and it's going to need input from many different\nstakeholders. Please reach out here or in private\n(carla at chaincode.com / clara at chaincode.com) if you have any questions\n/ concerns / comments!\n\nCheers until next time,\nCarla and Clara\n(Yes, our names are confusing. No, you won't get used to it)\n\n[1]\nhttps://github.com/ClaraShk/LNJamming/blob/main/meeting-transcripts/23-01-23-transcript.md\n[2] https://github.com/lightning/bolts/pull/1052\n[3] https://eprint.iacr.org/2022/1454.pdf\n[4]\nhttps://mempool.space/lightning/node/021c97a90a411ff2b10dc2a8e32de2f29d2fa49d41bfbb52bd416e460db0747d0d\n[5] https://github.com/lightning/bolts/pull/1044\n[6] https://github.com/lightning/bolts/pull/1043\n[8] https://github.com/BitcoinAndLightningLayerSpecs/lsp/issues/12\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230130/95a70748/attachment.html>", "summary": "The Lightning Network community resumed their fortnightly channel jamming mitigation calls for 2023, discussing upgrade mechanisms and upfront fees."}, {"author": "Antoine Riard", "date": "2023-01-31T05:43:52", "message_text_only": "Hi Clara,\n\n\n>  * They will likely require a network wide upgrade: when a sender\n\n>    makes a payment, the full path will need to understand the new\n\n>    feature bit for it to be used.\n\n\nI believe the upgradeability dimension is different both for circuit breaker\nand staking credentials -- Circuit breaker is a point-level deployment and\ncan be rolled out without cooperation of the channel peers. Staking\ncredentials is end-to-end and just requires cooperation between endpoints\n(HTLC senders and routing hops, not even all on the payment paths).\n\n\nAnd I think upfront fees is a link-level one, probably the one requesting the\nmost cooperation between the community of developers/node operators.\n\n\nPoint-to-point/end-to-end deployment already provides benefits with\n\"half-state\"\ndeployment, I think. However, you might have \"holistic\" beneficial effects\nof link-level solutions (in terms of economic engineering not in terms of\nsoftware compatibility), I don't know.\n\n\n>  * Sending nodes are unlikely to be incentivised to upgrade to\n\n>    support a channel jamming mitigation, as jamming mitigations incur\n\n>    additional cost (be it in the form of upfront fees, tokens or some\n\n>    other mechanism).\n\n\nAs with any \"unpatched\" security risks we're encumbering on Lightning\n(pinnings, time-dilation, etc), beyond clearly describing the attack in\nreference documents and proof-of-concept of the attack against\nimplementations, the next step to keep raising awareness is a live demo as\nmuch near as one can from really mainet conditions. While we were patching\nCVE-2021-41591 and friends, I've been testing the solidity of the fixes on\nthe Eclair-side in a \"black-box\" manner. Always worth it, you learn on the\nattack bounds.\n\n\nWe could do the same with jamming attacks, as there is a wide-range of\nscenarios\nto consider (network-wide/merchant/routing hops) and few optimizations\ntricks like looping. Just have to be super careful with any demo exploits\ntoolchain, there is always a question of ethics here.\n\n\n>  * Routing nodes have no way of knowing whether a payment comes from\n\n>    a node that is not upgraded, or simply doesn't want to pay the\n\n>    additional cost introduced by a jamming mitigation.\n\n\nI think a routing node able to know if the payment sender has upgraded could\nconstitute a version/implementation fingerprint and a downgrade in HTLC traffic\nprivacy, ideally a routing node should not be able to link payeer/payee.\n\n\nIf a sender does not want to pay the jamming mitigation cost, it might be a\nflaw in the incentive-compatibility benefit of a mitigation.\n\n\n(And in terms of evaluating the\nincentives-compatibility/economic-efficiency of any solution, we're going\nto run quickly in hard questions of economic methodology, a bit beyond the\nsoftware engineering realm).\n\n\n> It was generally agreed that the network is still in an early enough\n\n> stage that it is fair for relaying nodes to initially upgrade but not\n\n> enforce the feature, and later look at forwarding traffic to determine\n\n> whether it is appropriate to require the feature.\n\n\nIf we look at the recent history of mempool policy upgrades on the\nBitcoin Core-side,\nI think it's best practice to be more conservative in terms of \"smooth\nfeature\" deployment, even feature-gated beyond some node operator setting. At\ntime of feature enforcement, some node operators might claim an established\nclaim on other flows of HTLC traffic, and there would be a question of\nbackward-compatibility arising.\n\n\nIndependently, there is the fact on how discrepancies in feature activation\ncould be exploited (privacy-wise or economically-wise). Same issue we have\non the Bitcoin Core-side, when we update the mempool policy, and old nodes\nmight not see new types of outputs (e.g Taproot spends being non-standard\nbefore the activation iirc).\n\n\n> This will require sending nodes to opt-in to the new feature before the\nnetwork can\n\n> widely enforce it, as no rational routing node will require a feature\n\n> which would reduce its ability to serve un-upgraded traffic (unless\n\n> under attack, which is not the case at present).\n\n\nI think the corollary holds -- A rational routing node will not require a\nfeature which would reduce its ability to serve upgraded traffic.\n\n\nNote, I think the \"rational\" routing node could be better defined,\notherwise I think we'll run quickly in the same bottlenecked discussions\nabout \"policy rules\" compatible with miners incentives, as we're seeing on\nthe Core-side. So far, I don't think we have a consistent model of miners\nincentives.\n\n\n> A note was also made that wallets tend to upgrade less frequently, in\n\n> part because some providers run forked versions of LN implementations,\n\n> so this horizon may be quite long. It was emphasized that this type of\n\n> network upgrade would require input from wallets, designers and\n\n> application developers anyway, so hopefully by the time we look to\n\n> deploy a change there is rough consensus among the Lightning community\n\n> already.\n\n\nYeah, we have the same issues with transaction-relay/mempool policy or even the\nnon-really specified addr-relay strategy of Bitcoin Core, when there is\n\nan upgrade there. It sounds to me there are no well-maintained public and open\ncommunication channels where protocol developers can reach out to\nwallet softwares\nvendors for protocol upgrades feedback (and vice-versa). I don't know if\nit's one goal of the LSP spec effort. If you're building a wallet, you're\nprobably going to assemble and maintain components from the two layers.\n\n\n>  * Nodes can advertise custom upfront fee rates if desired, but to\n\n>    save gossip bandwidth we assume a network-wide default of 1%.\n\n\nI think you will have an additional issue here. The routing convergence delay\nnetwork-wide might be a bottleneck in how much fee rate variances you have\nflexibility as a routing node operator. Routing convergence delays have\nbeen studied in the past at 2,500 seconds for the worst-audience, I don't\nthink it's going to hold with network graph growth.\n\n\n>  * Upfront fees accumulate along the route (as htlc payment amounts\n\n>    do), and are simply pushed to the `to_remote` balance on\n\n>    `update_add_htlc`.\n\n\nI wonder if there is a concern of an \"upfront fee\" extraction issue at the\nchannel-level. You have Alice and you have Bob, Bob circular loop to\naccumulate max `upfront_fee` on his `to_remote` balance on Alice's commitment\ntransaction. Then provoke a force-close by Alice to have her paying the\non-chain fees in the post-anchor output model.\n\n\nThere can be an interesting \"upfront fees\" siphoning issue here.\n\n\n> The interaction between upfront fees and possible future protocol\n\n> changes such as inbound fees and negative fees was briefly discussed,\n\n> specifically the case where a node sets low (or negative) fees to\n\n> attract traffic then fails payments to accumulate upfront fees. As is,\n\n> all implementations\u2019 algorithms optimize for factors other than fees -\n\n> specifically avoiding a node once it's produced failures - and we\n\n> suspect that careful sender-side behavior will mitigate this risk.\n\n> However, it was also acknowledged that a node that attempts this attack\n\n> may be able to fool multiple individual senders and still be able to\n\n> accumulate some fees.\n\n\nCorrecting upfront fees abuses sounds simple as long as you assume the scoring\nis done by the endpoint. When you start to have gossip and routing scoring\ndelegation, you might be hijacked by an \"accumulating fees\" adversary. E.g,\none could sybil the rapid-gossip-sync servers, if their deployment becomes\nubiquitous [1]. Same issue with Electrum servers lack of incentives\nalignment.\n\n\n> However, Bob has no real incentive to forward the HTLC to Carol and\n\n> push her the 4100 msat because that value is more than the fees he'll\n\n> earn from successfully forwarding and settling the HTLC (10 msat\n\n> upfront fees + 1000 msat success case fees). It's worth noting that\n\n> this type of fee differential already exists in the network today - I\n\n> got these example numbers by looking at the fee rates of the Loop\n\n> node's peers [4].\n\n\nYes, \"fee differential\" issues have been discussed affecting upfront fees and\nall the hold fees variants in the past. I'm not sure they're acceptable fee\nrisks, if you can exploit them by setting correctly the channel\ntopologies around\na victim routing hop.\n\n\n>  * Whether we should look into a more complicated approach that\n\n>    includes a \"proof of forward\" secret in the next node's onion which\n\n>    must be supplied to claim the upfront fee.\n\n\nOne of the hard things with a \"proof of forward\" is a hop colluding with\nthe next counterparty in way non-provable to the HTLC sender. I don't think\nmore reliable onion errors will save the mechanism, as you might always\nmasquerade your routing node offliness (sure -- it might be penalized by\nrouting algorithms still probably a period of grace exploitable)\n\n\n>  * Whether Bob _would_ steal the upfront fee by dropping the payment,\n\n>    as it'll impact nodes' desire to route through them in future.\n\n\nAnd if you have \"floating\" upfront fees to adjust to routing node\nopportunity cost and the routing algorithms historical buckets are not\ncorrecting the variations, a \"upfront fee\" adversary might be able to steal\nthe amount, in a proportion not corrected by the penalty.\n\n\n>  * Is there a way to deliver upfront fees to nodes along the route\n\n>    *without* them adding up along the route (other than the naive\n\n>    version of sending each hop a payment, which comes with its own\n\n>    problems)? Seems not, but bright ideas are wanted and welcome!\n\n\nI think the latest update of the Staking Credentials could answer such\ndescription\nof \"delivering the upfront fees to nodes along the route *without* them\nadding up along the route\" as the credential issuance is separated from its\nredemption.\n\n\nOn a few other ideas, \"magically\" teleporting the fee payment to the\nrouting hops, it has been browsed in the past [2].\n\n\n>  * That nodes will decide where they fall in the trade-off of setting\n\n>    upfront fees to cover their opportunity cost for high routing fees\n\n>    and market pressure to keep these fees low for the sake of\n\n>    remaining competitive.\n\n\nThey will probably need to do real-time monitoring of the congestion rates\nand outcome results of their HTLC forwarding to adjust in consequence their\nrouting fees.\n\n\n>   * A taproot tree for all HTLCs where each leaf has a subset of HTLCs,\n\n>     and fees could be incorporated here (summary note: apparently some\n\n>     work has been done here, but I couldn't find the link).\n\n\nThe idea of summing up the taproot tree for all HTLCs is discussed here\nwith past references [3]. I don't know if it's really a viable direction,\nas aggregating the claim of HTLCs of different values in the same witness\nclaims might open the door to transaction-relay games.\n\n\n>   * If we're confident that a more complicated solution will solve many\n\n>     problems, then we should pursue them, otherwise a simple solution\n\n>     is possibly a _good enough_ first step.\n\n\nIf the \"proof of forward\" can be solved by \"magic\" covenant is still an open\nissue. I don't know if it's a viable solution as it's more a hard synchronicity\nissue between chain of contracts. However from exploring issue we might\nlearn interesting design considerations for contracting protocols (at the\nvery least some semi-formal proof it's not possible)\n\n\n>  * Should our first attempt at solving this issue be for a future\n\n>    steady state where nodes have significant traffic and nodes face\n\n>    real opportunity cost (in the form of lost revenue) if they are\n\n>    targeted by a jamming attack?\n\n\nDeferring the most economically-efficient solution we can come from, we might\nrun into a bunch of incentives-misallignment between generation of nodes\noperators and Lightning use-cases. Maybe same as we have seen with lack of\ntransaction replacement, first-seen RBF, opt-in RBF, mempoolfullrbf, I\nbelieve.\n\n\nOn the other-side, the deployment of a simple solution would enable us to\nstart to build a consistent model of how the economics of channel\ncongestion, that we can \"transpose\" for more advanced solutions (ideally --\nall other things being equal).\n\n\n>  * While circuit breaker isn't necessarily *the* solution to solving\n\n>    jamming on LN, it provides us with some data points and a\n\n>    practical way for individual operators to address spamming of\n\n>    their nodes.\n\n\nAs mentioned above, it sounds like the congestion monitoring and HTLCs\nresolution tracking is going to be a standard task among LN\nimplementations, and that you'll would probably need a piece of\ninfrastructure like circuit breaker for all implementations.\n\n\n> Since our last discussion an architecture document was added to the\n\n> proposal [6], details in the mailing list post [7]. The main goal is\n\n> to try to dissociate the people paying the fees from those gaining the\n\n> benefits from the credentials, so that credentials can be paid by a\n\n> LSP (for example).\n\n\nI think there is a missing footnote, I believe the mail thread might have\nbeen this one:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2023-January/003822.html\n\n\nBeyond delegation as mentioned, there are few other design goals targeted:\n\n- strong economic-efficiency due to credentials accumulation\n\n- fungibility of their credentials between their issuance and redemption\n\n- dynamic-management of liquidity risks\n\n- contract-agnostic (e.g can cover dual-opening)\n\n\nProbably, we'll have the credential issuance flow and extension gossip more\nspeced out before next meetings.\n\n\n> 4. Reputation discussions in LSP Specification\n\n> Some attendees have been working on a reputation system for the LSP\n\n> specification group [8]. This system is intended to provide standard\n\n> metrics about what makes a node good/bad to connect to in the context\n\n> of a decentralized marketplace. While this work looks at the problem\n\n> from a different perspective, there's a possibility to consolidate\n\n> the efforts. It seems particularly useful in the anti-jamming case\n\n> where a node has newly connected to you, and needs a \"start state\"\n\n> reputation score. The idea of defining what qualifies as good\n\n> behavior in the Lightning Network is useful across the board. The\n\n> LSP specification group also has bi-weekly calls, and welcomes\n\n> additional participants!\n\n\nEffectively, I think distributed market infrastructure design could benefit\nfrom the lessons of the Lightning Network. It could be fruitful for the LSP\nspecification group to have its own mailing list at some point in the\nfuture.\n\n\n> There's a lot to discuss - brave readers who made it all the way to\n\n> the bottom of this email will notice a fair number of question marks\n\n> scattered about - and we're going to continue to break the problem\n\n> down into smaller parts to discuss in the hope of making progress.\n\n\nBeyond archiving well the problem space, there is also an effort of\ndocumenting well any protocol design decisions to preserve future\nevolvability and achieve interoperability between implementations.\n\n\n> Any change to the Lightning Network that aims to address channel\n\n> jamming attacks will be a significant (but necessary) change to the\n\n> protocol\n\n\nFor sure, this is a significant change to the protocol, beyond that we\nshould be careful to not downgrade the throughput or operations of the\nbase-layer. If the original Stakes Certificates would have been\nimplemented, it would have constituted a mempool congestion risk, where the\nnode operators under jamming would have forced attackers to pay for fresh\nUTXOs. If we have to envision such cross-layer mitigation design in the\nfuture, I think we might have to do cross-layer consensus building.\n\n\nBest,\n\nAntoine\n\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-May/003594.html\n\n[1] https://github.com/lightningdevkit/rapid-gossip-sync-server\n\n[2] https://jamming-dev.github.io/book/4-design_space.html\n\n[3] https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/26\n\n[4]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-November/002884.html\n\nLe lun. 30 janv. 2023 \u00e0 15:25, Carla Kirk-Cohen <kirkcohenc at gmail.com> a\n\u00e9crit :\n\n> Hi list,\n>\n> On Monday last week we resumed our fortnightly channel jamming\n> mitigation calls for 2023.\n>\n> Details for the next call:\n> * Monday 02/06 @ 18:00 UTC\n> * https://meet.jit.si/UnjammingLN\n> * Agenda: https://github.com/ClaraShk/LNJamming/issues/2\n>\n> # Meeting Summary\n> This email attempts to summarize the discussion, but is of course\n> subject to my errors and opinions so the full transcript is available\n> at [1]. It is (imperfectly) AI generated, so please reach out to myself\n> or Clara if you'd like clarification for a specific section.\n>\n> 1. Upgrade Mechanisms\n> The first topic of discussion was around how we would go about\n> upgrading the network to support an anti-jamming mitigation. Most\n> solutions share the following characteristics:\n>   * They will likely require a network wide upgrade: when a sender\n>     makes a payment, the full path will need to understand the new\n>     feature bit for it to be used.\n>   * Sending nodes are unlikely to be incentivised to upgrade to\n>     support a channel jamming mitigation, as jamming mitigations incur\n>     additional cost (be it in the form of upfront fees, tokens or some\n>     other mechanism).\n>   * Routing nodes have no way of knowing whether a payment comes from\n>     a node that is not upgraded, or simply doesn't want to pay the\n>     additional cost introduced by a jamming mitigation.\n>\n> It was generally agreed that the network is still in an early enough\n> stage that it is fair for relaying nodes to initially upgrade but not\n> enforce the feature, and later look at forwarding traffic to determine\n> whether it is appropriate to require the feature. This will require\n> sending nodes to opt-in to the new feature before the network can\n> widely enforce it, as no rational routing node will require a feature\n> which would reduce its ability to serve un-upgraded traffic (unless\n> under attack, which is not the case at present).\n>\n> A note was also made that wallets tend to upgrade less frequently, in\n> part because some providers run forked versions of LN implementations,\n> so this horizon may be quite long. It was emphasized that this type of\n> network upgrade would require input from wallets, designers and\n> application developers anyway, so hopefully by the time we look to\n> deploy a change there is rough consensus among the Lightning community\n> already.\n>\n> 2. Upfront Fees\n> Next, we discussed the draft proposal for upfront fees [2] that\n> implements the first of a two-part jamming mitigation described in [3].\n> As it stands, the PR describes the simplest possible way to introduce\n> upfront fees to the protocol:\n>   * Upfront fees are expressed as a ppm of a channel's success-case\n>     fees, and charged on the outgoing link of a route.\n>   * Nodes can advertise custom upfront fee rates if desired, but to\n>     save gossip bandwidth we assume a network-wide default of 1%.\n>   * Upfront fees accumulate along the route (as htlc payment amounts\n>     do), and are simply pushed to the `to_remote` balance on\n>     `update_add_htlc`.\n>   * Final hop nodes advertise an upfront fee policy in bolt 11 invoices\n>     (or bolt 12 blinded routes) which is sufficiently padded to\n>     obfuscate their location in the route.\n>\n> The interaction between upfront fees and possible future protocol\n> changes such as inbound fees and negative fees was briefly discussed,\n> specifically the case where a node sets low (or negative) fees to\n> attract traffic then fails payments to accumulate upfront fees. As is,\n> all implementations\u2019 algorithms optimize for factors other than fees -\n> specifically avoiding a node once it's produced failures - and we\n> suspect that careful sender-side behavior will mitigate this risk.\n> However, it was also acknowledged that a node that attempts this attack\n> may be able to fool multiple individual senders and still be able to\n> accumulate some fees.\n>\n> We then discussed the shortcomings of the \"simplest possible\" upfront\n> fees in [2], specifically focused on the following scenario where\n> nodes receive 1% of their success-case fees as an upfront payment:\n>   * Alice is sending a payment to Dave, who is a popular sink node in\n>     the network.\n>   * Bob -> Carol has low/default routing policy: 1000 msat success\n>     case / 10 msat upfront fee\n>   * Carol -> Dave has high fees: 400,000 msat success case / 4000 msat\n>     upfront fee\n>   * Dave advertises no success case fee (is recipient) / 100 msat of\n>     upfront fee chosen for his invoice.\n>\n> Alice ------ Bob ------ Carol ------ Dave\n>\n> Since we need to source all of these funds from the sender (Alice), the\n> forwarding of funds is as follows:\n>   * Alice pushes 4110 msat to Bob.\n>   * Bob _should_ push 4100 msat to Carol, claiming his 10 msat upfront\n>     fee.\n>   * Carol _should_ push 100 msat to Dave, claiming her 4000 msat\n>     upfront fee.\n>\n> However, Bob has no real incentive to forward the HTLC to Carol and\n> push her the 4100 msat because that value is more than the fees he'll\n> earn from successfully forwarding and settling the HTLC (10 msat\n> upfront fees + 1000 msat success case fees). It's worth noting that\n> this type of fee differential already exists in the network today - I\n> got these example numbers by looking at the fee rates of the Loop\n> node's peers [4].\n>\n> There were a few points discussed around this issue:\n>   * Whether we should look into a more complicated approach that\n>     includes a \"proof of forward\" secret in the next node's onion which\n>     must be supplied to claim the upfront fee.\n>   * Discussion about whether these order of magnitude fee differences\n>     will exist in an efficient market (differing opinions).\n>   * Whether Bob _would_ steal the upfront fee by dropping the payment,\n>     as it'll impact nodes' desire to route through them in future.\n>   * Is there a way to deliver upfront fees to nodes along the route\n>     *without* them adding up along the route (other than the naive\n>     version of sending each hop a payment, which comes with its own\n>     problems)? Seems not, but bright ideas are wanted and welcome!\n>   * That nodes will decide where they fall in the trade-off of setting\n>     upfront fees to cover their opportunity cost for high routing fees\n>     and market pressure to keep these fees low for the sake of\n>     remaining competitive.\n>\n> A few people mentioned the desire to keep an upfront fee solution as\n> simple as possible, but generally it seemed that a solution where the\n> accumulated upfront fees at any point along a route exceed any single\n> hop's expected success case fees is unacceptable because incentives\n> are misaligned (even if we can properly attribute errors with [5]).\n>\n> We touched briefly on a few \"proof of forwarding\" solutions for\n> upfront fees:\n>   * Using a locking mechanism that relies on a secret that is provided\n>     by the next node's onion.\n>   * A taproot tree for all HTLCs where each leaf has a subset of HTLCs,\n>     and fees could be incorporated here (summary note: apparently some\n>     work has been done here, but I couldn't find the link).\n>   * If we're confident that a more complicated solution will solve many\n>     problems, then we should pursue them, otherwise a simple solution\n>     is possibly a _good enough_ first step.\n>\n> There was some discussion about how we want to go about addressing\n> spamming in the network:\n>   * Is it good enough to deploy something today that just charges a\n>     simple, capped upfront fee (eg 1 sat per hop) that solves jamming\n>     for the current state of the network and allows us to learn\n>     something then iterate?\n>   * Should our first attempt at solving this issue be for a future\n>     steady state where nodes have significant traffic and nodes face\n>     real opportunity cost (in the form of lost revenue) if they are\n>     targeted by a jamming attack?\n>\n> 3. Circuit Breaker Update\n>   * Circuit breaker has a UI now, and some issues are being opened in\n>     the repo so people have at minimum gone through the effort to spin\n>     it up.\n>   * It's still pretty manual, but it does provide node operators with\n>     information about the payment failures on their nodes (not easily\n>     surfaced in many LN UIs).\n>   * Hoping to get insights into stuck HTLCs and spam HTLCs so that we\n>     can learn from real life experience.\n>   * Circuit breaker is generally pushing in the same direction as the\n>     reputation scheme in [3], just a more manual one. We could\n>     possibly use it to visualize the endorsement system in [3] before\n>     enforcing it.\n>   * While circuit breaker isn't necessarily *the* solution to solving\n>     jamming on LN, it provides us with some data points and a\n>     practical way for individual operators to address spamming of\n>     their nodes.\n>\n> 3. Tokens Update\n> Since our last discussion an architecture document was added to the\n> proposal [6], details in the mailing list post [7]. The main goal is\n> to try to dissociate the people paying the fees from those gaining the\n> benefits from the credentials, so that credentials can be paid by a\n> LSP (for example).\n>\n> 4. Reputation discussions in LSP Specification\n> Some attendees have been working on a reputation system for the LSP\n> specification group [8]. This system is intended to provide standard\n> metrics about what makes a node good/bad to connect to in the context\n> of a decentralized marketplace. While this work looks at the problem\n> from a different perspective, there's a possibility to consolidate\n> the efforts. It seems particularly useful in the anti-jamming case\n> where a node has newly connected to you, and needs a \"start state\"\n> reputation score. The idea of defining what qualifies as good\n> behavior in the Lightning Network is useful across the board. The\n> LSP specification group also has bi-weekly calls, and welcomes\n> additional participants!\n>\n> 5. Call Cadence\n> Attendees agreed to continue with calls every two weeks. General\n> consensus was that we would aim for a 30 minute meeting with the\n> option to extend to an hour if discussion warrants it.\n>\n> # What's next\n> Thanks to everyone who attended last week's meeting, we hope to see\n> more folks in the next one!\n>\n> There's a lot to discuss - brave readers who made it all the way to\n> the bottom of this email will notice a fair number of question marks\n> scattered about - and we're going to continue to break the problem\n> down into smaller parts to discuss in the hope of making progress.\n>\n> Any change to the Lightning Network that aims to address channel\n> jamming attacks will be a significant (but necessary) change to the\n> protocol, and it's going to need input from many different\n> stakeholders. Please reach out here or in private\n> (carla at chaincode.com / clara at chaincode.com) if you have any questions\n> / concerns / comments!\n>\n> Cheers until next time,\n> Carla and Clara\n> (Yes, our names are confusing. No, you won't get used to it)\n>\n> [1]\n> https://github.com/ClaraShk/LNJamming/blob/main/meeting-transcripts/23-01-23-transcript.md\n> [2] https://github.com/lightning/bolts/pull/1052\n> [3] https://eprint.iacr.org/2022/1454.pdf\n> [4]\n> https://mempool.space/lightning/node/021c97a90a411ff2b10dc2a8e32de2f29d2fa49d41bfbb52bd416e460db0747d0d\n> [5] https://github.com/lightning/bolts/pull/1044\n> [6] https://github.com/lightning/bolts/pull/1043\n> [8] https://github.com/BitcoinAndLightningLayerSpecs/lsp/issues/12\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230131/eaa2019f/attachment-0001.html>", "summary": "Upgrading the Lightning Network to mitigate channel jamming may require a network-wide upgrade, but sending nodes may not be incentivized to upgrade. Routing nodes may not know if a payment comes from an un-upgraded node."}, {"author": "Antoine Riard", "date": "2023-01-31T18:28:14", "message_text_only": "Hi Clara,\n\n\n(Reply 1/2 - Apparently there is a limit of 80KB on Lightning mailing post)\n\n\n>  * They will likely require a network wide upgrade: when a sender\n\n>    makes a payment, the full path will need to understand the new\n\n>    feature bit for it to be used.\n\n\nI believe the upgradeability dimension is different both for circuit breaker\nand staking credentials -- Circuit breaker is a point-level deployment and\ncan be rolled out without cooperation of the channel peers. Staking\ncredentials is end-to-end and just requires cooperation between endpoints\n(HTLC senders and routing hops, not even all on the payment paths).\n\n\nAnd I think upfront fees is a link-level one, probably the one requesting the\nmost cooperation between the community of developers/node operators.\n\n\nPoint-to-point/end-to-end deployment already provides benefits with\n\"half-state\"\ndeployment, I think. However, you might have \"holistic\" beneficial effects\nof link-level solutions (in terms of economic engineering not in terms of\nsoftware compatibility), I don't know.\n\n\n>  * Sending nodes are unlikely to be incentivised to upgrade to\n\n>    support a channel jamming mitigation, as jamming mitigations incur\n\n>    additional cost (be it in the form of upfront fees, tokens or some\n\n>    other mechanism).\n\n\nAs with any \"unpatched\" security risks we're encumbering on Lightning\n(pinnings, time-dilation, etc), beyond clearly describing the attack in\nreference documents and proof-of-concept of the attack against\nimplementations, the next step to keep raising awareness is a live demo as\nmuch near as one can from really mainet conditions. While we were patching\nCVE-2021-41591 and friends, I've been testing the solidity of the fixes on\nthe Eclair-side in a \"black-box\" manner. Always worth it, you learn on the\nattack bounds.\n\n\nWe could do the same with jamming attacks, as there is a wide-range of\nscenarios\nto consider (network-wide/merchant/routing hops) and few optimizations\ntricks like looping. Just have to be super careful with any demo exploits\ntoolchain, there is always a question of ethics here.\n\n\n>  * Routing nodes have no way of knowing whether a payment comes from\n\n>    a node that is not upgraded, or simply doesn't want to pay the\n\n>    additional cost introduced by a jamming mitigation.\n\n\nI think a routing node able to know if the payment sender has upgraded could\nconstitute a version/implementation fingerprint and a downgrade in HTLC traffic\nprivacy, ideally a routing node should not be able to link payeer/payee.\n\n\nIf a sender does not want to pay the jamming mitigation cost, it might be a\nflaw in the incentive-compatibility benefit of a mitigation.\n\n\n(And in terms of evaluating the\nincentives-compatibility/economic-efficiency of any solution, we're going\nto run quickly in hard questions of economic methodology, a bit beyond the\nsoftware engineering realm).\n\n\n> It was generally agreed that the network is still in an early enough\n\n> stage that it is fair for relaying nodes to initially upgrade but not\n\n> enforce the feature, and later look at forwarding traffic to determine\n\n> whether it is appropriate to require the feature.\n\n\nIf we look at the recent history of mempool policy upgrades on the\nBitcoin Core-side,\nI think it's best practice to be more conservative in terms of \"smooth\nfeature\" deployment, even feature-gated beyond some node operator setting. At\ntime of feature enforcement, some node operators might claim an established\nclaim on other flows of HTLC traffic, and there would be a question of\nbackward-compatibility arising.\n\n\nIndependently, there is the fact on how discrepancies in feature activation\ncould be exploited (privacy-wise or economically-wise). Same issue we have\non the Bitcoin Core-side, when we update the mempool policy, and old nodes\nmight not see new types of outputs (e.g Taproot spends being non-standard\nbefore the activation iirc).\n\n\n> This will require sending nodes to opt-in to the new feature before the\nnetwork can\n\n> widely enforce it, as no rational routing node will require a feature\n\n> which would reduce its ability to serve un-upgraded traffic (unless\n\n> under attack, which is not the case at present).\n\n\nI think the corollary holds -- A rational routing node will not require a\nfeature which would reduce its ability to serve upgraded traffic.\n\n\nNote, I think the \"rational\" routing node could be better defined,\notherwise I think we'll run quickly in the same bottlenecked discussions\nabout \"policy rules\" compatible with miners incentives, as we're seeing on\nthe Core-side. So far, I don't think we have a consistent model of miners\nincentives.\n\n\n> A note was also made that wallets tend to upgrade less frequently, in\n\n> part because some providers run forked versions of LN implementations,\n\n> so this horizon may be quite long. It was emphasized that this type of\n\n> network upgrade would require input from wallets, designers and\n\n> application developers anyway, so hopefully by the time we look to\n\n> deploy a change there is rough consensus among the Lightning community\n\n> already.\n\n\nYeah, we have the same issues with transaction-relay/mempool policy or even the\nnon-really specified addr-relay strategy of Bitcoin Core, when there is\n\nan upgrade there. It sounds to me there are no well-maintained public and open\ncommunication channels where protocol developers can reach out to\nwallet softwares\nvendors for protocol upgrades feedback (and vice-versa). I don't know if\nit's one goal of the LSP spec effort. If you're building a wallet, you're\nprobably going to assemble and maintain components from the two layers.\n\n\n>  * Nodes can advertise custom upfront fee rates if desired, but to\n\n>    save gossip bandwidth we assume a network-wide default of 1%.\n\n\nI think you will have an additional issue here. The routing convergence delay\nnetwork-wide might be a bottleneck in how much fee rate variances you have\nflexibility as a routing node operator. Routing convergence delays have\nbeen studied in the past at 2,500 seconds for the worst-audience, I don't\nthink it's going to hold with network graph growth.\n\n\n>  * Upfront fees accumulate along the route (as htlc payment amounts\n\n>    do), and are simply pushed to the `to_remote` balance on\n\n>    `update_add_htlc`.\n\n\nI wonder if there is a concern of an \"upfront fee\" extraction issue at the\nchannel-level. You have Alice and you have Bob, Bob circular loop to\naccumulate max `upfront_fee` on his `to_remote` balance on Alice's commitment\ntransaction. Then provoke a force-close by Alice to have her paying the\non-chain fees in the post-anchor output model.\n\n\nThere can be an interesting \"upfront fees\" siphoning issue here.\n\n\n> The interaction between upfront fees and possible future protocol\n\n> changes such as inbound fees and negative fees was briefly discussed,\n\n> specifically the case where a node sets low (or negative) fees to\n\n> attract traffic then fails payments to accumulate upfront fees. As is,\n\n> all implementations\u2019 algorithms optimize for factors other than fees -\n\n> specifically avoiding a node once it's produced failures - and we\n\n> suspect that careful sender-side behavior will mitigate this risk.\n\n> However, it was also acknowledged that a node that attempts this attack\n\n> may be able to fool multiple individual senders and still be able to\n\n> accumulate some fees.\n\n\nCorrecting upfront fees abuses sounds simple as long as you assume the scoring\nis done by the endpoint. When you start to have gossip and routing scoring\ndelegation, you might be hijacked by an \"accumulating fees\" adversary. E.g,\none could sybil the rapid-gossip-sync servers, if their deployment becomes\nubiquitous [1]. Same issue with Electrum servers lack of incentives\nalignment.\n\n\n> However, Bob has no real incentive to forward the HTLC to Carol and\n\n> push her the 4100 msat because that value is more than the fees he'll\n\n> earn from successfully forwarding and settling the HTLC (10 msat\n\n> upfront fees + 1000 msat success case fees). It's worth noting that\n\n> this type of fee differential already exists in the network today - I\n\n> got these example numbers by looking at the fee rates of the Loop\n\n> node's peers [4].\n\n\nYes, \"fee differential\" issues have been discussed affecting upfront fees and\nall the hold fees variants in the past. I'm not sure they're acceptable fee\nrisks, if you can exploit them by setting correctly the channel\ntopologies around\na victim routing hop.\n\n\nEnd of 1/2.\n\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-May/003594.html\n\n[1]  https://github.com/lightningdevkit/rapid-gossip-sync-server\n\nLe lun. 30 janv. 2023 \u00e0 15:25, Carla Kirk-Cohen <kirkcohenc at gmail.com> a\n\u00e9crit :\n\n> Hi list,\n>\n> On Monday last week we resumed our fortnightly channel jamming\n> mitigation calls for 2023.\n>\n> Details for the next call:\n> * Monday 02/06 @ 18:00 UTC\n> * https://meet.jit.si/UnjammingLN\n> * Agenda: https://github.com/ClaraShk/LNJamming/issues/2\n>\n> # Meeting Summary\n> This email attempts to summarize the discussion, but is of course\n> subject to my errors and opinions so the full transcript is available\n> at [1]. It is (imperfectly) AI generated, so please reach out to myself\n> or Clara if you'd like clarification for a specific section.\n>\n> 1. Upgrade Mechanisms\n> The first topic of discussion was around how we would go about\n> upgrading the network to support an anti-jamming mitigation. Most\n> solutions share the following characteristics:\n>   * They will likely require a network wide upgrade: when a sender\n>     makes a payment, the full path will need to understand the new\n>     feature bit for it to be used.\n>   * Sending nodes are unlikely to be incentivised to upgrade to\n>     support a channel jamming mitigation, as jamming mitigations incur\n>     additional cost (be it in the form of upfront fees, tokens or some\n>     other mechanism).\n>   * Routing nodes have no way of knowing whether a payment comes from\n>     a node that is not upgraded, or simply doesn't want to pay the\n>     additional cost introduced by a jamming mitigation.\n>\n> It was generally agreed that the network is still in an early enough\n> stage that it is fair for relaying nodes to initially upgrade but not\n> enforce the feature, and later look at forwarding traffic to determine\n> whether it is appropriate to require the feature. This will require\n> sending nodes to opt-in to the new feature before the network can\n> widely enforce it, as no rational routing node will require a feature\n> which would reduce its ability to serve un-upgraded traffic (unless\n> under attack, which is not the case at present).\n>\n> A note was also made that wallets tend to upgrade less frequently, in\n> part because some providers run forked versions of LN implementations,\n> so this horizon may be quite long. It was emphasized that this type of\n> network upgrade would require input from wallets, designers and\n> application developers anyway, so hopefully by the time we look to\n> deploy a change there is rough consensus among the Lightning community\n> already.\n>\n> 2. Upfront Fees\n> Next, we discussed the draft proposal for upfront fees [2] that\n> implements the first of a two-part jamming mitigation described in [3].\n> As it stands, the PR describes the simplest possible way to introduce\n> upfront fees to the protocol:\n>   * Upfront fees are expressed as a ppm of a channel's success-case\n>     fees, and charged on the outgoing link of a route.\n>   * Nodes can advertise custom upfront fee rates if desired, but to\n>     save gossip bandwidth we assume a network-wide default of 1%.\n>   * Upfront fees accumulate along the route (as htlc payment amounts\n>     do), and are simply pushed to the `to_remote` balance on\n>     `update_add_htlc`.\n>   * Final hop nodes advertise an upfront fee policy in bolt 11 invoices\n>     (or bolt 12 blinded routes) which is sufficiently padded to\n>     obfuscate their location in the route.\n>\n> The interaction between upfront fees and possible future protocol\n> changes such as inbound fees and negative fees was briefly discussed,\n> specifically the case where a node sets low (or negative) fees to\n> attract traffic then fails payments to accumulate upfront fees. As is,\n> all implementations\u2019 algorithms optimize for factors other than fees -\n> specifically avoiding a node once it's produced failures - and we\n> suspect that careful sender-side behavior will mitigate this risk.\n> However, it was also acknowledged that a node that attempts this attack\n> may be able to fool multiple individual senders and still be able to\n> accumulate some fees.\n>\n> We then discussed the shortcomings of the \"simplest possible\" upfront\n> fees in [2], specifically focused on the following scenario where\n> nodes receive 1% of their success-case fees as an upfront payment:\n>   * Alice is sending a payment to Dave, who is a popular sink node in\n>     the network.\n>   * Bob -> Carol has low/default routing policy: 1000 msat success\n>     case / 10 msat upfront fee\n>   * Carol -> Dave has high fees: 400,000 msat success case / 4000 msat\n>     upfront fee\n>   * Dave advertises no success case fee (is recipient) / 100 msat of\n>     upfront fee chosen for his invoice.\n>\n> Alice ------ Bob ------ Carol ------ Dave\n>\n> Since we need to source all of these funds from the sender (Alice), the\n> forwarding of funds is as follows:\n>   * Alice pushes 4110 msat to Bob.\n>   * Bob _should_ push 4100 msat to Carol, claiming his 10 msat upfront\n>     fee.\n>   * Carol _should_ push 100 msat to Dave, claiming her 4000 msat\n>     upfront fee.\n>\n> However, Bob has no real incentive to forward the HTLC to Carol and\n> push her the 4100 msat because that value is more than the fees he'll\n> earn from successfully forwarding and settling the HTLC (10 msat\n> upfront fees + 1000 msat success case fees). It's worth noting that\n> this type of fee differential already exists in the network today - I\n> got these example numbers by looking at the fee rates of the Loop\n> node's peers [4].\n>\n> There were a few points discussed around this issue:\n>   * Whether we should look into a more complicated approach that\n>     includes a \"proof of forward\" secret in the next node's onion which\n>     must be supplied to claim the upfront fee.\n>   * Discussion about whether these order of magnitude fee differences\n>     will exist in an efficient market (differing opinions).\n>   * Whether Bob _would_ steal the upfront fee by dropping the payment,\n>     as it'll impact nodes' desire to route through them in future.\n>   * Is there a way to deliver upfront fees to nodes along the route\n>     *without* them adding up along the route (other than the naive\n>     version of sending each hop a payment, which comes with its own\n>     problems)? Seems not, but bright ideas are wanted and welcome!\n>   * That nodes will decide where they fall in the trade-off of setting\n>     upfront fees to cover their opportunity cost for high routing fees\n>     and market pressure to keep these fees low for the sake of\n>     remaining competitive.\n>\n> A few people mentioned the desire to keep an upfront fee solution as\n> simple as possible, but generally it seemed that a solution where the\n> accumulated upfront fees at any point along a route exceed any single\n> hop's expected success case fees is unacceptable because incentives\n> are misaligned (even if we can properly attribute errors with [5]).\n>\n> We touched briefly on a few \"proof of forwarding\" solutions for\n> upfront fees:\n>   * Using a locking mechanism that relies on a secret that is provided\n>     by the next node's onion.\n>   * A taproot tree for all HTLCs where each leaf has a subset of HTLCs,\n>     and fees could be incorporated here (summary note: apparently some\n>     work has been done here, but I couldn't find the link).\n>   * If we're confident that a more complicated solution will solve many\n>     problems, then we should pursue them, otherwise a simple solution\n>     is possibly a _good enough_ first step.\n>\n> There was some discussion about how we want to go about addressing\n> spamming in the network:\n>   * Is it good enough to deploy something today that just charges a\n>     simple, capped upfront fee (eg 1 sat per hop) that solves jamming\n>     for the current state of the network and allows us to learn\n>     something then iterate?\n>   * Should our first attempt at solving this issue be for a future\n>     steady state where nodes have significant traffic and nodes face\n>     real opportunity cost (in the form of lost revenue) if they are\n>     targeted by a jamming attack?\n>\n> 3. Circuit Breaker Update\n>   * Circuit breaker has a UI now, and some issues are being opened in\n>     the repo so people have at minimum gone through the effort to spin\n>     it up.\n>   * It's still pretty manual, but it does provide node operators with\n>     information about the payment failures on their nodes (not easily\n>     surfaced in many LN UIs).\n>   * Hoping to get insights into stuck HTLCs and spam HTLCs so that we\n>     can learn from real life experience.\n>   * Circuit breaker is generally pushing in the same direction as the\n>     reputation scheme in [3], just a more manual one. We could\n>     possibly use it to visualize the endorsement system in [3] before\n>     enforcing it.\n>   * While circuit breaker isn't necessarily *the* solution to solving\n>     jamming on LN, it provides us with some data points and a\n>     practical way for individual operators to address spamming of\n>     their nodes.\n>\n> 3. Tokens Update\n> Since our last discussion an architecture document was added to the\n> proposal [6], details in the mailing list post [7]. The main goal is\n> to try to dissociate the people paying the fees from those gaining the\n> benefits from the credentials, so that credentials can be paid by a\n> LSP (for example).\n>\n> 4. Reputation discussions in LSP Specification\n> Some attendees have been working on a reputation system for the LSP\n> specification group [8]. This system is intended to provide standard\n> metrics about what makes a node good/bad to connect to in the context\n> of a decentralized marketplace. While this work looks at the problem\n> from a different perspective, there's a possibility to consolidate\n> the efforts. It seems particularly useful in the anti-jamming case\n> where a node has newly connected to you, and needs a \"start state\"\n> reputation score. The idea of defining what qualifies as good\n> behavior in the Lightning Network is useful across the board. The\n> LSP specification group also has bi-weekly calls, and welcomes\n> additional participants!\n>\n> 5. Call Cadence\n> Attendees agreed to continue with calls every two weeks. General\n> consensus was that we would aim for a 30 minute meeting with the\n> option to extend to an hour if discussion warrants it.\n>\n> # What's next\n> Thanks to everyone who attended last week's meeting, we hope to see\n> more folks in the next one!\n>\n> There's a lot to discuss - brave readers who made it all the way to\n> the bottom of this email will notice a fair number of question marks\n> scattered about - and we're going to continue to break the problem\n> down into smaller parts to discuss in the hope of making progress.\n>\n> Any change to the Lightning Network that aims to address channel\n> jamming attacks will be a significant (but necessary) change to the\n> protocol, and it's going to need input from many different\n> stakeholders. Please reach out here or in private\n> (carla at chaincode.com / clara at chaincode.com) if you have any questions\n> / concerns / comments!\n>\n> Cheers until next time,\n> Carla and Clara\n> (Yes, our names are confusing. No, you won't get used to it)\n>\n> [1]\n> https://github.com/ClaraShk/LNJamming/blob/main/meeting-transcripts/23-01-23-transcript.md\n> [2] https://github.com/lightning/bolts/pull/1052\n> [3] https://eprint.iacr.org/2022/1454.pdf\n> [4]\n> https://mempool.space/lightning/node/021c97a90a411ff2b10dc2a8e32de2f29d2fa49d41bfbb52bd416e460db0747d0d\n> [5] https://github.com/lightning/bolts/pull/1044\n> [6] https://github.com/lightning/bolts/pull/1043\n> [8] https://github.com/BitcoinAndLightningLayerSpecs/lsp/issues/12\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230131/bbef78be/attachment-0001.html>", "summary": "Upgrading Lightning network for channel jamming mitigation may require network-wide cooperation, and incentivizing nodes to upgrade may be challenging. Privacy concerns also arise."}, {"author": "Antoine Riard", "date": "2023-01-31T18:29:38", "message_text_only": "(Reply 2/2)\n\n>  * Whether we should look into a more complicated approach that\n\n>    includes a \"proof of forward\" secret in the next node's onion which\n\n>    must be supplied to claim the upfront fee.\n\n\nOne of the hard things with a \"proof of forward\" is a hop colluding with\nthe next counterparty in way non-provable to the HTLC sender. I don't think\nmore reliable onion errors will save the mechanism, as you might always\nmasquerade your routing node offliness (sure -- it might be penalized by\nrouting algorithms still probably a period of grace exploitable)\n\n\n>  * Whether Bob _would_ steal the upfront fee by dropping the payment,\n\n>    as it'll impact nodes' desire to route through them in future.\n\n\nAnd if you have \"floating\" upfront fees to adjust to routing node\nopportunity cost and the routing algorithms historical buckets are not\ncorrecting the variations, a \"upfront fee\" adversary might be able to steal\nthe amount, in a proportion not corrected by the penalty.\n\n\n>  * Is there a way to deliver upfront fees to nodes along the route\n\n>    *without* them adding up along the route (other than the naive\n\n>    version of sending each hop a payment, which comes with its own\n\n>    problems)? Seems not, but bright ideas are wanted and welcome!\n\n\nI think the latest update of the Staking Credentials could answer such\ndescription\nof \"delivering the upfront fees to nodes along the route *without* them\nadding up along the route\" as the credential issuance is separated from its\nredemption.\n\n\nOn a few other ideas, \"magically\" teleporting the fee payment to the\nrouting hops, it has been browsed in the past [2].\n\n\n>  * That nodes will decide where they fall in the trade-off of setting\n\n>    upfront fees to cover their opportunity cost for high routing fees\n\n>    and market pressure to keep these fees low for the sake of\n\n>    remaining competitive.\n\n\nThey will probably need to do real-time monitoring of the congestion rates\nand outcome results of their HTLC forwarding to adjust in consequence their\nrouting fees.\n\n\n>   * A taproot tree for all HTLCs where each leaf has a subset of HTLCs,\n\n>     and fees could be incorporated here (summary note: apparently some\n\n>     work has been done here, but I couldn't find the link).\n\n\nThe idea of summing up the taproot tree for all HTLCs is discussed here\nwith past references [3]. I don't know if it's really a viable direction,\nas aggregating the claim of HTLCs of different values in the same witness\nclaims might open the door to transaction-relay games.\n\n\n>   * If we're confident that a more complicated solution will solve many\n\n>     problems, then we should pursue them, otherwise a simple solution\n\n>     is possibly a _good enough_ first step.\n\n\nIf the \"proof of forward\" can be solved by \"magic\" covenant is still an open\nissue. I don't know if it's a viable solution as it's more a hard synchronicity\nissue between chain of contracts. However from exploring issue we might\nlearn interesting design considerations for contracting protocols (at the\nvery least some semi-formal proof it's not possible)\n\n\n>  * Should our first attempt at solving this issue be for a future\n\n>    steady state where nodes have significant traffic and nodes face\n\n>    real opportunity cost (in the form of lost revenue) if they are\n\n>    targeted by a jamming attack?\n\n\nDeferring the most economically-efficient solution we can come from, we might\nrun into a bunch of incentives-misallignment between generation of nodes\noperators and Lightning use-cases. Maybe same as we have seen with lack of\ntransaction replacement, first-seen RBF, opt-in RBF, mempoolfullrbf, I\nbelieve.\n\n\nOn the other-side, the deployment of a simple solution would enable us to\nstart to build a consistent model of how the economics of channel\ncongestion, that we can \"transpose\" for more advanced solutions (ideally --\nall other things being equal).\n\n\n>  * While circuit breaker isn't necessarily *the* solution to solving\n\n>    jamming on LN, it provides us with some data points and a\n\n>    practical way for individual operators to address spamming of\n\n>    their nodes.\n\n\nAs mentioned above, it sounds like the congestion monitoring and HTLCs\nresolution tracking is going to be a standard task among LN\nimplementations, and that you'll would probably need a piece of\ninfrastructure like circuit breaker for all implementations.\n\n\n> Since our last discussion an architecture document was added to the\n\n> proposal [6], details in the mailing list post [7]. The main goal is\n\n> to try to dissociate the people paying the fees from those gaining the\n\n> benefits from the credentials, so that credentials can be paid by a\n\n> LSP (for example).\n\n\nI think there is a missing footnote, I believe the mail thread might have\nbeen this one:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2023-January/003822.html\n\n\nBeyond delegation as mentioned, there are few other design goals targeted:\n\n- strong economic-efficiency due to credentials accumulation\n\n- fungibility of their credentials between their issuance and redemption\n\n- dynamic-management of liquidity risks\n\n- contract-agnostic (e.g can cover dual-opening)\n\n\nProbably, we'll have the credential issuance flow and extension gossip more\nspeced out before next meetings.\n\n\n> 4. Reputation discussions in LSP Specification\n\n> Some attendees have been working on a reputation system for the LSP\n\n> specification group [8]. This system is intended to provide standard\n\n> metrics about what makes a node good/bad to connect to in the context\n\n> of a decentralized marketplace. While this work looks at the problem\n\n> from a different perspective, there's a possibility to consolidate\n\n> the efforts. It seems particularly useful in the anti-jamming case\n\n> where a node has newly connected to you, and needs a \"start state\"\n\n> reputation score. The idea of defining what qualifies as good\n\n> behavior in the Lightning Network is useful across the board. The\n\n> LSP specification group also has bi-weekly calls, and welcomes\n\n> additional participants!\n\n\nEffectively, I think distributed market infrastructure design could benefit\nfrom the lessons of the Lightning Network. It could be fruitful for the LSP\nspecification group to have its own mailing list at some point in the\nfuture.\n\n\n> There's a lot to discuss - brave readers who made it all the way to\n\n> the bottom of this email will notice a fair number of question marks\n\n> scattered about - and we're going to continue to break the problem\n\n> down into smaller parts to discuss in the hope of making progress.\n\n\nBeyond archiving well the problem space, there is also an effort of\ndocumenting well any protocol design decisions to preserve future\nevolvability and achieve interoperabilitybetween implementations.\n\n\n> Any change to the Lightning Network that aims to address channel\n\n> jamming attacks will be a significant (but necessary) change to the\n\n> protocol\n\n\nFor sure, this is a significant change to the protocol, beyond that we\nshould be careful to not downgrade the throughput or operations of the\nbase-layer. If the original Stakes Certificates would have been\nimplemented, it would have constituted a mempool congestion risk, where the\nnode operators under jamming would have forced attackers to pay for fresh\nUTXOs. If we have to envision such cross-layer mitigation design in the\nfuture, I think we might have to do cross-layer consensus building.\n\n\nBest,\n\nAntoine\n\n\n[2] https://jamming-dev.github.io/book/4-design_space.html\n\n[3] https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/26\n\n[4]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-November/002884.html\n\nLe lun. 30 janv. 2023 \u00e0 15:25, Carla Kirk-Cohen <kirkcohenc at gmail.com> a\n\u00e9crit :\n\n> Hi list,\n>\n> On Monday last week we resumed our fortnightly channel jamming\n> mitigation calls for 2023.\n>\n> Details for the next call:\n> * Monday 02/06 @ 18:00 UTC\n> * https://meet.jit.si/UnjammingLN\n> * Agenda: https://github.com/ClaraShk/LNJamming/issues/2\n>\n> # Meeting Summary\n> This email attempts to summarize the discussion, but is of course\n> subject to my errors and opinions so the full transcript is available\n> at [1]. It is (imperfectly) AI generated, so please reach out to myself\n> or Clara if you'd like clarification for a specific section.\n>\n> 1. Upgrade Mechanisms\n> The first topic of discussion was around how we would go about\n> upgrading the network to support an anti-jamming mitigation. Most\n> solutions share the following characteristics:\n>   * They will likely require a network wide upgrade: when a sender\n>     makes a payment, the full path will need to understand the new\n>     feature bit for it to be used.\n>   * Sending nodes are unlikely to be incentivised to upgrade to\n>     support a channel jamming mitigation, as jamming mitigations incur\n>     additional cost (be it in the form of upfront fees, tokens or some\n>     other mechanism).\n>   * Routing nodes have no way of knowing whether a payment comes from\n>     a node that is not upgraded, or simply doesn't want to pay the\n>     additional cost introduced by a jamming mitigation.\n>\n> It was generally agreed that the network is still in an early enough\n> stage that it is fair for relaying nodes to initially upgrade but not\n> enforce the feature, and later look at forwarding traffic to determine\n> whether it is appropriate to require the feature. This will require\n> sending nodes to opt-in to the new feature before the network can\n> widely enforce it, as no rational routing node will require a feature\n> which would reduce its ability to serve un-upgraded traffic (unless\n> under attack, which is not the case at present).\n>\n> A note was also made that wallets tend to upgrade less frequently, in\n> part because some providers run forked versions of LN implementations,\n> so this horizon may be quite long. It was emphasized that this type of\n> network upgrade would require input from wallets, designers and\n> application developers anyway, so hopefully by the time we look to\n> deploy a change there is rough consensus among the Lightning community\n> already.\n>\n> 2. Upfront Fees\n> Next, we discussed the draft proposal for upfront fees [2] that\n> implements the first of a two-part jamming mitigation described in [3].\n> As it stands, the PR describes the simplest possible way to introduce\n> upfront fees to the protocol:\n>   * Upfront fees are expressed as a ppm of a channel's success-case\n>     fees, and charged on the outgoing link of a route.\n>   * Nodes can advertise custom upfront fee rates if desired, but to\n>     save gossip bandwidth we assume a network-wide default of 1%.\n>   * Upfront fees accumulate along the route (as htlc payment amounts\n>     do), and are simply pushed to the `to_remote` balance on\n>     `update_add_htlc`.\n>   * Final hop nodes advertise an upfront fee policy in bolt 11 invoices\n>     (or bolt 12 blinded routes) which is sufficiently padded to\n>     obfuscate their location in the route.\n>\n> The interaction between upfront fees and possible future protocol\n> changes such as inbound fees and negative fees was briefly discussed,\n> specifically the case where a node sets low (or negative) fees to\n> attract traffic then fails payments to accumulate upfront fees. As is,\n> all implementations\u2019 algorithms optimize for factors other than fees -\n> specifically avoiding a node once it's produced failures - and we\n> suspect that careful sender-side behavior will mitigate this risk.\n> However, it was also acknowledged that a node that attempts this attack\n> may be able to fool multiple individual senders and still be able to\n> accumulate some fees.\n>\n> We then discussed the shortcomings of the \"simplest possible\" upfront\n> fees in [2], specifically focused on the following scenario where\n> nodes receive 1% of their success-case fees as an upfront payment:\n>   * Alice is sending a payment to Dave, who is a popular sink node in\n>     the network.\n>   * Bob -> Carol has low/default routing policy: 1000 msat success\n>     case / 10 msat upfront fee\n>   * Carol -> Dave has high fees: 400,000 msat success case / 4000 msat\n>     upfront fee\n>   * Dave advertises no success case fee (is recipient) / 100 msat of\n>     upfront fee chosen for his invoice.\n>\n> Alice ------ Bob ------ Carol ------ Dave\n>\n> Since we need to source all of these funds from the sender (Alice), the\n> forwarding of funds is as follows:\n>   * Alice pushes 4110 msat to Bob.\n>   * Bob _should_ push 4100 msat to Carol, claiming his 10 msat upfront\n>     fee.\n>   * Carol _should_ push 100 msat to Dave, claiming her 4000 msat\n>     upfront fee.\n>\n> However, Bob has no real incentive to forward the HTLC to Carol and\n> push her the 4100 msat because that value is more than the fees he'll\n> earn from successfully forwarding and settling the HTLC (10 msat\n> upfront fees + 1000 msat success case fees). It's worth noting that\n> this type of fee differential already exists in the network today - I\n> got these example numbers by looking at the fee rates of the Loop\n> node's peers [4].\n>\n> There were a few points discussed around this issue:\n>   * Whether we should look into a more complicated approach that\n>     includes a \"proof of forward\" secret in the next node's onion which\n>     must be supplied to claim the upfront fee.\n>   * Discussion about whether these order of magnitude fee differences\n>     will exist in an efficient market (differing opinions).\n>   * Whether Bob _would_ steal the upfront fee by dropping the payment,\n>     as it'll impact nodes' desire to route through them in future.\n>   * Is there a way to deliver upfront fees to nodes along the route\n>     *without* them adding up along the route (other than the naive\n>     version of sending each hop a payment, which comes with its own\n>     problems)? Seems not, but bright ideas are wanted and welcome!\n>   * That nodes will decide where they fall in the trade-off of setting\n>     upfront fees to cover their opportunity cost for high routing fees\n>     and market pressure to keep these fees low for the sake of\n>     remaining competitive.\n>\n> A few people mentioned the desire to keep an upfront fee solution as\n> simple as possible, but generally it seemed that a solution where the\n> accumulated upfront fees at any point along a route exceed any single\n> hop's expected success case fees is unacceptable because incentives\n> are misaligned (even if we can properly attribute errors with [5]).\n>\n> We touched briefly on a few \"proof of forwarding\" solutions for\n> upfront fees:\n>   * Using a locking mechanism that relies on a secret that is provided\n>     by the next node's onion.\n>   * A taproot tree for all HTLCs where each leaf has a subset of HTLCs,\n>     and fees could be incorporated here (summary note: apparently some\n>     work has been done here, but I couldn't find the link).\n>   * If we're confident that a more complicated solution will solve many\n>     problems, then we should pursue them, otherwise a simple solution\n>     is possibly a _good enough_ first step.\n>\n> There was some discussion about how we want to go about addressing\n> spamming in the network:\n>   * Is it good enough to deploy something today that just charges a\n>     simple, capped upfront fee (eg 1 sat per hop) that solves jamming\n>     for the current state of the network and allows us to learn\n>     something then iterate?\n>   * Should our first attempt at solving this issue be for a future\n>     steady state where nodes have significant traffic and nodes face\n>     real opportunity cost (in the form of lost revenue) if they are\n>     targeted by a jamming attack?\n>\n> 3. Circuit Breaker Update\n>   * Circuit breaker has a UI now, and some issues are being opened in\n>     the repo so people have at minimum gone through the effort to spin\n>     it up.\n>   * It's still pretty manual, but it does provide node operators with\n>     information about the payment failures on their nodes (not easily\n>     surfaced in many LN UIs).\n>   * Hoping to get insights into stuck HTLCs and spam HTLCs so that we\n>     can learn from real life experience.\n>   * Circuit breaker is generally pushing in the same direction as the\n>     reputation scheme in [3], just a more manual one. We could\n>     possibly use it to visualize the endorsement system in [3] before\n>     enforcing it.\n>   * While circuit breaker isn't necessarily *the* solution to solving\n>     jamming on LN, it provides us with some data points and a\n>     practical way for individual operators to address spamming of\n>     their nodes.\n>\n> 3. Tokens Update\n> Since our last discussion an architecture document was added to the\n> proposal [6], details in the mailing list post [7]. The main goal is\n> to try to dissociate the people paying the fees from those gaining the\n> benefits from the credentials, so that credentials can be paid by a\n> LSP (for example).\n>\n> 4. Reputation discussions in LSP Specification\n> Some attendees have been working on a reputation system for the LSP\n> specification group [8]. This system is intended to provide standard\n> metrics about what makes a node good/bad to connect to in the context\n> of a decentralized marketplace. While this work looks at the problem\n> from a different perspective, there's a possibility to consolidate\n> the efforts. It seems particularly useful in the anti-jamming case\n> where a node has newly connected to you, and needs a \"start state\"\n> reputation score. The idea of defining what qualifies as good\n> behavior in the Lightning Network is useful across the board. The\n> LSP specification group also has bi-weekly calls, and welcomes\n> additional participants!\n>\n> 5. Call Cadence\n> Attendees agreed to continue with calls every two weeks. General\n> consensus was that we would aim for a 30 minute meeting with the\n> option to extend to an hour if discussion warrants it.\n>\n> # What's next\n> Thanks to everyone who attended last week's meeting, we hope to see\n> more folks in the next one!\n>\n> There's a lot to discuss - brave readers who made it all the way to\n> the bottom of this email will notice a fair number of question marks\n> scattered about - and we're going to continue to break the problem\n> down into smaller parts to discuss in the hope of making progress.\n>\n> Any change to the Lightning Network that aims to address channel\n> jamming attacks will be a significant (but necessary) change to the\n> protocol, and it's going to need input from many different\n> stakeholders. Please reach out here or in private\n> (carla at chaincode.com / clara at chaincode.com) if you have any questions\n> / concerns / comments!\n>\n> Cheers until next time,\n> Carla and Clara\n> (Yes, our names are confusing. No, you won't get used to it)\n>\n> [1]\n> https://github.com/ClaraShk/LNJamming/blob/main/meeting-transcripts/23-01-23-transcript.md\n> [2] https://github.com/lightning/bolts/pull/1052\n> [3] https://eprint.iacr.org/2022/1454.pdf\n> [4]\n> https://mempool.space/lightning/node/021c97a90a411ff2b10dc2a8e32de2f29d2fa49d41bfbb52bd416e460db0747d0d\n> [5] https://github.com/lightning/bolts/pull/1044\n> [6] https://github.com/lightning/bolts/pull/1043\n> [8] https://github.com/BitcoinAndLightningLayerSpecs/lsp/issues/12\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20230131/e171e031/attachment-0001.html>", "summary": "The Lightning Network faces challenges with upfront fees, including the risk of theft and adding up along the route, but potential solutions are being explored."}], "thread_summary": {"title": "Jamming Mitigation Call Summary - 01/23", "categories": ["Lightning-dev"], "authors": ["Carla Kirk-Cohen", "Antoine Riard"], "messages_count": 4, "total_messages_chars_count": 79403, "convo_summary": "The Lightning Network community discussed upgrading mechanisms and upfront fees to mitigate channel jamming during their fortnightly calls. Upgrading the network may require network-wide cooperation, but incentivizing nodes to upgrade and addressing privacy concerns may be challenging. The network also faces challenges with upfront fees, but potential solutions are being explored."}}]